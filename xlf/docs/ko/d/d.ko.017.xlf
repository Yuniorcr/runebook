<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="eda17044e9450b32ce8d657d8c476e2e931877a8" translate="yes" xml:space="preserve">
          <source>Check an entire XML document for well-formedness</source>
          <target state="translated">전체 XML 문서가 올바른지 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="d970e5fd0eca0560f8d7376c859148711be4729a" translate="yes" xml:space="preserve">
          <source>Check for special enum names.</source>
          <target state="translated">특수 열거 형 이름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2d3f64068fd53c1e2cf2c76775f8f8fabfefbbfd" translate="yes" xml:space="preserve">
          <source>Check for unsafe access in @safe code: 1. read overlapped pointers 2. write misaligned pointers 3. write overlapped storage classes Print error if unsafe.</source>
          <target state="translated">@safe 코드에서 안전하지 않은 액세스를 확인하십시오. 1. 겹친 포인터 읽기 2. 잘못 정렬 된 포인터 쓰기 3. 겹친 스토리지 클래스 쓰기 안전하지 않은 경우 오류를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="7c0bee715813745db32b38bbccf3a069246cf610" translate="yes" xml:space="preserve">
          <source>Check given aggregate actually has an identity opAssign or not.</source>
          <target state="translated">주어진 집계에 실제로 opAssign ID가 있는지 여부를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3858f175449bae14406b7154904a8462b908a3ad" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;this&lt;/code&gt; is in the null state.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 널 (null) 상태 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="076573205d4206fc69ab2dc4fcc4e09a0f119e4b" translate="yes" xml:space="preserve">
          <source>Check if a symbol is visible from a given scope without taking into account the most visible overload.</source>
          <target state="translated">가장 눈에 띄는 과부하를 고려하지 않고 주어진 범위에서 기호가 보이는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="62479c6f09569fa4521b5d1a5251de698f6fa595" translate="yes" xml:space="preserve">
          <source>Check if an &lt;code&gt;alias this&lt;/code&gt; is deprecated</source>
          <target state="translated">있는지 확인 &lt;code&gt;alias this&lt;/code&gt; 되지 않습니다</target>
        </trans-unit>
        <trans-unit id="2bab44045df4b9981599697a77f678e9b3ebdf8e" translate="yes" xml:space="preserve">
          <source>Check if any elements exist in the container. Returns &lt;code&gt;false&lt;/code&gt; if at least one element exists.</source>
          <target state="translated">컨테이너에 요소가 있는지 확인하십시오. 하나 이상의 요소가 존재하면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0eee93ccff6c0e0b4aa6087370d984e43f3308e9" translate="yes" xml:space="preserve">
          <source>Check if the file the &lt;code&gt;path&lt;/code&gt; points to exists</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가리키는 파일이 존재 하는지 확인</target>
        </trans-unit>
        <trans-unit id="7ac10cbe580bb712b906c15722c15b6e0026c3e6" translate="yes" xml:space="preserve">
          <source>Check if the function &lt;code&gt;F&lt;/code&gt; is calleable in a &lt;code&gt;nothrow&lt;/code&gt; scope.</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; 범위 에서 함수 &lt;code&gt;F&lt;/code&gt; 를 호출 할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="64f568a0788eaf3c104e4f61c0874d4d74f59f4e" translate="yes" xml:space="preserve">
          <source>Check if the last template parameter is a tuple one, and returns it if so, else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">마지막 템플릿 매개 변수가 튜플인지 확인한 다음 반환하면 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="188659108f60184522d74ac9e6ab3f12baec9896" translate="yes" xml:space="preserve">
          <source>Check if the type &lt;code&gt;T&lt;/code&gt;'s postblit is called in nothrow, if it exist</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 의 포스트 블릿이 존재하지 않는 경우, nothrow로 호출되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="af7a4c6a5c2ba8859b2cd5a292e2e803c480f264" translate="yes" xml:space="preserve">
          <source>Check parameters and return type of D main() function. Issue error messages.</source>
          <target state="translated">D main () 함수의 매개 변수 및 반환 유형을 확인하십시오. 오류 메시지를 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="44068e2d631fa41db726b0ad86a2506b1696fdd4" translate="yes" xml:space="preserve">
          <source>Check struct constructor of the form &lt;code&gt;s.this(args)&lt;/code&gt;, by checking each &lt;code&gt;return&lt;/code&gt; parameter to see if it gets assigned to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;return&lt;/code&gt; 매개 변수가 &lt;code&gt;s&lt;/code&gt; 에 할당되어 있는지 확인 하여 &lt;code&gt;s.this(args)&lt;/code&gt; 형식의 구조체 생성자를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9ca07e85195a45175df8f93c70295e0d597f076" translate="yes" xml:space="preserve">
          <source>Check that an email address conforms to RFCs 5321, 5322 and others.</source>
          <target state="translated">이메일 주소가 RFC 5321, 5322 및 기타 사항을 준수하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="96a4caea4b58f9a696a9fa2d9139cbc448939376" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid type. If not, generates an error &quot;... has no type&quot;.</source>
          <target state="translated">표현식에 유효한 유형이 있는지 확인하십시오. 그렇지 않으면 &quot;... 유형 없음&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="72c3f1230ce767eb6fa0da10917246e5895c0d26" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid value. If not, generates an error &quot;... has no value&quot;.</source>
          <target state="translated">표현식에 유효한 값이 있는지 확인하십시오. 그렇지 않으면 &quot;... 값이 없습니다&quot;라는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dcdeb8730ffac94e46f7144e685915d89bb60d12" translate="yes" xml:space="preserve">
          <source>Check that the function contains any closure. If it's @nogc, report suitable errors. This is mostly consistent with FuncDeclaration::needsClosure().</source>
          <target state="translated">함수에 클로저가 포함되어 있는지 확인하십시오. @nogc이면 적절한 오류를보고하십시오. 이것은 대부분 FuncDeclaration :: needsClosure ()와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a439ace69e6b39c914e8a0f30a7839c881b0b42e" translate="yes" xml:space="preserve">
          <source>Check that the postblit is callable if t is an array of structs. Returns true if error happens.</source>
          <target state="translated">t가 구조체의 배열 인 경우 포스트 블릿이 호출 가능한지 확인하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a636a07f4f3d9c05ce29614c151925a9aeb57b2d" translate="yes" xml:space="preserve">
          <source>Check that there are no uses of arrays without [].</source>
          <target state="translated">[]없이 배열을 사용하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0af7c63ae853953456799e62f8dd988319b13c2e" translate="yes" xml:space="preserve">
          <source>Check that this function type is properly resolved. If not, report &quot;forward reference error&quot; and return true.</source>
          <target state="translated">이 기능 유형이 올바르게 해결되었는지 확인하십시오. 그렇지 않은 경우 &quot;정방향 참조 오류&quot;를보고하고 true를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="dc26a5cb1e94e18dd7bae9c48ba4424f2687029b" translate="yes" xml:space="preserve">
          <source>Check to see if constraint is satisfied.</source>
          <target state="translated">제한 조건이 만족되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2e9e70f18c437515a642e7710d6acf41c2b8a612" translate="yes" xml:space="preserve">
          <source>Check to see if declaration can be modified in this context (sc). Issue error if not.</source>
          <target state="translated">이 컨텍스트에서 선언을 수정할 수 있는지 확인하십시오 (sc). 그렇지 않으면 오류를 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="51115eb7becb93e1ed9565c740be9cbe2b13d39d" translate="yes" xml:space="preserve">
          <source>Check to see if this variable is actually in an enclosing function rather than the current one. Returns true if error occurs.</source>
          <target state="translated">이 변수가 실제로 현재 변수가 아닌 엔 클로징 함수에 있는지 확인하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c9e9e80b6fb0bcd2c2078fcf4d43cd2c78a6fad0" translate="yes" xml:space="preserve">
          <source>Check to see the aggregate type is nested and its context pointer is accessible from the current scope. Returns true if error occurs.</source>
          <target state="translated">집계 유형이 중첩되어 있고 현재 범위에서 컨텍스트 포인터에 액세스 할 수 있는지 확인하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4f9c3759a0e90a57282f3d4825c0a253d6bfa729" translate="yes" xml:space="preserve">
          <source>Check type to see if it is based on a deprecated symbol.</source>
          <target state="translated">더 이상 사용되지 않는 기호를 기반으로하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3bebff7bd9c6f992a862c3947845278a778590d5" translate="yes" xml:space="preserve">
          <source>Check whether a number is an integer power of two.</source>
          <target state="translated">숫자가 2의 정수 제곱인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="68ee613e321cfb260a31b167d7e8362d6611b9ba" translate="yes" xml:space="preserve">
          <source>Check whether a thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createLowLevelThread&lt;/code&gt; 에 의해 스레드가 작성되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="81773160380ee69dcc483492366b6c611e0a1eed" translate="yes" xml:space="preserve">
          <source>Check whether symbols &lt;code&gt;s&lt;/code&gt; is visible in &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 에서 기호 &lt;code&gt;s&lt;/code&gt; 가 표시 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="16a4ea9c15d653616cd1ab89eeb1d07e1733ed47" translate="yes" xml:space="preserve">
          <source>Check whether the expression allows RMW operations, error with rmw operator diagnostic if not. ex is the RHS expression, or NULL if ++/-- is used (for diagnostics) Returns true if error occurs.</source>
          <target state="translated">표현식이 RMW 조작을 허용하는지, 그렇지 않은 경우 rmw 운영자 진단 오류를 점검하십시오. ex는 RHS식이거나 ++ /-가 사용되는 경우 NULL입니다 (진단의 경우) 오류가 발생하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3f04bc3752d2690dd0208e77754d66e24067224" translate="yes" xml:space="preserve">
          <source>Check whether the given Unicode code point is valid.</source>
          <target state="translated">지정된 유니 코드 코드 포인트가 유효한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="967bb865d76cb5dec46effc4ddf3db69dd7bd8b3" translate="yes" xml:space="preserve">
          <source>Check whether the tuple &lt;code&gt;T&lt;/code&gt; is a type tuple. A type tuple only contains types.</source>
          <target state="translated">튜플 &lt;code&gt;T&lt;/code&gt; 가 타입 튜플 인지 확인하십시오 . 유형 튜플에는 유형 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b123f344913046043c7f94d2d9417280390123" translate="yes" xml:space="preserve">
          <source>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions.</source>
          <target state="translated">튜플 T가 표현식 튜플인지 확인하십시오. 표현식 튜플에는 표현식 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5374967cf17045f818df69f4c4da8c46fb272364" translate="yes" xml:space="preserve">
          <source>Check whether the type t representation relies on one or more the template parameters.</source>
          <target state="translated">유형 t 표현이 하나 이상의 템플릿 매개 변수에 의존하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a81260a4f45c118b1ea3d76244c3549c2710e64e" translate="yes" xml:space="preserve">
          <source>CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</source>
          <target state="translated">CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ad7d1dc4c316626ec88560f3cf3f5028c21c54" translate="yes" xml:space="preserve">
          <source>CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt;;</source>
          <target state="translated">CheckException &lt;strong id=&quot;err&quot;&gt;오류&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="102c409f892dccfa7ef03ae04285bb95f236e32f" translate="yes" xml:space="preserve">
          <source>CheckException if the document is not well formed  CheckException's toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</source>
          <target state="translated">문서가 제대로 구성되지 않은 경우 CheckException CheckException의 toString () 메소드는 구문 분석 실패의 전체 계층 구조 (스택 추적에 해당하는 XML)를 생성하여 모든 레벨에서 모든 실패의 행 및 열 번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bada63007fff0aeaf5219e5a4263f3c5062820f1" translate="yes" xml:space="preserve">
          <source>Checked integral type wraps an integral &lt;code&gt;T&lt;/code&gt; and customizes its behavior with the help of a &lt;code&gt;Hook&lt;/code&gt; type. The type wrapped must be one of the predefined integrals (unqualified), or another instance of &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">검사 된 정수 유형은 정수 &lt;code&gt;T&lt;/code&gt; 를 감싸고 &lt;code&gt;Hook&lt;/code&gt; 유형을 사용하여 동작을 사용자 정의 합니다. 랩핑 된 유형은 사전 정의 된 적분 (한정되지 않음) 중 하나이거나 &lt;code&gt;Checked&lt;/code&gt; 의 다른 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b9f346ef13e859da0e17906bab43906e87f9f1a9" translate="yes" xml:space="preserve">
          <source>Checked integral types.</source>
          <target state="translated">적분 유형을 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="3d046d9a56e84f129ac9c3b934c854cf8cc1eede" translate="yes" xml:space="preserve">
          <source>Checked!(T, Hook) &lt;strong id=&quot;checked&quot;&gt;checked&lt;/strong&gt;(Hook = Abort, T)(const T value)</source>
          <target state="translated">Checked! (T, Hook) &lt;strong id=&quot;checked&quot;&gt;점검&lt;/strong&gt; (Hook = Abort, T) (const T value)</target>
        </trans-unit>
        <trans-unit id="3a56e907097859f145f7eb967d0d6aafc8e25d7a" translate="yes" xml:space="preserve">
          <source>Checked!(T, WithNaN) &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">확인했습니다! (T, WithNaN) &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">데이터베이스 검사 점</target>
        </trans-unit>
        <trans-unit id="d455be643c887ed2e33c7fa95c88c9c55b8bf01c" translate="yes" xml:space="preserve">
          <source>Checks are being emitted for &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s</source>
          <target state="translated">점검을 위해 방출되는 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="7ae407b40a2f1ca0a962e37bda159883f242864f" translate="yes" xml:space="preserve">
          <source>Checks for UDAs on the aggregate symbol itself</source>
          <target state="translated">집계 기호 자체에서 UDA를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="91354966f9286424721ec9c11117e66f02deb883" translate="yes" xml:space="preserve">
          <source>Checks for equality between this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; and the given &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 과 지정된 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 사이의 동등성을 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="41f80afca0aca27fb1227fb2783c707494f14534" translate="yes" xml:space="preserve">
          <source>Checks for mismatching modifiers between &lt;code&gt;lhsMod&lt;/code&gt; and &lt;code&gt;rhsMod&lt;/code&gt; and prints the mismatching modifiers to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhsMod&lt;/code&gt; 와 &lt;code&gt;rhsMod&lt;/code&gt; 사이의 불일치 수정자를 확인하고 불일치 수정자를 &lt;code&gt;buf&lt;/code&gt; 로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="b1c54b7f70f2d7dcba8602a7148aa409d68cfd95" translate="yes" xml:space="preserve">
          <source>Checks for the existence of a package.d to set isPkgMod appropriately if isPkgMod == PKG.unknown</source>
          <target state="translated">isPkgMod == PKG.unknown 인 경우 isPkgMod를 적절히 설정하기 위해 package.d가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="93f909b0c91d05388ffc9701f547779940f4af50" translate="yes" xml:space="preserve">
          <source>Checks if</source>
          <target state="translated">여부를 확인</target>
        </trans-unit>
        <trans-unit id="fc3b0d143e6cc80d04881cd701b750744c2dc00b" translate="yes" xml:space="preserve">
          <source>Checks if a value is among a set of values, e.g. &lt;code&gt;if (v.among(1, 2, 3)) // &lt;/code&gt;v&lt;code&gt; is 1, 2 or 3&lt;/code&gt;</source>
          <target state="translated">값이 값 집합 중 하나인지 확인합니다 &lt;code&gt;if (v.among(1, 2, 3)) // &lt;/code&gt; 예 : (v.among (1, 2, 3)) // v &lt;code&gt; is 1, 2 or 3&lt;/code&gt; 임).</target>
        </trans-unit>
        <trans-unit id="5c267ca37e5703f72794d1240b1acbb9cca14995" translate="yes" xml:space="preserve">
          <source>Checks if an &lt;a href=&quot;#AliasSeq&quot;&gt;&lt;code&gt;AliasSeq&lt;/code&gt;&lt;/a&gt; is sorted according to &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AliasSeq&quot;&gt; &lt;code&gt;AliasSeq&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;cmp&lt;/code&gt; 에 따라 정렬 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="73214c70371a5d58586ec872bc8be088ccd2fe8d" translate="yes" xml:space="preserve">
          <source>Checks if both ranges are permutations of each other.</source>
          <target state="translated">두 범위가 서로 순열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f3bc0ac6ddb23e50ce7a6b35ff0d100ba52bb65c" translate="yes" xml:space="preserve">
          <source>Checks if pkg is a sub-package of this</source>
          <target state="translated">pkg가이 패키지의 하위 패키지인지 확인</target>
        </trans-unit>
        <trans-unit id="de380b72169766e3bc2056b6702adc831654ea3d" translate="yes" xml:space="preserve">
          <source>Checks if the final segments of two arrays refer to the same place in memory.</source>
          <target state="translated">두 배열의 마지막 세그먼트가 메모리에서 동일한 위치를 참조하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="922c914c67ac4f89ae28a039917cecb568914ebf" translate="yes" xml:space="preserve">
          <source>Checks if the given range ends with (one of) the given needle(s). The reciprocal of &lt;code&gt;startsWith&lt;/code&gt;.</source>
          <target state="translated">주어진 범위가 주어진 바늘 (들) 중 하나로 끝나는 지 확인합니다. &lt;code&gt;startsWith&lt;/code&gt; 의 역수 .</target>
        </trans-unit>
        <trans-unit id="82ecdaae8fa51f0373d5c72994edf3db1fb3d193" translate="yes" xml:space="preserve">
          <source>Checks if the initial segments of two arrays refer to the same place in memory.</source>
          <target state="translated">두 배열의 초기 세그먼트가 메모리에서 동일한 위치를 참조하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="82f5a929497edacf0f834d2b14872945ce21c9e0" translate="yes" xml:space="preserve">
          <source>Checks if the two ranges have the same number of elements. This function is optimized to always take advantage of the &lt;code&gt;length&lt;/code&gt; member of either range if it exists.</source>
          <target state="translated">두 범위에 동일한 개수의 요소가 있는지 확인합니다. 이 함수는 &lt;code&gt;length&lt;/code&gt; 범위 멤버가 존재하는 경우 항상 사용하도록 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="062799729dfffce6238995dbd50b05d58dc3f7e8" translate="yes" xml:space="preserve">
          <source>Checks that the given file or directory name is valid.</source>
          <target state="translated">주어진 파일 또는 디렉토리 이름이 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d27c0f548abb76a4596a54ad7418e7f7fc762d7c" translate="yes" xml:space="preserve">
          <source>Checks to see if &lt;code&gt;str&lt;/code&gt; is well-formed unicode or not.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 올바른 형식의 유니 코드인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f34bde45b70b49a2f480574578c1aa032b15dc5b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;os&lt;/code&gt; is the current &lt;a href=&quot;#TargetOS&quot;&gt;&lt;code&gt;TargetOS&lt;/code&gt;&lt;/a&gt;. For &lt;code&gt;TargetOS.all&lt;/code&gt; it will always return true.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; 가 현재 &lt;a href=&quot;#TargetOS&quot;&gt; &lt;code&gt;TargetOS&lt;/code&gt; &lt;/a&gt; 인지 확인합니다 . 들어 &lt;code&gt;TargetOS.all&lt;/code&gt; 항상 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="c8b948df59e14c40567ac47254a4d5c81976e17a" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;path&lt;/code&gt; is a valid path.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 유효한 경로 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dfec60ca2a2292ac998b0be0f2e72d965e16f264" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;r&lt;/code&gt; has &quot;balanced parentheses&quot;, i.e. all instances of &lt;code&gt;lPar&lt;/code&gt; are closed by corresponding instances of &lt;code&gt;rPar&lt;/code&gt;. The parameter &lt;code&gt;maxNestingLevel&lt;/code&gt; controls the nesting level allowed. The most common uses are the default or &lt;code&gt;0&lt;/code&gt;. In the latter case, no nesting is allowed.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 에 &quot;균형 괄호&quot;가 있는지 확인합니다 . 즉, &lt;code&gt;lPar&lt;/code&gt; 의 모든 인스턴스 가 해당 &lt;code&gt;rPar&lt;/code&gt; 의 인스턴스에 의해 닫힙니다 . &lt;code&gt;maxNestingLevel&lt;/code&gt; 매개 변수 는 허용되는 중첩 레벨을 제어합니다. 가장 일반적인 용도는 기본값 또는 &lt;code&gt;0&lt;/code&gt; 입니다. 후자의 경우 중첩이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77f07080dfad28c7957c689895a88f5ad1226a0f" translate="yes" xml:space="preserve">
          <source>Checks whether a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; is sorted according to the comparison operation &lt;code&gt;less&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;) evaluations of &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">순차 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;범위&lt;/a&gt; 가 비교 연산 &lt;code&gt;less&lt;/code&gt; 에 따라 정렬 되는지 여부를 확인합니다 . 수행합니다 &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; )의 평가 &lt;code&gt;less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17bdba71f684446d0078a53b44634a2483390259" translate="yes" xml:space="preserve">
          <source>Checks whether a function has the given attributes attached.</source>
          <target state="translated">함수에 주어진 속성이 첨부되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0f264f7871383b6deeb7f79fa3f8bb65dab34fc2" translate="yes" xml:space="preserve">
          <source>Checks whether a given source object contains pointers or references to a given target object.</source>
          <target state="translated">지정된 소스 객체에 지정된 대상 객체에 대한 포인터 또는 참조가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="90ef69351101a70d883b1cc5e529cfe98f43fdde" translate="yes" xml:space="preserve">
          <source>Checks whether the allocator is responsible for the allocation of &lt;code&gt;b&lt;/code&gt;. It does a simple &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) range check. &lt;code&gt;b&lt;/code&gt; should be a buffer either allocated with &lt;code&gt;this&lt;/code&gt; or obtained through other means.</source>
          <target state="translated">할당자가 &lt;code&gt;b&lt;/code&gt; 할당을 담당하는지 여부를 확인합니다 . 간단한 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 범위 확인을 수행합니다. &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;this&lt;/code&gt; 과 함께 할당 되거나 다른 수단을 통해 얻은 버퍼 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="54585d85d511f32526e9e2026456069b0e4b7e33" translate="yes" xml:space="preserve">
          <source>Checks whether the digest has a &lt;code&gt;blockSize&lt;/code&gt; member, which contains the digest's internal block size in bits. It is primarily used by &lt;a href=&quot;std_digest_hmac#HMAC&quot;&gt;&lt;code&gt;std.digest.hmac.HMAC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다이제스트에 다이제스트의 내부 블록 크기를 비트 단위로 포함 하는 &lt;code&gt;blockSize&lt;/code&gt; 멤버 가 있는지 확인합니다 . 주로 &lt;a href=&quot;std_digest_hmac#HMAC&quot;&gt; &lt;code&gt;std.digest.hmac.HMAC&lt;/code&gt; 에&lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="596a607c7dae9e909d8aa4bbcb358bbecdcb85a4" translate="yes" xml:space="preserve">
          <source>Checks whether the given &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; starts with (one of) the given needle(s) or, if no needles are given, if its front element fulfils predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 가 주어진 바늘 (들) 중 하나로 시작 하는지, 또는 바늘이 제공되지 않은 경우, 앞 요소가 술어 &lt;code&gt;pred&lt;/code&gt; 를 충족하는지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="efccb1331db4295c7feab2a66a6d3d82d986e9c3" translate="yes" xml:space="preserve">
          <source>Checks whether the target supports a vector type.</source>
          <target state="translated">대상이 벡터 유형을 지원하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a42d0788409e166459e51db8b3218d5314bd1d1f" translate="yes" xml:space="preserve">
          <source>Checks whether the target supports the given operation for vectors.</source>
          <target state="translated">대상이 벡터에 대해 지정된 연산을 지원하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="442e16f850c6d48d620dd486822aeb8ada3b125a" translate="yes" xml:space="preserve">
          <source>Checks whether type is a vendor-specific fundamental type.</source>
          <target state="translated">유형이 공급 업체별 기본 유형인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6927568c692c1534ead0f5a190223a7149662ac5" translate="yes" xml:space="preserve">
          <source>Cherokee</source>
          <target state="translated">Cherokee</target>
        </trans-unit>
        <trans-unit id="5b29ec40fe722116395b446baa3ca821a172b9e2" translate="yes" xml:space="preserve">
          <source>Choose one of multiple ranges at runtime.</source>
          <target state="translated">런타임시 여러 범위 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0bffc7533a173c7dee535e7316e44257ed38a803" translate="yes" xml:space="preserve">
          <source>Choose one of two ranges at runtime depending on a Boolean condition.</source>
          <target state="translated">부울 조건에 따라 런타임시 두 범위 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5544515d81b65f896e82120e57ec6fa91d774f56" translate="yes" xml:space="preserve">
          <source>Chooses all &lt;code&gt;byteXxx&lt;/code&gt; flags.</source>
          <target state="translated">모든 &lt;code&gt;byteXxx&lt;/code&gt; 플래그를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="6438169cea15a58e629d9074302588f2e1950054" translate="yes" xml:space="preserve">
          <source>Chooses all &lt;code&gt;numXxx&lt;/code&gt; flags.</source>
          <target state="translated">모든 &lt;code&gt;numXxx&lt;/code&gt; 플래그를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="c672631dbe7d09bcec68adc7f3844fea3aee543f" translate="yes" xml:space="preserve">
          <source>Chooses one of several ranges at runtime based on an index.</source>
          <target state="translated">인덱스를 기반으로 런타임에 여러 범위 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4155ddaaa02a43e8c79a78caa5873e37eb151cb9" translate="yes" xml:space="preserve">
          <source>Chooses one of two ranges at runtime based on a boolean condition.</source>
          <target state="translated">부울 조건에 따라 런타임시 두 범위 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="664b0f4761a82a8eae267ec54d633d690bb844d2" translate="yes" xml:space="preserve">
          <source>Choosing &lt;code&gt;stackSize&lt;/code&gt; is as always a compromise. Too small a size exhausts the stack storage after a few allocations, after which there are no gains over the backup allocator. Too large a size increases the stack consumed by the thread and may end up worse off because it explores cold portions of the stack.</source>
          <target state="translated">&lt;code&gt;stackSize&lt;/code&gt; 를 선택 하는 것은 언제나 절충안입니다. 크기가 너무 작 으면 몇 번의 할당 후에 스택 스토리지가 소진되고, 그 후에 백업 할당 자에 비해 이득이 없습니다. 크기가 너무 크면 스레드가 소비하는 스택이 증가하고 스택의 차가운 부분을 탐색하기 때문에 더 나빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9814b18eaeb245f343a07d23b55d5cc756f226e" translate="yes" xml:space="preserve">
          <source>Christopher E. Miller, &lt;a href=&quot;http://klickverbot.at&quot;&gt;David Nadlinger&lt;/a&gt;, &lt;a href=&quot;http://thecybershadow.net&quot;&gt;Vladimir Panteleev&lt;/a&gt;</source>
          <target state="translated">크리스토퍼 밀러, &lt;a href=&quot;http://klickverbot.at&quot;&gt;데이비드 나들 링거&lt;/a&gt; , &lt;a href=&quot;http://thecybershadow.net&quot;&gt;블라디미르 판 &lt;/a&gt;텔레 예프</target>
        </trans-unit>
        <trans-unit id="ef1a7c430ea76a914142ae9383408af4814b11d3" translate="yes" xml:space="preserve">
          <source>Chunk size</source>
          <target state="translated">청크 크기</target>
        </trans-unit>
        <trans-unit id="de7daf1e8f3f4e94d6cfd35d20241f9683bce14b" translate="yes" xml:space="preserve">
          <source>Chunks an input range into subranges of equivalent adjacent elements. In other languages this is often called &lt;code&gt;partitionBy&lt;/code&gt;, &lt;code&gt;groupBy&lt;/code&gt; or &lt;code&gt;sliceWhen&lt;/code&gt;.</source>
          <target state="translated">입력 범위를 동등한 인접 요소의 하위 범위로 청크합니다. 다른 언어에서는 이것을 종종 &lt;code&gt;partitionBy&lt;/code&gt; , &lt;code&gt;groupBy&lt;/code&gt; 또는 &lt;code&gt;sliceWhen&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="91ca4cec373000b1433d0ca1c64ba6f2c759ab69" translate="yes" xml:space="preserve">
          <source>Chunks!Source &lt;strong id=&quot;chunks&quot;&gt;chunks&lt;/strong&gt;(Source)(Source source, size_t chunkSize)</source>
          <target state="translated">청크! 소스 &lt;strong id=&quot;chunks&quot;&gt;청크&lt;/strong&gt; (소스) (소스 소스, size_t chunkSize)</target>
        </trans-unit>
        <trans-unit id="f715fee1f757a55e2f3373ac010b13257f33e0d8" translate="yes" xml:space="preserve">
          <source>Clamps a value into the given bounds.</source>
          <target state="translated">주어진 범위로 값을 고정합니다.</target>
        </trans-unit>
        <trans-unit id="8da610fd30240c8f7bfbe322ae9565c89acaafa1" translate="yes" xml:space="preserve">
          <source>Clang Cpp runtime</source>
          <target state="translated">Clang Cpp 런타임</target>
        </trans-unit>
        <trans-unit id="383b1d065b22448681cc3efc5daa12ef6fd55601" translate="yes" xml:space="preserve">
          <source>Class Allocators</source>
          <target state="translated">클래스 할당 자</target>
        </trans-unit>
        <trans-unit id="980dc71fd708724fc917e76399e0f97f54ca4455" translate="yes" xml:space="preserve">
          <source>Class Deallocators</source>
          <target state="translated">클래스 할당 자</target>
        </trans-unit>
        <trans-unit id="e1c46ea1296f65e318f6d1db9386faff86a36090" translate="yes" xml:space="preserve">
          <source>Class Instantiation</source>
          <target state="translated">클래스 인스턴스화</target>
        </trans-unit>
        <trans-unit id="9293e27da3b0684ddaaea3289920ae977e68c4b8" translate="yes" xml:space="preserve">
          <source>Class Invariant</source>
          <target state="translated">클래스 불변</target>
        </trans-unit>
        <trans-unit id="2459ca9a523f95a794bce603404c5263b4256290" translate="yes" xml:space="preserve">
          <source>Class Invariants</source>
          <target state="translated">클래스 불변</target>
        </trans-unit>
        <trans-unit id="1df27dbdacaa899d3c423178002cc7aabfcb82bd" translate="yes" xml:space="preserve">
          <source>Class Object Layout</source>
          <target state="translated">클래스 객체 레이아웃</target>
        </trans-unit>
        <trans-unit id="bce80736a23f07ec5379dd12c4e62a76fe4c9654" translate="yes" xml:space="preserve">
          <source>Class Properties</source>
          <target state="translated">클래스 속성</target>
        </trans-unit>
        <trans-unit id="31462d21de7565b81dba4582baea30b63d17330c" translate="yes" xml:space="preserve">
          <source>Class comparisons</source>
          <target state="translated">수업 비교</target>
        </trans-unit>
        <trans-unit id="004e7955e2bb1bee0b58b1c03a6c08f676e86914" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown by &lt;code&gt;Socket.accept&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Socket.accept&lt;/code&gt; 에 의해 throw되는 예외의 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0dd0234ce9a3827209b58ef80d34ea3eb2ef98d9" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown from an &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; 에서 발생한 예외 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f8cabad72b7cf81c1a9e42e92f24fcecebecdd13" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown from an &lt;code&gt;InternetHost&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InternetHost&lt;/code&gt; 에서 발생하는 예외 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="d5db95106b80e21b18e83bc22b84105ca9ec0f70" translate="yes" xml:space="preserve">
          <source>Class for parsing an XML Document.</source>
          <target state="translated">XML 문서를 구문 분석하기위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fd21b41b841c440b515f1b7977af0ee6dfc40b2f" translate="yes" xml:space="preserve">
          <source>Class for parsing an XML element.</source>
          <target state="translated">XML 요소를 구문 분석하기위한 클래스</target>
        </trans-unit>
        <trans-unit id="a44a999e4ee22e0e38e93a6feafd39bd8662867c" translate="yes" xml:space="preserve">
          <source>Class info, type info, and module info</source>
          <target state="translated">수업 정보, 유형 정보 및 모듈 정보</target>
        </trans-unit>
        <trans-unit id="00e4305e03e0dd23aa189c7dfb11b275650b4811" translate="yes" xml:space="preserve">
          <source>Class interface</source>
          <target state="translated">클래스 인터페이스</target>
        </trans-unit>
        <trans-unit id="d131c8c89307df58eaa35092ddaf0d9ccbded6f4" translate="yes" xml:space="preserve">
          <source>Class invariants are inherited, that is, any class invariant is implicitly in addition to the invariants of its base classes.</source>
          <target state="translated">클래스 불변은 상속됩니다. 즉, 클래스 불변은 기본 클래스의 불변에 추가로 암시 적으로 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f7dd120edececc37360a6e411b5d487475d92f" translate="yes" xml:space="preserve">
          <source>Class members are always accessed with the . operator.</source>
          <target state="translated">클래스 멤버는 항상으로 액세스합니다. 운영자.</target>
        </trans-unit>
        <trans-unit id="90603f7d1f1be2fd75c9f67da4fa9258a7fecd0e" translate="yes" xml:space="preserve">
          <source>Class members are always accessed with the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">클래스 멤버는 항상 &lt;code&gt;.&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="c108e7bd4e33d85ee940d619ea688f67c12f0119" translate="yes" xml:space="preserve">
          <source>Class references are assumed to be allocated using either the GC or are allocated on the stack as &lt;code&gt;scope&lt;/code&gt; classes, and are not tracked.</source>
          <target state="translated">클래스 참조는 GC를 사용하여 할당되거나 &lt;code&gt;scope&lt;/code&gt; 클래스 로 스택에 할당되는 것으로 간주되며 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="370a9bbed207ceee9d084543596997d531d9a330" translate="yes" xml:space="preserve">
          <source>Class references are considered pointers that are subject to &lt;code&gt;scope&lt;/code&gt;.</source>
          <target state="translated">클래스 참조는 &lt;code&gt;scope&lt;/code&gt; 따라 포인터로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="423af25d1c1b0ece97d135bd94f87785f1d1b081" translate="yes" xml:space="preserve">
          <source>Class representing a Character Data section</source>
          <target state="translated">문자 데이터 섹션을 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="af34b125b6fdaf2e164cb16e24345f12dba81970" translate="yes" xml:space="preserve">
          <source>Class representing a Processing Instruction section</source>
          <target state="translated">처리 명령 섹션을 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="f768c4c1669315ae2806f02f66c55aa9730651bb" translate="yes" xml:space="preserve">
          <source>Class representing a comment</source>
          <target state="translated">주석을 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="be60f698a1c1d4833c13a3027790690d573ab935" translate="yes" xml:space="preserve">
          <source>Class representing a text (aka Parsed Character Data) section</source>
          <target state="translated">텍스트 (파싱 된 문자 데이터) 섹션을 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="d71c9bec3d378a3193b92288d2a3d4f39af4d514" translate="yes" xml:space="preserve">
          <source>Class representing an XML Instruction section</source>
          <target state="translated">XML 명령어 섹션을 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="18bdedb4191bb66909c3afbec32afb00a0671f2d" translate="yes" xml:space="preserve">
          <source>Class representing an XML document.</source>
          <target state="translated">XML 문서를 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="b824acd16fc71bc2cc584e5d63675cb399574fdb" translate="yes" xml:space="preserve">
          <source>Class representing an XML element.</source>
          <target state="translated">XML 요소를 나타내는 클래스</target>
        </trans-unit>
        <trans-unit id="2e4077efbfeca1ecea84c2841a1e337531e07230" translate="yes" xml:space="preserve">
          <source>Class representing an XML tag.</source>
          <target state="translated">XML 태그를 나타내는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3eca99d66e1692913774b276a72eb2d9c5a613f4" translate="yes" xml:space="preserve">
          <source>Class that holds an expression in a Dsymbol wraper. This is not an AST node, but a class used to pass an expression as a function parameter of type Dsymbol.</source>
          <target state="translated">Dsymbol wraper에서 표현식을 보유하는 클래스입니다. 이것은 AST 노드가 아니라 Dsymbol 유형의 함수 매개 변수로 식을 전달하는 데 사용되는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fd66f846be164f5572f2b91a4e8cf668edcb8a5f" translate="yes" xml:space="preserve">
          <source>Class that implements the &lt;code&gt;InputRange&lt;/code&gt; interface and wraps the input range methods in virtual functions.</source>
          <target state="translated">&lt;code&gt;InputRange&lt;/code&gt; 인터페이스 를 구현하고 입력 범위 메서드를 가상 함수로 래핑하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="7a5fb94e691e67e69c8178bf66e0bfcda94440d4" translate="yes" xml:space="preserve">
          <source>Class that implements the &lt;code&gt;OutputRange&lt;/code&gt; interface and wraps the &lt;code&gt;put&lt;/code&gt; methods in virtual functions.</source>
          <target state="translated">&lt;code&gt;OutputRange&lt;/code&gt; 인터페이스 를 구현하고 &lt;code&gt;put&lt;/code&gt; 메소드를 가상 함수로 래핑하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="6f02b7cdf3a27dfb668a50be53f3c4a25b5410c5" translate="yes" xml:space="preserve">
          <source>ClassDeclaration</source>
          <target state="translated">ClassDeclaration</target>
        </trans-unit>
        <trans-unit id="e227e5b1defef4ae4a1612e580a4b6e31545ba58" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;code&gt;cd&lt;/code&gt;</source>
          <target state="translated">ClassDeclaration &lt;code&gt;cd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88d2f59bfb7ba6b0443204d9f4aa0913667339b9" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;strong id=&quot;classDeclaration&quot;&gt;classDeclaration&lt;/strong&gt;;</source>
          <target state="translated">ClassDeclaration &lt;strong id=&quot;classDeclaration&quot;&gt;classDeclaration&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="922055dec836bd4265fccad1b410b15255aed28c" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;strong id=&quot;metaclass&quot;&gt;metaclass&lt;/strong&gt;;</source>
          <target state="translated">ClassDeclaration &lt;strong id=&quot;metaclass&quot;&gt;메타 클래스&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ed3cf94875958c0b64c8f17bbe32c5545117a531" translate="yes" xml:space="preserve">
          <source>ClassDeclaration if found, null if not</source>
          <target state="translated">발견되면 ClassDeclaration, 그렇지 않으면 null</target>
        </trans-unit>
        <trans-unit id="0193a1974eb2b77a25fbe296ffc8a9c0fc9032a5" translate="yes" xml:space="preserve">
          <source>ClassInfo &lt;strong id=&quot;getClassInfo&quot;&gt;getClassInfo&lt;/strong&gt;(_Unwind_Exception* exceptionObject, const(ubyte)* currentLsd);</source>
          <target state="translated">ClassInfo &lt;strong id=&quot;getClassInfo&quot;&gt;getClassInfo&lt;/strong&gt; (_Unwind_Exception * exceptionObject, const (ubyte) * currentLsd);</target>
        </trans-unit>
        <trans-unit id="082cd7ff80693ec8dbf6e94d67e626c8eb7acf74" translate="yes" xml:space="preserve">
          <source>ClassInvariant</source>
          <target state="translated">ClassInvariant</target>
        </trans-unit>
        <trans-unit id="931763918b2d001bdeb9a0167eeecd1b1464e45f" translate="yes" xml:space="preserve">
          <source>ClassKind &lt;strong id=&quot;classKind&quot;&gt;classKind&lt;/strong&gt;;</source>
          <target state="translated">ClassKind &lt;strong id=&quot;classKind&quot;&gt;classKind&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="91e40f8e856e33a510bdbf85b94648241eeb6d72" translate="yes" xml:space="preserve">
          <source>ClassTemplateDeclaration</source>
          <target state="translated">ClassTemplateDeclaration</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="88928400c233ae410eba0ed5ea1d5d957388cae0" translate="yes" xml:space="preserve">
          <source>Classes and functions for creating and parsing XML</source>
          <target state="translated">XML 작성 및 구문 분석을위한 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="e64d39090ae91d34137788357a6ca17b0e59eef2" translate="yes" xml:space="preserve">
          <source>Classes and functions for handling and transcoding between various encodings.</source>
          <target state="translated">다양한 인코딩 간의 처리 및 트랜스 코딩을위한 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="94ee5f9cdf031a9bf96906a438e53b06b5e364d3" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate assignments.</source>
          <target state="translated">계급과 노조는 정교하게 임무를 부여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cf9cc918357cc355736633df26f1b2a1c76d306" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate copy constructors.</source>
          <target state="translated">클래스와 공용체에는 정교한 복사 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="531947ccb13d84d3c9d91ba0159960b4ae281773" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate destructors, even though classes may define &lt;code&gt;~this()&lt;/code&gt;.</source>
          <target state="translated">클래스가 &lt;code&gt;~this()&lt;/code&gt; 정의하더라도 클래스와 공용체는 정교한 소멸자를 갖지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="061681876af68eae00bc697b791a9edd12ded2c6" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate move semantics.</source>
          <target state="translated">클래스와 노조는 정교한 움직임 의미를 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b757232012d9216b3c6a4071538b9dc9ae16e888" translate="yes" xml:space="preserve">
          <source>Classes are programmer defined types. Support for classes are what make D an object oriented language, giving it encapsulation, inheritance, and polymorphism. D classes support the single inheritance paradigm, extended by adding support for interfaces. Class objects are instantiated by reference only.</source>
          <target state="translated">클래스는 프로그래머 정의 유형입니다. 클래스 지원은 D를 객체 지향 언어로 만들어 캡슐화, 상속 및 다형성을 제공합니다. D 클래스는 인터페이스 지원을 추가하여 단일 상속 패러다임을 지원합니다. 클래스 객체는 참조 용으로 만 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="64beae7795db165495c04ccd743e7e2188a737f0" translate="yes" xml:space="preserve">
          <source>Classes become abstract if any of its virtual member functions are declared abstract or if they are defined within an abstract attribute. Note that an abstract class may also contain non-virtual member functions.</source>
          <target state="translated">가상 멤버 함수가 abstract로 선언되거나 abstract 속성 내에 정의 된 경우 클래스는 abstract가됩니다. 추상 클래스에는 비가 상 멤버 함수도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13447880a16527416e427574ff84252582f7e516" translate="yes" xml:space="preserve">
          <source>Classes can be used as the</source>
          <target state="translated">수업은</target>
        </trans-unit>
        <trans-unit id="80f7ca9d259d3ef3e97f57bc1d7cca827ec1caa6" translate="yes" xml:space="preserve">
          <source>Classes consist of:</source>
          <target state="translated">수업은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="282ae17a602326eef034194b26fb43aa7fe0fc9d" translate="yes" xml:space="preserve">
          <source>Classes defined within an abstract attribute or with abstract member functions cannot be instantiated directly. They can only be instantiated as a base class of another, non-abstract, class.</source>
          <target state="translated">추상 속성 또는 추상 멤버 함수로 정의 된 클래스는 직접 인스턴스화 할 수 없습니다. 이들은 비 추상적 인 다른 클래스의 기본 클래스로만 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d8e8c29e8bdc647b741d3f95fb6db5ee347a64" translate="yes" xml:space="preserve">
          <source>Classes derived from COM interfaces are COM classes.</source>
          <target state="translated">COM 인터페이스에서 파생 된 클래스는 COM 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bd620604c65cda121c2c3178e92377099e03939c" translate="yes" xml:space="preserve">
          <source>Classes that inherit from an interface may not override final or static interface member functions.</source>
          <target state="translated">인터페이스에서 상속 된 클래스는 최종 또는 정적 인터페이스 멤버 함수를 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d1fce9e58eb73d5ee27c4db7d0cde0cfef20fab" translate="yes" xml:space="preserve">
          <source>Classic Visitor class which implements visit methods for all the AST nodes present in the compiler. The visit methods for AST nodes created at parse time are inherited while the visiting methods for AST nodes created at semantic time are implemented.</source>
          <target state="translated">컴파일러에있는 모든 AST 노드에 대해 방문 메소드를 구현하는 클래식 방문자 클래스입니다. 구문 분석시 생성 된 AST 노드의 방문 방법은 상속되는 반면 시맨틱 시간에 생성 된 AST 노드의 방문 방법은 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ec46bc29fc953e9c5d20d1293a749b2d318b26db" translate="yes" xml:space="preserve">
          <source>Classics</source>
          <target state="translated">Classics</target>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="f7e62460bb760d585edcc42972294b3355a88236" translate="yes" xml:space="preserve">
          <source>Classsym* &lt;strong id=&quot;fake_classsym&quot;&gt;fake_classsym&lt;/strong&gt;(Identifier id);</source>
          <target state="translated">Classsym * &lt;strong id=&quot;fake_classsym&quot;&gt;fake_classsym&lt;/strong&gt; (식별자 ID);</target>
        </trans-unit>
        <trans-unit id="c24c0db0ec6dd19513d073595d928b550d95b320" translate="yes" xml:space="preserve">
          <source>Cleans up and removes a whole multi stack. It does not free or touch any individual easy handles in any way. We need to define in what state those handles will be if this function is called in the middle of a transfer.</source>
          <target state="translated">전체 멀티 스택을 정리하고 제거합니다. 어떤 식 으로든 개별 손쉬운 손잡이를 풀거나 건드리지 않습니다. 이 함수가 전송 도중에 호출되는 경우 해당 핸들의 상태를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="74435379a09fe369f083f9d7cb1588b2c142f5b0" translate="yes" xml:space="preserve">
          <source>Cleans up this ThreadInfo.</source>
          <target state="translated">이 ThreadInfo를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="2978244ea1d5b187c301c21366eda9dedde71b7e" translate="yes" xml:space="preserve">
          <source>Clear a pointer option.</source>
          <target state="translated">포인터 옵션을 지우십시오.</target>
        </trans-unit>
        <trans-unit id="e034f5a3aa872aabba7dcb11d326d687c4332626" translate="yes" xml:space="preserve">
          <source>Clear a pointer option. Does not raise an exception if the underlying libcurl does not support the option. Use sparingly.</source>
          <target state="translated">포인터 옵션을 지우십시오. 기본 libcurl이 옵션을 지원하지 않는 경우 예외를 발생시키지 않습니다. 드물게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d817365eb86e6681481b253301a6c9352b3cc8" translate="yes" xml:space="preserve">
          <source>Clear all commands send to ftp server.</source>
          <target state="translated">ftp 서버로 보내는 모든 명령을 지우십시오.</target>
        </trans-unit>
        <trans-unit id="aabfad8a5b74b09b0c1a45cf20e29c1bc3b34566" translate="yes" xml:space="preserve">
          <source>Clear all cookies.</source>
          <target state="translated">모든 쿠키를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="959b909eeb5ade07f369e65c6d34109729b67e12" translate="yes" xml:space="preserve">
          <source>Clear all outgoing headers.</source>
          <target state="translated">발신 헤더를 모두 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="266e66f0d3d6904b779ec3d759be8309dd9c6a30" translate="yes" xml:space="preserve">
          <source>Clear session cookies.</source>
          <target state="translated">세션 쿠키를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="8fc5d7d65b7fdfd82eecfa31a9a25b3fac8d53e4" translate="yes" xml:space="preserve">
          <source>Clear the data in the buffer</source>
          <target state="translated">버퍼의 데이터를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="aa6bcffd4a89f4241729474f1c06cc264b136f23" translate="yes" xml:space="preserve">
          <source>Clears the TZ environment variable.</source>
          <target state="translated">TZ 환경 변수를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="bf4e8edf5ce7d61a0c02a57350749b31964ea588" translate="yes" xml:space="preserve">
          <source>Clears the heap by detaching it from the underlying store.</source>
          <target state="translated">기본 저장소에서 힙을 분리하여 힙을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="85a1162bfefbbee36bd8acce0b24bc3c4f0d6476" translate="yes" xml:space="preserve">
          <source>Clears the heap. Returns the portion of the store from &lt;code&gt;0&lt;/code&gt; up to &lt;code&gt;length&lt;/code&gt;, which satisfies the &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap property&lt;/a&gt;.</source>
          <target state="translated">힙을 지 웁니다. 저장소의 부분을 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length&lt;/code&gt; 까지 리턴하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;힙 특성&lt;/a&gt; 을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="87154787f8eca1558e3d9985e8d82cb0474f80d3" translate="yes" xml:space="preserve">
          <source>Clears the managed array. This allows the elements of the array to be reused for appending.</source>
          <target state="translated">관리 형 배열을 지 웁니다. 이를 통해 배열의 요소를 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc6960537f814063b8ae6e19a6580b4b9426a39" translate="yes" xml:space="preserve">
          <source>Clears the specified bits for the memory references by p. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, no action will be performed.</source>
          <target state="translated">p로 메모리 참조에 지정된 비트를 지 웁니다. p가이 가비지 수집기에 의해 원래 할당되지 않은 메모리를 참조하는 경우 메모리 블록의 내부를 가리 키거나 p가 null이면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">BLOB 핸들 닫기</target>
        </trans-unit>
        <trans-unit id="c2fcec962038b6d876aef882b5671cadf0a6a473" translate="yes" xml:space="preserve">
          <source>Close similarity with StructDeclaration::buildPostBlit(), and the ordering changes (runs backward instead of forwards).</source>
          <target state="translated">StructDeclaration :: buildPostBlit ()과의 유사성과 순서 변경 (앞으로가 아니라 뒤로 실행)</target>
        </trans-unit>
        <trans-unit id="abc1e6908fffa951befef872f924ffd37a933a94" translate="yes" xml:space="preserve">
          <source>Close_Punctuation</source>
          <target state="translated">Close_Punctuation</target>
        </trans-unit>
        <trans-unit id="111445e87ccfca2b4a774d56d32be272bb8db6b1" translate="yes" xml:space="preserve">
          <source>Closes both ends of the pipe.</source>
          <target state="translated">파이프의 양쪽 끝을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">데이터베이스 연결 닫기</target>
        </trans-unit>
        <trans-unit id="749585ff38f67fad5e857de1d450982c56ce1960" translate="yes" xml:space="preserve">
          <source>Closing a file will release all locks associated with the file. On POSIX, even locks acquired via a different &lt;code&gt;File&lt;/code&gt; will be released as well.</source>
          <target state="translated">파일을 닫으면 파일과 관련된 모든 잠금이 해제됩니다. POSIX에서는 다른 &lt;code&gt;File&lt;/code&gt; 을 통해 획득 한 잠금 도 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="63c1d27a07661bae4b5bbb559006eaa3661d7c60" translate="yes" xml:space="preserve">
          <source>Closures are implemented by taking the local variables that need to survive the scope of the function, and copying them into a gc allocated chuck of memory. That chunk, called the closure here, is inserted into the linked list of stack frames instead of the usual stack frame.</source>
          <target state="translated">클로저는 함수 범위에서 살아남 아야하는 로컬 변수를 가져 와서 gc 할당 메모리 척에 복사하여 구현됩니다. 여기서 클로저라고하는 해당 청크는 일반적인 스택 프레임 대신 스택 스택의 링크 된 목록에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b2ef049e2a57bda63fd1cc78251ce6a2187e99" translate="yes" xml:space="preserve">
          <source>Cn</source>
          <target state="translated">Cn</target>
        </trans-unit>
        <trans-unit id="8d39b08893191a61de5487a71b3ae48e722dc4dc" translate="yes" xml:space="preserve">
          <source>Co</source>
          <target state="translated">Co</target>
        </trans-unit>
        <trans-unit id="3b89922ff6533757df55cb947df36b1820f7780e" translate="yes" xml:space="preserve">
          <source>Coalescing is carried during deallocation.</source>
          <target state="translated">거래 취소 중에는 병합이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae47022506f14b1edf01e25a19bb75021f3dfd6b" translate="yes" xml:space="preserve">
          <source>Code Generator State</source>
          <target state="translated">코드 생성기 상태</target>
        </trans-unit>
        <trans-unit id="61eac493399c61900e3b0a3c302c25c90df00dd5" translate="yes" xml:space="preserve">
          <source>Code Snippet</source>
          <target state="translated">코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="ca4bf5763a8f4b0c77b0483fb046442fb68b4bcf" translate="yes" xml:space="preserve">
          <source>Code calling &lt;code&gt;getLine&lt;/code&gt; (usually far away from its definition) can't be understood without looking at the documentation, even by users familiar with the API:</source>
          <target state="translated">API에 익숙한 사용자라도 문서를 보지 않으면 &lt;code&gt;getLine&lt;/code&gt; (보통 정의와는 거리가 먼)을 호출하는 코드를 이해할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81c9c017895b738c0e50ae9184f9f1e3b2468977" translate="yes" xml:space="preserve">
          <source>Code data type</source>
          <target state="translated">코드 데이터 타입</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">코드 생성</target>
        </trans-unit>
        <trans-unit id="f2a3cebabe66438483aac9c32717824f44b75d4c" translate="yes" xml:space="preserve">
          <source>Code that defines allocators shareable across threads ultimately implements the &lt;a href=&quot;#ISharedAllocator&quot;&gt;&lt;code&gt;ISharedAllocator&lt;/code&gt;&lt;/a&gt; interface, possibly by using &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt;&lt;code&gt;CSharedAllocatorImpl&lt;/code&gt;&lt;/a&gt; below, and then build a &lt;code&gt;RCISharedAllocator&lt;/code&gt; out of this.</source>
          <target state="translated">코드를 정의 할당 자 스레드를 통해 공유하는 것이 궁극적으로 구현 &lt;a href=&quot;#ISharedAllocator&quot;&gt; &lt;code&gt;ISharedAllocator&lt;/code&gt; 의&lt;/a&gt; 가능성을 사용하여, 인터페이스를 &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt; &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; 을&lt;/a&gt; 아래 한 다음 구축 &lt;code&gt;RCISharedAllocator&lt;/code&gt; 이 중입니다.</target>
        </trans-unit>
        <trans-unit id="2ce7d7f9589694e248dfd5c203d7de9947b03c60" translate="yes" xml:space="preserve">
          <source>Code that defines allocators ultimately implements the &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt; interface, possibly by using &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; below, and then build a &lt;code&gt;RCIAllocator&lt;/code&gt; out of this.</source>
          <target state="translated">코드를 정의 할당 자 궁극적으로 구현하는 &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; 의&lt;/a&gt; 가능성을 사용하여, 인터페이스를 &lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; 을&lt;/a&gt; 아래 한 다음 구축 &lt;code&gt;RCIAllocator&lt;/code&gt; 이 중입니다.</target>
        </trans-unit>
        <trans-unit id="648d49ad8e99c3fb1b22ef73fd685d72f38f47f8" translate="yes" xml:space="preserve">
          <source>CodePoints!E &lt;strong id=&quot;codePoints&quot;&gt;codePoints&lt;/strong&gt;(E)(immutable(E)[] s);</source>
          <target state="translated">CodePoints! E &lt;strong id=&quot;codePoints&quot;&gt;codePoints&lt;/strong&gt; (E) (불변 (E) [] s);</target>
        </trans-unit>
        <trans-unit id="e056cd1238b78a879d641cec9ec7096771e7f154" translate="yes" xml:space="preserve">
          <source>CodeUnits!E &lt;strong id=&quot;codeUnits&quot;&gt;codeUnits&lt;/strong&gt;(E)(dchar c);</source>
          <target state="translated">CodeUnits! E &lt;strong id=&quot;codeUnits&quot;&gt;codeUnits&lt;/strong&gt; (E) (dchar c);</target>
        </trans-unit>
        <trans-unit id="9e5e2fb2ae8d76c3506f723e7bf1081e039cf3b0" translate="yes" xml:space="preserve">
          <source>CodepointSet &lt;strong id=&quot;parseSet&quot;&gt;parseSet&lt;/strong&gt;(Range)(ref Range range, bool casefold = false)</source>
          <target state="translated">CodepointSet &lt;strong id=&quot;parseSet&quot;&gt;parseSet&lt;/strong&gt; (범위) (참조 범위 범위, bool casefold = false)</target>
        </trans-unit>
        <trans-unit id="ab22b1cbc13995ba1b3b200e55dcfdd0544bb677" translate="yes" xml:space="preserve">
          <source>CodepointTrie is the type of Trie as generated by codepointTrie function.</source>
          <target state="translated">CodepointTrie는 codepointTrie 함수로 생성 된 Trie 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f4676db78e987928a98e39c01c3be6dce486eb6b" translate="yes" xml:space="preserve">
          <source>Codeview 4 stuff See &quot;Microsoft Symbol and Type OMF&quot; document</source>
          <target state="translated">Codeview 4 관련 자료 &quot;Microsoft Symbol 및 Type OMF&quot;문서 참조</target>
        </trans-unit>
        <trans-unit id="5703d432c480d27062f281f688e79056c7ad8ff5" translate="yes" xml:space="preserve">
          <source>Codeview Debugger Extensions</source>
          <target state="translated">코드 뷰 디버거 확장</target>
        </trans-unit>
        <trans-unit id="f2ac091ea616d198f2fcdf2fa7fca9b23cc03ae8" translate="yes" xml:space="preserve">
          <source>Codeview OEM Extensions for D</source>
          <target state="translated">D 용 Codeview OEM 확장</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">콜 레이션에 필요한 콜백</target>
        </trans-unit>
        <trans-unit id="6fe1d0f55b0a1f3b24dadd046f77aad5b501d708" translate="yes" xml:space="preserve">
          <source>Collect all instance fields, then determine instance size.</source>
          <target state="translated">모든 인스턴스 필드를 수집 한 다음 인스턴스 크기를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="12bbc9c399cd5560e95d3b021061d86be8bc2a9c" translate="yes" xml:space="preserve">
          <source>Collect certificate chain info and allow it to get retrievable with CURLINFO_CERTINFO after the transfer is complete. (Unfortunately) only working with OpenSSL-powered builds.</source>
          <target state="translated">인증서 체인 정보를 수집하여 전송이 완료된 후 CURLINFO_CERTINFO로 검색 가능하도록하십시오. (안타깝게도) OpenSSL 기반 빌드에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="468b13f09989b44757225ef38e66278a68977e9f" translate="yes" xml:space="preserve">
          <source>Collect statistics about any other allocator.</source>
          <target state="translated">다른 할당 자에 대한 통계를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="051496a97d15089d5729a697772eef84032a0d1c" translate="yes" xml:space="preserve">
          <source>CollectHandler &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">CollectHandler &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26184bfd23f5e4f04f870a87cbb3381399308c03" translate="yes" xml:space="preserve">
          <source>CollectHandler &lt;strong id=&quot;rt_getCollectHandler&quot;&gt;rt_getCollectHandler&lt;/strong&gt;();</source>
          <target state="translated">CollectHandler &lt;strong id=&quot;rt_getCollectHandler&quot;&gt;rt_getCollectHandler&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="9e011708a38de006c0934dcad91ea7104a3760e9" translate="yes" xml:space="preserve">
          <source>Collection of declarations that stores foreach index variables in a local symbol table. Other symbols declared within are forwarded to another scope, like:</source>
          <target state="translated">foreach 인덱스 변수를 로컬 심볼 테이블에 저장하는 선언 모음. 내부에 선언 된 다른 기호는 다음과 같이 다른 범위로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4550137c5d8ee30c9c444e2275bc095775ae9fd8" translate="yes" xml:space="preserve">
          <source>Collection of typical and useful prebuilt allocators using the given components. User code would typically import this module and use its facilities, or import individual heap building blocks and assemble them.</source>
          <target state="translated">주어진 구성 요소를 사용하여 일반적이고 유용한 사전 빌드 된 할당 기 모음. 사용자 코드는 일반적으로이 모듈을 가져 와서 해당 기능을 사용하거나 개별 힙 빌딩 블록을 가져 와서 조립합니다.</target>
        </trans-unit>
        <trans-unit id="ef19b0ece05a3462504233adba544b8b5a08b828" translate="yes" xml:space="preserve">
          <source>Colloquially known as the average, &lt;code&gt;mean([1, 2, 3])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">구어 적으로 평균으로 알려진 &lt;code&gt;mean([1, 2, 3])&lt;/code&gt; 은 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fb3df2ba2c8c0867352fa9e3671ba7ae4fd30398" translate="yes" xml:space="preserve">
          <source>Color highlighting to classify messages</source>
          <target state="translated">메시지를 분류하기위한 색상 강조</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">결과 집합의 열 이름</target>
        </trans-unit>
        <trans-unit id="17e28d0308aeca3705368383ac8a754a55a1f9cb" translate="yes" xml:space="preserve">
          <source>Column number at which parse failure occurred</source>
          <target state="translated">구문 분석 실패가 발생한 열 번호</target>
        </trans-unit>
        <trans-unit id="8802a6119729c5dbcd1a4a6fccd2dd26ff860c9c" translate="yes" xml:space="preserve">
          <source>Combine a &lt;code&gt;path&lt;/code&gt; and a file &lt;code&gt;name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 와 파일 &lt;code&gt;name&lt;/code&gt; 결합</target>
        </trans-unit>
        <trans-unit id="98f6dcf6f609fca2856f9333b52c621a46631536" translate="yes" xml:space="preserve">
          <source>Combine e1 and e2 by CommaExp if both are not NULL.</source>
          <target state="translated">둘 다 NULL이 아닌 경우 e1과 e2를 CommaExp로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="c26362babef999f12a51b76dac746d90b76964fd" translate="yes" xml:space="preserve">
          <source>Combine two document comments into one, separated by an extra newline if newParagraph is true.</source>
          <target state="translated">newParagraph가 true이면 두 개의 문서 주석을 하나의 줄 바꿈으로 구분하여 하나로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="edc044e8199855a2b041cea713a198a580a2531b" translate="yes" xml:space="preserve">
          <source>Combine types.</source>
          <target state="translated">유형을 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="25346b872edf3bfe2419bf590c58043497a9e602" translate="yes" xml:space="preserve">
          <source>Combines all flags above.</source>
          <target state="translated">위의 모든 플래그를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="74c07f7ae306b9dd4da07ceabcc403719eb0b180" translate="yes" xml:space="preserve">
          <source>Combines one or more path segments.</source>
          <target state="translated">하나 이상의 경로 세그먼트를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f83b8c4f6b0762b14b6a3f2a338c87fcd58c0b18" translate="yes" xml:space="preserve">
          <source>Combines several template predicates using logical AND, i.e. constructs a new predicate which evaluates to true for a given input T if and only if all of the passed predicates are true for T.</source>
          <target state="translated">논리 AND를 사용하여 여러 템플리트 술어를 결합합니다. 즉, 전달 된 술어가 모두 T에 대해 참인 경우에만 주어진 입력 T에 대해 참으로 평가되는 새 술어를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="aba602ae0d3fbfaf1b1e3b80dab8046665c5745f" translate="yes" xml:space="preserve">
          <source>Combines several template predicates using logical OR, i.e. constructs a new predicate which evaluates to true for a given input T if and only at least one of the passed predicates is true for T.</source>
          <target state="translated">논리 OR을 사용하여 여러 템플리트 술어를 결합합니다. 즉, 전달 된 술어 중 하나 이상이 T에 대해 참인 경우 주어진 입력 T에 대해 참으로 평가되는 새 술어를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b31cc4ba9ad95a280e295db305a32838ab4494f4" translate="yes" xml:space="preserve">
          <source>Combines the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt;&lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt;&lt;/a&gt; structs to give an object which holds both the date and the time. It is optimized for calendar-based operations and has no concept of time zone. For an object which is optimized for time operations based on the system time, use &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt; has a concept of time zone and has much higher precision (hnsecs). &lt;code&gt;DateTime&lt;/code&gt; is intended primarily for calendar-based uses rather than precise time operations.</source>
          <target state="translated">&lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt; &lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt; &lt;/a&gt; 구조체를 결합하여 날짜와 시간을 모두 보유하는 객체를 제공합니다. 달력 기반 작업에 최적화되어 있으며 시간대 개념이 없습니다. 시스템 시간을 기반으로 시간 조작에 최적화 된 오브젝트의 경우 &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 . &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; &lt;/a&gt; 은 표준 시간대 개념을 가지며 훨씬 높은 정밀도 (hnsecs)를 갖습니다. &lt;code&gt;DateTime&lt;/code&gt; 은 기본적으로 정확한 시간 작업이 아닌 달력 기반 사용을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b348c9883d7a65f18c195bae42b3350c1cfcc257" translate="yes" xml:space="preserve">
          <source>Combines things into output file name for .html and .di files.</source>
          <target state="translated">html 및 .di 파일의 출력 파일 이름으로 항목을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1cb6816f0f4c743f4be34cb8f1005b8dc4a5dbab" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks</source>
          <target state="translated">분음 부호 결합</target>
        </trans-unit>
        <trans-unit id="7bbd088f443b08f8c69b5507dfb474b887bed2d3" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks Supplement</source>
          <target state="translated">분음 부호 보충</target>
        </trans-unit>
        <trans-unit id="89777baa8157a4e8e953c3fa634c48e0c8258bcc" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks for Symbols</source>
          <target state="translated">기호에 대한 분음 부호 결합</target>
        </trans-unit>
        <trans-unit id="d0f9b6a69c0d912d5ea6af9438228b3d2f3751e4" translate="yes" xml:space="preserve">
          <source>Combining Half Marks</source>
          <target state="translated">하프 마크 결합</target>
        </trans-unit>
        <trans-unit id="33e7a69b870095426b74829cdf476d33798ed00e" translate="yes" xml:space="preserve">
          <source>Combining Qualifiers</source>
          <target state="translated">한정자 결합</target>
        </trans-unit>
        <trans-unit id="6b7ee24a290e7c102397f117a90975aafc87fb59" translate="yes" xml:space="preserve">
          <source>Comma Separated Values provide a simple means to transfer and store tabular data. It has been common for programs to use their own variant of the CSV format. This parser will loosely follow the &lt;a href=&quot;http://tools.ietf.org/html/rfc4180&quot;&gt;RFC-4180&lt;/a&gt;. CSV input should adhere to the following criteria (differences from RFC-4180 in parentheses):</source>
          <target state="translated">쉼표로 구분 된 값은 테이블 형식의 데이터를 전송하고 저장하는 간단한 방법을 제공합니다. 프로그램에서 CSV 형식의 고유 한 변형을 사용하는 것이 일반적입니다. 이 파서는 &lt;a href=&quot;http://tools.ietf.org/html/rfc4180&quot;&gt;RFC-4180을&lt;/a&gt; 느슨하게 따릅니다 . CSV 입력은 다음 기준을 준수해야합니다 (괄호 안의 RFC-4180과의 차이점).</target>
        </trans-unit>
        <trans-unit id="b4def8608142eafccba008125cdb8f25176618f8" translate="yes" xml:space="preserve">
          <source>Comma Separated Values provide a simple means to transfer and store tabular data. It has been common for programs to use their own variant of the CSV format. This parser will loosely follow the &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC-4180&lt;/a&gt;. CSV input should adhere to the following criteria (differences from RFC-4180 in parentheses):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7bdcc128a60763ff9cb8c0be38b2ccf8b45812" translate="yes" xml:space="preserve">
          <source>Comma separated list of hostnames defining no-proxy zones. These should match both hostnames directly, and hostnames within a domain. For example, local.com will match local.com and www.local.com, but NOT notlocal.com or www.notlocal.com. For compatibility with other implementations of this, .local.com will be considered to be the same as local.com. A single * is the only valid wildcard, and effectively disables the use of proxy.</source>
          <target state="translated">프록시가없는 영역을 정의하는 쉼표로 구분 된 호스트 이름 목록. 이들은 호스트 이름과 도메인 내의 호스트 이름 모두와 직접 일치해야합니다. 예를 들어 local.com은 local.com 및 www.local.com과 일치하지만 notlocal.com 또는 www.notlocal.com과는 일치하지 않습니다. 이것의 다른 구현과의 호환성을 위해 .local.com은 local.com과 동일한 것으로 간주됩니다. 단일 *는 유일한 유효한 와일드 카드이며 프록시 사용을 효과적으로 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f6fe35e209171bf42b301a97ecb399ad5a56cfaf" translate="yes" xml:space="preserve">
          <source>Command line</source>
          <target state="translated">커맨드 라인</target>
        </trans-unit>
        <trans-unit id="5663b86338bee23174b52b5ba46d8c32b58f8344" translate="yes" xml:space="preserve">
          <source>Command line arguments</source>
          <target state="translated">명령 줄 인수</target>
        </trans-unit>
        <trans-unit id="b7387b33d51887468652e802f6afcaeeac9763ce" translate="yes" xml:space="preserve">
          <source>Command line options starting with &quot;--DRT-&quot; are filtered out before calling main, so the program will not see them. They are still available via &lt;code&gt;rt_args&lt;/code&gt;.</source>
          <target state="translated">&quot;--DRT-&quot;로 시작하는 명령 행 옵션은 main을 호출하기 전에 필터링되므로 프로그램에서이를 볼 수 없습니다. 그것들은 여전히 &lt;code&gt;rt_args&lt;/code&gt; 를 통해 사용 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="66903ceee41d5ef93421296e69bd6bc51f61efb5" translate="yes" xml:space="preserve">
          <source>Comment &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">댓글 &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48954ad4a0817f783f701d92a1c3c569e75777df" translate="yes" xml:space="preserve">
          <source>Comment associated with this member.</source>
          <target state="translated">이 회원과 관련된 댓글입니다.</target>
        </trans-unit>
        <trans-unit id="1e06489a89cedf711af9607db1d687967d2faf01" translate="yes" xml:space="preserve">
          <source>Comment below is from curlbuild.h:</source>
          <target state="translated">아래는 curlbuild.h의 주석입니다.</target>
        </trans-unit>
        <trans-unit id="7f9ff34af4b665bfb574ac85235f0f1cf4635d35" translate="yes" xml:space="preserve">
          <source>CommentException if the comment body is illegal (contains &quot;--&quot; or exactly equals &quot;-&quot;)</source>
          <target state="translated">주석 본문이 잘못된 경우 ( &quot;-&quot;포함 또는 &quot;-&quot;와 정확히 동일)</target>
        </trans-unit>
        <trans-unit id="4264255f1057eb8725699e53f5d3e7b96386a8eb" translate="yes" xml:space="preserve">
          <source>Comment[] &lt;strong id=&quot;comments&quot;&gt;comments&lt;/strong&gt;;</source>
          <target state="translated">코멘트 [] &lt;strong id=&quot;comments&quot;&gt;코멘트&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="f8e4ca873b869b2ec1ff4daac61440fd8ce0e0ee" translate="yes" xml:space="preserve">
          <source>Comments cannot be used as token concatenators, for example, &lt;code&gt;abc/**/def&lt;/code&gt; is two tokens, &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt;, not one &lt;code&gt;abcdef&lt;/code&gt; token.</source>
          <target state="translated">주석은 토큰 연결기로 사용할 수 없습니다. 예를 들어, &lt;code&gt;abc/**/def&lt;/code&gt; 는 &lt;code&gt;abcdef&lt;/code&gt; 토큰이 아닌 &lt;code&gt;abc&lt;/code&gt; 및 &lt;code&gt;def&lt;/code&gt; 의 두 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">커밋 및 롤백 알림 콜백</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="d5f7712570de637ff2bff7b7aca4d031bb1ee21d" translate="yes" xml:space="preserve">
          <source>Common Indic Number Forms</source>
          <target state="translated">일반적인 인도 숫자 양식</target>
        </trans-unit>
        <trans-unit id="b01bd9f5938cc4dfaf1079b1a8c35dbfb98a3ba0" translate="yes" xml:space="preserve">
          <source>Common approaches such as hash-tables or binary search over sorted code point intervals (as in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;) are insufficient. Hash-tables have enormous memory footprint and binary search over intervals is not fast enough for some heavy-duty algorithms.</source>
          <target state="translated">해시 테이블 또는 정렬 된 코드 포인트 간격 ( &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; 에서와 같이)에 대한 이진 검색과 같은 일반적인 접근 방식으로 는 충분하지 않습니다. 해시 테이블은 엄청난 메모리 공간을 차지하며 간격에 따른 이진 검색은 일부 강력한 알고리즘에 대해 충분히 빠르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a32dd588a7041c6270a2514d02c733a9073d9c8d" translate="yes" xml:space="preserve">
          <source>Common case for setting integer and boolean options.</source>
          <target state="translated">정수 및 부울 옵션을 설정하는 일반적인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="cfa4873432fa4d4b23cf20cc5198f21c85152d5f" translate="yes" xml:space="preserve">
          <source>Common case of getting integer and boolean options.</source>
          <target state="translated">정수 및 부울 옵션을 얻는 일반적인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="a72840f8f3c4385179a2e1cf4bebd6d9b76a472a" translate="yes" xml:space="preserve">
          <source>Common code for writing containers.</source>
          <target state="translated">컨테이너 작성을위한 공통 코드.</target>
        </trans-unit>
        <trans-unit id="437c2f93da603a10ceee0ebf4f1919d2974c2022" translate="yes" xml:space="preserve">
          <source>Common qualifier of the two type qualifiers</source>
          <target state="translated">두 가지 유형 한정자의 공통 한정자</target>
        </trans-unit>
        <trans-unit id="89b171c2ecd63cf0a35ea222440907368f9360a4" translate="yes" xml:space="preserve">
          <source>Common uses of &lt;code&gt;FreeTree&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;FreeTree&lt;/code&gt; 의 일반적인 용도는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92e85a9032d0518091b64099c3e63f685bc8df63" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;cosineSimilarity&quot;&gt;cosineSimilarity&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;cosineSimilarity&quot;&gt;코사인 유사성&lt;/strong&gt; (Range1, Range2) (Range1 a, Range2 b)</target>
        </trans-unit>
        <trans-unit id="ab52ba0cfbd974531b75cec838a9576c7724e23a" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt; (Range1, Range2) (Range1 a, Range2 b)</target>
        </trans-unit>
        <trans-unit id="78c516be482530cc1f87a2e85f9f687667bad396" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;유클리드 거리&lt;/strong&gt; (Range1, Range2) (Range1 a, Range2 b)</target>
        </trans-unit>
        <trans-unit id="8b31f84db6c6a02bc762e2196d7797a3ccad082e" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;(Range1, Range2, F)(Range1 a, Range2 b, F limit)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;유클리드 거리&lt;/strong&gt; (Range1, Range2, F) (Range1 a, Range2 b, F limit)</target>
        </trans-unit>
        <trans-unit id="99490d0eb9c15796c0e0ff22de9c774a74b4f439" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;젠슨 ShannonDivergence&lt;/strong&gt; (Range1, Range2) (Range1 a, Range2 b)</target>
        </trans-unit>
        <trans-unit id="39e238fe92f1abc74d373ce3196f749befb03cf0" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;(Range1, Range2, F)(Range1 a, Range2 b, F limit)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;젠슨 산논 확산&lt;/strong&gt; (Range1, Range2, F) (Range1 a, Range2 b, F limit)</target>
        </trans-unit>
        <trans-unit id="2b63f6969cbcdac3dc164e1220875639e9d0d85f" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;kullbackLeiblerDivergence&quot;&gt;kullbackLeiblerDivergence&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType! (ElementType! Range1, ElementType! Range2) &lt;strong id=&quot;kullbackLeiblerDivergence&quot;&gt;kullbackLeiblerDivergence&lt;/strong&gt; (Range1, Range2) (Range1 a, Range2 b)</target>
        </trans-unit>
        <trans-unit id="482d9be28df1e9221b752743fa47c81f861b6eb6" translate="yes" xml:space="preserve">
          <source>CommonType!(F1, F2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(F1, F2)(in F1[] avector, in F2[] bvector);</source>
          <target state="translated">CommonType! (F1, F2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt; (F1, F2) (F1 [] 벡터에서, F2 [] bvector에서);</target>
        </trans-unit>
        <trans-unit id="59567896c72bea971e25cca00ca5982b60db700d" translate="yes" xml:space="preserve">
          <source>CommonType!(T, Ts) &lt;strong id=&quot;either&quot;&gt;either&lt;/strong&gt;(alias pred = (a) =&amp;gt; a, T, Ts...)(T first, lazy Ts alternatives)</source>
          <target state="translated">CommonType! (T, Ts) &lt;strong id=&quot;either&quot;&gt;또는&lt;/strong&gt; (alias pred = (a) =&amp;gt; a, T, Ts ...) (T first, lazy Ts alternatives)</target>
        </trans-unit>
        <trans-unit id="5c4c8f5d8b8482e06dd925b14fcab2c3af9acffc" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(E : Throwable = Exception, T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler);</source>
          <target state="translated">CommonType! (T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt; (E : Throwable = Exception, T1, T2) (lazy scope T1 표현식, lazy scope T2 errorHandler);</target>
        </trans-unit>
        <trans-unit id="2d94d685f738626c2b0f123b65566e240d54d753" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(E : Throwable, T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler);</source>
          <target state="translated">CommonType! (T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt; (E : Throwable, T1, T2) (지연 한 범위 T1 표현식, 범위 T2 delegate (E) errorHandler);</target>
        </trans-unit>
        <trans-unit id="106770f05acf1293b31c427d84352126dc825e9c" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler);</source>
          <target state="translated">CommonType! (T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt; (T1, T2) (게으른 범위 T1 표현식, 범위 T2 delegate (Exception) errorHandler);</target>
        </trans-unit>
        <trans-unit id="d21cc02f1aab33002c403671fdd746279f33b65d" translate="yes" xml:space="preserve">
          <source>Communication semantics</source>
          <target state="translated">통신 의미론</target>
        </trans-unit>
        <trans-unit id="f24e56471fa8b175056938019fdeefa50ef168a7" translate="yes" xml:space="preserve">
          <source>Compare Expressions</source>
          <target state="translated">식 비교</target>
        </trans-unit>
        <trans-unit id="5817894eddc9a1f74a0238aa6f626e4444e59c11" translate="yes" xml:space="preserve">
          <source>Compare and exchange for mixed-&lt;code&gt;shared&lt;/code&gt;ness types</source>
          <target state="translated">혼합 &lt;code&gt;shared&lt;/code&gt; 유형 비교 및 교환</target>
        </trans-unit>
        <trans-unit id="caa535ca46ced3c4b33a96aab608929abbb4fdf9" translate="yes" xml:space="preserve">
          <source>Compare proposed template instantiation with existing template instantiation. Note that this is not commutative because of the auto ref check.</source>
          <target state="translated">제안 된 템플릿 인스턴스화와 기존 템플릿 인스턴스화를 비교합니다. 자동 참조 확인으로 인해 이는 정식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2c7808fae6354fb79882d9e3894f49385a385060" translate="yes" xml:space="preserve">
          <source>Compare two complex floating point numbers, x and y.</source>
          <target state="translated">두 개의 복잡한 부동 소수점 숫자 x와 y를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="4b589fbc23973e0904ddeba8f483e18ded8c6fc2" translate="yes" xml:space="preserve">
          <source>Compare two lists using the comparison function fp. The comparison function is the same as used for qsort().</source>
          <target state="translated">비교 기능 fp를 사용하여 두 목록을 비교하십시오. 비교 함수는 qsort ()에 사용 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="53048e0cd3f3523910efe523391cf85f13b1f561" translate="yes" xml:space="preserve">
          <source>Compare two lists.</source>
          <target state="translated">두 목록을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="ec1ea853fba43ebac35e9589bc1b5421280f317a" translate="yes" xml:space="preserve">
          <source>Compare two name according to the platform's rules (case sensitive or not)</source>
          <target state="translated">플랫폼 규칙에 따라 두 이름을 비교하십시오 (대소 문자 구분)</target>
        </trans-unit>
        <trans-unit id="470f25e165e645b09541078696ae4bb01732c4b6" translate="yes" xml:space="preserve">
          <source>Compare two slices for equality, in a case-insensitive way</source>
          <target state="translated">대소 문자를 구분하지 않는 방식으로 두 슬라이스가 동일한 지 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b2aaa9a2feba60d75ca35ce0d9eaf6a325e5cf" translate="yes" xml:space="preserve">
          <source>Compare with another Object obj.</source>
          <target state="translated">다른 Object obj와 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="7d45a1b5434fdb490caf4f37107281ff4b27634f" translate="yes" xml:space="preserve">
          <source>Compare-and-exchange for &lt;code&gt;class&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 비교 및 교환</target>
        </trans-unit>
        <trans-unit id="56759e40fbf219e9426d9bc8573761f0a60a3d8b" translate="yes" xml:space="preserve">
          <source>Compare-and-exchange for non-&lt;code&gt;shared&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 유형에 대한 비교 및 ​​교환</target>
        </trans-unit>
        <trans-unit id="d8464f9142c18b6c2262013f0b9d014233850d21" translate="yes" xml:space="preserve">
          <source>Compare-and-set for &lt;code&gt;shared&lt;/code&gt; reference type (&lt;code&gt;class&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 참조 유형 ( &lt;code&gt;class&lt;/code&gt; )에 대한 비교 및 ​​설정</target>
        </trans-unit>
        <trans-unit id="33efea0257b207beff234a818ac9d15ab90a8752" translate="yes" xml:space="preserve">
          <source>Compare-and-set for non-shared values</source>
          <target state="translated">비공유 값에 대한 비교 및 ​​설정</target>
        </trans-unit>
        <trans-unit id="389e01c09aa88cfd5fe3b34b651ba75b671e5bb3" translate="yes" xml:space="preserve">
          <source>Compare-and-set for shared value type</source>
          <target state="translated">공유 가치 유형에 대한 비교 및 ​​설정</target>
        </trans-unit>
        <trans-unit id="269cc9dfce30ec1e7d235e3871e31eeb2e9ea313" translate="yes" xml:space="preserve">
          <source>Compares 2 lambda functions described by their serialization.</source>
          <target state="translated">직렬화로 설명 된 2 개의 람다 함수를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3514fc794b1b84ff2dcda58da47639190d167244" translate="yes" xml:space="preserve">
          <source>Compares &lt;code&gt;this&lt;/code&gt; against &lt;code&gt;rhs&lt;/code&gt; for equality. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpEquals&lt;/code&gt;, the function forwards to &lt;code&gt; hook.hookOpEquals(get, rhs)&lt;/code&gt;. Otherwise, the result of the built-in operation &lt;code&gt;get == rhs&lt;/code&gt; is returned.</source>
          <target state="translated">평등을 위해 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;rhs&lt;/code&gt; 와 비교 합니다 . 경우 &lt;code&gt;Hook&lt;/code&gt; 을 정의의 &lt;code&gt;hookOpEquals&lt;/code&gt; 에 함수 전달 &lt;code&gt; hook.hookOpEquals(get, rhs)&lt;/code&gt; . 그렇지 않으면 내장 조작 &lt;code&gt;get == rhs&lt;/code&gt; 의 결과 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="834d94035a6f955e584fb4c7ba4b567912fa0d8a" translate="yes" xml:space="preserve">
          <source>Compares &lt;code&gt;this&lt;/code&gt; against &lt;code&gt;rhs&lt;/code&gt; for ordering. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCmp&lt;/code&gt;, the function forwards to &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt;. Otherwise, the result of the built-in comparison operation is returned.</source>
          <target state="translated">주문을 위해 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;rhs&lt;/code&gt; 와 비교 합니다 . 경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookOpCmp&lt;/code&gt; 에 전달하는 기능 &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; . 그렇지 않으면 내장 비교 연산의 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8d72cb06967d76ad2315bc14800e16c84c791ad4" translate="yes" xml:space="preserve">
          <source>Compares file names and returns</source>
          <target state="translated">파일 이름을 비교하고 반환</target>
        </trans-unit>
        <trans-unit id="ed50f74df59a0142ddc654a4239b67d9a76c7149" translate="yes" xml:space="preserve">
          <source>Compares filename characters.</source>
          <target state="translated">파일 이름 문자를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="2249aabcb1e96260d3051f1dca27aa7ab8ce5589" translate="yes" xml:space="preserve">
          <source>Compares ranges for element-by-element equality, e.g. &lt;code&gt;equal([1, 2, 3], [1.0, 2.0, 3.0])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요소 별 동등성의 범위를 비교합니다. 예를 들어 &lt;code&gt;equal([1, 2, 3], [1.0, 2.0, 3.0])&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ffefd591caadf7c9238108ca12da950ac2e6a35f" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 와 지정된 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 를&lt;/a&gt; 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="15738864f6cafc73bd814277cd09c013ecd311e3" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with the given &lt;code&gt;DateTime.&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 과 지정된 &lt;code&gt;DateTime.&lt;/code&gt; 비교합니다 . .</target>
        </trans-unit>
        <trans-unit id="689160a534f49b2dda3e4266c47b5941a7703870" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 과 지정된 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 을&lt;/a&gt; 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="c8165c8a402fda4e1a1b6bfe46a9433cba2d560d" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 와 지정된 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 를&lt;/a&gt; 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="fe6b91ee80ba217913bf0d3b49282d731578146c" translate="yes" xml:space="preserve">
          <source>Compares this &lt;code&gt;Duration&lt;/code&gt; with the given &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 와 지정된 &lt;code&gt;Duration&lt;/code&gt; 를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="59460af8f5d8d95384b897b17a23456d8cbca065" translate="yes" xml:space="preserve">
          <source>Compares this MonoTime with the given MonoTime.</source>
          <target state="translated">이 MonoTime을 주어진 MonoTime과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="61073ed6151d4099d5b99ce170507850bbec3a0f" translate="yes" xml:space="preserve">
          <source>Compares two CDatas</source>
          <target state="translated">두 CData 비교</target>
        </trans-unit>
        <trans-unit id="2feed28735d9cb020838db7c34238164751ec4e9" translate="yes" xml:space="preserve">
          <source>Compares two CDatas for equality</source>
          <target state="translated">두 CData가 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="cf953c71e71cad559a1b6f41099f639fc4b7a9a7" translate="yes" xml:space="preserve">
          <source>Compares two Documents</source>
          <target state="translated">두 문서를 비교</target>
        </trans-unit>
        <trans-unit id="155a80b4bbc808c799aa0f116b685c5ba6a2b770" translate="yes" xml:space="preserve">
          <source>Compares two Documents for equality</source>
          <target state="translated">두 문서의 평등 비교</target>
        </trans-unit>
        <trans-unit id="71867a59aab2e3bc4e1f645998ccc58f3385b507" translate="yes" xml:space="preserve">
          <source>Compares two Elements</source>
          <target state="translated">두 요소를 비교</target>
        </trans-unit>
        <trans-unit id="1c6b132b2fbac57463697b6c1796a4b2c009f21e" translate="yes" xml:space="preserve">
          <source>Compares two Elements for equality</source>
          <target state="translated">두 요소가 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="1de75b0a506aa6ed853b26b0a46cd0641566a633" translate="yes" xml:space="preserve">
          <source>Compares two Tags</source>
          <target state="translated">두 개의 태그를 비교</target>
        </trans-unit>
        <trans-unit id="1c8a71eb2f93f8e19bd6763d1b05643346323e21" translate="yes" xml:space="preserve">
          <source>Compares two Tags for equality</source>
          <target state="translated">두 태그가 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="5b4c697a2d7145b631ee5e772ec59f8a1f518990" translate="yes" xml:space="preserve">
          <source>Compares two XML instructions</source>
          <target state="translated">두 개의 XML 명령어 비교</target>
        </trans-unit>
        <trans-unit id="d3f58d3dea043b6d22fc6cc7d29ac43c66b365bd" translate="yes" xml:space="preserve">
          <source>Compares two XML instructions for equality</source>
          <target state="translated">두 개의 XML 명령어가 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="a047b0e437993116e7c77e0618c976828560c65e" translate="yes" xml:space="preserve">
          <source>Compares two comments</source>
          <target state="translated">두 의견을 비교</target>
        </trans-unit>
        <trans-unit id="5f0ccb1455dbbca2718693f6457fa9a0e4ab0a7e" translate="yes" xml:space="preserve">
          <source>Compares two comments for equality</source>
          <target state="translated">평등에 대한 두 의견 비교</target>
        </trans-unit>
        <trans-unit id="5cfb7b733711f89793eb5d1c213b36ce5b8619ff" translate="yes" xml:space="preserve">
          <source>Compares two instances for &amp;lt;, ==, or &amp;gt;.</source>
          <target state="translated">&amp;lt;, == 또는&amp;gt;에 대한 두 인스턴스를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8f551041ef1a130ca32a1c918d060ad148571f0b" translate="yes" xml:space="preserve">
          <source>Compares two instances for equality.</source>
          <target state="translated">두 인스턴스가 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="899d53ea8150068dbb59e10d9add2e1cdebde76c" translate="yes" xml:space="preserve">
          <source>Compares two processing instructions</source>
          <target state="translated">두 개의 처리 명령을 비교</target>
        </trans-unit>
        <trans-unit id="4f39f88ab522977bdc2f3dff102f72d43f0f9cc9" translate="yes" xml:space="preserve">
          <source>Compares two processing instructions for equality</source>
          <target state="translated">두 처리 명령이 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="8d5d39ab88f4f47308cef4f47f2b602afa70b300" translate="yes" xml:space="preserve">
          <source>Compares two ranges for equality, as defined by predicate &lt;code&gt;pred&lt;/code&gt; (which is &lt;code&gt;==&lt;/code&gt; by default).</source>
          <target state="translated">술어 &lt;code&gt;pred&lt;/code&gt; ( 기본적으로 &lt;code&gt;==&lt;/code&gt; )에 의해 정의 된대로 두 범위가 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="f81d47748b180086bf89fb2bd5331b855132ca4a" translate="yes" xml:space="preserve">
          <source>Compares two ranges for equality. The ranges may have different element types, as long as &lt;code&gt;pred(r1.front, r2.front)&lt;/code&gt; evaluates to &lt;code&gt;bool&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">두 범위가 동일한 지 비교합니다. &lt;code&gt;pred(r1.front, r2.front)&lt;/code&gt; 가 &lt;code&gt;bool&lt;/code&gt; 로 평가 되는 한 범위는 다른 요소 유형을 가질 수 있습니다 . &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ) 평가를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="248fdeb67d5d8ff8dea5a626cacfd8c772e6ff5b" translate="yes" xml:space="preserve">
          <source>Compares two text sections</source>
          <target state="translated">두 개의 텍스트 섹션을 비교</target>
        </trans-unit>
        <trans-unit id="aea8d87c28bd8f8f4e53228c798c86d39471182a" translate="yes" xml:space="preserve">
          <source>Compares two text sections for equality</source>
          <target state="translated">두 텍스트 섹션이 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="b96961131f8b2d56c0afdc08b9dfc3f261ece799" translate="yes" xml:space="preserve">
          <source>Compares two time unit strings at compile time. &lt;code&gt;&quot;years&quot;&lt;/code&gt; are the largest units and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; are the smallest.</source>
          <target state="translated">컴파일 타임에 두 개의 시간 단위 문자열을 비교합니다. &lt;code&gt;&quot;years&quot;&lt;/code&gt; 이 가장 큰 단위이고 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; 가 가장 작습니다.</target>
        </trans-unit>
        <trans-unit id="73cfa7cb938dfbb7800d8b2d717f330ee6a481ac" translate="yes" xml:space="preserve">
          <source>Compares two time unit strings. &lt;code&gt;&quot;years&quot;&lt;/code&gt; are the largest units and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; are the smallest.</source>
          <target state="translated">두 개의 시간 단위 문자열을 비교합니다. &lt;code&gt;&quot;years&quot;&lt;/code&gt; 이 가장 큰 단위이고 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; 가 가장 작습니다.</target>
        </trans-unit>
        <trans-unit id="736528f0c2f124578ad75bec18127fa0c5d8df06" translate="yes" xml:space="preserve">
          <source>Compares two trees for equality.</source>
          <target state="translated">두 트리가 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8ea391c8d4e8b1e4cad6bceeb3d88e880c28dcc6" translate="yes" xml:space="preserve">
          <source>Compares with another InternetAddress of same type for equality</source>
          <target state="translated">동일한 유형의 다른 InternetAddress와 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="49cdf7c2ab546d5587c6ee0331c985ef36d21ae1" translate="yes" xml:space="preserve">
          <source>Compares with another Item of same type</source>
          <target state="translated">동일한 유형의 다른 항목과 비교</target>
        </trans-unit>
        <trans-unit id="feedb86ff0053ef1f5bbf048b43463a97c30f866" translate="yes" xml:space="preserve">
          <source>Compares with another Item of same type for equality</source>
          <target state="translated">동일한 유형의 다른 항목과 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="aa1d4e3fc8af232a8529a23e0a4021de49404caa" translate="yes" xml:space="preserve">
          <source>Comparing D Immutable and Const with C++ Const</source>
          <target state="translated">D 불변과 Const를 C ++ Const와 비교</target>
        </trans-unit>
        <trans-unit id="1cddc2b857fb24fec592019a977ade46bd8e0d9d" translate="yes" xml:space="preserve">
          <source>ComparingBenchmarkResult &lt;strong id=&quot;comparingBenchmark&quot;&gt;comparingBenchmark&lt;/strong&gt;(alias baseFunc, alias targetFunc, int times = 4095)();</source>
          <target state="translated">ComparingBenchmarkResult &lt;strong id=&quot;comparingBenchmark&quot;&gt;comparingBenchmark&lt;/strong&gt; (별칭 baseFunc, 별명 targetFunc, INT 시간 = 4095) ();</target>
        </trans-unit>
        <trans-unit id="2dfcf898a3bd4e011123eee87384ecb67d0919d4" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="translated">Comparison</target>
        </trans-unit>
        <trans-unit id="d674be464fc3dfa9b4b4dc25d1b812f36bad0d19" translate="yes" xml:space="preserve">
          <source>Comparison for equality used by the &quot;==&quot; and &quot;!=&quot; operators.</source>
          <target state="translated">&quot;==&quot;및 &quot;! =&quot;연산자가 사용하는 동등성 비교</target>
        </trans-unit>
        <trans-unit id="9b6db5f546098b8351c2a295c7a744c7f9c5b1f3" translate="yes" xml:space="preserve">
          <source>Comparison for equality.</source>
          <target state="translated">평등 비교.</target>
        </trans-unit>
        <trans-unit id="27f31591aeeb71d8072850ad96cfcf618bb9c4b6" translate="yes" xml:space="preserve">
          <source>Comparison for equality. Two &lt;code&gt;Tuple&lt;/code&gt;s are considered equal &lt;b&gt;iff&lt;/b&gt; they fulfill the following criteria:</source>
          <target state="translated">평등 비교. 두 개의 &lt;code&gt;Tuple&lt;/code&gt; 은 다음 기준을 충족하는 &lt;b&gt;경우&lt;/b&gt; 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="acd5826889c075fa96051d4ba9ec6abdd7e93115" translate="yes" xml:space="preserve">
          <source>Comparison for ordering.</source>
          <target state="translated">주문 비교.</target>
        </trans-unit>
        <trans-unit id="77915f2fa8db68346e105b6be7363156bb2e830c" translate="yes" xml:space="preserve">
          <source>Comparison is based on &lt;code&gt;char&lt;/code&gt; and does not do decoding. As a result, it's only really accurate for plain ASCII strings.</source>
          <target state="translated">비교는 &lt;code&gt;char&lt;/code&gt; 을 기반으로 하며 디코딩을 수행하지 않습니다. 결과적으로 일반 ASCII 문자열에 대해서만 정확합니다.</target>
        </trans-unit>
        <trans-unit id="50830d36fb34a645e85fdd460f20e839e99c57c9" translate="yes" xml:space="preserve">
          <source>Comparison operations are rewritten as follows:</source>
          <target state="translated">비교 작업은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8724559a94ef0fe371c3295abbffe07e7c73b1" translate="yes" xml:space="preserve">
          <source>Compatibility decomposition is a &lt;b&gt;lossy&lt;/b&gt; conversion, typically suitable only for fuzzy matching and internal processing.</source>
          <target state="translated">호환성 분해는 &lt;b&gt;손실&lt;/b&gt; 변환이며 일반적으로 퍼지 매칭 및 내부 처리에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d515317076de8e82a7df9a5583ce6d1adb904fdc" translate="yes" xml:space="preserve">
          <source>Compatibility decomposition. The result is compatibility equivalent sequence.</source>
          <target state="translated">호환성 분해. 결과는 호환성에 상응하는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="47f75260822181977396612d26a17c9f895fd067" translate="yes" xml:space="preserve">
          <source>Compexity</source>
          <target state="translated">Compexity</target>
        </trans-unit>
        <trans-unit id="899c4bbe236b40b7f4f386ca0e1d495afd2b9909" translate="yes" xml:space="preserve">
          <source>Compile Time Disabling of &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 컴파일 시간 비활성화</target>
        </trans-unit>
        <trans-unit id="9601f2a530e239754089111cdf22a63d09d0da03" translate="yes" xml:space="preserve">
          <source>Compile Time Function Execution (CTFE)</source>
          <target state="translated">CTFE (컴파일 시간 함수 실행)</target>
        </trans-unit>
        <trans-unit id="111b991b8bd8902ab908d279507dbc2567386414" translate="yes" xml:space="preserve">
          <source>Compile regular expression pattern for the later execution.</source>
          <target state="translated">나중에 실행할 수 있도록 정규식 패턴을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="277fb4d7b34b839316a7f89f2653d3a761832e8c" translate="yes" xml:space="preserve">
          <source>Compile regular expression using CTFE and generate optimized native machine code for matching it.</source>
          <target state="translated">CTFE를 사용하여 정규식을 컴파일하고이를 최적화하기 위해 최적화 된 기본 기계 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f7f33f2933c6141df88a84f55a23e09ba130a02f" translate="yes" xml:space="preserve">
          <source>Compile the MixinType, returning the type AST.</source>
          <target state="translated">AST 유형을 반환하여 MixinType을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">컴파일 타임 인증 콜백</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">컴파일 타임 라이브러리 버전 번호</target>
        </trans-unit>
        <trans-unit id="c1beaf7d1ab6d20b70616c28d06d81210d112960" translate="yes" xml:space="preserve">
          <source>Compile-time values</source>
          <target state="translated">컴파일 타임 값</target>
        </trans-unit>
        <trans-unit id="31fa1f41f5b6804e8b506439e0a320efb83fde36" translate="yes" xml:space="preserve">
          <source>CompiledCtfeFunctionPimpl &lt;strong id=&quot;ctfeCode&quot;&gt;ctfeCode&lt;/strong&gt;;</source>
          <target state="translated">CompiledCtfeFunctionPimpl &lt;strong id=&quot;ctfeCode&quot;&gt;ctfeCode&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="7ab8d68f763422663c5a51a1109f0f26969187ef" translate="yes" xml:space="preserve">
          <source>Compiler Checks</source>
          <target state="translated">컴파일러 점검</target>
        </trans-unit>
        <trans-unit id="dae36f6f6064ffef1e1754fc1a3db46d87b57e16" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D 프로그래밍 언어&lt;/a&gt; 의 컴파일러 구현</target>
        </trans-unit>
        <trans-unit id="14f91068413d32dc45e209e13c1a52a0c98a2adc" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D 프로그래밍 언어&lt;/a&gt; 의 컴파일러 구현 .</target>
        </trans-unit>
        <trans-unit id="638d4fafd817156b7a7b919c2d357c7a4e40fecd" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;. Entry point for DMD.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D 프로그래밍 언어&lt;/a&gt; 의 컴파일러 구현 . DMD의 진입 점.</target>
        </trans-unit>
        <trans-unit id="cb9f3472430d511bc2a1cab99cbca60b61a1a542" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;. Utility functions for DMD.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D 프로그래밍 언어&lt;/a&gt; 의 컴파일러 구현 . DMD를위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="a308cc3158cc4a66d0a8f5bf6d0eff2374e034a3" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the D programming language &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt;</source>
          <target state="translated">D 프로그래밍 언어 &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt; 의 컴파일러 구현</target>
        </trans-unit>
        <trans-unit id="f1d6503c070a457a61fda17f2153cd21a3084d96" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the D programming language &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt; This file is not shared with other compilers which use the DMD front-end.</source>
          <target state="translated">D 프로그래밍 언어의 컴파일러 구현 &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt; 이 파일은 DMD 프런트 엔드를 사용하는 다른 컴파일러와 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67b78e834ccfc3fb4d626c14e19e68b2f93a8064" translate="yes" xml:space="preserve">
          <source>Compiler vendor could not be detected</source>
          <target state="translated">컴파일러 공급 업체를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="4dcbf24d21d00f4926da34a218b3790f5b4e8f04" translate="yes" xml:space="preserve">
          <source>Compiler vendor specific versions can be predefined if the trademarked vendor identifier prefixes it, as in:</source>
          <target state="translated">다음과 같이 상표가 부여 된 공급 업체 식별자가 접두사 인 경우 컴파일러 공급 업체별 버전을 미리 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9879770228628f9210415d896412d02eb35c7ccc" translate="yes" xml:space="preserve">
          <source>Compiler vendor string</source>
          <target state="translated">컴파일러 공급 업체 문자열</target>
        </trans-unit>
        <trans-unit id="89ab065950932906f0c70953836cc3d876a0f5c7" translate="yes" xml:space="preserve">
          <source>Compiler version as an integer</source>
          <target state="translated">정수로서의 컴파일러 버전</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">SQL 문 컴파일</target>
        </trans-unit>
        <trans-unit id="6f279773bb3b6d94a13d70e62a02f07420245fdd" translate="yes" xml:space="preserve">
          <source>Compiling the two files, the first with a C++ compiler, the second with a D compiler, linking them together, and then running it yields:</source>
          <target state="translated">첫 번째 파일은 C ++ 컴파일러로, 두 번째 파일은 D 컴파일러로 컴파일하고 함께 링크 한 다음 실행하면 두 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="e44e982f24d61ce8d41fc7d68d07e93d8ea91560" translate="yes" xml:space="preserve">
          <source>Compiling, linking, and running produces the output:</source>
          <target state="translated">컴파일, 링크 및 실행은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="364056731803da7d64b4bd1e1c06e2898671284f" translate="yes" xml:space="preserve">
          <source>Complement Expressions</source>
          <target state="translated">보완 표현</target>
        </trans-unit>
        <trans-unit id="13fa3d3fb38078f1c48463c71e72cdb5396d3061" translate="yes" xml:space="preserve">
          <source>Complement the list of characters in &lt;code&gt;from&lt;/code&gt;</source>
          <target state="translated">문자의 목록 보완 &lt;code&gt;from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28e3cfba20327bd23ec2cb2a7627c4989a6658fd" translate="yes" xml:space="preserve">
          <source>ComplementExpression</source>
          <target state="translated">ComplementExpression</target>
        </trans-unit>
        <trans-unit id="f8ad3ce6091208da960c4f9ee62d22e28a03304d" translate="yes" xml:space="preserve">
          <source>Complementary error function</source>
          <target state="translated">보완 오류 기능</target>
        </trans-unit>
        <trans-unit id="60272d7a34e9d3443f3926aeffc1c58edec5ebed" translate="yes" xml:space="preserve">
          <source>Completes in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) steps for ranges that support slicing and have length. Completes in &amp;Omicron;(&lt;code&gt;range.length&lt;/code&gt;) time for all other ranges.</source>
          <target state="translated">슬라이싱을 지원하고 길이가있는 범위에 대해 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 단계로 완료 합니다. 다른 모든 범위에 대해 &amp;Omicron; ( &lt;code&gt;range.length&lt;/code&gt; ) 시간으로 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="c324110011c7213010b1b0d05dbf1729490872c8" translate="yes" xml:space="preserve">
          <source>Complex!F[] &lt;strong id=&quot;fft&quot;&gt;fft&lt;/strong&gt;(F = double, R)(R range);</source>
          <target state="translated">복소수! F [] &lt;strong id=&quot;fft&quot;&gt;fft&lt;/strong&gt; (F = 이중, R) (R 범위);</target>
        </trans-unit>
        <trans-unit id="26f92c913e85906bb3fdfd3ea8f70b3edc75f349" translate="yes" xml:space="preserve">
          <source>Complex!F[] &lt;strong id=&quot;inverseFft&quot;&gt;inverseFft&lt;/strong&gt;(F = double, R)(R range);</source>
          <target state="translated">복소수! F [] &lt;strong id=&quot;inverseFft&quot;&gt;inverseFft&lt;/strong&gt; (F = 이중, R) (R 범위);</target>
        </trans-unit>
        <trans-unit id="d4aa1dc82fea5042746ba87afcfe0abdd31c0457" translate="yes" xml:space="preserve">
          <source>Complex!T &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">복잡하다! T &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bcb9bd086a1d4b769b555d5e43ad8175d34e8e1" translate="yes" xml:space="preserve">
          <source>Complex!T &lt;code&gt;z&lt;/code&gt;</source>
          <target state="translated">복잡한! T &lt;code&gt;z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d89a21ad941e5bb1c1e9e577be9c7a732c2b0200" translate="yes" xml:space="preserve">
          <source>Complex!T &lt;strong id=&quot;proj&quot;&gt;proj&lt;/strong&gt;(T)(Complex!T z);</source>
          <target state="translated">Complex!T &lt;strong id=&quot;proj&quot;&gt;proj&lt;/strong&gt;(T)(Complex!T z);</target>
        </trans-unit>
        <trans-unit id="f564777ac40c723997c5eed12787c64f393c6531" translate="yes" xml:space="preserve">
          <source>Complexity</source>
          <target state="translated">Complexity</target>
        </trans-unit>
        <trans-unit id="47da6f0838f083d3a01f384d483b468a305c5a2c" translate="yes" xml:space="preserve">
          <source>Compose</source>
          <target state="translated">Compose</target>
        </trans-unit>
        <trans-unit id="95aa63ea8e2a3bfd87e37ac5a85ae9bd67fcad2c" translate="yes" xml:space="preserve">
          <source>Composes passed-in functions &lt;code&gt;fun[0], fun[1], ...&lt;/code&gt;.</source>
          <target state="translated">전달 된 함수 &lt;code&gt;fun[0], fun[1], ...&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5c30048c94daf4d26e828fea1daf807749cf7065" translate="yes" xml:space="preserve">
          <source>Composite allocators involving nested instantiations of &lt;code&gt;Segregator&lt;/code&gt; make it difficult to access individual sub-allocators stored within. &lt;code&gt; allocatorForSize&lt;/code&gt; simplifies the task by supplying the allocator nested inside a &lt;code&gt;Segregator&lt;/code&gt; that is responsible for a specific size &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Segregator&lt;/code&gt; 의 중첩 인스턴스화를 포함하는 복합 할당자는 그 안에 저장된 개별 하위 할당 자에 액세스하기 어렵습니다. &lt;code&gt; allocatorForSize&lt;/code&gt; 는 돌며 중첩 된 할당 제공하여 작업을 단순화 &lt;code&gt;Segregator&lt;/code&gt; 특정 크기에 대한 책임 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34ec312f3176cda38964288e354f29e0c4b397f3" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;IAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스를 사용하여 할당자를 구성한 다음 작성된 할당자를 &lt;code&gt;IAllocator&lt;/code&gt; 에 맞게 조정하십시오 ( 아래 &lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; &lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="40c8a933628c77ca08e491a5b2e22d9b1ce4fde0" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;ISharedAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt;&lt;code&gt;CSharedAllocatorImpl&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스를 사용하여 할당자를 구성한 다음 작성된 할당자를 &lt;code&gt;ISharedAllocator&lt;/code&gt; 에 맞게 조정하십시오 ( 아래 &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt; &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; &lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="d7b50cb2c8713f1b5ca6e3a46afeecbf46654a4a" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;RCIAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스 를 사용하여 &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt; 구성한 다음 작성된 할당자를 &lt;code&gt;RCIAllocator&lt;/code&gt; 에 적용하십시오 ( 아래의 allocatorObject 를 사용하여 가능 ).</target>
        </trans-unit>
        <trans-unit id="d600c469ce6615aec4b9ccc9ac99015222a2cd4a" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;RCISharedAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#sharedAllocatorObject&quot;&gt;&lt;code&gt;sharedAllocatorObject&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">동적 인터페이스의 융통성 및 계단식 다중 호출로 인한 비 효율성으로 인해이 레벨에서 할당 자의 구성은 권장되지 않습니다. 대신 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 에&lt;/a&gt; 정의 된 정적 인터페이스를 사용하여 할당자를 구성한 다음 구성된 할당자를 &lt;code&gt;RCISharedAllocator&lt;/code&gt; 에 적용하십시오 ( 아래의 &lt;a href=&quot;#sharedAllocatorObject&quot;&gt; &lt;code&gt;sharedAllocatorObject&lt;/code&gt; &lt;/a&gt; 를 사용하여 가능 ).</target>
        </trans-unit>
        <trans-unit id="b431b82e9bce2d80758c9a0364b1e899b167bca3" translate="yes" xml:space="preserve">
          <source>Compress and return any remaining data. The returned data should be appended to that returned by compress().</source>
          <target state="translated">나머지 데이터를 압축하고 반환하십시오. 반환 된 데이터는 compress ()에 의해 반환 된 데이터에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b91383db4a977df84d9d757e34690eb3fc7d851" translate="yes" xml:space="preserve">
          <source>Compress data</source>
          <target state="translated">데이터 압축</target>
        </trans-unit>
        <trans-unit id="a8dc2c07db65d42c9c393d98f8d9729c6beed681" translate="yes" xml:space="preserve">
          <source>Compress the data in buf and return the compressed data.</source>
          <target state="translated">buf로 데이터를 압축하고 압축 된 데이터를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="89a75f1668dd36d7548c52993ff9cd9810b43d8a" translate="yes" xml:space="preserve">
          <source>Compress/decompress data using the &lt;a href=&quot;http://www.zlib.net&quot;&gt;zlib library&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.zlib.net&quot;&gt;zlib 라이브러리를&lt;/a&gt; 사용하여 데이터를 압축 / 압축 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbe2af0a34e5107b1775ad6a8976ff6c5822f0ee" translate="yes" xml:space="preserve">
          <source>Compress/decompress data using the &lt;a href=&quot;https://www.zlib.net&quot;&gt;zlib library&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80550794074729987ba2c50d10325a6661e3698e" translate="yes" xml:space="preserve">
          <source>Compress/decompress data using the zlib library.</source>
          <target state="translated">zlib 라이브러리를 사용하여 데이터를 압축 / 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="dc10154ed4deb931d65cd3942c615949df575b8c" translate="yes" xml:space="preserve">
          <source>Compression method used by &lt;code&gt;ArchiveMember&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArchiveMember&lt;/code&gt; 에서 사용하는 압축 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="f100b192df1f9c75c6c1d947e071005a9b94874f" translate="yes" xml:space="preserve">
          <source>Compression method used by ArchiveMember</source>
          <target state="translated">ArchiveMember에서 사용하는 압축 방법</target>
        </trans-unit>
        <trans-unit id="9cff7160bc1140411b9344944c01d77d95110520" translate="yes" xml:space="preserve">
          <source>Compression method.</source>
          <target state="translated">압축 방법.</target>
        </trans-unit>
        <trans-unit id="26aaa35645fb564b496958b2c50db8717acc133f" translate="yes" xml:space="preserve">
          <source>CompressionMethod</source>
          <target state="translated">CompressionMethod</target>
        </trans-unit>
        <trans-unit id="937ed94f3a66aa628561e8cb95c083b6199c5b0b" translate="yes" xml:space="preserve">
          <source>CompressionMethod &lt;code&gt;cm&lt;/code&gt;</source>
          <target state="translated">CompressionMethod &lt;code&gt;cm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbc8d8043da3b003c6d2aff42124a5bad20359c0" translate="yes" xml:space="preserve">
          <source>Compute HMAC digests of arbitrary data.</source>
          <target state="translated">임의 데이터의 HMAC 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="95994e5336c058f341ee7887a377a099034ec411" translate="yes" xml:space="preserve">
          <source>Compute MD5 hash of arbitrary data.</source>
          <target state="translated">임의 데이터의 MD5 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="24baedad0dbc82d64549a5102e14973f3260590c" translate="yes" xml:space="preserve">
          <source>Compute MOD bits matching &lt;code&gt;this&lt;/code&gt; argument type to wild parameter type.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 인수 타입을 와일드 파라미터 타입에 일치시키는 MOD 비트를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="081bc30fb0efc1dbeb72897ae1b50df74202f671" translate="yes" xml:space="preserve">
          <source>Compute MurmurHash of arbitrary data.</source>
          <target state="translated">임의 데이터의 MurmurHash를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4ada77a245b8b65254fa2bd2ec7982197684a020" translate="yes" xml:space="preserve">
          <source>Compute RIPEMD-160 hash of arbitrary data.</source>
          <target state="translated">임의 데이터의 RIPEMD-160 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0ba34f35a04123a2ebf02b152eea60a361465caa" translate="yes" xml:space="preserve">
          <source>Compute SHA1 and SHA2 hashes of arbitrary data.</source>
          <target state="translated">임의 데이터의 SHA1 및 SHA2 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="59806efe8816bdf113fe5ffcf24b9d67587999dc" translate="yes" xml:space="preserve">
          <source>Compute column number at the end of the printed form of the string, assuming the string starts in the leftmost column, which is numbered starting from 0.</source>
          <target state="translated">문자열이 맨 왼쪽 열에서 시작하고 0부터 시작하여 번호가 매겨진 것으로 가정하면 인쇄 된 문자열 형식의 끝에서 열 번호를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="39ea6ece3f7ff3bfca84b026b3c00d5558a650d8" translate="yes" xml:space="preserve">
          <source>Compute covariance of parameters &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; as determined by the storage classes of both.</source>
          <target state="translated">둘 다의 스토리지 클래스에 의해 결정된 파라미터 &lt;code&gt;this&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 의 공분산을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="2899928c342104b102c9fb899b2a19b12b7c6b8f" translate="yes" xml:space="preserve">
          <source>Compute digests such as md5, sha1 and crc32.</source>
          <target state="translated">md5, sha1 및 crc32와 같은 계산 다이제스트</target>
        </trans-unit>
        <trans-unit id="114ac47572e156cc9f60194024ceb062761cf170" translate="yes" xml:space="preserve">
          <source>Compute hash function for Object.</source>
          <target state="translated">Object의 계산 해시 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3b9f081e79f23af8321ffcc88ead6e2e02f25fb6" translate="yes" xml:space="preserve">
          <source>Compute n * 2&lt;sup&gt;exp&lt;/sup&gt;</source>
          <target state="translated">계산 n * 2 &lt;sup&gt;exp&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="605710f35eafe733df0dc2a4c0e73d7c711eb032" translate="yes" xml:space="preserve">
          <source>Compute number of elements for a (possibly multidimensional) static array, or 1 for other types.</source>
          <target state="translated">(다차원) 정적 배열의 경우 요소 수를 계산하거나 다른 유형의 경우 1을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="23878574338ad4ed6153fe2d2983bb38e8e88560" translate="yes" xml:space="preserve">
          <source>Compute size of a dt</source>
          <target state="translated">dt의 계산 크기</target>
        </trans-unit>
        <trans-unit id="47dd82c7c7297f6f9c8f6783436ccac77ec97b62" translate="yes" xml:space="preserve">
          <source>Compute square root of x.</source>
          <target state="translated">x의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6810299cd458778af68742dfbad149d1819bc21e" translate="yes" xml:space="preserve">
          <source>Compute the Adler-32 checksum of a buffer's worth of data.</source>
          <target state="translated">버퍼 가치가있는 데이터의 Adler-32 체크섬을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="99c622a401ade4d7e2ebcffe7d148251987300a5" translate="yes" xml:space="preserve">
          <source>Compute the CRC32 checksum of a buffer's worth of data.</source>
          <target state="translated">버퍼에 해당하는 데이터의 CRC32 체크섬을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe16e5290f537eb58bcbe27dcbb8dabf4bc6163" translate="yes" xml:space="preserve">
          <source>Compute the Fourier transform of range using the &amp;Omicron;(&lt;code&gt;N log N&lt;/code&gt;) Cooley-Tukey Algorithm. &lt;code&gt;range&lt;/code&gt; must be a random-access range with slicing and a length equal to &lt;code&gt;size&lt;/code&gt; as provided at the construction of this object. The contents of range can be either numeric types, which will be interpreted as pure real values, or complex types with properties or members &lt;code&gt;.re&lt;/code&gt; and &lt;code&gt;.im&lt;/code&gt; that can be read.</source>
          <target state="translated">&amp;Omicron; ( &lt;code&gt;N log N&lt;/code&gt; ) Cooley-Tukey 알고리즘을 사용하여 범위의 푸리에 변환을 계산합니다 . &lt;code&gt;range&lt;/code&gt; 동일 슬라이싱 및 길이의 랜덤 액세스 범위이어야 &lt;code&gt;size&lt;/code&gt; 객체의 구성에 제공한다. 범위의 내용은 속성 또는 회원과 순수한 실제 값 또는 복합 유형으로 해석됩니다 중 숫자 형식이 될 수 있습니다 &lt;code&gt;.re&lt;/code&gt; 및 &lt;code&gt;.im&lt;/code&gt; 그 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc35381601c0eacc7d756fcdac3f07b01848561" translate="yes" xml:space="preserve">
          <source>Compute the absolute value.</source>
          <target state="translated">절대 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c01ddf497acd77343bfc51afa6a69282e063bf27" translate="yes" xml:space="preserve">
          <source>Compute the power of two integral numbers.</source>
          <target state="translated">두 정수의 거듭 제곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b471c4955a83035411d5b45de39b1b5e1642da44" translate="yes" xml:space="preserve">
          <source>Compute the sum of binary logarithms of the input range &lt;code&gt;r&lt;/code&gt;. The error of this method is much smaller than with a naive sum of log2.</source>
          <target state="translated">입력 범위 &lt;code&gt;r&lt;/code&gt; 의 이진 로그의 합을 계산합니다 . 이 방법의 오류는 순진 합계 log2보다 훨씬 작습니다.</target>
        </trans-unit>
        <trans-unit id="ff38c1a05c708138b2214f90d4dc1a12310dd41c" translate="yes" xml:space="preserve">
          <source>Compute the value of an integer x, raised to the power of a positive integer n.</source>
          <target state="translated">양의 정수 n만큼 거듭 제곱 한 정수 x의 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4f68d18423d62869cea6398c61a35fc2726681da" translate="yes" xml:space="preserve">
          <source>Compute the value of x &lt;sup&gt;n&lt;/sup&gt;, where n is an integer</source>
          <target state="translated">x &lt;sup&gt;n&lt;/sup&gt; 의 값을 계산합니다 . 여기서 n은 정수입니다.</target>
        </trans-unit>
        <trans-unit id="77fc143961f9dbeaf572c0de2cdcd8820a0f8972" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/Entropy_(information_theory)&quot;&gt;entropy&lt;/a&gt; of input range &lt;code&gt;r&lt;/code&gt; in bits. This function assumes (without checking) that the values in &lt;code&gt;r&lt;/code&gt; are all in &lt;code&gt;[0, 1]&lt;/code&gt;. For the entropy to be meaningful, often &lt;code&gt;r&lt;/code&gt; should be normalized too (i.e., its values should sum to 1). The two-parameter version stops evaluating as soon as the intermediate result is greater than or equal to &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">입력 범위 &lt;code&gt;r&lt;/code&gt; 의&lt;a href=&quot;https://en.wikipedia.org/wiki/Entropy_(information_theory)&quot;&gt;엔트로피&lt;/a&gt; 를 비트 단위로 계산 합니다 . 이 함수는 (확인하지 않고) &lt;code&gt;r&lt;/code&gt; 의 값 이 모두 &lt;code&gt;[0, 1]&lt;/code&gt; 있다고 가정합니다 . 엔트로피가 의미를 갖기 위해서는 종종 &lt;code&gt;r&lt;/code&gt; 도 정규화해야합니다 (즉, 그 값의 합은 1이어야 함). 중간 결과가 &lt;code&gt;max&lt;/code&gt; 이상이되는 즉시 2- 파라미터 버전의 평가가 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="296843c88206c491563d4a7f5e7016600d230563" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_distance&quot;&gt;Euclidean distance&lt;/a&gt; between input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. The three-parameter version stops computation as soon as the distance is greater than or equal to &lt;code&gt;limit&lt;/code&gt; (this is useful to save computation if a small distance is sought).</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_distance&quot;&gt;유클리드 거리&lt;/a&gt; 를 계산합니다 . 두 범위의 길이는 같아야합니다. 3- 파라미터 버전은 거리가 &lt;code&gt;limit&lt;/code&gt; 보다 크거나 같은 즉시 계산을 중지 합니다 (작은 거리를 찾는 경우 계산을 저장하는 데 유용함).</target>
        </trans-unit>
        <trans-unit id="e8687c4446d77dec6b0783c73ae0c35b758b4e36" translate="yes" xml:space="preserve">
          <source>Computes &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash&quot;&gt;MurmurHash&lt;/a&gt; hashes of arbitrary data. MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. It is optimized for x86 but can be used on all architectures.</source>
          <target state="translated">임의 데이터의 &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash&quot;&gt;MurmurHash&lt;/a&gt; 해시를 계산 합니다. MurmurHash는 일반 해시 기반 조회에 적합한 비 암호화 해시 기능입니다. x86에 최적화되어 있지만 모든 아키텍처에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1c57bf08f15b670eca8f41ce0168ced47af851" translate="yes" xml:space="preserve">
          <source>Computes Cartesian product of two ranges.</source>
          <target state="translated">두 범위의 데카르트 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fb193027e232a8b400c045bedc504035cc557cce" translate="yes" xml:space="preserve">
          <source>Computes MD5 hashes of arbitrary data. MD5 hashes are 16 byte quantities that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 MD5 해시를 계산합니다. MD5 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 16 바이트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="5579e2951cd84cd7814305254794db678509d171" translate="yes" xml:space="preserve">
          <source>Computes RIPEMD-160 hashes of arbitrary data. RIPEMD-160 hashes are 20 byte quantities that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 RIPEMD-160 해시를 계산합니다. RIPEMD-160 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 20 바이트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="b03ce1bab59ab2d228bb375354ca2f56fee8c218" translate="yes" xml:space="preserve">
          <source>Computes SHA1 and SHA2 hashes of arbitrary data. SHA hashes are 20 to 64 byte quantities (depending on the SHA algorithm) that are like a checksum or CRC, but are more robust.</source>
          <target state="translated">임의 데이터의 SHA1 및 SHA2 해시를 계산합니다. SHA 해시는 체크섬 또는 CRC와 유사하지만보다 강력한 20-64 바이트 (SHA 알고리즘에 따라 다름) 수량입니다.</target>
        </trans-unit>
        <trans-unit id="e7873407fccab092da69ee0890f41357999dc857" translate="yes" xml:space="preserve">
          <source>Computes a hash of the instance of a type.</source>
          <target state="translated">유형 인스턴스의 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="82604089c1a3a9639da1f3dad4ff14761ed55648" translate="yes" xml:space="preserve">
          <source>Computes a subrange of &lt;code&gt;range&lt;/code&gt; starting at the first occurrence of &lt;code&gt;range&lt;/code&gt;'s minimum (respectively maximum) and with the same ending as &lt;code&gt;range&lt;/code&gt;, or the empty range if &lt;code&gt;range&lt;/code&gt; itself is empty.</source>
          <target state="translated">부분 범위의 계산 &lt;code&gt;range&lt;/code&gt; 의 처음부터 발생 &lt;code&gt;range&lt;/code&gt; 의 최소값 (각각 최대) '과 동일한 결말 &lt;code&gt;range&lt;/code&gt; 않거나 빈 영역 &lt;code&gt;range&lt;/code&gt; 자체가 비어있다.</target>
        </trans-unit>
        <trans-unit id="b28e3792ae1738b85ec20e79a7ef0f511b39b00f" translate="yes" xml:space="preserve">
          <source>Computes an index for &lt;code&gt;r&lt;/code&gt; based on the comparison &lt;code&gt;less&lt;/code&gt;. The index is a sorted array of pointers or indices into the original range. This technique is similar to sorting, but it is more flexible because (1) it allows &quot;sorting&quot; of immutable collections, (2) allows binary search even if the original collection does not offer random access, (3) allows multiple indexes, each on a different predicate, and (4) may be faster when dealing with large objects. However, using an index may also be slower under certain circumstances due to the extra indirection, and is always larger than a sorting-based solution because it needs space for the index in addition to the original collection. The complexity is the same as &lt;code&gt;sort&lt;/code&gt;'s.</source>
          <target state="translated">&lt;code&gt;less&lt;/code&gt; 비교를 기반으로 &lt;code&gt;r&lt;/code&gt; 에 대한 인덱스를 계산합니다 . 인덱스는 원래 범위로 정렬 된 포인터 또는 인덱스의 배열입니다. 이 기술은 정렬과 유사하지만 (1) 변경 불가능한 콜렉션의 &quot;정렬&quot;을 허용하고 (2) 원래 콜렉션이 무작위 액세스를 제공하지 않더라도 2 진 검색을 허용하고 (3) 각각 여러 인덱스를 허용하므로보다 유연합니다. 다른 술어에서 (4) 큰 오브젝트를 처리 할 때 더 빠를 수 있습니다. 그러나 추가 간접적으로 인해 특정 환경에서는 인덱스 사용이 느려질 수 있으며 원본 컬렉션 외에 인덱스를위한 공간이 필요하기 때문에 정렬 기반 솔루션보다 항상 더 큽니다. 복잡성은 &lt;code&gt;sort&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="92f85def44d73b410c07064bdb1637d1fdade94c" translate="yes" xml:space="preserve">
          <source>Computes integer to floating point powers.</source>
          <target state="translated">정수를 부동 소수점으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="828dda1e22c2f096a88e923fc1bc2efd10471f59" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;cosine similarity&lt;/a&gt; of input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. If both ranges define length, the check is done once; otherwise, it is done at each iteration. If either range has all-zero elements, return 0.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cosine_similarity&quot;&gt;코사인 유사성&lt;/a&gt; 을 계산합니다 . 두 범위의 길이는 같아야합니다. 두 범위가 모두 길이를 정의하면 점검이 한 번 수행됩니다. 그렇지 않으면 각 반복에서 수행됩니다. 두 범위 중 하나에 모두 0의 요소가 있으면 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="001e06c86d6d760ab7657dfb18427574bae02730" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dot_product&quot;&gt;dot product&lt;/a&gt; of input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The two ranges must have the same length. If both ranges define length, the check is done once; otherwise, it is done at each iteration.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dot_product&quot;&gt;내적을&lt;/a&gt; 계산합니다 . 두 범위의 길이는 같아야합니다. 두 범위가 모두 길이를 정의하면 점검이 한 번 수행됩니다. 그렇지 않으면 각 반복에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf4ed97371360235833e69216aba07328958d9e" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence&quot;&gt;Jensen-Shannon divergence&lt;/a&gt; between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, which is the sum &lt;code&gt;(ai * log(2 * ai / (ai + bi)) + bi * log(2 * bi / (ai + bi))) / 2&lt;/code&gt;. The base of logarithm is 2. The ranges are assumed to contain elements in &lt;code&gt;[0, 1]&lt;/code&gt;. Usually the ranges are normalized probability distributions, but this is not required or checked by &lt;code&gt;jensenShannonDivergence&lt;/code&gt;. If the inputs are normalized, the result is bounded within &lt;code&gt;[0, 1]&lt;/code&gt;. The three-parameter version stops evaluations as soon as the intermediate result is greater than or equal to &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence&quot;&gt;Jensen-Shannon 분기 발산을&lt;/a&gt; 계산합니다. 이 합은 &lt;code&gt;(ai * log(2 * ai / (ai + bi)) + bi * log(2 * bi / (ai + bi))) / 2&lt;/code&gt; 입니다. 로그의 밑은 2입니다. 범위는 &lt;code&gt;[0, 1]&lt;/code&gt; 요소를 포함한다고 가정합니다 . 일반적으로 범위는 정규화 된 확률 분포이지만 &lt;code&gt;jensenShannonDivergence&lt;/code&gt; 는이를 요구하거나 확인하지 않습니다 . 입력이 정규화되면 결과는 &lt;code&gt;[0, 1]&lt;/code&gt; 내로 제한됩니다 . 3 개 매개 변수 버전은 중간 결과가 &lt;code&gt;limit&lt;/code&gt; 보다 크거나 같으면 평가를 중지 합니다 .</target>
        </trans-unit>
        <trans-unit id="bccc93152f84cfb32d87abe05334a1cc08f473ea" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;&gt;Kullback-Leibler divergence&lt;/a&gt; between input ranges &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, which is the sum &lt;code&gt;ai * log(ai / bi)&lt;/code&gt;. The base of logarithm is 2. The ranges are assumed to contain elements in &lt;code&gt;[0, 1]&lt;/code&gt;. Usually the ranges are normalized probability distributions, but this is not required or checked by &lt;code&gt;kullbackLeiblerDivergence&lt;/code&gt;. If any element &lt;code&gt;bi&lt;/code&gt; is zero and the corresponding element &lt;code&gt;ai&lt;/code&gt; nonzero, returns infinity. (Otherwise, if &lt;code&gt;ai == 0 &amp;amp;&amp;amp; bi == 0&lt;/code&gt;, the term &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; is considered zero.) If the inputs are normalized, the result is positive.</source>
          <target state="translated">입력 범위 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;&gt;Kullback-Leibler 발산을&lt;/a&gt; 계산합니다 . 이는 합 &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; 입니다. 로그의 밑은 2입니다. 범위는 &lt;code&gt;[0, 1]&lt;/code&gt; 요소를 포함한다고 가정합니다 . 일반적으로 범위는 정규화 된 확률 분포이지만 &lt;code&gt;kullbackLeiblerDivergence&lt;/code&gt; 는 필수 또는 점검하지 않습니다 . 요소 &lt;code&gt;bi&lt;/code&gt; 가 0이고 해당 요소 &lt;code&gt;ai&lt;/code&gt; 가 0이 아닌 경우 무한대를 반환합니다. (그렇지 않으면 &lt;code&gt;ai == 0 &amp;amp;&amp;amp; bi == 0&lt;/code&gt; 이면 &lt;code&gt;ai * log(ai / bi)&lt;/code&gt; 은 0으로 간주됩니다.) 입력이 정규화되면 결과는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="82f8a61e8d0a5e2c407cc15d0dc98d8a7c77f454" translate="yes" xml:space="preserve">
          <source>Computes the greatest common divisor of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; by using an efficient algorithm such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_algorithm&quot;&gt;Euclid's&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_GCD_algorithm&quot;&gt;Stein's&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_algorithm&quot;&gt;Euclid&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_GCD_algorithm&quot;&gt;Stein&lt;/a&gt; 알고리즘과 같은 효율적인 알고리즘을 사용하여 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 최대 공약수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="62daeb05222388ac697dc74b9f37d3d0822c2a6e" translate="yes" xml:space="preserve">
          <source>Computes the hash of the held value.</source>
          <target state="translated">보류 값의 해시를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="265e1e72bdf2f361616fec34db23103d27bf2241" translate="yes" xml:space="preserve">
          <source>Computes the index of the first occurrence of &lt;code&gt;range&lt;/code&gt;'s maximum element.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 최대 요소 가 처음 나타나는 인덱스를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="355f343fa9f1a69e378af49768a7655e8cf9c6b9" translate="yes" xml:space="preserve">
          <source>Computes the index of the first occurrence of &lt;code&gt;range&lt;/code&gt;'s minimum element.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 최소 ​​요소 가 처음 나타나는 인덱스를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="23157290f28401c16bb054d1176e6a8721bc9834" translate="yes" xml:space="preserve">
          <source>Computes the inverse Fourier transform of a range. The range must be a random access range with slicing, have a length equal to the size provided at construction of this object, and contain elements that are either of type std.complex.Complex or have essentially the same compile-time interface.</source>
          <target state="translated">범위의 역 푸리에 변환을 계산합니다. 범위는 슬라이싱을 사용하는 임의의 액세스 범위 여야하고이 객체를 구성 할 때 제공되는 크기와 길이가 동일해야하며 std.complex.Complex 유형이거나 본질적으로 동일한 컴파일 타임 인터페이스를 가진 요소를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4770977a60d3756b3fc642893a20b59f0fe70f5" translate="yes" xml:space="preserve">
          <source>Computes the length of any range in O(n) time.</source>
          <target state="translated">O (n) 시간으로 범위의 길이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a53d2cd20ccb22bc201e56bc6c6a7059b3ec842d" translate="yes" xml:space="preserve">
          <source>Computes the length of grapheme cluster starting at &lt;code&gt;index&lt;/code&gt;. Both the resulting length and the &lt;code&gt;index&lt;/code&gt; are measured in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 에서 시작하는 grapheme 클러스터의 길이를 계산합니다 . 결과 길이와 &lt;code&gt;index&lt;/code&gt; 은 모두 &lt;a href=&quot;#Code%20unit&quot;&gt;코드 단위&lt;/a&gt; 로 측정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a5a9de63581b03924af8f2c2bbd32e205910376" translate="yes" xml:space="preserve">
          <source>Computes the match of the popFront length. Completes in &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time.</source>
          <target state="translated">popFront 길이의 일치를 계산합니다. &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) 시간으로 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="3d970629c10f34f68e73440748e21b623f859402" translate="yes" xml:space="preserve">
          <source>Computes the minimum (respectively maximum) of &lt;code&gt;range&lt;/code&gt; along with its number of occurrences. Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">발생 횟수와 함께 &lt;code&gt;range&lt;/code&gt; 의 최소 ​​(각각 최대)를 계산합니다 . 공식적으로 최소 값이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(a, x)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; . 반대로, 최대 값이며 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(x, a)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; (의 교환 인자 유의 &lt;code&gt;pred&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef86bb558e70e54418dec649b83e309302fe4774" translate="yes" xml:space="preserve">
          <source>Computes the next lexicographically greater even permutation of a range in-place.</source>
          <target state="translated">범위 내에서 다음 사전 사전 순으로 더 큰 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c939037e683052e11796212630e886a0f710fc91" translate="yes" xml:space="preserve">
          <source>Computes the next lexicographically greater permutation of a range in-place.</source>
          <target state="translated">범위 내 다음 사전 순으로 더 큰 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0ac0eb054effc8e964f179add51ac8ce5cde0817" translate="yes" xml:space="preserve">
          <source>Computes the nth permutation of a range in-place.</source>
          <target state="translated">전체 범위의 n 번째 순열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7776b0304fc7917421d0069aa2e2faee1db476d1" translate="yes" xml:space="preserve">
          <source>Computes the union of a range of sorted ranges.</source>
          <target state="translated">정렬 된 범위의 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cb77e0d53b3af1bb492d078444229137406cc49e" translate="yes" xml:space="preserve">
          <source>Computes the union of multiple ranges. The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input ranges&lt;/a&gt; are passed as a range of ranges and each is assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Computation is done lazily, one union element at a time. &lt;code&gt;multiwayUnion(ror)&lt;/code&gt; is functionally equivalent to &lt;code&gt;multiwayMerge(ror).uniq&lt;/code&gt;.</source>
          <target state="translated">여러 범위의 합집합을 계산합니다. &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 범위의 범위로 전달되고, 각각으로 분류되는 것으로 가정 &lt;code&gt;less&lt;/code&gt; . 계산은 한 번에 하나의 공용체 요소로 느리게 수행됩니다. &lt;code&gt;multiwayUnion(ror)&lt;/code&gt; 은 기능적으로 &lt;code&gt;multiwayMerge(ror).uniq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a126dbb5dda187ebb7d5104cb58f176f39bc7db" translate="yes" xml:space="preserve">
          <source>Computes the value of a positive integer &lt;code&gt;x&lt;/code&gt;, raised to the power &lt;code&gt;n&lt;/code&gt;, modulo &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">양의 정수 &lt;code&gt;x&lt;/code&gt; 값을 거듭 제곱 &lt;code&gt;n&lt;/code&gt; , 모듈로 &lt;code&gt;m&lt;/code&gt; 으로 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="5b267e5f3dfcaf722a685eb900169bb377c96955" translate="yes" xml:space="preserve">
          <source>Computes whether a values is approximately equal to a reference value, admitting a maximum relative difference, and a maximum absolute difference.</source>
          <target state="translated">값이 기준 값과 거의 같은지 여부를 계산하고 최대 상대 차이 및 최대 절대 차이를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="04fa1754d0f3ba8b19daaf72ab1060db4c420591" translate="yes" xml:space="preserve">
          <source>Computes whether two values are approximately equal, admitting a maximum relative difference, and a maximum absolute difference.</source>
          <target state="translated">최대 상대 차이와 최대 절대 차이를 허용하여 두 값이 대략 같은지 여부를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="90f1bfbd09f8811922bf824de5a2cde80eff4934" translate="yes" xml:space="preserve">
          <source>Computing array lengths during compilation</source>
          <target state="translated">컴파일하는 동안 배열 길이 계산</target>
        </trans-unit>
        <trans-unit id="ed0c24b1a7f07e9baa4b3d7d42eace24ae7358ef" translate="yes" xml:space="preserve">
          <source>Concatenate Tuples. Tuple concatenation is only allowed if all named fields are distinct (no named field of this tuple occurs in &lt;code&gt;t&lt;/code&gt; and no named field of &lt;code&gt;t&lt;/code&gt; occurs in this tuple).</source>
          <target state="translated">튜플을 연결하십시오. 튜플 연결은 모든 명명 된 필드가 고유 한 경우에만 허용됩니다 (이 튜플의 명명 된 필드는 &lt;code&gt;t&lt;/code&gt; 에서 발생 하지 않으며 &lt;code&gt;t&lt;/code&gt; 의 명명 된 필드는이 튜플에서 발생 하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="c1cbdd888810a65f9ce252092149adeb11bad0f8" translate="yes" xml:space="preserve">
          <source>Concatenate multiple &lt;code&gt;escapeShellCommand&lt;/code&gt; and &lt;a href=&quot;#escapeShellFileName&quot;&gt;&lt;code&gt;escapeShellFileName&lt;/code&gt;&lt;/a&gt; results to use shell redirection or piping operators.</source>
          <target state="translated">쉘 재 지정 또는 파이핑 연산자를 사용하기 위해 여러 &lt;code&gt;escapeShellCommand&lt;/code&gt; 및 &lt;a href=&quot;#escapeShellFileName&quot;&gt; &lt;code&gt;escapeShellFileName&lt;/code&gt; &lt;/a&gt; 결과를 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef92b5ecddb9c03ee25b9741d86e91adf28ae5ee" translate="yes" xml:space="preserve">
          <source>Concatenate path segments together to form one path.</source>
          <target state="translated">경로 세그먼트를 함께 연결하여 하나의 경로를 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="fbbbf15264cd015326c8650e5c9bcfe45679594d" translate="yes" xml:space="preserve">
          <source>Concatenate tuples</source>
          <target state="translated">튜플 연결</target>
        </trans-unit>
        <trans-unit id="d334da4f36d3ac970a49b9c6ff3d38de0a94daec" translate="yes" xml:space="preserve">
          <source>Concatenate two lists (l2 appended to l1).</source>
          <target state="translated">두 목록을 연결하십시오 (l1이 l1에 추가됨).</target>
        </trans-unit>
        <trans-unit id="54605f22a1f1252b76de960747267c3c0603476d" translate="yes" xml:space="preserve">
          <source>Concatenates a range of ranges into one array.</source>
          <target state="translated">범위의 범위를 하나의 배열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="09f32ec319e44bc6f468a74c63ca6c7d780d7a7f" translate="yes" xml:space="preserve">
          <source>Concatenates several ranges into a single range.</source>
          <target state="translated">여러 범위를 단일 범위로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aba48fb5ee4afc0282b513e1b8419e115676e665" translate="yes" xml:space="preserve">
          <source>Concatenating the arrays inside of &lt;code&gt;arrs&lt;/code&gt;. &lt;code&gt;_d_arraycatnTX([a, b, c])&lt;/code&gt; means &lt;code&gt;a ~ b ~ c&lt;/code&gt;.</source>
          <target state="translated">내부의 배열을 연결 &lt;code&gt;arrs&lt;/code&gt; . &lt;code&gt;_d_arraycatnTX([a, b, c])&lt;/code&gt; 는 &lt;code&gt;a ~ b ~ c&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="1fd32d36258eae30e3a703b388fd2d676ac083d9" translate="yes" xml:space="preserve">
          <source>Concatenation always creates a copy of its operands, even if one of the operands is a 0 length array, so:</source>
          <target state="translated">피연산자 중 하나가 0 길이 배열 인 경우에도 연결은 항상 피연산자의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8bfdaed1fe3ba5044986f54f678261c455c4286e" translate="yes" xml:space="preserve">
          <source>Concatenation and appending</source>
          <target state="translated">연결 및 추가</target>
        </trans-unit>
        <trans-unit id="f307354edc327002aff0696b23e699bed6b0337f" translate="yes" xml:space="preserve">
          <source>Conceptual type that outlines the common properties of all UTF Matchers.</source>
          <target state="translated">모든 UTF 매처의 공통 특성을 설명하는 개념적 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="368834630d459ecc51471d8ef1eb3550a7af82cb" translate="yes" xml:space="preserve">
          <source>Conditional Compilation</source>
          <target state="translated">조건부 컴파일</target>
        </trans-unit>
        <trans-unit id="8a0d63179619b501ad5800876cf0df368b27a390" translate="yes" xml:space="preserve">
          <source>Conditional Expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="02b96d4c9fbd3a91b071d3d53be1d37274828f1c" translate="yes" xml:space="preserve">
          <source>Conditional Logging</source>
          <target state="translated">조건부 로깅</target>
        </trans-unit>
        <trans-unit id="61fb1fb5259174d8968cdd64b4b930f65a905d82" translate="yes" xml:space="preserve">
          <source>Conditional compilation</source>
          <target state="translated">조건부 컴파일</target>
        </trans-unit>
        <trans-unit id="41d7d233afb0dd68d28fc8f570d341d5c22d2172" translate="yes" xml:space="preserve">
          <source>Conditional logging can be achieved be passing a &lt;code&gt;bool&lt;/code&gt; as first argument to a log function. If conditional logging is used the condition must be &lt;code&gt;true&lt;/code&gt; in order to have the log message logged.  In order to combine an explicit &lt;code&gt;LogLevel&lt;/code&gt; passing with conditional logging, the &lt;code&gt;LogLevel&lt;/code&gt; has to be passed as first argument followed by the &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">조건부 로깅은 &lt;code&gt;bool&lt;/code&gt; 을 첫 번째 인수로 로그 함수에 전달하여 얻을 수 있습니다 . 조건부 로깅을 사용하는 경우 로그 메시지를 로깅 하려면 조건이 &lt;code&gt;true&lt;/code&gt; 여야합니다 . 명시 적으로 결합하기 위하여 &lt;code&gt;LogLevel&lt;/code&gt; 에 조건부 로깅 지나가는 상기 &lt;code&gt;LogLevel&lt;/code&gt; 첫번째 인자는 다음과 같이 전달되어야 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e9b71968760fc03c2bd272ee9bbb297247e44ef" translate="yes" xml:space="preserve">
          <source>ConditionalDeclaration</source>
          <target state="translated">ConditionalDeclaration</target>
        </trans-unit>
        <trans-unit id="c5b4a55bf44bb04ff293c5deb38688769ac299cf" translate="yes" xml:space="preserve">
          <source>ConditionalStatement</source>
          <target state="translated">ConditionalStatement</target>
        </trans-unit>
        <trans-unit id="2cda11f185fbbbe7d23cfc89fd493405e9cae9a1" translate="yes" xml:space="preserve">
          <source>Config &lt;code&gt;config&lt;/code&gt;</source>
          <target state="translated">구성 &lt;code&gt;config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="06610b8b075f898940036a6adb700398270f1776" translate="yes" xml:space="preserve">
          <source>Configuration options for &lt;code&gt;getopt&lt;/code&gt;.</source>
          <target state="translated">에 대한 구성 옵션 &lt;code&gt;getopt&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="a6431b321225e094a850e4edc49d8a1243e81cc7" translate="yes" xml:space="preserve">
          <source>Configuration options for druntime.</source>
          <target state="translated">druntime에 대한 구성 옵션.</target>
        </trans-unit>
        <trans-unit id="1b3ac33acfeded0c91e96d651db32f59b33bf43d" translate="yes" xml:space="preserve">
          <source>Configuration via the command line can be disabled by declaring a variable for the linker to pick up before using it's default from the runtime:</source>
          <target state="translated">런타임에서 기본값을 사용하기 전에 링커가 선택할 변수를 선언하여 명령 줄을 통한 구성을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c549a207a37db7214dfa5f6be06a12b29fcccee0" translate="yes" xml:space="preserve">
          <source>Configuration via the command line can be disabled by declaring a variable for the linker to pick up before using its default from the runtime:</source>
          <target state="translated">런타임에서 기본값을 사용하기 전에 링커가 선택할 변수를 선언하여 명령 줄을 통한 구성을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">자동 검사 점 구성</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">데이터베이스 연결 구성</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 구성</target>
        </trans-unit>
        <trans-unit id="6c9652511df81d8bc126592a1f7ea6652bb3ab73" translate="yes" xml:space="preserve">
          <source>Configuring the Garbage Collector</source>
          <target state="translated">가비지 콜렉터 구성</target>
        </trans-unit>
        <trans-unit id="76ad8dda0a203dcd9a14445916230e10df73a7f3" translate="yes" xml:space="preserve">
          <source>Confirm s is a valid template, then store it.</source>
          <target state="translated">s가 유효한 템플리트인지 확인한 후 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="db012c464d251d67ffbcac09777d640d209be8dd" translate="yes" xml:space="preserve">
          <source>Confirm whether this stopwatch is measuring time.</source>
          <target state="translated">이 스톱워치가 시간을 측정하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="788ef0c8e55eab85066dfba32db7ceacb60c9712" translate="yes" xml:space="preserve">
          <source>Conflation of different memory pools:</source>
          <target state="translated">다른 메모리 풀의 혼합 :</target>
        </trans-unit>
        <trans-unit id="841a7cce211d41301505ff131d9f016fac1e6279" translate="yes" xml:space="preserve">
          <source>Conforms to IEEE 754-2008</source>
          <target state="translated">IEEE 754-2008 준수</target>
        </trans-unit>
        <trans-unit id="8d2931da0a4a255003ce81824b3d90572948d6f8" translate="yes" xml:space="preserve">
          <source>Conforms to the Microsoft Windows Structured Exception Handling conventions.</source>
          <target state="translated">Microsoft Windows 구조적 예외 처리 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="bad8df68294c8ab2277b9345f70f577dbf3c8959" translate="yes" xml:space="preserve">
          <source>Conforms to the target's C ABI struct layout.</source>
          <target state="translated">대상의 C ABI 구조체 레이아웃을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="49578a731259515bbadf31f422528ce8c4631b50" translate="yes" xml:space="preserve">
          <source>Conn &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">코네티컷의 &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0474ba2f1ee3e396c97ac1ac34d1d19ad3689dae" translate="yes" xml:space="preserve">
          <source>Connection encoding. Defaults to ISO-8859-1.</source>
          <target state="translated">연결 인코딩. 기본값은 ISO-8859-1입니다.</target>
        </trans-unit>
        <trans-unit id="519ecd274822b5f9ddc30ae246a94167b56bf039" translate="yes" xml:space="preserve">
          <source>Connection type used when the URL should be used to auto detect the protocol. This struct is used as placeholder for the connection parameter when calling the high level API and the connection type (HTTP/FTP) should be guessed by inspecting the URL parameter. The rules for guessing the protocol are: 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed. 2, HTTP connection otherwise.</source>
          <target state="translated">프로토콜을 자동 감지하기 위해 URL을 사용해야 할 때 사용되는 연결 유형입니다. 이 구조체는 고급 API를 호출 할 때 연결 매개 변수의 자리 표시 자로 사용되며 URL 매개 변수를 검사하여 연결 유형 (HTTP / FTP)을 추측해야합니다. 프로토콜을 추측하기위한 규칙은 다음과 같습니다. 1, URL이 ftp : //, ftps : // 또는 ftp로 시작하는 경우. FTP 연결이 가정됩니다. 그렇지 않으면 2, HTTP 연결.</target>
        </trans-unit>
        <trans-unit id="078912762bea745ba2c41bae707b195db48327c8" translate="yes" xml:space="preserve">
          <source>Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order</source>
          <target state="translated">최대 길이가 고정 된 연결이없고 신뢰할 수없는 데이터 그램 데이터가 손실되거나 고장난 경우</target>
        </trans-unit>
        <trans-unit id="d929792a86b18c9fb89df6aef5598294f6328000" translate="yes" xml:space="preserve">
          <source>Connector_Punctuation</source>
          <target state="translated">Connector_Punctuation</target>
        </trans-unit>
        <trans-unit id="a30b51b4925a7ede0792face17a4f0e9710a0252" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;getAddress&lt;/code&gt;, &lt;code&gt;parseAddress&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt; methods instead of using this class directly.</source>
          <target state="translated">사용을 고려 &lt;code&gt;getAddress&lt;/code&gt; 에 , &lt;code&gt;parseAddress&lt;/code&gt; 및 &lt;code&gt;Address&lt;/code&gt; 방법 대신이 클래스를 사용하여.</target>
        </trans-unit>
        <trans-unit id="9810660bbdff1aae34eac15a7facdded0db22668" translate="yes" xml:space="preserve">
          <source>Const Member Functions</source>
          <target state="translated">Const 멤버 함수</target>
        </trans-unit>
        <trans-unit id="83dcf3de7eb019ec6629bbd79f8b667634364e18" translate="yes" xml:space="preserve">
          <source>Const Storage Class</source>
          <target state="translated">콘 스트 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="3d742d8dde06f988077f8f82f51f498a3531d234" translate="yes" xml:space="preserve">
          <source>Const Type</source>
          <target state="translated">콘 스트 타입</target>
        </trans-unit>
        <trans-unit id="784fed24b477710eef1f5226f481179174928151" translate="yes" xml:space="preserve">
          <source>Const and Immutable</source>
          <target state="translated">불변과 불변</target>
        </trans-unit>
        <trans-unit id="896cf932e98b76529cba660f6f6a0543fea0acaa" translate="yes" xml:space="preserve">
          <source>Const and Immutable Interfaces</source>
          <target state="translated">불변 및 불변 인터페이스</target>
        </trans-unit>
        <trans-unit id="9069f2cf93e274994d11feade6815e9fb488f82d" translate="yes" xml:space="preserve">
          <source>Const array is converted to input range by removing its qualifier.</source>
          <target state="translated">Const 배열은 한정자를 제거하여 입력 범위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f40015b781b2d4acdb42042e30dd8e0561ab4289" translate="yes" xml:space="preserve">
          <source>Const member functions are functions that are not allowed to change any part of the object through the member function's this reference.</source>
          <target state="translated">Const 멤버 함수는 멤버 함수의이 참조를 통해 객체의 일부를 변경할 수없는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2250093f69faa6a58322166f59cb9d509a15db57" translate="yes" xml:space="preserve">
          <source>Const types are like immutable types, except that const forms a read-only</source>
          <target state="translated">const 유형은 불변 유형과 유사하지만 const는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="cc17a30efd81f4b6809eff7a896b92f5876f25e3" translate="yes" xml:space="preserve">
          <source>Const, Immutable Comparison</source>
          <target state="translated">불변의 불변 비교</target>
        </trans-unit>
        <trans-unit id="b27c2428c75022095914c42cb3f655e37a5625b8" translate="yes" xml:space="preserve">
          <source>Const, Immutable and Shared Classes</source>
          <target state="translated">불변의 공유 클래스</target>
        </trans-unit>
        <trans-unit id="8681eda928fe17b6615fbb79a2dc733c8ebaba94" translate="yes" xml:space="preserve">
          <source>Const, Immutable and Shared Structs</source>
          <target state="translated">불변의 공유 구조</target>
        </trans-unit>
        <trans-unit id="6c73b65a7e00144e4a4cd7b116f22177ab58213a" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x0085) - next line.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x0085)-다음 줄.</target>
        </trans-unit>
        <trans-unit id="ee9a92399d6335bc2aeede4d454001baa024aaf3" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x2028) - line separator.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x2028)-줄 구분 기호</target>
        </trans-unit>
        <trans-unit id="d9cdea9445ed1d8ad134d40b5e8dd40f3350c441" translate="yes" xml:space="preserve">
          <source>Constant &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; (0x2029) - paragraph separator.</source>
          <target state="translated">상수 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; (0x2029)-단락 구분 기호</target>
        </trans-unit>
        <trans-unit id="ae1de1f3ec7fd1e298252331c9256b1f73d60516" translate="yes" xml:space="preserve">
          <source>Constant defining a fully decoded BOM</source>
          <target state="translated">완전히 디코딩 된 BOM을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="513fd3be0bfd521c00e6fe601132e59539268d57" translate="yes" xml:space="preserve">
          <source>Constant fold an Expression.</source>
          <target state="translated">식을 일정하게 접습니다.</target>
        </trans-unit>
        <trans-unit id="3db4fce387c01b326d3e15a975e8b04f8af06c7c" translate="yes" xml:space="preserve">
          <source>Constant folded version of &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 일정한 접힌 버전</target>
        </trans-unit>
        <trans-unit id="9c1d160235265d86d921f707d3ce59f58aed4954" translate="yes" xml:space="preserve">
          <source>Constant folding, with support for CTFE Return true if non-pointer expression e can be compared with &amp;gt;,is, ==, etc, using ctfeCmp, ctfeEqual, ctfeIdentity</source>
          <target state="translated">CTFE를 지원하는 상수 폴딩 ctfeCmp, ctfeEqual, ctfeIdentity를 사용하여 비 포인터 식 e를&amp;gt;, is, == 등과 비교할 수 있으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">특수 소멸자 동작을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="cdd87b7907fb17673e884c148848c9c5e93b59ca" translate="yes" xml:space="preserve">
          <source>Constraint</source>
          <target state="translated">Constraint</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="cd7dc62d6119143cd2fd7c7185b12b70cf0749f3" translate="yes" xml:space="preserve">
          <source>Construct 256 character translation table, where characters in from[] are replaced by corresponding characters in to[].</source>
          <target state="translated">from []의 문자가 to []의 해당 문자로 대체되는 256 자 변환 표를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5de02eef75a505103dd6a73f454b30bd0638b7c9" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a ISO time string</source>
          <target state="translated">구성체 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; ISO 시간 문자열</target>
        </trans-unit>
        <trans-unit id="cef526ef10de16815aa0c9df0e5fee07dd4e2470" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from a built-in integral type.</source>
          <target state="translated">컨스 &lt;code&gt;BigInt&lt;/code&gt; 일체형으로 내장에서.</target>
        </trans-unit>
        <trans-unit id="d5b5175be9d000ff28745ca7b47dfab50bb5237b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from a decimal or hexadecimal string. The number must be in the form of a decimal or hex literal. It may have a leading &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign, followed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt; if hexadecimal. Underscores are permitted in any location after the &lt;code&gt;0x&lt;/code&gt; and/or the sign of the number.</source>
          <target state="translated">구성체 &lt;code&gt;BigInt&lt;/code&gt; 진수 또는 16 진수 문자열. 숫자는 10 진수 또는 16 진 리터럴 형식이어야합니다. &lt;code&gt;0x&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 부호 가있을 수 있고 16 진수 인 경우 0x 또는 &lt;code&gt;0X&lt;/code&gt; 가 올 수 있습니다. 밑줄은 &lt;code&gt;0x&lt;/code&gt; 및 / 또는 숫자 부호 뒤의 모든 위치에서 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f8a2a29c0df9993c9fe72f3dbc60846c4494239" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from a sign and a magnitude.</source>
          <target state="translated">부호와 크기 로 &lt;code&gt;BigInt&lt;/code&gt; 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0d7c3b4548cf75fac0de21ecc52fb10d3606eec5" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;BigInt&lt;/code&gt; from another &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">구성체 &lt;code&gt;BigInt&lt;/code&gt; 서로 &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7efa1a6ab14f5ccd00f6c0c9a24eba2121df8bda" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundStatement&lt;/code&gt; from an array of &lt;code&gt;Statement&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;Statement&lt;/code&gt; 의 배열로부터 &lt;code&gt;CompoundStatement&lt;/code&gt; 를 구축합니다</target>
        </trans-unit>
        <trans-unit id="29b364a0138bce0f5c44e30e508e17d93f7c05ed" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundStatement&lt;/code&gt; using an already existing array of &lt;code&gt;Statement&lt;/code&gt;s</source>
          <target state="translated">컨스 &lt;code&gt;CompoundStatement&lt;/code&gt; 의 기존 배열하여 &lt;code&gt;Statement&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="c4a6c4a823793d5f65499787e95138d6100b624f" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoding of the given Base64 encoded data.</source>
          <target state="translated">주어진 Base64 인코딩 데이터의 디코딩을 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="edbcd15b10b6211f79e2728db1542060e841dc30" translate="yes" xml:space="preserve">
          <source>Construct a BitRange.</source>
          <target state="translated">BitRange를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5951f021a460e25ffeab1777192f63d5dcad38" translate="yes" xml:space="preserve">
          <source>Construct a Processing Instruction section</source>
          <target state="translated">처리 명령 섹션 구성</target>
        </trans-unit>
        <trans-unit id="1f8c7657f3358e4444599716fc5a5104fadd594b" translate="yes" xml:space="preserve">
          <source>Construct a UUID struct from the 16 byte representation of a UUID.</source>
          <target state="translated">UUID의 16 바이트 표현에서 UUID 구조체를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="16a3dc0d5228e43b22556eb8ffea43940ae8f1b3" translate="yes" xml:space="preserve">
          <source>Construct a UUID struct from the 16 byte representation of a UUID. Variadic constructor to allow a simpler syntax, see examples. You need to pass exactly 16 ubytes.</source>
          <target state="translated">UUID의 16 바이트 표현에서 UUID 구조체를 구성하십시오. 보다 간단한 구문을 허용하는 다양한 생성자 (예제 참조) 정확히 16 바이트를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="23141c0f7e0d7ab9526562ff979c5df531f9e26b" translate="yes" xml:space="preserve">
          <source>Construct a character data section</source>
          <target state="translated">문자 데이터 섹션 구성</target>
        </trans-unit>
        <trans-unit id="e7a49314abea8219c1157b1b3da7ac10cc878066" translate="yes" xml:space="preserve">
          <source>Construct a comment</source>
          <target state="translated">주석 구성</target>
        </trans-unit>
        <trans-unit id="a2c71e5e027279ee45a7931fee354af43aa8085a" translate="yes" xml:space="preserve">
          <source>Construct a complex number with the specified real and imaginary parts. In the case where a single argument is passed that is not complex, the imaginary part of the result will be zero.</source>
          <target state="translated">지정된 실수 부와 허수 부로 복소수를 만듭니다. 복잡하지 않은 단일 인수가 전달되는 경우 결과의 허수 부분은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1465ea8ff9842efb9f4fb5533375eb53710f4b" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;FormatSpec&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt;, no processing is done until needed.</source>
          <target state="translated">형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 를 사용하여 새 &lt;code&gt;FormatSpec&lt;/code&gt; 을 구성하십시오 . 필요한 때까지 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b338b11da2dffa6fdc8f6e1cebf5a1fc9737f7a" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;Internet6Address&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Internet6Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="2d79b3621c7911196f6ede8afe742e5c8ec1d706" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;InternetAddress&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;InternetAddress&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="a7538127e5f1404acba2c44fa3de190633fd2308" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;UnixAddress&lt;/code&gt; from the specified path.</source>
          <target state="translated">지정된 경로에서 새로운 &lt;code&gt;UnixAddress&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dd446bfae9180e30b1daa43c407ceb3fdf970415" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;UnixAddress&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;UnixAddress&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="1bdec3f526944ac27208976a2f90415d2bb71451" translate="yes" xml:space="preserve">
          <source>Construct a new string from &lt;code&gt;input&lt;/code&gt; by replacing all of the fragments that match a pattern &lt;code&gt;re&lt;/code&gt; with a string generated from the match according to the &lt;code&gt;format&lt;/code&gt; specifier.</source>
          <target state="translated">의 새로운 캐릭터 구축 &lt;code&gt;input&lt;/code&gt; 패턴에 일치하는 조각을 모두 교체하여 &lt;code&gt;re&lt;/code&gt; 받는 따른 매치로부터 생성 된 문자열 &lt;code&gt;format&lt;/code&gt; 지정자.</target>
        </trans-unit>
        <trans-unit id="70db60e9276b0769769d7bc219186f785f9656d7" translate="yes" xml:space="preserve">
          <source>Construct a new string from &lt;code&gt;input&lt;/code&gt; by replacing the first match with a string generated from it according to the &lt;code&gt;format&lt;/code&gt; specifier.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 지정자 에 따라 첫 번째 일치 항목을 생성 한 문자열로 대체하여 &lt;code&gt;input&lt;/code&gt; 에서 새 문자열 을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf2215c38ab2484cd95c1a3f8d7e5ea5d6e5d89" translate="yes" xml:space="preserve">
          <source>Construct a range iterating over an associative array by key/value tuples.</source>
          <target state="translated">키 / 값 튜플을 사용하여 연관 배열에서 반복되는 범위를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e49b6c0e84de21ca12a39e319d7d0f1c33c4e83a" translate="yes" xml:space="preserve">
          <source>Construct a set from a forward range of code point intervals.</source>
          <target state="translated">코드 포인트 간격의 정방향 범위에서 세트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ce8cada6e1ecb8296e6778664e7e54197cd4560" translate="yes" xml:space="preserve">
          <source>Construct a set from plain values of code point intervals.</source>
          <target state="translated">코드 포인트 간격의 일반 값으로 세트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="f66ee7eaa1f920dff7ccd0302783f06c78ac43a1" translate="yes" xml:space="preserve">
          <source>Construct a specific point in time in the UTC timezone and add two days.</source>
          <target state="translated">UTC 시간대에서 특정 시점을 구성하고 이틀을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d5725c80a7627176eef25dd37fe82818e437ca5c" translate="yes" xml:space="preserve">
          <source>Construct a specific point in time without timezone information and get its ISO string.</source>
          <target state="translated">시간대 정보없이 특정 시점을 구성하고 해당 ISO 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="394f0b49b16c495da3d93936f500ab9712ce9376" translate="yes" xml:space="preserve">
          <source>Construct a ternary value from another ternary value</source>
          <target state="translated">다른 삼항 값에서 삼항 값 구성</target>
        </trans-unit>
        <trans-unit id="0e61b23e18fedae64c5d35d65cf20fb2f2d67df8" translate="yes" xml:space="preserve">
          <source>Construct a text (aka PCData) section</source>
          <target state="translated">텍스트 (일명 PCData) 섹션 구성</target>
        </trans-unit>
        <trans-unit id="84da9edb06d68da916babe0161ac2b1d6a5d7665" translate="yes" xml:space="preserve">
          <source>Construct a variable from &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; and put it in the environment while saving the previous value of the environment variable into a global list so it can be restored later.</source>
          <target state="translated">에서 변수 구축 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;value&lt;/code&gt; 하고 나중에 복원 할 수 있도록 글로벌 목록에 환경 변수의 이전 값을 저장하는 동안 환경에 넣어.</target>
        </trans-unit>
        <trans-unit id="49fa16f74b39989050bae31ab6353db2926f9d36" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoding of the given &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 Base64 인코딩을 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="aa8c85542dd824e935b81b57a1863e6723f75cb5" translate="yes" xml:space="preserve">
          <source>Construct an XML Instruction section</source>
          <target state="translated">XML 명령어 섹션 생성</target>
        </trans-unit>
        <trans-unit id="a194031f6ae934ce18b0c67914deaf21cac16ec1" translate="yes" xml:space="preserve">
          <source>Construct an archive out of the current members of the archive.</source>
          <target state="translated">현재 아카이브 멤버에서 아카이브를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c166b2ff50eb5ec5eec43caf2eb44127f34619" translate="yes" xml:space="preserve">
          <source>Construct an associative array consisting of all abbreviations that uniquely map to the strings in values.</source>
          <target state="translated">값의 문자열에 고유하게 맵핑되는 모든 약어로 구성된 연관 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5cf702deece5ed2b82278e20dc28296a3a195348" translate="yes" xml:space="preserve">
          <source>Construct an associative array of type ti from keys and value</source>
          <target state="translated">키와 값으로 ti 유형의 연관 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e75af0c6e150db4d6b4dec02927806bba690aec9" translate="yes" xml:space="preserve">
          <source>Construct an identifier from a D slice</source>
          <target state="translated">D 슬라이스에서 식별자 구성</target>
        </trans-unit>
        <trans-unit id="80d4446ef4560aaedf6b918f5799b1c445900184" translate="yes" xml:space="preserve">
          <source>Construct and assign from a &lt;code&gt;bool&lt;/code&gt;, receiving &lt;code&gt;no&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;yes&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">A로부터 구성하고 할당 &lt;code&gt;bool&lt;/code&gt; 수신 &lt;code&gt;no&lt;/code&gt; 에 대한 &lt;code&gt;false&lt;/code&gt; 과 &lt;code&gt;yes&lt;/code&gt; 에 대한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="647783f6e0c996a537f44ec3b423196a31d77d95" translate="yes" xml:space="preserve">
          <source>Construct and manipulate template argument lists (aka type lists).</source>
          <target state="translated">템플릿 인수 목록 (일명 유형 목록)을 구성하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b7a26e15daa59c5841cd23ead59280c64ffa4247" translate="yes" xml:space="preserve">
          <source>Construct elem to run when an array bounds check fails.</source>
          <target state="translated">배열 경계 검사가 실패 할 때 실행할 elem을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6de53d9bc658052402833a77bcc70a7c52e05729" translate="yes" xml:space="preserve">
          <source>Construct from another code point set of any type.</source>
          <target state="translated">모든 유형의 다른 코드 포인트 세트에서 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="195707e72a012ddb97f51ce7407e70d2a55623c4" translate="yes" xml:space="preserve">
          <source>Construct new, useful general purpose types.</source>
          <target state="translated">새롭고 유용한 범용 유형을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="82ce738c4d85678079ef40a05612ba2651226474" translate="yes" xml:space="preserve">
          <source>Construct the array operation expression, call object.arrayOp!(tiargs)(args). Encode operand types and operations into tiargs using reverse polish notation (RPN) to preserve precedence. Unary operations are prefixed with &quot;u&quot; (e.g. &quot;u~&quot;). Pass operand values (slices or scalars) as args.</source>
          <target state="translated">배열 연산 식을 생성하고 object.arrayOp! (tiargs) (args)를 호출하십시오. 우선 순위를 유지하기 위해 RPN (Reverse Polish Notation)을 사용하여 피연산자 유형 및 연산을 tiarg로 인코딩합니다. 단항 연산은 &quot;u&quot;로 시작합니다 (예 : &quot;u ~&quot;). 피연산자 값 (슬라이스 또는 스칼라)을 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d9a4b38839617151d36e6f6d557c6634ed7c22c1" translate="yes" xml:space="preserve">
          <source>Construct the entire contents of the current members of the archive.</source>
          <target state="translated">아카이브의 현재 구성원의 전체 내용을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="2f3ec07075420c87a074dd94b630d897ff817037" translate="yes" xml:space="preserve">
          <source>Construct. destbufsize is the same as for D.zlib.uncompress().</source>
          <target state="translated">구성합니다. destbufsize는 D.zlib.uncompress ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cba1d6a444e0426f16ee3f9f52dcc2b14b8af47" translate="yes" xml:space="preserve">
          <source>Constructed ArrayLiteralExp</source>
          <target state="translated">생성 된 ArrayLiteralExp</target>
        </trans-unit>
        <trans-unit id="da33e1b7e0c4eae1911ee4a15280f0990e1a6115" translate="yes" xml:space="preserve">
          <source>Construction</source>
          <target state="translated">Construction</target>
        </trans-unit>
        <trans-unit id="a3fe9a9b809ec5725205d76e7f854c1241a03e33" translate="yes" xml:space="preserve">
          <source>Construction and Reference Semantics</source>
          <target state="translated">구성 및 참조 의미론</target>
        </trans-unit>
        <trans-unit id="976162fa882990e03c8dd184b0b58a781b3a0c3b" translate="yes" xml:space="preserve">
          <source>Construction from an input and an index.</source>
          <target state="translated">입력과 색인으로 구성.</target>
        </trans-unit>
        <trans-unit id="2186eebe242de29328a263df29ae1111232f2644" translate="yes" xml:space="preserve">
          <source>Construction from an input.</source>
          <target state="translated">입력으로부터의 구성.</target>
        </trans-unit>
        <trans-unit id="b811fc2a657ea4e942e1143cd08736916b4217a0" translate="yes" xml:space="preserve">
          <source>Construction of lookup tables</source>
          <target state="translated">룩업 테이블의 건설</target>
        </trans-unit>
        <trans-unit id="6dd3a5d9a969f9c6c6072358abb68461c1de1b22" translate="yes" xml:space="preserve">
          <source>Construction or Assignment on Setting AA Entries</source>
          <target state="translated">AA 항목 설정에 대한 구성 또는 할당</target>
        </trans-unit>
        <trans-unit id="d3516ef4fcc0fefa8ef460409910d17c762a3e6c" translate="yes" xml:space="preserve">
          <source>Constructor Attributes</source>
          <target state="translated">생성자 속성</target>
        </trans-unit>
        <trans-unit id="a494a02b46c9d078348d4b43daaa23777792b7f5" translate="yes" xml:space="preserve">
          <source>Constructor argument for default construction</source>
          <target state="translated">기본 구성에 대한 생성자 인수</target>
        </trans-unit>
        <trans-unit id="054ab73cf0d9f14ed49f82c4cff717124d2a513c" translate="yes" xml:space="preserve">
          <source>Constructor binding &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">생성자 바인딩 &lt;code&gt;this&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7aca37d11a5dad62fa7753ebd2d62be1dbbcf19" translate="yes" xml:space="preserve">
          <source>Constructor for &lt;code&gt;JSONValue&lt;/code&gt;. If &lt;code&gt;arg&lt;/code&gt; is a &lt;code&gt;JSONValue&lt;/code&gt; its value and type will be copied to the new &lt;code&gt;JSONValue&lt;/code&gt;. Note that this is a shallow copy: if type is &lt;code&gt;JSONType.object&lt;/code&gt; or &lt;code&gt;JSONType.array&lt;/code&gt; then only the reference to the data will be copied. Otherwise, &lt;code&gt;arg&lt;/code&gt; must be implicitly convertible to one of the following types: &lt;code&gt;typeof(null)&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, an associative array &lt;code&gt;V[K]&lt;/code&gt; for any &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt; i.e. a JSON object, any array or &lt;code&gt;bool&lt;/code&gt;. The type will be set accordingly.</source>
          <target state="translated">생성자 &lt;code&gt;JSONValue&lt;/code&gt; . 경우 &lt;code&gt;arg&lt;/code&gt; A는 &lt;code&gt;JSONValue&lt;/code&gt; 의 가치와 유형은 새에 복사됩니다 &lt;code&gt;JSONValue&lt;/code&gt; . 얕은 사본입니다. type이 &lt;code&gt;JSONType.object&lt;/code&gt; 또는 &lt;code&gt;JSONType.array&lt;/code&gt; 인 경우 데이터에 대한 참조 만 복사됩니다. 그렇지 않으면, &lt;code&gt;arg&lt;/code&gt; 는 &lt;code&gt;typeof(null)&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;ulong&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; 및 &lt;code&gt;K&lt;/code&gt; 에 대한 연관 배열 &lt;code&gt;V[K]&lt;/code&gt; , 즉 JSON 객체, 배열 또는 &lt;code&gt;bool&lt;/code&gt; 중 하나로 암시 적으로 변환 가능해야합니다.. 그에 따라 유형이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="958db728358d20353a09b0ce14e29f648fa7b9b6" translate="yes" xml:space="preserve">
          <source>Constructor initializing &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">생성자 초기화 &lt;code&gt;this&lt;/code&gt; 함께 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0367f2949e838dbf344d79ca0be183c08f50ddea" translate="yes" xml:space="preserve">
          <source>Constructor taking a compatible &lt;code&gt;Tuple&lt;/code&gt;. Two &lt;code&gt;Tuple&lt;/code&gt;s are compatible &lt;b&gt;iff&lt;/b&gt; they are both of the same length, and, for each type &lt;code&gt;T&lt;/code&gt; on the left-hand side, the corresponding type &lt;code&gt;U&lt;/code&gt; on the right-hand side can implicitly convert to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">호환되는 &lt;code&gt;Tuple&lt;/code&gt; 을 생성하는 생성자 . 두 &lt;code&gt;Tuple&lt;/code&gt; 들 호환되는 &lt;b&gt;IFF에&lt;/b&gt; 각 타입에 대해, 그들은 같은 길이의 모두가, 그리고 &lt;code&gt;T&lt;/code&gt; 왼쪽에, 해당 유형 &lt;code&gt;U&lt;/code&gt; 오른쪽에 암시 적으로 변환 할 수 있습니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82fb824d4d5cc73ecbddf2d369c8b6d494d4005e" translate="yes" xml:space="preserve">
          <source>Constructor taking a compatible array.</source>
          <target state="translated">호환 가능한 배열을 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="337303cb1c4142f79bb21427c7834170cf217748" translate="yes" xml:space="preserve">
          <source>Constructor taking a number of items.</source>
          <target state="translated">여러 항목을 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="312dcee2fedfca8db731097219798f4fda057356" translate="yes" xml:space="preserve">
          <source>Constructor taking a number of nodes</source>
          <target state="translated">다수의 노드를 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="39aa104961235c81ea7ce5789ee56792a20446f0" translate="yes" xml:space="preserve">
          <source>Constructor taking a value properly convertible to the underlying type. &lt;code&gt;U&lt;/code&gt; may be either an integral that can be converted to &lt;code&gt;T&lt;/code&gt; without a loss, or another &lt;code&gt;Checked&lt;/code&gt; instance whose representation may be in turn converted to &lt;code&gt;T&lt;/code&gt; without a loss.</source>
          <target state="translated">기본 유형으로 올바르게 변환 가능한 값을 취하는 생성자 &lt;code&gt;U&lt;/code&gt; 가 변환 될 수있는 일체 이어도 &lt;code&gt;T&lt;/code&gt; 손실없이, 또는 다른 &lt;code&gt;Checked&lt;/code&gt; 그 표현 될 수 차례 변환 인스턴스 &lt;code&gt;T&lt;/code&gt; 손실없이.</target>
        </trans-unit>
        <trans-unit id="c7462d0e28326868b6e970d116a087457bc47647" translate="yes" xml:space="preserve">
          <source>Constructor taking an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위를&lt;/a&gt; 취하는 생성자</target>
        </trans-unit>
        <trans-unit id="028ef1ffceb1a8e2f931182078782ecd73909dff" translate="yes" xml:space="preserve">
          <source>Constructor taking one value for each field.</source>
          <target state="translated">각 필드에 대해 하나의 값을 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="ec87cd71d0c30421b4e1bbb4504a346899fd1803" translate="yes" xml:space="preserve">
          <source>Constructor taking the name of the file to open and the open mode.</source>
          <target state="translated">열려는 파일 이름과 열기 모드를 취하는 생성자.</target>
        </trans-unit>
        <trans-unit id="2b736db750e5b8588933a2cab677f5fbd588db97" translate="yes" xml:space="preserve">
          <source>Constructor taking the url as parameter.</source>
          <target state="translated">URL을 매개 변수로 사용하는 생성자</target>
        </trans-unit>
        <trans-unit id="2f815f9d325af38009f8487671b992fc3b8edee2" translate="yes" xml:space="preserve">
          <source>Constructor that initializes the payload.</source>
          <target state="translated">페이로드를 초기화하는 생성자</target>
        </trans-unit>
        <trans-unit id="016997051201ccc98c813dcc7c39a587d61ab8c6" translate="yes" xml:space="preserve">
          <source>Constructor that takes a &lt;code&gt;Unique&lt;/code&gt; of a type that is convertible to our type.</source>
          <target state="translated">우리 유형으로 변환 할 수 있는 &lt;code&gt;Unique&lt;/code&gt; 한 유형 을 취하는 생성자 .</target>
        </trans-unit>
        <trans-unit id="0b1f1dc0db9cef3da3b4be09aee734bc80e7d08c" translate="yes" xml:space="preserve">
          <source>Constructor that takes an lvalue. It nulls its source. The nulling will ensure uniqueness as long as there are no previous aliases to the source.</source>
          <target state="translated">lvalue를 취하는 생성자 소스를 무효로합니다. 널링은 소스에 대한 이전 별명이없는 한 고유성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="6d0b20d8fc18f15a14377620be1f3f6c18b63a08" translate="yes" xml:space="preserve">
          <source>Constructor that takes an rvalue. It will ensure uniqueness, as long as the rvalue isn't just a view on an lvalue (e.g., a cast). Typical usage:</source>
          <target state="translated">rvalue를 취하는 생성자 rvalue가 lvalue (예 : 캐스트)에 대한 관점이 아닌 한 고유성을 보장합니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="05f636b7912d58ac3b449cb36c994c98a7238361" translate="yes" xml:space="preserve">
          <source>Constructor to use when creating a new archive.</source>
          <target state="translated">새로운 아카이브를 생성 할 때 사용할 생성자.</target>
        </trans-unit>
        <trans-unit id="7c1ac12e45facf352f3efe44eb326d743f2088a0" translate="yes" xml:space="preserve">
          <source>Constructor to use when reading an existing archive.</source>
          <target state="translated">기존 아카이브를 읽을 때 사용할 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="48b7f1869a1fb50e06c68f08a76aa0238231d852" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message and error code.</source>
          <target state="translated">오류 메시지와 오류 코드를받는 생성자</target>
        </trans-unit>
        <trans-unit id="28237bb656117133502ebdcbb4cc87ee22fad07c" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message.</source>
          <target state="translated">에러 메세지를받는 생성자</target>
        </trans-unit>
        <trans-unit id="4c0e6f93d76eef0a5ad9b6d7bb2bad4c3b17cd12" translate="yes" xml:space="preserve">
          <source>Constructor which takes an error message. The current global &lt;a href=&quot;core_stdc_errno#errno&quot;&gt;&lt;code&gt;core.stdc.errno.errno&lt;/code&gt;&lt;/a&gt; value is used as error code.</source>
          <target state="translated">에러 메세지를받는 생성자 현재 전역 &lt;a href=&quot;core_stdc_errno#errno&quot;&gt; &lt;code&gt;core.stdc.errno.errno&lt;/code&gt; &lt;/a&gt; 값이 오류 코드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="28ff53758848e03bffa7a7a1c38781a50d47e14d" translate="yes" xml:space="preserve">
          <source>Constructor which takes the error number (&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; in Windows, errno in POSIX).</source>
          <target state="translated">오류 번호 ( Windows의 경우 &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; , POSIX의 경우 errno)를받는 생성자 .</target>
        </trans-unit>
        <trans-unit id="4d4ae6f60e2d60a48fe329503bd32951d4cbc36d" translate="yes" xml:space="preserve">
          <source>Constructor which takes the error number (&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; in Windows, errno in Posix).</source>
          <target state="translated">오류 번호를 갖는 생성자 ( Windows의 &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=GetLastError&quot;&gt;GetLastError&lt;/a&gt; , Posix의 errno)</target>
        </trans-unit>
        <trans-unit id="ba2200976ccedc895aa8714dc1e6fb4e9038e5f4" translate="yes" xml:space="preserve">
          <source>Constructor.</source>
          <target state="translated">Constructor.</target>
        </trans-unit>
        <trans-unit id="fb6b24775698549efb7aa5531d3b2988935f90f6" translate="yes" xml:space="preserve">
          <source>Constructor. Pass in a range of elements to initialize the tree with.</source>
          <target state="translated">건설자. 트리를 초기화하려면 다양한 요소를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="1a178df59f99c60619523cc28c3159353aae12d6" translate="yes" xml:space="preserve">
          <source>Constructor. Pass in an array of elements, or individual elements to initialize the tree with.</source>
          <target state="translated">건설자. 요소의 배열 또는 개별 요소를 전달하여 트리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="807d66814f4ba4f921c1396af90944a155259be3" translate="yes" xml:space="preserve">
          <source>Constructors accepting desired capacity or a preallocated buffer, similar in semantics to those of &lt;code&gt;BitmappedBlock&lt;/code&gt;.</source>
          <target state="translated">의미론의 것과 유사한 용량 원하는 또는 미리 할당 된 버퍼 수락 생성자 &lt;code&gt;BitmappedBlock&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4225d3cb91899353150e813e7d2d79a3a8782065" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and have no return value. The grammar is the same as for the class &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자는 &lt;code&gt;this&lt;/code&gt; 의 함수 이름으로 정의되며 반환 값이 없습니다. 문법은 &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt; 클래스와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1d34dd8f0324fd045374d49c9c3d54d188eaf093" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and have no return value:</source>
          <target state="translated">생성자의 함수 이름으로 정의되는 &lt;code&gt;this&lt;/code&gt; 더 리턴 값이 없다 :</target>
        </trans-unit>
        <trans-unit id="16754c38fa1206780e385874d1438ae4c6a8b8c6" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and having no return value. The grammar is the same as for the class &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자는 함수의 이름으로 정의되는 &lt;code&gt;this&lt;/code&gt; 어떠한 리턴 값을 갖는 않는다. 문법은 &lt;a href=&quot;class#Constructor&quot;&gt;&lt;i&gt;Constructor&lt;/i&gt;&lt;/a&gt; 클래스와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c2e6c63b9009979683923270fe7969b7aa741e91" translate="yes" xml:space="preserve">
          <source>Constructors are defined with a function name of &lt;code&gt;this&lt;/code&gt; and having no return value:</source>
          <target state="translated">생성자는 함수의 이름으로 정의되는 &lt;code&gt;this&lt;/code&gt; 더 리턴 값이없는 :</target>
        </trans-unit>
        <trans-unit id="fc2ab456b803f2a781f337931bdcedefaed757d1" translate="yes" xml:space="preserve">
          <source>Constructors can be overloaded with different attributes.</source>
          <target state="translated">생성자는 다른 속성으로 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa2beb6e3d0ab0cb39859e1839af45b65f842fd" translate="yes" xml:space="preserve">
          <source>Constructors can call other constructors for the same class in order to share common initializations (this is called a delegating constructor):</source>
          <target state="translated">생성자는 공통 초기화를 공유하기 위해 동일한 클래스에 대해 다른 생성자를 호출 할 수 있습니다 (위임 생성자라고 함).</target>
        </trans-unit>
        <trans-unit id="3f4fc5393e597a57538cf4de6d5462b225d2d51e" translate="yes" xml:space="preserve">
          <source>Constructors can call other constructors for the same struct in order to share common initializations (this is called a &lt;a href=&quot;class#delegating-constructors&quot;&gt;delegating constructor&lt;/a&gt;):</source>
          <target state="translated">생성자는 공통 초기화를 공유하기 위해 동일한 구조체에 대해 다른 생성자를 호출 할 수 있습니다 ( &lt;a href=&quot;class#delegating-constructors&quot;&gt;위임 생성자&lt;/a&gt; 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="5417b6074f85a905aed32a156a099f6cc6ef82a9" translate="yes" xml:space="preserve">
          <source>Constructors can have one of these member function attributes: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, and &lt;code&gt;shared&lt;/code&gt;. Construction of qualified objects will then be restricted to the implemented qualified constructors.</source>
          <target state="translated">생성자는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 멤버 함수 속성 중 하나를 가질 수 있습니다 . 정규화 된 객체의 생성은 구현 된 정규화 된 생성자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6224547e06b5379ad7844e2e3e6bdd01e198c7c9" translate="yes" xml:space="preserve">
          <source>Constructors return the this pointer in EAX.</source>
          <target state="translated">생성자는이 포인터를 EAX로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e983ecc3235a082ac5ab3438cb35588e5913d548" translate="yes" xml:space="preserve">
          <source>Constructors setting up the memory structured as a free list.</source>
          <target state="translated">생성자는 사용 가능한 목록으로 구조화 된 메모리를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="917fbdc8fb87d3240ea5d269d2fec24c7e203ffc" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; object instantiated and initialized according to the given arguments.</source>
          <target state="translated">주어진 인수에 따라 인스턴스화되고 초기화 된 &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dad768a1d3c806574ce4ef1d6f17739935f5ef4b" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;DirEntry&lt;/code&gt; for the given file (or directory).</source>
          <target state="translated">지정된 파일 (또는 디렉토리) 의 &lt;code&gt;DirEntry&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f2cf92b74dfa870775ce13ac3caf1d9e122173" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;RefAppender&lt;/code&gt; with a given array reference. This does not copy the data. If the array has a larger capacity as determined by &lt;code&gt;arr.capacity&lt;/code&gt;, it will be used by the appender.</source>
          <target state="translated">지정된 배열 참조 로 &lt;code&gt;RefAppender&lt;/code&gt; 를 구축합니다 . 이것은 데이터를 복사하지 않습니다. &lt;code&gt;arr.capacity&lt;/code&gt; 에 의해 결정된 배열의 용량이 더 큰 경우 어 펜더가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0a99c29487dadc182d8a3bda120934df206639c9" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;VariantN&lt;/code&gt; value given an argument of a generic type. Statically rejects disallowed types.</source>
          <target state="translated">구축 &lt;code&gt;VariantN&lt;/code&gt; 의 제네릭 형식의 인수 지정된 값을. 허용되지 않는 유형을 정적으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="4bc5b4b671ae60c2f6de52fe65f7ef1b9d577caf" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;XorshiftEngine&lt;/code&gt; generator seeded with x0.</source>
          <target state="translated">x0으로 시드 된 &lt;code&gt;XorshiftEngine&lt;/code&gt; 생성기를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="ecf8fa50fa09e85a50a7ee1d6d9cb5689198b305" translate="yes" xml:space="preserve">
          <source>Constructs a Document by parsing XML text.</source>
          <target state="translated">XML 텍스트를 구문 분석하여 문서를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="142fbb3a4f3a407f93e0c16daba0bb5064ea4c6d" translate="yes" xml:space="preserve">
          <source>Constructs a Document from a Tag.</source>
          <target state="translated">태그에서 문서를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b95fdaa893c80a5c04bf4437cd4b6fdd348c04af" translate="yes" xml:space="preserve">
          <source>Constructs a DocumentParser.</source>
          <target state="translated">DocumentParser를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="f20472cfd83dc45168ff0eb4d99a68f4a6aafcdf" translate="yes" xml:space="preserve">
          <source>Constructs a LinearCongruentialEngine generator seeded with &lt;code&gt;x0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x0&lt;/code&gt; 시드 된 LinearCongruentialEngine 생성기를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="233b957299550b15a28e3548a091cca8b823bc0f" translate="yes" xml:space="preserve">
          <source>Constructs a MersenneTwisterEngine object.</source>
          <target state="translated">MersenneTwisterEngine 객체를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="9f9db8efce8dd429db5938c30a8f172827296779" translate="yes" xml:space="preserve">
          <source>Constructs a StopWatch. Whether it starts immediately depends on the &lt;a href=&quot;#AutoStart&quot;&gt;&lt;code&gt;AutoStart&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">스톱워치를 구성합니다. 시작 여부는 &lt;a href=&quot;#AutoStart&quot;&gt; &lt;code&gt;AutoStart&lt;/code&gt; &lt;/a&gt; 인수 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="00d1a29960b8444e123571c0597b354c35facc3d" translate="yes" xml:space="preserve">
          <source>Constructs a block allocator given a hunk of memory, or a desired capacity in bytes.</source>
          <target state="translated">메모리 덩어리 또는 원하는 용량 (바이트)이 주어지면 블록 할당자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="146e982316dbe394422d91958193b29e48ddcb91" translate="yes" xml:space="preserve">
          <source>Constructs a blocking IPv4 TCP Socket.</source>
          <target state="translated">차단 IPv4 TCP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="53247329cc6a51d22ab4698276b1f754d0339aaa" translate="yes" xml:space="preserve">
          <source>Constructs a blocking IPv4 UDP Socket.</source>
          <target state="translated">차단 IPv4 UDP 소켓을 구축합니다.</target>
        </trans-unit>
        <trans-unit id="f485ed96de3ac13b7303b9b65eca592e0443e023" translate="yes" xml:space="preserve">
          <source>Constructs a blocking TCP Socket and connects to an &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">차단 TCP 소켓을 구성하고 &lt;code&gt;Address&lt;/code&gt; 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="431478cfa4f05184c54f87ab32bb9c9692007e39" translate="yes" xml:space="preserve">
          <source>Constructs a blocking TCP Socket.</source>
          <target state="translated">블로킹 TCP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d350c91652d7b9b0cd2159ce6cde3003102137a6" translate="yes" xml:space="preserve">
          <source>Constructs a blocking UDP Socket.</source>
          <target state="translated">블로킹 UDP 소켓을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="17cdbaf765f763438b5c9e4f2e41158243f3b098" translate="yes" xml:space="preserve">
          <source>Constructs a complex number given its absolute value and argument.</source>
          <target state="translated">절대 값과 인수가 주어진 복소수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6854fd227e337caa25e42f39155a6f82de1c1e18" translate="yes" xml:space="preserve">
          <source>Constructs a matcher object to classify &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; from the &lt;code&gt;set&lt;/code&gt; for encoding that has &lt;code&gt;Char&lt;/code&gt; as code unit.</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 를 코드 단위로 사용 하는 인코딩 &lt;code&gt;set&lt;/code&gt; 에서 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 를 분류하는 matcher 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ec9df545fbfee53dd90779724e7a812c8dc67a55" translate="yes" xml:space="preserve">
          <source>Constructs a message from the</source>
          <target state="translated">메시지를 구성합니다</target>
        </trans-unit>
        <trans-unit id="ea8599b64b5ab10e1403a39d677d9d23280a9390" translate="yes" xml:space="preserve">
          <source>Constructs a new function or delegate type with the same basic signature as the given one, but different attributes (including linkage).</source>
          <target state="translated">지정된 것과 동일한 기본 서명을 사용하지만 다른 속성 (링크 포함)을 사용하여 새 함수 또는 델리게이트 유형을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a007be1fb9fb1e9a3bb438949e90dfe8105d9f56" translate="yes" xml:space="preserve">
          <source>Constructs a region backed by a user-provided store. Assumes the memory was allocated with &lt;code&gt;ParentAllocator&lt;/code&gt; (if different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">사용자 제공 상점이 지원하는 영역을 구성합니다. 메모리는 할당 된 가정합니다 &lt;code&gt;ParentAllocator&lt;/code&gt; (다를 경우 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b06ce7a9e6471d4b389eadc615ef60d562d5d9b2" translate="yes" xml:space="preserve">
          <source>Constructs a static array from &lt;code&gt;a&lt;/code&gt;. The type of elements can be specified implicitly so that &lt;code&gt;[1, 2].staticArray&lt;/code&gt; results in &lt;code&gt;int[2]&lt;/code&gt;, or explicitly, e.g. &lt;code&gt;[1, 2].staticArray!float&lt;/code&gt; returns &lt;code&gt;float[2]&lt;/code&gt;. When &lt;code&gt;a&lt;/code&gt; is a range whose length is not known at compile time, the number of elements must be given as template argument (e.g. &lt;code&gt;myrange.staticArray!2&lt;/code&gt;). Size and type can be combined, if the source range elements are implicitly convertible to the requested element type (eg: &lt;code&gt;2.iota.staticArray!(long[2])&lt;/code&gt;). When the range &lt;code&gt;a&lt;/code&gt; is known at compile time, it can also be specified as a template argument to avoid having to specify the number of elements (e.g.: &lt;code&gt;staticArray!(2.iota)&lt;/code&gt; or &lt;code&gt;staticArray!(double, 2.iota)&lt;/code&gt;).</source>
          <target state="translated">에서 정적 배열을 생성 &lt;code&gt;a&lt;/code&gt; . 요소의 유형은 &lt;code&gt;[1, 2].staticArray&lt;/code&gt; 가 &lt;code&gt;int[2]&lt;/code&gt; 가되거나 명시 적으로 &lt;code&gt;[1, 2].staticArray!float&lt;/code&gt; 가 &lt;code&gt;float[2]&lt;/code&gt; 반환 하도록 암시 적으로 지정할 수 있습니다 . 때 &lt;code&gt;a&lt;/code&gt; 길이가 컴파일 타임에 알려지지 않은 범위는, 요소의 수는 템플릿 인수 (예로서 제공해야합니다 &lt;code&gt;myrange.staticArray!2&lt;/code&gt; ). 소스 범위 요소를 요청 된 요소 유형으로 암시 적으로 변환 할 수있는 경우 크기와 유형을 결합 할 수 있습니다 (예 : &lt;code&gt;2.iota.staticArray!(long[2])&lt;/code&gt; ). 범위 &lt;code&gt;a&lt;/code&gt; 컴파일 타임에 알려진 것으로, 요소의 수를 지정하지 않아도되는 템플릿 인수로 지정할 수도 있습니다 (예 : &lt;code&gt;staticArray!(2.iota)&lt;/code&gt; 또는 &lt;code&gt;staticArray!(double, 2.iota)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7781933a4887fd803519fc54f562055cd812781c" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Address&lt;/code&gt; with a copy of the specified &lt;code&gt;sockaddr&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;sockaddr&lt;/code&gt; 의 카피로 &lt;code&gt;Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="9aec993528ca9dc016d572af7cf82ee72630798f" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Address&lt;/code&gt; with a reference to the specified &lt;code&gt;sockaddr&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;sockaddr&lt;/code&gt; 를 참조 해 &lt;code&gt;Address&lt;/code&gt; 를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="9615b78e90ddc4141b1f50da180143f27c8af2f7" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;AllocatorList&lt;/code&gt; given a factory object. This constructor is defined only if &lt;code&gt;Factory&lt;/code&gt; has state.</source>
          <target state="translated">팩토리 객체를 지정해 &lt;code&gt;AllocatorList&lt;/code&gt; 를 구축 합니다. 이 생성자는 &lt;code&gt;Factory&lt;/code&gt; 에 상태가있는 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bb58461416282d926d1b319755b4712d0bb7ef9" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;code&gt;Appender&lt;/code&gt; with a given array. Note that this does not copy the data. If the array has a larger capacity as determined by &lt;code&gt;arr.capacity&lt;/code&gt;, it will be used by the appender. After initializing an appender on an array, appending to the original array will reallocate.</source>
          <target state="translated">지정된 배열 로 &lt;code&gt;Appender&lt;/code&gt; 를 구축합니다 . 이것은 데이터를 복사하지 않습니다. &lt;code&gt;arr.capacity&lt;/code&gt; 에 의해 결정된 배열의 용량이 더 큰 경우 어 펜더가 사용합니다. 배열에서 어 펜더를 초기화 한 후 원래 배열에 추가하면 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3c9e846d5ff280c1c43c0fc859906e5949020f" translate="yes" xml:space="preserve">
          <source>Constructs an Element from a Tag.</source>
          <target state="translated">태그에서 요소를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b04b95cb59989b1f3e6f81986bdbf5684b4e8e11" translate="yes" xml:space="preserve">
          <source>Constructs an Element given a name and a string to be used as a Text interior.</source>
          <target state="translated">텍스트 내부로 사용될 이름과 문자열이 지정된 Element를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7ef5c16305c0cacfff7b62667368f5395c44c8f0" translate="yes" xml:space="preserve">
          <source>Constructs an instance of Tag with a specified name and type</source>
          <target state="translated">지정된 이름과 타입으로 Tag의 인스턴스를 구축합니다</target>
        </trans-unit>
        <trans-unit id="0eb54bebdca75e4774fca8547e272f327c707365" translate="yes" xml:space="preserve">
          <source>Constructs an object given two ranges &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; and a penalty &lt;code&gt;lambda&lt;/code&gt;. Constructor completes in &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time and computes all matches of length 1.</source>
          <target state="translated">두 개의 범위 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;t&lt;/code&gt; 와 페널티 &lt;code&gt;lambda&lt;/code&gt; 주어진 객체를 구성합니다 . 생성자는 &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) 시간 내에 완료되고 길이 1의 모든 일치 항목을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c2e1b07aa0f19ca657a0f923e6620e04e17d896" translate="yes" xml:space="preserve">
          <source>Constructs the HMAC digest using the specified secret.</source>
          <target state="translated">지정된 비밀을 사용해 HMAC 다이제스트를 구축합니다.</target>
        </trans-unit>
        <trans-unit id="3ac831e9f5e17e420e37b7e07bf6060ff89784d9" translate="yes" xml:space="preserve">
          <source>Container primitives</source>
          <target state="translated">컨테이너 프리미티브</target>
        </trans-unit>
        <trans-unit id="cdcf8089bd1bb28d912fe327273fec402f37b4f0" translate="yes" xml:space="preserve">
          <source>Containers do not form a class hierarchy, instead they implement a common set of primitives (see table below). These primitives each guarantee a specific worst case complexity and thus allow generic code to be written independently of the container implementation.</source>
          <target state="translated">컨테이너는 클래스 계층 구조를 형성하지 않고 일반적인 기본 세트를 구현합니다 (아래 표 참조). 이러한 프리미티브는 각각 최악의 특정 복잡성을 보장하므로 컨테이너 구현과 독립적으로 일반 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc21d6c189ee8cb63a6e6aac085f59dcacbe434" translate="yes" xml:space="preserve">
          <source>Contains a memset implementation used by compiler-generated code.</source>
          <target state="translated">컴파일러 생성 코드에서 사용하는 memset 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7a6f3a1f434d86f30876a874a0b93c581c1c8b1e" translate="yes" xml:space="preserve">
          <source>Contains a registry for GC factories.</source>
          <target state="translated">GC 팩토리의 레지스트리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e083cdb203f74feb48a6a33669824a6e66cb3369" translate="yes" xml:space="preserve">
          <source>Contains aggregate information about a block of managed memory. The purpose of this struct is to support a more efficient query style in instances where detailed information is needed.</source>
          <target state="translated">관리 메모리 블록에 대한 집계 정보를 포함합니다. 이 구조체의 목적은 자세한 정보가 필요한 경우보다 효율적인 쿼리 스타일을 지원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29492764613b66bb03de8ad7679e7a717630eb80" translate="yes" xml:space="preserve">
          <source>Contains aggregated diagnostics information.</source>
          <target state="translated">집계 된 진단 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="273a7dc903587fcac7ec096b9861c3c1e1e83e38" translate="yes" xml:space="preserve">
          <source>Contains all available CLI &lt;a href=&quot;#Usage.Option&quot;&gt;&lt;code&gt;Usage.Option&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">사용 가능한 모든 CLI &lt;a href=&quot;#Usage.Option&quot;&gt; &lt;code&gt;Usage.Option&lt;/code&gt; 을&lt;/a&gt; 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="7ca74771e8e4d50838a5d61dfe30a32ee401633a" translate="yes" xml:space="preserve">
          <source>Contains all data for a class declaration that is needed for the Objective-C integration.</source>
          <target state="translated">Objective-C 통합에 필요한 클래스 선언에 대한 모든 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5758660e7aee75739c576bec5bbbf585a0eeed56" translate="yes" xml:space="preserve">
          <source>Contains all text which occurs after the root element. Defaults to the empty string</source>
          <target state="translated">루트 요소 다음에 나오는 모든 텍스트를 포함합니다. 빈 문자열을 기본값으로</target>
        </trans-unit>
        <trans-unit id="d8783cd5f87b85b9067504dfc5f62c8eeef387c4" translate="yes" xml:space="preserve">
          <source>Contains all text which occurs before the root element. Defaults to &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;</source>
          <target state="translated">루트 요소 앞에 나타나는 모든 텍스트를 포함합니다. 기본적으로 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08c7edba7490157d52a2bebdf452e082ec47a85a" translate="yes" xml:space="preserve">
          <source>Contains druntime startup and shutdown routines.</source>
          <target state="translated">druntime 시작 및 종료 루틴을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="99a79c4c156e712bb397dee3eeb5c6eea6c0caf3" translate="yes" xml:space="preserve">
          <source>Contains implementations of functions called when the -profile=gc switch is thrown.</source>
          <target state="translated">-profile = gc 스위치가 발생할 때 호출되는 함수의 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="112d647b95fa2b2ab3d70a20ea3ae9e158bd5c22" translate="yes" xml:space="preserve">
          <source>Contains some information on how to extract this archive. See &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt; original documentation&lt;/a&gt; for details.</source>
          <target state="translated">이 아카이브를 추출하는 방법에 대한 정보를 포함합니다. 자세한 내용은 &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;원본 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61ba82fdcfc8dae9c85e2e28e679b79ee9524ff4" translate="yes" xml:space="preserve">
          <source>Contains support code for code profiling.</source>
          <target state="translated">코드 프로파일 링을위한 지원 코드가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d68b82f5a6be5a484ed9b7861d6e9244ca39d4e" translate="yes" xml:space="preserve">
          <source>Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical special functions are available in &lt;code&gt;std.mathspecial&lt;/code&gt;.</source>
          <target state="translated">기초 수학 함수 (승리, 근, 삼각 함수) 및 저수준 부동 소수점 연산을 포함합니다. 수학 특수 함수는 &lt;code&gt;std.mathspecial&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="374abc9326723db2e7c697a2e6e4a267fe502ba8" translate="yes" xml:space="preserve">
          <source>Contains the garbage collector configuration.</source>
          <target state="translated">가비지 수집기 구성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="55cac8fa5f9a9f51445b40b028c04583fd1b7e94" translate="yes" xml:space="preserve">
          <source>Contains the implementation for object monitors.</source>
          <target state="translated">오브젝트 모니터 구현을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c43e50c1f103bb404d1f65f3ca0cac200dba4a52" translate="yes" xml:space="preserve">
          <source>Contains the internal GC interface.</source>
          <target state="translated">내부 GC 인터페이스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a032e0777594355a5de7f90137f141d62d5d95dd" translate="yes" xml:space="preserve">
          <source>Contains various utility functions used by the runtime implementation.</source>
          <target state="translated">런타임 구현에서 사용되는 다양한 유틸리티 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a08a8cb56aef49a4bb99834f8677b54329650228" translate="yes" xml:space="preserve">
          <source>Content of this structure depends on information which is known and is achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man page for callbacks returning this structure -- some fields are mandatory, some others are optional. The FLAG field has special meaning.</source>
          <target state="translated">이 구조의 내용은 알려지고 달성 할 수있는 정보 (예 : FTP LIST 구문 분석)에 따라 다릅니다. 이 구조를 반환하는 콜백에 대해서는 url_easy_setopt (3) 매뉴얼 페이지를 참조하십시오. 일부 필드는 필수이며 일부는 선택 사항입니다. FLAG 필드는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d12b97ba61ffccb079e0dd2ef6809c1e957255" translate="yes" xml:space="preserve">
          <source>Content-Type</source>
          <target state="translated">Content-Type</target>
        </trans-unit>
        <trans-unit id="98251b802b3d8e0fab3d7ef7d11a13d8ba221384" translate="yes" xml:space="preserve">
          <source>Context Limitation</source>
          <target state="translated">상황 제한</target>
        </trans-unit>
        <trans-unit id="a63c8852980994787d7c6baea59a86eeb09c551f" translate="yes" xml:space="preserve">
          <source>Context Pointer</source>
          <target state="translated">컨텍스트 포인터</target>
        </trans-unit>
        <trans-unit id="6cc99c46b528420190afd0244c38be46fd558d8e" translate="yes" xml:space="preserve">
          <source>Continue Statement</source>
          <target state="translated">계속 진술</target>
        </trans-unit>
        <trans-unit id="e00690c736538c71ad18c2491100afa18d8ad07d" translate="yes" xml:space="preserve">
          <source>Continue to send authentication (user+password) when following locations, even when hostname changed. This can potentially send off the name and password to whatever host the server decides.</source>
          <target state="translated">호스트 이름이 변경된 경우에도 다음 위치에있을 때 인증 (사용자 + 암호)을 계속 보냅니다. 이것은 서버가 결정한 호스트에게 이름과 암호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="871aae3a25947aaa249c78c11e20e318f84bf435" translate="yes" xml:space="preserve">
          <source>Contract Programming</source>
          <target state="translated">계약 프로그래밍</target>
        </trans-unit>
        <trans-unit id="ef3ae2c761b4a2473b2910338e239fa3eb7fe7d0" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;arrayBounds&quot;&gt;arrayBounds&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;arrayBounds&quot;&gt;arrayBounds&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="58b151a487b5b15bd53e628c2aa67fcd794d1b65" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;assert_&quot;&gt;assert_&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;assert_&quot;&gt;assert_&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="5375164204a2f5e56cdbbed34a61f0552eceffaf" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;invariant_&quot;&gt;invariant_&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;invariant_&quot;&gt;불변량&lt;/strong&gt; 계약 확인 ;</target>
        </trans-unit>
        <trans-unit id="07797d6d70881f0065abbaa5d2db584cee41ccbe" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;postcondition&quot;&gt;postcondition&lt;/strong&gt;;</source>
          <target state="translated">계약 확인 &lt;strong id=&quot;postcondition&quot;&gt;후 상태&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b8c4e2d35f85c409b1763c5d617c7124eb387c47" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;precondition&quot;&gt;precondition&lt;/strong&gt;;</source>
          <target state="translated">계약 체결 &lt;strong id=&quot;precondition&quot;&gt;전제 조건&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d8a121a438ee5a2fb57a169295d9586a112d6e2a" translate="yes" xml:space="preserve">
          <source>ContractChecking &lt;strong id=&quot;switchError&quot;&gt;switchError&lt;/strong&gt;;</source>
          <target state="translated">ContractChecking &lt;strong id=&quot;switchError&quot;&gt;switchError&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="32767bc87ce3ae8cd973b35c715a2ae94be49543" translate="yes" xml:space="preserve">
          <source>Contracts</source>
          <target state="translated">Contracts</target>
        </trans-unit>
        <trans-unit id="e08ca7a19394780a00d421700b2b6072e92cd151" translate="yes" xml:space="preserve">
          <source>Contracts Reading List</source>
          <target state="translated">계약서 읽기 목록</target>
        </trans-unit>
        <trans-unit id="4a6fd7ad54f6db44bd48aaa1e54275e15709f220" translate="yes" xml:space="preserve">
          <source>Contracts are a breakthrough technique to reduce the programming effort for large projects. Contracts are the concept of preconditions, postconditions, errors, and invariants.</source>
          <target state="translated">계약은 대규모 프로젝트의 프로그래밍 노력을 줄이는 혁신적인 기술입니다. 계약은 전제 조건, 사후 조건, 오류 및 변형의 개념입니다.</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="adf251f07168589eca3ad151f045da715921ca0e" translate="yes" xml:space="preserve">
          <source>Control Pictures</source>
          <target state="translated">사진 제어</target>
        </trans-unit>
        <trans-unit id="1c2234cbd63091af60ac97c73f8399e25e57cbf0" translate="yes" xml:space="preserve">
          <source>Control and configure the D runtime.</source>
          <target state="translated">D 런타임을 제어하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="537748b8d0b3c009932ffdcb2807345633628bae" translate="yes" xml:space="preserve">
          <source>Control the Floating point hardware</source>
          <target state="translated">부동 소수점 하드웨어 제어</target>
        </trans-unit>
        <trans-unit id="c7f5075a114488026d76dd48e5050fddf4db4821" translate="yes" xml:space="preserve">
          <source>Control the built-in garbage collector.</source>
          <target state="translated">내장 가비지 수집기를 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="6184ead7fbc8b585f30f7328c7d83cf9c22576b4" translate="yes" xml:space="preserve">
          <source>Control the various text mode attributes, such as color, when writing text to the console.</source>
          <target state="translated">콘솔에 텍스트를 쓸 때 색상과 같은 다양한 텍스트 모드 속성을 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="0d531b827bceefa0692483efc8f1348a688772d8" translate="yes" xml:space="preserve">
          <source>Controls the assumptions the function makes about the lengths of the ranges</source>
          <target state="translated">함수가 범위의 길이에 대한 가정을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1fc385e9b61ce294ccbd6295a709917db7660e5f" translate="yes" xml:space="preserve">
          <source>Controls the assumptions the function makes about the lengths of the ranges (i.e. jagged or not)</source>
          <target state="translated">함수가 범위의 길이에 대한 가정을 제어합니다 (즉, 들쭉날쭉한지 여부)</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">쿼리 실행을위한 편의 루틴</target>
        </trans-unit>
        <trans-unit id="bbaf8ee56cf3b9369018adb601f4bf25663e048e" translate="yes" xml:space="preserve">
          <source>Convenience aliases for &lt;a href=&quot;#dur&quot;&gt;&lt;code&gt;dur&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#dur&quot;&gt; &lt;code&gt;dur&lt;/code&gt; 에&lt;/a&gt; 대한 편의 별명 .</target>
        </trans-unit>
        <trans-unit id="bd805f155418cecaf1531265afd99b52aac61ab2" translate="yes" xml:space="preserve">
          <source>Convenience function for constructing a generic container.</source>
          <target state="translated">일반 컨테이너 구성을위한 편의 기능</target>
        </trans-unit>
        <trans-unit id="97a89cd2033f72e4eb474981a122ebe612ce8f03" translate="yes" xml:space="preserve">
          <source>Convenience function for creating a &lt;code&gt;Rebindable&lt;/code&gt; using automatic type inference.</source>
          <target state="translated">자동 형식 유추를 사용하여 &lt;code&gt;Rebindable&lt;/code&gt; 을 만드는 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="7fe3ba594a0730c8377a41b425b9f0bdc446eba1" translate="yes" xml:space="preserve">
          <source>Convenience function for creating a &lt;code&gt;RedBlackTree!E&lt;/code&gt; from a list of values.</source>
          <target state="translated">값 목록에서 &lt;code&gt;RedBlackTree!E&lt;/code&gt; 를 작성하기위한 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="5fcfa4530313650065bc0666bdfaa3f7071ece58" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;InputRangeObject&lt;/code&gt; of the proper type.</source>
          <target state="translated">적절한 타입 의 &lt;code&gt;InputRangeObject&lt;/code&gt; 를 작성하기위한 간이 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="2deeddfbf7c17e3c5ed993f8f07764fedbbc9c86" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;InputRangeObject&lt;/code&gt; of the proper type. See &lt;a href=&quot;#InputRange&quot;&gt;&lt;code&gt;InputRange&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">적절한 타입 의 &lt;code&gt;InputRangeObject&lt;/code&gt; 를 작성하기위한 간이 함수입니다 . 예제는 &lt;a href=&quot;#InputRange&quot;&gt; &lt;code&gt;InputRange&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33f3457273684d37c964b9c19f1490014d05b78c" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;OutputRangeObject&lt;/code&gt; with a base range of type &lt;code&gt;R&lt;/code&gt; that accepts types &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 유형을 허용하는 &lt;code&gt;R&lt;/code&gt; 유형의 기본 범위를 갖는 &lt;code&gt;OutputRangeObject&lt;/code&gt; 를 작성하기위한 편의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="f13ca9b185b997f6100d99d5834656c2a0f654b1" translate="yes" xml:space="preserve">
          <source>Convenience function for creating an &lt;code&gt;OutputRangeObject&lt;/code&gt; with a base range of type R that accepts types E.</source>
          <target state="translated">E 유형을 허용하는 R 유형의 기본 범위로 &lt;code&gt;OutputRangeObject&lt;/code&gt; 를 작성하기위한 편의 함수</target>
        </trans-unit>
        <trans-unit id="543a17dfa7cd9fecc2d051d691cc274f44674a5b" translate="yes" xml:space="preserve">
          <source>Convenience function that forwards to &lt;code&gt;core.sys.posix.stdio.popen&lt;/code&gt; with appropriately-constructed C-style strings.</source>
          <target state="translated">적절하게 구성된 C 스타일 문자열을 사용 하여 &lt;code&gt;core.sys.posix.stdio.popen&lt;/code&gt; 으로 전달하는 편의 기능 .</target>
        </trans-unit>
        <trans-unit id="57e58ca108f45c53d8dfc085d29212201f4aa333" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a &lt;a href=&quot;#RefAppender&quot;&gt;&lt;code&gt;RefAppender&lt;/code&gt;&lt;/a&gt; instance initialized with &lt;code&gt;arrayPtr&lt;/code&gt;. Don't use null for the array pointer, use the other version of &lt;code&gt;appender&lt;/code&gt; instead.</source>
          <target state="translated">반환 편리한 기능 &lt;a href=&quot;#RefAppender&quot;&gt; &lt;code&gt;RefAppender&lt;/code&gt; 의&lt;/a&gt; 로 초기화 예를 &lt;code&gt;arrayPtr&lt;/code&gt; 을 . 배열 포인터에 null을 사용하지 말고 다른 버전의 &lt;code&gt;appender&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="281f96e0594e5b73a2e2e9d42b693c5d84ca8aef" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a &lt;code&gt;BinaryHeap!Store&lt;/code&gt; object initialized with &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;initialSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;initialSize&lt;/code&gt; 로 초기화 된 &lt;code&gt;BinaryHeap!Store&lt;/code&gt; 객체 를 반환하는 간이 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="dbf606ab86105b722d7651433b775855c8f60974" translate="yes" xml:space="preserve">
          <source>Convenience function that returns an &lt;a href=&quot;#Appender&quot;&gt;&lt;code&gt;Appender&lt;/code&gt;&lt;/a&gt; instance, optionally initialized with &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">선택적으로 &lt;code&gt;array&lt;/code&gt; 로 초기화 된 &lt;a href=&quot;#Appender&quot;&gt; &lt;code&gt;Appender&lt;/code&gt; &lt;/a&gt; 인스턴스 를 반환하는 편의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="47da49afa84caecf99a65771eecc2d27ea32a75e" translate="yes" xml:space="preserve">
          <source>Convenience function that turns an integral into the corresponding &lt;code&gt;Checked&lt;/code&gt; instance by using template argument deduction. The hook type may be specified (by default &lt;code&gt;Abort&lt;/code&gt;).</source>
          <target state="translated">템플릿 인수 공제를 사용하여 적분을 해당 &lt;code&gt;Checked&lt;/code&gt; 인스턴스 로 바꾸는 편의 기능 . 후크 유형을 지정할 수 있습니다 (기본적으로 &lt;code&gt;Abort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eb2cf7a70b87e610611dcba9cc0bdabcaa306a1" translate="yes" xml:space="preserve">
          <source>Convenience function that uses type deduction to return the appropriate &lt;code&gt;FallbackAllocator&lt;/code&gt; instance. To initialize with allocators that don't have state, use their &lt;code&gt;it&lt;/code&gt; static member.</source>
          <target state="translated">형식 추론을 사용하여 적절한 &lt;code&gt;FallbackAllocator&lt;/code&gt; 인스턴스 를 반환하는 편의 함수입니다 . 상태가없는 할당 자와 함께 초기화하려면, 자신의 사용 &lt;code&gt;it&lt;/code&gt; 정적 멤버를.</target>
        </trans-unit>
        <trans-unit id="81c10fc980c8a23004da700f26d2e49b63195765" translate="yes" xml:space="preserve">
          <source>Convenience function to construct optimal configurations for packed Trie from any &lt;code&gt;set&lt;/code&gt; of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">편리한 기능은 어떤에서 포장 트리는을위한 최적의 구성을 구성하는 &lt;code&gt;set&lt;/code&gt; 의 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa203451ffb1f6e9e972677557577f159f71f56a" translate="yes" xml:space="preserve">
          <source>Convenience function which calls &lt;a href=&quot;std_range_primitives#popFrontN&quot;&gt;&lt;code&gt;std.range.primitives.popFrontN&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(range, n)&lt;/code&gt; and returns &lt;code&gt;range&lt;/code&gt;. &lt;code&gt;drop&lt;/code&gt; makes it easier to pop elements from a range and then pass it to another function within a single expression, whereas &lt;code&gt;popFrontN&lt;/code&gt; would require multiple statements.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#popFrontN&quot;&gt; &lt;code&gt;std.range.primitives.popFrontN&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(range, n)&lt;/code&gt; 을 호출 하고 &lt;code&gt;range&lt;/code&gt; 를 반환 하는 편의 함수입니다 . &lt;code&gt;drop&lt;/code&gt; 을 사용하면 범위에서 요소를 더 쉽게 팝하고 단일 표현식 내에서 다른 함수로 전달할 수 있지만 &lt;code&gt;popFrontN&lt;/code&gt; 에는 여러 명령문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6ed83ebf96e10dc1b8f43752d4d2a8c69a7ef125" translate="yes" xml:space="preserve">
          <source>Convenience function which calls &lt;code&gt;range.popFront()&lt;/code&gt; and returns &lt;code&gt;range&lt;/code&gt;. &lt;code&gt;dropOne&lt;/code&gt; makes it easier to pop an element from a range and then pass it to another function within a single expression, whereas &lt;code&gt;popFront&lt;/code&gt; would require multiple statements.</source>
          <target state="translated">&lt;code&gt;range.popFront()&lt;/code&gt; 를 호출 하고 &lt;code&gt;range&lt;/code&gt; 를 반환 하는 편의 함수입니다 . &lt;code&gt;dropOne&lt;/code&gt; 을 사용하면 범위에서 요소를 더 쉽게 팝한 다음 단일 표현식 내에서 다른 함수로 전달할 수 있지만 &lt;code&gt;popFront&lt;/code&gt; 에는 여러 명령문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d00821ec7d482d22259510bb224af117d2300d18" translate="yes" xml:space="preserve">
          <source>Convenience function. Like find, but only returns whether or not the search was successful.</source>
          <target state="translated">편의 기능. 찾기와 같지만 검색이 성공했는지 여부 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3dc32f284d99498a3ff78fa7f8707de6601d006" translate="yes" xml:space="preserve">
          <source>Convenience functions for converting one or more arguments of any type into text (the three character widths).</source>
          <target state="translated">모든 유형의 하나 이상의 인수를 텍스트 (세 문자 너비)로 변환하기위한 편의 함수.</target>
        </trans-unit>
        <trans-unit id="63a9968094dce5e51d767213fb044fe75d3397ea" translate="yes" xml:space="preserve">
          <source>Convenience functions that create an &lt;code&gt;Fft&lt;/code&gt; object, run the FFT or inverse FFT and return the result. Useful for one-off FFTs.</source>
          <target state="translated">&lt;code&gt;Fft&lt;/code&gt; 객체 를 생성 하고 FFT를 실행하거나 역 FFT를 실행하여 결과를 반환하는 편의 함수입니다 . 일회성 FFT에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a5a94220c8ea5abfb148116a7e3799cbbf7ea2be" translate="yes" xml:space="preserve">
          <source>Convenience functions that forwards to &lt;code&gt;taskPool.parallel&lt;/code&gt;. The purpose of these is to make parallel foreach less verbose and more readable.</source>
          <target state="translated">&lt;code&gt;taskPool.parallel&lt;/code&gt; 로 전달하는 편의 기능 . 이것의 목적은 각각의 문장을 덜 장황하고 읽기 쉽게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="967ff579d1b9e412dbb4fb0ba6bf32a0206aa7b7" translate="yes" xml:space="preserve">
          <source>Convenience functions that throw an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">던져 편리한 기능 &lt;code&gt;StdioException&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4f361faef9831cb8d5034d73da3a4a91d8124d09" translate="yes" xml:space="preserve">
          <source>Convenience mixin for trivially sub-classing exceptions</source>
          <target state="translated">사소한 서브 클래 싱 예외를위한 편의 믹스 인</target>
        </trans-unit>
        <trans-unit id="df84ccbf276b4bf10a3abe6941075be97f75450b" translate="yes" xml:space="preserve">
          <source>Convenience names that allow using e.g. &lt;code&gt;Yes.encryption&lt;/code&gt; instead of &lt;code&gt;Flag!&quot;encryption&quot;.yes&lt;/code&gt; and &lt;code&gt;No.encryption&lt;/code&gt; instead of &lt;code&gt;Flag!&quot;encryption&quot;.no&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Flag!&quot;encryption&quot;.yes&lt;/code&gt; &lt;code&gt;No.encryption&lt;/code&gt; 대신 Yes.encryption! 및 &lt;code&gt;Flag!&quot;encryption&quot;.no&lt;/code&gt; 대신 &lt;code&gt;Yes.encryption&lt;/code&gt; 을 사용할 수있는 편의 이름 .</target>
        </trans-unit>
        <trans-unit id="1cb541d4dad444c9b9a7542a4394d7feffdcfdf0" translate="yes" xml:space="preserve">
          <source>Convenience wrapper around &lt;a href=&quot;#convClockFreq&quot;&gt;&lt;code&gt;convClockFreq&lt;/code&gt;&lt;/a&gt; which converts ticks at a clock frequency of &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; to nanoseconds.</source>
          <target state="translated">&lt;a href=&quot;#convClockFreq&quot;&gt; &lt;code&gt;convClockFreq&lt;/code&gt; &lt;/a&gt; 주변의 편의 래퍼로 MonoTime.ticksPerSecond 의 클럭 주파수에서 &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; 을 나노초 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2b5c35c190fd9666d416cddc663fbf2993d10e6b" translate="yes" xml:space="preserve">
          <source>Convenient operations commonly used with built-in arrays. Note that many common array operations are subsets of more generic algorithms that work with arbitrary ranges, so they are found in &lt;code&gt;std.algorithm&lt;/code&gt;.</source>
          <target state="translated">내장 어레이에 일반적으로 사용되는 편리한 조작. 많은 일반적인 배열 연산은 임의의 범위에서 작동하는보다 일반적인 알고리즘의 하위 집합이므로 &lt;code&gt;std.algorithm&lt;/code&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="e5a1bf84f0030e4788165ba4a4686a376904272f" translate="yes" xml:space="preserve">
          <source>Conversely, all of the &lt;code&gt;out&lt;/code&gt; contracts need to be satisfied, so overriding functions becomes a processes of</source>
          <target state="translated">반대로 모든 &lt;code&gt;out&lt;/code&gt; 계약은 충족되어야하므로 재정의 기능은 다음과 같은 프로세스가됩니다.</target>
        </trans-unit>
        <trans-unit id="c5af5b7bf221e414a8c6a208feed4235fe84af14" translate="yes" xml:space="preserve">
          <source>Conversely, allocating memory with one non-&lt;code&gt;shared&lt;/code&gt; allocator, passing it across threads (by casting the obtained buffer to &lt;code&gt;shared&lt;/code&gt;), and later deallocating it in a different thread (either with a different allocator object or with the same allocator object after casting it to &lt;code&gt;shared&lt;/code&gt;) is illegal.</source>
          <target state="translated">반대로, 하나의 &lt;code&gt;shared&lt;/code&gt; 할당 자에 메모리를 할당하고, 스레드를 통해 메모리를 전달하고 (구입 된 버퍼를 &lt;code&gt;shared&lt;/code&gt; 로 캐스팅하여 ) 나중에 다른 스레드 (다른 할당 자 객체 또는 다른 할당 자 객체를 사용하여 캐스팅 한 후)에 할당 해제 &lt;code&gt;shared&lt;/code&gt; )는 불법입니다.</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="494c619bf8123d3b37b181684cb6338f68758f1b" translate="yes" xml:space="preserve">
          <source>Conversion from string types to char types enforces the input to consist of a single code point, and said code point must fit in the target type. Otherwise, &lt;a href=&quot;#ConvException&quot;&gt;&lt;code&gt;ConvException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">문자열 유형에서 문자 유형으로 변환하면 입력이 단일 코드 포인트로 구성되고 해당 코드 포인트가 대상 유형에 맞아야합니다. 그렇지 않으면 &lt;a href=&quot;#ConvException&quot;&gt; &lt;code&gt;ConvException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9809150893d2b2bb036c8fb3972fbb95c93ae93b" translate="yes" xml:space="preserve">
          <source>Conversion operators. Convert from conversion operator to conversion index parallel array invconvtab[] in cgelem.c</source>
          <target state="translated">변환 연산자. cgelem.c의 변환 연산자에서 변환 색인 병렬 배열 invconvtab []로 변환</target>
        </trans-unit>
        <trans-unit id="6b9cd0af162c3095105f23d4382e114423f820eb" translate="yes" xml:space="preserve">
          <source>Conversion to bool and int</source>
          <target state="translated">bool 및 int로 변환</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="197e8fd63c43eaa131c7d71bd1c845f261c1ca73" translate="yes" xml:space="preserve">
          <source>Conversions from integral types to floating-point types always succeed, but might lose accuracy. The largest integers with a predecessor representable in floating-point format are &lt;code&gt;2^24-1&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;2^53-1&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;2^64-1&lt;/code&gt; for &lt;code&gt;real&lt;/code&gt; (when &lt;code&gt;real&lt;/code&gt; is 80-bit, e.g. on Intel machines).</source>
          <target state="translated">정수 유형에서 부동 소수점 유형으로의 변환은 항상 성공하지만 정확도가 떨어질 수 있습니다. 부동 소수점 형식의 선행 표현할 수와 가장 큰 정수는 &lt;code&gt;2^24-1&lt;/code&gt; 에 대한 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;2^53-1&lt;/code&gt; 에 대한 &lt;code&gt;double&lt;/code&gt; , 및 &lt;code&gt;2^64-1&lt;/code&gt; 에 대한 &lt;code&gt;real&lt;/code&gt; (때 &lt;code&gt;real&lt;/code&gt; 인텔 시스템에서 80 비트, 예입니다) .</target>
        </trans-unit>
        <trans-unit id="86f181ecd6da52a393babcdf0413f894069d62dc" translate="yes" xml:space="preserve">
          <source>Conversions from string to numeric types differ from the C equivalents &lt;code&gt;atoi()&lt;/code&gt; and &lt;code&gt;atol()&lt;/code&gt; by checking for overflow and not allowing whitespace.</source>
          <target state="translated">문자열에서 숫자 유형으로의 변환은 오버 플로우를 확인하고 공백을 허용하지 않음에 따라 &lt;code&gt;atoi()&lt;/code&gt; 및 &lt;code&gt;atol()&lt;/code&gt; C와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7d749a4f79969e83668c822ec3cb207e0dfcb26a" translate="yes" xml:space="preserve">
          <source>Conversions operate transitively, meaning that they work on arrays and associative arrays of any complexity.  This conversion works because &lt;code&gt;to!short&lt;/code&gt; applies to an &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;to!wstring&lt;/code&gt; applies to a &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;to!string&lt;/code&gt; applies to a &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;to!(double[])&lt;/code&gt; applies to an &lt;code&gt;int[]&lt;/code&gt;. The conversion might throw an exception because &lt;code&gt;to!short&lt;/code&gt; might fail the range check.</source>
          <target state="translated">변환은 전 이적으로 작동하므로 복잡한 배열 및 연관 배열에서 작동합니다. 때문에 변환 작업 &lt;code&gt;to!short&lt;/code&gt; 적용 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;to!wstring&lt;/code&gt; A를 적용 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;to!string&lt;/code&gt; A와 적용 &lt;code&gt;double&lt;/code&gt; , 그리고 &lt;code&gt;to!(double[])&lt;/code&gt; 에 적용 &lt;code&gt;int[]&lt;/code&gt; . &lt;code&gt;to!short&lt;/code&gt; 는 범위 검사에 실패 할 수 있으므로 변환에서 예외 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f15ce79532d7a88716daffe2b5fa5245abe9c20" translate="yes" xml:space="preserve">
          <source>Convert</source>
          <target state="translated">Convert</target>
        </trans-unit>
        <trans-unit id="cbfd7dd188ff7f487f68697a8d34f14f04f7dec6" translate="yes" xml:space="preserve">
          <source>Convert Expression to elem, then append destructors for any temporaries created in elem.</source>
          <target state="translated">Expression을 elem으로 변환 한 다음 elem에서 만든 모든 임시 요소에 대해 소멸자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="300d1d44e039ebbc34544e6257ab84ea8d05e054" translate="yes" xml:space="preserve">
          <source>Convert MODxxxx to STCxxx</source>
          <target state="translated">MODxxxx를 STCxxx로 변환</target>
        </trans-unit>
        <trans-unit id="cac4192e2c3b155cebc1be34d4b77eb443e533c0" translate="yes" xml:space="preserve">
          <source>Convert Object to a human readable string.</source>
          <target state="translated">Object를 사람이 읽을 수있는 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a157b506be054ad583671757f6739b58b4eae2cf" translate="yes" xml:space="preserve">
          <source>Convert Win32 error code to string.</source>
          <target state="translated">Win32 오류 코드를 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="8203e1072dab83cb9ec37a4f4016d9ab9deef361" translate="yes" xml:space="preserve">
          <source>Convert a callable to a delegate with the same parameter list and return type, avoiding heap allocations and use of auxiliary storage.</source>
          <target state="translated">힙 할당 및 보조 기억 장치 사용을 피하면서 호출 가능 매개 변수를 동일한 매개 변수 목록 및 리턴 유형을 가진 대리자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ddfa177b3d340952f0710190200b69c560b06948" translate="yes" xml:space="preserve">
          <source>Convert a narrow autodecoding string to an array type that fully supports random access. This is handled as a special case and always returns an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">좁은 자동 디코딩 문자열을 임의 액세스를 완전히 지원하는 배열 유형으로 변환합니다. 이것은 특별한 경우로 처리되며 항상 &lt;code&gt;dchar&lt;/code&gt; 의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7616efe01f9711b656d048ab996095537d915ed4" translate="yes" xml:space="preserve">
          <source>Convert a narrow string to an array type that fully supports random access. This is handled as a special case and always returns an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">좁은 문자열을 임의 액세스를 완전히 지원하는 배열 유형으로 변환하십시오. 이것은 특별한 경우로 처리되며 항상 &lt;code&gt;dchar&lt;/code&gt; 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae8c143fc472917c228a5c0ff4611ff8f4b320dd" translate="yes" xml:space="preserve">
          <source>Convert a string from one encoding to another.</source>
          <target state="translated">한 인코딩에서 다른 인코딩으로 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="775fe4e45be29046b343c44db1012fcf4054e8bd" translate="yes" xml:space="preserve">
          <source>Convert an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or a string to upper or lower case.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 또는 문자열을 대문자 또는 소문자로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c279cb7055f08eba41ad9320ed65a8b4bd24423e" translate="yes" xml:space="preserve">
          <source>Convert an IPv4 address number in host byte order to a human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">호스트 바이트 순서의 IPv4 주소 번호를 점으로 구분 된 십진수 형식으로 IPv4 주소를 나타내는 사람이 읽을 수있는 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="7a94a08d73d55d4d138a67dc22b14b4c3e02569f" translate="yes" xml:space="preserve">
          <source>Convert array to a dynamic array.</source>
          <target state="translated">배열을 동적 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6ca78c70b84ae82ae6555ba40c8527618a61c871" translate="yes" xml:space="preserve">
          <source>Convert array to a pointer to the data.</source>
          <target state="translated">배열을 데이터에 대한 포인터로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="6a023ef771ded91cccae26939483968bef14680b" translate="yes" xml:space="preserve">
          <source>Convert expression into a delegate.</source>
          <target state="translated">식을 대리자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="21d2c697aa6b1950d17d8a4c4f437a6c775e1abd" translate="yes" xml:space="preserve">
          <source>Convert from pointer to exception_object field to pointer to CppExceptionHeader that it is embedded inside of.</source>
          <target state="translated">포인터를 exception_object 필드로 변환하고 그 안에 포함 된 CppExceptionHeader를 가리키는 포인터로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ca97d234020c359f0ea9445b2940ce5ecabb073f" translate="yes" xml:space="preserve">
          <source>Convert from pointer to exception_object to pointer to ExceptionHeader that it is embedded inside of.</source>
          <target state="translated">내부에 포함 된 ExceptionHeader에 대한 포인터에서 exception_object로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="141d85c0215cf01962972ffaaf51166d383ad99a" translate="yes" xml:space="preserve">
          <source>Convert front end type &lt;code&gt;t&lt;/code&gt; to backend type &lt;code&gt;t.ctype&lt;/code&gt;. Memoize the result.</source>
          <target state="translated">프론트 엔드 유형 &lt;code&gt;t&lt;/code&gt; 를 백엔드 유형 &lt;code&gt;t.ctype&lt;/code&gt; 으로 변환하십시오 . 결과를 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="cdd72d6f2bdb11b763377603b2356cca157b65d6" translate="yes" xml:space="preserve">
          <source>Convert integer to a range of characters. Intended to be lightweight and fast.</source>
          <target state="translated">정수를 문자 범위로 변환하십시오. 가볍고 빠르다.</target>
        </trans-unit>
        <trans-unit id="dbbceb68e9badc857157ec44ce9e4004ea0d70fb" translate="yes" xml:space="preserve">
          <source>Convert integral value to string in radix radix. radix must be a value from 2 to 36. value is treated as a signed value only if radix is 10. The characters A through Z are used to represent values 10 through 36 and their case is determined by the letterCase parameter.</source>
          <target state="translated">기수로 적분 값을 문자열로 변환합니다. 기수는 2-36 사이의 값이어야합니다. 기수는 10 인 경우에만 부호있는 값으로 처리됩니다. 문자 A-Z는 값 10-36을 나타내는 데 사용되며 대소 ​​문자는 letterCase 매개 변수에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b617a1afa58073368ac7644c913c0a1351ae0d" translate="yes" xml:space="preserve">
          <source>Convert internal buffer to array of chars.</source>
          <target state="translated">내부 버퍼를 문자 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f1c0c49893f30f59cf861f572b87531ec8714ef8" translate="yes" xml:space="preserve">
          <source>Convert intrinsic function to operator.</source>
          <target state="translated">내장 함수를 연산자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="df7a4dda020c82114c65501c86fda6ef64fb7578" translate="yes" xml:space="preserve">
          <source>Convert string contents to a 0 terminated string, allocated by mem.xmalloc().</source>
          <target state="translated">문자열 내용을 mem.xmalloc ()에 의해 할당 된 0 종료 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ec4aa6a499b7d8a47d71bacac0397813ddfaa4db" translate="yes" xml:space="preserve">
          <source>Convert string to char[].</source>
          <target state="translated">문자열을 char []로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5b362d69a7b7939119a85847912d34f42f3d2a" translate="yes" xml:space="preserve">
          <source>Convert the &lt;code&gt;BigInt&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;, passing it to the given sink.</source>
          <target state="translated">지정된 싱크로 전달 하여 &lt;code&gt;BigInt&lt;/code&gt; 를 &lt;code&gt;string&lt;/code&gt; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e697a11907653a602483019409a860f0b6b446e" translate="yes" xml:space="preserve">
          <source>Convert the result of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; to &lt;a href=&quot;#ParameterStorageClass&quot;&gt;&lt;code&gt;ParameterStorageClass&lt;/code&gt;&lt;/a&gt;&lt;code&gt;enum&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; 의 결과 를 &lt;a href=&quot;#ParameterStorageClass&quot;&gt; &lt;code&gt;ParameterStorageClass&lt;/code&gt; &lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7da59e0b399f4430a5165fc7efc2188b462909d8" translate="yes" xml:space="preserve">
          <source>Convert to 'const'.</source>
          <target state="translated">'const'로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="2d339781d067223d4ff6ffa91e1a499862e4e10d" translate="yes" xml:space="preserve">
          <source>Convert to 'immutable'.</source>
          <target state="translated">'불변'으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="64a97922b6ad5fabb50249f78bb7261af9bfcdc7" translate="yes" xml:space="preserve">
          <source>Convert to 'wild'.</source>
          <target state="translated">'wild'로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="87e0f4222e74eab68817299371f9ec11a177e211" translate="yes" xml:space="preserve">
          <source>Convert to &lt;code&gt;size_t[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size_t[]&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b01671f329e1e8db8dfaf9b057f7d93f19d92bc" translate="yes" xml:space="preserve">
          <source>Convert to &lt;code&gt;void[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void[]&lt;/code&gt; 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7e573911db63a61f22b50d1d7f51e71f6801020" translate="yes" xml:space="preserve">
          <source>Convert to array of bytes.</source>
          <target state="translated">바이트 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="81f5f7ef2860779e845c8d181cf922cbaa33cd4e" translate="yes" xml:space="preserve">
          <source>Convert types from one type to another.</source>
          <target state="translated">한 유형에서 다른 유형으로 유형을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="f2ca50a2d69bd1118ceb42e9e63fb2cadf8cec83" translate="yes" xml:space="preserve">
          <source>Convert wrapped value to a human readable string</source>
          <target state="translated">랩핑 된 값을 사람이 읽을 수있는 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="792ceeff170dffe3167fec916d1a3b1293c9dd91" translate="yes" xml:space="preserve">
          <source>Converted to D from curl headers by &lt;a href=&quot;http://www.digitalmars.com/d/2.0/htod.html&quot;&gt;htod&lt;/a&gt; and cleaned up by Jonas Drewsen (jdrewsen)</source>
          <target state="translated">&lt;a href=&quot;http://www.digitalmars.com/d/2.0/htod.html&quot;&gt;htod에&lt;/a&gt; 의해 curl header에서 D로 변환 되고 Jonas Drewsen (jdrewsen)에 의해 정리</target>
        </trans-unit>
        <trans-unit id="b36e0d9093c25cbc6e2a4908ce26bc8670d8275a" translate="yes" xml:space="preserve">
          <source>Converting a value to its own type (useful mostly for generic code) simply returns its argument.</source>
          <target state="translated">값을 고유 한 유형으로 변환하면 (일반적으로 일반 코드에 유용함) 단순히 인수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="450f535fe5b129de6888d6e0eaa750ca3a090834" translate="yes" xml:space="preserve">
          <source>Converting among numeric types is a safe way to cast them around.  Conversions from floating-point types to integral types allow loss of precision (the fractional part of a floating-point number). The conversion is truncating towards zero, the same way a cast would truncate. (To round a floating point value when casting to an integral, use &lt;code&gt;roundTo&lt;/code&gt;.)</source>
          <target state="translated">숫자 유형간에 변환하는 것이 안전한 방법입니다. 부동 소수점 유형에서 정수 유형으로 변환하면 정밀도 손실 (부동 소수점 수의 소수 부분)이 허용됩니다. 캐스트가 잘리는 것과 같은 방식으로 변환이 0으로 잘립니다. 정수로 캐스트 할 때 부동 소수점 값을 반올림하려면 &lt;code&gt;roundTo&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="031bf48dec6b48a765724d561163e257c0bd643c" translate="yes" xml:space="preserve">
          <source>Converting an array to another array type works by converting each element in turn. Associative arrays can be converted to associative arrays as long as keys and values can in turn be converted.</source>
          <target state="translated">각 요소를 차례로 변환하면 배열을 다른 배열 유형으로 변환 할 수 있습니다. 키와 값을 차례로 변환 할 수 있으면 연관 배열을 연관 배열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54717abb3bcd9a560b4033abb55a3f1b9abaf0c" translate="yes" xml:space="preserve">
          <source>Converting text to any of the four normalization forms via &lt;a href=&quot;#normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">를 통해 네 개의 정규화 형태의 텍스트를 변환 &lt;a href=&quot;#normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a774f38191f5ee26ac3460d0bd0ede6e3b255259" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;s&lt;/code&gt; to lowercase (by performing Unicode lowercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If &lt;code&gt;s&lt;/code&gt; does not have any uppercase characters, then &lt;code&gt;s&lt;/code&gt; is unaltered.</source>
          <target state="translated">변환 &lt;code&gt;s&lt;/code&gt; 대신에 (유니 코드 소문자 매핑을 수행하여) 소문자로. 변환 후 몇 자의 문자열 길이가 증가 할 수 있으며,이 경우 함수가 정확히 한 번 재 할당됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 모든 대문자가없는 한 다음 &lt;code&gt;s&lt;/code&gt; 변경되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="f50788ea46280702695186b92c1242c64d22af55" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;s&lt;/code&gt; to uppercase (by performing Unicode uppercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If &lt;code&gt;s&lt;/code&gt; does not have any lowercase characters, then &lt;code&gt;s&lt;/code&gt; is unaltered.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 대문자로 변환합니다 (유니 코드 대문자 매핑을 수행하여). 변환 후 몇 자의 문자열 길이가 증가 할 수 있으며,이 경우 함수가 정확히 한 번 재 할당됩니다. 경우 &lt;code&gt;s&lt;/code&gt; 모든 소문자가없는 한 다음 &lt;code&gt;s&lt;/code&gt; 변경되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ae33ebc9b2f5b3c2490b1760900c22c6b676fbc" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;FILETIME&lt;/code&gt; struct.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;FILETIME&lt;/code&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="56be3b4d1a90af46d0b4592f89cac9048787f523" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="894edb86f4a8a0cd1f69c6b5d9062818feeb4ddd" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;FILETIME&lt;/code&gt; struct to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 구조체를 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="ed832f63736b31569fc124964cd3c928884d26d6" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;FILETIME&lt;/code&gt; struct to the number of hnsecs since midnight, January 1st, 1 A.D.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 구조체를 AD 1 월 1 일 자정 이후의 hnsec 수로 변환</target>
        </trans-unit>
        <trans-unit id="cf543602844b3062641ecae07379d485cf8d1e9c" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SYSTEMTIME&lt;/code&gt; 구조체를 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="543b837fe53783efdefb34be70919c615cbd90b2" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;TickDuration&lt;/code&gt; to the given units as either an integral value or a floating point value.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 을 정수 또는 부동 소수점 값으로 지정된 단위로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="da8e27299262cc14743b153feb76d11d4fc53020" translate="yes" xml:space="preserve">
          <source>Converts a callable to a delegate.</source>
          <target state="translated">콜 러블을 델리게이트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b2246d69735597617ac670e1cd79c63e9b7c718e" translate="yes" xml:space="preserve">
          <source>Converts a hex literal to a string at compile time.</source>
          <target state="translated">컴파일 타임에 16 진 리터럴을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="83a9e235dafe38c896876f468796a7e891631152" translate="yes" xml:space="preserve">
          <source>Converts a multi-argument function into a series of single-argument functions. f(x, y) == curry(f)(x)(y)</source>
          <target state="translated">다중 인수 함수를 일련의 단일 인수 함수로 변환합니다. f (x, y) == 카레 (f) (x) (y)</target>
        </trans-unit>
        <trans-unit id="12fd3fc98603c4c30662a5d938bee086fc318076" translate="yes" xml:space="preserve">
          <source>Converts a number of hnsecs since midnight, January 1st, 1 A.D. to a &lt;code&gt;FILETIME&lt;/code&gt; struct.</source>
          <target state="translated">AD 1 월 1 일 자정 이후의 hnsec 수를 &lt;code&gt;FILETIME&lt;/code&gt; 구조체로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e8645b8b019a6a92357fd2abaf953b052fdc1822" translate="yes" xml:space="preserve">
          <source>Converts an ASCII letter to lowercase.</source>
          <target state="translated">ASCII 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="498c6f9ce172411761c196b39cf785adcfc26947" translate="yes" xml:space="preserve">
          <source>Converts an ASCII letter to uppercase.</source>
          <target state="translated">ASCII 문자를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f236af9686b5551670717880afe98b4a169a9b35" translate="yes" xml:space="preserve">
          <source>Converts any foreach-iterable entity (e.g. an input range) to an alias sequence.</source>
          <target state="translated">각각의 반복 가능한 엔티티 (예 : 입력 범위)를 별명 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd9c57aa4a490cac5e73dc3d34bbb7dcb896ecd" translate="yes" xml:space="preserve">
          <source>Converts array (other than strings) to string. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">문자열 이외의 배열을 문자열로 변환합니다. 각 요소는 &lt;code&gt;to!T&lt;/code&gt; 를 호출 하여 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f0da0dc296d4db8687cb43fe21c97d98f43b18d" translate="yes" xml:space="preserve">
          <source>Converts from &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to DOS file date/time.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 DOS 파일 날짜 / 시간으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="203d4991495ad2a5ccd5bf2eb36f27bdb41d0ab3" translate="yes" xml:space="preserve">
          <source>Converts from DOS file date/time to &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DOS 파일 날짜 / 시간에서 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="96775ca56ca5ed48ab90888921d90905553fc258" translate="yes" xml:space="preserve">
          <source>Converts from unix time (i.e. seconds from midnight, January 1st, 1970 in UTC) to a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유닉스 시간 (즉, 1970 년 1 월 1 일 자정에서 UTC로 초)을 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 으로 변환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="47a6cd5246b5128f541dc1f56c74256ce4a5cf6e" translate="yes" xml:space="preserve">
          <source>Converts from unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units) to &quot;std time&quot; (which uses midnight, January 1st, 1 A.D. UTC and hnsecs as its units).</source>
          <target state="translated">unix 시간 (1970 년 1 월 1 일 자정을 UTC로, 초를 단위로 사용)을 &quot;std time&quot;(1 월 1 일 1 일 자정을 UTC로 사용하고 hnsecs를 단위로)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2ff42625e816f32f0e903105abab719aab3bc247" translate="yes" xml:space="preserve">
          <source>Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch and hnsecs as its units) to unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units).</source>
          <target state="translated">std 시간 (1 월 1 일 자정 1 AD UTC를 에포크로 사용하고 hnsecs를 단위로 사용)을 유닉스 시간 (1970 년 1 월 1 일 자정 UTC를 에포크로 사용하고 초를 단위로 사용)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="02026be234370e8ba0fa5a12a01ca8dc15195021" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 string s into a null-terminated string in a Windows 8-bit character set.</source>
          <target state="translated">UTF-8 문자열을 Windows 8 비트 문자 세트의 널 종료 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="68545d42d5434868c8492fc2ad3250e2f1494c37" translate="yes" xml:space="preserve">
          <source>Converts the complex number to a string representation.</source>
          <target state="translated">복소수를 문자열 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d4417d8f06d1b116703d3dde566fa560d538d75d" translate="yes" xml:space="preserve">
          <source>Converts the given time from one clock frequency/resolution to another.</source>
          <target state="translated">주어진 시간을 한 클럭 주파수 / 해상도에서 다른 클럭 주파수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1a6e949bbca6ba048ef59d86f6355918bc8f8588" translate="yes" xml:space="preserve">
          <source>Converts the given value from big endian to the native endianness and returns it. The value is given as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type.</source>
          <target state="translated">주어진 값을 빅 엔디안에서 네이티브 엔디안으로 변환하여 반환합니다. 값은 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 제공되며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 대상 유형의 크기입니다. 크기가 동일한 여러 유형이 있으므로 인수 유형이 리턴 유형을 판별하기에 충분하지 않으므로 대상 유형을 템플리트 인수로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="99754092cef6ee8c6b8a8736f7dda136a6df1796" translate="yes" xml:space="preserve">
          <source>Converts the given value from little endian to the native endianness and returns it. The value is given as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type.</source>
          <target state="translated">주어진 값을 리틀 엔디안에서 네이티브 엔디안으로 변환하여 반환합니다. 값은 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 제공됩니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 대상 유형의 크기입니다. 크기가 동일한 여러 유형이 있으므로 인수 유형이 리턴 유형을 판별하기에 충분하지 않으므로 대상 유형을 템플리트 인수로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7026ec6ca618852b8dbaface42f39c87c3912a93" translate="yes" xml:space="preserve">
          <source>Converts the given value from the native endianness to big endian and returns it as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the given type.</source>
          <target state="translated">주어진 값을 원시 엔디안에서 빅 엔디안으로 변환하고 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 반환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 주어진 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="db7766a0ee6d7c4c104a32edc118f2a266f57364" translate="yes" xml:space="preserve">
          <source>Converts the given value from the native endianness to little endian and returns it as a &lt;code&gt;ubyte[n]&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the size of the given type.</source>
          <target state="translated">주어진 값을 원시 엔디안에서 리틀 엔디안으로 변환하고 &lt;code&gt;ubyte[n]&lt;/code&gt; 으로 반환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 주어진 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="71032212236b6edba85329a7e36a9ebec7e90c73" translate="yes" xml:space="preserve">
          <source>Converts the null-terminated string s from a Windows 8-bit character set into a UTF-8 char array.</source>
          <target state="translated">널 종료 문자열을 Windows 8 비트 문자 세트에서 UTF-8 문자 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="453bede937d557afda6a1aea6ab1d8f1c5734489" translate="yes" xml:space="preserve">
          <source>Converts the store &lt;code&gt;s&lt;/code&gt; into a heap. If &lt;code&gt;initialSize&lt;/code&gt; is specified, only the first &lt;code&gt;initialSize&lt;/code&gt; elements in &lt;code&gt;s&lt;/code&gt; are transformed into a heap, after which the heap can grow up to &lt;code&gt;r.length&lt;/code&gt; (if &lt;code&gt;Store&lt;/code&gt; is a range) or indefinitely (if &lt;code&gt;Store&lt;/code&gt; is a container with &lt;code&gt;insertBack&lt;/code&gt;). Performs &amp;Omicron;(&lt;code&gt;min(r.length, initialSize)&lt;/code&gt;) evaluations of &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">가게 변환 &lt;code&gt;s&lt;/code&gt; 힙에. 경우 &lt;code&gt;initialSize&lt;/code&gt; 가이 지정된 경우에만 제 &lt;code&gt;initialSize&lt;/code&gt; 가 된 요소 &lt;code&gt;s&lt;/code&gt; 힙가 자랄 수있는 후 힙로 변환된다 &lt;code&gt;r.length&lt;/code&gt; (경우 &lt;code&gt;Store&lt;/code&gt; (무기한의 범위이다) 또는 &lt;code&gt;Store&lt;/code&gt; 와 컨테이너 &lt;code&gt;insertBack&lt;/code&gt; ). &amp;Omicron; 행한다 ( &lt;code&gt;min(r.length, initialSize)&lt;/code&gt; )의 평가를 &lt;code&gt;less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f93578046a37a61d755a351d7403ee07d2feb19" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6603b566288f85150171c62cd84c2febe4e416d1" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-Mon-DD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYY-Mon-DD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bbed58be0aee4969a87b68c3fa4d895942507f6c" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYYMMDD&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;YYYYMMDD&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6a1ebbb6b69924d680654dfe931f3d107306042b" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2cdf3feb7790120701384059bf58b361680f227a" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-MM-DDTHH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYY-MM-DDTHH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b6f600d98add32575a23efab5b281c9146f97b" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYY-Mon-DD HH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYY-Mon-DD HH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f02a2e92abc14cc294c7e38e57188968b21a1abb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;YYYYMMDDTHHMMSS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;YYYYMMDDTHHMMSS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="db51859446cb3a5e9180034baebbd2056ca398e0" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2476ac04da69ffdc944a61493a1b71959fe371eb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYY-MM-DDTHH : MM : SS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="6fd506aa039e90544044bf8ca9bc422fc2f26564" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYY-Mon-DD HH : MM : SS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="d39abfdab21a7e5012c4e5c22865dc3c6b9b9a8f" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time zone).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 YYYYMMDDTHHMMSS.FFFFFFFTZ 형식의 문자열로 변환합니다 (여기서 F는 소수 초이고 TZ는 시간대입니다).</target>
        </trans-unit>
        <trans-unit id="288ffc29180217ab372bbf85f774ec19f9c71bdb" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="b5ead06637aa29f4e0f3f6e8350a6b3d0470262f" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to unix time (i.e. seconds from midnight, January 1st, 1970 in UTC).</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 유닉스 시간으로 변환합니다 (즉, 1970 년 1 월 1 일 자정에서 UTC로 초).</target>
        </trans-unit>
        <trans-unit id="11c0c6c4e0883ccde835c4d2ba2f873e1dc0fe81" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;HH:MM:SS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;HH:MM:SS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="289897447b39fc44b7870f5a328e8892eb4029c1" translate="yes" xml:space="preserve">
          <source>Converts this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string with the format &lt;code&gt;HHMMSS&lt;/code&gt;. If &lt;code&gt;writer&lt;/code&gt; is set, the resulting string will be written directly to it.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;HHMMSS&lt;/code&gt; 형식의 문자열로 변환합니다 . 경우 &lt;code&gt;writer&lt;/code&gt; 설정되어, 결과 문자열을 직접 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8233cbfc0d952b5bfeda989512aed9518e2812db" translate="yes" xml:space="preserve">
          <source>Converts this &lt;code&gt;Duration&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 를 &lt;code&gt;string&lt;/code&gt; 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e0e45d39cee812b4f40d98644bee8bb2dbdb9d" translate="yes" xml:space="preserve">
          <source>Converts this TimeOfDay to a string.</source>
          <target state="translated">이 TimeOfDay를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2d70de6e4f1b10ef5bbf7032a91df90630348700" translate="yes" xml:space="preserve">
          <source>Converts this interval to a string.</source>
          <target state="translated">이 간격을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="da35025d96842d394967858a7a95f5b87cb34797" translate="yes" xml:space="preserve">
          <source>Converts to string.</source>
          <target state="translated">문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cf38165162fb8000f4b46022cfe90ad022d53d08" translate="yes" xml:space="preserve">
          <source>Copies a range to another. If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = new int[5]&lt;/code&gt;, then &lt;code&gt;copy(a, b)&lt;/code&gt; leaves &lt;code&gt;b = [1, 2, 3, 0, 0]&lt;/code&gt; and returns &lt;code&gt;b[3 .. $]&lt;/code&gt;.</source>
          <target state="translated">범위를 다른 범위로 복사합니다. 하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 및 &lt;code&gt;b = new int[5]&lt;/code&gt; 다음 &lt;code&gt;copy(a, b)&lt;/code&gt; 잎 &lt;code&gt;b = [1, 2, 3, 0, 0]&lt;/code&gt; 되돌아 &lt;code&gt;b[3 .. $]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14bbc85755baa25d4951be7218064216daa78c34" translate="yes" xml:space="preserve">
          <source>Copies all environment variables into an associative array.</source>
          <target state="translated">모든 환경 변수를 연관 배열로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="3484c1ab3cd6af03dbf05b6c0cb7f8dbede1bc3e" translate="yes" xml:space="preserve">
          <source>Copies out the top elements of a range.</source>
          <target state="translated">범위의 최상위 요소를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="3760826c7bb74f35fbcd18d73458a48731a1bc5b" translate="yes" xml:space="preserve">
          <source>Copies out the values that occur most frequently (multiplied by per-value weights) in a range of ranges.</source>
          <target state="translated">범위 범위에서 가장 자주 발생하는 값 (값당 가중치를 곱한 값)을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="7bdd3f12e99e3b707353754ea1c09e13976482b7" translate="yes" xml:space="preserve">
          <source>Copies out the values that occur most frequently in a range of ranges.</source>
          <target state="translated">다양한 범위에서 가장 자주 발생하는 값을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="cc55bda0ef1918898bb2580421cef4d1e592ad70" translate="yes" xml:space="preserve">
          <source>Copies the content of &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;target&lt;/code&gt; and returns the remaining (unfilled) part of &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">복사본의 컨텐츠 &lt;code&gt;source&lt;/code&gt; 에 &lt;code&gt;target&lt;/code&gt; 및 나머지 (잔여) 부분 반환 &lt;code&gt;target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78798d20653e71e4060adbb2cf9963f5c8d2dbc1" translate="yes" xml:space="preserve">
          <source>Copies the top &lt;code&gt;n&lt;/code&gt; elements of the &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;&lt;code&gt;source&lt;/code&gt; into the random-access range &lt;code&gt;target&lt;/code&gt;, where &lt;code&gt;n = target.length&lt;/code&gt;. Elements of &lt;code&gt;source&lt;/code&gt; are not touched. If &lt;code&gt;sorted&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target is sorted. Otherwise, the target respects the &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;heap property&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위 &lt;/a&gt; &lt;code&gt;source&lt;/code&gt; 의 상위 &lt;code&gt;n&lt;/code&gt; 개 요소를 랜덤 액세스 범위 &lt;code&gt;target&lt;/code&gt; 에 복사합니다 ( 여기서 &lt;code&gt;n = target.length&lt;/code&gt; . &lt;code&gt;source&lt;/code&gt; 요소는 건드리지 않습니다. 경우 &lt;code&gt;sorted&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 대상이 정렬됩니다. 그렇지 않으면 대상은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;힙 특성을&lt;/a&gt; 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="f8909a2f89d37e4a1395c4735e8c64cffa4be2dd" translate="yes" xml:space="preserve">
          <source>Copies the top &lt;code&gt;n&lt;/code&gt; elements of the &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;&lt;code&gt;source&lt;/code&gt; into the random-access range &lt;code&gt;target&lt;/code&gt;, where &lt;code&gt;n = target.length&lt;/code&gt;. Elements of &lt;code&gt;source&lt;/code&gt; are not touched. If &lt;code&gt;sorted&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target is sorted. Otherwise, the target respects the &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_heap&quot;&gt;heap property&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c860f91e1096880f98894442e0fd5b51861a8938" translate="yes" xml:space="preserve">
          <source>Copies type qualifiers from &lt;code&gt;FromType&lt;/code&gt; to &lt;code&gt;ToType&lt;/code&gt;.</source>
          <target state="translated">사본에서 예선 입력 &lt;code&gt;FromType&lt;/code&gt; 을 에 &lt;code&gt;ToType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f831e18f3d39d06a4db85c2a93c55cd8de3583f9" translate="yes" xml:space="preserve">
          <source>Coptic</source>
          <target state="translated">Coptic</target>
        </trans-unit>
        <trans-unit id="942537a642285809db23368aa138b752dec2796c" translate="yes" xml:space="preserve">
          <source>Copy Constructor Attributes</source>
          <target state="translated">생성자 속성 복사</target>
        </trans-unit>
        <trans-unit id="709184dfbdae79b767c073438461d5232cfaf826" translate="yes" xml:space="preserve">
          <source>Copy a list and return it.</source>
          <target state="translated">리스트를 복사하여 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="cd1c2a586ccbd243219ac10eddf70c09e31d365c" translate="yes" xml:space="preserve">
          <source>Copy construction</source>
          <target state="translated">복사 공사</target>
        </trans-unit>
        <trans-unit id="37418ac4b9973316ffcd94559dc007884df26d17" translate="yes" xml:space="preserve">
          <source>Copy constructors are used to initialize a &lt;code&gt;struct&lt;/code&gt; instance from another &lt;code&gt;struct&lt;/code&gt; of the same type.</source>
          <target state="translated">Copy 생성자는 같은 유형의 다른 &lt;code&gt;struct&lt;/code&gt; 에서 &lt;code&gt;struct&lt;/code&gt; 인스턴스 를 초기화하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="320779b333b853c0722a1290050d477167e8a078" translate="yes" xml:space="preserve">
          <source>Copy file &lt;code&gt;from&lt;/code&gt; to file &lt;code&gt;to&lt;/code&gt;. File timestamps are preserved. File attributes are preserved, if &lt;code&gt;preserve&lt;/code&gt; equals &lt;code&gt;Yes.preserveAttributes&lt;/code&gt;. On Windows only &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; (the default on Windows) is supported. If the target file exists, it is overwritten.</source>
          <target state="translated">파일을 복사 &lt;code&gt;from&lt;/code&gt; 파일 &lt;code&gt;to&lt;/code&gt; . 파일 타임 스탬프가 유지됩니다. 경우 파일 속성은 보존 &lt;code&gt;preserve&lt;/code&gt; 등호의 &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; 을 . Windows에서만 &lt;code&gt;Yes.preserveAttributes&lt;/code&gt; ( Windows 의 기본값)가 지원됩니다. 대상 파일이 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="6adfec0ea49b245d49516253d1dd309df3c674d0" translate="yes" xml:space="preserve">
          <source>Copy list of pointers into an array of pointers.</source>
          <target state="translated">포인터 목록을 포인터 배열로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="308a306712a72a68760a831c427ff9a7b6f477e8" translate="yes" xml:space="preserve">
          <source>Copy of pContext passed to s_r_g_c()</source>
          <target state="translated">s_r_g_c ()에 전달 된 pContext의 사본</target>
        </trans-unit>
        <trans-unit id="a8fcd23e55300e52517fa8bcab8fa048a94546e8" translate="yes" xml:space="preserve">
          <source>Copy the AST for Initializer.</source>
          <target state="translated">이니셜 라이저의 AST를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b2e4441cb240ca98a4ab28279101e86791c233" translate="yes" xml:space="preserve">
          <source>Copy the content of &lt;code&gt;src&lt;/code&gt; into a C-string ('\0' terminated) then call &lt;code&gt;dg&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 내용을 C- 문자열 ( '\ 0'종결 됨)에 복사 한 다음 &lt;code&gt;dg&lt;/code&gt; 를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b95b3aef1bd39e43db4216e5417954c43df1366d" translate="yes" xml:space="preserve">
          <source>Copy the syntax. Used for template instantiations. If s is NULL, allocate the new object, otherwise fill it in.</source>
          <target state="translated">구문을 복사하십시오. 템플릿 인스턴스화에 사용됩니다. s가 NULL이면 새 객체를 할당하고 그렇지 않으면 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="19a4ab4fb21f129930562e73dc3fbf182a5d9262" translate="yes" xml:space="preserve">
          <source>CopyTypeQualifiers!(ElementType!String, dchar)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(String)(scope String str)</source>
          <target state="translated">CopyTypeQualifiers!(ElementType!String, dchar)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(String)(scope String str)</target>
        </trans-unit>
        <trans-unit id="8ec1721ef2b902c8de7cb0d0aa34612ec83401fd" translate="yes" xml:space="preserve">
          <source>Copying of this struct is disabled, since it would provide no useful semantics. If you want to pass this struct around, you should do so by reference or pointer.</source>
          <target state="translated">이 구조체의 복사는 유용한 의미를 제공하지 않으므로 비활성화됩니다. 이 구조체를 전달하려면 참조 또는 포인터로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9e302476e5802312f92d2000e1d7eb281d3f5c6" translate="yes" xml:space="preserve">
          <source>Copying one &lt;code&gt;File&lt;/code&gt; object to another results in the two &lt;code&gt;File&lt;/code&gt; objects referring to the same underlying file.</source>
          <target state="translated">한 &lt;code&gt;File&lt;/code&gt; 객체를 다른 File 객체로 복사 하면 두 개의 &lt;code&gt;File&lt;/code&gt; 객체가 동일한 기본 파일을 참조하게됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a652bd968ffd57a4235b12a1e05a73da8e344b" translate="yes" xml:space="preserve">
          <source>Copying range &lt;code&gt;E&lt;/code&gt; into &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">범위 &lt;code&gt;E&lt;/code&gt; 를 &lt;code&gt;R&lt;/code&gt; 에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="9c490d0555e01fccc566b2049a123406254aec4e" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1998 - 2010, Daniel Stenberg, &amp;lt;daniel@haxx.se&amp;gt;, et al.</source>
          <target state="translated">Copyright (C) 1998-2010, Daniel Stenberg, &amp;lt;daniel@haxx.se&amp;gt;, et al.</target>
        </trans-unit>
        <trans-unit id="d7fd2f0b0b062e7925bd7e80f9edff1469e8c0cd" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2018-2019 by The D Language Foundation, All Rights Reserved</source>
          <target state="translated">Copyright (C) 2018-2019 D 언어 재단, 판권 소유</target>
        </trans-unit>
        <trans-unit id="791e6eab1ad061b18a1d6efc93a77ad535bf0203" translate="yes" xml:space="preserve">
          <source>Copyright Digital Mars 2007 - 2010.</source>
          <target state="translated">Copyright Digital Mars 2007-2010.</target>
        </trans-unit>
        <trans-unit id="4671543319eb1a3e40086a095380b9f58bb42d23" translate="yes" xml:space="preserve">
          <source>Copyright:</source>
          <target state="translated">Copyright:</target>
        </trans-unit>
        <trans-unit id="c1c6068dcf095f0b88f5e50f1dfe0135b6190c47" translate="yes" xml:space="preserve">
          <source>Core allocator objects that interface with D's garbage collected heap (&lt;a href=&quot;std_experimental_allocator_gc_allocator&quot;&gt;&lt;code&gt;std.experimental.allocator.gc_allocator&lt;/code&gt;&lt;/a&gt;), the C &lt;code&gt;malloc&lt;/code&gt; family (&lt;a href=&quot;std_experimental_allocator_mallocator&quot;&gt;&lt;code&gt;std.experimental.allocator.mallocator&lt;/code&gt;&lt;/a&gt;), and the OS (&lt;a href=&quot;std_experimental_allocator_mmap_allocator&quot;&gt;&lt;code&gt;std.experimental.allocator.mmap_allocator&lt;/code&gt;&lt;/a&gt;). Most custom allocators would ultimately obtain memory from one of these core allocators.</source>
          <target state="translated">D의 가비지 수집 힙 ( &lt;a href=&quot;std_experimental_allocator_gc_allocator&quot;&gt; &lt;code&gt;std.experimental.allocator.gc_allocator&lt;/code&gt; &lt;/a&gt; ), C &lt;code&gt;malloc&lt;/code&gt; 패밀리 ( &lt;a href=&quot;std_experimental_allocator_mallocator&quot;&gt; &lt;code&gt;std.experimental.allocator.mallocator&lt;/code&gt; &lt;/a&gt; ) 및 OS ( &lt;a href=&quot;std_experimental_allocator_mmap_allocator&quot;&gt; &lt;code&gt;std.experimental.allocator.mmap_allocator&lt;/code&gt; &lt;/a&gt; ) 와 인터페이스하는 코어 할당 자 오브젝트 대부분의 커스텀 할당자는 궁극적으로 이러한 핵심 할당 자 중 하나로부터 메모리를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7b820d5ee9cbef08cc0675cf59c9e9666eb11879" translate="yes" xml:space="preserve">
          <source>Core language definitions. Automatically imported.</source>
          <target state="translated">핵심 언어 정의. 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1d6abcd3d5aab81c8555d7d3eaeff9737c1eea01" translate="yes" xml:space="preserve">
          <source>Correctly matching the format specifier to the D type is necessary. The D compiler recognizes the printf formats and diagnoses mismatches with the supplied arguments. The specification for the formats used by D is the C99 specification 7.19.6.1.</source>
          <target state="translated">형식 지정자를 D 유형에 올바르게 일치시켜야합니다. D 컴파일러는 printf 형식을 인식하고 제공된 인수와의 불일치를 진단합니다. D에서 사용하는 형식의 사양은 C99 사양 7.19.6.1입니다.</target>
        </trans-unit>
        <trans-unit id="76cb799cd1522d52368e0a75ed33732541a23b3a" translate="yes" xml:space="preserve">
          <source>Could not find an MX record for this domain but an A-record does exist</source>
          <target state="translated">이 도메인에 대한 MX 레코드를 찾을 수 없지만 A 레코드가 존재합니다</target>
        </trans-unit>
        <trans-unit id="08c19a8f1d0d59ad9d116a7f6a492aba8099b5e8" translate="yes" xml:space="preserve">
          <source>Could not find an MX record or an A-record for this domain</source>
          <target state="translated">이 도메인에 대한 MX 레코드 또는 A 레코드를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">수정 된 행 수 계산</target>
        </trans-unit>
        <trans-unit id="8d5ade84a80435c2bfa6f6177104e09a64281c70" translate="yes" xml:space="preserve">
          <source>Count all the possible substrings of length 2</source>
          <target state="translated">길이 2의 가능한 모든 부분 문자열을 세십시오</target>
        </trans-unit>
        <trans-unit id="8be0facbf0a137c1553dcd917b58aac8fddcb84c" translate="yes" xml:space="preserve">
          <source>Count up and return number of items in list.</source>
          <target state="translated">목록에있는 항목 수를 세고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e564d45aaad122a5874f0bff4352287fa9c20217" translate="yes" xml:space="preserve">
          <source>Counting Rod Numerals</source>
          <target state="translated">카운팅로드 숫자</target>
        </trans-unit>
        <trans-unit id="173f9b130d44a68c96e425930a40f7564c0cd832" translate="yes" xml:space="preserve">
          <source>Counts all the set bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 의 모든 설정 비트 수</target>
        </trans-unit>
        <trans-unit id="7ce36e691e55ca1534110cdf92701208325abb85" translate="yes" xml:space="preserve">
          <source>Counts elements in the given &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; until the given predicate is true for one of the given &lt;code&gt;needles&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;needles&lt;/code&gt; 중 하나에 대해 주어진 술어가 true가 될 때까지 주어진 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;앞으로 범위의&lt;/a&gt; 요소를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="036b8b1123e79381082e175aa22db7cf31f3e5e1" translate="yes" xml:space="preserve">
          <source>Counts elements that are equal to a specified value or satisfy a predicate. &lt;code&gt;count([1, 2, 1], 1)&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;count!&quot;a &amp;lt; 0&quot;([1, -3, 0])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">지정된 값과 같거나 술어를 만족시키는 요소를 계산합니다. &lt;code&gt;count([1, 2, 1], 1)&lt;/code&gt; 은 &lt;code&gt;2&lt;/code&gt; 를 반환 하고 &lt;code&gt;count!&quot;a &amp;lt; 0&quot;([1, -3, 0])&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ccf0dfb24dfd16253b0f3c9addacb80ba1861801" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;alignedAllocate&lt;/code&gt; that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</source>
          <target state="translated">성공한 &lt;code&gt;alignedAllocate&lt;/code&gt; 대한 호출 수를 계산합니다 . 즉, 요청한만큼 큰 블록을 반환합니다. 0 바이트에 대한 NB 요청은 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="89e430aecb0bc14a42573f4e6f98203eeb3b69aa" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;alignedAllocate&lt;/code&gt;. All calls are counted, including requests for zero bytes or failed requests.</source>
          <target state="translated">&lt;code&gt;alignedAllocate&lt;/code&gt; 대한 호출 수를 계산합니다 . 0 바이트 요청 또는 실패한 요청을 포함한 모든 호출이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="33412aaca6b7b7660ddf82c644a97ea07b39f016" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;allocate&lt;/code&gt; that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</source>
          <target state="translated">성공한 &lt;code&gt;allocate&lt;/code&gt; 즉, 요청한만큼 큰 블록을 반환 한 호출 수를 계산합니다 . 0 바이트에 대한 NB 요청은 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b35cbf7d07dd6ee024a9bcd8d87883db36546721" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;allocate&lt;/code&gt;. All calls are counted, including requests for zero bytes or failed requests.</source>
          <target state="translated">&lt;code&gt;allocate&lt;/code&gt; 호출 수를 계산합니다 . 0 바이트 요청 또는 실패한 요청을 포함한 모든 호출이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3219b291728cf96157a69f99f29e801ca560a91d" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5961c3ed47a6ea7e033c8af93daa0abd5528a016" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;deallocateAll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deallocateAll&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2879654a173945a9cba0580571953a4dc0a97302" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;expand&lt;/code&gt; that resulted in a successful expansion.</source>
          <target state="translated">성공적으로 확장 된 &lt;code&gt;expand&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5c5af41f873e7913601ca76a10cc79cc68d7c141" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;expand&lt;/code&gt;, regardless of arguments or result.</source>
          <target state="translated">인수 또는 결과에 관계없이 &lt;code&gt;expand&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="09d92465f887e970b05288ec88d3e63ccb6de9ca" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;owns&lt;/code&gt; 통화 수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="1afc421ebe17abffb879f6aab12a15ef83d68dd4" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt; that resulted in an in-place reallocation (no memory moved). If this number is close to the total number of reallocations, that indicates the allocator finds room at the current block's end in a large fraction of the cases, but also that internal fragmentation may be high (the size of the unit of allocation is large compared to the typical allocation size of the application).</source>
          <target state="translated">전체 재 할당 (메모리 이동 없음)을 초래 한 &lt;code&gt;reallocate&lt;/code&gt; 호출 수를 계산합니다 . 이 수가 총 재 할당의 총 수에 가까우면 할당자가 많은 경우에 현재 블록의 끝에서 공간을 찾았지만 내부 조각화가 클 수 있음을 나타냅니다 (배분 단위의 크기가 비교됨). 응용 프로그램의 일반적인 할당 크기로).</target>
        </trans-unit>
        <trans-unit id="820537dc16117e7850cbde5ae4bfce6bca7be8ed" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt; that succeeded. (Reallocations to zero bytes count as successful.)</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; 호출 이 성공한 횟수를 계산합니다 . (0 바이트로의 재 할당은 성공한 것으로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="bc15833a702b66d803c03a8019110e6825ca2625" translate="yes" xml:space="preserve">
          <source>Counts the number of calls to &lt;code&gt;reallocate&lt;/code&gt;, regardless of arguments or result.</source>
          <target state="translated">인수 또는 결과에 관계없이 &lt;code&gt;reallocate&lt;/code&gt; 호출 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c12f5fb99ca2154f2dcfa85d6b67e6da2e844b9b" translate="yes" xml:space="preserve">
          <source>Covariant means that 'this' can substitute for 't', i.e. a pure function is a match for an impure type.</source>
          <target state="translated">공변량은 'this'가 't'를 대신 할 수 있음을 의미합니다. 즉 순수한 함수는 불순한 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d95e70de908fe667a8d90b4c2c9835cc65a2bc51" translate="yes" xml:space="preserve">
          <source>Covariant return types are supported, which means that the overriding function in a derived class can return a type that is derived from the type returned by the overridden function:</source>
          <target state="translated">공변량 반환 유형이 지원됩니다. 즉, 파생 클래스의 재정의 함수는 재정의 된 함수에 의해 반환 된 유형에서 파생 된 유형을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e13549b47a4dfc6e898a282920091b209c78be" translate="yes" xml:space="preserve">
          <source>Coverage</source>
          <target state="translated">Coverage</target>
        </trans-unit>
        <trans-unit id="134b318951a0e9fd4c15b2f4d1bdf343d3855913" translate="yes" xml:space="preserve">
          <source>Covers a given range &lt;code&gt;r&lt;/code&gt; in a random manner, i.e. goes through each element of &lt;code&gt;r&lt;/code&gt; once and only once, just in a random order. &lt;code&gt;r&lt;/code&gt; must be a random-access range with length.</source>
          <target state="translated">주어진 범위 &lt;code&gt;r&lt;/code&gt; 을 임의의 방식으로 처리합니다. 즉 , 임의의 순서 로 &lt;code&gt;r&lt;/code&gt; 의 각 요소를 한 번만 통과합니다 . &lt;code&gt;r&lt;/code&gt; 은 길이가 랜덤 액세스 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="80b8fd5910e5321eafb27f61b9891d1fcfabc69f" translate="yes" xml:space="preserve">
          <source>CppTypeInfo &lt;code&gt;sti&lt;/code&gt;</source>
          <target state="translated">CppTypeInfo &lt;code&gt;sti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">새로운 동적 문자열 객체 생성</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">SQL 함수 작성 또는 재정의</target>
        </trans-unit>
        <trans-unit id="ece1dfb335b9491989584a0b93ef182f523f9560" translate="yes" xml:space="preserve">
          <source>Create RTInfo for type T</source>
          <target state="translated">타입 T에 대한 RTInfo 생성</target>
        </trans-unit>
        <trans-unit id="d375db3a1f3f34950378c2942ec463da134ac351" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;KRRegion&lt;/code&gt;. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;KRRegion&lt;/code&gt;'s destructor will call &lt;code&gt;parent.deallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 을 작성하십시오 . 경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;KRRegion&lt;/code&gt; 의 소멸자 호출합니다 &lt;code&gt;parent.deallocate&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f87dab8d862d0e2f326eb6f6f98422949344a463" translate="yes" xml:space="preserve">
          <source>Create a SocketSet with a specific initial capacity (defaults to &lt;code&gt;FD_SETSIZE&lt;/code&gt;, the system's default capacity).</source>
          <target state="translated">초기 용량이 특정인 SocketSet을 작성하십시오 (기본값 은 시스템의 기본 용량 인 &lt;code&gt;FD_SETSIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6115e98c8527cdbd982abe785b7a57087cb4c9e9" translate="yes" xml:space="preserve">
          <source>Create a bitfield pack of eight bits, which fit in one ubyte. The bitfields are allocated starting from the least significant bit, i.e. x occupies the two least significant bits of the bitfields storage.</source>
          <target state="translated">1 바이트에 맞는 8 비트 비트 필드 팩을 만듭니다. 비트 필드는 최하위 비트부터 시작하여 할당됩니다. 즉, x는 비트 필드 스토리지의 최하위 비트 2 개를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="839d59c094905e9232ab8c88f3cdc905e73f062f" translate="yes" xml:space="preserve">
          <source>Create a blocking socket using the parameters from the specified &lt;code&gt;AddressInfo&lt;/code&gt; structure.</source>
          <target state="translated">지정된 &lt;code&gt;AddressInfo&lt;/code&gt; 구조 의 매개 변수를 사용하여 블로킹 소켓을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ae856d1b4059fd4c939c4490a4432d4ce09656" translate="yes" xml:space="preserve">
          <source>Create a blocking socket. If a single protocol type exists to support this socket type within the address family, the &lt;code&gt;ProtocolType&lt;/code&gt; may be omitted.</source>
          <target state="translated">차단 소켓을 만듭니다. 주소 패밀리 내에서이 소켓 유형을 지원하기 위해 단일 프로토콜 유형이 존재하면 &lt;code&gt;ProtocolType&lt;/code&gt; 은 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c91e7ca2204837ccbc8674326fb67dea000b39" translate="yes" xml:space="preserve">
          <source>Create a deep copy of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 의 깊은 사본을 만듭니다</target>
        </trans-unit>
        <trans-unit id="2eb536cb42ec7dabddf6284395324e96212d115e" translate="yes" xml:space="preserve">
          <source>Create a dynamic array of the same size and copy the contents of the array into it. The copy is typed as being immutable. If this conversion is invalid the call will not compile.</source>
          <target state="translated">동일한 크기의 동적 배열을 만들고 배열의 내용을 그 안에 복사하십시오. 사본이 변경 불가능한 것으로 입력되었습니다. 이 변환이 유효하지 않으면 호출이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ddf0e62c5224c606a534ff3f1eb6d8fe747981d" translate="yes" xml:space="preserve">
          <source>Create a dynamic array of the same size and copy the contents of the array into it. The copy will have any immutability or const stripped. If this conversion is invalid the call will not compile.</source>
          <target state="translated">동일한 크기의 동적 배열을 만들고 배열의 내용을 그 안에 복사하십시오. 사본에는 불변성 또는 const가 제거됩니다. 이 변환이 유효하지 않으면 호출이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341accefd95b61afa9893db29309cc44315c3a2a" translate="yes" xml:space="preserve">
          <source>Create a horizontal rule by adding a line containing three or more asterisks, underscores or hyphens:</source>
          <target state="translated">별표, 밑줄 또는 하이픈이 3 개 이상 포함 된 줄을 추가하여 가로 규칙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e967753a33c5c7c7aa1e8f4422915e9dfd50d92c" translate="yes" xml:space="preserve">
          <source>Create a new associative array of the same size and copy the contents of the associative array into it.</source>
          <target state="translated">동일한 크기의 새 연관 배열을 작성하고 연관 배열의 컨텐츠를 여기에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9de552758093961aee77c1dae8b1dd3d177f54" translate="yes" xml:space="preserve">
          <source>Create a new scope from sc. semantic, semantic2 and semantic3 will use this for aggregate members.</source>
          <target state="translated">sc에서 새 범위를 만듭니다. semantic, semantic2 및 semantic3은 집계 멤버에이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="765b47ab87cb7a6d03987e9ff17e776ff00c1f20" translate="yes" xml:space="preserve">
          <source>Create a new scope if one or more given attributes are different from the sc's. If the returned scope != sc, the caller should pop the scope after it used.</source>
          <target state="translated">하나 이상의 지정된 속성이 sc와 다른 경우 새 범위를 만듭니다. 반환 된 범위! = sc 인 경우 호출자는 사용 후 범위를 팝해야합니다.</target>
        </trans-unit>
        <trans-unit id="0af330de1bfdb44bc3db78edbb6764a903bd5a6f" translate="yes" xml:space="preserve">
          <source>Create a new thread for executing this &lt;code&gt;Task&lt;/code&gt;, execute it in the newly created thread, then terminate the thread. This can be used for future/promise parallelism. An explicit priority may be given to the &lt;code&gt;Task&lt;/code&gt;. If one is provided, its value is forwarded to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;. See &lt;a href=&quot;std_parallelism#task&quot;&gt;&lt;code&gt;std.parallelism.task&lt;/code&gt;&lt;/a&gt; for usage example.</source>
          <target state="translated">이 &lt;code&gt;Task&lt;/code&gt; 를 실행할 새 스레드를 작성하고 새로 작성된 스레드에서 실행 한 다음 스레드를 종료하십시오. 이것은 미래 / 약속 병렬 처리에 사용될 수 있습니다. 명시 적 우선 순위가 부여 될 수 있습니다 &lt;code&gt;Task&lt;/code&gt; . 제공되는 경우 해당 값은 &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; 로 전달됩니다 . 사용법 예는 &lt;a href=&quot;std_parallelism#task&quot;&gt; &lt;code&gt;std.parallelism.task&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c71ba660ac8a783c6ab9eb2e83d4cb7a0caf6e05" translate="yes" xml:space="preserve">
          <source>Create a quiet NAN, storing an integer inside the payload.</source>
          <target state="translated">페이로드 안에 정수를 저장하여 조용한 NAN을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0230dbb481a6cc7524fc6a1776a286525afecbb" translate="yes" xml:space="preserve">
          <source>Create a range which repeats one value.</source>
          <target state="translated">하나의 값을 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="05cea08ac76b777160923ee7d8caa033b1e3267d" translate="yes" xml:space="preserve">
          <source>Create a reference to another dt.</source>
          <target state="translated">다른 dt에 대한 참조를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="956893df969cb511fe8cb0a535aa0c05eb7c1e44" translate="yes" xml:space="preserve">
          <source>Create a scope for the parameters of the TemplateInstance &lt;code&gt;ti&lt;/code&gt; in the parent scope sc from the ScopeDsymbol paramsym.</source>
          <target state="translated">ScopeDsymbol 매개 변수 에서 상위 범위 sc 의 TemplateInstance &lt;code&gt;ti&lt;/code&gt; 매개 변수에 대한 범위를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6243527d15de44e02eb522bb38a9f03d7ab0c9b3" translate="yes" xml:space="preserve">
          <source>Create a thread not under control of the runtime, i.e. TLS module constructors are not run and the GC does not suspend it during a collection.</source>
          <target state="translated">런타임을 제어하지 않는 스레드를 작성하십시오. 즉, TLS 모듈 생성자가 실행되지 않고 GC가 콜렉션 중에이를 일시 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="348e3661ccba88f4db846a336ac30d6c05131e6d" translate="yes" xml:space="preserve">
          <source>Create a unary or binary function from a string. Most often used when defining algorithms on ranges.</source>
          <target state="translated">문자열에서 단항 또는 이진 함수를 만듭니다. 범위에서 알고리즘을 정의 할 때 가장 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="959f9dde6d0a81fc23a2588b08ba6db6bae1876b" translate="yes" xml:space="preserve">
          <source>Create a vector type.</source>
          <target state="translated">벡터 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9572cfad6b3211fcd4b15b756e271a21d6de1572" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Fft&lt;/code&gt; object for computing fast Fourier transforms of power of two sizes of &lt;code&gt;size&lt;/code&gt; or smaller. &lt;code&gt;size&lt;/code&gt; must be a power of two.</source>
          <target state="translated">두 가지 &lt;code&gt;size&lt;/code&gt; 또는 그보다 작은 크기의 고속 푸리에 변환을 계산하기위한 &lt;code&gt;Fft&lt;/code&gt; 객체를 만듭니다 . &lt;code&gt;size&lt;/code&gt; 는 2의 거듭 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6650f16211e259caf5365253a1f7216d8f5171d" translate="yes" xml:space="preserve">
          <source>Create an array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;length&lt;/code&gt; elements using &lt;code&gt;alloc&lt;/code&gt;. The array is either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">배열 생성 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;length&lt;/code&gt; 사용 요소 &lt;code&gt;alloc&lt;/code&gt; . 배열은 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="526001f9a9b94b9fd00bba4fb0e338ddc47b01cf" translate="yes" xml:space="preserve">
          <source>Create an array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;length&lt;/code&gt; elements. The array is either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">배열 생성 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;length&lt;/code&gt; 요소. 배열은 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="afd41877e2d03683b62c3966d07b3578b44fa83c" translate="yes" xml:space="preserve">
          <source>Create an array of enumerated values</source>
          <target state="translated">열거 된 값으로 구성된 배열 만들기</target>
        </trans-unit>
        <trans-unit id="d624d8319aaa043a0e0bcda5eb8c6692ae1c99ad" translate="yes" xml:space="preserve">
          <source>Create an array of random numbers using range functions and UFCS</source>
          <target state="translated">범위 함수와 UFCS를 사용하여 난수 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14ef15a3d735dc58c104a58836a40a871675370e" translate="yes" xml:space="preserve">
          <source>Create an identifier in the string table.</source>
          <target state="translated">문자열 테이블에서 식별자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5f15bb6174bb0ae0102d8f77548b958b264eca0f" translate="yes" xml:space="preserve">
          <source>Create inclusive destructor for struct/class by aggregating all the destructors in dtors[] with the destructors for all the members.</source>
          <target state="translated">dtors []의 모든 소멸자를 모든 멤버의 소멸자와 집계하여 struct / class에 대한 포괄적 인 소멸자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="06412ef3cdbe60fb294e12eeae1a8f44ed3439af" translate="yes" xml:space="preserve">
          <source>Create inclusive invariant for struct/class by aggregating all the invariants in invs[]. void __invariant() const [pure nothrow @trusted] { invs[0](), invs[1](), ...; }</source>
          <target state="translated">invs []에있는 모든 불변량을 모아서 구조체 / 클래스에 대한 불변 값을 만드십시오. void __invariant () const [순수하지 않은 @trusted] {invs [0] (), invs [1] (), ...; }</target>
        </trans-unit>
        <trans-unit id="86c9df773642e6041f2232b04da0147162423a70" translate="yes" xml:space="preserve">
          <source>Create instance of Object represented by 'this'.</source>
          <target state="translated">'this'로 표시되는 Object의 인스턴스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f91dcf5e8a8544b29b8c109ab40e97ebba994da" translate="yes" xml:space="preserve">
          <source>Create instance of class specified by the fully qualified name classname. The class must either have no constructors or have a default constructor.</source>
          <target state="translated">완전한 이름 classname으로 지정된 클래스의 인스턴스를 작성하십시오. 클래스에는 생성자가 없거나 기본 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3aae95e6ec02b6e5eb22379134870bf1f1adbec6" translate="yes" xml:space="preserve">
          <source>Create link to existing list, that is, share the list with somebody else.</source>
          <target state="translated">기존 목록에 대한 링크를 작성하십시오. 즉, 다른 사람과 목록을 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="aeec46bd186170bc95905007868367a92e1a1373" translate="yes" xml:space="preserve">
          <source>Create reference to s+offset</source>
          <target state="translated">s + offset에 대한 참조 생성</target>
        </trans-unit>
        <trans-unit id="e69371dea3bc5d5b1ce101edd514aa4b5a3a2c33" translate="yes" xml:space="preserve">
          <source>Create the static initializer for the struct/class.</source>
          <target state="translated">구조체 / 클래스에 대한 정적 초기화 프로그램을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e2c8a09dc1433291cd9bc6fd5786498693b64e21" translate="yes" xml:space="preserve">
          <source>CreateFolder &lt;code&gt;createFileNameFolder&lt;/code&gt;</source>
          <target state="translated">CreateFolder &lt;code&gt;createFileNameFolder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e34f80c232756fb185e577f5d37547da03fc5dc5" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-MM-DD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc6e946bb7d665d5d024eddf994d6bb9a983bdc" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-Mon-DD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-Mon-DD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e20c926289335859e6d97ff01950b27ec62dd2" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDD. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYYMMDD 형식의 문자열에서 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d3091af4b2ee859443ab3c8a53bebcda60ddb979" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-MM-DDTHH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3041e4d81e36a466d1e51fa044e13c66f2d70792" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYY-Mon-DD HH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9dbacf39bfced8fa82e9ebe4c805f56fa4355100" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDDTHHMMSS. Whitespace is stripped from the given string.</source>
          <target state="translated">YYYYMMDDTHHMMSS 형식의 문자열에서 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="89d6b000a1e0072815008260d5751f430cc1bc5b" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; MM : 형식 YYYY-MM-DD HH의 문자열을 행 SS.FFFFFFFTZ (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="25e0e1d4a091ccac9d256e34e9f9ae4e5842e2bf" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; MM : 형식 YYYY-MM-ISO 형식의 문자열을 행 SS.FFFFFFFTZ (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bbfa00e601500f8abcab6f8903eca2c36e737ac4" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; from a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 포맷 YYYYMMDDTHHMMSS.FFFFFFFTZ의 문자열을 행 (F 분수 초이다 시간대이다). 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b213f5d28de923b7220902c1697934db1c8f60d3" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; from a string with the format HH:MM:SS. Whitespace is stripped from the given string.</source>
          <target state="translated">HH : MM : SS 형식의 문자열에서 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="96b1a32d19336613b876dcd9a105f13defae7bd7" translate="yes" xml:space="preserve">
          <source>Creates a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; from a string with the format HHMMSS. Whitespace is stripped from the given string.</source>
          <target state="translated">작성 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 형식 HHMMSS의 문자열에서합니다. 주어진 문자열에서 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="661f5e4bfc4e5c0b2feb77d82f632d60d90264a2" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;BitArray&lt;/code&gt; from a &lt;code&gt;bool&lt;/code&gt; array, such that &lt;code&gt;bool&lt;/code&gt; values read from left to right correspond to subsequent bits in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">작성 &lt;code&gt;BitArray&lt;/code&gt; 를 A로부터 &lt;code&gt;bool&lt;/code&gt; 되도록 배열 &lt;code&gt;bool&lt;/code&gt; 값은 후속 비트 오른쪽 대응하여 왼쪽에서 판독 &lt;code&gt;BitArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75f1a094795d835c2e6c032e474ae4ed7954f131" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;BitArray&lt;/code&gt; from the raw contents of the source array. The source array is not copied but simply acts as the underlying array of bits, which stores data as &lt;code&gt;size_t&lt;/code&gt; units.</source>
          <target state="translated">소스 배열의 원시 내용에서 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 . 소스 배열은 복사되지 않고 단순히 기본 비트 배열로 작동하여 데이터를 &lt;code&gt;size_t&lt;/code&gt; 단위 로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="91bf27933374868d67d5fe77c4446e5f6d88a641" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;Task&lt;/code&gt; on the GC heap that calls a function pointer, delegate, or class/struct with overloaded opCall.</source>
          <target state="translated">오버로드 된 opCall을 사용하여 함수 포인터, 델리게이트 또는 클래스 / 구조를 호출 하는 &lt;code&gt;Task&lt;/code&gt; 을 GC 힙에 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f4058ec66257ae48d3c3078de7f6e641a360c7cb" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;Task&lt;/code&gt; on the GC heap that calls an alias. This may be executed via &lt;code&gt;Task.executeInNewThread&lt;/code&gt; or by submitting to a &lt;a href=&quot;std_parallelism#TaskPool&quot;&gt;&lt;code&gt;std.parallelism.TaskPool&lt;/code&gt;&lt;/a&gt;. A globally accessible instance of &lt;code&gt;TaskPool&lt;/code&gt; is provided by &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">별칭을 호출하는 GC 힙에 &lt;code&gt;Task&lt;/code&gt; 을 만듭니다 . 이를 통해 실행될 수있다 &lt;code&gt;Task.executeInNewThread&lt;/code&gt; 또는에 제출 &lt;a href=&quot;std_parallelism#TaskPool&quot;&gt; &lt;code&gt;std.parallelism.TaskPool&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt; 은 세계적으로 액세스 가능한 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="34e4d8ddfca04c3316cc068b4800ba69aa18ecdf" translate="yes" xml:space="preserve">
          <source>Creates a Condition variable analog for signaling.</source>
          <target state="translated">시그널링을위한 Condition 변수 아날로그를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c859ea4adbfacacaab358299326fde8ee39270d1" translate="yes" xml:space="preserve">
          <source>Creates a Lexer for the source code base[begoffset..endoffset+1]. The last character, base[endoffset], must be null (0) or EOF (0x1A).</source>
          <target state="translated">소스 코드베이스 [begoffset..endoffset + 1]에 대한 Lexer를 작성합니다. 마지막 문자 인 base [endoffset]은 null (0) 또는 EOF (0x1A) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4043d1c472260058ff2b44188bce91464289418" translate="yes" xml:space="preserve">
          <source>Creates a bitfield pack of eight bits, which fit in one &lt;code&gt;ubyte&lt;/code&gt;. The bitfields are allocated starting from the least significant bit, i.e. x occupies the two least significant bits of the bitfields storage.</source>
          <target state="translated">한 적합한 8 비트의 비트 필드 팩 생성 &lt;code&gt;ubyte&lt;/code&gt; 를 . 비트 필드는 최하위 비트부터 시작하여 할당됩니다. 즉, x는 비트 필드 스토리지의 최하위 비트 2 개를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="22e271cc711a759e645164a6c0eb60bcdf7daa84" translate="yes" xml:space="preserve">
          <source>Creates a container of type &lt;code&gt;C&lt;/code&gt; from either another container or a range. The created container must not be a null reference even if x is empty.</source>
          <target state="translated">다른 컨테이너 또는 범위에서 유형 &lt;code&gt;C&lt;/code&gt; 의 컨테이너를 만듭니다 . x가 비어 있어도 작성된 컨테이너는 널 참조가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c88b30b91f6883b933e7785db39c6a543b98bd1" translate="yes" xml:space="preserve">
          <source>Creates a copy of a &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; with its fields in reverse order.</source>
          <target state="translated">필드를 역순 으로 &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 의 복사본을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eafa6a0f5a2c3f7d41c7a2a8061125f06fba9dbe" translate="yes" xml:space="preserve">
          <source>Creates a forward range whose values are defined by a mathematical recurrence relation.</source>
          <target state="translated">수학적 되풀이 관계에 의해 값이 정의되는 전달 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f24557243bfa5bfdcb62b5e9b12d22b154537901" translate="yes" xml:space="preserve">
          <source>Creates a function that binds the first argument of a given function to a given value.</source>
          <target state="translated">주어진 함수의 첫 번째 인수를 주어진 값에 바인딩하는 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bb183c0a9d71fad3327428b4e288c762c0601c56" translate="yes" xml:space="preserve">
          <source>Creates a function that caches its result for fast re-evaluation.</source>
          <target state="translated">빠른 재평가를 위해 결과를 캐시하는 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ca671f44e7aaeac35a6537c07507991cbe066f68" translate="yes" xml:space="preserve">
          <source>Creates a function that negates another.</source>
          <target state="translated">다른 것을 무효화하는 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="cde91551966a8c3538a557aa7e1f65e48ffab5da" translate="yes" xml:space="preserve">
          <source>Creates a hash of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Tuple&lt;/code&gt; 의 해시를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="0adb30e0283a4af18094accba2f9b8d4adae66b8" translate="yes" xml:space="preserve">
          <source>Creates a mathematical sequence given the initial values and a recurrence function that computes the next value from the existing values. The sequence comes in the form of an infinite forward range. The type &lt;code&gt;Recurrence&lt;/code&gt; itself is seldom used directly; most often, recurrences are obtained by calling the function &lt;code&gt;recurrence&lt;/code&gt;.</source>
          <target state="translated">초기 값과 기존 값에서 다음 값을 계산하는 반복 함수가 주어지면 수학적 시퀀스를 만듭니다. 시퀀스는 무한 앞으로 범위의 형태로 제공됩니다. &lt;code&gt;Recurrence&lt;/code&gt; 유형 자체는 거의 사용되지 않습니다. 대부분의 경우 재발은 함수 &lt;code&gt;recurrence&lt;/code&gt; 을 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="96ee19dd76d73d769afaaa909687c75babff0184" translate="yes" xml:space="preserve">
          <source>Creates a new Condition variable analog which is used to check for and to signal the addition of messages to a thread's message queue. Like yield, some schedulers may need to define custom behavior so that calls to Condition.wait() yield to another thread when no new messages are available instead of blocking.</source>
          <target state="translated">스레드의 메시지 큐에 메시지 추가를 확인하고 신호를 보내는 데 사용되는 새로운 조건 변수 아날로그를 작성합니다. yield와 마찬가지로 일부 스케줄러는 블로킹 대신 사용 가능한 새 메시지가 없을 때 Condition.wait () 호출이 다른 스레드를 생성하도록 사용자 지정 동작을 정의해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a031f47a97f06dd1d0df403626203b69d541f12c" translate="yes" xml:space="preserve">
          <source>Creates a new Condition variable. No custom behavior is needed here.</source>
          <target state="translated">새로운 조건 변수를 만듭니다. 여기에는 사용자 지정 동작이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9116bfcb531f9d54454fcfc948e4d0383d354a83" translate="yes" xml:space="preserve">
          <source>Creates a new Fiber which calls the given delegate.</source>
          <target state="translated">주어진 델리게이트를 호출하는 새로운 Fiber를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="124555a8b0f648fe1d012d276d753c0d19322a5b" translate="yes" xml:space="preserve">
          <source>Creates a new array out of several copies of an input array or range.</source>
          <target state="translated">입력 배열 또는 범위의 여러 복사본으로 새 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c29b4591a6c00e3151f27e3a3a0216407411dd7f" translate="yes" xml:space="preserve">
          <source>Creates a new array such that the items in &lt;code&gt;slice&lt;/code&gt; are replaced with the items in &lt;code&gt;replacement&lt;/code&gt;. &lt;code&gt;slice&lt;/code&gt; and &lt;code&gt;replacement&lt;/code&gt; do not need to be the same length. The result will grow or shrink based on the items given.</source>
          <target state="translated">&lt;code&gt;slice&lt;/code&gt; 의 항목이 &lt;code&gt;replacement&lt;/code&gt; 항목으로 대체 되도록 새 배열을 만듭니다 . &lt;code&gt;slice&lt;/code&gt; 와 &lt;code&gt;replacement&lt;/code&gt; 길이가 같을 필요는 없습니다. 주어진 항목에 따라 결과가 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="3890727bd831b1cb6c012e4c91606c3ef658c4a3" translate="yes" xml:space="preserve">
          <source>Creates a new array which is identical to &lt;code&gt;s&lt;/code&gt; except that all of its characters are converted to lowercase (by preforming Unicode lowercase mapping). If none of &lt;code&gt;s&lt;/code&gt; characters were affected, then &lt;code&gt;s&lt;/code&gt; itself is returned if &lt;code&gt;s&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;-like type.</source>
          <target state="translated">모든 문자가 유니 코드 소문자 매핑을 수행하여 소문자로 변환된다는 점을 제외하고 &lt;code&gt;s&lt;/code&gt; 와 동일한 새 배열을 만듭니다 . 아무도 경우 &lt;code&gt;s&lt;/code&gt; 문자가 영향을받지 된 후 &lt;code&gt;s&lt;/code&gt; 의 경우 그 자체가 반환 &lt;code&gt;s&lt;/code&gt; A는 &lt;code&gt;string&lt;/code&gt; 유형 -like가.</target>
        </trans-unit>
        <trans-unit id="7e9c86b82c6b1fb66dd08cc61c38a1b079756d54" translate="yes" xml:space="preserve">
          <source>Creates a new curl session handle with the same options set for the handle passed in. Duplicating a handle could only be a matter of cloning data and options, internal state info and things like persistant connections cannot be transfered. It is useful in multithreaded applications when you can run curl_easy_duphandle() for each new thread to avoid a series of identical curl_easy_setopt() invokes in every thread.</source>
          <target state="translated">전달 된 핸들에 대해 동일한 옵션 세트를 사용하여 새로운 curl 세션 핸들을 작성합니다. 핸들 복제는 데이터 및 옵션 복제, 내부 상태 정보 및 지속 연결과 같은 항목 만 전송할 수 있습니다. 모든 스레드에서 일련의 동일한 curl_easy_setopt () 호출을 피하기 위해 각 새 스레드에 대해 curl_easy_duphandle ()을 실행할 수있는 경우 다중 스레드 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60a4fea607c23225fa400ed6c857bae74cd299af" translate="yes" xml:space="preserve">
          <source>Creates a new function call expression</source>
          <target state="translated">새로운 함수 호출 표현식을 작성합니다</target>
        </trans-unit>
        <trans-unit id="2112334d42e17720c661c805ce3324b558dd51cb" translate="yes" xml:space="preserve">
          <source>Creates a new instance of Error. The nextInChain parameter is used internally and should always be &lt;code&gt;null&lt;/code&gt; when passed by user code. This constructor does not automatically throw the newly-created Error; the &lt;code&gt;throw&lt;/code&gt; statement should be used for that purpose.</source>
          <target state="translated">새 Error 인스턴스를 만듭니다. nextInChain 매개 변수는 내부적으로 사용 되며 사용자 코드가 전달할 때 항상 &lt;code&gt;null&lt;/code&gt; 이어야 합니다. 이 생성자는 새로 작성된 오류를 자동으로 발생시키지 않습니다. &lt;code&gt;throw&lt;/code&gt; 문은 그 목적을 위해 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="29ef1c3bd126426d443d7475b7ad71d8d8c5679c" translate="yes" xml:space="preserve">
          <source>Creates a new instance of Exception. The nextInChain parameter is used internally and should always be &lt;code&gt;null&lt;/code&gt; when passed by user code. This constructor does not automatically throw the newly-created Exception; the &lt;code&gt;throw&lt;/code&gt; statement should be used for that purpose.</source>
          <target state="translated">Exception의 새 인스턴스를 만듭니다. nextInChain 매개 변수는 내부적으로 사용 되며 사용자 코드가 전달할 때 항상 &lt;code&gt;null&lt;/code&gt; 이어야 합니다. 이 생성자는 새로 만든 예외를 자동으로 throw하지 않습니다. &lt;code&gt;throw&lt;/code&gt; 문은 그 목적을 위해 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="75f34c3d414f8f4a0b73cf72e2fb0126aa145b92" translate="yes" xml:space="preserve">
          <source>Creates a new kernel thread and assigns it to run the supplied op.</source>
          <target state="translated">새로운 커널 스레드를 생성하고 제공된 op를 실행하도록 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8d99a8a851fc71224c4095d3dc8c906d38b101b8" translate="yes" xml:space="preserve">
          <source>Creates a new static array from given data.</source>
          <target state="translated">주어진 데이터에서 새로운 정적 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ecd36a22428e9994d09134717eafec38a89d2e58" translate="yes" xml:space="preserve">
          <source>Creates a pair of connected sockets.</source>
          <target state="translated">연결된 소켓 쌍을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="19f224f0cad04c0c9a5314d50caf1aa975093e9d" translate="yes" xml:space="preserve">
          <source>Creates a proxy for the value &lt;code&gt;a&lt;/code&gt; that will forward all operations while disabling implicit conversions. The aliased item &lt;code&gt;a&lt;/code&gt; must be an &lt;b&gt;lvalue&lt;/b&gt;. This is useful for creating a new type from the &quot;base&quot; type (though this is &lt;b&gt;not&lt;/b&gt; a subtype-supertype relationship; the new type is not related to the old type in any way, by design).</source>
          <target state="translated">암시 적 변환을 비활성화하면서 모든 작업을 전달 하는 값 &lt;code&gt;a&lt;/code&gt; 에 대한 프록시를 만듭니다 . 별명 항목 &lt;code&gt;a&lt;/code&gt; 는 &lt;b&gt;lvalue&lt;/b&gt; 이어야합니다 . 이것은 &quot;기본&quot;유형의 새로운 유형을 만드는 데 유용합니다 (이 비록 &lt;b&gt;하지&lt;/b&gt; 하위 유형 - 슈퍼 관계, 새로운 유형의 디자인에 의해, 어떤 방식으로 기존의 유형과 관련이 없습니다).</target>
        </trans-unit>
        <trans-unit id="facab5397d905340fc2ff34e036fe91a505cf570" translate="yes" xml:space="preserve">
          <source>Creates a random-access range consisting of exactly the first element of the given range.</source>
          <target state="translated">주어진 범위의 첫 번째 요소로 구성된 랜덤 액세스 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="491697895d99be2bf8ff4cd9ed471190dfadb752" translate="yes" xml:space="preserve">
          <source>Creates a random-access range consisting of zero elements of the given range.</source>
          <target state="translated">주어진 범위의 0 요소로 구성된 랜덤 액세스 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2f69619e79d80e1df263dcf9dbcb2c394594c350" translate="yes" xml:space="preserve">
          <source>Creates a range by successive calls to a given function. This allows to create ranges as a single delegate.</source>
          <target state="translated">주어진 함수를 연속적으로 호출하여 범위를 만듭니다. 이를 통해 범위를 단일 대리자로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="167e3b6167defb5f50874936631196fc03fabc4e" translate="yes" xml:space="preserve">
          <source>Creates a range consisting of numbers between a starting point and ending point, spaced apart by a given interval.</source>
          <target state="translated">지정된 간격으로 이격 된 시작점과 끝점 사이의 숫자로 구성된 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="095bb16dbe08643123728b96d2a088f28e3da974" translate="yes" xml:space="preserve">
          <source>Creates a range of values that span the given starting and stopping values.</source>
          <target state="translated">지정된 시작 및 중지 값에 걸쳐있는 값 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c95f11a9b28c359aba0cb5384ce5aea65f8856bc" translate="yes" xml:space="preserve">
          <source>Creates a range that consists of a single element repeated</source>
          <target state="translated">반복되는 단일 요소로 구성된 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6fa647cca40fc0069485c0e4600015ae305d64f8" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the</source>
          <target state="translated">반복되는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="119d886f6f9141897a559c5bf0cae6c375d23ffa" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the first elements of the given ranges.</source>
          <target state="translated">주어진 범위의 첫 번째 요소를 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b3797332557503d8df3a90878b6a631d088b9e66" translate="yes" xml:space="preserve">
          <source>Creates a range that iterates over the given arguments.</source>
          <target state="translated">주어진 인수를 반복하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="27a319945d62e58889db17071829a24459cceffe" translate="yes" xml:space="preserve">
          <source>Creates a range that offers a view of a given range as though its elements were reordered according to a given range of indices.</source>
          <target state="translated">주어진 인덱스 범위에 따라 요소가 재정렬 된 것처럼 지정된 범위의보기를 제공하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f505e45463d22852e5431617427809b2bc561947" translate="yes" xml:space="preserve">
          <source>Creates a range that returns a fixed-size sliding window over the original range. Unlike chunks, it advances a configurable number of items at a time, not one chunk at a time.</source>
          <target state="translated">원래 범위에 고정 크기 슬라이딩 창을 반환하는 범위를 만듭니다. 청크와 달리 한 번에 한 청크가 아니라 구성 가능한 항목 수를 한 번에 전진시킵니다.</target>
        </trans-unit>
        <trans-unit id="e2da09b0362ffc9ff9f92b609fc490c7a66e9f7b" translate="yes" xml:space="preserve">
          <source>Creates a range that returns a number of chunks of approximately equal length from the original range.</source>
          <target state="translated">원래 범위와 대략 같은 길이의 청크 수를 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c3774ff477392cd2c3383bbfc03f5d68150b2336" translate="yes" xml:space="preserve">
          <source>Creates a range that returns fixed-size chunks of the original range.</source>
          <target state="translated">원래 범위의 고정 크기 청크를 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0d113436e57d2b2729c85287cfeed4bd50c9facf" translate="yes" xml:space="preserve">
          <source>Creates a range that wraps a given range, forwarding along its elements while also calling a provided function with each element.</source>
          <target state="translated">각 요소와 함께 제공된 함수를 호출하면서 해당 요소를 전달하면서 주어진 범위를 감싸는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f7977beaa2aaf3f6cc573dcadaf85a1c0d137ad7" translate="yes" xml:space="preserve">
          <source>Creates a scalable &lt;code&gt;AllocatorList&lt;/code&gt; of &lt;code&gt;Regions&lt;/code&gt;, each having at least &lt;code&gt;bytesPerRegion&lt;/code&gt; bytes. Allocation is very fast. This allocator does not offer &lt;code&gt;deallocate&lt;/code&gt; but does free all regions in its destructor. It is recommended for short-lived batch applications that count on never running out of memory.</source>
          <target state="translated">적어도 &lt;code&gt;bytesPerRegion&lt;/code&gt; 바이트를 갖는 &lt;code&gt;Regions&lt;/code&gt; 의 확장 가능한 &lt;code&gt;AllocatorList&lt;/code&gt; 를 작성 합니다. 할당이 매우 빠릅니다. 이 할당자는 할당 &lt;code&gt;deallocate&lt;/code&gt; 제공하지 않지만 소멸자의 모든 지역을 해제 합니다. 절대로 메모리가 부족하지 않은 단기 배치 응용 프로그램에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="6f435c0e7fa6220851faf44b48ca047ab20cefcb" translate="yes" xml:space="preserve">
          <source>Creates a separate index for a range.</source>
          <target state="translated">범위에 대해 별도의 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dd006c74f19abaa4a0761b1b7efaf29942f86da3" translate="yes" xml:space="preserve">
          <source>Creates a sequence of zero or more aliases. This is most commonly used as template parameters or arguments.</source>
          <target state="translated">0 개 이상의 별칭 시퀀스를 만듭니다. 템플릿 매개 변수 또는 인수로 가장 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40566702e6ad921ff558ff9ca4d1037811d09aae" translate="yes" xml:space="preserve">
          <source>Creates a sub-range consisting of only up to the first</source>
          <target state="translated">처음까지만 구성된 하위 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="469d599d62d1c2fd391700f6a0c78d2089510708" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link (symlink).</source>
          <target state="translated">심볼릭 링크 (symlink)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="802b8df3eba4f0a49c5a4217df7e199c969ce5ad" translate="yes" xml:space="preserve">
          <source>Creates a unidirectional pipe.</source>
          <target state="translated">단방향 파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf8f38539d3338ea07ae1f542a53a2838ccaf683" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; set up to parse one line at a time from the file into a tuple.</source>
          <target state="translated">작성 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 튜플로 파일에서 동시에 해석 한 라인을 설정한다.</target>
        </trans-unit>
        <trans-unit id="3561d870353a64c33492bae1227a4b54a7562e97" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;AliasSeq&lt;/code&gt; which repeats &lt;code&gt;TList&lt;/code&gt; exactly &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;TList&lt;/code&gt; 를 정확히 &lt;code&gt;n&lt;/code&gt; 번 반복 하는 &lt;code&gt;AliasSeq&lt;/code&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="8204b9ea20ad3e99dc18dafe9f5966a149ef25a0" translate="yes" xml:space="preserve">
          <source>Creates an empty range from the given range in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). If it can, it will return the same range type. If not, it will return &lt;code&gt;takeExactly(range, 0)&lt;/code&gt;.</source>
          <target state="translated">지정된 범위에서 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 의 빈 범위를 만듭니다 . 가능한 경우 동일한 범위 유형을 반환합니다. 그렇지 않으면 &lt;code&gt;takeExactly(range, 0)&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="98c208a0fd5b7f2985b53749917bb319ab1b4a0f" translate="yes" xml:space="preserve">
          <source>Creates an event object.</source>
          <target state="translated">이벤트 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9fc3668b0b3ac61f1c2ccf2f6e391f909fb421a6" translate="yes" xml:space="preserve">
          <source>Creates an infinite range that repeats the given forward range indefinitely. Good for implementing circular buffers.</source>
          <target state="translated">주어진 앞으로 범위를 무기한 반복하는 무한 범위를 만듭니다. 순환 버퍼 구현에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dcde82886bef2cfc57fa138c18fa3fe6f213ba99" translate="yes" xml:space="preserve">
          <source>Creates an instance of worker-local storage, initialized with a given value. The value is &lt;code&gt;lazy&lt;/code&gt; so that you can, for example, easily create one instance of a class for each worker. For usage example, see the &lt;code&gt;WorkerLocalStorage&lt;/code&gt; struct.</source>
          <target state="translated">지정된 값으로 초기화 된 작업자 로컬 저장소 인스턴스를 만듭니다. 예를 들어 각 작업자에 대해 하나의 클래스 인스턴스를 쉽게 만들 수 있도록 값이 &lt;code&gt;lazy&lt;/code&gt; 됩니다. 사용 예는 &lt;code&gt;WorkerLocalStorage&lt;/code&gt; 구조체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be1b805e9512fab0c82226f8469579575b03085d" translate="yes" xml:space="preserve">
          <source>Creates an lvalue or rvalue of type &lt;code&gt;T&lt;/code&gt; for &lt;code&gt;typeof(...)&lt;/code&gt; and &lt;code&gt;__traits(compiles, ...)&lt;/code&gt; purposes. No actual value is returned.</source>
          <target state="translated">형의 좌변 또는를 rvalue 작성 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;typeof(...)&lt;/code&gt; 와 &lt;code&gt;__traits(compiles, ...)&lt;/code&gt; 목적. 실제 값이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaebf9f2d50b56a9272662e3ba187103b8fd7fb6" translate="yes" xml:space="preserve">
          <source>Creates and returns the hidden parameters for this function declaration.</source>
          <target state="translated">이 함수 선언에 대한 숨겨진 매개 변수를 작성하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9b553ea67f7afbb68b5ef6b9110f190f5fa0d536" translate="yes" xml:space="preserve">
          <source>Creates and starts a new Thread object that executes dg and adds it to the list of tracked threads.</source>
          <target state="translated">dg를 실행하고 추적 된 스레드 목록에 추가하는 새 Thread 객체를 만들고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d8465192a47f3a3964b86383849851b3f987af9e" translate="yes" xml:space="preserve">
          <source>Creates and starts a new Thread object that executes fn and adds it to the list of tracked threads.</source>
          <target state="translated">fn을 실행하고 추적 된 스레드 목록에 추가하는 새 Thread 객체를 만들고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1f14747fb861d9f57045e9760eebadb571c0f14c" translate="yes" xml:space="preserve">
          <source>Creates the file if it does not already exist.</source>
          <target state="translated">파일이 없으면 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5e72ff62874af2b080424b1f364475d8251da057" translate="yes" xml:space="preserve">
          <source>Creates the list of modules based on the files provided</source>
          <target state="translated">제공된 파일을 기반으로 모듈 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c36b26347d25b74467c336b27111c896866bd305" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding exactly</source>
          <target state="translated">정확히 버림으로써 발생하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3bc721a88f6358a1f98c1960601822da71eda438" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the first</source>
          <target state="translated">첫 번째를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f4fae2eaf902de2336623c5f44ed9233da515843" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the first element from the given range.</source>
          <target state="translated">주어진 범위에서 첫 번째 요소를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e8ccf47a3faeae60cbaa6e290f3c7add8d8439e4" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the last</source>
          <target state="translated">마지막을 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e26745f992813425c3f6e9ec560904ac5dfc6d56" translate="yes" xml:space="preserve">
          <source>Creates the range that results from discarding the last element from the given range.</source>
          <target state="translated">주어진 범위에서 마지막 요소를 버린 결과 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="702d6feb03374612a47955af68790e7167c2df15" translate="yes" xml:space="preserve">
          <source>Creating Immutable Data</source>
          <target state="translated">불변 데이터 생성</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="662cb4a2bd7d633921dbca8a7d42f872af7c9656" translate="yes" xml:space="preserve">
          <source>Cs</source>
          <target state="translated">Cs</target>
        </trans-unit>
        <trans-unit id="c2c3639bbe4de0aea10b057ea83de756ef98378f" translate="yes" xml:space="preserve">
          <source>Ctor</source>
          <target state="translated">Ctor</target>
        </trans-unit>
        <trans-unit id="a47b165571b7225fe9e41c496a97f58f335b0c95" translate="yes" xml:space="preserve">
          <source>CtorFlow &lt;code&gt;ctorflow&lt;/code&gt;</source>
          <target state="translated">CtorFlow &lt;code&gt;ctorflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2ec2f1f5ce49dd13daec8eee36db1395ae3b43f" translate="yes" xml:space="preserve">
          <source>CtorFlow &lt;strong id=&quot;clone&quot;&gt;clone&lt;/strong&gt;();</source>
          <target state="translated">CtorFlow &lt;strong id=&quot;clone&quot;&gt;클론&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="7c804c33db286558bb634271d46f72ed27582aa7" translate="yes" xml:space="preserve">
          <source>Cuneiform</source>
          <target state="translated">Cuneiform</target>
        </trans-unit>
        <trans-unit id="45b5a2c7a3a08d60fb826e098c079562c9b73f47" translate="yes" xml:space="preserve">
          <source>Cuneiform Numbers and Punctuation</source>
          <target state="translated">설형 문자 숫자와 문장 부호</target>
        </trans-unit>
        <trans-unit id="c04085590ca8e7a54d013972ef35c99a27d5d737" translate="yes" xml:space="preserve">
          <source>Curl &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">컬 &lt;strong id=&quot;dup&quot;&gt;덥&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="773dbcf2918b7b09831a0ed13a940ea3c1ee1fa6" translate="yes" xml:space="preserve">
          <source>CurlCode &lt;strong id=&quot;getTiming&quot;&gt;getTiming&lt;/strong&gt;(CurlInfo timing, ref double val);</source>
          <target state="translated">CurlCode &lt;strong id=&quot;getTiming&quot;&gt;getTiming&lt;/strong&gt; (CurlInfo 타이밍, ref double val);</target>
        </trans-unit>
        <trans-unit id="c2ad2d9e83c0551cb2f717df5892a96ecafc33b4" translate="yes" xml:space="preserve">
          <source>CurlCode &lt;strong id=&quot;perform&quot;&gt;perform&lt;/strong&gt;(ThrowOnError throwOnError = Yes.throwOnError);</source>
          <target state="translated">CurlCode &lt;strong id=&quot;perform&quot;&gt;perform&lt;/strong&gt; (ThrowOnError throwOnError = Yes.throwOnError);</target>
        </trans-unit>
        <trans-unit id="be31623169a932d4c6c560d7201b407aa5182a35" translate="yes" xml:space="preserve">
          <source>CurlInfo &lt;code&gt;timing&lt;/code&gt;</source>
          <target state="translated">CurlInfo &lt;code&gt;timing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12060f8ec6f86ad11a42f46cb52ac099f81f88f5" translate="yes" xml:space="preserve">
          <source>CurlKHType &lt;strong id=&quot;keytype&quot;&gt;keytype&lt;/strong&gt;;</source>
          <target state="translated">CurlKHType &lt;strong id=&quot;keytype&quot;&gt;키 타입&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="88902869e96472323a9edc08d7ae406940c970e5" translate="yes" xml:space="preserve">
          <source>CurlOption &lt;code&gt;option&lt;/code&gt;</source>
          <target state="translated">CurlOption &lt;code&gt;option&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52b9269b5ed7da7a493a1dbe83846551a4d7568c" translate="yes" xml:space="preserve">
          <source>CurlSeek delegate(long, CurlSeekPos) &lt;code&gt;callback&lt;/code&gt;</source>
          <target state="translated">CurlSeek 델리게이트 (long, CurlSeekPos) &lt;code&gt;callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37f1460d74729779c053720f8343662b43997475" translate="yes" xml:space="preserve">
          <source>Currency Symbols</source>
          <target state="translated">통화 기호</target>
        </trans-unit>
        <trans-unit id="84f9a40ca51da6b15c30fb2dde0fe4ae3193cebf" translate="yes" xml:space="preserve">
          <source>Currency_Symbol</source>
          <target state="translated">Currency_Symbol</target>
        </trans-unit>
        <trans-unit id="1c51a4dec4b6d066a950991a20e81d7204b847ff" translate="yes" xml:space="preserve">
          <source>Current 'state' of the compiler. Used to gather together most global variables. This struct is saved/restored during function body parsing.</source>
          <target state="translated">컴파일러의 현재 '상태'. 대부분의 전역 변수를 모으는 데 사용됩니다. 이 구조체는 함수 본문 파싱 중에 저장 / 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb5afa66ef9deeeb65948941312b1da2a80f78e" translate="yes" xml:space="preserve">
          <source>Current items are equal; no editing is necessary.</source>
          <target state="translated">현재 품목은 동일합니다. 편집이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69802cb8c8d960584abd7b92600c394739df538c" translate="yes" xml:space="preserve">
          <source>Current limitation: Due to &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=11500&quot;&gt;bug #11500&lt;/a&gt;, currently the constructors specified in this mixin cannot be overloaded with any other custom constructors. Thus this mixin can currently only be used when no such custom constructors need to be explicitly specified.</source>
          <target state="translated">현재 제한 사항 : &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=11500&quot;&gt;버그 # 11500&lt;/a&gt; 때문에 현재이 믹스 인에 지정된 생성자는 다른 사용자 지정 생성자로 오버로드 할 수 없습니다. 따라서이 믹스 인은 현재 이러한 사용자 정의 생성자를 명시 적으로 지정할 필요가없는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce942321383836e436083da3460ea976ea73c9cf" translate="yes" xml:space="preserve">
          <source>Currently nested templates can capture at most one context. As a typical example, non-static template member functions cannot take local symbol by using template alias parameter.</source>
          <target state="translated">현재 중첩 된 템플릿은 최대 하나의 컨텍스트를 캡처 할 수 있습니다. 일반적인 예로 정적이 아닌 템플릿 멤버 함수는 템플릿 별칭 매개 변수를 사용하여 로컬 심볼을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff4623ac05dc3913907977438836d2f3c936fb47" translate="yes" xml:space="preserve">
          <source>Currently only supports UTF documents.  If there is an encoding attribute in the prolog, it is ignored.</source>
          <target state="translated">현재 UTF 문서 만 지원합니다. 프롤로그에 인코딩 속성이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb34bac47d9c08061ba96d029fe7cfb9cc5802d" translate="yes" xml:space="preserve">
          <source>Currently only works on x86 and Itanium CPUs. Many processors have bugs in their microcode for the CPUID instruction, so sometimes the cache information may be incorrect.</source>
          <target state="translated">현재 x86 및 Itanium CPU에서만 작동합니다. 많은 프로세서가 CPUID 명령에 대한 마이크로 코드에 버그를 가지고 있으므로 때때로 캐시 정보가 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc0dbba909b8d801dfd589ff4ce7238fefbfe4c" translate="yes" xml:space="preserve">
          <source>Currently, only FreeBSD/DragonFlyBSD supports a more precise clock, where it uses &lt;code&gt;CLOCK_MONOTONIC_PRECISE&lt;/code&gt; for the monotonic time and &lt;code&gt;CLOCK_REALTIME_PRECISE&lt;/code&gt; for the wall clock time.</source>
          <target state="translated">현재는 FreeBSD / DragonFlyBSD만이보다 정확한 클럭을 지원합니다 . 단조로운 시간 에는 &lt;code&gt;CLOCK_MONOTONIC_PRECISE&lt;/code&gt; 를 사용 하고 &lt;code&gt;CLOCK_REALTIME_PRECISE&lt;/code&gt; 시간에는 CLOCK_REALTIME_PRECISE 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="959207731027f2760054a49b8e3de46c08dd6bdd" translate="yes" xml:space="preserve">
          <source>Currently, only Linux and FreeBSD/DragonFlyBSD support a coarser clock, and on other platforms, it's treated as &lt;code&gt;ClockType.normal&lt;/code&gt;.</source>
          <target state="translated">현재는 Linux 및 FreeBSD / DragonFlyBSD 만 더 거친 시계를 지원하며 다른 플랫폼에서는 &lt;code&gt;ClockType.normal&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">맞춤 페이지 캐시 객체</target>
        </trans-unit>
        <trans-unit id="b3fc60eff39cb549b6d9c803b4a451eb43428671" translate="yes" xml:space="preserve">
          <source>Custom predicate for comparison of haystack and needle</source>
          <target state="translated">건초 더미와 바늘의 비교를위한 사용자 정의 술어</target>
        </trans-unit>
        <trans-unit id="c8a592f320e5a686e3807c060bc9b332dcc6b0b4" translate="yes" xml:space="preserve">
          <source>Custom predicate functions.</source>
          <target state="translated">사용자 정의 술어 기능.</target>
        </trans-unit>
        <trans-unit id="bfed9740a3d512ab6d90b0cbc0ffce4c3744006e" translate="yes" xml:space="preserve">
          <source>Custom request, for customizing the get command like</source>
          <target state="translated">다음과 같이 get 명령을 사용자 정의하기위한 사용자 정의 요청</target>
        </trans-unit>
        <trans-unit id="a74881d82849f50f687aa6d7ccfec894be3d7785" translate="yes" xml:space="preserve">
          <source>Customized Base64 encoding schemes can be implemented by instantiating this template with the appropriate arguments. For example:</source>
          <target state="translated">이 인수를 적절한 인수로 인스턴스화하여 사용자 정의 된 Base64 인코딩 체계를 구현할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5edb9626eb87d040db1eb00c7aa5b2c28b0e6650" translate="yes" xml:space="preserve">
          <source>Cycle!R &lt;strong id=&quot;cycle&quot;&gt;cycle&lt;/strong&gt;(R)(R input, size_t index = 0)</source>
          <target state="translated">사이클! R &lt;strong id=&quot;cycle&quot;&gt;사이클&lt;/strong&gt; (R) (R 입력, size_t 인덱스 = 0)</target>
        </trans-unit>
        <trans-unit id="7d8cafa53ee2c1c0875ad69af202f51945cbe5f0" translate="yes" xml:space="preserve">
          <source>Cycles (circular dependencies) in the import declarations are allowed as long as not both of the modules contain static constructors or static destructors. Violation of this rule will result in a runtime exception.</source>
          <target state="translated">두 모듈 모두 정적 생성자 또는 정적 소멸자를 포함하지 않는 한 가져 오기 선언의 순환 (순환 종속성)이 허용됩니다. 이 규칙을 위반하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb48393cdd04925357b593a4e1a8ff95b3dc4455" translate="yes" xml:space="preserve">
          <source>Cycles (circular dependencies) in the import declarations are allowed so long as neither, or one, but not both, of the modules, contains static constructors or static destructors. Violation of this rule will result in a runtime exception.</source>
          <target state="translated">가져 오기 선언의 순환 (순환 종속성)은 모듈 중 하나 또는 둘 다가 아닌 정적 생성자 또는 정적 소멸자를 포함하지 않는 한 허용됩니다. 이 규칙을 위반하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="467f7f2e1a32702888fd1652ec31b786fd0b1c0b" translate="yes" xml:space="preserve">
          <source>Cyclic Redundancy Check (32-bit) implementation.</source>
          <target state="translated">주기적 중복 검사 (32 비트) 구현.</target>
        </trans-unit>
        <trans-unit id="36c9c09d1a88bef7e48da22695dc2c7f51367161" translate="yes" xml:space="preserve">
          <source>Cyclic functions (i.e. functions that wind up directly or indirectly calling themselves) are inferred as being impure, throwing, and @system.</source>
          <target state="translated">순환 함수 (즉, 직접 또는 간접적으로 자신을 호출하는 함수)는 불순하고, 던지고, @ 시스템 인 것으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="0de933d74049be9213bca8bd3670f39dc4e2b3ac" translate="yes" xml:space="preserve">
          <source>Cyclic redundancy check (CRC) value.</source>
          <target state="translated">CRC (Cyclic Redundancy Check) 값입니다.</target>
        </trans-unit>
        <trans-unit id="5330ddfa4df379999c1bfc18ba91ec4dcf678d1d" translate="yes" xml:space="preserve">
          <source>Cypriot</source>
          <target state="translated">Cypriot</target>
        </trans-unit>
        <trans-unit id="3f15c59d268026cfd87f29afcccbd986a8b120f6" translate="yes" xml:space="preserve">
          <source>Cypriot Syllabary</source>
          <target state="translated">키프로스 실라 바리</target>
        </trans-unit>
        <trans-unit id="1cb0955565a00adf2d4dd0f3ab0976a162bd4df5" translate="yes" xml:space="preserve">
          <source>Cyrillic</source>
          <target state="translated">Cyrillic</target>
        </trans-unit>
        <trans-unit id="13cb71dbdc01614be3dd0248e4bab527145b3a0c" translate="yes" xml:space="preserve">
          <source>Cyrillic Extended-A</source>
          <target state="translated">키릴 확장 -A</target>
        </trans-unit>
        <trans-unit id="6e19f6b8db26b5f4584e846a958391e34785c75d" translate="yes" xml:space="preserve">
          <source>Cyrillic Extended-B</source>
          <target state="translated">키릴 확장 B</target>
        </trans-unit>
        <trans-unit id="5f096016543cf8648b1e0ba5ebd0cde1cb50f3a2" translate="yes" xml:space="preserve">
          <source>Cyrillic Supplement</source>
          <target state="translated">키릴 보충</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="c075a684f58014ba537d34ff9519af0073d068d0" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;duration&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;duration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="420ba6fd12e656eed08bc3686d185ed3d67a02db" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31ddff47ea2df1a65990ec2b6a0572ffb0107b5b" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df22aa7a42bde4b06895be25544565774c8fe9f9" translate="yes" xml:space="preserve">
          <source>D &lt;code&gt;td&lt;/code&gt;</source>
          <target state="translated">D &lt;code&gt;td&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ca85edb97301be7fd1849c8854fbc23b8139193" translate="yes" xml:space="preserve">
          <source>D And C Function Prototype Equivalence</source>
          <target state="translated">D와 C 함수 프로토 타입 동등성</target>
        </trans-unit>
        <trans-unit id="c3dde59eb8e6d6f854408cbe61a4fbfc9b447911" translate="yes" xml:space="preserve">
          <source>D And C Type Equivalence</source>
          <target state="translated">D와 C 유형 동등 물</target>
        </trans-unit>
        <trans-unit id="4959476e34feab4fd79ecd8a71227840715bd031" translate="yes" xml:space="preserve">
          <source>D And C++ Type Equivalence</source>
          <target state="translated">D와 C ++ 타입 동등성</target>
        </trans-unit>
        <trans-unit id="86da087c301b2f798d4ba996b708f1700a968709" translate="yes" xml:space="preserve">
          <source>D Code Formatting Macros</source>
          <target state="translated">D 코드 형식 매크로</target>
        </trans-unit>
        <trans-unit id="d3f23c864026a341662336508bfcf4b56460282f" translate="yes" xml:space="preserve">
          <source>D Grammar</source>
          <target state="translated">D 문법</target>
        </trans-unit>
        <trans-unit id="20fb9b176e61fdbf6fd72a0f9b1c75e432e9363e" translate="yes" xml:space="preserve">
          <source>D Operations That Involve the Garbage Collector</source>
          <target state="translated">가비지 콜렉터와 관련된 D 작업</target>
        </trans-unit>
        <trans-unit id="3b1a6b14130ac212af69f729479639b4f6728d35" translate="yes" xml:space="preserve">
          <source>D accomplishes typesafe linking by</source>
          <target state="translated">D는 다음에 의해 타입 세이프 연결을 달성합니다.</target>
        </trans-unit>
        <trans-unit id="e8bd85138c80a70ce7a94bdf0dbb9e8c049bd318" translate="yes" xml:space="preserve">
          <source>D allows overloading of the comparison operators &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; via two functions, &lt;code&gt;opEquals&lt;/code&gt; and &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">D는 비교 연산자 과부하 허용 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 두 가지 기능을 통해 &lt;code&gt;opEquals&lt;/code&gt; 및 &lt;code&gt;opCmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245c88a0d2db8ba44dd302d346881e4a09782dfc" translate="yes" xml:space="preserve">
          <source>D also provides the mechanisms to write code where the garbage collector is &lt;b&gt;not involved&lt;/b&gt;. More information is provided below.</source>
          <target state="translated">D는 또한 가비지 수집기가 포함 &lt;b&gt;되지 않은&lt;/b&gt; 코드를 작성하는 메커니즘을 제공합니다 . 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="536f3a2ed377e10f64d552c2d73a20c905e02fc9" translate="yes" xml:space="preserve">
          <source>D binding to C++</source>
          <target state="translated">C ++에 대한 D 바인딩</target>
        </trans-unit>
        <trans-unit id="19ddf415c5a9aba3800b9f9389ba5483b40b7a2f" translate="yes" xml:space="preserve">
          <source>D binding to C++ std::allocator.</source>
          <target state="translated">C ++ std :: allocator에 대한 D 바인딩.</target>
        </trans-unit>
        <trans-unit id="31b1546a7311b8038bca2bd20f9fc0ac1391d37a" translate="yes" xml:space="preserve">
          <source>D bindings for standard C headers.</source>
          <target state="translated">표준 C 헤더에 대한 D 바인딩.</target>
        </trans-unit>
        <trans-unit id="40b1be27cbfa93ccf74b6920df5a41be8c48c101" translate="yes" xml:space="preserve">
          <source>D can easily call C callbacks (function pointers), and C can call callbacks provided by D code if the callback is an &lt;code&gt;extern(C)&lt;/code&gt; function, or some other linkage that both sides have agreed to (e.g. &lt;code&gt;extern(Windows)&lt;/code&gt;).</source>
          <target state="translated">D는 C 콜백 (함수 포인터)을 쉽게 호출 할 수 있으며 콜백이 &lt;code&gt;extern(C)&lt;/code&gt; 함수이거나 양측이 동의 한 다른 연결 (예 : &lt;code&gt;extern(Windows)&lt;/code&gt; ) 인 경우 D 코드가 제공하는 콜백을 콜할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c470394ce7797205adec8b8a502a172295e638c7" translate="yes" xml:space="preserve">
          <source>D can explicitly manage memory using a variety of library tools, such as with &lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt;&lt;code&gt;std.experimental.allocator&lt;/code&gt;&lt;/a&gt;. Additionally, &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; and &lt;code&gt;core.stdc.stdlib.free&lt;/code&gt; can be used directly for connecting to C++ functions that expect &lt;code&gt;malloc&lt;/code&gt;'d buffers.</source>
          <target state="translated">D는 &lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt; &lt;code&gt;std.experimental.allocator&lt;/code&gt; &lt;/a&gt; 와 같은 다양한 라이브러리 도구를 사용하여 메모리를 명시 적으로 관리 할 수 ​​있습니다 . 또한 &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; 및 &lt;code&gt;core.stdc.stdlib.free&lt;/code&gt; 는 &lt;code&gt;malloc&lt;/code&gt; 'd 버퍼 가 필요한 C ++ 함수에 연결하는 데 직접 사용할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
