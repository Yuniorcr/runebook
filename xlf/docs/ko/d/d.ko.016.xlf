<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="e8adc363777a6afb1445324ba10df4840c08d231" translate="yes" xml:space="preserve">
          <source>An input range of the subranges of elements between separators. If &lt;code&gt;r&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements.</source>
          <target state="translated">구분 기호 사이의 요소 하위 범위의 입력 범위입니다. 경우 &lt;code&gt;r&lt;/code&gt; A는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어&lt;/a&gt; 또는 &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 범위&lt;/a&gt; , 반환 범위는 마찬가지 일 것이다. 범위를 구분 기호로 사용하면 양방향성이 불가능합니다. 빈 범위가 제공되면 결과는 빈 범위입니다. 하나의 구분 기호가있는 범위가 제공되면 결과는 두 개의 빈 요소가있는 범위입니다.</target>
        </trans-unit>
        <trans-unit id="77fcb0b8936d71a377fcbb398a2e222509a71db3" translate="yes" xml:space="preserve">
          <source>An input range representing the results of the map. This range has a length iff &lt;code&gt;source&lt;/code&gt; has a length.</source>
          <target state="translated">지도 결과를 나타내는 입력 범위입니다. 이 범위의 길이 는 &lt;code&gt;source&lt;/code&gt; 의 길이가 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e3ed7a93b1ad11aa4211044600bdb3f20f6462d6" translate="yes" xml:space="preserve">
          <source>An input range that offers the elements of &lt;code&gt;inputRange&lt;/code&gt;. Regardless of whether &lt;code&gt;inputRange&lt;/code&gt; is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes &lt;code&gt;inputRange&lt;/code&gt; to be iterated and returns its elements in turn. In addition, the same elements will be passed to &lt;code&gt;outputRange&lt;/code&gt; or &lt;code&gt;fun&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;inputRange&lt;/code&gt; 의 요소를 제공하는 입력 범위입니다 . &lt;code&gt;inputRange&lt;/code&gt; 여부에 관계없이 가 더 강력한 범위 (앞으로, 양방향 등) 결과는 항상 입력 범위입니다. 이것을 &lt;code&gt;inputRange&lt;/code&gt; 가 반복되고 요소가 차례로 리턴됩니다. 또한 동일한 요소가 &lt;code&gt;outputRange&lt;/code&gt; 또는 &lt;code&gt;fun&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8db0e5d660666f379e5bd5033aea5532a4a6d755" translate="yes" xml:space="preserve">
          <source>An input range, or a single element, to join the ranges on</source>
          <target state="translated">범위를 결합 할 입력 범위 또는 단일 요소</target>
        </trans-unit>
        <trans-unit id="53e41ba736cd23d712f10ab5d4286f8a49bbcc4b" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;BoyerMooreFinder&lt;/code&gt; that can be used with &lt;code&gt;find()&lt;/code&gt; to invoke the Boyer-Moore matching algorithm for finding of &lt;code&gt;needle&lt;/code&gt; in a given haystack.</source>
          <target state="translated">&lt;code&gt;BoyerMooreFinder&lt;/code&gt; 의 인스턴스 &lt;code&gt;find()&lt;/code&gt; 와 함께 사용 하여 지정된 건초 더미에서 &lt;code&gt;needle&lt;/code&gt; 을 찾기 위해 Boyer-Moore 일치 알고리즘을 호출 할 수있는 .</target>
        </trans-unit>
        <trans-unit id="082c7f6d5b0afa12e8dd042a23683a443fd1ed5f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;RefCounted&lt;/code&gt; is a reference to a structure, which is referred to as the</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; 의 인스턴스는 구조 에 대한 참조이며</target>
        </trans-unit>
        <trans-unit id="81dfbeaffbeddcdca676ca9f6b1f01a2e767b7b5" translate="yes" xml:space="preserve">
          <source>An instance of Class called ClassXXXX.</source>
          <target state="translated">ClassXXXX라는 Class 인스턴스.</target>
        </trans-unit>
        <trans-unit id="df7f1cf5303035f4982248b96ae7f8dcd8dbd36d" translate="yes" xml:space="preserve">
          <source>An instance of ModuleInfo is generated into the object file for each compiled module.</source>
          <target state="translated">컴파일 된 각 모듈의 오브젝트 파일에 ModuleInfo 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0af1d2f763a9f835d30a298bd5512f1a1ecb310d" translate="yes" xml:space="preserve">
          <source>An instance of Rebindable!T.</source>
          <target state="translated">Rebindable! T의 인스턴스</target>
        </trans-unit>
        <trans-unit id="f20d76f76289925279727351d584459074c5f577" translate="yes" xml:space="preserve">
          <source>An instance of StaticClassXXXX called StaticXXXX for the static members.</source>
          <target state="translated">정적 멤버에 대해 StaticXXXX라는 StaticClassXXXX 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7588661ba7457b5448344cfc895cdb3b665fc0e3" translate="yes" xml:space="preserve">
          <source>An instance of an interface cannot be created.</source>
          <target state="translated">인터페이스 인스턴스를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0019410ce360e69e8b7f1b0e344a14bdf938e6e9" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed these values.</source>
          <target state="translated">정수 리터럴은이 값을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9fe6552b2cda57271319df5e41efc135feb5083" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed those values.</source>
          <target state="translated">정수 리터럴은 해당 값을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dd1eb0e6607d6d3937d482192de7ee283f310ab" translate="yes" xml:space="preserve">
          <source>An interface is a pointer to a pointer to a vtbl[]. The vtbl[0] entry is a pointer to the corresponding instance of the object.Interface class. The rest of the &lt;code&gt;vtbl[1..$]&lt;/code&gt; entries are pointers to the virtual functions implemented by that interface, in the order that they were declared.</source>
          <target state="translated">인터페이스는 vtbl []에 대한 포인터를 가리키는 포인터입니다. vtbl [0] 항목은 object.Interface 클래스의 해당 인스턴스에 대한 포인터입니다. &lt;code&gt;vtbl[1..$]&lt;/code&gt; 의 나머지 부분 [1 .. $] 항목은 선언 된 순서대로 해당 인터페이스에 의해 구현 된 가상 함수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f535852beda0178c415bc9fa63dbe96b52f5fffb" translate="yes" xml:space="preserve">
          <source>An interface to a pipe created by the &lt;a href=&quot;#pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">에 의해 작성된 파이프에 인터페이스 &lt;a href=&quot;#pipe&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; 함수로 입니다.</target>
        </trans-unit>
        <trans-unit id="ab4113213830fe7d72486bf84fdb4481ba6c3903" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the</source>
          <target state="translated">할당 된 메모리 블록에 대한 내부 포인터는 GC에 객체가 사용 중임을 알리기에 충분합니다. 즉, 포인터를 유지할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e468e9d85b8c7d660b637f4814b9ebc7dd018028" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the beginning of the allocated memory.</source>
          <target state="translated">할당 된 메모리 블록에 대한 내부 포인터는 GC에 객체가 사용 중임을 알리기에 충분합니다. 즉, 할당 된 메모리의 시작에 대한 포인터를 유지할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f380906d548143bc93c92fea41836178dba951d1" translate="yes" xml:space="preserve">
          <source>An invalid IPv4 host address.</source>
          <target state="translated">유효하지 않은 IPv4 호스트 주소입니다.</target>
        </trans-unit>
        <trans-unit id="5c151927ff98085446422d3ef9db66acbb3009ff" translate="yes" xml:space="preserve">
          <source>An invalid memory operation error occurs in circumstances when the garbage collector has detected an operation it cannot reliably handle. The default D GC is not re-entrant, so this can happen due to allocations done from within finalizers called during a garbage collection cycle.</source>
          <target state="translated">가비지 수집기가 안정적으로 처리 할 수없는 작업을 감지 한 경우에는 잘못된 메모리 작업 오류가 발생합니다. 기본 D GC는 재진입 할 ​​수 없으므로 가비지 콜렉션주기 동안 호출 된 종료 자 내에서 할당이 수행되어 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1ca0b5740cb0c049a4626d36738a30cd09bcf8" translate="yes" xml:space="preserve">
          <source>An new array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 동일한 요소 유형을 가진 새로운 배열 .</target>
        </trans-unit>
        <trans-unit id="b9a13417415c3a89c1b29b77e22f2e53079843b6" translate="yes" xml:space="preserve">
          <source>An object consists of:</source>
          <target state="translated">객체는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4aafa70d4d827025493d92426cb1881df221dd19" translate="yes" xml:space="preserve">
          <source>An object describing the current calling context or null if no handler is supplied.</source>
          <target state="translated">현재 호출 컨텍스트를 설명하는 객체이거나 핸들러가 제공되지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="3a620a30bdbf13210b0ac45ebfde607dd57f15dd" translate="yes" xml:space="preserve">
          <source>An object spans a sequence of memory locations which may or may not be contiguous. Its lifetime encompasses construction, destruction, and the period in between. Each object has a type which is determined either statically or by runtime type information. The object's memory locations may include any combination of thread-local, immutable, or shared.</source>
          <target state="translated">객체는 연속적 일 수도 있고 아닐 수도있는 일련의 메모리 위치에 걸쳐 있습니다. 그것의 수명은 건설, 파괴 및 그 사이의 기간을 포함합니다. 각 개체에는 정적으로 또는 런타임 유형 정보에 의해 결정되는 유형이 있습니다. 객체의 메모리 위치에는 스레드 로컬, 불변 또는 공유의 조합이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad48c285dfb60c4d3c86eb82873ee83b03c3fe1" translate="yes" xml:space="preserve">
          <source>An object's address is the address of the first byte of the first memory location for that object. Object addresses are distinct unless one object is nested within the other.</source>
          <target state="translated">객체의 주소는 해당 객체에 대한 첫 번째 메모리 위치의 첫 번째 바이트 주소입니다. 한 개체가 다른 개체 내에 중첩되지 않는 한 개체 주소는 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="5be2f170166a5ab81d9f7b1c1bbe46754996b242" translate="yes" xml:space="preserve">
          <source>An object, interface, array slice type, or associative array type.</source>
          <target state="translated">객체, 인터페이스, 배열 슬라이스 유형 또는 연관 배열 유형</target>
        </trans-unit>
        <trans-unit id="46658cef8915a535dc984d5da9a05cb48f404327" translate="yes" xml:space="preserve">
          <source>An opaque type used to represent a logical thread.</source>
          <target state="translated">논리 스레드를 나타내는 데 사용되는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ac93278e9eecd73148f8d1da8ce3975a03dbd346" translate="yes" xml:space="preserve">
          <source>An operating system handle to the process.</source>
          <target state="translated">프로세스에 대한 운영 체제 핸들</target>
        </trans-unit>
        <trans-unit id="6f1bf7d22dd547a7812632d87cd15c2924db734c" translate="yes" xml:space="preserve">
          <source>An option can be bound to a function or delegate with the signature &lt;code&gt;void function()&lt;/code&gt;, &lt;code&gt;void function(string option)&lt;/code&gt;, &lt;code&gt;void function(string option, string value)&lt;/code&gt;, or their delegate equivalents.</source>
          <target state="translated">옵션은 서명 &lt;code&gt;void function()&lt;/code&gt; , &lt;code&gt;void function(string option)&lt;/code&gt; , &lt;code&gt;void function(string option, string value)&lt;/code&gt; 을 사용하여 함수 또는 델리게이트에 바인딩 될 수 있습니다. 또는 이와 동등한 .</target>
        </trans-unit>
        <trans-unit id="2b5227e5d32ce42de170098574202aa25566b464" translate="yes" xml:space="preserve">
          <source>An option can be marked as required. If that option is not present in the arguments an exception will be thrown.</source>
          <target state="translated">옵션은 필요에 따라 표시 할 수 있습니다. 해당 옵션이 인수에 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62587f93049001b563bb61577949d667674822d9" translate="yes" xml:space="preserve">
          <source>An option to create &lt;a href=&quot;#FileLogger&quot;&gt;&lt;code&gt;FileLogger&lt;/code&gt;&lt;/a&gt; directory if it is non-existent.</source>
          <target state="translated">&lt;a href=&quot;#FileLogger&quot;&gt; &lt;code&gt;FileLogger&lt;/code&gt; &lt;/a&gt; 를 작성하는 옵션존재하지 않는 경우 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="64ee06f639f325adeda208d2447a973be665d9e1" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;header&lt;/code&gt; can be provided. The first record will be read in as the header. If &lt;code&gt;Contents&lt;/code&gt; is a struct then the header provided is expected to correspond to the fields in the struct. When &lt;code&gt;Contents&lt;/code&gt; is not a type which can contain the entire record, the &lt;code&gt;header&lt;/code&gt; must be provided in the same order as the input or an exception is thrown.</source>
          <target state="translated">선택적인 &lt;code&gt;header&lt;/code&gt; 가 제공 될 수 있습니다. 첫 번째 레코드는 헤더로 읽습니다. 경우 &lt;code&gt;Contents&lt;/code&gt; 구조체 인 다음에서 제공하는 헤더는 구조체의 필드에 해당 할 것으로 예상된다. 때 &lt;code&gt;Contents&lt;/code&gt; 의 전체 기록을 포함 할 수있는 유형이 아닌 &lt;code&gt;header&lt;/code&gt; 상기 입력과 같은 순서로 제공해야 또는 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="c541908f1a9f1491cf9b9d292e345a7480fb7a54" translate="yes" xml:space="preserve">
          <source>An optional destination buffer.</source>
          <target state="translated">선택적 대상 버퍼.</target>
        </trans-unit>
        <trans-unit id="8208436747ee5979d41650c17a37d3a20bbfe83b" translate="yes" xml:space="preserve">
          <source>An optional list of strings naming each successive field of the &lt;code&gt;Tuple&lt;/code&gt; or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by &lt;code&gt;Args&lt;/code&gt;. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 의 각 연속 필드를 명명하는 선택적 문자열 목록 또는 요소가 캐스트되는 유형 목록. 이름 목록의 경우 각 이름은 &lt;code&gt;Args&lt;/code&gt; 에서 제공 한 해당 필드와 일치합니다 . 모든 필드에 이름을 제공 할 필요는 없지만, 순서대로 진행해야하므로 한 필드를 건너 뛰고 다음 필드의 이름을 지정할 수 없습니다. 유형 목록의 경우 매개 변수만큼 유형이 정확하게 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="301d753d609aee359b108ee54a2daf0751f4373a" translate="yes" xml:space="preserve">
          <source>An optional suffix to be removed from the file name.</source>
          <target state="translated">파일 이름에서 제거 할 선택적 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="77f5c788c6482dd19248d4d066b4335ce5e940c4" translate="yes" xml:space="preserve">
          <source>An out parameter &lt;code&gt;x&lt;/code&gt; is similar to a ref parameter, except it is initialized with &lt;code&gt;x.init&lt;/code&gt; upon function invocation.</source>
          <target state="translated">out 매개 변수 &lt;code&gt;x&lt;/code&gt; 는 함수 호출시 &lt;code&gt;x.init&lt;/code&gt; 로 초기화된다는 점을 제외하면 ref 매개 변수와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="bbb578323324900d1fe9af43a6b6b06a406772b4" translate="yes" xml:space="preserve">
          <source>An output range for returning the results may be provided as the last argument. If one is not provided, an array of the proper type will be allocated on the garbage collected heap. If one is provided, it must be a random access range with assignable elements, must have reference semantics with respect to assignment to its elements, and must have the same length as the input range. Writing to adjacent elements from different threads must be safe.</source>
          <target state="translated">결과를 반환하기위한 출력 범위가 마지막 인수로 제공 될 수 있습니다. 하나를 제공하지 않으면 적절한 유형의 배열이 가비지 수집 힙에 할당됩니다. 하나가 제공되는 경우, 지정 가능한 요소가있는 임의 액세스 범위 여야하고 해당 요소에 대한 지정과 관련하여 참조 의미가 있어야하며 입력 범위와 길이가 같아야합니다. 다른 스레드에서 인접한 요소에 쓰는 것은 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="translated">수신 한 데이터를 버리는 출력 범위.</target>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="translated">내용을 쓸 출력 범위입니다.</target>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;Variant&lt;/code&gt; 은 assignment와 &lt;code&gt;hasValue&lt;/code&gt; 를 제외하고 어떤 식 으로든 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="translated">void 초기화 프로그램에서 생성 된 초기화되지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="translated">구조체가 &lt;code&gt;immutable&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 로 인스턴스화 되어도 정규화되지 않은 포스트 블릿이 호출 되지만 구조체가 &lt;code&gt;shared&lt;/code&gt; 로 인스턴스화되면 컴파일러에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="translated">인식 할 수없는 명령 행 인수가 전달되었으며 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="translated">&quot;--baz&quot;와 같은 인식 할 수없는 옵션은 &lt;code&gt;getopt&lt;/code&gt; 가 반환 된 후에 &lt;code&gt;args&lt;/code&gt; 에서 수정되지 않은 것으로 발견됩니다 .</target>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="translated">클래스 템플릿과 마찬가지로 템플릿 매개 변수 목록을 제공하여 구조체, 공용체 및 인터페이스를 템플릿으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="translated">마찬가지로 &lt;code&gt;typeof(super)&lt;/code&gt; 는 비 정적 멤버 함수에있는 &lt;code&gt;super&lt;/code&gt; 의 유형을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="translated">고대 그리스 음악 표기법</target>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="translated">고대 그리스 숫자</target>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="translated">고대의 상징</target>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="translated">그리고 표현</target>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="translated">이제 모든 요약 섹션이 녹색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="translated">그리고 C 코드에 대한 콜백을 제공하는 D 코드의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="translated">AndAnd 표현식</target>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="translated">AndAndExpression</target>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="translated">안드레이 알렉산더 스쿠</target>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="translated">Andrei Alexandrescu의 기사 범위와 개념 동기에 대한 &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt;&lt;i&gt;반복에&lt;/i&gt;&lt;/a&gt; 관한 기사 &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="translated">익명 열거 형</target>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="translated">익명의 기능 및 익명의 대리인</target>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="translated">익명의 중첩 클래스</target>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="translated">익명 대리자는 임의의 문 리터럴처럼 동작 할 수 있습니다. 예를 들어, 임의의 명령문은 루프에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="translated">하위 매처를 사용할 때의 또 다른 경고는 하위 매 처가 모든 길이를 감지하지 않기 때문에 건너 뛰기를 미리 사용할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="translated">다른 이벤트 처리 모듈</target>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="translated">정의 된 &lt;code&gt;toString&lt;/code&gt; 으로 &lt;code&gt;struct&lt;/code&gt; 를 형식화하는 또 다른 예는 이번에는 &lt;code&gt;scope delegate&lt;/code&gt; 메소드를 사용합니다 . 이 방법은 이제 비가 상 기능에는 사용하지 않는 것이 좋습니다. 가능하면 출력 범위 방법을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="translated">모든 &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LNAME&lt;/i&gt;&lt;/a&gt; 또는 비 기본 &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;유형&lt;/i&gt;&lt;/a&gt; (즉, 고정 된 하나 개 또는 두 개의 문자 시퀀스로하지 않는 인코딩 모든 종류의) 다시 방출되지 않습니다 전에 망가 기호로 배출되었지만, 상대적 위치를 코딩하는 특별한 순서에 의해 참조 맹 글링 된 심볼 이름에서 원래 발생</target>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="translated">모든 &lt;code&gt;pure&lt;/code&gt; 강하게 순수하지 않다 기능은 memoizable로 간주 될 수 있고, 호출은 반환 경우에도 생략 할 수 없습니다 &lt;code&gt;void&lt;/code&gt; (함수가 적용되지 않습니다 증명 컴파일러 최적화를위한 저장). 모든 함수에 사용할 수있는 기존의 인라인 및 최적화 기술을 통해 함수 호출을 제거하거나 결과를 메모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="translated">모든 CSV 입력</target>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="translated">모든 IPv4 호스트 주소</target>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="translated">모든 IPv4 포트 번호</target>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="translated">모든 IPv6 호스트 주소</target>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="translated">모든 IPv6 포트 번호</target>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="translated">모든 객체 유형은 키 정렬 순서로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="translated">semantic ()에 실패하거나 ErrorExp 또는 TypeError 인 구성 요소가있는 명령문은 semantic ()에서 ErrorStatement를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="translated">문법의 모든 모호성</target>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="translated">모든 원자</target>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="translated">파생 클래스 참조에 대한 클래스 참조 캐스팅은 실제로 다운 캐스트인지 확인하기 위해 런타임 확인으로 수행됩니다. 그렇지 않은 경우 결과는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="translated">기본 클래스의 클래스 불변 값은 파생 클래스의 클래스 불변 값보다 먼저 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="translated">const 선언이 참조하는 데이터는 const 선언에서 변경할 수 없지만 다른 데이터가 동일한 데이터를 참조하여 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="translated">결합 된 스레드가 처리하지 않는 예외</target>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="translated">결합 된 스레드가 처리하지 않는 예외</target>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="translated">rethrow = false 인 경우이 파이버가 처리하지 않는 예외는 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="translated">rethrow = false 인 경우이 스레드에서 처리하지 않은 예외는 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="3547b50f09fd44e299559c0d0f1b8fb00ea84d79" translate="yes" xml:space="preserve">
          <source>Any expression that resolves to either a tuple of strings or an empty tuple is accepted. When the expression resolves to an empty tuple, it is equivalent to &lt;code&gt;extern (C++)&lt;/code&gt;</source>
          <target state="translated">문자열 튜플 또는 빈 튜플로 확인되는 모든 표현식이 허용됩니다. 식이 빈 튜플로 확인되면 &lt;code&gt;extern (C++)&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="translated">CTFE에서 실행되는 모든 기능은 런타임에 실행 가능해야합니다. 함수의 컴파일 시간 평가는 런타임에 함수를 실행하는 것과 같습니다. 이는 함수의 의미가 함수의 컴파일 시간 값에 의존 할 수 없음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="translated">연관 배열의 모든 삽입, 제거 또는 조회</target>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="translated">C ++ 인터페이스에서 파생되는 모든 인터페이스도 C ++ 인터페이스입니다. C ++ 인터페이스는 다음과 같은 점에서 D 인터페이스와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="translated">중재 동기화 뮤텍스를 해제하는 것과 함께 중재 최종 절이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="translated">모든 intervening finally 절이 실행되고 모든 intervening 동기화 오브젝트가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="translated">필드의 모든 불변은 구조체 불변 전에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="translated">저작권이있는 코드에 대한 모든 라이센스 정보.</target>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="translated">모듈로 연산자 &lt;code&gt;%&lt;/code&gt; 를 지원하는 모든 숫자 유형 . 비트 시프 팅 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 도 지원되는 경우 Stein 알고리즘이 사용됩니다. 그렇지 않으면 유클리드 알고리즘이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="translated">모든 포인터는 &lt;code&gt;void*&lt;/code&gt; , &lt;code&gt;void*&lt;/code&gt; 에서 원래 유형으로 다시 캐스트 될 수 있습니다 . 포인터와 비 포인터 유형 사이의 캐스팅은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="translated">&lt;code&gt;NegInfInterval&lt;/code&gt; 을 반복하는 모든 범위 는 무한합니다. 따라서 &lt;code&gt;NegInfInterval&lt;/code&gt; 을 사용하는 주요 목적은 음의 무한대에서 시작하여 고정 된 끝점으로 이동하는 무한 범위를 만드는 것입니다. 반대로 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="translated">&lt;code&gt;PosInfInterval&lt;/code&gt; 을 반복하는 모든 범위 는 무한합니다. 따라서 &lt;code&gt;PosInfInterval&lt;/code&gt; 을 사용하는 주요 목적은 고정 된 시점에서 시작하여 양의 무한대로 진행되는 무한 범위를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="translated">일련의 문자 클래스 요소는 암시 적으로 통합을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="translated">빈 명령문을 포함하여 모든 명령문에 레이블을 지정할 수 있으므로 goto 문의 대상으로 사용할 수 있습니다. 레이블이있는 명령문은 break 또는 continue 문의 대상으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="translated">암시로 변환 모든 유형 &lt;code&gt;dchar&lt;/code&gt; . 내장형이거나 내장형의 열거 형인 경우 &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; 가 반환되는 반면, 사용자 정의 형식 인 경우 &lt;code&gt;dchar&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="translated">특정 모듈 멤버에게 'this'추가</target>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="translated">이 grapheme에 &lt;a href=&quot;#Character&quot;&gt;문자 &lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;e1&lt;/code&gt; 로 시작하는 예외 체인에 &lt;code&gt;e2&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="translated">이 요소의 내부에 CData 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="translated">이 요소의 내부에 주석을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="translated">이 요소의 내부에 완전한 요소를 추가</target>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="translated">이 요소의 내부에 처리 명령 추가</target>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="translated">이 요소의 내부에 텍스트 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="translated">입력 범위 &lt;code&gt;inp&lt;/code&gt; 의 모든 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 를이 Grapheme에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;y&lt;/code&gt; 를 배열 &lt;code&gt;x&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="translated">ptr [0..size]로 표시되는 데이터 추가</target>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="translated">내부 버퍼에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="translated">dchar를 char에 추가 []</target>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="translated">dchar를 wchar에 추가 []</target>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="translated">데이터에 dt를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="translated">데이터에 dtb를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="translated">업로드시 덮어 쓰기 대신 추가!</target>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="translated">정수 항목을 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="translated">내부 버퍼에 nbytes 0을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="translated">C의 printf () 출력을 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="translated">C의 vprintf () 출력을 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="translated">ptr을 * plist에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="translated">나중에 생성 할 객체 파일 목록에을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="translated">문자열 의 나머지 &lt;code&gt;path&lt;/code&gt; 세그먼트를 추가 하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="translated">배열 x []에 y []를 추가</target>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="translated">Appender! (E []) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A : E [], E) (자동 참조 A 배열);</target>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="translated">Appender! 어 &lt;strong id=&quot;appender&quot;&gt;펜더&lt;/strong&gt; (A) ()</target>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="translated">추가로 항상 사본이 생성되는 것은 아닙니다 . 자세한 내용 은 &lt;a href=&quot;#resize&quot;&gt;동적 배열 길이 설정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="translated">grapheme의 &lt;a href=&quot;#Character&quot;&gt;문자를&lt;/a&gt; 추가하고 직접 조작 하면 더 이상 유효하지 않을 수 있습니다. 특정 응용 프로그램은 Grapheme을 모든 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 의 &quot;작은 문자열&quot;로 사용하도록 선택 하고이 속성을 완전히 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt; 를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">관리 형 배열에 &lt;code&gt;item&lt;/code&gt; 을 추가합니다 . &lt;code&gt;A&lt;/code&gt; 가 다른 유형의 &lt;code&gt;char&lt;/code&gt; 배열 인 경우 &lt;code&gt;char&lt;/code&gt; 유형에 대한 인코딩을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="translated">관리 형 배열에 &lt;code&gt;rhs&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;c&lt;/code&gt; 에 추가합니다 . &lt;code&gt;x&lt;/code&gt; 는 단일 요소 또는 입력 범위 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="translated">문자열을 연결된 목록에 추가합니다. 목록이 없으면 먼저 작성됩니다. 추가 한 후 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">전체 범위를 관리 형 배열에 추가합니다. &lt;code&gt;A&lt;/code&gt; 가 다른 유형의 &lt;code&gt;char&lt;/code&gt; 배열 인 경우 &lt;code&gt;char&lt;/code&gt; 요소에 대한 인코딩을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">인수의 내용에 추가 &lt;code&gt;rhs&lt;/code&gt; 로 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="translated">관리 형 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="translated">AppleTalk</target>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="translated">응용 프로그램 이진 인터페이스</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시.</target>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="translated">보류 유형에 따라 지정된 &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; 에 델리게이트 또는 함수를 적용하여 모든 유형이 방문 함수에 의해 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="translated">기존 유형에 MODxxxx 비트를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="translated">기존 유형에 STCxxxx 비트를 적용하십시오. 시맨틱 분석이 실행되기 전에 * 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="translated">리스트의 각 멤버에 함수 fp를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="translated">이미 규정이 법적 가지고 있지만 적정 유형 주어진 예에는 영향을주지 않습니다 유형에 규정을 적용 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;shared(const shared T)&lt;/code&gt; 유형의 산출 &lt;code&gt;const shared T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 한정자를 임의의 유형 (적격 또는 불완전한)에 적용하면 &lt;code&gt;immutable T&lt;/code&gt; 됩니다. 어떤 규정 적용 &lt;code&gt;immutable T&lt;/code&gt; 결과 &lt;code&gt;immutable T&lt;/code&gt; . 이것은 &lt;code&gt;immutable&lt;/code&gt; 을 한정자 한정자 조합 포인트로 만들고 &lt;code&gt;const(immutable(shared T))&lt;/code&gt; 와 같은 유형 을 만들 수 없게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="translated">아랍어 확장 -A</target>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="translated">아랍어 수학 알파벳 기호</target>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="translated">아랍어 프리젠 테이션 양식 -A</target>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="translated">아랍어 프리젠 테이션 양식 -B</target>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="translated">아랍어 보충</target>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">임의의 메모리 블록 ( &lt;code&gt;null&lt;/code&gt; 허용, &lt;code&gt;owns(null)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 반환 )</target>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="translated">lookahind와 lookse의 lookahead를 포함하여 임의의 길이와 복잡성 lookbehind.</target>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="translated">임의 정밀도 ( 'bignum') 산술.</target>
        </trans-unit>
        <trans-unit id="04a64131d2f2d9afe00e52e932f2410778390372" translate="yes" xml:space="preserve">
          <source>ArchiveMember &lt;code&gt;de&lt;/code&gt;</source>
          <target state="translated">ArchiveMember &lt;code&gt;de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="translated">MMX에 대한 AMD 확장이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="translated">LAHF 및 SAHF는 64 비트 모드에서 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="translated">객체에 오류가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">Args &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="translated">인수 공제</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="translated">xInit () 및 xShutdown ()에 대한 인수</target>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="translated">ArgumentList</target>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 생성자 에 전달할 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="translated">메소드에 전달할 인수입니다.</target>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="translated">기능에 대한 주장.</target>
        </trans-unit>
        <trans-unit id="cd64cf49b3ec9934a802f3e5622e652b8742e909" translate="yes" xml:space="preserve">
          <source>Arguments to variadic functions (such as &lt;code&gt;printf&lt;/code&gt;) are considered to be consumed.</source>
          <target state="translated">가변 함수에 대한 인수 (예 : &lt;code&gt;printf&lt;/code&gt; )는 소비 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 객체와 숫자 값 사이의 산술 . 모든 산술 연산 은 관련된 두 값의 유형에 따라 유형이 지정된 &lt;code&gt;VariantN&lt;/code&gt; 객체를 반환합니다 . 변환 규칙은 산술 변환에 대한 D의 기본 제공 규칙을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">배열 &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (문자열 op, 물건) (스터프 물건)</target>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="translated">배열 바운드 확인</target>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="translated">배열 연결</target>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="translated">배열 복사</target>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="translated">배열 선언</target>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="translated">배열 인덱스 / 슬라이스 범위</target>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="translated">배열 인덱싱 및 슬라이싱 연산자 오버로드</target>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="translated">배열 초기화</target>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="translated">배열 길이</target>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="translated">배열 연산</target>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="translated">배열 속성</target>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="translated">배열 설정</target>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="translated">배열 사용법</target>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="translated">배열 및 연관 배열 연산. &lt;code&gt; VariantN&lt;/code&gt; 에 (연관) 배열이 포함되어 있으면 이를 인덱스 할 수 있습니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="translated">배열 추가</target>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="translated">배열 바운드 검사.</target>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="translated">배열 경계 검사가 비활성화됩니다 (명령 줄 스위치 &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck = off&lt;/em&gt;&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="translated">메모리 안전을 강화하려면 배열 범위 검사가 필요하므로 &lt;b&gt;릴리스&lt;/b&gt; 모드 에서도 &lt;code&gt;@safe&lt;/code&gt; 코드에 대해 기본적으로 활성화 됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="translated">배열 연결</target>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="translated">내부 용 배열 컨테이너.</target>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="translated">연결할 배열을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">배열 리터럴은 GC 힙에 할당됩니다. 힙으로 이동하여 이스케이프가 없는지 요소를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="translated">배열 리터럴 (정적 데이터를 초기화하는 데 사용되는 경우 제외)</target>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="translated">배열 리터럴은 대괄호 &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이에 쉼표로 구분 된 &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 목록입니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="translated">배열 리터럴은 메모리 관리 힙에 할당됩니다. 따라서 함수에서 안전하게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="translated">매개 변수에 대한 VarDeclaration의 배열</target>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="translated">읽은 문자 배열.</target>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="translated">집계에서 각 멤버에 대한 오프셋 및 유형 정보를 제공하는 쌍의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">가장 작은 단위부터 시작하여 가장 큰 단위까지 시간 단위를 나타내는 문자열 배열입니다. &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 는 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="translated">배열 옵션.</target>
        </trans-unit>
        <trans-unit id="fecbe8e577ceb3d414c1005061daf3736c402d86" translate="yes" xml:space="preserve">
          <source>Array representing the entire archive.</source>
          <target state="translated">전체 아카이브를 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="268c73e26ed36171acb2987f7e489853cedee3f4" translate="yes" xml:space="preserve">
          <source>Array representing the entire contents of the archive.</source>
          <target state="translated">아카이브의 전체 내용을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="translated">배열 슬라이싱 및 배열 범위 검사</target>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 전용 배열입니다 . 요소 당 하나의 비트를 할당하여 값을 효율적으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="translated">json 배열의 배열 구문.</target>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="translated">플래그를 추가 할 배열입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="translated">바이너리 (공유 / 정적 라이브러리 및 객체 파일)가 추가 될 배열</target>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="translated">메모리를 결정적으로 제어하는 ​​어레이 유형. 어레이에 할당 된 메모리는 가능한 빨리 회수됩니다. 가비지 수집기에 의존하지 않습니다. &lt;code&gt;Array&lt;/code&gt; 는 &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;realloc&lt;/code&gt; 및 &lt;code&gt;free&lt;/code&gt; 를 사용하여 자체 메모리를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">어레이 유틸리티.</target>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="translated">소켓 주소 당 하나의 &lt;code&gt;Address&lt;/code&gt; 인스턴스가있는 배열 .</target>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="translated">소켓 주소 당 하나의 &lt;code&gt;AddressInfo&lt;/code&gt; 가있는 배열 .</target>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">배열! T &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">Array! &lt;strong id=&quot;opBinary&quot;&gt;Bool opBinary&lt;/strong&gt; (스트링 op, Stuff) (Stuff &lt;strong id=&quot;opBinary&quot;&gt;RMS&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">배열! bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (문자열 op, 물건) (스터프 물건)</target>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="translated">ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="translated">ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt; (UnionExp * pue, ref const Loc loc, Type type, Expression elem, size_t dim);</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="translated">배열 (동적 및 정적)</target>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="translated">배열과 정적 배열</target>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="translated">모든 유형의 배열은 암시 적으로 void 배열로 변환 될 수 있습니다. 컴파일러 는 결과 배열 크기 의 &lt;code&gt;.length&lt;/code&gt; 가 요소 수가 아닌 바이트로 되도록 적절한 계산을 삽입합니다 . 무효 배열은 캐스트를 사용하지 않고 원래 형식으로 다시 변환 할 수 없으며, 요소 크기가 공백 배열의 길이를 균등하게 나누지 않는 배열 형식으로 변환하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="translated">배열도 오른쪽에서 왼쪽으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="translated">같이 &lt;code&gt;static foreach&lt;/code&gt; 코드 생성 구조체 아닌 루프이다 &lt;code&gt;break&lt;/code&gt; 하고 &lt;code&gt;continue&lt;/code&gt; 그 안에서 변경 제어 플로우에 사용될 수 없다. 적절한 둘러싸는 문장을 깨거나 계속하는 대신, 그러한 사용법으로 오류가 발생합니다 (오해를 방지하기위한 것임).</target>
        </trans-unit>
        <trans-unit id="8fe64c824a70f2fd7f91ffe1f685564777c5e63c" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;scope&lt;/code&gt; parameter must not escape, the compiler can potentially avoid heap-allocating a unique argument to a &lt;code&gt;scope&lt;/code&gt; parameter. Due to this, passing an array literal, delegate literal or a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; to a scope parameter may be allowed in a &lt;code&gt;@nogc&lt;/code&gt; context, depending on the compiler implementation.</source>
          <target state="translated">A와 &lt;code&gt;scope&lt;/code&gt; 매개 변수가 탈출하지 않아야합니다, 컴파일러는 잠재적으로 힙 - 할당 피할 수에 고유 한 인수 &lt;code&gt;scope&lt;/code&gt; 매개 변수를. 이로 인해 컴파일러 구현에 따라 &lt;code&gt;@nogc&lt;/code&gt; 컨텍스트 에서 배열 리터럴, 델리게이트 리터럴 또는 &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; 을 범위 매개 변수에 전달하는 것이 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="translated">실용성의 양보로서, 순수한 기능은 또한</target>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="translated">계약으로서, &lt;code&gt;assert&lt;/code&gt; 는 코드가</target>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">디버깅을 돕기 위해 컴파일러는 런타임 검사를 삽입하여 표현식이 실제로 참인지 확인할 수 있습니다. False이면 &lt;code&gt;AssertError&lt;/code&gt; 가 발생합니다. 릴리스를 위해 컴파일 할 때는이 검사가 생성되지 않습니다. 그러나 특수 &lt;code&gt;assert(0)&lt;/code&gt; 표현식은 릴리스 모드에서도 생성됩니다. 자세한 내용은 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; 최적화 또는 클로저 생성과 관련된 힙 할당을 피하기위한 미세 최적화 .</target>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">위와 같이 &lt;code&gt;back&lt;/code&gt; 과 &lt;code&gt;popBack&lt;/code&gt; 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">위와 같지만 나중에 재 할당 될 수 있습니다. 이 설명에 맞는 유형의 예는 &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt;double[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt; 이지만 &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="translated">위와 같지만 간접적으로 포함 할 수 있습니다. 이 설명에 적합한 유형의 예는 &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Object[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="translated">위와 같이 할당 된 메모리 &lt;code&gt;a&lt;/code&gt; 바이트 단위 로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">위와 같이 유형이 추후에 추가 될 수 있습니다. 예 : &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="translated">위와 같이 형식에 참조가 포함될 수 있습니다. 예 : &lt;code&gt;immutable(Object)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="translated">위의 예외로 curl_off_t는 64 비트 유형이없는 경우 32 비트 너비의 부호있는 정수 데이터 유형으로 typedef됩니다.</target>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="translated">범위를 복사한다는 것은 모든 요소를 ​​복사하는 것을 의미하므로 함수에서 안전하게 반환 할 수 있습니다. 같은 이유로 반환 된 범위를 복사하면 많은 인수에 대해 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="translated">대상 범위 요소가 소스 범위 요소에서의 할당을 지원하는 한 다른 유형의 범위가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="translated">현재 &lt;code&gt;std.experimental.allocator&lt;/code&gt; 는 &lt;code&gt;new&lt;/code&gt; , 배열 리터럴 또는 배열 연결 연산자 와 같이 메모리를 할당하는 D의 내장 연산자와 통합되어 있지 않습니다 . 이는 &lt;code&gt;std.experimental.allocator&lt;/code&gt; 가 옵트 인 되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7b1738337554a47ddb128a4a9aaf14cc6fec9d90" translate="yes" xml:space="preserve">
          <source>As some GC implementations (such as the current conservative one) don't support GC memory allocation during object finalization, this function can be used to guard against such programming errors.</source>
          <target state="translated">일부 GC 구현 (예 : 현재 보수적 인 구현)은 객체 종료 중에 GC 메모리 할당을 지원하지 않으므로이 함수를 사용하여 이러한 프로그래밍 오류를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="translated">위의 예에서 보듯이, 다른 컴파일시 인수가 전달됩니다 &lt;code&gt;opDollar&lt;/code&gt; 가에 표시되는 인수에 따라 다릅니다. &lt;code&gt;$&lt;/code&gt; 는 첫 번째 인수에 나타나는이로 번역됩니다 &lt;code&gt;opDollar!0&lt;/code&gt; A, &lt;code&gt;$&lt;/code&gt; 두 번째 인수에 나타나는이로 번역됩니다 &lt;code&gt;opDollar!1&lt;/code&gt; 등. 따라서 다차원 배열을 구현하기 위해 &lt;code&gt;$&lt;/code&gt; 에 적절한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">간격이 음의 무한대가되면 범위는 항상 뒤로 거꾸로 반복되고 앞으로는 반복되지 않습니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행하는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 &lt;code&gt;func&lt;/code&gt; 이 생성하는 시점은 전달 된 시점보다 빨라야합니다. 동일하거나 이후의 경우 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">구간이 양의 무한대로 진행됨에 따라 범위는 항상 앞뒤로 반복되지 않으며 뒤로는 반복되지 않습니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행하는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 &lt;code&gt;func&lt;/code&gt; 이 생성하는 시점은 전달 된 시점보다 늦어 야합니다. 동일하거나 이전의 시간이면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80d4a16f3b080b8168646190c746d43efc570fe1" translate="yes" xml:space="preserve">
          <source>As this module is used for diagnostic, it should handle failures as gracefully as possible. Having the runtime error out on printing the stack trace one is trying to debug would be quite a terrible UX. For this reason, this module works on a &quot;best effort&quot; basis and will sometimes print mangled symbols, or &quot;???&quot; when it cannot do anything more useful.</source>
          <target state="translated">이 모듈은 진단에 사용되기 때문에 가능한 한 정상적으로 오류를 처리해야합니다. 디버깅하려는 스택 추적을 인쇄 할 때 런타임 오류가 발생하면 끔찍한 UX가됩니다. 이러한 이유로이 모듈은 &quot;최선의 노력&quot;을 바탕으로 작동하며 때때로 엉켜 진 기호 또는 &quot;???&quot;를 인쇄합니다. 더 유용한 것을 할 수 없을 때.</target>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="translated">코드를 생성 할 때 필요한 NT 예외 처리 부분에 대한 정보를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="translated">&lt;a href=&quot;#lists&quot;&gt;list&lt;/a&gt; 와 마찬가지로 위의 예제에서 초기 &lt;code&gt;*&lt;/code&gt; 는 별표로 구분 된 설명서 주석의 일부이므로 제거되므로 별표 3 개 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="translated">&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 두 가지 오버로드가 있습니다. 하나는 형식 문자열이고 다른 하나는 사용자 정의 functor입니다.</target>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="translated">모든 글로벌 자원과 마찬가지로 &lt;code&gt;theAllocator&lt;/code&gt; 및 &lt;code&gt;processAllocator&lt;/code&gt; 설정을 자주 수행하지 않아야합니다. 특히, 하나의 할당 자와 함께 메모리를 할당하고 다른 할당 자와 함께 할당을 해제하면 정의되지 않은 동작이 발생합니다. 일반적으로 이러한 변수는 응용 프로그램 초기화 단계에서 설정되고 응용 프로그램을 통해 마지막에 설정됩니다. 이를 피하기 위해 할당, 재 할당 및 할당 해제를 상대적으로 수행해야하는 수명이 긴 객체는 수명 기간 동안 사용하는 할당 자 객체에 대한 참조를 저장하는 것이 좋습니다. 그런 다음 내부 할당 관련 작업에 &lt;code&gt;theAllocator&lt;/code&gt; 를 사용하는 대신 내부적으로 보유 된 참조를 사용합니다. 예를 들어, 사용자 정의 해시 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="translated">curl에 fd_set 세트를 요청하십시오. 앱은이를 사용하여 select () 또는 poll ()을 켤 수 있습니다. curl_multi_perform () 중 하나가 준비 되 자마자 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="translated">개별 전송에서 메시지 / 정보가 있는지 멀티 핸들에 문의하십시오. 메시지에는 전송 오류 코드 또는 전송 완료 사실과 같은 정보가 포함됩니다. 이것들에 대한 자세한 내용도 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="translated">Asm 명세서</target>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="translated">asm 명령</target>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="translated">Asm 명령어는 줄 끝이 아닌;로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">Asm 진술</target>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="translated">AsmStatement</target>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="translated">모든 요소를 ​​현장에서 운반 할 수있는 범위로 &lt;code&gt;values&lt;/code&gt; 을 조립 합니다 .</target>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="translated">어셈블러 명령어는 다른 명령문과 같이 레이블을 지정할 수 있습니다. 그들은 goto 문의 대상이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="translated">어셈블러 명령어는 &lt;code&gt;asm&lt;/code&gt; 블록 안에 있어야합니다 . 함수와 마찬가지로 &lt;code&gt;asm&lt;/code&gt; 문은 호출자와 호환되도록 적절한 함수 속성으로 주석을 달아야합니다. Asm 문 속성은 명시 적으로 정의되어야하며 추론되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="translated">자신의 할당자를 조립</target>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="translated">계약서</target>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="translated">어설 션 식</target>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="translated">실패 주장</target>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="translated">검사를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="translated">GLIBC 라이브러리에서 실패 함수를 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="translated">AssertExpression</target>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="translated">AssertExpressions</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주어진 조건이 &lt;code&gt;true&lt;/code&gt; 이라고 주장 합니다 .</target>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="translated">주어진 표현이</target>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="translated">주어진 표현식이 주어진 유형의 &lt;code&gt;Throwable&lt;/code&gt; 을 던지도록합니다 . &lt;code&gt;Throwable&lt;/code&gt; 잡힌 및 assertThrown을 탈출하지 않습니다. 그러나, 다른 &lt;code&gt;Throwable&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="translated">식 할당</target>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="translated">현재 스레드의 인스턴스에 값을 지정하십시오. 이 기능은 과부하와 동일한 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="translated">AssignExpression</target>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="translated">범위의 각 요소에 할당</target>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="translated">대입 연산자 식</target>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="translated">할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;Tuple&lt;/code&gt; 에서 할당 .</target>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="translated">다른 BigInt에서 할당.</target>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="translated">내장 정수 유형에서 지정.</target>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="translated">할당 도우미 기능</target>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="translated">할당 연산자. 생성자와 동일한 제약 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 할당 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="translated">에 할당 &lt;code&gt;this&lt;/code&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="translated">컨테이너의 첫 번째 요소에 &lt;code&gt;v&lt;/code&gt; 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="translated">컨테이너의 마지막 요소에 &lt;code&gt;v&lt;/code&gt; 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">입력 범위 &lt;code&gt;range&lt;/code&gt; 의 각 요소에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 . 할당이 성공하면, &lt;code&gt;this&lt;/code&gt; null이 아닌이된다.</target>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="translated">내부 보류 상태에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 . 할당이 성공하면, &lt;code&gt;this&lt;/code&gt; null이 아닌이된다. 널 검사가 수행되지 않습니다. 할당은 &lt;code&gt;this&lt;/code&gt; null 상태로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="translated">일반 인수에서 &lt;code&gt;VariantN&lt;/code&gt; 을 할당합니다 . 허용되지 않는 유형을 정적으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="translated">파일을 다른 파일에 할당합니다. 할당 대상은 첨부 된 파일에서 분리되어 새 파일에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="translated">제공된 op를 실행하기 위해 논리 스레드를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="translated">주어진 &lt;code&gt;name&lt;/code&gt; 가진 환경 변수에 주어진 &lt;code&gt;value&lt;/code&gt; 을 할당합니다 . 경우 &lt;code&gt;value&lt;/code&gt; 널 변수는 환경으로부터 제거된다.</target>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="translated">합성 범위에서 &lt;code&gt;n&lt;/code&gt; 번째 요소에 할당합니다 . 모든 범위가 임의 액세스를 제공하는지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="translated">AssocArrayLiteral</target>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="translated">로컬 주소를이 소켓과 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="translated">프로세스 로컬 맵에서 이름을 tid와 연관시킵니다. tid로 표시되는 스레드가 종료되면 이와 관련된 모든 이름이 자동으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="translated">이름을 tid와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="33ed59cb9cc5ad4f51c71cb705b6c66305c4ea95" translate="yes" xml:space="preserve">
          <source>Associative Array Example: counting Tuples</source>
          <target state="translated">연관 배열 예 : 튜플 계산</target>
        </trans-unit>
        <trans-unit id="66110798d937132b8b4c69b6c86f490e42147357" translate="yes" xml:space="preserve">
          <source>Associative Array Example: word count</source>
          <target state="translated">연관 배열 예 : 단어 수</target>
        </trans-unit>
        <trans-unit id="62a00c8d718bd407e11a04d361c97fd9304d9228" translate="yes" xml:space="preserve">
          <source>Associative Array Literals</source>
          <target state="translated">연관 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="8cd02aabb1cb92301b44ecacb4a3476fbc048ed6" translate="yes" xml:space="preserve">
          <source>Associative Array Properties</source>
          <target state="translated">연관 배열 속성</target>
        </trans-unit>
        <trans-unit id="ac6bb05c1566d531b5e617bff01417f7eeacaa8d" translate="yes" xml:space="preserve">
          <source>Associative Arrays</source>
          <target state="translated">연관 배열</target>
        </trans-unit>
        <trans-unit id="eac66f094196ab59907d539af93b0f79d61ccbc4" translate="yes" xml:space="preserve">
          <source>Associative array indexed by the name of each member of the archive.</source>
          <target state="translated">아카이브의 각 구성원 이름으로 인덱싱 된 연관 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b6a88997c71f98db7849444ee105aa1b9e104461" translate="yes" xml:space="preserve">
          <source>Associative array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">연관 배열 리터럴이 GC 힙에 할당됩니다. 힙으로 이동하여 이스케이프가 있는지 확인하려면 해당 요소를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2cdd3f26aaf9ed2ca50e34f9cba8cec0e214e787" translate="yes" xml:space="preserve">
          <source>Associative array literals</source>
          <target state="translated">연관 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="aa59b9862478a41dd5f1d43314d8d4fd2f36cfac" translate="yes" xml:space="preserve">
          <source>Associative array literals are a comma-separated list of</source>
          <target state="translated">연관 배열 리터럴은 쉼표로 구분 된</target>
        </trans-unit>
        <trans-unit id="f1464f4beecb9ccd1b6cd79f0d3fdebe26677ef6" translate="yes" xml:space="preserve">
          <source>Associative array of attributes</source>
          <target state="translated">속성의 연관 배열</target>
        </trans-unit>
        <trans-unit id="b87ce9bf0d9a5c06c6d7bc4fc73a4cd816351837" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">연관 배열을 문자열로 변환합니다. 각 요소는 &lt;code&gt;to!T&lt;/code&gt; 를 호출 하여 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c3256b0ab3483fa8604ecf1ce16a782f56f85d2" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is printed by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">연관 배열을 문자열로 변환 각 요소는 &lt;code&gt;to!T&lt;/code&gt; 를 호출 하여 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="6eed25868a22de24520441116395f69e925a6704" translate="yes" xml:space="preserve">
          <source>Associative array with all archive members.</source>
          <target state="translated">모든 아카이브 멤버가있는 연관 배열.</target>
        </trans-unit>
        <trans-unit id="a0cf74a282aed4f93bc7369a99f5541139720753" translate="yes" xml:space="preserve">
          <source>Associative arrays</source>
          <target state="translated">연관 배열</target>
        </trans-unit>
        <trans-unit id="b7b195035b64b57f923bdef12ca24604e56d713e" translate="yes" xml:space="preserve">
          <source>Associative arrays are declared by placing the</source>
          <target state="translated">연관 배열은</target>
        </trans-unit>
        <trans-unit id="e2e6b379c645fab1d146e1f88662672372565c42" translate="yes" xml:space="preserve">
          <source>Associative arrays are formatted by using &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;&quot;, &quot;&lt;/code&gt; as separators, and enclosed by &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;.</source>
          <target state="translated">연관 배열은 &lt;code&gt;':'&lt;/code&gt; 및 &lt;code&gt;&quot;, &quot;&lt;/code&gt; 를 구분 기호로 사용하고 &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; 로 묶어 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="578b6958d55efc32eb2164f95c40c985b159a3d3" translate="yes" xml:space="preserve">
          <source>Associative arrays are initialized to having 0 elements.</source>
          <target state="translated">연관 배열은 0 개의 요소를 갖도록 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="1f9ac76e68b33aa5367eaec796765ac41035935d" translate="yes" xml:space="preserve">
          <source>Associative arrays are returned in EAX.</source>
          <target state="translated">연관 배열은 EAX로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca5da5a3d3a14509f014f2f90e91f3a2f1bc8b9" translate="yes" xml:space="preserve">
          <source>Associative arrays consist of a pointer to an opaque, implementation defined type.</source>
          <target state="translated">연관 배열은 불투명 한 구현 정의 유형에 대한 포인터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4b7aaeec3338d91fc185c073ff6aea7f4aaaf1d1" translate="yes" xml:space="preserve">
          <source>Associative arrays have an index that is not necessarily an integer, and can be sparsely populated. The index for an associative array is called the</source>
          <target state="translated">연관 배열에는 반드시 정수일 필요는 없으며 드물게 채워질 수있는 인덱스가 있습니다. 연관 배열의 색인을</target>
        </trans-unit>
        <trans-unit id="24b2b993b7d8aa8b139deca02db3001c61ba8f93" translate="yes" xml:space="preserve">
          <source>Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r.</source>
          <target state="translated">연관 배열에는 고유 키가 있습니다. r에 중복 키가 있으면 결과에는 r의 해당 키에 대한 마지막 쌍의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7140c60dcf97eae1fd241925dc294e9b664ccf47" translate="yes" xml:space="preserve">
          <source>Associativity and Commutativity</source>
          <target state="translated">연관성 및 전이성</target>
        </trans-unit>
        <trans-unit id="d4afb493c09c81bc22adc7df22495a98eac06f94" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt;. Then &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; leaves &lt;code&gt;a&lt;/code&gt; unchanged and returns &lt;code&gt;false&lt;/code&gt;, whereas &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to refer to &lt;code&gt;&quot;ah&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = &quot;blah&quot;&lt;/code&gt; 가정하십시오 . 그런 다음 &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; 잎 변경 및 반환 &lt;code&gt;false&lt;/code&gt; 하는 반면, &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; 진보 &lt;code&gt;a&lt;/code&gt; 참조하는 &lt;code&gt;&quot;ah&quot;&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c94a2c42cde8321b948dff42533f346ec9014aea" translate="yes" xml:space="preserve">
          <source>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with.</source>
          <target state="translated">이 배열에 추가하는 것이 안전하다고 가정하십시오. 이 함수를 호출 한 후이 배열에 추가하면 배열이 더 큰 배열의 슬라이스 인 경우에도 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3954f2a28b82752323144cbb88151e77e6d01da9" translate="yes" xml:space="preserve">
          <source>Assume the given array of integers &lt;code&gt;arr&lt;/code&gt; is a well-formed UTF string and return it typed as a UTF string.</source>
          <target state="translated">주어진 정수 배열 &lt;code&gt;arr&lt;/code&gt; 이 올바른 형식의 UTF 문자열 이라고 가정하고 UTF 문자열로 입력하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51fef9f691908f559d18676822c2b16e9811cadf" translate="yes" xml:space="preserve">
          <source>Assume, that the range is sorted without checking.</source>
          <target state="translated">범위가 확인하지 않고 정렬되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d46abda9a40531b5c7ab25b4f982669308c54d50" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가정합니다 &lt;code&gt;r&lt;/code&gt; 술어에 의해 정렬됩니다 &lt;code&gt;pred&lt;/code&gt; 반환 해당 &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; 을 갖는 &lt;code&gt;r&lt;/code&gt; 지원 등을. 비용 &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ) 에서 정렬 성을 확인하려면 &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="24e62b25f8e7aaa35a775d4bc9ee591164888166" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To keep the checking costs low, the cost is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of &lt;code&gt;r&lt;/code&gt; are checked for sorted-ness. The size of the sample is proportional &amp;Omicron;(&lt;code&gt;log(r.length)&lt;/code&gt;). That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가정합니다 &lt;code&gt;r&lt;/code&gt; 술어에 의해 정렬됩니다 &lt;code&gt;pred&lt;/code&gt; 반환 해당 &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; 을 갖는 &lt;code&gt;r&lt;/code&gt; 지원 등을. 점검 비용을 낮게 유지하기 위해 비용은 릴리스 모드에서 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; )입니다 (정렬에 대한 점검은 수행되지 않음). 디버그 모드에서 &lt;code&gt;r&lt;/code&gt; 의 몇 가지 임의 요소가 정렬되어 있는지 확인합니다. 표본의 크기는 비례 &amp;Omicron; ( &lt;code&gt;log(r.length)&lt;/code&gt; )입니다. 이렇게하면 검사는 정렬 된 범위 (이진 검색 등)와 관련된 후속 작업의 복잡성에 영향을 미치지 않습니다. 임의의 정렬되지 않은 범위가 테스트에 실패 할 확률은 매우 높습니다 (그러나 거의 정렬 된 범위가 통과 할 가능성이 높습니다). 비용 &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; 에서 정렬 성을 확인하려면) 인 경우 &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f92de52d34809fb9f9b5a422d22d2bd3f403b63b" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;T&lt;/code&gt; is an unqualified type, the graph below illustrates how qualifiers combine (combinations with &lt;code&gt;immutable&lt;/code&gt; are omitted). For each node, applying the qualifier labeling the edge leads to the resulting type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 규정되지 않은 유형 이라고 가정하면 아래 그래프는 규정자가 결합되는 방법을 보여줍니다 ( &lt;code&gt;immutable&lt;/code&gt; 조합 은 생략 됨). 각 노드에 대해 가장자리를 표시하는 한정자를 적용하면 결과 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="317581a22ccf8624556bdb31509c5c5a51feef3f" translate="yes" xml:space="preserve">
          <source>Assuming that pages are laid out consequently in one array at &lt;code&gt;pages&lt;/code&gt;, the pseudo-code is:</source>
          <target state="translated">페이지가 결과적으로 &lt;code&gt;pages&lt;/code&gt; 의 한 배열에 배치된다고 가정하면 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bfdbbc84ee0d35091e2296c00a0a25e1c9d7c15" translate="yes" xml:space="preserve">
          <source>Assuming the file was at /example/test.d, this will output:</source>
          <target state="translated">파일이 /example/test.d에 있다고 가정하면 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4ade9724e5f6c8aea4d40d9c22982099c0a42498" translate="yes" xml:space="preserve">
          <source>Assuming the reverse meaning (i.e. &quot;ignoreTerminator&quot;) and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of &lt;code&gt;Flag&lt;/code&gt;, code calling &lt;code&gt;getLine&lt;/code&gt; can be easily read and understood even by people not fluent with the API:</source>
          <target state="translated">반대 의미 (예 : &quot;ignoreTerminator&quot;)를 가정하고 잘못된 코드를 삽입하면 잘못된 결과로 컴파일되고 실행됩니다. 부울 매개 변수를 &lt;code&gt;Flag&lt;/code&gt; 인스턴스화로 대체 한 후 API에 익숙하지 않은 사람들도 &lt;code&gt;getLine&lt;/code&gt; 을 호출하는 코드를 쉽게 읽고 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="875a558108f6180c117cd2a9851fbd31bf1ad357" translate="yes" xml:space="preserve">
          <source>At Least Alias</source>
          <target state="translated">최소한 별명으로</target>
        </trans-unit>
        <trans-unit id="319fc7f766d3014146f622cd42e082b9d29acc59" translate="yes" xml:space="preserve">
          <source>At any point in the program, for each memory object, there is exactly one live mutable pointer to it or all the live pointers to it are read-only.</source>
          <target state="translated">프로그램의 어느 지점에서나 각 메모리 객체에 대해 정확히 하나의 라이브 가변 포인터가 있거나 모든 라이브 포인터가 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="6a5e7ce73794fbffd33597afe29e6656f7606b48" translate="yes" xml:space="preserve">
          <source>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</source>
          <target state="translated">함수에 인라인 어셈블러 코드가 포함되어 있지 않은 한 함수가 void가 아닌 리턴 유형을 지정하는 경우 하나 이상의 return 문, throw 문 또는 assert (0) 표현식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="90d61c89ed43af9a321f3f7948cd37fb3078855e" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. &lt;code&gt;Zip&lt;/code&gt; offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, &lt;code&gt;Zip&lt;/code&gt; is extremely powerful because it allows manipulating several ranges in lockstep.</source>
          <target state="translated">최소한 입력 범위. &lt;code&gt;Zip&lt;/code&gt; 은 모든 구성 요소 중 가장 낮은 범위의 기능을 제공합니다. 예를 들어 모든 범위가 임의 액세스를 제공하는 경우 임의 액세스를 제공하고 모든 범위가 제공하는 경우 돌연변이 및 스와핑도 제공합니다. 이로 인해 &lt;code&gt;Zip&lt;/code&gt; 은 잠금 범위에서 여러 범위를 조작 할 수 있기 때문에 매우 강력합니다.</target>
        </trans-unit>
        <trans-unit id="bf82744118a56dc50e99bed95e0674d739012373" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. All other range primitives are given in the resulting range if &lt;code&gt;range&lt;/code&gt; has them. The exceptions are the bidirectional primitives, which are propagated only if &lt;code&gt;range&lt;/code&gt; has length.</source>
          <target state="translated">최소한 입력 범위. &lt;code&gt;range&lt;/code&gt; 가있는 경우 다른 모든 범위 기본 요소는 결과 범위에 제공됩니다 . &lt;code&gt;range&lt;/code&gt; 가 길이를 갖는 경우에만 전파되는 양방향 프리미티브는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="e9641b92bdebc39e62f8119a95b586fda5bb953c" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. If the range offers random access and &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt; offers them as well.</source>
          <target state="translated">최소한 입력 범위. 범위 제공 랜덤 액세스 및 경우 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;take&lt;/code&gt; 이벤트 그뿐만 아니라입니다.</target>
        </trans-unit>
        <trans-unit id="b4f8bcff8fd004d35539b31be3e23eec00e83071" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of &lt;code&gt;rr&lt;/code&gt; provides them.</source>
          <target state="translated">최소한 입력 범위. &lt;code&gt;rr&lt;/code&gt; 의 요소 유형이 제공하는 경우 양방향성 및 임의 액세스와 같은 범위 기본 요소가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ab81f7243697f45d24e88eac476807c5bafc54c5" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">최소한 입력 범위. &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 결과 범위는 기본 범위의 범위 프리미티브를 채택 합니다 .</target>
        </trans-unit>
        <trans-unit id="13e0cdc536d3ebf98a18c0bc6152dede0a930dcf" translate="yes" xml:space="preserve">
          <source>At offset index into buffer, create nbytes of space by shifting upwards all data past index.</source>
          <target state="translated">버퍼로의 오프셋 인덱스에서 인덱스를지나 모든 데이터를 위로 이동하여 nbytes의 공간을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1427d1990cebaf6b24e9781e5fa4c566cf53ece6" translate="yes" xml:space="preserve">
          <source>At present, C++ exceptions cannot be caught in or thrown from D, and D exceptions cannot be caught in or thrown from C++. Additionally, objects in C++ stack frames are not guaranteed to be destroyed when unwinding the stack due to a D exception, and vice versa.</source>
          <target state="translated">현재 C ++ 예외는 D에서 포착하거나 던질 수 없으며 D 예외는 C ++에서 포착되거나 던질 수 없습니다. 또한 D 예외로 인해 스택을 풀 때 C ++ 스택 프레임의 객체가 소멸되지 않을 수 있으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8d76f9b99e41b5780a5b8aa58882552e760fb6a3" translate="yes" xml:space="preserve">
          <source>Atomically adds &lt;code&gt;mod&lt;/code&gt; to the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 이 참조하는 값에 원자 적으로 &lt;code&gt;mod&lt;/code&gt; 를 추가 하고 이전에 보유한 &lt;code&gt;val&lt;/code&gt; 값을 반환합니다 . 이 작업은 잠금이없고 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="79117be4a561837c4e341dc958c03f4b3575dace" translate="yes" xml:space="preserve">
          <source>Atomically increment the current count by one. This will notify one waiter, if there are any in the queue.</source>
          <target state="translated">현재 카운트를 하나씩 증가시킵니다. 대기열에 대기자가있는 경우 한 명의 웨이터에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="0e72ffed036979247fd717525ebb223918c99bbc" translate="yes" xml:space="preserve">
          <source>Atomically subtracts &lt;code&gt;mod&lt;/code&gt; from the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 이 참조하는 값에서 원자 적으로 &lt;code&gt;mod&lt;/code&gt; 를 빼고 이전에 보유한 &lt;code&gt;val&lt;/code&gt; 값을 반환합니다 . 이 작업은 잠금이없고 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">힙 메모리를 비우려고 시도</target>
        </trans-unit>
        <trans-unit id="2d4188d946f5310d84944e1cbc16ca3404e12f5e" translate="yes" xml:space="preserve">
          <source>Attempt to write a readonly database</source>
          <target state="translated">읽기 전용 데이터베이스를 쓰려고 시도</target>
        </trans-unit>
        <trans-unit id="bad2e7923396bd94563de54c8743dd18ec710863" translate="yes" xml:space="preserve">
          <source>Attempting to read a non-existent file.</source>
          <target state="translated">존재하지 않는 파일을 읽으려고합니다.</target>
        </trans-unit>
        <trans-unit id="cfc72cd8439fa8fc0153768ece769b118903087b" translate="yes" xml:space="preserve">
          <source>Attempting to write to a read-only file.</source>
          <target state="translated">읽기 전용 파일에 쓰려고합니다.</target>
        </trans-unit>
        <trans-unit id="f3bc6684b273ddb5150c8f76dec58669641f537c" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="translated">둘러싸는 뮤텍스에서 읽기 잠금을 얻으려고 시도합니다. 차단하지 않고 얻을 수 있으면 잠금을 획득하고 true를 반환합니다. 그렇지 않으면 잠금을 획득 할 수 있거나 경과 된 시간이 제한 시간을 초과 할 때까지 기능이 차단되어 잠금이 획득되면 true를 리턴하고 함수가 제한 시간을 초과하면 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="619f7dc21d7be2451ba09a0a31590c696e32ea77" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">둘러싸는 뮤텍스에서 읽기 잠금을 획득하려고 시도합니다. 차단하지 않고 획득 할 수 있으면 잠금이 획득되고 true가 리턴됩니다. 그렇지 않으면 잠금이 획득되지 않고 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3953627ccf0b01ecfcf23b7ad87c26a8060eafac" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="translated">엔 클로징 뮤텍스에서 쓰기 잠금을 획득하려고합니다. 차단하지 않고 얻을 수 있으면 잠금을 획득하고 true를 반환합니다. 그렇지 않으면 잠금을 획득 할 수 있거나 경과 된 시간이 제한 시간을 초과 할 때까지 기능이 차단되어 잠금이 획득되면 true를 리턴하고 함수가 제한 시간을 초과하면 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="640457600821a8df2d538564c057e12d520f4905" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">둘러싸는 뮤텍스에서 쓰기 잠금을 얻으려고 시도합니다. 차단하지 않고 획득 할 수 있으면 잠금이 획득되고 true가 리턴됩니다. 그렇지 않으면 잠금이 획득되지 않고 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3b9757d22891fdb7b2db7ae0d5e59794d8111018" translate="yes" xml:space="preserve">
          <source>Attempts to cast Object o to class c. Returns o if successful, null if not.</source>
          <target state="translated">Object o를 클래스 c로 캐스트하려고 시도합니다. 성공하면 o를, 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb9f33e63583d791ce38087ee972da2a9a91218e" translate="yes" xml:space="preserve">
          <source>Attempts to lock the specified file segment. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">지정된 파일 세그먼트를 잠그려고 시도합니다. 두 경우 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;length&lt;/code&gt; 제로이며, 전체 파일이 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ad0c35f575b740f4d561c41e13284745953ceb" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host address as a human-readable string.</source>
          <target state="translated">호스트 주소를 사람이 읽을 수있는 문자열로 검색하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0ee6b4fbb8496cdc7d0620d9b9ed398b895a55e3" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host name as a fully qualified domain name.</source>
          <target state="translated">호스트 이름을 완전한 도메인 이름으로 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2288a588beafb785ffe5d4183be649edf540fac4" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the numeric port number as a string.</source>
          <target state="translated">숫자 포트 번호를 문자열로 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f6c4cea55c8d840b0fc77f72a5e89fc5d0c7b734" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the service name as a string.</source>
          <target state="translated">서비스 이름을 문자열로 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="06a30d499359e73aad911822ebc036ba5b33b771" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process associated with &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 와 연관된 프로세스를 종료하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5e521b72cd060c4862399350be7113a0bf337401" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution typing global memory. For example, if you pre-allocate memory in the DATA/TLS segment and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">주의 : 정확한 스캔을 사용하려면 전역 메모리를 입력 할 때 약간 더주의해야합니다. 예를 들어, DATA / TLS 세그먼트에서 메모리를 사전 할당 한 후 나중에이 메모리에 다른 할당에 대한 참조로 오브젝트 인스턴스를 배치하는 경우 공간을 예약하기 위해 기본 정수 유형을 사용해서는 안됩니다. 그렇게하면 가비지 수집기가 참조를 감지하지 못하게됩니다. 대신이 영역을 보수적으로 스캔하는 배열 유형을 사용하십시오. &lt;code&gt;void*&lt;/code&gt; 사용 하는 것이 GC에 의해 스캔되는 포인터에 대한 올바른 정렬을 보장하기 때문에 일반적으로 가장 좋은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="435469686dcf93332d214d0927042b6ab70eb76c" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution with type declarations. For example, if you reserve a buffer as part of a struct and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">주의 : 정확한 스캔을 가능하게하려면 유형 선언에서 약간 더주의해야합니다. 예를 들어, 구조체의 일부로 버퍼를 예약 한 후 나중에이 메모리에 다른 할당에 대한 참조로 객체 인스턴스를 배치하는 경우 기본 정수 유형을 사용하여 공간을 예약해서는 안됩니다. 그렇게하면 가비지 수집기가 참조를 감지하지 못하게됩니다. 대신이 영역을 보수적으로 스캔하는 배열 유형을 사용하십시오. &lt;code&gt;void*&lt;/code&gt; 사용 하는 것이 GC에 의해 스캔되는 포인터에 대한 올바른 정렬을 보장하기 때문에 일반적으로 가장 좋은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="563889efc6708465a0f8d7b13b7a64dc9449be63" translate="yes" xml:space="preserve">
          <source>Attribute inference is not done for other functions, even if the function body is present.</source>
          <target state="translated">함수 본문이 있더라도 다른 함수에 대해서는 속성 유추가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fde0c64566e4280899df7f71f529a9c5822593d2" translate="yes" xml:space="preserve">
          <source>Attributed Unittests</source>
          <target state="translated">속성 단위 테스트</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="3566d57f396227b960696c7c5f730c9617ce2ae9" translate="yes" xml:space="preserve">
          <source>Attributes are a way to modify one or more declarations. The general forms are:</source>
          <target state="translated">속성은 하나 이상의 선언을 수정하는 방법입니다. 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caa5510657413031ecde7637769e34ce12f05928" translate="yes" xml:space="preserve">
          <source>Attributes as obtained by &lt;a href=&quot;std_file#getAttributes&quot;&gt;&lt;code&gt;std.file.getAttributes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_file#DirEntry.attributes&quot;&gt;&lt;code&gt;std.file.DirEntry.attributes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_file#getAttributes&quot;&gt; &lt;code&gt;std.file.getAttributes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_file#DirEntry.attributes&quot;&gt; &lt;code&gt;std.file.DirEntry.attributes&lt;/code&gt; 에서&lt;/a&gt; 얻은 속성 .</target>
        </trans-unit>
        <trans-unit id="1a118fa9a5b31a61d074da7d6149cfba22d1f3ad" translate="yes" xml:space="preserve">
          <source>Authentication method as specified in &lt;a href=&quot;#AuthMethod&quot;&gt;&lt;code&gt;AuthMethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 규정 된 인증 방법 &lt;a href=&quot;#AuthMethod&quot;&gt; &lt;code&gt;AuthMethod&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1033f15759fcb47c36fb8ab321053fc3f1eca814" translate="yes" xml:space="preserve">
          <source>Authentication method equal to &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt;&lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt; &lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt; &lt;/a&gt; 같은 인증 방법</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="66d5524bc6e9a905bcd8ad67ae1eb457c570b564" translate="yes" xml:space="preserve">
          <source>Authorization denied</source>
          <target state="translated">승인 거부</target>
        </trans-unit>
        <trans-unit id="96526fc6efe098c9c6df94252412831b9ccb9466" translate="yes" xml:space="preserve">
          <source>Authors:</source>
          <target state="translated">Authors:</target>
        </trans-unit>
        <trans-unit id="ce0159a5518bc584a9e41b4b2690ef154fde135a" translate="yes" xml:space="preserve">
          <source>Auto Functions</source>
          <target state="translated">자동 기능</target>
        </trans-unit>
        <trans-unit id="cac7a53f813ead2d8559f8bf1f813c3742d1564d" translate="yes" xml:space="preserve">
          <source>Auto Ref Functions</source>
          <target state="translated">자동 참조 기능</target>
        </trans-unit>
        <trans-unit id="5437bd3930e7f40ca7893e40f97b38d23c03f5fa" translate="yes" xml:space="preserve">
          <source>Auto functions have their return type inferred from any &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body.</source>
          <target state="translated">자동 함수는 함수 본문의 모든 &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt; 에서 반환 유형을 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="cec7110add8230fd3e3cee4a6982476165507102" translate="yes" xml:space="preserve">
          <source>Auto ref function can have explicit return type.</source>
          <target state="translated">자동 참조 기능은 명시적인 반환 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c98218626b244980716cf56d4d67cef842f3ffa" translate="yes" xml:space="preserve">
          <source>Auto ref functions infer their return type just as &lt;a href=&quot;#auto-functions&quot;&gt;auto functions&lt;/a&gt; do. In addition, they become &lt;a href=&quot;#ref-functions&quot;&gt;ref functions&lt;/a&gt; if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</source>
          <target state="translated">자동 참조 기능은 &lt;a href=&quot;#auto-functions&quot;&gt;자동 기능&lt;/a&gt; 과 마찬가지로 반환 유형을 유추합니다 . 또한 모든 리턴 표현식이 lvalue 인 경우 &lt;a href=&quot;#ref-functions&quot;&gt;참조 함수&lt;/a&gt; 가되며 로컬 또는 매개 변수에 대한 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="72dbdd4328b363da1dc721bef13390d325cb449b" translate="yes" xml:space="preserve">
          <source>Auto ref parameters can be combined with auto ref return attributes:</source>
          <target state="translated">자동 참조 매개 변수는 자동 참조 리턴 속성과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60c388599c6393e9a67e964a642ad91629c903e" translate="yes" xml:space="preserve">
          <source>Auto start with constructor.</source>
          <target state="translated">생성자로 자동 시작합니다.</target>
        </trans-unit>
        <trans-unit id="efe7dcdfb00b164478f91903b1de63b3b45e9d2f" translate="yes" xml:space="preserve">
          <source>Auto-initialize the object</source>
          <target state="translated">객체 자동 초기화</target>
        </trans-unit>
        <trans-unit id="9d4560b6ff607cd4aecb5b5ff67e03b10904f66c" translate="yes" xml:space="preserve">
          <source>Autodecoding is enabled if this is set to true.</source>
          <target state="translated">이것이 자동으로 설정되면 자동 디코딩이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="360d06366226a26ec284df57dde94213ed2f94dc" translate="yes" xml:space="preserve">
          <source>Automatic input/output redirection using pipes</source>
          <target state="translated">파이프를 사용한 자동 입출력 리디렉션</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">정적으로 연결된 확장 프로그램 자동로드</target>
        </trans-unit>
        <trans-unit id="d2178e65328973816c4ca61d0183a96480a9ed99" translate="yes" xml:space="preserve">
          <source>Available GC options are:</source>
          <target state="translated">사용 가능한 GC 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e14fc18612f34181b225bea7665a50b7b0f96761" translate="yes" xml:space="preserve">
          <source>Available output formats:</source>
          <target state="translated">사용 가능한 출력 형식 :</target>
        </trans-unit>
        <trans-unit id="063d4770adfbdb2cd75f5fde3c562c12c1713762" translate="yes" xml:space="preserve">
          <source>Available parameters are: CURLFTPAUTH_DEFAULT - let libcurl decide CURLFTPAUTH_SSL - try &quot;AUTH SSL&quot; first, then TLS CURLFTPAUTH_TLS - try &quot;AUTH TLS&quot; first, then SSL</source>
          <target state="translated">사용 가능한 매개 변수는 다음과 같습니다. CURLFTPAUTH_DEFAULT-libcurl이 CURLFTPAUTH_SSL을 결정하게하십시오-먼저 &quot;AUTH SSL&quot;을 시도한 다음 TLS CURLFTPAUTH_TLS-먼저 &quot;AUTH TLS&quot;를 시도한 다음 SSL을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="463bce54270761ca786235a57251bca24f1dbc8b" translate="yes" xml:space="preserve">
          <source>Available space in bytes</source>
          <target state="translated">사용 가능한 공간 (바이트)</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="2be47cf0ea6736915b049bc8ea265c97a2606e56" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be a sign of poor decomposition of program structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains declarations needed by the other two.</source>
          <target state="translated">가능한 경우 주기적 수입을 피하십시오. 이것은 프로그램 구조가 독립적 인 모듈로 잘 분해되지 않았다는 표시 일 수 있습니다. 서로를 가져 오는 두 개의 모듈은주기없이 세 개의 모듈로 재구성 될 수 있으며, 세 번째 모듈은 다른 두 모듈에 필요한 선언을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4417a2a43deb22ade3de0092387bf58a8c4fe263" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be an indication of poor decomposition of a program's structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains the declarations needed by the other two.</source>
          <target state="translated">가능한 경우주기적인 수입을 피하십시오. 이는 프로그램 구조가 독립적 인 모듈로 잘못 분해되었음을 나타낼 수 있습니다. 서로를 가져 오는 두 모듈은 종종 순환없이 세 개의 모듈로 재구성 될 수 있습니다. 세 번째 모듈에는 다른 두 모듈에 필요한 선언이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa042d5d9bad75e7a516100618f6fbb64a7728b7" translate="yes" xml:space="preserve">
          <source>Avoid dependence on byte order; i.e. whether the CPU is big-endian or little-endian.</source>
          <target state="translated">바이트 순서에 의존하지 마십시오. 즉, CPU가 빅 엔디안인지 리틀 엔디안인지.</target>
        </trans-unit>
        <trans-unit id="87263cc0efbd41c932d10eec489a5a9fa53f4615" translate="yes" xml:space="preserve">
          <source>Avoid dependence on the size of a pointer or reference being the same size as a particular integral type.</source>
          <target state="translated">포인터 또는 참조의 크기가 특정 정수 유형과 동일한 크기에 의존하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="a5f3c22b10cd44ac8e47f76e9ce3358fd5ea5dbb" translate="yes" xml:space="preserve">
          <source>Avoid depending on the order of side effects in a computation that may get reordered by the compiler. For example:</source>
          <target state="translated">컴파일러에서 재정렬 할 수있는 계산에서 부작용의 순서에 의존하지 마십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07964cf6df89426658b50b243ee7036b1cf42153" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">변하지 않는 클래스의 변경 가능한 공용 필드를 사용하지 마십시오. 변하지 않는 경우 공용 인터페이스를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d3d6af1490ba88616db8531edd7f4d34c56a495" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">가변성이있는 구조체의 변경 가능한 퍼블릭 필드는 피하십시오. 불변으로는 퍼블릭 인터페이스를 확인할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0209d0b0190d63b253227592d1649d56cf0d62a8" translate="yes" xml:space="preserve">
          <source>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</source>
          <target state="translated">불변의 부작용에 의존하지 마십시오. 불변은 실행되거나 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a2c3569f4cdef214baa0f7dccd251b7796ef000" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs as parameters or arguments to variadic functions.</source>
          <target state="translated">빈 구조체를 가변 함수에 대한 매개 변수 또는 인수로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aa27a565a88b1217ee8242e278c52dfa4dc27415" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs when interfacing with C and C++ code.</source>
          <target state="translated">C 및 C ++ 코드와 인터페이스 할 때 빈 구조체를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fa97dd47910ed157d733ff928c6533de2cbdb883" translate="yes" xml:space="preserve">
          <source>A|B</source>
          <target state="translated">A|B</target>
        </trans-unit>
        <trans-unit id="ee75ef351995c342c1fa5ff34f0c8888a0c4023e" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed32df2c72f22e8029196feaab8d830b375f94a9" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228bacbd6367d63160ad16de9da2a5dc0a4c8ac" translate="yes" xml:space="preserve">
          <source>B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt;(bool cond : false, A, B)(lazy A a, B b);</source>
          <target state="translated">B &lt;strong id=&quot;select&quot;&gt;선택&lt;/strong&gt; (부식 : 거짓, A, B) (게으른 A a, B b);</target>
        </trans-unit>
        <trans-unit id="38af9591e3fb4695fab9bf9aa8e4b04997260819" translate="yes" xml:space="preserve">
          <source>BE stands for BlockExit.</source>
          <target state="translated">BE는 BlockExit의 약자입니다.</target>
        </trans-unit>
        <trans-unit id="f18291c5630b11c70838e02838757f776b664e5c" translate="yes" xml:space="preserve">
          <source>BE.xxxx</source>
          <target state="translated">BE.xxxx</target>
        </trans-unit>
        <trans-unit id="a8ac71a34c4bf8d47fcd34a3bb48e39638e1c9c2" translate="yes" xml:space="preserve">
          <source>BEL (alarm) character (U+0007).</source>
          <target state="translated">BEL (알람) 문자 (U + 0007).</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="4248a9b200b0703a243217afa7ea61bb6e9a6078" translate="yes" xml:space="preserve">
          <source>BOM</source>
          <target state="translated">BOM</target>
        </trans-unit>
        <trans-unit id="9e5d541d33dd4e690757280921ed4737bc5066d7" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;builtin&quot;&gt;builtin&lt;/strong&gt;;</source>
          <target state="translated">BUILTIN의 &lt;strong id=&quot;builtin&quot;&gt;내장&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e08e1bc55cdffceca473579010d3eed8f80f3da4" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;(FuncDeclaration fd);</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt; (FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="2ba208c7a57215fe25a2dc8edeb1eed6d80c323c" translate="yes" xml:space="preserve">
          <source>Back references</source>
          <target state="translated">역 참조</target>
        </trans-unit>
        <trans-unit id="cc6aace08575981676ef15b08f05eb45989c65af" translate="yes" xml:space="preserve">
          <source>Back-end type seldom used directly by user code. Two commonly-used types using &lt;code&gt;VariantN&lt;/code&gt; are:</source>
          <target state="translated">백엔드 유형은 사용자 코드에서 직접 사용하는 경우가 거의 없습니다. &lt;code&gt;VariantN&lt;/code&gt; 을 사용하여 일반적으로 사용되는 두 가지 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="59c009b9aac36256a825b962a8506069b93a0cd0" translate="yes" xml:space="preserve">
          <source>Backspace (U+0008).</source>
          <target state="translated">백 스페이스 (U + 0008).</target>
        </trans-unit>
        <trans-unit id="cc460f6a8460cfc0b7f80f1ff3a6c734e2b3ea57" translate="yes" xml:space="preserve">
          <source>Backward.</source>
          <target state="translated">Backward.</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="a4ba5616fd448eeba2a0c6f11c812abe221ea915" translate="yes" xml:space="preserve">
          <source>Bamum Supplement</source>
          <target state="translated">바움 보충제</target>
        </trans-unit>
        <trans-unit id="8e0abbaab6b20b6084d656b5fa956a7ead91c3cf" translate="yes" xml:space="preserve">
          <source>Bare URLs</source>
          <target state="translated">베어 URL</target>
        </trans-unit>
        <trans-unit id="f70b3222f4784cd8b2d7fa95c5e6ff653751d799" translate="yes" xml:space="preserve">
          <source>Bare URLs are sequences of characters that start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;, continue with one or more characters from the set of letters, digits and &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt;, and contain at least one period. URL recognition happens before all macro text substitution. The URL is wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; macro and is otherwise left untouched.</source>
          <target state="translated">베어 URL은 &lt;code&gt;http://&lt;/code&gt; 또는 &lt;code&gt;https://&lt;/code&gt; 로 시작하는 문자 시퀀스이며 문자, 숫자 및 &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt; 에서 하나 이상의 문자로 계속됩니다 . , 하나 이상의 기간을 포함합니다. 모든 매크로 텍스트 대체 전에 URL 인식이 수행됩니다. URL은 &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; 매크로에 싸여 있으며, 그렇지 않으면 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="cc110ca211bf143dd27dd71bfdb7b015a52cf91f" translate="yes" xml:space="preserve">
          <source>Base class construction is done by calling the base class constructor by the name &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">기본 클래스 생성은 이름 &lt;code&gt;super&lt;/code&gt; 로 기본 클래스 생성자를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="da5e0d7ff0c3f501f663124890a539611d14d952" translate="yes" xml:space="preserve">
          <source>Base class for synchronization errors.</source>
          <target state="translated">동기화 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c38a7f6f1cb2f71a182073d464805a1edb6ea0e7" translate="yes" xml:space="preserve">
          <source>Base class for synchronization exceptions.</source>
          <target state="translated">동기화 예외의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="672c3fd9686f0e99c9f798afb18e998c05c3a884" translate="yes" xml:space="preserve">
          <source>Base class for thread errors to be used for function inside GC when allocations are unavailable.</source>
          <target state="translated">할당을 사용할 수 없을 때 GC 내부의 함수에 사용되는 스레드 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="db07e1efbf8851dc009b2f7a1cf1562018684f57" translate="yes" xml:space="preserve">
          <source>Base class for thread exceptions.</source>
          <target state="translated">스레드 예외의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b0f6bbd9a7204a011357ddbe15da4f159805a9c3" translate="yes" xml:space="preserve">
          <source>Base classes are a list of these.</source>
          <target state="translated">기본 클래스는 이들의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="72c50689eae38c1c7d83b57fc2a2426479cefce2" translate="yes" xml:space="preserve">
          <source>Base exception thrown by &lt;code&gt;std.socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.socket&lt;/code&gt; 에 의해 발생 된 기본 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="05df8270dbce2a852d75025619c0b4d03bd1da5f" translate="yes" xml:space="preserve">
          <source>BaseClass* &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt;;</source>
          <target state="translated">BaseClass * &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="22f60185c7bbe04f26adbe40ecfd3daf1c5e1e4a" translate="yes" xml:space="preserve">
          <source>Based on a design by Mikola Lysenko.</source>
          <target state="translated">Mikola Lysenko의 디자인을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="b9c44f636926230213ca4c58bc4bd5fa1a395472" translate="yes" xml:space="preserve">
          <source>Based on code written by Regan Heath</source>
          <target state="translated">Regan Heath가 작성한 코드 기반</target>
        </trans-unit>
        <trans-unit id="8a178898d54dc17c11ed3e0694b1794aa76cee7f" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="translated">Andrei Alexandrescu (Addison-Wesley Professional, 2001)의 &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt;Modern C ++ Design&lt;/a&gt; 표 3.1의 아이디어를 바탕으로</target>
        </trans-unit>
        <trans-unit id="42a7227a261c13be83db50272e404bef15016672" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;https://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c70ad4dc394c37a35d8a9a02d3bbf206c6a2c3" translate="yes" xml:space="preserve">
          <source>Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt;;</source>
          <target state="translated">바 &lt;strong id=&quot;baseok&quot;&gt;ok&lt;/strong&gt; 바 &lt;strong id=&quot;baseok&quot;&gt;ok&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2958841f21ba5aab25e4b9de01c61072c4396f05" translate="yes" xml:space="preserve">
          <source>Basic (default)</source>
          <target state="translated">기본 (기본값)</target>
        </trans-unit>
        <trans-unit id="0376175c25ef469be8d7167b7c3f076d8a83135c" translate="yes" xml:space="preserve">
          <source>Basic Data Types</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="e19913977bf78df5f5b70c758a83b5ae4241e38e" translate="yes" xml:space="preserve">
          <source>Basic Latin</source>
          <target state="translated">기본 라틴</target>
        </trans-unit>
        <trans-unit id="0c51e02cc99b54172f7d7ba26283b9a2651139e1" translate="yes" xml:space="preserve">
          <source>Basic Logging</source>
          <target state="translated">기본 로깅</target>
        </trans-unit>
        <trans-unit id="c1025054c73b30fcc4ab113e76ab64be203331d7" translate="yes" xml:space="preserve">
          <source>Basic SMTP protocol support.</source>
          <target state="translated">기본 SMTP 프로토콜 지원</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="bf25bdb7baac4ca40f143b32bfd463f5aa35f794" translate="yes" xml:space="preserve">
          <source>Basic and dumm visitor which implements a visit method for each AST node implemented in AST. This visitor is the parent of strict, transitive and permissive visitors.</source>
          <target state="translated">AST로 구현 된 각 AST 노드에 대해 방문 방법을 구현하는 기본 및 덤프 방문자입니다. 이 방문자는 엄격하고 전 이적이며 허용되는 방문자의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="da424bc11d72f3a523d822671599c05d2482dd43" translate="yes" xml:space="preserve">
          <source>Basic block control flow operators.</source>
          <target state="translated">기본 블록 제어 흐름 연산자.</target>
        </trans-unit>
        <trans-unit id="55069311e393b3bc10e5288945ff6aebf4b60dce" translate="yes" xml:space="preserve">
          <source>Basic blocks: Basic blocks are a linked list of all the basic blocks in a function. startblock heads the list.</source>
          <target state="translated">기본 블록 : 기본 블록은 함수의 모든 기본 블록이 연결된 목록입니다. startblock이 목록을 이끈다.</target>
        </trans-unit>
        <trans-unit id="b015bc27621ab2a6e58582de340627d2513e110c" translate="yes" xml:space="preserve">
          <source>Basic data types are leaf types. Derived data types build on leaf types. User defined types are aggregates of basic and derived types.</source>
          <target state="translated">기본 데이터 유형은 리프 유형입니다. 파생 데이터 형식은 리프 형식을 기반으로합니다. 사용자 정의 유형은 기본 및 파생 유형의 집합입니다.</target>
        </trans-unit>
        <trans-unit id="c76e778b9531849f5fdc3371b8bf8a9576ca93cb" translate="yes" xml:space="preserve">
          <source>Basic splitting with characters and numbers.</source>
          <target state="translated">문자와 숫자로 기본 분할.</target>
        </trans-unit>
        <trans-unit id="22d64c70202f0fd0175e71294c1f0654ef85c43d" translate="yes" xml:space="preserve">
          <source>Basic support for lock-free concurrent programming.</source>
          <target state="translated">잠금없는 동시 프로그래밍에 대한 기본 지원.</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="f3a7ec26a786494d0ab6bd615e7d7023643666db" translate="yes" xml:space="preserve">
          <source>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; More info: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&lt;/a&gt;</source>
          <target state="translated">CWE-22 : 제한된 디렉토리에 대한 경로 이름의 제한 ( '경로 탐색') 공격에주의하십시오. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; 추가 정보 : &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating + from + tainted + sources에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9a6a84847309258cd9cad1f00b1d9b08270b36" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MultiwayMerge&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;MultiwayMerge&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;MultiwayMerge&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">때문에 &lt;code&gt;MultiwayMerge&lt;/code&gt; 가 추가 메모리를 할당하지 않습니다, 그것은 떠나 &lt;code&gt;ror&lt;/code&gt; 수정했습니다. 즉, &lt;code&gt;MultiwayMerge&lt;/code&gt; 는 &lt;code&gt;ror&lt;/code&gt; 의 소유권을 가정 하고 임의로 ror의 요소를 교환하고 발전시킵니다. 당신이 원하는 경우 &lt;code&gt;ror&lt;/code&gt; 호출 한 후 그 내용을 보존하기 위해, 당신은에 중복을 통과 할 수 있습니다 &lt;code&gt;MultiwayMerge&lt;/code&gt; (아마도 호출 사이에 중복 캐시).</target>
        </trans-unit>
        <trans-unit id="34edc8e4b66b211204a07db61a02d64017fc4c94" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;largestPartialIntersection&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;largestPartialIntersection&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;largestPartialIntersection&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">때문에 &lt;code&gt;largestPartialIntersection&lt;/code&gt; 가 추가 메모리를 할당하지 않습니다, 그것은 떠나 &lt;code&gt;ror&lt;/code&gt; 수정했습니다. 즉, &lt;code&gt;largestPartialIntersection&lt;/code&gt; 은 &lt;code&gt;ror&lt;/code&gt; 의 소유권을 가정 하고 임의로 그것의 요소를 교환하고 전진시킵니다. 당신이 원하는 경우 &lt;code&gt;ror&lt;/code&gt; 호출 한 후 그 내용을 보존하기 위해, 당신은에 중복을 통과 할 수 있습니다 &lt;code&gt;largestPartialIntersection&lt;/code&gt; (아마도 호출 사이에 중복 캐시).</target>
        </trans-unit>
        <trans-unit id="f9b6407740dfbc3c5fa141971e324ac38d1b4cc4" translate="yes" xml:space="preserve">
          <source>Because errors are unusual, execution of error handling code is not performance critical.</source>
          <target state="translated">오류가 드물기 때문에 오류 처리 코드를 실행하는 것이 성능에 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1362358bff14273f0cd677a86a2f16a4032a69e1" translate="yes" xml:space="preserve">
          <source>Because immutable is transitive, data referred to by an immutable is also immutable:</source>
          <target state="translated">불변은 전이이기 때문에 불변에 의해 참조되는 데이터도 불변입니다.</target>
        </trans-unit>
        <trans-unit id="37a897f3827c71e8379bebae37724c5759dd60a2" translate="yes" xml:space="preserve">
          <source>Because it doesn't return the value, this function is cheaper than &lt;code&gt;get&lt;/code&gt;. However, if you do need the value as well, you should just check the return of &lt;code&gt;get&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; instead of using this function first.</source>
          <target state="translated">값을 반환하지 않기 때문에이 함수는 &lt;code&gt;get&lt;/code&gt; 보다 저렴 합니다. 그러나 값도 필요하면 이 함수를 먼저 사용하는 대신 &lt;code&gt;null&lt;/code&gt; 에 대한 &lt;code&gt;get&lt;/code&gt; 의 리턴을 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="46a9674034fbe47581e972f1a85b13b8dd6bc584" translate="yes" xml:space="preserve">
          <source>Because modules are not part of C++, each function with C++ linkage in the global namespace must be globally unique within the program.</source>
          <target state="translated">모듈은 C ++의 일부가 아니므로 전역 네임 스페이스에서 C ++ 연결을 사용하는 각 함수는 프로그램 내에서 전역 적으로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a175b9174f2111e9e8065ab0dee738f3bde0af2" translate="yes" xml:space="preserve">
          <source>Because static arrays are passed to functions by value, a larger array can consume a lot of stack space. Use dynamic arrays instead.</source>
          <target state="translated">정적 배열은 값으로 함수에 전달되므로 더 큰 배열은 많은 스택 공간을 소비 할 수 있습니다. 대신 동적 배열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f36468f4c3a8d99449e93cf621c400036ac04c35" translate="yes" xml:space="preserve">
          <source>Because the allocator does not reuse memory, any dangling references to deallocated memory will always result in deterministically crashing the process.</source>
          <target state="translated">할당자가 메모리를 재사용하지 않기 때문에 할당 해제 된 메모리에 대한 댕글 링 참조는 항상 프로세스를 결정적으로 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="d8c3a61715e6c076e516e2adb94c24e13d1a7e0e" translate="yes" xml:space="preserve">
          <source>Because the reduction is being performed in parallel, &lt;code&gt;functions&lt;/code&gt; must be associative. For notational simplicity, let # be an infix operator representing &lt;code&gt;functions&lt;/code&gt;. Then, (a # b) # c must equal a # (b # c). Floating point addition is not associative even though addition in exact arithmetic is. Summing floating point numbers using this function may give different results than summing serially. However, for many practical purposes floating point addition can be treated as associative.</source>
          <target state="translated">축소가 병렬로 수행되므로 &lt;code&gt;functions&lt;/code&gt; 이 연관되어야합니다. 표기법의 단순화를 위해 #을 &lt;code&gt;functions&lt;/code&gt; 나타내는 중위 연산자로하자 . 그런 다음 (a # b) # c는 a # (b # c)와 같아야합니다. 정확한 산술에 추가하는 경우에도 부동 소수점 추가는 연관성이 없습니다. 이 함수를 사용하여 부동 소수점 숫자를 합하면 직렬로 합산하는 것과 다른 결과를 얻을 수 있습니다. 그러나 많은 실용적인 목적으로 부동 소수점 추가는 연관성으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b9c971f1d02fbd8d1af3306f1013bb85ae0126" translate="yes" xml:space="preserve">
          <source>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day.</source>
          <target state="translated">일 수의 유효성은 일이 발생한 연도와 월에 따라 다르므로 세 가지 변수를 모두 사용하여 일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="04beefc07e753c0350f57ce75d35ae3795bc6efa" translate="yes" xml:space="preserve">
          <source>Because there are no units larger than years, there is no difference between adding and rolling years.</source>
          <target state="translated">연도보다 큰 단위가 없기 때문에 연도 및 연도 사이에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b9fa636d60436156ac4d9755dc04095e1b03ef6" translate="yes" xml:space="preserve">
          <source>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</source>
          <target state="translated">함수가 실제로 반환하기 전에 범위 저장 기간이있는 모든 객체가 삭제되고, 엔 클로징 finally 절이 실행되고, 범위 (exit) 문이 실행되고, 범위 (성공) 문이 실행되고 모든 엔 클로징 동기화 객체가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="29b56d3b3ce732a418c6733f4aa512d819b9b955" translate="yes" xml:space="preserve">
          <source>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</source>
          <target state="translated">전체 컬렉션을 시작합니다. 이 의미는 가비지 수집기 구현에 따라 변경 될 수 있지만 일반적인 동작은 모든 스택 세그먼트에서 루트를 검색하고 액세스 가능한 메모리 블록을 활성으로 표시 한 다음 여유 공간을 확보하는 것입니다. 이 조치는 콜렉션 프로세스의 적어도 일부에 대해 실행중인 모든 스레드를 일시 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9290b213da7c41d3b9d381305e1a85dfd638ddf" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#visit&quot;&gt;&lt;code&gt;visit&lt;/code&gt;&lt;/a&gt; but doesn't enforce that all types are handled by the visiting functions.</source>
          <target state="translated">&lt;a href=&quot;#visit&quot;&gt; &lt;code&gt;visit&lt;/code&gt; &lt;/a&gt; 작동 하지만 모든 유형이 방문 기능에 의해 처리되도록 강제하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8671963c6358c10c30f0a9f60f5760e545d91151" translate="yes" xml:space="preserve">
          <source>Behaves like the identity function when args is empty.</source>
          <target state="translated">인수가 비어있는 경우 identity 함수처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f909782a90d0d82b3e7b38e26ebe9e00bc13126f" translate="yes" xml:space="preserve">
          <source>Being 100% compatible with C++ means more or less adding a fully functional C++ compiler front end to D. Anecdotal evidence suggests that writing such is a minimum of a 10 man-year project, essentially making a D compiler with such capability unimplementable. Other languages looking to hook up to C++ face the same problem, and the solutions have been:</source>
          <target state="translated">C ++과 100 % 호환된다는 것은 D에 완전한 기능을 갖춘 C ++ 컴파일러 프런트 엔드를 추가하는 것을 의미합니다. 일화적인 증거에 따르면 그러한 저작을 작성하는 것이 최소 10 년의 프로젝트 일 것입니다. C ++에 연결하려는 다른 언어도 동일한 문제에 직면하며 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="d6bc78c2edfd9a1e4a494692d443253b772c6030" translate="yes" xml:space="preserve">
          <source>Below here follows defines for the CURLOPT_IPRESOLVE option. If a host name resolves addresses using more than one IP protocol version, this option might be handy to force libcurl to use a specific IP version.</source>
          <target state="translated">아래는 CURLOPT_IPRESOLVE 옵션에 대한 정의입니다. 호스트 이름이 둘 이상의 IP 프로토콜 버전을 사용하여 주소를 확인하는 경우이 옵션을 사용하면 libcurl이 특정 IP 버전을 사용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8ee9a8f224bc381d10b9725300af6e8ad60b2f" translate="yes" xml:space="preserve">
          <source>Below is the table of names accepted by &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt;&lt;code&gt;unicode.hangulSyllableType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래는 &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt; &lt;code&gt;unicode.hangulSyllableType&lt;/code&gt; 에서&lt;/a&gt; 허용되는 이름 표입니다 .</target>
        </trans-unit>
        <trans-unit id="f460beb4086eb83db26145c0c14bfc2836a2dd77" translate="yes" xml:space="preserve">
          <source>Below is the table with block names accepted by &lt;a href=&quot;#unicode.block&quot;&gt;&lt;code&gt;unicode.block&lt;/code&gt;&lt;/a&gt;. Note that the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; requires &quot;In&quot; to be prepended to the names of blocks so as to disambiguate scripts and blocks.</source>
          <target state="translated">아래는 &lt;a href=&quot;#unicode.block&quot;&gt; &lt;code&gt;unicode.block&lt;/code&gt; 에&lt;/a&gt; 의해 허용되는 블록 이름을 가진 테이블입니다 . 속기 버전 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 는 스크립트와 블록을 명확하게하기 위해 블록 이름 앞에 &quot;In&quot;을 붙여야합니다.</target>
        </trans-unit>
        <trans-unit id="c16ded473b8d6a501e3afbf1d6b1aaa3bb67b9a5" translate="yes" xml:space="preserve">
          <source>Below is the table with script names accepted by &lt;a href=&quot;#unicode.script&quot;&gt;&lt;code&gt;unicode.script&lt;/code&gt;&lt;/a&gt; and by the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">아래는 &lt;a href=&quot;#unicode.script&quot;&gt; &lt;code&gt;unicode.script&lt;/code&gt; &lt;/a&gt; 및 단축 버전 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 에서 허용하는 스크립트 이름이있는 표입니다 .</target>
        </trans-unit>
        <trans-unit id="5cce75cef6b6f1b3c31bc07730b294f2256592a7" translate="yes" xml:space="preserve">
          <source>Benchmark with two functions comparing.</source>
          <target state="translated">두 가지 기능을 비교 한 벤치 마크.</target>
        </trans-unit>
        <trans-unit id="aa8cbccdf814344c472fdc83108ce95f463d76c2" translate="yes" xml:space="preserve">
          <source>Benchmarks code for speed assessment and comparison.</source>
          <target state="translated">속도 평가 및 비교를위한 벤치 마크 코드.</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="39b464ae10a3403acc76206ce3373cf277ad5588" translate="yes" xml:space="preserve">
          <source>Beta function</source>
          <target state="translated">베타 기능</target>
        </trans-unit>
        <trans-unit id="6cf60f60aed600fb3f70f4f199ce23160c46df50" translate="yes" xml:space="preserve">
          <source>Better C</source>
          <target state="translated">더 나은 C</target>
        </trans-unit>
        <trans-unit id="fa66737ffd71fbd94c99a79ae1d7c0f7a3f83f97" translate="yes" xml:space="preserve">
          <source>Bidi_Control</source>
          <target state="translated">Bidi_Control</target>
        </trans-unit>
        <trans-unit id="c1dd854953db9a48bc0d0ea0a3df0b423f22bafe" translate="yes" xml:space="preserve">
          <source>Bidirectional primitives. They are offered if &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt;.</source>
          <target state="translated">양방향 프리미티브. &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt; 경우 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fd2b2945fcece1d7de6dc41f877ba8c67c13689" translate="yes" xml:space="preserve">
          <source>Bidirectional range of elements</source>
          <target state="translated">양방향 요소 범위</target>
        </trans-unit>
        <trans-unit id="019ef9f3f8b5262d462588c43fd756f3913eee2d" translate="yes" xml:space="preserve">
          <source>Bidirectional range primitives. Provided only if both &lt;code&gt;hasSlicing!Source&lt;/code&gt; and &lt;code&gt;hasLength!Source&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">양방향 범위 프리미티브. &lt;code&gt;hasSlicing!Source&lt;/code&gt; 및 &lt;code&gt;hasLength!Source&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="71bfb07d0cb12b1ba4834790c7322d9de720c8a3" translate="yes" xml:space="preserve">
          <source>BidirectionalRange &lt;code&gt;range&lt;/code&gt;</source>
          <target state="translated">양방향 &lt;code&gt;range&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635846f5f8a3535fe06ebe7bdfb132d87f3a3a9b" translate="yes" xml:space="preserve">
          <source>Big endian byte order</source>
          <target state="translated">빅 엔디안 바이트 순서</target>
        </trans-unit>
        <trans-unit id="880ccaf424d3d59837e9afca21d218a82696d56c" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;base&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15d8e19b48cf73cfcbd5673d000427a6c89fe0cf" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;dividend&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;dividend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bf4e8892121a909f8719ff5ba16cf85f8324a8e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;divisor&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;divisor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9d72c5e7f7fec77eccf61954e6a190a6919e39" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;exponent&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;exponent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d09af76576312e7fbdeb58e15f85ddf03bdfeca" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;modulus&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;modulus&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6719bddb8d0310ee6d49cac219e4be2a60dd859e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;quotient&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;quotient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acf46d3f9c34c441344f4052f380185deff090a" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;remainder&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;remainder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc0d6128e74b8ffa38299adc002109eff669779d" translate="yes" xml:space="preserve">
          <source>BigInt implements value semantics using copy-on-write. This means that assignment is cheap, but operations such as x++ will cause heap allocation. (But note that for most bigint operations, heap allocation is inevitable anyway.)</source>
          <target state="translated">BigInt는 COW (Copy-On-Write)를 사용하여 값 의미를 구현합니다. 이는 할당이 저렴하지만 x ++와 같은 작업으로 인해 힙 할당이 발생 함을 의미합니다. (그러나 대부분의 bigint 작업의 경우 힙 할당은 불가피합니다.)</target>
        </trans-unit>
        <trans-unit id="2ae987b3c8b155139b22a17dacfded40cd54d6e8" translate="yes" xml:space="preserve">
          <source>Binary Operator Overloading</source>
          <target state="translated">이진 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="7ea3f10d7dc50a5d1d60c584be4ba66327be2344" translate="yes" xml:space="preserve">
          <source>Binary exponentiation</source>
          <target state="translated">이진 지수</target>
        </trans-unit>
        <trans-unit id="bc0e2dd063d01cb0a49d6952e1a447f5a0786666" translate="yes" xml:space="preserve">
          <source>Binary expressions except for &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; are evaluated in lexical order (left-to-right). Example:</source>
          <target state="translated">&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt; 및 &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression을&lt;/i&gt;&lt;/a&gt; 제외한 이진 표현식 은 어휘 순서 (왼쪽에서 오른쪽으로)로 평가됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3f59323ff0289ed186c342bdb4f9ade9bee4b594" translate="yes" xml:space="preserve">
          <source>Binary files: Number of bytes to offset from origin.</source>
          <target state="translated">이진 파일 : 원점에서 오프셋 할 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5ec3f5b7c67a25b307ee5761394fbc7f85f5c4ec" translate="yes" xml:space="preserve">
          <source>Binary files: Position used as reference for the offset, must be one of &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;, &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; or &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;.</source>
          <target state="translated">이진 파일 : 오프셋에 대한 참조로 사용되는 위치는 &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt; , &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; 또는 &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="710001c86b903db5ac28284015f70ad29d702165" translate="yes" xml:space="preserve">
          <source>Binary integers are a sequence of binary digits preceded by a &amp;lsquo;0b&amp;rsquo; or &amp;lsquo;0B&amp;rsquo;.</source>
          <target state="translated">이진 정수는 '0b'또는 '0B'가 앞에 오는 이진수의 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="e30449766634fc47649993e043f53913e318f363" translate="yes" xml:space="preserve">
          <source>Binary operations: subtracting and intersecting flags</source>
          <target state="translated">이항 연산 : 빼기 및 교차 플래그</target>
        </trans-unit>
        <trans-unit id="5bc41f55b9ac5ad602ac2a15812f4fa17e719258" translate="yes" xml:space="preserve">
          <source>Binary predicate for determining equivalence of two elements.</source>
          <target state="translated">두 요소의 동등성을 결정하기위한 이진 술어.</target>
        </trans-unit>
        <trans-unit id="1b5c4d6f642263934709007da433b44cfafe3dfa" translate="yes" xml:space="preserve">
          <source>Binary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b)&lt;/code&gt;, returns &lt;code&gt;pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">예를 들어 주어진 &lt;code&gt;pred(a, b)&lt;/code&gt; 와 같이 인수의 순서를 반대로하는 이진 술어 는 &lt;code&gt;pred(b, a)&lt;/code&gt; a) 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3390f0873b37228eb9da1981c4edea13376f4ce4" translate="yes" xml:space="preserve">
          <source>Binary zero (NUL, U+0000).</source>
          <target state="translated">이진수 0 (NUL, U + 0000).</target>
        </trans-unit>
        <trans-unit id="f07c525c75d6754496cc9e553ac6cf1931c4d038" translate="yes" xml:space="preserve">
          <source>BinaryHeap!(Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Store)(Store s, size_t initialSize = size_t.max);</source>
          <target state="translated">BinaryHeap! (Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt; (별칭 less = &quot;a &amp;lt;b&quot;, Store) (Store s, size_t initialSize = size_t.max);</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">준비된 명령문에 값 바인딩</target>
        </trans-unit>
        <trans-unit id="29d9453c80dc53e32cc00f3280980ce7ea8a0687" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr)</source>
          <target state="translated">:: operator delete (void * ptr)의 바인딩</target>
        </trans-unit>
        <trans-unit id="f7d97838adda037dd541956c0b38a3516ae36925" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr, const std::nothrow_t&amp;amp; tag)</source>
          <target state="translated">:: operator delete (void * ptr, const std :: nothrow_t &amp;amp; tag)의 바인딩</target>
        </trans-unit>
        <trans-unit id="9e8bd6d0542a61db39dc7370f4ff9f5bdec532e6" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count)</source>
          <target state="translated">:: operator new (std :: size_t count)에 대한 바인딩</target>
        </trans-unit>
        <trans-unit id="c9209fa1a437c94943e83fdcf912d410e070a043" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count, const std::nothrow_t&amp;amp;)</source>
          <target state="translated">:: operator new (std :: size_t count, const std :: nothrow_t &amp;amp;)에 대한 바인딩</target>
        </trans-unit>
        <trans-unit id="c595af9a225910870bb198153cb9e584ec6c2237" translate="yes" xml:space="preserve">
          <source>Binds the internal state to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">내부 상태를 &lt;code&gt;value&lt;/code&gt; 에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="1e718a122aa87d12e98c5f3055711cc94d264e1c" translate="yes" xml:space="preserve">
          <source>Bionic C runtime</source>
          <target state="translated">바이오닉 C 런타임</target>
        </trans-unit>
        <trans-unit id="cec8cf9a0b27bd714792dac06606e5c1b0178367" translate="yes" xml:space="preserve">
          <source>Bit constructs</source>
          <target state="translated">비트 구성</target>
        </trans-unit>
        <trans-unit id="70402e7ad10ad5f2124d70b6b5dfed369e14c974" translate="yes" xml:space="preserve">
          <source>Bit decoding of the TargetOS</source>
          <target state="translated">TargetOS의 비트 디코딩</target>
        </trans-unit>
        <trans-unit id="da97ac52d02a77703c633362dd74456458d249b2" translate="yes" xml:space="preserve">
          <source>Bit fields are supported with the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bitfields&lt;/a&gt; template.</source>
          <target state="translated">비트 필드는 &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;비트 필드&lt;/a&gt; 템플릿에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="11ee76002d783da853ef20847f30176e5d03ae44" translate="yes" xml:space="preserve">
          <source>Bit flipping</source>
          <target state="translated">비트 뒤집기</target>
        </trans-unit>
        <trans-unit id="8f76655665dcf73e363d56fc2df9877070986357" translate="yes" xml:space="preserve">
          <source>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done. Then, the bitwise operation is done.</source>
          <target state="translated">비트 단위 식은 피연산자에 비트 단위 연산을 수행합니다. 피연산자는 정수 유형이어야합니다. 먼저, &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 이 수행됩니다. 그런 다음 비트 단위 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab61da13a6c10abbc480c4a1c0747cb3baa6877" translate="yes" xml:space="preserve">
          <source>Bit-level manipulation facilities.</source>
          <target state="translated">비트 레벨 조작 기능.</target>
        </trans-unit>
        <trans-unit id="d9eff8dc4264242a1ae12f932821b47da28a5cc7" translate="yes" xml:space="preserve">
          <source>Bitwise Expressions</source>
          <target state="translated">비트 식</target>
        </trans-unit>
        <trans-unit id="df5079d347ee1e4244353fecfac2f5edf6b28c3c" translate="yes" xml:space="preserve">
          <source>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</source>
          <target state="translated">정수 유형 범위의 비트 단위 어댑터. 최하위 비트부터 최상위 비트까지 범위 단위를 비트 단위로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9b504c7d294e8d9e76232c80318479234720041d" translate="yes" xml:space="preserve">
          <source>Bitwise rotate &lt;code&gt;value&lt;/code&gt; left (&lt;code&gt;rol&lt;/code&gt;) or right (&lt;code&gt;ror&lt;/code&gt;) by &lt;code&gt;count&lt;/code&gt; bit positions.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 비트 위치를 기준으로 &lt;code&gt;value&lt;/code&gt; 왼쪽 ( &lt;code&gt;rol&lt;/code&gt; ) 또는 오른쪽 ( &lt;code&gt;ror&lt;/code&gt; )으로 회전 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ac6960d99f504b227c089027d841f4e9c385375" translate="yes" xml:space="preserve">
          <source>Block Elements</source>
          <target state="translated">블록 요소</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">블록 진술</target>
        </trans-unit>
        <trans-unit id="7358e14919f4d134af66ef6ad913b5a7d1139ac8" translate="yes" xml:space="preserve">
          <source>Block comments can span multiple lines, but do not nest.</source>
          <target state="translated">블록 주석은 여러 줄에 걸쳐있을 수 있지만 중첩되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fbe37dc50c1260fc0044f00cb0158d89f4c81af" translate="yes" xml:space="preserve">
          <source>Block of memory to serve as support for the allocator. Memory must be larger than two words and word-aligned.</source>
          <target state="translated">할당자를 지원하는 메모리 블록. 메모리는 두 단어보다 크고 단어로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0016c0671df573a3221620d651641a4c8dfdcc" translate="yes" xml:space="preserve">
          <source>Block previously obtained by a call to &lt;code&gt;allocate&lt;/code&gt; against this allocator (&lt;code&gt;null&lt;/code&gt; is allowed).</source>
          <target state="translated">이 할당 자에 대해 &lt;code&gt;allocate&lt;/code&gt; 하기 위해 호출에 의해 이전에 얻은 블록입니다 ( &lt;code&gt;null&lt;/code&gt; 은 허용됨).</target>
        </trans-unit>
        <trans-unit id="3ccb689779e89b6ac603e18c3e2082f3bf5ed78f" translate="yes" xml:space="preserve">
          <source>Block to deallocate.</source>
          <target state="translated">할당 해제를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="8117bd427e84d25123d525df198441ce5a262ba4" translate="yes" xml:space="preserve">
          <source>BlockStatement</source>
          <target state="translated">BlockStatement</target>
        </trans-unit>
        <trans-unit id="1c575a00b6c6472431006e69a67cda683c681cb6" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator</source>
          <target state="translated">BookkeepingAllocator</target>
        </trans-unit>
        <trans-unit id="642b597338266fa6f0fcfa51d03f6363e4f3af1d" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt;;</source>
          <target state="translated">부기 &lt;strong id=&quot;bkalloc&quot;&gt;할당 자 bkalloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="807b1864fdb6805b8347ae2bc9a6c20e8e44cbff" translate="yes" xml:space="preserve">
          <source>Boolean Operations</source>
          <target state="translated">부울 연산</target>
        </trans-unit>
        <trans-unit id="9a7bb38540335c853c8483b5f52966e014c86be1" translate="yes" xml:space="preserve">
          <source>Boolean flag set to true while the runtime is initialized.</source>
          <target state="translated">런타임이 초기화되는 동안 부울 플래그가 true로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="919ba0f721b82028f799116e9733b52309e726b3" translate="yes" xml:space="preserve">
          <source>Boolean options</source>
          <target state="translated">부울 옵션</target>
        </trans-unit>
        <trans-unit id="d62f48763e9c33e113d6e562d9814ef6092b4bb1" translate="yes" xml:space="preserve">
          <source>Boolean values are converted to &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">부울 값은 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="401d2f1688a777ae0bc5be157d0d7272e332e127" translate="yes" xml:space="preserve">
          <source>Boolean values are printed as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">부울 값은 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="105c6c86d7dd1b24e773395f017e7ee3c51ac8ff" translate="yes" xml:space="preserve">
          <source>Boost License 1.0</source>
          <target state="translated">부스트 라이센스 1.0</target>
        </trans-unit>
        <trans-unit id="e47a3386c7e74d205f749769164e9ef5c8040834" translate="yes" xml:space="preserve">
          <source>Boost Signals</source>
          <target state="translated">부스트 신호</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="5ba82cb02c720f3652f57a038e834a4bcc4c4c2f" translate="yes" xml:space="preserve">
          <source>Bopomofo Extended</source>
          <target state="translated">보포 모포 확장</target>
        </trans-unit>
        <trans-unit id="50d58ef5d04eba875c690e66a2db13e6043d0608" translate="yes" xml:space="preserve">
          <source>Borrowed</source>
          <target state="translated">Borrowed</target>
        </trans-unit>
        <trans-unit id="a5cd3b3f934540f0788541fb598aaaad1cf890f6" translate="yes" xml:space="preserve">
          <source>Borrowers are considered Owners if they are initialized from other than a pointer.</source>
          <target state="translated">차용자는 포인터가 아닌 다른 곳에서 초기화 된 경우 소유자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0a58aa19fb67e0b5abe5d7641293ce8ffcd1a87d" translate="yes" xml:space="preserve">
          <source>Borrowers can be Owners</source>
          <target state="translated">차용자는 소유자가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60c93251f61201f166e2379b490f975956e31c4" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;Variant&lt;/code&gt; share &lt;code&gt; VariantN&lt;/code&gt;'s interface. (See their respective documentations below.)</source>
          <target state="translated">&lt;code&gt;Algebraic&lt;/code&gt; 와 &lt;code&gt;Variant&lt;/code&gt; 은 모두 &lt;code&gt; VariantN&lt;/code&gt; 의 인터페이스를 공유 합니다. (아래의 해당 설명서를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="6535ded07930e3ddda0a1fe0ceda88dc9ce33dfa" translate="yes" xml:space="preserve">
          <source>Both backward and forward.</source>
          <target state="translated">앞뒤로.</target>
        </trans-unit>
        <trans-unit id="b8f7ae57cc9f0d657e03c01e9e4d98ba216ba14c" translate="yes" xml:space="preserve">
          <source>Both immutable and const are</source>
          <target state="translated">불변과 const는 모두</target>
        </trans-unit>
        <trans-unit id="e6a3f4fd036b065b2e797530c76e1c67c7c891ad" translate="yes" xml:space="preserve">
          <source>Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</source>
          <target state="translated">함수에 이중 컨텍스트 포인터가 필요한 경우 isThis () 및 isNested ()는 모두 true를 반환하고, 그렇지 않으면 isThis ()가 true를 반환하면 isNested ()는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf39d0ca68e0898427724a5e452ff23fb939fa46" translate="yes" xml:space="preserve">
          <source>Both rewrites are tried. If only one compiles, that one is taken. If they both resolve to the same function, the first rewrite is done. If they resolve to different functions, the best matching one is used. If they both match the same, but are different functions, an ambiguity error results.</source>
          <target state="translated">재 작성이 모두 시도됩니다. 하나만 컴파일하면 그 하나가 사용됩니다. 둘 다 동일한 기능으로 해결되면 첫 번째 다시 쓰기가 수행됩니다. 다른 기능으로 해석되면 가장 일치하는 기능이 사용됩니다. 둘 다 동일하지만 다른 기능인 경우 모호한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cd32d8791a4b901dbb6cc0f81dd64df4c40048e" translate="yes" xml:space="preserve">
          <source>Both the test and the return expressions are lazily evaluated.</source>
          <target state="translated">테스트 및 리턴 표현식 모두 지연 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="171f0c459de342d1f54dbc2ce2646745cc4ebc56" translate="yes" xml:space="preserve">
          <source>Both variants are implemented as instantiations of the template &lt;a href=&quot;#Base64Impl&quot;&gt;&lt;code&gt;Base64Impl&lt;/code&gt;&lt;/a&gt;. Most users will not need to use this template directly; however, it can be used to create customized Base64 encodings, such as one that omits padding characters, or one that is safe to embed inside a regular expression.</source>
          <target state="translated">두 변형 모두 템플릿 &lt;a href=&quot;#Base64Impl&quot;&gt; &lt;code&gt;Base64Impl&lt;/code&gt; 의&lt;/a&gt; 인스턴스화로 구현됩니다 . 대부분의 사용자는이 템플릿을 직접 사용할 필요가 없습니다. 그러나 패딩 문자를 생략하거나 정규식에 포함하기에 안전한 코드와 같은 사용자 정의 된 Base64 인코딩을 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d1805af0d734eef9db29bbdcf7d82b5d3e7f04" translate="yes" xml:space="preserve">
          <source>Box Drawing</source>
          <target state="translated">상자 그리기</target>
        </trans-unit>
        <trans-unit id="b8d28f7a363659e9c4b08c47130a0d8f80f5c106" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(binaryFun!pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range needle)</source>
          <target state="translated">BoyerMooreFinder! (binaryFun! pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, Range) (범위 바늘)</target>
        </trans-unit>
        <trans-unit id="2a76fd949603813a813972f30d7b0eeea91480d5" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</source>
          <target state="translated">BoyerMooreFinder! (pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5a99860d31900d36389daa3fa718de031554d4" translate="yes" xml:space="preserve">
          <source>Brahmi</source>
          <target state="translated">Brahmi</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="754a680c22eb1f9ecca61fac281a3f23b7fb9d29" translate="yes" xml:space="preserve">
          <source>Braille Patterns</source>
          <target state="translated">점자 패턴</target>
        </trans-unit>
        <trans-unit id="b2fcd02a50371b93a9e3654260745ee0af90cca2" translate="yes" xml:space="preserve">
          <source>Break Statement</source>
          <target state="translated">브레이크 선언</target>
        </trans-unit>
        <trans-unit id="76820814ec6d343b49333e574d3bb22a7fa8676a" translate="yes" xml:space="preserve">
          <source>Break and Continue out of Foreach</source>
          <target state="translated">Foreach 중단 및 계속</target>
        </trans-unit>
        <trans-unit id="0a89343c3ed16b2574554e37596ef4b4facffb9f" translate="yes" xml:space="preserve">
          <source>Breaking from a parallel foreach loop via a break, labeled break, labeled continue, return or goto statement throws a &lt;code&gt;ParallelForeachError&lt;/code&gt;.  In the case of non-random access ranges, parallel foreach buffers lazily to an array of size &lt;code&gt;workUnitSize&lt;/code&gt; before executing the parallel portion of the loop. The exception is that, if a parallel foreach is executed over a range returned by &lt;code&gt;asyncBuf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, the copying is elided and the buffers are simply swapped. In this case &lt;code&gt;workUnitSize&lt;/code&gt; is ignored and the work unit size is set to the buffer size of &lt;code&gt;range&lt;/code&gt;.  A memory barrier is guaranteed to be executed on exit from the loop, so that results produced by all threads are visible in the calling thread.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside a parallel foreach loop, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown by any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">break, 레이블이있는 continue, return 또는 goto 문을 통해 병렬 foreach 루프에서 분리하면 &lt;code&gt;ParallelForeachError&lt;/code&gt; 가 발생 합니다. 비 랜덤 액세스 범위의 경우, 병렬 foreach 버퍼 는 루프의 병렬 부분을 실행하기 전에 &lt;code&gt;workUnitSize&lt;/code&gt; 크기의 배열에 게으르게 지연됩니다 . 예외적으로, 병렬 foreach가 &lt;code&gt;asyncBuf&lt;/code&gt; 또는 &lt;code&gt;map&lt;/code&gt; 에 의해 반환 된 범위에서 실행 되면 복사가 생략되고 버퍼가 간단히 교체됩니다. 이 경우 &lt;code&gt;workUnitSize&lt;/code&gt; 는 무시되고 작업 단위 크기는 버퍼 크기 &lt;code&gt;range&lt;/code&gt; 설정됩니다. . 루프에서 나올 때 메모리 배리어가 실행되므로 모든 스레드에서 생성 된 결과가 호출 스레드에서 볼 수 있습니다. &lt;b&gt;예외 처리&lt;/b&gt; : 병렬 foreach 루프 내에서 하나 이상의 예외가 발생하면 추가 &lt;code&gt;Task&lt;/code&gt; 개체 의 제출이 비 결정적 방식으로 가능한 빨리 종료됩니다. 모든 실행 또는 대기열에있는 작업 단위를 완료 할 수 있습니다. 그런 다음 모든 작업 단위에서 발생한 모든 예외는 &lt;code&gt;Throwable.next&lt;/code&gt; 를 사용하여 연결됩니다. 되고 다시 발생합니다. 예외 체인의 순서는 결정적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d3201041918654fbf75089e070856aa79ebc523" translate="yes" xml:space="preserve">
          <source>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i.</source>
          <target state="translated">x를 정수 부분과 분수 부분으로 나눕니다. 각 부분은 x와 같은 부호를 갖습니다. 필수 부분은 i에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4324d0ed28641cb58b631967da3876548c2a70ef" translate="yes" xml:space="preserve">
          <source>Bring leaves to common type.</source>
          <target state="translated">나뭇잎을 일반적인 유형으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="399d0f0935a4fd7e2adf0462c69b1578bb0496b9" translate="yes" xml:space="preserve">
          <source>Buffer &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">버퍼 &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535393fe6f448d36dc112ebfa2c4ec8acdaebcaa" translate="yes" xml:space="preserve">
          <source>Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big. If this is not used, error messages go to stderr instead:</source>
          <target state="translated">오류 메시지를 수신 할 버퍼는 CURL_ERROR_SIZE 바이트 이상이어야합니다. 이것이 사용되지 않으면 대신 오류 메시지가 stderr로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="303f92df69f201e44e4c0ca1825e2e280d1f0c91" translate="yes" xml:space="preserve">
          <source>Buffer to structure as a free list. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, the buffer is assumed to be allocated by &lt;code&gt;parent&lt;/code&gt; and will be freed in the destructor.</source>
          <target state="translated">자유 목록으로 구조화하기위한 버퍼. 경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; 상기 버퍼가 할당되는 것으로 가정 &lt;code&gt;parent&lt;/code&gt; 와 소멸자 해제한다.</target>
        </trans-unit>
        <trans-unit id="c05d2a8029044c4c4e57f66bbd40a3eac5b198a2" translate="yes" xml:space="preserve">
          <source>Buffer to write the escaped path to</source>
          <target state="translated">이스케이프 된 경로를 쓸 버퍼</target>
        </trans-unit>
        <trans-unit id="c083c9d2a3d468528bb5dd1cebdd4400312c43c2" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</source>
          <target state="translated">결과 라인 데이터를 저장하는 데 사용되는 버퍼. 필요한 경우 buf가 확대 된 다음 선을 정확하게 포함하는 슬라이스로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab4ac68db7c219824ba8029fe0a1e0d5e5c01c5" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is resized as necessary.</source>
          <target state="translated">결과 라인 데이터를 저장하는 데 사용되는 버퍼. buf는 필요에 따라 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="80432fb4403119d7fa36b39cc0581f74363b7507" translate="yes" xml:space="preserve">
          <source>Bugs:</source>
          <target state="translated">Bugs:</target>
        </trans-unit>
        <trans-unit id="e543d61d1db526d2c201a9150a8eeb4f6a08a7bb" translate="yes" xml:space="preserve">
          <source>Bugzilla 2137</source>
          <target state="translated">Bugzilla 2137</target>
        </trans-unit>
        <trans-unit id="d957a3ddca24bb7ba3415ed5d23a475def657008" translate="yes" xml:space="preserve">
          <source>Bugzilla 592</source>
          <target state="translated">Bugzilla 592</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="e4ce8210e89bb0abea338092bae131b54bcd5ff1" translate="yes" xml:space="preserve">
          <source>Build __xopCmp for TypeInfo_Struct static bool __xopCmp(ref const S p, ref const S q) { return p.opCmp(q); }</source>
          <target state="translated">TypeInfo_Struct에 대한 __xopCmp 빌드 static bool __xopCmp (ref const S p, ref const S q) {return p.opCmp (q); }</target>
        </trans-unit>
        <trans-unit id="f3d924ea22f0f293cf6f3ebfcd84f23fb87ecdc9" translate="yes" xml:space="preserve">
          <source>Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p, ref const S q) { return p == q; }</source>
          <target state="translated">TypeInfo_Struct에 대한 __xopEquals 빌드 static bool __xopEquals (ref const S p, ref const S q) {return p == q; }</target>
        </trans-unit>
        <trans-unit id="edd21187462263909c4e5bccda552a4211a055ce" translate="yes" xml:space="preserve">
          <source>Build _xtoHash for non-bitwise hashing static hash_t xtoHash(ref const S p) nothrow @trusted;</source>
          <target state="translated">비트 단위가 아닌 해싱을 위해 _xtoHash 빌드 정적 해시 _t xtoHash (ref const S p) nothrow @trusted;</target>
        </trans-unit>
        <trans-unit id="02755102e393b0ceee36f18acf3cd4f3a97f903b" translate="yes" xml:space="preserve">
          <source>Build a list out of the null-terminated argument list.</source>
          <target state="translated">널 종료 인수 목록에서 목록을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8926cd9ddf0e4003036d0a204fc3589b6f556c48" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to copy the value of e into.</source>
          <target state="translated">e 값을 복사 할 임시 변수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7126b83ecb05ac49ee0d9a4bfd7fa2c9443a5db6" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to extract e's evaluation, if e is not trivial.</source>
          <target state="translated">e가 사소하지 않은 경우 e의 평가를 추출 할 임시 변수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0947173a3022e64a66ace8a16da7bd0953de0d" translate="yes" xml:space="preserve">
          <source>Build opAssign for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 대한 opAssign을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd267126bb39bb406bc3a0c8c87a8165b825fa2e" translate="yes" xml:space="preserve">
          <source>Build opEquals for struct. const bool opEquals(const S s) { ... }</source>
          <target state="translated">구조체에 대한 opEquals를 빌드하십시오. const bool opEquals (const S s) {...}</target>
        </trans-unit>
        <trans-unit id="6dd999e7845d7581c295f9165da47448ffe76f29" translate="yes" xml:space="preserve">
          <source>Build scoped variables and reference-counted types.</source>
          <target state="translated">범위가 지정된 변수 및 참조 횟수 유형을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="e777aa2ee0a1277f1927115dd56047ae99acaf63" translate="yes" xml:space="preserve">
          <source>Building Blocks</source>
          <target state="translated">빌딩 블록</target>
        </trans-unit>
        <trans-unit id="3f334616286956fcb816046552d7f9bf1acd6341" translate="yes" xml:space="preserve">
          <source>Building block functions, they translate to a single x87 instruction.</source>
          <target state="translated">빌딩 블록 함수는 단일 x87 명령어로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d7f3504504044d481b2cb93792c53ee903721c6" translate="yes" xml:space="preserve">
          <source>Building blocks</source>
          <target state="translated">빌딩 블록</target>
        </trans-unit>
        <trans-unit id="39c609d88be88f825074ec54ab9e12948dadee89" translate="yes" xml:space="preserve">
          <source>Building contract support into the language makes for:</source>
          <target state="translated">언어로 계약 지원을 구축하면 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e5d9a44c338285ef0b2cf2cbe5abd6d13da4bd15" translate="yes" xml:space="preserve">
          <source>Builds a &lt;code&gt;Trie&lt;/code&gt; with typically optimal speed-size trade-off and wraps it into a delegate of the following type: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt;.</source>
          <target state="translated">일반적으로 최적의 속도 크기 절충으로 &lt;code&gt;Trie&lt;/code&gt; 를 빌드하고 &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt; 유형의 델리게이트로 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="0ddd9b5faf4e195f0b71766badf13e8513590fa7" translate="yes" xml:space="preserve">
          <source>Builds an index of the top elements of a range.</source>
          <target state="translated">범위의 최상위 요소에 대한 색인을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="8ac6cb76b75c220d2577581173ee0a6d992a81d1" translate="yes" xml:space="preserve">
          <source>Builds an object. Usually this is invoked indirectly by using the &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">객체를 만듭니다. 일반적으로 이것은 &lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 을 사용하여 간접적으로 호출됩니다. 함수 .</target>
        </trans-unit>
        <trans-unit id="12e943a67bf614d76638933b655f13c408534085" translate="yes" xml:space="preserve">
          <source>Built-in mathematical intrinsics.</source>
          <target state="translated">내장 수학 수학적.</target>
        </trans-unit>
        <trans-unit id="393ada6b17ede7fe1acbc7b82bec2f4e8c1c04b5" translate="yes" xml:space="preserve">
          <source>Built-in postfix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to lambda invocations as follows: &lt;code&gt;expr++&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt;, and &lt;code&gt;expr--&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt;. Therefore, the result of postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is an rvalue just before the side effect has been effected.</source>
          <target state="translated">내장 된 접두어 단항 표현식 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 는 다음과 같이 람다 호출로 낮아진 (재 작성된) 것으로 평가됩니다. &lt;code&gt;expr++&lt;/code&gt; does &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt; 이고 &lt;code&gt;expr--&lt;/code&gt; 는 &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt; . 따라서 postfix &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 의 결과 는 부작용이 발생하기 직전에 rvalue입니다.</target>
        </trans-unit>
        <trans-unit id="140a63c50a697c2475ba756ea1b637cf7b49226e" translate="yes" xml:space="preserve">
          <source>Built-in prefix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to assignments as follows: &lt;code&gt;++expr&lt;/code&gt; becomes &lt;code&gt;((expr) += 1)&lt;/code&gt;, and &lt;code&gt;--expr&lt;/code&gt; becomes &lt;code&gt;((expr) -= 1)&lt;/code&gt;. Therefore, the result of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is the lvalue after the side effect has been effected.</source>
          <target state="translated">내장 접두사 단항 표현식 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 는 다음과 같이 대입을 낮추어 다시 쓴 것처럼 평가됩니다. &lt;code&gt;++expr&lt;/code&gt; 은 &lt;code&gt;((expr) += 1)&lt;/code&gt; , &lt;code&gt;--expr&lt;/code&gt; 은 &lt;code&gt;((expr) -= 1)&lt;/code&gt; . 따라서 접두사 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 의 결과 는 부작용이 발생한 후의 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="f4ef630934a7f1267240a157c0264f348c4dadf3" translate="yes" xml:space="preserve">
          <source>Built-in threading (e.g. &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt;&lt;code&gt;core.thread&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">내장 스레딩 (예 : &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt; &lt;code&gt;core.thread&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="738019c18e7d3c678f51b2d2bb9de596778335f1" translate="yes" xml:space="preserve">
          <source>Builtin SIMD intrinsics</source>
          <target state="translated">내장 SIMD 내장 함수</target>
        </trans-unit>
        <trans-unit id="809be9a33e4a381b76b3f2392efbde90e7cac474" translate="yes" xml:space="preserve">
          <source>Builtin mathematical intrinsics</source>
          <target state="translated">내장 수학 본질</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="aee13f098c3fbc98d67893709d2f60dddc7f25f1" translate="yes" xml:space="preserve">
          <source>But the precision of &lt;code&gt;StopWatch&lt;/code&gt; differs from system to system. It is impossible to for it to be the same from system to system since the precision of the system clock varies from system to system, and other system-dependent and situation-dependent stuff (such as the overhead of a context switch between threads) can also affect &lt;code&gt;StopWatch&lt;/code&gt;'s accuracy.</source>
          <target state="translated">그러나 &lt;code&gt;StopWatch&lt;/code&gt; 의 정밀도는 시스템마다 다릅니다. 시스템 클럭의 정밀도는 시스템마다 다르고 다른 시스템 종속 및 상황 종속적 요소 (예 : 스레드 간 컨텍스트 전환의 오버 헤드)가 시스템마다 동일 할 수는 없습니다. &lt;code&gt;StopWatch&lt;/code&gt; 의 정확도 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="768690cb6415ff721efd279bcb993c49ad663947" translate="yes" xml:space="preserve">
          <source>But, if one context is indirectly accessible from other context, it is allowed.</source>
          <target state="translated">그러나 한 컨텍스트가 다른 컨텍스트에서 간접적으로 액세스 가능한 경우 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd7cb5dd010de18293afcbf1ef490f5cd753c28" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because these names have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. Using all lower case package and module names will avoid or minimize problems when moving projects between dissimilar file systems.</source>
          <target state="translated">관례 상 패키지와 모듈 이름은 모두 소문자입니다. 이는 이러한 이름이 운영 체제의 디렉토리 및 파일 이름과 일대일로 대응하고 많은 파일 시스템이 대소 문자를 구분하지 않기 때문입니다. 모든 소문자 패키지 및 모듈 이름을 사용하면 서로 다른 파일 시스템간에 프로젝트를 이동할 때 문제를 방지하거나 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45921646718dbb6e00896e143e95be14de95c04" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because those names can have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. All lower case package and module names will minimize problems moving projects between dissimilar file systems.</source>
          <target state="translated">일반적으로 패키지 및 모듈 이름은 모두 소문자입니다. 이러한 이름은 운영 체제의 디렉토리 및 파일 이름과 일대일로 대응할 수 있으며 많은 파일 시스템은 대소 문자를 구분하지 않기 때문입니다. 모든 소문자 패키지 및 모듈 이름은 다른 파일 시스템간에 프로젝트를 이동하는 문제를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="2f986e628567a153d5373360f16e912e237bc63a" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;StoppingPolicy&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;StoppingPolicy&lt;/code&gt; 이 설정되어 &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8a76e2827ccb54962a847a022109fb17e84070" translate="yes" xml:space="preserve">
          <source>By default a request has it's &quot;User-Agent&quot; field set to &lt;a href=&quot;#%20defaultUserAgent&quot;&gt;&lt;code&gt; defaultUserAgent&lt;/code&gt;&lt;/a&gt; even if &lt;code&gt;setUserAgent&lt;/code&gt; was never called. Pass an empty string to suppress the &quot;User-Agent&quot; field altogether.</source>
          <target state="translated">기본적으로 요청에는 &lt;code&gt;setUserAgent&lt;/code&gt; 인 경우에도 &quot;User-Agent&quot;필드가 &lt;a href=&quot;#%20defaultUserAgent&quot;&gt; &lt;code&gt; defaultUserAgent&lt;/code&gt; 로&lt;/a&gt; 설정되어 있습니다. 가 호출되지 않은 있습니다. &quot;User-Agent&quot;필드를 모두 억제하려면 빈 문자열을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="478b0d271a29c1d5ae05535cd04bb959cef13353" translate="yes" xml:space="preserve">
          <source>By default an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">기본적으로 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6de89d666cfcbf1e2d91df4f90cb3d04defa9a2" translate="yes" xml:space="preserve">
          <source>By default four &lt;code&gt;Logger&lt;/code&gt; implementations are given. The &lt;code&gt;FileLogger&lt;/code&gt; logs data to files. It can also be used to log to &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as these devices are files as well. A &lt;code&gt;Logger&lt;/code&gt; that logs to &lt;code&gt;stdout&lt;/code&gt; can therefore be created by &lt;code&gt;new FileLogger(stdout)&lt;/code&gt;. The &lt;code&gt;MultiLogger&lt;/code&gt; is basically an associative array of &lt;code&gt;string&lt;/code&gt;s to &lt;code&gt;Logger&lt;/code&gt;. It propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;ArrayLogger&lt;/code&gt; contains an array of &lt;code&gt;Logger&lt;/code&gt; and also propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;NullLogger&lt;/code&gt; does not do anything. It will never log a message and will never throw on a log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">기본적으로 네 가지 &lt;code&gt;Logger&lt;/code&gt; 구현이 제공됩니다. &lt;code&gt;FileLogger&lt;/code&gt; 는 파일에 데이터를 기록합니다. 또한 이러한 장치는 파일이므로 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 에 로그하는 데 사용할 수 있습니다 . 따라서 &lt;code&gt;stdout&lt;/code&gt; 에 로그 하는 &lt;code&gt;Logger&lt;/code&gt; 는 &lt;code&gt;new FileLogger(stdout)&lt;/code&gt; 작성할 수 있습니다 . &lt;code&gt;MultiLogger&lt;/code&gt; 는 기본적으로의 연관 배열 &lt;code&gt;string&lt;/code&gt; s의 &lt;code&gt;Logger&lt;/code&gt; . 저장된 &lt;code&gt;Logger&lt;/code&gt; 에 로그 호출을 전파합니다 . &lt;code&gt;ArrayLogger&lt;/code&gt; 은 의 배열이 포함되어 &lt;code&gt;Logger&lt;/code&gt; 하고 또한 저장에 로그 전화 전파 &lt;code&gt;Logger&lt;/code&gt; . 그만큼 &lt;code&gt;NullLogger&lt;/code&gt; 는 아무것도하지 않습니다. 메시지를 기록하지 않으며 &lt;code&gt;LogLevel&lt;/code&gt; &lt;code&gt;error&lt;/code&gt; 로 로그 호출을 던지지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ef4ca6979d9539ab9bd7cee842dec5c1148639b" translate="yes" xml:space="preserve">
          <source>By default it is conservatively assumed that allocated memory may be &lt;code&gt;cast&lt;/code&gt; to &lt;code&gt;shared&lt;/code&gt;, passed across threads, and deallocated in a different thread than the one that allocated it. If that's not the case, there are two options. First, &lt;code&gt;immutableShared&lt;/code&gt; means the memory is allocated for &lt;code&gt;immutable&lt;/code&gt; data and will be deallocated in the same thread it was allocated in. Second, &lt;code&gt;threadLocal&lt;/code&gt; means the memory is not to be shared across threads at all. The two flags cannot be simultaneously present.</source>
          <target state="translated">기본적으로 할당 된 메모리는 &lt;code&gt;shared&lt;/code&gt; 로 &lt;code&gt;cast&lt;/code&gt; 되고 , 스레드를 통해 전달 되고 , 할당 된 메모리 와 다른 스레드에서 할당 해제 될 수 있다고 보수적으로 가정 합니다. 그렇지 않은 경우 두 가지 옵션이 있습니다. 먼저, &lt;code&gt;immutableShared&lt;/code&gt; 는 메모리가 &lt;code&gt;immutable&lt;/code&gt; 데이터에 할당되고 할당 된 동일한 스레드에서 할당 해제 &lt;code&gt;threadLocal&lt;/code&gt; 의미합니다 . 둘째, threadLocal 은 메모리가 스레드간에 전혀 공유되지 않음을 의미합니다. 두 플래그는 동시에 존재할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f5b3a15a485cfab1e5a75e1fa6e376cde7fb92a" translate="yes" xml:space="preserve">
          <source>By default options are case-insensitive. You can change that behavior by passing &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; directive like this:</source>
          <target state="translated">기본적으로 옵션은 대소 문자를 구분합니다. &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; 를 전달 하여 해당 동작을 변경할 수 있습니다. 지시문을 다음과 같이 .</target>
        </trans-unit>
        <trans-unit id="dbec3e9c45747840b24455eb80ba1df0a750e9ae" translate="yes" xml:space="preserve">
          <source>By default the garbage collector uses all available CPU cores to mark the heap.</source>
          <target state="translated">기본적으로 가비지 수집기는 사용 가능한 모든 CPU 코어를 사용하여 힙을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b8fa023c2d92a0d81832e9bd89d175d5927659d9" translate="yes" xml:space="preserve">
          <source>By default, GC options can only be passed on the command line of the program to run, e.g.</source>
          <target state="translated">기본적으로 GC 옵션은 프로그램의 명령 줄에서만 전달할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="8b24a9b44aee4758b90d689774f561a91ccfd9f7" translate="yes" xml:space="preserve">
          <source>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</source>
          <target state="translated">기본적으로 문자열 리터럴은 동적 배열로 입력되지만 요소 수는 컴파일 타임에 알려져 있습니다. 따라서 모든 문자열 리터럴을 내재적으로 정적 배열 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdaa68e3c22ff7ff0194a0456f12cfccad4e7b3" translate="yes" xml:space="preserve">
          <source>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</source>
          <target state="translated">기본적으로 배열 리터럴은 동적 배열로 입력되지만 요소 수는 컴파일 타임에 알려져 있습니다. 따라서 모든 배열 리터럴을 내재적으로 정적 배열 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22091b5b2cb326fb7704d38d801e2ea343fe0a4b" translate="yes" xml:space="preserve">
          <source>By default, imports are</source>
          <target state="translated">기본적으로 수입품은</target>
        </trans-unit>
        <trans-unit id="f143feea6dee31aa56bf9053dddf3e0e772b7f34" translate="yes" xml:space="preserve">
          <source>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the &lt;code&gt;__gshared&lt;/code&gt; attribute, its value is shared across all threads.</source>
          <target state="translated">기본적으로 변경할 수없는 전역 선언은 스레드 로컬 저장소에 있습니다. 전역 변수가 &lt;code&gt;__gshared&lt;/code&gt; 로 표시 될 때 속성 되면 해당 값이 모든 스레드에서 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="aad3d8313e40930c344804ce8ccc20bf40a3e89a" translate="yes" xml:space="preserve">
          <source>By default, parameters take rvalue arguments. A ref parameter takes an lvalue argument, so changes to its value will operate on the caller's argument.</source>
          <target state="translated">기본적으로 매개 변수는 rvalue 인수를 사용합니다. ref 매개 변수는 lvalue 인수를 취하므로 값 변경은 호출자의 인수에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="079ae70c5ecf861c3729c19e224c7956b1bb4ed1" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt; functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as &lt;code&gt;execute&lt;/code&gt;'s result would then contain a mix of output and warning/error messages.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#execute&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt; 함수는 하위 프로세스의 stdout 및 stderr을 모두 캡처합니다. &lt;code&gt;execute&lt;/code&gt; 결과에는 출력과 경고 / 오류 메시지가 혼합되어 있기 때문에 호출 프로그램이 표준 출력을 처리하거나 달리 사용하는 경우 바람직하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5c5dc33ccdd6fb02e11d57deb9c037003d388703" translate="yes" xml:space="preserve">
          <source>By default, the above will print:</source>
          <target state="translated">기본적으로 위의 내용이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2a431b7902a6f8a61040ea86e57ea9fd88c07b45" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the environment of the parent process, along with any additional variables specified in the &lt;code&gt;env&lt;/code&gt; parameter. If the same variable exists in both the parent's environment and in &lt;code&gt;env&lt;/code&gt;, the latter takes precedence.</source>
          <target state="translated">기본적으로 하위 프로세스는 &lt;code&gt;env&lt;/code&gt; 매개 변수에 지정된 추가 변수와 함께 상위 프로세스의 환경을 상속합니다 . 같은 변수는 부모의 모두 환경과에있는 경우 &lt;code&gt;env&lt;/code&gt; 하면 후자가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="00f97c90e4779d49bd0154dcbe3ccd270b7c1a5c" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the parent's environment, and any environment variables passed to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</source>
          <target state="translated">기본적으로 자식 프로세스는 부모의 환경을 상속하며 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; 에&lt;/a&gt; 전달 된 모든 환경 변수 가 추가됩니다. 이 플래그가 설정되면, 자식 프로세스 환경의 유일한 변수는 spawnProcess에 주어진 변수입니다.</target>
        </trans-unit>
        <trans-unit id="164f65e6c4e1ffea6984f3be9b15c6fd4fcd5bd7" translate="yes" xml:space="preserve">
          <source>By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size.</source>
          <target state="translated">기본적으로 반환 유형은 time_t (일반적으로 32 비트 시스템에서 int의 별칭이고 64 비트 시스템에서 long 임)이지만 int 또는 long과 다른 크기가 필요한 경우 템플릿 인수로 전달할 수 있습니다. 원하는 크기를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="887970dcbfc9d8811c8813f736813ed286b7d258" translate="yes" xml:space="preserve">
          <source>By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the</source>
          <target state="translated">기본적으로 반올림 모드는 roundToNearest이며 모든 하드웨어 예외는 비활성화되어 있습니다. 대부분의 응용 프로그램의 경우 디버깅이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6e33332413c374faf23d6382e0a46b9fcaf1aadb" translate="yes" xml:space="preserve">
          <source>By definition, empty ranges are matched fully and if &lt;code&gt;needles&lt;/code&gt; contains an empty range, &lt;code&gt;skipOver&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">정의에 따라 빈 범위는 완전히 일치하며 &lt;code&gt;needles&lt;/code&gt; 에 빈 범위가 포함 된 경우 &lt;code&gt;skipOver&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="10ce83358e38997bfd068876bacbbbb4077fd36b" translate="yes" xml:space="preserve">
          <source>By definition, if a pre contract fails, then the function received bad parameters. If a post contract fails, then there is a bug in the function. In either case, an &lt;code&gt;assert&lt;/code&gt; statement within the corresponding &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; block will throw an &lt;code&gt;AssertError&lt;/code&gt;.</source>
          <target state="translated">사전 계약에 실패하면 기능에 잘못된 매개 변수가 수신되었습니다. 사후 계약이 실패하면 기능에 버그가있는 것입니다. 두 경우 모두 해당 &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;out&lt;/code&gt; 블록 내의 &lt;code&gt;assert&lt;/code&gt; 문 은 &lt;code&gt;AssertError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bb96c2ff58da640b614e1d83a03d1ae961343b00" translate="yes" xml:space="preserve">
          <source>By fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals is changed to be never implicitly generated. Now, struct objects comparison s1 == s2 is translated to: s1.tupleof == s2.tupleof to calculate structural equality. See EqualExp.op_overload.</source>
          <target state="translated">&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; 를 수정함으로써 opEquals가 암시 적으로 생성되지 않도록 변경됩니다. 이제 구조체 객체 비교 s1 == s2는 s1.tupleof == s2.tupleof로 변환되어 구조적 평등을 계산합니다. EqualExp.op_overload를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aac8d772d9fb45f1ebe981cf3bff581d81f0a9a1" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;std_utf#byUTF&quot;&gt;&lt;code&gt;std.utf.byUTF&lt;/code&gt;&lt;/a&gt; and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making &lt;code&gt;icmp&lt;/code&gt;&lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_utf#byUTF&quot;&gt; &lt;code&gt;std.utf.byUTF&lt;/code&gt; &lt;/a&gt; 와 그 별명 을 사용 하면 자동 디코딩 및 예외를 통한 GC 할당을 피할 수있어 &lt;code&gt;icmp&lt;/code&gt; &lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bc291c2891b81ab141f345fa0230adb20fd10cd9" translate="yes" xml:space="preserve">
          <source>Byte order endianness.</source>
          <target state="translated">바이트 순서 엔디안</target>
        </trans-unit>
        <trans-unit id="1eb54b97f13d87edcd6a934d982b6f81fb1b387f" translate="yes" xml:space="preserve">
          <source>Byte order, least significant first</source>
          <target state="translated">바이트 순서, 가장 중요하지 않은 첫 번째</target>
        </trans-unit>
        <trans-unit id="b59f4e1ab4662646945739f875a2dc8274ccd34b" translate="yes" xml:space="preserve">
          <source>Byte order, most significant first</source>
          <target state="translated">바이트 순서, 가장 중요한 첫 번째</target>
        </trans-unit>
        <trans-unit id="0c1f86b6eef786b75f48b5164472c5f379f29825" translate="yes" xml:space="preserve">
          <source>Byte value in hexadecimal, where</source>
          <target state="translated">16 진수의 바이트 값</target>
        </trans-unit>
        <trans-unit id="f4e5cf625ea1bf16e64b237498429dc72e94863d" translate="yes" xml:space="preserve">
          <source>Byte value in octal.</source>
          <target state="translated">8 진수의 바이트 값.</target>
        </trans-unit>
        <trans-unit id="a58fed109fdbc425c9e3e299c4f472aa1e81b9e2" translate="yes" xml:space="preserve">
          <source>Bytes (not items) to be allocated for the free list. Memory will be allocated during construction and deallocated in the destructor.</source>
          <target state="translated">빈 목록에 할당 할 바이트 (항목 아님) 구축 중에 메모리가 할당되고 소멸자에서 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e625cfca365b6f5ed6d88821a2c881a6679253" translate="yes" xml:space="preserve">
          <source>Bytes to allocate</source>
          <target state="translated">할당 할 바이트</target>
        </trans-unit>
        <trans-unit id="2eadc64c1cdbc5d6ca752a0b38f5f0a02d05c4b1" translate="yes" xml:space="preserve">
          <source>Bytes to allocate using &lt;code&gt;ParentAllocator&lt;/code&gt;. This constructor is only defined If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;parent.allocate(n)&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the region will be initialized as empty (correctly initialized but unable to allocate).</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 를 사용하여 할당 할 바이트 입니다. 경우이 생성자는 정의 &lt;code&gt;ParentAllocator&lt;/code&gt; 는 다른 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;parent.allocate(n)&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 을 반환하는 경우 이 지역은 빈 (제대로 초기화하지만 할당 할 수 없습니다)로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d3fc47eb5e867c1a90c1c6140022201511e39c13" translate="yes" xml:space="preserve">
          <source>Byzantine Musical Symbols</source>
          <target state="translated">비잔틴 음악 기호</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="91ab2886a8945715f467ad2616dd5309295ba114" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="922a6aa3cb89e34ea72fe9d27effc2df259df392" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;create&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;create&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9652018eda95d6aa3dab8e093571b39cf52c2264" translate="yes" xml:space="preserve">
          <source>C ABI</source>
          <target state="translated">C ABI</target>
        </trans-unit>
        <trans-unit id="f824a58327e609cd9fdba23fe1a3c84c364898ea" translate="yes" xml:space="preserve">
          <source>C code can correspondingly call D functions, if the D functions use an attribute that is compatible with the C compiler, most likely the extern (C):</source>
          <target state="translated">D 함수가 C 컴파일러와 호환되는 속성을 사용하는 경우 C 코드는 이에 상응하여 D 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffb7f8837c1a11eeb25850dd4e1e4ef9b573509" translate="yes" xml:space="preserve">
          <source>C code explicitly manages memory with calls to &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc()&lt;/a&gt; and &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free()&lt;/a&gt;. D allocates memory using the D garbage collector, so no explicit frees are necessary.</source>
          <target state="translated">C 코드는 &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc ()&lt;/a&gt; 및 &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free ()&lt;/a&gt; 호출로 메모리를 명시 적으로 관리합니다 . D는 D 가비지 수집기를 사용하여 메모리를 할당하므로 명시 적 해제가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d221b852c9ebec0058ed069c0351edaaeb33622d" translate="yes" xml:space="preserve">
          <source>C code often adjusts the alignment and packing of struct members with a command line switch or with various implementation specific #pragmas. D supports explicit alignment attributes that correspond to the C compiler's rules. Check what alignment the C code is using, and explicitly set it for the D struct declaration.</source>
          <target state="translated">C 코드는 종종 명령 행 스위치 또는 다양한 구현 특정 #pragma를 사용하여 구조체 멤버의 정렬 및 패킹을 조정합니다. D는 C 컴파일러의 규칙에 해당하는 명시 적 정렬 속성을 지원합니다. C 코드가 사용하는 정렬을 확인하고 D 구조체 선언에 대해 명시 적으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ad0081e0fe0dd4d8c8faa110d448e18b099251c6" translate="yes" xml:space="preserve">
          <source>C function calling conventions are specified by:</source>
          <target state="translated">C 함수 호출 규칙은 다음에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7bbdeb583f7af40df326e5ef45b5341310bfa3a8" translate="yes" xml:space="preserve">
          <source>C functions can be called directly from D. There is no need for wrapper functions, argument swizzling, and the C functions do not need to be put into a separate DLL.</source>
          <target state="translated">C 함수는 D에서 직접 호출 할 수 있습니다. 랩퍼 함수, 인수 스위 즐링이 필요하지 않으며 C 함수는 별도의 DLL에 넣을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="391732c6d45f595037ed6d3acf61093990d2af4d" translate="yes" xml:space="preserve">
          <source>C functions cannot be overloaded with another C function with the same name.</source>
          <target state="translated">C 함수는 같은 이름의 다른 C 함수로 오버로드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f547f273af63b8119db89b56d4a8680c878d370" translate="yes" xml:space="preserve">
          <source>C globals can be accessed directly from D. C globals have the C naming convention, and so must be in an &lt;code&gt;extern (C)&lt;/code&gt; block. Use the &lt;code&gt;extern&lt;/code&gt; storage class to indicate that the global is allocated in the C code, not the D code. C globals default to being in global, not thread local, storage. To reference global storage from D, use the &lt;code&gt;__gshared&lt;/code&gt; storage class.</source>
          <target state="translated">C 전역은 D에서 직접 액세스 할 수 있습니다. C 전역에는 C 명명 규칙이 있으므로 &lt;code&gt;extern (C)&lt;/code&gt; 블록 에 있어야합니다 . &lt;code&gt;extern&lt;/code&gt; 스토리지 클래스를 사용하여 글로벌이 D 코드가 아닌 C 코드에 할당되었음을 표시하십시오. C 전역은 기본적으로 스레드 로컬 저장소가 아닌 전역에 있습니다. D에서 글로벌 스토리지를 참조하려면 &lt;code&gt;__gshared&lt;/code&gt; 스토리지 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="088f42af395914ff1b11b211001ff8dc3bfb47de" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.initialize, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.initialize의 C 인터페이스는 bool 대신 1/0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc4b969769a12fb03185e79820cbdb1188eba5a6" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.loadLibrary</source>
          <target state="translated">Runtime.loadLibrary에 대한 C 인터페이스</target>
        </trans-unit>
        <trans-unit id="1ba4ae2523a2983e2479e8220f1eed45cabbda41" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.terminate, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.terminate의 C 인터페이스, bool 대신 1/0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8ebac48238568ab95c4c5ad69ed5cd780269c53c" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.unloadLibrary, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.unloadLibrary의 C 인터페이스, bool 대신 1/0을 반환</target>
        </trans-unit>
        <trans-unit id="86cf735b5a9e30aaa5f0fee060cea7d39ebc4f60" translate="yes" xml:space="preserve">
          <source>C library routines. See callclib().</source>
          <target state="translated">C 라이브러리 루틴. callclib ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1ff5ead3c46826c14b71159d580aef25ffbf060" translate="yes" xml:space="preserve">
          <source>C name mangling is done by adding a prefix on some platforms.</source>
          <target state="translated">C 이름 맹 글링은 일부 플랫폼에서 접 두부를 추가하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="126f7b78af09df06aa9df51a74fef4005eae1de9" translate="yes" xml:space="preserve">
          <source>C style variadic function</source>
          <target state="translated">C 스타일 가변성 함수</target>
        </trans-unit>
        <trans-unit id="dd58d1bb166ddedbf2d0eda882e81a02524b0fbc" translate="yes" xml:space="preserve">
          <source>C#'s &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;embedded XML&lt;/a&gt;</source>
          <target state="translated">C #의 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;임베디드 XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34cf1ff3bbe582bde426d598f3ad72cfcc2d599c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;free&lt;/code&gt; does not have a safe interface:</source>
          <target state="translated">C의 &lt;code&gt;free&lt;/code&gt; 에는 안전한 인터페이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fcd30234820540d843ae13b550abfa205649ae3c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;malloc&lt;/code&gt; does have a safe interface:</source>
          <target state="translated">C의 &lt;code&gt;malloc&lt;/code&gt; 에는 안전한 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0143508b7b64b86b3401c85034e750942cedf11" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;strlen&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; do not have safe interfaces:</source>
          <target state="translated">C의 &lt;code&gt;strlen&lt;/code&gt; 및 &lt;code&gt;memcpy&lt;/code&gt; 에는 안전한 인터페이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd0548c5e650e5d6686abc5b2a04b9371833fa90" translate="yes" xml:space="preserve">
          <source>C's printf() and Strings</source>
          <target state="translated">C의 printf ()와 문자열</target>
        </trans-unit>
        <trans-unit id="4f540b0aaef1641b1d80a5208b7c055e606bf72a" translate="yes" xml:space="preserve">
          <source>C++ Interfaces</source>
          <target state="translated">C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="f1642c1a4e4dce54c68aa20addb027e83adf0715" translate="yes" xml:space="preserve">
          <source>C++ Namespaces</source>
          <target state="translated">C ++ 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="c5cb41022921444e105840eeb5b0879ab0ff1d75" translate="yes" xml:space="preserve">
          <source>C++ Support</source>
          <target state="translated">C ++ 지원</target>
        </trans-unit>
        <trans-unit id="f9f27585ae5da3fc2a761861b44ded6adf3015ec" translate="yes" xml:space="preserve">
          <source>C++ Templates</source>
          <target state="translated">C ++ 템플릿</target>
        </trans-unit>
        <trans-unit id="7e28b0c0a074b69119fdaf750d5061c6c3eed943" translate="yes" xml:space="preserve">
          <source>C++ allows a struct to inherit from a base struct. This is done in D using &lt;code&gt;alias this&lt;/code&gt;:</source>
          <target state="translated">C ++에서는 구조체가 기본 구조체에서 상속 할 수 있습니다. 이것은 &lt;code&gt;alias this&lt;/code&gt; 사용하여 D에서 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="270c92d90f5419eb56fc78a11ccc1e3fb6e75988" translate="yes" xml:space="preserve">
          <source>C++ and D follow different rules for function overloading. D source code, even when calling &lt;code&gt;extern (C++)&lt;/code&gt; functions, will still follow D overloading rules.</source>
          <target state="translated">C ++와 D는 함수 오버로딩에 대해 다른 규칙을 따릅니다. &lt;code&gt;extern (C++)&lt;/code&gt; 함수를 호출 할 때에도 D 소스 코드 는 여전히 D 오버로드 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="803c33c0bd9c5c8e423f248219c12fcafd72a234" translate="yes" xml:space="preserve">
          <source>C++ can open the same namespace in the same file and multiple files. In D, this can be done as follows:</source>
          <target state="translated">C ++는 동일한 파일 및 여러 파일에서 동일한 네임 스페이스를 열 수 있습니다. D에서는 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9777d8f776f92bf25e9cab083b49833d4a402d3" translate="yes" xml:space="preserve">
          <source>C++ class</source>
          <target state="translated">C ++ 클래스</target>
        </trans-unit>
        <trans-unit id="bc6ef19080a44be47740e7c8ef1fb2da8b514001" translate="yes" xml:space="preserve">
          <source>C++ classes can be declared in D by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declarations. &lt;code&gt;extern (C++)&lt;/code&gt; interfaces have the same restrictions as D interfaces, which means that Multiple Inheritance is supported to the extent that only one base class can have member fields.</source>
          <target state="translated">C ++ 클래스는 &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;interface&lt;/code&gt; 선언 에서 &lt;code&gt;extern (C++)&lt;/code&gt; 속성을 사용하여 D로 선언 될 수 있습니다 . &lt;code&gt;extern (C++)&lt;/code&gt; 인터페이스는 D 인터페이스와 동일한 제한 사항을 갖습니다. 즉, 하나의 기본 클래스 만 멤버 필드를 가질 수있는 범위에서 다중 상속이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2696fbb29a2404060229a5c0ef4dcf0d930ebf5a" translate="yes" xml:space="preserve">
          <source>C++ code explicitly manages memory with calls to &lt;code&gt;::operator new()&lt;/code&gt; and &lt;code&gt;::operator delete()&lt;/code&gt;. D's &lt;code&gt;new&lt;/code&gt; operator allocates memory using the D garbage collector, so no explicit delete is necessary. D's &lt;code&gt;new&lt;/code&gt; operator is not compatible with C++'s &lt;code&gt;::operator new&lt;/code&gt; and &lt;code&gt;::operator delete&lt;/code&gt;. Attempting to allocate memory with D's &lt;code&gt;new&lt;/code&gt; and deallocate with C++ &lt;code&gt;::operator delete&lt;/code&gt; will result in miserable failure.</source>
          <target state="translated">C ++ 코드는 &lt;code&gt;::operator new()&lt;/code&gt; 및 &lt;code&gt;::operator delete()&lt;/code&gt; 를 호출하여 메모리를 명시 적으로 관리합니다 . D의 &lt;code&gt;new&lt;/code&gt; 연산자는 D 가비지 수집기를 사용하여 메모리를 할당하므로 명시적인 삭제가 필요하지 않습니다. D의 &lt;code&gt;new&lt;/code&gt; 연산자는 C ++의 &lt;code&gt;::operator new&lt;/code&gt; 및 &lt;code&gt;::operator delete&lt;/code&gt; 와 호환되지 않습니다 . D의 &lt;code&gt;new&lt;/code&gt; 메모리를 할당하고 C ++ &lt;code&gt;::operator delete&lt;/code&gt; 를 할당 해제 하려고하면 실패한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc28c8a3178ea35aefa2bc7cad45f485c5c7f436" translate="yes" xml:space="preserve">
          <source>C++ constructors, copy constructors, move constructors and destructors cannot be called directly in D code, and D constructors, postblit operators and destructors cannot be directly exported to C++ code. Interoperation of types with these special operators is possible by either 1) disabling the operator in the client language and only using it in the host language, or 2) faithfully reimplementing the operator in the client language. With the latter approach, care needs to be taken to ensure observable semantics remain the same with both implementations, which can be difficult, or in some edge cases impossible, due to differences in how the operators work in the two languages. For example, in D all objects are movable and there is no move constructor.</source>
          <target state="translated">C ++ 생성자, 복사 생성자, 이동 생성자 및 소멸자는 D 코드에서 직접 호출 할 수 없으며 D 생성자, 포스트 블릿 연산자 및 소멸자는 C ++ 코드로 직접 내보낼 수 없습니다. 이러한 특수 연산자와 형식의 상호 운용은 1) 클라이언트 언어로 연산자를 비활성화하고 호스트 언어로만 연산자를 사용하거나 2) 클라이언트 언어로 연산자를 충실하게 다시 구현하여 가능합니다. 후자의 접근법에서는 관찰자가 의미하는 의미론이 두 구현에서 동일하게 유지되도록주의를 기울여야한다. 이는 두 언어에서 연산자의 작동 방식의 차이로 인해 어려울 수 있거나 일부 경우에는 불가능할 수있다. 예를 들어, D에서는 모든 객체가 이동 가능하며 이동 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7201ae364cc48822a82b73b893189a5dd94aef18" translate="yes" xml:space="preserve">
          <source>C++ function and type templates can be bound by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on a function or type template declaration.</source>
          <target state="translated">C ++ 함수 및 형식 템플릿은 함수 또는 형식 템플릿 선언 에서 &lt;code&gt;extern (C++)&lt;/code&gt; 속성을 사용하여 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5593ddf6c58f1012fa7ffeb46813794152a771a" translate="yes" xml:space="preserve">
          <source>C++ global functions, including those in namespaces, can be declared and called in D, or defined in D and called in C++.</source>
          <target state="translated">네임 스페이스의 함수를 포함한 C ++ 전역 함수는 D에서 선언 및 호출되거나 D에서 정의되어 C ++에서 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9e4356221d1ee2aa897fff7328f9ee52314134" translate="yes" xml:space="preserve">
          <source>C++ interfaces are interfaces declared with C++ linkage:</source>
          <target state="translated">C ++ 인터페이스는 C ++ 링크로 선언 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5099e4c841655b922a765e68cbf8aefc57d5356e" translate="yes" xml:space="preserve">
          <source>C++ namespace this symbol belongs to</source>
          <target state="translated">이 심볼이 속한 C ++ 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="c6f5200183cdf7ce197fbb3bc50824c16c47152a" translate="yes" xml:space="preserve">
          <source>C++ reference:</source>
          <target state="translated">C ++ 참조 :</target>
        </trans-unit>
        <trans-unit id="912b136567cd7cbd9fc8f323d5606bbe39d07750" translate="yes" xml:space="preserve">
          <source>C++ symbols that reside in namespaces can be accessed from D. A &lt;a href=&quot;attribute#namespace&quot;&gt;namespace&lt;/a&gt; can be added to the &lt;code&gt;extern (C++)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute&lt;/a&gt;:</source>
          <target state="translated">네임 스페이스에있는 C ++ 기호는 D에서 액세스 할 수 있습니다. &lt;a href=&quot;attribute#namespace&quot;&gt;네임 스페이스&lt;/a&gt; 는 &lt;code&gt;extern (C++)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute에&lt;/a&gt; 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f98b3c489784aabeb7da68a1d1411495ec51290" translate="yes" xml:space="preserve">
          <source>C++'s make_shared</source>
          <target state="translated">C ++의 make_shared</target>
        </trans-unit>
        <trans-unit id="588f44e70bf472a1f45f7efcfa562168c8457c0a" translate="yes" xml:space="preserve">
          <source>C-style Variadic Functions</source>
          <target state="translated">C 스타일의 가변 함수</target>
        </trans-unit>
        <trans-unit id="d5ccb24bc3ad9fc7c10cfe2824e9cb190ac91f9d" translate="yes" xml:space="preserve">
          <source>C-style array, function pointer and pointer to array declarations are deprecated:</source>
          <target state="translated">C 스타일 배열, 함수 포인터 및 배열 선언에 대한 포인터는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0848a8145c311481df53130b777fe467332d312" translate="yes" xml:space="preserve">
          <source>C-style octal integer notation was deemed too easy to mix up with decimal notation; it is only fully supported in string literals. D still supports octal integer literals interpreted at compile time through the &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt;&lt;code&gt;std.conv.octal&lt;/code&gt;&lt;/a&gt; template, as in &lt;code&gt;octal!167&lt;/code&gt;.</source>
          <target state="translated">C 스타일의 8 진 정수 표기법은 10 진수 표기법과 혼합하기가 너무 쉽다고 간주되었습니다. 문자열 리터럴에서만 완벽하게 지원됩니다. D는 여전히 &lt;code&gt;octal!167&lt;/code&gt; 에서와 같이 &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt; &lt;code&gt;std.conv.octal&lt;/code&gt; &lt;/a&gt; 템플릿을 통해 컴파일 타임에 해석되는 8 진 정수 리터럴을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9adf55a50113afd886edb1cbfcea7b8ecf56ed5e" translate="yes" xml:space="preserve">
          <source>C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array.</source>
          <target state="translated">포인터 산술에 대한 C 스타일 시맨틱은 엄격하게 적용됩니다. 포인터 산술은 정적 또는 동적 배열 요소를 가리키는 포인터에서만 허용됩니다. 이러한 포인터는 배열의 요소 또는 배열을 지나는 첫 번째 요소를 가리켜 야합니다. 포인터가 산술적이거나 널이 아닌 포인터를 가리키는 포인터는 완전히 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">C 스타일의 가변 함수</target>
        </trans-unit>
        <trans-unit id="77ba44bb9e589c769fa658f005333eee147a4900" translate="yes" xml:space="preserve">
          <source>C-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">C 스타일의 가변 함수는 &lt;code&gt;@safe&lt;/code&gt; 로 표시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddb858f8a20b16ac93e15adcc78e42ffbd8db66" translate="yes" xml:space="preserve">
          <source>C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">C 스타일의 가변 함수는 가변 함수에 대한 C 호출 규칙과 일치하며 &lt;code&gt;printf&lt;/code&gt; 와 같은 C 라이브러리 함수를 호출하는 데 가장 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="8818f4ee4a0e406f4fe10b1e03aebaf4d71f3819" translate="yes" xml:space="preserve">
          <source>C1 &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; C1</target>
        </trans-unit>
        <trans-unit id="30212c965112a877f52f60d83e8ff113ef1b3f96" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9089e6f07372bce6e832f5f650cb3e7c0c621e3b" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aa0499528f63537a98f340c34d4972647df60e5" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;suffix&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;suffix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c459d7b347295856b421ffb8792a1964353bfe70" translate="yes" xml:space="preserve">
          <source>C1[] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null);</source>
          <target state="translated">C1 [] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt; (C1, C2, C3, C4 = 불변 (char)) (C1 [] str, const (C2) [], const (C3) []에서 const (C4) [] 수정 자 = null) ;</target>
        </trans-unit>
        <trans-unit id="a0d01d3baedb5ae97bde5874c2012010c575e84c" translate="yes" xml:space="preserve">
          <source>C2 &lt;code&gt;empty&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; C2</target>
        </trans-unit>
        <trans-unit id="a8e1804fe922cd90750831c2c298d54a222ba628" translate="yes" xml:space="preserve">
          <source>C2[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C2 [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b7d328ba78816f38f975bb5147f4c05534a9bc5" translate="yes" xml:space="preserve">
          <source>CAPI3REF</source>
          <target state="translated">CAPI3REF</target>
        </trans-unit>
        <trans-unit id="bd963590f78aa017d53387443be555aa971b1144" translate="yes" xml:space="preserve">
          <source>CData &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">C 데이터 &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afdd392374481b4db6ac2ce43fdc87d5888fe7e3" translate="yes" xml:space="preserve">
          <source>CDataException if the segment body is illegal (contains &quot;]]&amp;gt;&quot;)</source>
          <target state="translated">세그먼트 본문이 잘못된 경우 CDataException ( &quot;]]&amp;gt;&quot;포함)</target>
        </trans-unit>
        <trans-unit id="3061e575e355c19788f22cb3d62aa0cd47f40e40" translate="yes" xml:space="preserve">
          <source>CData[] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt;;</source>
          <target state="translated">CData [] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="92b00c2e72a02d322e30292a494b0f77de93d540" translate="yes" xml:space="preserve">
          <source>CJK Compatibility</source>
          <target state="translated">CJK 호환성</target>
        </trans-unit>
        <trans-unit id="24dc7006e4bfb5dae3e8ea7f01d766f357b0514b" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Forms</source>
          <target state="translated">CJK 호환성 양식</target>
        </trans-unit>
        <trans-unit id="28610435f9d6e37ccd13448891ef635456bc6798" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs</source>
          <target state="translated">CJK 호환성 표</target>
        </trans-unit>
        <trans-unit id="3a3044d64bf35123af4c2034c39688d2f85c3b7d" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs Supplement</source>
          <target state="translated">CJK 호환성 표의 부록</target>
        </trans-unit>
        <trans-unit id="56398f3cc299fcadc8172ed7743fcc8d6604a2b2" translate="yes" xml:space="preserve">
          <source>CJK Radicals Supplement</source>
          <target state="translated">CJK 라디칼 보충제</target>
        </trans-unit>
        <trans-unit id="c80daba1e9c50935dee4c69ef20e42e31a63bfcb" translate="yes" xml:space="preserve">
          <source>CJK Strokes</source>
          <target state="translated">CJK 스트로크</target>
        </trans-unit>
        <trans-unit id="41d774013768fc4cae9cda6ce11ff4062ab10d65" translate="yes" xml:space="preserve">
          <source>CJK Symbols and Punctuation</source>
          <target state="translated">CJK 기호 및 문장 부호</target>
        </trans-unit>
        <trans-unit id="a8e25b3246b6d0e0fa06fb72ba766979769141a7" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs</source>
          <target state="translated">CJK 통합 이데 오 그래프</target>
        </trans-unit>
        <trans-unit id="6370cdf4d714b545f5b7bf4ee34e57e56e359487" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension A</source>
          <target state="translated">CJK 통합 Ideographs 확장 A</target>
        </trans-unit>
        <trans-unit id="a1724e7543e72f713653f623821483898403f1d0" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension B</source>
          <target state="translated">CJK 통합 Ideographs 확장 B</target>
        </trans-unit>
        <trans-unit id="71e4356045ae7c85afc88a13e5be97e037f502d4" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension C</source>
          <target state="translated">CJK 통합 Ideographs 확장 C</target>
        </trans-unit>
        <trans-unit id="de4f53e7b0971e7c4fd9b6b5639b6d9d3d564380" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension D</source>
          <target state="translated">CJK 통합 이데 오 그래프 확장 D</target>
        </trans-unit>
        <trans-unit id="df31bd94e79946dcd6e346825f4e84b5f0358f50" translate="yes" xml:space="preserve">
          <source>CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">선행이없는 CLI 플래그 &lt;code&gt;-&lt;/code&gt; 예 : &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d78b798fee78a64b81d6899e06efc15c1dccde51" translate="yes" xml:space="preserve">
          <source>COM Interfaces</source>
          <target state="translated">COM 인터페이스</target>
        </trans-unit>
        <trans-unit id="154721c66d149bb61466c03b8ff3861e25ef38c7" translate="yes" xml:space="preserve">
          <source>COM classes and C++ classes</source>
          <target state="translated">COM 클래스 및 C ++ 클래스</target>
        </trans-unit>
        <trans-unit id="ae337737f416d275254734defda66541f870f22e" translate="yes" xml:space="preserve">
          <source>COMPILER INTERFACE /////////////////////</source>
          <target state="translated">컴파일러 인터페이스 //////////////////////</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="0af12e3ea89b844b314d17c7e3f7bac655ebd0c7" translate="yes" xml:space="preserve">
          <source>CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt;;</source>
          <target state="translated">CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="95fe9c2b68a6150c2538241de478d073b3c01eb6" translate="yes" xml:space="preserve">
          <source>CPU architectures supported -mcpu=id</source>
          <target state="translated">지원되는 CPU 아키텍처 -mcpu = id</target>
        </trans-unit>
        <trans-unit id="73c7fc0f09e167cc17d6e2ae64cdb2bc100ca9d7" translate="yes" xml:space="preserve">
          <source>CPUs often support specialized vector types and vector operations (a.k.a.</source>
          <target state="translated">CPU는 종종 특수한 벡터 유형과 벡터 연산 (일명 일명)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="bf887172139520e2ce3c00abdb93ee2e9fd86211" translate="yes" xml:space="preserve">
          <source>CRC32 of data</source>
          <target state="translated">데이터의 CRC32</target>
        </trans-unit>
        <trans-unit id="992514a6a8b2e73f449a04615c81ce6686d74551" translate="yes" xml:space="preserve">
          <source>CRC32 value.</source>
          <target state="translated">CRC32 값.</target>
        </trans-unit>
        <trans-unit id="764a2bd592ab90f526cba7f18836f8fb323c69e5" translate="yes" xml:space="preserve">
          <source>CRC64-ECMA of data</source>
          <target state="translated">데이터의 CRC64-ECMA</target>
        </trans-unit>
        <trans-unit id="de219addfefcc2e27f49a3ca6fa5a51d3de19ec6" translate="yes" xml:space="preserve">
          <source>CRC64-ISO of data</source>
          <target state="translated">데이터의 CRC64-ISO</target>
        </trans-unit>
        <trans-unit id="91d96d88652e57b949051060aed04c0c7a55db68" translate="yes" xml:space="preserve">
          <source>CRCs are usually printed with the MSB first. When using &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt; the result will be in an unexpected order. Use &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt;'s optional order parameter to specify decreasing order for the correct result. The &lt;a href=&quot;#crcHexString&quot;&gt;&lt;code&gt;crcHexString&lt;/code&gt;&lt;/a&gt; alias can also be used for this purpose.</source>
          <target state="translated">CRC는 일반적으로 MSB와 함께 먼저 인쇄됩니다. &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; 을&lt;/a&gt; 사용할 때 결과는 예상치 못한 순서로 나타납니다. 사용 &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt; 의 선택 순서 매개 변수는 올바른 결과를 내림차순으로 지정합니다. &lt;a href=&quot;#crcHexString&quot;&gt; &lt;code&gt;crcHexString&lt;/code&gt; 의&lt;/a&gt; 별칭은이 목적을 위해 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="20226dce447690b9ec8699b49af5230d49691790" translate="yes" xml:space="preserve">
          <source>CRL file</source>
          <target state="translated">CRL 파일</target>
        </trans-unit>
        <trans-unit id="9d1c93dd97d25f4c239981585e218bded30a91de" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a402cf31f9cf0e6b5b8a55752e348488f03f726b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9864028d4f462263a4ffef0bfb1252c98316a14b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;csx&lt;/code&gt;</source>
          <target state="translated">CSX의 &lt;code&gt;csx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8934fa932e57010a67e3ca78ffd8b25af059e9" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6cb8e5d0c4fc4c6db7f22e70f099ed917c02dc9a" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ef70b18a1d95d31d7157c61d4106f2015fb5f903" translate="yes" xml:space="preserve">
          <source>CTFE</source>
          <target state="translated">CTFE</target>
        </trans-unit>
        <trans-unit id="f226c00a4d670c28c9ce96128a908ed75e3c4fc6" translate="yes" xml:space="preserve">
          <source>CTFE Sanity Checks</source>
          <target state="translated">CTFE 위생 검사</target>
        </trans-unit>
        <trans-unit id="bcdc8bcedfff54c513bf8524b5ea04b31a01d40f" translate="yes" xml:space="preserve">
          <source>CTFE is not supported.</source>
          <target state="translated">CTFE는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8b7f100028e56862c1d736efc547af30992b6b" translate="yes" xml:space="preserve">
          <source>CTFE is subject to the following restrictions:</source>
          <target state="translated">CTFE에는 다음 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5cbcfb039635320e7ff7d8feb659fe88d90d6d53" translate="yes" xml:space="preserve">
          <source>CTFE-able expression, resolving to &lt;code&gt;TupleExp&lt;/code&gt; or &lt;code&gt;StringExp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TupleExp&lt;/code&gt; 또는 &lt;code&gt;StringExp&lt;/code&gt; 로 해석되는 CTFE 가능 표현식</target>
        </trans-unit>
        <trans-unit id="da921efe49d919390e46ee7013dc94409e0427b9" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt; (CURL * 컬);</target>
        </trans-unit>
        <trans-unit id="f3df3af8e49ed4cabb82ec3eb374069c299119bb" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;();</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="6751502e2bc0440a5e6927ebe6c763c9fb33f615" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt;;</source>
          <target state="translated">CURL * &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="828fa48577f41dee0175a07d2bcd99aa7917b639" translate="yes" xml:space="preserve">
          <source>CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error instead of a memory allocation error if CURL_DOES_CONVERSIONS is defined</source>
          <target state="translated">CURL_DOES_CONVERSIONS가 정의 된 경우 CURLE_OUT_OF_MEMORY가 때때로 메모리 할당 오류 대신 변환 오류를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab51649023b66c808197a6d0ba638e7d65bf9da" translate="yes" xml:space="preserve">
          <source>CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;(curl_httppost** httppost, curl_httppost** last_post, ...);</source>
          <target state="translated">CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt; (curl_httppost ** httppost, curl_httppost ** last_post, ...);</target>
        </trans-unit>
        <trans-unit id="ee42c010a41bbc2d374ffe159f6514f8ff046b0e" translate="yes" xml:space="preserve">
          <source>CURLINFO_RESPONSE_CODE is the new name for the option previously known as CURLINFO_HTTP_CODE</source>
          <target state="translated">CURLINFO_RESPONSE_CODE는 이전에 CURLINFO_HTTP_CODE로 알려진 옵션의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="32ad7575f66b5734a63076c0cb3d75f3884da653" translate="yes" xml:space="preserve">
          <source>CURLM error code.</source>
          <target state="translated">CURLM 오류 코드</target>
        </trans-unit>
        <trans-unit id="99dd99b527ed789fcfbdfc456b2eb941ef204be1" translate="yes" xml:space="preserve">
          <source>CURLM* &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;();</source>
          <target state="translated">CURLM * &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="3b90f598cb268ee4dc09f1ac996362f90296018c" translate="yes" xml:space="preserve">
          <source>CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt;;</source>
          <target state="translated">CURLMSG &lt;strong id=&quot;msg&quot;&gt;메시지&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1999612ad18366624e0d0b2cd56012c1afc025b3" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="22a1019ea56e4dab3fcad53491bac13d0d8af5fb" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t sockfd, void* sockp);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt; (CURLM * 멀티 _ 핸들, curl_socket_t sockfd, void * sockp);</target>
        </trans-unit>
        <trans-unit id="25a2804bd3b7261884e99b1fc524c94a8f152120" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;(CURLM* multi_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt; (CURLM * multi_handle);</target>
        </trans-unit>
        <trans-unit id="0d7d7eae82011af95f4a6e15b19e86d79b7d077b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt; (CURLM * 다중 _ 핸들, fd_set * read_fd_set, fd_set * write_fd_set, fd_set * exc_fd_set, int * max_fd);</target>
        </trans-unit>
        <trans-unit id="811b3bdcf0c9e88ad95fd7b9e1e9194bc510f1d4" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="cdc21e6a79fac27e25ab2401a2231a5159d42fa2" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="b77796e4441642019f5f0ee725e2d2ccbaf79203" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;(CURLM* multi_handle, CURLMoption option, ...);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt; (CURLM * 다중 핸들, CURLMoption 옵션, ...);</target>
        </trans-unit>
        <trans-unit id="a09fadf338e9129df789fdea317e027aaed23a5b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="ff40633804853059e167a117757dc66453ca66ad" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t, int ev_bitmask, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="2466194fef4d1ee2ade6e8ccdeda99a667524258" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="11ebb04cdf64624f9d24ec68ab137e1aca46350a" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;(CURLM* multi_handle, c_long* milliseconds);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt; (CURLM * 멀티 핸들, c_long * 밀리 초);</target>
        </trans-unit>
        <trans-unit id="78c7684a9c1f8b1ac34050129574ece72e711bdd" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.</source>
          <target state="translated">CURLMcode 유형, 일반 다중 오류 코드</target>
        </trans-unit>
        <trans-unit id="4dc759c2b4e3bdbdc1edda0576bc41603b22a66f" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.  tmp decl</source>
          <target state="translated">CURLMcode 유형, 일반 다중 오류 코드 tmp decl</target>
        </trans-unit>
        <trans-unit id="8b52c35c36f45f74e7316bea0caa3ca7b9817c93" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code. &lt;em&gt;NOTE&lt;/em&gt; that this only returns errors etc regarding the whole multi stack. There might still have occurred problems on invidual transfers even when this returns OK.</source>
          <target state="translated">CURLMcode 유형, 일반 다중 오류 코드 &lt;em&gt;참고&lt;/em&gt; 이 전체 다중 스택과 관련이 만 반환 오류 등. OK를 반환하더라도 개별 전송에 여전히 문제가 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24871c0c35a14246d94f5b601f5067185618ba89" translate="yes" xml:space="preserve">
          <source>CURLMsg* &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;(CURLM* multi_handle, int* msgs_in_queue);</source>
          <target state="translated">CURLMsg * &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt; (CURLM * multi_handle, int * msgs_in_queue);</target>
        </trans-unit>
        <trans-unit id="af2fa369dcf8fd4fae6663dacfb6660f7d91238e" translate="yes" xml:space="preserve">
          <source>CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options</source>
          <target state="translated">CURLPROTO_는 CURLOPT_ * PROTOCOLS 옵션에 대한 것으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d2e3b588ca39c50e2dd064cfebdc4915a19704fb" translate="yes" xml:space="preserve">
          <source>CURLSH* &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;();</source>
          <target state="translated">CURLSH * &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="0cd2315c9c925b9d61d4c461b411526f237b821b" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;(CURLSH*);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt; (CURLSH *);</target>
        </trans-unit>
        <trans-unit id="c12fc1ef3ac28f47fb0a0bb249fb914036edd5d6" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;(CURLSH*, CURLSHoption option, ...);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt; (CURLSH *, CURLSH 옵션 옵션, ...);</target>
        </trans-unit>
        <trans-unit id="80c9a3afaa37cabae0ead42d1ea2a983b4448ab3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_ILLEGAL_ARRAY if an illegal option is used in an array</source>
          <target state="translated">배열에 잘못된 옵션이 사용 된 경우 CURL_FORMADD_ILLEGAL_ARRAY</target>
        </trans-unit>
        <trans-unit id="237caace3d00237f9fad71d5fdcb4b423276a5aa" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_INCOMPLETE if the some FormInfo is not complete (or error)</source>
          <target state="translated">일부 FormInfo가 완료되지 않은 경우 (또는 오류) CURL_FORMADD_INCOMPLETE</target>
        </trans-unit>
        <trans-unit id="16321db303d4490b9645491e5cfe20deb293518b" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if a curl_httppost struct cannot be allocated</source>
          <target state="translated">curl_httppost 구조체를 할당 할 수없는 경우 CURL_FORMADD_MEMORY</target>
        </trans-unit>
        <trans-unit id="468f4fa1bb410d0fd70e03f6a5dce8bd45ccdbe3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if some allocation for string copying failed.</source>
          <target state="translated">문자열 복사 할당에 실패한 경우 CURL_FORMADD_MEMORY</target>
        </trans-unit>
        <trans-unit id="244588782f153f2f49d14b88a76a4b1567aa1f97" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the FormInfo allocation fails</source>
          <target state="translated">FormInfo 할당에 실패한 경우 CURL_FORMADD_MEMORY</target>
        </trans-unit>
        <trans-unit id="21b7579474f488d4369aa40ec4d89dc3bb5304c5" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the allocation of a FormInfo struct failed</source>
          <target state="translated">FormInfo 구조체 할당에 실패한 경우 CURL_FORMADD_MEMORY</target>
        </trans-unit>
        <trans-unit id="f486f564c902d8b166b922ce6666a103809fa080" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_NULL if a null pointer was given for a char</source>
          <target state="translated">문자에 널 포인터가 제공된 경우 CURL_FORMADD_NULL</target>
        </trans-unit>
        <trans-unit id="03c087c14e47ce05c5a730cee27884e0f0271510" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OK on success</source>
          <target state="translated">성공시 CURL_FORMADD_OK</target>
        </trans-unit>
        <trans-unit id="657acce1995ce0c4c4cc9704302fc40b3180ce0c" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OPTION_TWICE if one option is given twice for one Form</source>
          <target state="translated">하나의 양식에 대해 하나의 옵션이 두 번 제공되는 경우 CURL_FORMADD_OPTION_TWICE</target>
        </trans-unit>
        <trans-unit id="fb231ca0da85a5247735b55bae68726897d51402" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used</source>
          <target state="translated">알 수없는 옵션이 사용 된 경우 CURL_FORMADD_UNKNOWN_OPTION</target>
        </trans-unit>
        <trans-unit id="c1c36583a3bee413dd4d6eabaaf03906540af6c8" translate="yes" xml:space="preserve">
          <source>CURL_LOCK_DATA_SHARE is used internally to say that the locking is just made to change the internal state of the share itself.</source>
          <target state="translated">CURL_LOCK_DATA_SHARE는 내부적으로 사용되어 공유 자체의 내부 상태를 변경하기 위해 잠금을 수행한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="08d333ae982f2ab5fd05c92959c9f03604998f78" translate="yes" xml:space="preserve">
          <source>CURL_VERSION</source>
          <target state="translated">CURL_VERSION</target>
        </trans-unit>
        <trans-unit id="311de4a4e55e22b4fb916aea606488f2810807f6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;(CURL* curl, CURLINFO info, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt; (CURL * curl, CURLINFO 정보, ...);</target>
        </trans-unit>
        <trans-unit id="732ee216b7a86b2068f3e21e26d039d5ff87d0a6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;(CURL* handle, int bitmask);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt; (CURL * 핸들, int 비트 마스크);</target>
        </trans-unit>
        <trans-unit id="743291b335af5fe8701249accd883cdee309abc2" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt; (CURL * 컬);</target>
        </trans-unit>
        <trans-unit id="5ef9ed35887a97572c7e153166cf3c37d4499135" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt; (CURL * curl, void * 버퍼, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="03f5e5216a441a870631a8ebbf1324f0d53aad46" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt; (CURL * curl, void * 버퍼, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="c2267b7c0b6dd8f394f4e53f9877924630091aa4" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;(CURL* curl, CURLoption option, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt; (CURL * curl, CURLoption 옵션, ...);</target>
        </trans-unit>
        <trans-unit id="856a997055fde5b0daa6466669272d7c21200826" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;(c_long flags);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt; (c_long 플래그);</target>
        </trans-unit>
        <trans-unit id="ad44c3dd1dc580f2f09873c3d8bc4b0f2c99e680" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt; (c_long 플래그, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</target>
        </trans-unit>
        <trans-unit id="47d9bbe805f8580c705596e7003de4a50cbc2583" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;result&quot;&gt;result&lt;/strong&gt;;</source>
          <target state="translated">CURLcode &lt;strong id=&quot;result&quot;&gt;결과&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="304f1ec0769d4c548febbdf47625f266fdcfab5b" translate="yes" xml:space="preserve">
          <source>CURLformoption &lt;strong id=&quot;option&quot;&gt;option&lt;/strong&gt;;</source>
          <target state="translated">CURLformoption &lt;strong id=&quot;option&quot;&gt;옵션&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a4c24fe1a70e51826ba9ae7c30e20cd7e2a29828" translate="yes" xml:space="preserve">
          <source>CURLversion &lt;strong id=&quot;age&quot;&gt;age&lt;/strong&gt;;</source>
          <target state="translated">CURLversion &lt;strong id=&quot;age&quot;&gt;연령&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b4a140e494ddd4ae40e04aab42088b88b1becbfe" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe63bc0735098979cb97ac441f55ea9bf41ba0b" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bacd88197768daee4b3de506c5c3a95e5a62751a" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06ae80fea6ce71846e64d1060826cd17e855a35" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7150792a1546098dee35fe7a98fdfc975256a790" translate="yes" xml:space="preserve">
          <source>Cache size and behaviour</source>
          <target state="translated">캐시 크기 및 동작</target>
        </trans-unit>
        <trans-unit id="f800f99aa3df3800502bbb36ab972cc0eb0d5c0b" translate="yes" xml:space="preserve">
          <source>CacheInfo[5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt;;</source>
          <target state="translated">CacheInfo [5] 데이터 &lt;strong id=&quot;datacache&quot;&gt;캐시&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6bcc4b116e2d06311b0fc9927d035dbff820590a" translate="yes" xml:space="preserve">
          <source>Calculate and return</source>
          <target state="translated">계산 및 반환</target>
        </trans-unit>
        <trans-unit id="3d6ed85fb2e3f634e358f0719e27875d435ea774" translate="yes" xml:space="preserve">
          <source>Calculate built-in properties which just the type is necessary.</source>
          <target state="translated">유형 만 필요한 내장 속성을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="a4aa52fc673bba9caf0d9f71c29d0ae6f9877456" translate="yes" xml:space="preserve">
          <source>Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit field initializers have unique memory space on instance.</source>
          <target state="translated">field [i] .overlapped 및 duplicateUnsafe를 계산하고 모든 명시 적 필드 이니셜 라이저가 인스턴스에서 고유 한 메모리 공간을 가지고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5c68d55b4c8ec705956e2d8e0515e64b113840ed" translate="yes" xml:space="preserve">
          <source>Calculate the base-10 logarithm of x.</source>
          <target state="translated">x의 밑이 10 인 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="aa77a0a0c44f9dd6e1b336ed64c758b221d1485c" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence ending one code unit before &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;index&lt;/code&gt; 전에 하나의 코드 단위로 끝나는 UTF 시퀀스의 길이를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="14c2e14715fa06b8f138716be37c507138d963e7" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence starting at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;index&lt;/code&gt; 로 시작하는 UTF 시퀀스의 길이를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="e12b3a821d4bde6f6cb14b1be6565da8f2b8ddac" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x.</source>
          <target state="translated">x의 자연 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3f112af5d27881f2633fc0efa7c8c3ce5a0a8242" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x. The branch cut is along the negative axis.</source>
          <target state="translated">x의 자연 로그를 계산합니다. 분기 절단은 음의 축을 따라 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30b6367e2a4061ed4b790ec3600b0de931f9e1f" translate="yes" xml:space="preserve">
          <source>Calculate the next largest floating point value after x.</source>
          <target state="translated">x 다음으로 큰 부동 소수점 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b9c742d632c337bd8cbf69961edcf3221964c540" translate="yes" xml:space="preserve">
          <source>Calculate the next smallest floating point value before x.</source>
          <target state="translated">x 전에 다음으로 가장 작은 부동 소수점 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="018fa0870c360e2cac7a8c4bc28e389efc5f1613" translate="yes" xml:space="preserve">
          <source>Calculate the remainder x REM y, following IEC 60559.</source>
          <target state="translated">IEC 60559에 따라 나머지 x REM y를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="3fba25e1430b0ae9ada9b4efe1168d1151f49b29" translate="yes" xml:space="preserve">
          <source>Calculates 2&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">2 &lt;sup&gt;x를&lt;/sup&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="63c1fbfad55eb2f0634d2925033191320d7fe148" translate="yes" xml:space="preserve">
          <source>Calculates e&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">e &lt;sup&gt;x를&lt;/sup&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="552f818572293e7e3df3d8078e1d8502861c8778" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number</source>
          <target state="translated">숫자의 절대 값을 계산합니다</target>
        </trans-unit>
        <trans-unit id="4ec6328d585b956e719618a807b023dcff090ac5" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number.</source>
          <target state="translated">숫자의 절대 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8be2a6f70202c3264162991c74bed6c4baae9236" translate="yes" xml:space="preserve">
          <source>Calculates the arc cosine of x, returning a value ranging from 0 to &amp;pi;.</source>
          <target state="translated">x의 아크 코사인을 계산하여 0에서 &amp;pi; 사이의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d946a27b03ca4cac969d0047946f4fc66affc0fa" translate="yes" xml:space="preserve">
          <source>Calculates the arc sine of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">x의 아크 사인을 계산하여 -&amp;pi; / 2에서 &amp;pi; / 2 사이의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9e1b5526d250f5e8ab8ddc83903cc95d1cc029a" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">x의 아크 탄젠트를 계산하여 -&amp;pi; / 2에서 &amp;pi; / 2 범위의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3783817bf938b83309854c6205d56ee4a302e644" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of y / x, returning a value ranging from -&amp;pi; to &amp;pi;.</source>
          <target state="translated">y / x의 아크 탄젠트를 계산하여 -&amp;pi;에서 &amp;pi; 범위의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1c3e20fd2cd7d94fdcf1efca206597755351a82" translate="yes" xml:space="preserve">
          <source>Calculates the base-2 logarithm of x: log&lt;sub&gt;2&lt;/sub&gt;x</source>
          <target state="translated">x의 밑이 2 인 로그를 계산합니다. log &lt;sub&gt;2&lt;/sub&gt; x</target>
        </trans-unit>
        <trans-unit id="ba562ff7e573b706f15ed8cff069704fa53ed5ac" translate="yes" xml:space="preserve">
          <source>Calculates the cube root of x.</source>
          <target state="translated">x의 세제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c6b3ccb038ca0414c5d73b25ada62fdde6188a5c" translate="yes" xml:space="preserve">
          <source>Calculates the hash value of &lt;code&gt;arg&lt;/code&gt; with an optional &lt;code&gt;seed&lt;/code&gt; initial value. The result might not be equal to &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt;.</source>
          <target state="translated">선택적인 &lt;code&gt;seed&lt;/code&gt; 초기 값 으로 &lt;code&gt;arg&lt;/code&gt; 의 해시 값을 계산합니다 . 결과는 &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt; 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6077e40f1d7c6b4630a9eabd54e9cc9ad6cdbbd5" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic cosine of x.</source>
          <target state="translated">x의 쌍곡 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c3be2955cec737e95210a83c0153e5a7b26737f0" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic sine of x.</source>
          <target state="translated">x의 쌍곡 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="836a3048b7c344efad04edc701d9a39358e4ddc2" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic tangent of x.</source>
          <target state="translated">x의 쌍곡 탄젠트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="26863b4aef8c0a694cd2e723d6778f9f04e7eb52" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic cosine of x.</source>
          <target state="translated">x의 역 쌍곡 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c627e3b3df39ce6438ba816e8a109c0ffed6f76d" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic sine of x.</source>
          <target state="translated">x의 역 쌍곡 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8af98eaa49794884fefd803885cf1f1893246ddf" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1.</source>
          <target state="translated">x의 역 쌍곡 탄젠트를 계산하여 -1에서 1 사이의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c5618c4bbf47d472509dd6366443a216865a98d" translate="yes" xml:space="preserve">
          <source>Calculates the length needed to store the encoded string corresponding to an input of the given length.</source>
          <target state="translated">주어진 길이의 입력에 해당하는 인코딩 된 문자열을 저장하는 데 필요한 길이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="027e373dfea678dcf40ffef9e131551d07153fd8" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y:</source>
          <target state="translated">길이 x와 y의 변을 가진 직각 삼각형의 빗변의 길이를 계산합니다. 빗변은 x와 y의 제곱의 합의 제곱근의 값입니다.</target>
        </trans-unit>
        <trans-unit id="49efa739aec865cfda8564b9080c48989d5e33a7" translate="yes" xml:space="preserve">
          <source>Calculates the natural logarithm of 1 + x.</source>
          <target state="translated">1 + x의 자연 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c06de5b0b0a99a9dfc2d0912c58bdadc98082d6" translate="yes" xml:space="preserve">
          <source>Calculates the next representable value after x in the direction of y.</source>
          <target state="translated">x 다음에 y 방향으로 표현할 수있는 다음 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3754c2ce035cf1b13a7cd37e615749fb652610b4" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</source>
          <target state="translated">X86 SSE4 POPCNT 명령어를 사용하여 정수의 세트 비트 수를 계산합니다. 모든 X86 CPU에서 POPCNT를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="06d72e9a8ced5d5423191cc63ca6b46b4610af0d" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer.</source>
          <target state="translated">정수로 설정된 비트 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9a6eed62af9d1a47c1ab6bc79899d39e32a6483a" translate="yes" xml:space="preserve">
          <source>Calculates the remainder from the calculation x/y.</source>
          <target state="translated">계산 x / y에서 나머지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fe24886c3219456f2196eb244fb852afd4fb56a9" translate="yes" xml:space="preserve">
          <source>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1.</source>
          <target state="translated">x의 제곱에서 1을 뺀 자연 로그 밑 (e)의 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="af2f291e997ca41e56ba422f46bf86ff11ebb79d" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;n&lt;/sup&gt;. The branch cut is on the negative axis.</source>
          <target state="translated">x &lt;sup&gt;n을&lt;/sup&gt; 계산합니다 . 분기 절단은 음의 축에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6cce6873a9a6bb919b268ff433dd1e133a874" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;y&lt;/sup&gt;.</source>
          <target state="translated">x &lt;sup&gt;y를&lt;/sup&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="801ce4a0b5aa9b661ade0819332605cc7b1ae809" translate="yes" xml:space="preserve">
          <source>Call each of the connected slots, passing the argument(s) i to them. Nested call will be ignored.</source>
          <target state="translated">연결된 각 슬롯을 호출하여 인수 i를 전달하십시오. 중첩 된 통화는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9f4deb84100f6aec181820d5a751140cd068c1" translate="yes" xml:space="preserve">
          <source>Call this after printing out fatal error messages to clean up and exit the compiler.</source>
          <target state="translated">치명적 오류 메시지를 인쇄 한 후 호출하여 컴파일러를 정리하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f75e5681020d520d2c6f752e809e81b0c81a85b8" translate="yes" xml:space="preserve">
          <source>CallExp &lt;code&gt;ce&lt;/code&gt;</source>
          <target state="translated">CallExp &lt;code&gt;ce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf7b36d93b4e5475d0f1769a4ea2f0934f697c5" translate="yes" xml:space="preserve">
          <source>Callback for each received StatusLine.</source>
          <target state="translated">수신 된 각 StatusLine에 대한 콜백</target>
        </trans-unit>
        <trans-unit id="f3869aa6b3628e9280e1301a0819ce5b27364caa" translate="yes" xml:space="preserve">
          <source>Callback function for opening socket (instead of socket(2)). Optionally, callback is able change the address or refuse to connect returning CURL_SOCKET_BAD. The callback should have type curl_opensocket_callback</source>
          <target state="translated">소켓을 열기위한 콜백 함수 (소켓 (2) 대신). 선택적으로 콜백은 주소를 변경하거나 CURL_SOCKET_BAD를 반환하는 연결을 거부 할 수 있습니다. 콜백은 curl_opensocket_callback 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa6c180b210d6c195ea47a0f5808f2e991c787e3" translate="yes" xml:space="preserve">
          <source>Callback function for seeking in the input stream</source>
          <target state="translated">입력 스트림에서 찾기위한 콜백 함수</target>
        </trans-unit>
        <trans-unit id="d4829fe836ac65e604efec860420d6bb34e163e7" translate="yes" xml:space="preserve">
          <source>Callback implementation user data</source>
          <target state="translated">콜백 구현 사용자 데이터</target>
        </trans-unit>
        <trans-unit id="7958bba34f83b3f0d9bec51f1aa784c3099f4330" translate="yes" xml:space="preserve">
          <source>Callback options.</source>
          <target state="translated">콜백 옵션.</target>
        </trans-unit>
        <trans-unit id="2c70d267e735763e25416c3729426a88c83fd93c" translate="yes" xml:space="preserve">
          <source>Callback parameters</source>
          <target state="translated">콜백 매개 변수</target>
        </trans-unit>
        <trans-unit id="83da71c0b0c98f854fd142c883ddfbc56d402d5a" translate="yes" xml:space="preserve">
          <source>Callback returns</source>
          <target state="translated">콜백 반환</target>
        </trans-unit>
        <trans-unit id="5277f74ec6b2c07897ae08c4150298f4a47bfee7" translate="yes" xml:space="preserve">
          <source>Callback routine requested an abort</source>
          <target state="translated">콜백 루틴이 중단을 요청했습니다</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="9d7a88bd45dd2018e4f369390635318ba64e842f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad &lt;code&gt;opOpAssign&lt;/code&gt; call (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">잘못된 &lt;code&gt;opOpAssign&lt;/code&gt; 호출 (정밀도를 잃거나 음수 값을 부호없는 유형으로 변환하려고 시도)에 따라 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7102900b536c87cd1ddcccfc7367f11bb9536bf4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is &lt;code&gt;Src&lt;/code&gt; and the destination type is &lt;code&gt;Dst&lt;/code&gt;.</source>
          <target state="translated">잘못된 캐스트 (정밀도를 잃거나 음수 값을 부호없는 유형으로 변환하려고 시도하는 경우)에서 자동으로 호출됩니다. 소스 유형은 &lt;code&gt;Src&lt;/code&gt; 이고 대상 유형은 &lt;code&gt;Dst&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09ced3e78029e52a33dba4c3dc622cbf4db610e5" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast from &lt;code&gt;src&lt;/code&gt; to type &lt;code&gt;Dst&lt;/code&gt; (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에서 &lt;code&gt;Dst&lt;/code&gt; 유형 으로의 잘못된 캐스트 (정밀도를 잃거나 음수 값을 부호없는 유형으로 변환하려고 시도하는 유형)로 자동 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b890f532573803598c95ff0855037312602e65a" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bounds error.</source>
          <target state="translated">경계 오류가 발생하면 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cec93f38cfc349e778449343568f595e85578df6" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues &lt;code&gt;assert(0)&lt;/code&gt; which terminates the application.</source>
          <target state="translated">평등을 비교할 때 자동으로 호출됩니다. 잘못된 비교 (부호있는 음수 값을 부호없는 양의 값과 같게 만드는 것)가 잘못된 경우이 후크는 &lt;code&gt;assert(0)&lt;/code&gt; 을 발행 하여 응용 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0d9a0c46bb6698d633be1a9f6fd1250d9925d992" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to &lt;code&gt;stderr&lt;/code&gt; as a side effect.</source>
          <target state="translated">평등을 비교할 때 자동으로 호출됩니다. 부호있는 음수 값을 부호없는 양수 값과 동일하게 만드는 잘못된 비교의 경우 부작용 으로 &lt;code&gt;stderr&lt;/code&gt; 에 경고 메시지를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c5f36c313c02bf2d55947333ca1b1ce5b5e726cd" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value).</source>
          <target state="translated">평등을 비교할 때 자동으로 호출됩니다. 잘못된 비교 (부호있는 음수 값을 부호없는 양수 값과 동일하게 만드는 것)를 던집니다.</target>
        </trans-unit>
        <trans-unit id="482787b051181ec9851e392f48ceca8d8cc29f3f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 중 하나를 사용하여 주문을 비교할 때 자동으로 호출됩니다 . 비교가 잘못된 경우 (즉, 부호있는 음수 값이 부호없는 양수 값 이상으로 표시됨) 경고 메시지가 &lt;code&gt;stderr&lt;/code&gt; 에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="f347895ce62ab753804db2ed8acefc457ef89fc4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with &lt;code&gt;assert(0)&lt;/code&gt;. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 중 하나를 사용하여 주문을 비교할 때 자동으로 호출됩니다 . 비교가 잘못된 경우 (즉, 부호있는 음수 값이 부호없는 양수 값 이상으로 표시됨) &lt;code&gt;assert(0)&lt;/code&gt; 응용 프로그램이 종료됩니다 . 그렇지 않으면 3 상태 결과가 반환됩니다 ( &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양수 , &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음수 , 그렇지 않은 경우 &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd9dee545de2de37ec8d225d3452d9b9db4a4de3" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a &lt;code&gt;Throw.CheckFailure&lt;/code&gt; exception. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 중 하나를 사용하여 주문을 비교할 때 자동으로 호출됩니다 . 비교가 잘못된 경우 (즉, 부호있는 음수 값이 부호없는 양수 값보다 크거나 같게 &lt;code&gt;Throw.CheckFailure&lt;/code&gt; 예외가 발생합니다. 그렇지 않으면 3 상태 결과가 반환됩니다 ( &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양수 , &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음수 , 그렇지 않은 경우 &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="288a3bb051cf2f7e5a316c4d4e70d5118f188801" translate="yes" xml:space="preserve">
          <source>Called automatically upon an overflow during a unary or binary operation.</source>
          <target state="translated">단항 또는 이진 연산 중에 오버플로가 발생하면 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="18ffd2396df8d946aeaff03367807e9289b502e5" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;accept&lt;/code&gt; when a new &lt;code&gt;Socket&lt;/code&gt; must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned &lt;code&gt;Socket&lt;/code&gt;'s handle must not be set; &lt;code&gt;Socket&lt;/code&gt; has a protected constructor &lt;code&gt;this()&lt;/code&gt; to use in this situation.</source>
          <target state="translated">새 연결을 위해 새 &lt;code&gt;Socket&lt;/code&gt; 만들어야 할 때 &lt;code&gt;accept&lt;/code&gt; 에 의해 호출됩니다 . 파생 클래스를 사용하려면이 메서드를 재정의하고 클래스의 인스턴스를 반환하십시오. 돌려 주어진 &lt;code&gt;Socket&lt;/code&gt; 의 핸들은 설정되어서는 안됩니다. &lt;code&gt;Socket&lt;/code&gt; 에는 이 상황에서 사용할 보호 생성자 &lt;code&gt;this()&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b54f1e19b12e53615e8a653c409ba5ab2951a872" translate="yes" xml:space="preserve">
          <source>Called by D code to throw an exception via</source>
          <target state="translated">를 통해 예외를 발생시키기 위해 D 코드에 의해 호출</target>
        </trans-unit>
        <trans-unit id="1ca7f5a39bbf37ff1a678bd1aa4c79aba11959d4" translate="yes" xml:space="preserve">
          <source>Called by SQLite to clean up pUser</source>
          <target state="translated">pUser를 정리하기 위해 SQLite에 의해 호출</target>
        </trans-unit>
        <trans-unit id="9743db8f1711c6b311db6267994885195b8a6347" translate="yes" xml:space="preserve">
          <source>Called by libcurl whenever the library detects a change in the maximum number of milliseconds the app is allowed to wait before curl_multi_socket() or curl_multi_perform() must be called (to allow libcurl's timed events to take place).</source>
          <target state="translated">라이브러리가 lib_l_Timed 이벤트가 발생하도록 curl_multi_socket () 또는 curl_multi_perform ()을 호출하기 전에 앱이 대기 할 수있는 최대 밀리 초 수의 변경을 감지 할 때마다 libcurl에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3edd2c76a126518315d7a71140c73140e3fc8324" translate="yes" xml:space="preserve">
          <source>Called during runtime initialization to initialize a GC instance of given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;name&lt;/code&gt; 의 GC 인스턴스를 초기화하기 위해 런타임 초기화 중에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6980b4453fbc6893945f9512aa33baa854c12d55" translate="yes" xml:space="preserve">
          <source>Called from back end.</source>
          <target state="translated">백엔드에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f90881b5eb5e600ad18d60ab2849afead809fc76" translate="yes" xml:space="preserve">
          <source>Called once per thread; returns array of thread local storage ranges</source>
          <target state="translated">스레드 당 한 번 호출됩니다. 스레드 로컬 스토리지 범위의 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a912bc6a899a5bd4ea502581245c2ef16bd2966" translate="yes" xml:space="preserve">
          <source>Called when fibers switch contexts.</source>
          <target state="translated">파이버가 컨텍스트를 전환 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c0acd999c318ee36079d9ad700960738ccee34ac" translate="yes" xml:space="preserve">
          <source>Called when setting a version identifier, e.g. &lt;code&gt;-version=identifier&lt;/code&gt; parameter to the compiler or &lt;code&gt;version = Foo&lt;/code&gt; in user code.</source>
          <target state="translated">버전 식별자, 예를 들어 &lt;code&gt;-version=identifier&lt;/code&gt; 매개 변수를 컴파일러로 설정하거나 &lt;code&gt;version = Foo&lt;/code&gt; 를 사용자 코드로 설정할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="495dea06203f25ae26116f2f5772a696918832bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#reset&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; will reset this to &lt;code&gt;Duration.zero&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#reset&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 을 호출 하면이 값이 &lt;code&gt;Duration.zero&lt;/code&gt; 로재설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f23a63a5505f1213693ee8224d96b5310cf3183b" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; with the resulting &lt;code&gt;Pid&lt;/code&gt; is invalid.</source>
          <target state="translated">호출 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; 결과와 &lt;code&gt;Pid&lt;/code&gt; 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="796201301481a494676b87bd22f58df79f6f3bdb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;printf()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="e69ccd3a1a7e462d569968184a6624c2a8f6e037" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reopen&lt;/code&gt; with a &lt;code&gt;null&lt;/code&gt;&lt;code&gt;name&lt;/code&gt; is not implemented in all C runtimes.</source>
          <target state="translated">일부 C 런타임 에서는 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; &lt;code&gt;reopen&lt;/code&gt; 호출 이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a670c32e5ff77bac0fbdbb4ed6c86d3156f5f82" translate="yes" xml:space="preserve">
          <source>Calling C Functions</source>
          <target state="translated">C 함수 호출</target>
        </trans-unit>
        <trans-unit id="2a58b71a9eba354c8a2762dcf96889501c4c8b2f" translate="yes" xml:space="preserve">
          <source>Calling C++ Global Functions from D</source>
          <target state="translated">D에서 C ++ 전역 함수 호출</target>
        </trans-unit>
        <trans-unit id="0af92a8a9a70b3aa97a6e09d334eff695960b293" translate="yes" xml:space="preserve">
          <source>Calling CTFE-able functions or using manifest constants is also possible.</source>
          <target state="translated">CTFE 가능 함수 호출 또는 매니페스트 상수 사용도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ab9616e4fb5ac458c376db23b38a3a4f41bdffa3" translate="yes" xml:space="preserve">
          <source>Calling Global D Functions From C++</source>
          <target state="translated">C ++에서 전역 D 함수 호출</target>
        </trans-unit>
        <trans-unit id="011de1cd8c5a8313b4819150b58f7b77ffe1686b" translate="yes" xml:space="preserve">
          <source>Calling an Instance Method</source>
          <target state="translated">인스턴스 메소드 호출</target>
        </trans-unit>
        <trans-unit id="882cd8e97a7e6dec1b20f7ffc308265e42981f07" translate="yes" xml:space="preserve">
          <source>Calling an Objective-C instance method uses the same syntax as calling regular D methods:</source>
          <target state="translated">Objective-C 인스턴스 메소드 호출은 일반 D 메소드 호출과 동일한 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2837bac68cbbca90ef92df0ecb7045b8bad05e30" translate="yes" xml:space="preserve">
          <source>Calling any system functions.</source>
          <target state="translated">모든 시스템 기능을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="99afec36350160ba55067caa792fb170d47da7f2" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</source>
          <target state="translated">함수 호출 f. @ nogc-ness를 확인하십시오. 즉, @nogc 함수에 있다면 다른 @nogc 함수 만 호출 할 수 있습니다. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="889558fe1d6b373ebfb4108727201ca1efea7bd9" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</source>
          <target state="translated">함수 호출 f. 순도를 확인하십시오. 즉, 순수한 기능을 사용하는 경우 다른 순수한 기능 만 호출 할 수 있습니다. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d07dff2f17d03cbf0372862de2a911c37b1df31" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</source>
          <target state="translated">함수 호출 f. 안전성을 확인하십시오. 예를 들어 @safe 함수 인 경우 @safe 또는 @trusted 함수 만 호출 할 수 있습니다. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="49f72934b9748e8925ba7a574cd2caf074e942d5" translate="yes" xml:space="preserve">
          <source>Calling printf()</source>
          <target state="translated">printf () 호출</target>
        </trans-unit>
        <trans-unit id="06859dbd6f7a9d0b1a468c855675188601e16f52" translate="yes" xml:space="preserve">
          <source>Calling this function sets a flag indicating that this struct is no longer worker-local, and attempting to use the &lt;code&gt;get&lt;/code&gt; method again will result in an assertion failure if assertions are enabled.</source>
          <target state="translated">이 함수를 호출하면이 구조체가 더 이상 작업자 로컬이 아님을 나타내는 플래그 가 설정되고 어설 션이 활성화 된 경우 &lt;code&gt;get&lt;/code&gt; 메서드를 다시 사용하려고 하면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c5e417ef005e02e78fdb802550dfe5fd2fa097a5" translate="yes" xml:space="preserve">
          <source>Calling this function with &lt;code&gt;blocking = true&lt;/code&gt; from a worker thread that is a member of the same &lt;code&gt;TaskPool&lt;/code&gt; that &lt;code&gt;finish&lt;/code&gt; is being called on will result in a deadlock.</source>
          <target state="translated">이 함수 호출 &lt;code&gt;blocking = true&lt;/code&gt; 동일의 구성원 인 작업자 스레드에서 &lt;code&gt;TaskPool&lt;/code&gt; 을 것으로 &lt;code&gt;finish&lt;/code&gt; 교착 상태가 발생합니다에 대한 호출되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a483b09288907bf0c6892b8a0c3a3688580a1534" translate="yes" xml:space="preserve">
          <source>Calling this function, and then using references to data located after the given array results in undefined behavior.</source>
          <target state="translated">이 함수를 호출 한 다음 지정된 배열 뒤에있는 데이터에 대한 참조를 사용하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a48762ee3e2f7b163567b2b8c2bdc321fb3d29c" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일 핸들에 대한 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5fa582845b2a8965acb06e6a0955d839742fab8a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</source>
          <target state="translated">파일 핸들에 대해 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; 를 호출 합니다. 읽을 항목 수와 각 항목의 크기는 각각 입력 배열의 크기와 유형에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="4204f336078b400c2ca8218f3dc707eed9fc8eef" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; for the file handle to move its position indicator.</source>
          <target state="translated">파일 핸들이 위치 표시기를 이동하도록 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b841aa017960fa21330d3bce71d1341f08261fc1" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; for the managed file handle.</source>
          <target state="translated">관리되는 파일 핸들에 대한 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="19416b73e0b0cfe1706209f1904f9557babb3844" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</source>
          <target state="translated">파일 핸들에 대해 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; 를 호출 합니다. 쓸 항목 수와 각 항목의 크기는 각각 입력 배열의 크기와 유형에서 유추됩니다. 버퍼 전체를 쓸 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b50971f4c5e8a0e45c73e7c7c90d36d61fddcb7f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rewind&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일 핸들에 대한 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;되감기&lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6954ffddc60a249c70b2b20272f1b59673a22e6b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일 핸들에 대해 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="660af3415b8af8c796363c6a336c94f83d470574" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (as it must be called or copied in any function overriding &lt;code&gt;newScope&lt;/code&gt;), then set the &lt;code&gt;Scope&lt;/code&gt;'s depdecl.</source>
          <target state="translated">&lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; 를 호출 하고 ( &lt;code&gt;newScope&lt;/code&gt; 를 재정의하는 함수에서 호출하거나 복사해야 함 ) &lt;code&gt;Scope&lt;/code&gt; 의 depdecl 을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea66981f1c839cec218fd677425515ff882faad6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">Posix에서는 &lt;code&gt;free(b.ptr)&lt;/code&gt; 를 호출 하고 Windows에서는 &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="80b24062036e8206a4a3aaaa50eca541bcbb2352" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;https://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e076da4834d8b045458f6ec7dd1c5d3b78bd298c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;impl.deallocateAll()&lt;/code&gt; and returns the result if defined, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.deallocateAll()&lt;/code&gt; 호출 하고 정의 된 경우 결과를 반환하고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0b0309269b86732c6de69ae225028495fc3e76bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order, stopping when either range has been exhausted.</source>
          <target state="translated">통화 &lt;code&gt;move(a, b)&lt;/code&gt; 각 요소에 대한 에서 &lt;code&gt;src&lt;/code&gt; 와 해당 소자 &lt;code&gt;b&lt;/code&gt; 에 &lt;code&gt;tgt&lt;/code&gt; 어느 영역이 소진 된 때 중지 승순. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3aff67db2952371a04e1469cf552b2bafe5ed21" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order.</source>
          <target state="translated">통화 &lt;code&gt;move(a, b)&lt;/code&gt; 각 요소에 대한 에서 &lt;code&gt;src&lt;/code&gt; 와 해당 소자 &lt;code&gt;b&lt;/code&gt; 에 &lt;code&gt;tgt&lt;/code&gt; 증가하는 순서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9326ff35ce625813cb6e134a6874955a7343c986" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;popBack&lt;/code&gt; for all controlled ranges.</source>
          <target state="translated">모든 제어 된 범위에 대해 &lt;code&gt;popBack&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1cb6a5ebd9c3d585d565184c781a892ebfa3d0e5" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol.</source>
          <target state="translated">각 기호마다 dg (Dsymbol * sym)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f0ea91146057c0154bb8b4caec2606cab70e289d" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol. If dg returns !=0, stops and returns that value else returns 0.</source>
          <target state="translated">각 기호마다 dg (Dsymbol * sym)를 호출합니다. dg가! = 0을 반환하면 중지하고 해당 값을 반환하고 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20447109fe962cd134aaca38e701f9a14ee5ab9e" translate="yes" xml:space="preserve">
          <source>Calls the destructor &lt;code&gt;~this()&lt;/code&gt; for the object referred to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a class or interface reference) or for the object pointed to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a pointer to a &lt;code&gt;struct&lt;/code&gt;). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect.</source>
          <target state="translated">소멸자를 호출 &lt;code&gt;~this()&lt;/code&gt; 개체에 의해 참조에 대한 &lt;code&gt;x&lt;/code&gt; (경우 &lt;code&gt;x&lt;/code&gt; 클래스 또는 인터페이스 참조 인) 또는 객체가 가리키는 위해 &lt;code&gt;x&lt;/code&gt; (경우 &lt;code&gt;x&lt;/code&gt; 는 A와 포인터입니다 &lt;code&gt;struct&lt;/code&gt; ). 구조체의 배열은 정의 된 경우 배열의 각 요소에 대해 소멸자를 호출합니다. 소멸자가 정의되지 않은 경우이 단계는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d91be267ab03b3c9611f9cbcd4786308f2144fc6" translate="yes" xml:space="preserve">
          <source>Calls to functions with &lt;code&gt;extern(D)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage&lt;/a&gt; (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</source>
          <target state="translated">과 함수 호출 &lt;code&gt;extern(D)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;링키지&lt;/a&gt; (기본 연결기 임)의 순서로 계산된다 : 첫째, 필요한 경우 호출 할 함수의 주소 (예를 들면 계산 된 함수 포인터 또는 대리인의 경우) 평가 . 그런 다음 인수는 왼쪽에서 오른쪽으로 평가됩니다. 마지막으로 전송이 함수로 전달됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="0645e6f6a8a53952c04e63653f8086d201146bb8" translate="yes" xml:space="preserve">
          <source>Calls to the free standing log functions are not directly forwarded to the global &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;sharedLog&lt;/code&gt;. Actually, a thread local &lt;code&gt;Logger&lt;/code&gt; of type &lt;code&gt;StdForwardLogger&lt;/code&gt; processes the log call and then, by default, forwards the created &lt;code&gt;Logger.LogEntry&lt;/code&gt; to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The thread local &lt;code&gt;Logger&lt;/code&gt; is accessible by the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; property. This property allows to assign user defined &lt;code&gt;Logger&lt;/code&gt;. The default &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt; and it will therefore forward all messages to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; can be used to filter log calls before they reach the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">독립형 로그 기능에 대한 호출은 글로벌 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;sharedLog&lt;/code&gt; 로 직접 전달되지 않습니다 . 실제로 &lt;code&gt;StdForwardLogger&lt;/code&gt; 유형 의 스레드 로컬 &lt;code&gt;Logger&lt;/code&gt; 는 로그 호출을 처리 한 다음 기본적으로 작성된 &lt;code&gt;Logger.LogEntry&lt;/code&gt; 를 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 로 전달합니다 . 스레드 로컬 &lt;code&gt;Logger&lt;/code&gt; 는 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 특성으로 액세스 할 수 있습니다. 이 특성은 사용자 정의 &lt;code&gt;Logger&lt;/code&gt; 를 지정할 수 있습니다 . 기본 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 입니다 &lt;code&gt;LogLevel.all&lt;/code&gt; 있으며 따라서 모든 메시지를 전달합니다 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 로그 호출이 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 에 도달하기 전에 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb904d86116e0af2b9834a7896df4545d587c42c" translate="yes" xml:space="preserve">
          <source>Can also assign class values</source>
          <target state="translated">클래스 값을 지정할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="0e9fa73b910a6a2eb1eaa95a1ab5ac09bd2a00f0" translate="yes" xml:space="preserve">
          <source>Can be called from either the driver or a &lt;code&gt;debug = Ident;&lt;/code&gt; statement. Unlike version identifier, there isn't any reserved debug identifier so no validation takes place.</source>
          <target state="translated">드라이버 또는 &lt;code&gt;debug = Ident;&lt;/code&gt; 에서 호출 할 수 있습니다 . 성명서. 버전 식별자와 달리 예약 된 디버그 식별자가 없으므로 유효성 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38f77fd06cc4025566434eff583d8ad55911f526" translate="yes" xml:space="preserve">
          <source>Can be overridden to support other addresses.</source>
          <target state="translated">다른 주소를 지원하도록 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93c4ede92c61cd906a3c26c9c976c09eb1f2fc5" translate="yes" xml:space="preserve">
          <source>Can start enumeration from a negative position:</source>
          <target state="translated">음수 위치에서 열거를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a5600ddf1629b08398131936e3e9652bd1d2e46" translate="yes" xml:space="preserve">
          <source>Can variable be read and written by CTFE?</source>
          <target state="translated">CTFE에서 변수를 읽고 쓸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3b92458a5ee7b262130f2150d91ab4bffe0cab98" translate="yes" xml:space="preserve">
          <source>Can't run semantic on s now, try again later.</source>
          <target state="translated">s에서 시맨틱을 실행할 수 없습니다. 나중에 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="77dfd2135f4db726c47299bb55be26f7f4525a46" translate="yes" xml:space="preserve">
          <source>Cancel</source>
          <target state="translated">Cancel</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">자동 확장 로딩 취소</target>
        </trans-unit>
        <trans-unit id="33b8203d640b9445058eff13b7f608ffa2a1d260" translate="yes" xml:space="preserve">
          <source>Cannot access &lt;code&gt;__gshared&lt;/code&gt; variables.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; 변수에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="23679ec318316b42991fb0add8c6df84610db970" translate="yes" xml:space="preserve">
          <source>Cannot access unions that have pointers or references overlapping with other types.</source>
          <target state="translated">다른 유형과 겹치는 포인터 또는 참조가있는 공용체에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="486e3c068e9f84acb903fe338c21a7a8da40f7e4" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for class or interface references.</source>
          <target state="translated">클래스 또는 인터페이스 참조에 &lt;code&gt;void&lt;/code&gt; 이니셜 라이저를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="71a9611e8c1a236df296e1967a0f6238ddd70798" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for pointers.</source>
          <target state="translated">포인터에 &lt;code&gt;void&lt;/code&gt; 이니셜 라이저를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="774c0fbc4f368f6c2081f7a0dddc8b68729cb7f6" translate="yes" xml:space="preserve">
          <source>Canonical decomposition. The result is canonically equivalent sequence.</source>
          <target state="translated">정식 분해. 결과는 정식으로 동등한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="aae48ee7b1f403f38486b8bf47778fda77282b5f" translate="yes" xml:space="preserve">
          <source>Canonical name, when &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; 이 사용될 때의 정식 이름 .</target>
        </trans-unit>
        <trans-unit id="ca2d0802f87ef08825202a1ca29c54992dad17b0" translate="yes" xml:space="preserve">
          <source>Capabilities of the CPU the program is running on.</source>
          <target state="translated">프로그램이 실행중인 CPU의 기능.</target>
        </trans-unit>
        <trans-unit id="7e1973f266a216415dc191028046ea7f74365eb7" translate="yes" xml:space="preserve">
          <source>Capacity desired. This constructor is defined only if &lt;code&gt; ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;.</source>
          <target state="translated">원하는 용량. 경우이 생성자은 정의 &lt;code&gt; ParentAllocator&lt;/code&gt; 이 아니다 &lt;code&gt;NullAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70603ccef126aa6da95612288168a613c4bc83f0" translate="yes" xml:space="preserve">
          <source>Capitalize a the first character of a ASCII string.</source>
          <target state="translated">ASCII 문자열의 첫 문자를 대문자로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="7bac59f23d8a421d02552a2b75009a6de4d133eb" translate="yes" xml:space="preserve">
          <source>Capitalize an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or string, meaning convert the first character to upper case and subsequent characters to lower case.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 또는 문자열을 대문자 로 사용하십시오. 즉, 첫 문자를 대문자로, 후속 문자를 소문자로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d87b28abafacc3e31f8a5ef814dc1a89c95adc81" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of &lt;code&gt;s&lt;/code&gt; and convert the rest of &lt;code&gt;s&lt;/code&gt; to lowercase.</source>
          <target state="translated">의 첫 번째 문자 대문자 &lt;code&gt;s&lt;/code&gt; 과의 나머지 변환 &lt;code&gt;s&lt;/code&gt; 소문자로.</target>
        </trans-unit>
        <trans-unit id="63beb67c34339e7c0d71b7c05343dfc0c5c06706" translate="yes" xml:space="preserve">
          <source>Captures a range state.</source>
          <target state="translated">범위 상태를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="b94582323a02af8750c89d9914ff8a094fbada5b" translate="yes" xml:space="preserve">
          <source>Carriage return (U+000D).</source>
          <target state="translated">캐리지 리턴 (U + 000D).</target>
        </trans-unit>
        <trans-unit id="9254c4bba00f5ff69304a7921d3118fcbac7e6b8" translate="yes" xml:space="preserve">
          <source>Case</source>
          <target state="translated">Case</target>
        </trans-unit>
        <trans-unit id="af7c0d9ee5c8a6c4478105142a141d1bad096c35" translate="yes" xml:space="preserve">
          <source>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</source>
          <target state="translated">대소 문자 표현식은 모두 고유 한 값으로 평가되어야합니다. 상수 또는 불변 변수는 모두 다른 이름을 가져야합니다. 값을 공유하면 해당 값을 가진 첫 번째 경우 문이 제어됩니다. 정확히 하나의 기본 명령문이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="be29d0c965453b901d4ad20bdc8e2ddd09f27c5c" translate="yes" xml:space="preserve">
          <source>Case insensitive matching.</source>
          <target state="translated">대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b632747e3a93dfa45ef0653a66ab6ac246268230" translate="yes" xml:space="preserve">
          <source>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed:</source>
          <target state="translated">스위치와 연관된 케이스 명령문 및 기본 명령문은 블록 명령문 내에 중첩 될 수 있습니다. 그들은 가장 바깥 쪽 블록에있을 필요는 없습니다. 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4830655a69813534d85f86f1ac7683b83fc06b02" translate="yes" xml:space="preserve">
          <source>Case-insensitive find of a string</source>
          <target state="translated">대소 문자를 구분하지 않는 문자열 찾기</target>
        </trans-unit>
        <trans-unit id="22a0daee669e27ee86078432c6d32a4c0da14fe0" translate="yes" xml:space="preserve">
          <source>Case-insensitive string comparison (&lt;a href=&quot;#sicmp&quot;&gt;&lt;code&gt;sicmp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#icmp&quot;&gt;&lt;code&gt;icmp&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">대소 문자를 구분하지 않는 문자열 비교 ( &lt;a href=&quot;#sicmp&quot;&gt; &lt;code&gt;sicmp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#icmp&quot;&gt; &lt;code&gt;icmp&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc02e22f8ccf2c7182decb6993c9ab41402098ce" translate="yes" xml:space="preserve">
          <source>Case-sensitivity of the comparison.</source>
          <target state="translated">비교의 대소 문자 구분.</target>
        </trans-unit>
        <trans-unit id="8647c28bed14fb487e34d3da55fb4ace9c3a88fa" translate="yes" xml:space="preserve">
          <source>CaseRangeStatement</source>
          <target state="translated">CaseRangeStatement</target>
        </trans-unit>
        <trans-unit id="f31bf93714d4f8de709a473ac493e8917fd94741" translate="yes" xml:space="preserve">
          <source>CaseSensitive &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">대소 &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82cbdef9815d26de04f79b63bed3258b574ec1e5" translate="yes" xml:space="preserve">
          <source>CaseStatements* &lt;strong id=&quot;cases&quot;&gt;cases&lt;/strong&gt;;</source>
          <target state="translated">CaseStatements * &lt;strong id=&quot;cases&quot;&gt;사례&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93e81c6075ed3230ff50ed8c47578708810401aa" translate="yes" xml:space="preserve">
          <source>Case_Ignorable</source>
          <target state="translated">Case_Ignorable</target>
        </trans-unit>
        <trans-unit id="744f1d9b60891d9266196d1c3e78b1d6da592b82" translate="yes" xml:space="preserve">
          <source>Cased</source>
          <target state="translated">Cased</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="fdce1732b6c6c14b93a5e9a8f896d5e70598b645" translate="yes" xml:space="preserve">
          <source>Cast Expressions</source>
          <target state="translated">캐스트 표현식</target>
        </trans-unit>
        <trans-unit id="1be1f5579be197b60f4cbccf065fa7be7bb581e6" translate="yes" xml:space="preserve">
          <source>Cast Operator Overloading</source>
          <target state="translated">캐스트 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="ca826936bee948f2eb775d1f8e1ae92d516c0afe" translate="yes" xml:space="preserve">
          <source>Cast is not necessary if the type of the variable is inferred. See the example below.</source>
          <target state="translated">변수 유형이 유추되는 경우 캐스트가 필요하지 않습니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25e55b52ee2f3dc95810f24ff7dd2b0e1de46b08" translate="yes" xml:space="preserve">
          <source>CastExpression</source>
          <target state="translated">CastExpression</target>
        </trans-unit>
        <trans-unit id="f137db9c32541b4a024e2e40ec97ea3e4571d7c9" translate="yes" xml:space="preserve">
          <source>Casting a class object to an interface consists of adding the offset of the interface's corresponding vptr to the address of the base of the object. Casting an interface ptr back to the class type it came from involves getting the correct offset to subtract from it from the object.Interface entry at vtbl[0]. Adjustor thunks are created and pointers to them stored in the method entries in the vtbl[] in order to set the this pointer to the start of the object instance corresponding to the implementing method.</source>
          <target state="translated">클래스 객체를 인터페이스에 캐스트하는 것은 인터페이스의 해당 vptr의 오프셋을 객체의 기본 주소에 추가하는 것으로 구성됩니다. 인터페이스 ptr을 클래스 유형으로 다시 캐스팅하는 것은 vtbl [0]의 object.Interface 항목에서 올바른 오프셋을 빼는 것입니다. 이 포인터를 구현 메소드에 해당하는 오브젝트 인스턴스의 시작으로 설정하기 위해 조정자 썽크가 작성되고 vtbl []의 메소드 항목에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="2be16817be1151d2bfd103342ffb9b83c9bc8eec" translate="yes" xml:space="preserve">
          <source>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</source>
          <target state="translated">배열 길이에 요소 크기를 곱한 값이 일치하는 경우에만 동적 배열을 다른 동적 배열로 캐스트합니다. 캐스트는 요소 페인트의 변화에 ​​맞게 배열 길이를 조정하여 유형 페인트로 수행됩니다. 일치하지 않으면 런타임 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="16edfc7539440dbdc02f7a14941c4d5ef8ef9a5e" translate="yes" xml:space="preserve">
          <source>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</source>
          <target state="translated">부동 소수점 리터럴을 한 유형에서 다른 유형으로 캐스트하면 유형이 변경되지만 내부적으로는 일정한 폴딩을 위해 완전히 정밀하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="11324dd9fa7b8d9c53df605d6416fafef2a68188" translate="yes" xml:space="preserve">
          <source>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</source>
          <target state="translated">부동 소수점 값을 정수 유형으로 캐스트하는 것은 절단을 사용하여 정수로 변환하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f259cd40444c3107ae944acf4631f694eae6b61d" translate="yes" xml:space="preserve">
          <source>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast).</source>
          <target state="translated">클래스 유형과의 포인터 유형 캐스트는 유형 페인트 (즉, 재 해석 캐스트)로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="67471401dacb96c319b67d90467f1e1ec414ef57" translate="yes" xml:space="preserve">
          <source>Casting a value</source>
          <target state="translated">가치 캐스팅</target>
        </trans-unit>
        <trans-unit id="c6340b2b57764ca857638ab68adda2ab272e357c" translate="yes" xml:space="preserve">
          <source>Casting an expression to &lt;code&gt;void&lt;/code&gt; type is allowed to mark that the result is unused. On &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt;, it could be used properly to avoid &quot;has no effect&quot; error.</source>
          <target state="translated">표현식을 &lt;code&gt;void&lt;/code&gt; 유형으로 캐스트하면 결과가 사용되지 않음을 표시 할 수 있습니다. 에 &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt; ,이를 방지하기 위해 적절하게 사용될 수있는 오류 &quot;효과가 없습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="01335a9c442d0255ed0b8bd54d5bf5a26e8b8dab" translate="yes" xml:space="preserve">
          <source>Casting operator to integral, &lt;code&gt;bool&lt;/code&gt;, or floating point type. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCast&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt;. Otherwise, casting to &lt;code&gt;bool&lt;/code&gt; yields &lt;code&gt; get != 0&lt;/code&gt; and casting to another integral that can represent all values of &lt;code&gt;T&lt;/code&gt; returns &lt;code&gt;get&lt;/code&gt; promoted to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">연산자를 정수, &lt;code&gt;bool&lt;/code&gt; 또는 부동 소수점 유형으로 캐스팅 합니다. 경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookOpCast&lt;/code&gt; 를 호출은 즉시 반환 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; . 그렇지 않으면, 캐스팅하는 &lt;code&gt;bool&lt;/code&gt; 에 수익률이 &lt;code&gt; get != 0&lt;/code&gt; 과의 모든 값을 나타낼 수있는 또 다른 중요한에 캐스팅 &lt;code&gt;T&lt;/code&gt; 의 반환을 &lt;code&gt;get&lt;/code&gt; 승진 &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563db6d9dd42954287b5cda42119295bd4e28aa4" translate="yes" xml:space="preserve">
          <source>Casting pointers to non-pointers and vice versa is allowed.</source>
          <target state="translated">포인터가 아닌 포인터를 가리키는 포인터는 그 반대의 경우도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c8325b9ae374bf1edc7d50c4d5a016a9981e5a" translate="yes" xml:space="preserve">
          <source>Casting to a &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; replaces the qualifiers to the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual로&lt;/i&gt;&lt;/a&gt; 캐스트 하면 한정자가 &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt; 유형으로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="3d98bf7b9cde5141dc8af74c8c9759ef593ae47b" translate="yes" xml:space="preserve">
          <source>Casting to/from &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; may break type system guarantees. Use with care.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 로 또는 &lt;code&gt;immutable&lt;/code&gt; 캐스팅하면 유형 시스템 보증이 중단 될 수 있습니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b02f79fb40c6ba2556a5ea0081aed386869f0012" translate="yes" xml:space="preserve">
          <source>Casting with no &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; or &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; removes any top level &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;inout&lt;/code&gt; type modifiers from the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; 또는 &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; 없이 캐스팅 하면 &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt; 형식에서 최상위 수준 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt; 또는 &lt;code&gt;inout&lt;/code&gt; 형식 한정자가 제거 됩니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="5591322bc1301d82b541b6b5ad169c351dc74a45" translate="yes" xml:space="preserve">
          <source>Casts a mutable array to an immutable array in an idiomatic manner. Technically, &lt;code&gt;assumeUnique&lt;/code&gt; just inserts a cast, but its name documents assumptions on the part of the caller. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; should only be called when there are no more active mutable aliases to elements of &lt;code&gt; arr&lt;/code&gt;. To strengthen this assumption, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; also clears &lt;code&gt;arr&lt;/code&gt; before returning. Essentially &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indicates commitment from the caller that there is no more mutable access to any of &lt;code&gt;arr&lt;/code&gt;'s elements (transitively), and that all future accesses will be done through the immutable array returned by &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">관용적 인 방식으로 가변 배열을 불변 배열로 캐스팅합니다. 기술적으로 &lt;code&gt;assumeUnique&lt;/code&gt; 는 캐스트 만 삽입하지만 이름은 호출자 측의 가정을 문서화합니다. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 요소에 더 활성 가변 별칭 더있을 경우에만 호출되지 않아야 &lt;code&gt; arr&lt;/code&gt; . 이 가정을 강화하기 위해 가정 하기 전에 &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 도 &lt;code&gt;arr&lt;/code&gt; 을 지 웁니다 . 본질적으로 &lt;code&gt; assumeUnique(arr)&lt;/code&gt; 는 &lt;code&gt;arr&lt;/code&gt; 의 요소에 전 이적으로 변경 가능한 액세스가 없으며 , 향후 모든 액세스는 &lt;code&gt;assumeUnique&lt;/code&gt; 에 의해 반환 된 불변 배열을 통해 수행 된다는 발신자의 약속을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="96fd17cf1de8b408679f9b1db49477fb8f0c66b6" translate="yes" xml:space="preserve">
          <source>Casts that break the type system.</source>
          <target state="translated">타입 시스템을 파괴하는 캐스트.</target>
        </trans-unit>
        <trans-unit id="bc260f3af1fc6e8bf46c5b8f8a854fbc6153096b" translate="yes" xml:space="preserve">
          <source>Cat Expressions</source>
          <target state="translated">고양이 표현</target>
        </trans-unit>
        <trans-unit id="a953a29fa47d85867e2fab2716c48cee491dd470" translate="yes" xml:space="preserve">
          <source>CatExpression</source>
          <target state="translated">CatExpression</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="d3ce6d6c33d89c5cd835012c244acc4d8b858a0e" translate="yes" xml:space="preserve">
          <source>CatchParameter</source>
          <target state="translated">CatchParameter</target>
        </trans-unit>
        <trans-unit id="5e59a1d3b6be9c8f0e29f469cc4ebfb54cc7e205" translate="yes" xml:space="preserve">
          <source>Catches</source>
          <target state="translated">Catches</target>
        </trans-unit>
        <trans-unit id="f1645524550ec6b1dbf604c910de525c1199c393" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and &lt;code&gt;result&lt;/code&gt; is set to the result of the expression.</source>
          <target state="translated">주어진 표현식에서 발생한 예외를 포착하고 반환합니다. 예외가 발생하지 않으면 null이 반환되고 &lt;code&gt;result&lt;/code&gt; 는 식의 결과로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="040c55a2a9c3c731e36a7abc0e21f539bc1f80a5" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">주어진 표현식에서 발생한 예외를 포착하고 반환합니다. 예외가 발생하지 않으면 null이 반환됩니다. &lt;code&gt;E&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d90ffac3b749155c40310e22300174e6246501c0" translate="yes" xml:space="preserve">
          <source>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">주어진 표현식에서 발생한 예외를 포착하고 해당 예외의 msg 속성을 반환합니다. 예외가 발생하지 않으면 null이 반환됩니다. &lt;code&gt;E&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73a0dfe4cefda0d8bb54b75566ce6c7751cb0769" translate="yes" xml:space="preserve">
          <source>Catching C++ Class Objects</source>
          <target state="translated">C ++ 클래스 객체 잡기</target>
        </trans-unit>
        <trans-unit id="df7467bf765f309d90be05cf8631fc4bacfe7590" translate="yes" xml:space="preserve">
          <source>Categories of types</source>
          <target state="translated">유형의 카테고리</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="729cda91611ce285ba0ef14cc4efdd486065b7fa" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an</source>
          <target state="translated">어셈블러가 NOP 명령어를 생성하여 다음 어셈블러 명령어를</target>
        </trans-unit>
        <trans-unit id="147c8bbdbf1f140f88bd53dffd29cf82c9997a05" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an even boundary.</source>
          <target state="translated">어셈블러가 NOP 명령어를 생성하여 다음 어셈블러 명령어를 짝수 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="70c5dda624176ab62b854d62901ed2b2ed8a9f72" translate="yes" xml:space="preserve">
          <source>Causes the compiler to not generate the function prolog and epilog sequences. This means such is the responsibility of inline assembly programmer, and is normally used when the entire function is to be written in assembler.</source>
          <target state="translated">컴파일러가 함수 프롤로그 및 에필로그 시퀀스를 생성하지 않도록합니다. 이는 인라인 어셈블리 프로그래머의 책임이며, 전체 기능을 어셈블러로 작성할 때 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fd6a880ee16bb33003559b204f8a2cff5a9e90c" translate="yes" xml:space="preserve">
          <source>Cc</source>
          <target state="translated">Cc</target>
        </trans-unit>
        <trans-unit id="51f00921e108b6ca8be5e3997778036a6ec831aa" translate="yes" xml:space="preserve">
          <source>Cells in the delimiter row contain hyphens (&lt;code&gt;-&lt;/code&gt;) and optional colons (&lt;code&gt;:&lt;/code&gt;). A &lt;code&gt;:&lt;/code&gt; to the left of the hyphens creates a left-aligned column, a &lt;code&gt;:&lt;/code&gt; to the right of the hyphens creates a right-aligned column (like the example above), and &lt;code&gt;:&lt;/code&gt;'s on both sides of the hyphens create a center-aligned column.</source>
          <target state="translated">(구분 기호 행의 세포는 하이픈 포함 &lt;code&gt;-&lt;/code&gt; ) 및 옵션 콜론 ( &lt;code&gt;:&lt;/code&gt; ). &lt;code&gt;:&lt;/code&gt; 하이픈의 왼쪽은 왼쪽 맞춤 열에서 생성에 &lt;code&gt;:&lt;/code&gt; 하이픈 오른쪽 (위의 예처럼) 오른쪽 맞춤 열을 생성하고 &lt;code&gt;:&lt;/code&gt; 하이픈 양쪽의 센터 -를 만들 정렬 된 열.</target>
        </trans-unit>
        <trans-unit id="20b2af77551ab62ecafee8361a6775168a8911be" translate="yes" xml:space="preserve">
          <source>Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.</source>
          <target state="translated">Centaur Isiah = VIA Nano (패밀리 6, 모델 F)는 고장난 코어입니다.</target>
        </trans-unit>
        <trans-unit id="8408f82534bfffd0ab07188fc9d719f71130e4e0" translate="yes" xml:space="preserve">
          <source>Center &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">필드 &lt;code&gt;width&lt;/code&gt; 문자 너비 &lt;code&gt;s&lt;/code&gt; 가운데를 가운데에 놓습니다. &lt;code&gt;fillChar&lt;/code&gt; 는 그 분야에서 공간을 채우기 위해 사용되는 문자 &lt;code&gt;s&lt;/code&gt; 기입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e74b6056afd83cbdf235c0e1e1aa022d7643f34" translate="yes" xml:space="preserve">
          <source>Center justify &lt;code&gt;r&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;r&lt;/code&gt; doesn't fill.</source>
          <target state="translated">필드 &lt;code&gt;width&lt;/code&gt; 문자 너비 에서 &lt;code&gt;r&lt;/code&gt; 을 맞 춥니 다 . &lt;code&gt;fillChar&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; 이 채우지 않는 필드의 공간을 채우는 데 사용되는 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="fb14d77020e4dbef1a189a81fe3dbc04509cb2d1" translate="yes" xml:space="preserve">
          <source>Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead.</source>
          <target state="translated">독일어 및 그리스어와 같은 특정 알파벳에는 1 : 1 상위-하위 매핑이 없습니다. 대신 전체 문자열을 사용하는 toUpper의 과부하를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64a2e3e9bc5b4cd297d23de932339bb6c474455f" translate="yes" xml:space="preserve">
          <source>Cf</source>
          <target state="translated">Cf</target>
        </trans-unit>
        <trans-unit id="70b3ae21ee59942a0d41812e09cc5d908774f36f" translate="yes" xml:space="preserve">
          <source>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression.</source>
          <target state="translated">여러 번의 호출을 ifThrown에 연결하면 각각의 이전 표현식에서 오류를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="c94dac697486986e71af2c37242755c0937be074" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and POSIX.</source>
          <target state="translated">디렉토리를 &lt;code&gt;pathname&lt;/code&gt; 변경하십시오 . Windows 및 POSIX의 &lt;code&gt;cd&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="458b3d4cc82936041a171ad6f7ca77493ddeb2bd" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and Posix.</source>
          <target state="translated">디렉토리를 &lt;code&gt;pathname&lt;/code&gt; 으로 변경하십시오 . Windows 및 Posix의 &lt;code&gt;cd&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6f314cb3c24c1c8ee48dc8abfd534cc520363d6c" translate="yes" xml:space="preserve">
          <source>Change match (fnmatch-like) callback for wildcard matching</source>
          <target state="translated">와일드 카드 일치를위한 일치 (fnmatch-like) 콜백 변경</target>
        </trans-unit>
        <trans-unit id="e8304f2bae085deed1b3c8125f9fa43407a675db" translate="yes" xml:space="preserve">
          <source>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions.</source>
          <target state="translated">IEEE754 부동 소수점 반올림 모드 및 부동 소수점 하드웨어 예외를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9f333c0a78429177429051909d1f599b48a73b54" translate="yes" xml:space="preserve">
          <source>Change the floating-point hardware rounding mode</source>
          <target state="translated">부동 소수점 하드웨어 반올림 모드 변경</target>
        </trans-unit>
        <trans-unit id="3d9d32d43390d1a2629123edfc32deb49f461b6a" translate="yes" xml:space="preserve">
          <source>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted.</source>
          <target state="translated">열린 데이터베이스에서 키를 변경하십시오. 현재 데이터베이스가 암호화되지 않은 경우이 루틴은이를 암호화합니다. pNew == 0 또는 nNew == 0이면 데이터베이스가 해독됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba310a0f8acd1b8bbbdaa00b70d0bff2f5990f6" translate="yes" xml:space="preserve">
          <source>Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</source>
          <target state="translated">발신자가이 문제를 알 필요가 없도록이 기능을 변경하십시오. 값으로 반환하고 호출자가 항상 struct가 유효한지 여부를 나타내는 기본 ptr을 확인하거나 BlkInfo를 부작용으로 설정하고 성공을 표시하는 부울을 리턴 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="e7d3b1db7f0a311580f3e633ae63903d1a427f37" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; arguments are not propagated to the call site, only to &lt;code&gt;args&lt;/code&gt; in this struct.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 및 &lt;code&gt;out&lt;/code&gt; 인수에 대한 변경 사항 은 호출 사이트에 전파되지 &lt;code&gt;args&lt;/code&gt; 구조체의 인수 에만 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c06a1392ead6cea3258d7b832ab861bbcb2d0e3" translate="yes" xml:space="preserve">
          <source>Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line:</source>
          <target state="translated">옵티마이 저가 반올림 모드가 변경되지 않는다고 가정하므로 함수 중간에서 반올림 모드를 변경하면 부동 소수점 표현식의 최적화를 방해 할 수 있습니다. 함수 시작시에만 반올림 모드를 변경하고 함수가 반환 될 때까지 유지하는 것이 가장 좋습니다. 다음 줄을 추가하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="c6b74142b3b389f15ac5cd805f70960cc3a1abf0" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">문자 [] &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66a912fb521a267fef61e2619d881aa8e9c5935" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">샤아 [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516088a32b97fe8b60ae41af7a9da5ea8c8b89b1" translate="yes" xml:space="preserve">
          <source>Character Entities</source>
          <target state="translated">캐릭터 엔터티</target>
        </trans-unit>
        <trans-unit id="669b19e596ff87d2ed122a5266e7aff0c3d614e2" translate="yes" xml:space="preserve">
          <source>Character Literals</source>
          <target state="translated">문자 리터럴</target>
        </trans-unit>
        <trans-unit id="2760308a0f6d1684065a6510212e96dc91848ae1" translate="yes" xml:space="preserve">
          <source>Character Set</source>
          <target state="translated">문자 세트</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="ad3c933b2dd70972eec55e516f2ae9ffae669d0e" translate="yes" xml:space="preserve">
          <source>Character classification by category and common properties: &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">카테고리 및 공통 특성별로 문자 분류 : &lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt; 및 기타.</target>
        </trans-unit>
        <trans-unit id="1ef00f56499c816e60a9c87369bcd2210570f41d" translate="yes" xml:space="preserve">
          <source>Character input ranges</source>
          <target state="translated">문자 입력 범위</target>
        </trans-unit>
        <trans-unit id="133c67a5c003572ca8daaddcc62800905a7a14d7" translate="yes" xml:space="preserve">
          <source>Character literals are a single character or escape sequence enclosed by single quotes.</source>
          <target state="translated">문자 리터럴은 작은 따옴표로 묶은 단일 문자 또는 이스케이프 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="aa8ec24f3290e6543c77a63504c45b69a0237e5a" translate="yes" xml:space="preserve">
          <source>Character literals are single characters and resolve to one of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;. If the literal is a &lt;code&gt;\u&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;wchar&lt;/code&gt;. If the literal is a &lt;code&gt;\U&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;dchar&lt;/code&gt;. Otherwise, it resolves to the type with the smallest size it will fit into.</source>
          <target state="translated">문자 리터럴은 단일 문자이며 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 유형 중 하나로 해석됩니다 . 리터럴이 &lt;code&gt;\u&lt;/code&gt; 이스케이프 시퀀스 인 경우 &lt;code&gt;wchar&lt;/code&gt; 유형으로 해석됩니다 . 리터럴이 &lt;code&gt;\U&lt;/code&gt; 이스케이프 시퀀스 인 경우 &lt;code&gt;dchar&lt;/code&gt; 유형으로 해석됩니다 . 그렇지 않으면 가장 작은 크기의 유형으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3748669139d2553c2dce70085bc8d87e3b65bf04" translate="yes" xml:space="preserve">
          <source>Character to insert between digits.</source>
          <target state="translated">숫자 사이에 삽입 할 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b03707df5e411692fe21adde8672bde4c3d712ec" translate="yes" xml:space="preserve">
          <source>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</source>
          <target state="translated">문자 특성 클래스는 문자 특성을 지정하고 문자 및 문자 시퀀스에서 특정 조작에 대한 특정 의미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7d08e774321e793244bcf20b89151a8c5636ee9d" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">각 줄의 문자 유형이며 기본값은 &lt;code&gt;char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3ea2c19a4eb8af5f3f4d555aac37a5f0f405718" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;immutable char&lt;/code&gt;.</source>
          <target state="translated">각 줄의 문자 유형으로, 기본값은 &lt;code&gt;immutable char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fe23e4b9b84f174b905f70c10737ea338eb6786" translate="yes" xml:space="preserve">
          <source>Characters and Entities</source>
          <target state="translated">캐릭터와 엔티티</target>
        </trans-unit>
        <trans-unit id="407259c6fa72a57c5df67c0a931d6eaafa218825" translate="yes" xml:space="preserve">
          <source>Characters and Escape Macros</source>
          <target state="translated">캐릭터와 탈출 매크로</target>
        </trans-unit>
        <trans-unit id="e688823a84fa6f43670fb82f99c26f690e6bccb5" translate="yes" xml:space="preserve">
          <source>Cheat Sheet</source>
          <target state="translated">컨닝 지</target>
        </trans-unit>
        <trans-unit id="98fea9560fa564556454626729a76607af1a8cca" translate="yes" xml:space="preserve">
          <source>Check access to d for expression e.d Returns true if the declaration is not accessible.</source>
          <target state="translated">표현식 ed에 대한 d에 대한 액세스 점검 선언에 액세스 할 수없는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="992d8a3514d4f8fb1a7565ecd89e7c7459b088b7" translate="yes" xml:space="preserve">
          <source>Check access to package/module &lt;code&gt;p&lt;/code&gt; from scope &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">범위 &lt;code&gt;sc&lt;/code&gt; 에서 패키지 / 모듈 &lt;code&gt;p&lt;/code&gt; 에 대한 액세스를 확인하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
