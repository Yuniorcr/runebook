<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;opCmp&lt;/code&gt; , &lt;code&gt;toHash&lt;/code&gt; 와 같은 다른 &lt;code&gt;Object&lt;/code&gt; 메소드 에도 동일하게 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="translated">같은 &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt; 아무것도 무시하지 않는 최종 기능을 제외하고는, 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="translated">아무것도 무시하지 않는 최종 함수가 true를 반환한다는 점을 제외하면 &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="translated">구조체도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="translated">블록, 스크립트 또는 이진 속성에서 동일한 조회이지만 런타임에 수행됩니다. 이 버전은 &lt;code&gt;name&lt;/code&gt; 미리 알 수없는 경우에 제공됩니다 . 그렇지 않으면 컴파일 타임 검사 &lt;a href=&quot;#opDispatch&quot;&gt; &lt;code&gt;opDispatch&lt;/code&gt; &lt;/a&gt; 가 일반적으로 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="translated">운영자의 포화 결과.</target>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="translated">스캐너 기능. p1에서 p2-1까지 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="translated">스캔 기능.</target>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="translated">이 스레드의 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="translated">범위 특성이 상속되므로 범위 클래스에서 파생 된 모든 클래스도 범위입니다.</target>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="translated">두번째</target>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="translated">비교할 두 번째 배열</target>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="translated">두 번째 형식은 &lt;code&gt;return&lt;/code&gt; 을 &lt;code&gt;ref&lt;/code&gt; 에 첨부하고 추가 &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;범위 매개 &lt;/a&gt;&lt;a href=&quot;#return-ref-parameters&quot;&gt;변수&lt;/a&gt; 의미를 갖는 리턴 ref 매개 변수 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="translated">이 함수의 두 번째 형식은 일반적으로 직접 호출되지 않습니다. 대신 아래 예제와 같이 &lt;a href=&quot;std_string#format&quot;&gt; &lt;code&gt;std.string.format&lt;/code&gt; 을&lt;/a&gt; 통해 사용 됩니다. 지원되는 형식 문자는 'e', ​​'f', 'g', 'a'및 's'입니다.</target>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">두 번째 양식은 &lt;code&gt;goto default;&lt;/code&gt; , 둘러싸는 &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; 의 가장 안쪽 &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; 로 전송합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="translated">두 번째 기능</target>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="translated">두 번째는 템플릿 믹스 인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="translated">시간의 두 번째 부분;</target>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="translated">두 번째 범위</target>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="translated">비교할 두 번째 범위입니다.</target>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="translated">두 번째 범위.</target>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="translated">유형 이름을받는 두 번째 유형</target>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AutoImplement&lt;/code&gt; 의 두 번째 버전은 &lt;code&gt;BaseClass&lt;/code&gt; 에서 파생되는 동안 자동으로 &lt;code&gt;Interface&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">함수의 두 번째 버전은 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 데이터를 &lt;code&gt;sharedLog&lt;/code&gt; 에 기록합니다 . 결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">두 번째 버전은 &lt;code&gt;haystack&lt;/code&gt; 에서 &lt;code&gt;needle&lt;/code&gt; 이 발생한 횟수를 반환합니다 . 임의의 범위에서 빈 범위의 개수가 무한 &lt;code&gt;needle.empty&lt;/code&gt; 인 경우 예외를 발생 시킵니다 . 겹친 카운트는 고려되지 않습니다. 예를 들어 &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 가 아니라 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="translated">두 번째 방법은 데이터를 불변으로 캐스트하는 것입니다. 그렇게 할 때, 동일한 데이터에 대한 변경 가능한 참조가 캐스트 후 데이터를 수정하는 데 사용되지 않도록하는 것은 프로그래머의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="translated">두 번째 방법은 정밀도 지정자를 사용하는 것입니다. 길이가 먼저오고 포인터가옵니다.</target>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="translated">대기중인 기록기가 있으면 두 번째는 판독기를 대기시킵니다. 작가는 한 번에 하나씩 통과하고 작가가 없으면 대기중인 모든 독자에게 경고합니다.</target>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="translated">Objective-C 메소드의 선택기 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">양방향 범위의 의미 (컴파일 중에는 확인할 수 없음)는 다음과 같다고 가정합니다 ( &lt;code&gt;r&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 유형의 객체 임 ).</target>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="translated">포워드 범위의 의미 (컴파일 중에는 확인할 수 없음)는 입력 범위와 동일하며, 범위 오브젝트의 사본을 &lt;code&gt;save&lt;/code&gt; 과 함께 저장 한 후 나중에 사용하여 역 추적이 가능해야하는 추가 요구 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="translated">모듈의 의미는 가져 오는 대상의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">랜덤 액세스 범위의 의미 (컴파일 중에는 확인할 수 없음)는 다음과 같다고 가정합니다 ( &lt;code&gt;r&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 유형의 오브젝트 임 ).</target>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="translated">세마포어 모듈은 동기화를 위해 일반적으로 사용되는 세마포어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="translated">토큰 시퀀스는 구문 분석 트리를 구성하기 위해 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BOM&lt;/code&gt; 을 확인하는 순서</target>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="translated">이 옵션의 짧은 기호</target>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="translated">뒤섞인 임의 접근 범위.</target>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="translated">&amp;Gamma; (x)의 부호.</target>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="translated">이 함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="translated">부호있는 유형이 부호없는 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 당 유사성 은 문자열이 실제로 매우 유사하지 않더라도 두 문자열의 길이에 따라 증가한다는 문제가 있습니다. 예를 들어, 범위는 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; 범위 점점 비슷 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; 의 이상의 인스턴스로서 &lt;code&gt;&quot;world&quot;&lt;/code&gt; 첨부되고 . 이를 방지하기 위해 &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; 는 &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt; 로 계산 된 유사성의 정규화 된 버전을 계산 합니다. &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (소위 정규화 된 커널) 함수 는 함수 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;[0, 1]&lt;/code&gt; 은 어떤 위치에서도 일치하지 않는 범위에 대해서만, 동일한 범위에 대해서는 &lt;code&gt;1&lt;/code&gt; 에 도달 합니다.</target>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="translated">가져 오기의 가장 간단한 형태는 가져올 모듈을 나열하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="translated">가장 간단한 불변 선언은이를 저장 클래스로 사용합니다. 매니페스트 상수를 선언하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 의 가장 간단한 사용법은 버퍼에서 요소를 회전시키는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">사인 및 코사인 &lt;code&gt;z&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="1ad591c3d3f25fb3fd9de0046684571acd9030d0" translate="yes" xml:space="preserve">
          <source>The sine, cosine and tangent of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 사인, 코사인 및 탄젠트입니다 .</target>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="translated">확인할 단일 요소입니다.</target>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="translated">검사 할 단일 바늘로, 단일 요소 또는 요소의 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="translated">추가 할 블록의 크기 (바이트)입니다. sz가 0이면 아무 작업도 수행되지 않습니다. p가 null이면 sz는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="translated">확장이 발생하지 않은 경우 p 또는 0으로 참조되는 확장 메모리 블록의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="translated">오류시 p 또는 0으로 참조되는 메모리 블록의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a5ec735b95eb9947e1d6e43682f1263ddf71f814" translate="yes" xml:space="preserve">
          <source>The size of a system page in bytes.</source>
          <target state="translated">시스템 페이지의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="translated">각 블록의 크기는 컴파일 중 또는 런타임 중에 선택할 수 있습니다. 정적으로 알려진 블록 크기는 실제로 빈번하며 성능이 약간 향상됩니다. 블록 크기를 정적으로 선택하려면 &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt; 에서 와 같이 블록 크기를 &lt;code&gt;blockSize&lt;/code&gt; 매개 변수로 전달하십시오 . 블록 크기 매개 변수를 선택하려면 &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; 사용 하고 블록 크기를 생성자에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="translated">각 청크의 크기</target>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="translated">바이트 단위의 파일 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="translated">끝에 할당 된 길이의 크기는 블록 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="translated">평가 된 요소를 저장할 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="translated">청크의 크기</target>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="translated">형식화 된 문자열을 포함하는 &lt;code&gt;buf&lt;/code&gt; 조각입니다 .</target>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="translated">실제로 읽은 데이터를 포함하는 &lt;code&gt;buffer&lt;/code&gt; 조각입니다 . 버퍼가 채워지기 전에 EOF에 도달하면 &lt;code&gt;buffer&lt;/code&gt; 보다 짧습니다 .</target>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="translated">복사 된 요소를 포함하는 &lt;code&gt;target&lt;/code&gt; 조각입니다 .</target>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="translated">디코딩 된 결과를 포함하는 버퍼 슬라이스입니다.</target>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="translated">인코딩 된 문자열을 포함하는 버퍼 조각입니다.</target>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="translated">왼쪽의 슬라이스와 오른쪽의 슬라이스는 겹치지 않아야합니다. 배열 슬라이스에 요소가없는 경우에도 모든 피연산자가 정확히 한 번 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="translated">슬라이스의 사용 가능한 크기가 블록 크기와 일치하지 않습니다. 실제 사용 가능한 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 을 검색 하려면 용량 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="translated">할당 할 수있는 가장 작은 크기는 2 워드 (64 비트 시스템의 경우 16 바이트, 32 비트 시스템의 경우 8 바이트)입니다. 자유 목록 관리에는 두 단어가 필요하기 때문입니다 (하나는 길이, 다른 하나는 단일 링크 목록의 다음 포인터).</target>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="translated">소위 &quot;전장 간격 가중 문자열 커널&quot;은 다음과 같은 유사성을 계산합니다. &lt;code&gt;s&lt;/code&gt; 모든 길이의 공통 하위 시퀀스를 모두 기반으로 s 와 &lt;code&gt;t&lt;/code&gt; 의 . 갭 서브 시퀀스도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="translated">해결책은 예외 처리를 사용하여 오류를보고하는 것입니다. 모든 에러는 추상 클래스 &lt;code&gt;Error&lt;/code&gt; 에서 파생 된 객체 입니다. &lt;code&gt;Error&lt;/code&gt; 에는 toString ()이라는 순수한 가상 함수 가 있으며 사람이 읽을 수있는 오류에 대한 설명이 포함 된 &lt;code&gt;string&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="translated">정렬 된 별칭 시퀀스</target>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="translated">정렬 할 랜덤 액세스 범위의 정렬 된 왼쪽입니다.</target>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">할당 할 소스 &lt;code&gt;Tuple&lt;/code&gt; 입니다. 소스 &lt;code&gt;Tuple&lt;/code&gt; 의 각 요소는 대상 &lt;code&gt;Tuple&lt;/code&gt; 의 각 요소에 내재적으로 지정 가능해야합니다. .</target>
        </trans-unit>
        <trans-unit id="04c2f4edcae02e1187a2d950f9afa01879a679fc" translate="yes" xml:space="preserve">
          <source>The source file is checked to determine its encoding and the appropriate scanner is loaded. 7-bit ASCII and UTF encodings are accepted.</source>
          <target state="translated">소스 파일을 검사하여 인코딩을 확인하고 적절한 스캐너가로드됩니다. 7 비트 ASCII 및 UTF 인코딩이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="translated">소스 파일에서 문자 세트를 확인하고 적절한 스캐너가로드되었는지 확인합니다. ASCII 및 UTF 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="720cc790393ba54be158f390e51929cd3fbb4795" translate="yes" xml:space="preserve">
          <source>The source file is divided into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">소스 파일은 일련의 토큰으로 나뉩니다. &lt;a href=&quot;lex#specialtokens&quot;&gt;특수 토큰&lt;/a&gt; 은 다른 토큰 으로 대체됩니다. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; 는 처리 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">소스 파일은 일련의 토큰으로 나뉩니다. &lt;a href=&quot;lex#specialtokens&quot;&gt;특수 토큰&lt;/a&gt; 은 다른 토큰 으로 대체됩니다. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;특별 토큰 순서&lt;/i&gt;&lt;/a&gt; 가 처리 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="translated">발신자의 소스 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="translated">발신자의 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="translated">소스 위치</target>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="translated">소스 객체</target>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="translated">캐스트의 소스</target>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="translated">소스 범위.</target>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">소스 텍스트는 소스 표현에서 유니 코드 &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;문자&lt;/i&gt;&lt;/a&gt; 로 디코딩됩니다 . &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;캐릭터&lt;/i&gt;&lt;/a&gt; : S 추가로 분할된다 &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;공백&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;코멘트&lt;/i&gt;&lt;/a&gt; 들, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; S, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;토큰&lt;/i&gt;&lt;/a&gt; 모든 이어 S &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80e2eeed7c3f3243964c7d881365f7f9018dc7a1" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, and &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, with the source terminated by an &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">소스 텍스트는 소스 표현에서 Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt; 로 디코딩됩니다 . &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;캐릭터&lt;/i&gt;&lt;/a&gt; : S 추가로 분할된다 &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;공백&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;코멘트&lt;/i&gt;&lt;/a&gt; 들, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; S 및 &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;토큰&lt;/i&gt;&lt;/a&gt; 종료 소스와 S &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3bd371bebb79ced3649c783e9ef8bd79386c89d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch algorithm, i.e., the lexical analyzer makes the longest possible token. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">소스 텍스트는 최대 뭉크 알고리즘을 사용하여 토큰으로 분할됩니다. 즉, 어휘 분석기가 가능한 가장 긴 토큰을 만듭니다. 예를 들어 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 오른쪽 시프트 토큰이며 토큰보다 두 개가 크지 않습니다. 이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">소스 텍스트는 최대 뭉크 기술을 사용하여 토큰으로 분할됩니다. 즉, 어휘 분석기는 가능한 가장 긴 토큰을 만듭니다. 예를 들어 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 토큰보다 2보다 크지 않은 올바른 시프트 토큰입니다. 이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="translated">소스 텍스트는 둘 중 먼저 오는 것으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="translated">변환 또는 비교의 소스 유형</target>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="translated">로그 메시지를 기록하는 데 사용되는 특정 &lt;code&gt;LogLevel&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="translated">임베디드 문서 주석 형태의 스펙은 컴파일러에 정보를 제공하는 방법 만 지정합니다. 정보가 사용되는 방법과 최종 프레젠테이션 형식에 따라 구현 정의됩니다. 최종 프리젠 테이션 양식이 HTML 웹 페이지인지 맨 페이지인지 PDF 파일인지 등은 D 프로그래밍 언어의 일부로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">의 제곱근 &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0df139a9fed00ace05dd03db279a17a8b348a2" translate="yes" xml:space="preserve">
          <source>The squared magnitude of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 제곱 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 제곱 계수입니다 . 일반성을 위해 실수로 호출하면 제곱을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="translated">스택 및 / 또는 레지스터를 스캔 중입니다.</target>
        </trans-unit>
        <trans-unit id="7f3ea7f5b668b927908903c59ab3b69fcb5af861" translate="yes" xml:space="preserve">
          <source>The stack size for this fiber.</source>
          <target state="translated">이 파이버의 스택 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d77b689dcb1ab13845e33f5ac0d239d2be984a77" translate="yes" xml:space="preserve">
          <source>The stack size for this thread.</source>
          <target state="translated">이 스레드의 스택 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1902c662d9b13b82fe81369d128dde4e10ffcdaa" translate="yes" xml:space="preserve">
          <source>The stack trace of where the error happened. This is an opaque object that can either be converted to &lt;code&gt;string&lt;/code&gt;, or iterated over with &lt;code&gt; foreach&lt;/code&gt; to extract the items in the stack trace (as strings).</source>
          <target state="translated">오류가 발생한 위치의 스택 추적 이것은 &lt;code&gt;string&lt;/code&gt; 로 변환 되거나 &lt;code&gt; foreach&lt;/code&gt; 로 반복 되어 스택 추적에서 항목을 추출합니다 (문자열).</target>
        </trans-unit>
        <trans-unit id="9f20dc3ac3213d71596e365d3a32376deda65355" translate="yes" xml:space="preserve">
          <source>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a</source>
          <target state="translated">중첩 함수가 참조하는 스택 변수는 함수가 종료 된 후에도 여전히 유효합니다 (D 1.0과 다릅니다). 이것은</target>
        </trans-unit>
        <trans-unit id="813353f101357b03d0b61c073a4c5ccf1975eaf3" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="translated">표준 HTTP 메소드 : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 섹션 5.1.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39497b20674a1c136623bd3a720f591f80537d17" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2cd87a2b0f4860fcc1853c1fefdfb3d5a3f6e" translate="yes" xml:space="preserve">
          <source>The standard error stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's error stream.</source>
          <target state="translated">자식 프로세스의 표준 오류 스트림. 쓰기 위해 열린 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 . 기본적으로 자식 프로세스는 부모의 오류 스트림을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">표준 오류 스트림.</target>
        </trans-unit>
        <trans-unit id="28e8c3771deea57b1287ddecdda74142b64d7ee8" translate="yes" xml:space="preserve">
          <source>The standard input stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for reading. By default the child process inherits the parent's input stream.</source>
          <target state="translated">자식 프로세스의 표준 입력 스트림. 읽기 위해 열린 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 . 기본적으로 자식 프로세스는 부모의 입력 스트림을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">표준 입력 스트림</target>
        </trans-unit>
        <trans-unit id="7f5d48c8b0f2de69f4c747237a77a2d1bfba7b08" translate="yes" xml:space="preserve">
          <source>The standard library lends a hand for comparing strings with mixed encodings (by transparently decoding, see &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt;&lt;code&gt;std.algorithm.cmp&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;case-insensitive comparison&lt;/a&gt; and &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;normalization&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리는 문자열을 혼합 인코딩 (투명하게 디코딩하여 &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt; &lt;code&gt;std.algorithm.cmp&lt;/code&gt; &lt;/a&gt; 참조 ), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;대소 문자를 구분하지 않는 비교&lt;/a&gt; 및 &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;정규화&lt;/a&gt; 와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d461322cb73ba656cc10ee6e78ac236193d95ae6" translate="yes" xml:space="preserve">
          <source>The standard output stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's output stream.</source>
          <target state="translated">자식 프로세스의 표준 출력 스트림. 쓰기 위해 열린 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 . 기본적으로 자식 프로세스는 부모의 출력 스트림을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">표준 출력 스트림</target>
        </trans-unit>
        <trans-unit id="21e7fda428c2c6b1ed80304e44601e7fae93a662" translate="yes" xml:space="preserve">
          <source>The start tag of the element</source>
          <target state="translated">요소의 시작 태그</target>
        </trans-unit>
        <trans-unit id="e872d9d6a6689ad057f6c088df86c8dbaa1e7c70" translate="yes" xml:space="preserve">
          <source>The starting point of the interval. It is included in the interval.</source>
          <target state="translated">간격의 시작점. 간격에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3554fc05aa3ab3a9ddf7ec9973a0bf7f4072e5a0" translate="yes" xml:space="preserve">
          <source>The starting value.</source>
          <target state="translated">시작 값.</target>
        </trans-unit>
        <trans-unit id="a84bd1411e0ff3c732833affc83038a36b88c2e4" translate="yes" xml:space="preserve">
          <source>The state of the sequence is stored as a &lt;code&gt;Tuple&lt;/code&gt; so it can be heterogeneous.</source>
          <target state="translated">시퀀스의 상태는 &lt;code&gt;Tuple&lt;/code&gt; 로 저장 되므로 이기종이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8013cbe10851e46bc860bd1d31ef9871f35e223" translate="yes" xml:space="preserve">
          <source>The state of this fiber as an enumerated value.</source>
          <target state="translated">열거 된 값으로이 섬유의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="debdb4248e291669b86fe314e231ec5f465f64cb" translate="yes" xml:space="preserve">
          <source>The std time to convert.</source>
          <target state="translated">변환 할 표준 시간입니다.</target>
        </trans-unit>
        <trans-unit id="e0b383e1171d8d015f97f2490da3a859a852e7d9" translate="yes" xml:space="preserve">
          <source>The stored &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">저장된 &lt;code&gt;Logger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d23198b78726b12c064950153015ab0cde6faecb" translate="yes" xml:space="preserve">
          <source>The strategy for finding the next available block is first fit.</source>
          <target state="translated">사용 가능한 다음 블록을 찾는 전략이 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c2420fb1448496dbbd08ceea8e09dc60562adfb8" translate="yes" xml:space="preserve">
          <source>The stream to pass to INTERLEAVEFUNCTION.</source>
          <target state="translated">INTERLEAVEFUNCTION에 전달할 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="translated">끈</target>
        </trans-unit>
        <trans-unit id="e64ff94f3ecfd8fab9d37892f66980e617d6433b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;command&lt;/code&gt; is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;command&lt;/code&gt; 은 셸에 그대로 전달되므로 명령 구조, 인수 / 파일 이름 인용 및 특수 문자 이스케이프에 대한 규칙이 적용됩니다. 쉘 실행 파일의 경로는 기본적으로 &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="601595000f8c78875086bc48ab40c9c94bc17a1c" translate="yes" xml:space="preserve">
          <source>The string arguments must only contain valid characters for C++ name mangling which currently include alphanumerics and the underscore character.</source>
          <target state="translated">문자열 인수는 현재 영숫자 및 밑줄 문자를 포함하는 C ++ 이름 변경에 유효한 문자 만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bf86f45ac17363df2917e94c577fdefa4162b88" translate="yes" xml:space="preserve">
          <source>The string indicating which characters to replace and what to replace them with. It is generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대체 할 문자와 대체 할 문자를 나타내는 문자열입니다. &lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; 에&lt;/a&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0533873999a54cfe4dbbd386fac2585e64d8e51" translate="yes" xml:space="preserve">
          <source>The string is meant to be human readable, not machine parseable (e.g. whether there is an &lt;code&gt;'s'&lt;/code&gt; on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is &lt;code&gt;zero&lt;/code&gt;). Any code needing a specific string format should use &lt;code&gt;total&lt;/code&gt; or &lt;code&gt;split&lt;/code&gt; to get the units needed to create the desired string format and create the string itself.</source>
          <target state="translated">이 문자열은 기계로 해석 할 수 없으며 사람이 읽을 수 있어야합니다 (예 : 단위 이름 끝에 &lt;code&gt;'s'&lt;/code&gt; 가 있는지 여부는 일반적으로 복수인지 여부에 따라 달라지며 Duration이 &lt;code&gt;zero&lt;/code&gt; 이 아니면 빈 단위는 포함되지 않습니다 ). 특정 문자열 형식이 필요한 코드는 &lt;code&gt;total&lt;/code&gt; 또는 &lt;code&gt;split&lt;/code&gt; 을 사용하여 원하는 문자열 형식을 만들고 문자열 자체를 만드는 데 필요한 단위를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="2bd07e9629d13f3f409b884d3ffac3a7eb0da845" translate="yes" xml:space="preserve">
          <source>The string literal specifies a linker directive to be embedded in the generated object file.</source>
          <target state="translated">문자열 리터럴은 생성 된 오브젝트 파일에 임베드 될 링커 지시문을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="32d9e6c3c8e59228cc1e78ece5ad6aef58df9887" translate="yes" xml:space="preserve">
          <source>The string literals are assembled as UTF-8 char arrays, and the postfix is applied to convert to wchar or dchar as necessary as a final step.</source>
          <target state="translated">문자열 리터럴은 UTF-8 문자 배열로 어셈블되며 마지막 단계에서 필요에 따라 접미사가 wchar 또는 dchar로 변환되도록 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1f9801101f016db2a559c014cb349546f881701" translate="yes" xml:space="preserve">
          <source>The string representation of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">이것의 캐릭터 라인 표현 &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95ecc1c83a5bc8c9a30b488436872240eb5cf883" translate="yes" xml:space="preserve">
          <source>The string that conventionally marks the end of all options (default '--').</source>
          <target state="translated">일반적으로 모든 옵션의 끝을 표시하는 문자열 (기본값 '-')</target>
        </trans-unit>
        <trans-unit id="a364f528b991ce1bd157c8e5da1cb5665c7d72c5" translate="yes" xml:space="preserve">
          <source>The string to be decoded</source>
          <target state="translated">디코딩 할 문자열</target>
        </trans-unit>
        <trans-unit id="a6de95ac63fa71760fd1a5b11770046f783a2524" translate="yes" xml:space="preserve">
          <source>The string to be encoded</source>
          <target state="translated">인코딩 할 문자열</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">대문자로 지정할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="cf1478823e2820a59dba10485e438b40c5348725" translate="yes" xml:space="preserve">
          <source>The string to center</source>
          <target state="translated">중앙에 문자열</target>
        </trans-unit>
        <trans-unit id="2e9ccd0a631efea8fdc72a8c62875a331c029bd3" translate="yes" xml:space="preserve">
          <source>The string to demangle.</source>
          <target state="translated">디밍 글 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b67968a1752f9ee5eb2c12fda8191f64a6136ec4" translate="yes" xml:space="preserve">
          <source>The string to parse</source>
          <target state="translated">파싱 ​​할 문자열</target>
        </trans-unit>
        <trans-unit id="5681bac273a271a57db9a94a9ee8c1380568e850" translate="yes" xml:space="preserve">
          <source>The string to return the representation of.</source>
          <target state="translated">표현을 돌려주는 캐릭터 라인.</target>
        </trans-unit>
        <trans-unit id="6f72b4c4ff92e79f46043b6ac90fd712bc168dfd" translate="yes" xml:space="preserve">
          <source>The string used to separate the elements of an array or associative array (default is &quot;&quot; which means the elements are separated by whitespace).</source>
          <target state="translated">배열 또는 연관 배열의 요소를 구분하는 데 사용되는 문자열입니다 (기본값은 &quot;&quot;이며 요소가 공백으로 구분됨).</target>
        </trans-unit>
        <trans-unit id="555d16dee4415f5ab0acc21725fda20143e994af" translate="yes" xml:space="preserve">
          <source>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements.</source>
          <target state="translated">스트립 기능 그룹을 사용하면 선행, 후행 또는 선행 및 후행 요소를 모두 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b660c2a16b28679d8eef710bda4717a0e26225" translate="yes" xml:space="preserve">
          <source>The structs &lt;code&gt;Yes&lt;/code&gt; and &lt;code&gt;No&lt;/code&gt; are provided as shorthand for &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; and &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a &lt;code&gt;Flag&lt;/code&gt; as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured &lt;code&gt;bool&lt;/code&gt; parameters is classified under &quot;simple-data coupling&quot; by Steve McConnell in the &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. &lt;code&gt;Flag&lt;/code&gt; offers a simple structuring method for passing yes/no flags to APIs.</source>
          <target state="translated">&lt;code&gt;Yes&lt;/code&gt; 와 &lt;code&gt;No&lt;/code&gt; 구조체 는 &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; 와 &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; 약어로 제공되며 간결성과 가독성을 위해 선호됩니다. 이러한 편의 구조 는 긍정적 또는 부정적 옵션을 지정하는 동안 전체 유형을 입력하지 않는 방법으로 &lt;code&gt;Flag&lt;/code&gt; 별명을 작성하는 것이 일반적으로 불필요하고 비생산적임을 의미합니다 . 구조화되지 않은 &lt;code&gt;bool&lt;/code&gt; 매개 변수를 사용 하여 범주 형 데이터를 전달 하는 것은 &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; 책 의 Steve McConnell이 &quot;단순 데이터 결합&quot; 과 3 가지 다른 종류의 결합으로 분류합니다. 저자는 커플 링이 코드 품질에 부정적인 영향을 미친다는 몇 가지 연구를 인용했다. &lt;code&gt;Flag&lt;/code&gt; 예 / 아니오 플래그를 API에 전달하기위한 간단한 구조화 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="076392e866b208f90ee610d973e43efceb10e97e" translate="yes" xml:space="preserve">
          <source>The subclass of EncodingScheme to register.</source>
          <target state="translated">등록 할 EncodingScheme의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="c1ed1f004de54db1586dcfe56503caa35fb79f44" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;sizes&lt;/code&gt; must be equal 21.</source>
          <target state="translated">&lt;code&gt;sizes&lt;/code&gt; 의 합은 21과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="789facc231279c33347577b57e2a474fbfbd6abb" translate="yes" xml:space="preserve">
          <source>The sum of all bit lengths in one bitfield instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name.</source>
          <target state="translated">하나의 비트 필드 인스턴스화에서 모든 비트 길이의 합은 정확히 8, 16, 32 또는 64 여야합니다. 패딩이 필요한 경우 하나의 비트 필드를 빈 이름으로 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="2cfe229a83e79df357cdfd328b79e038bc593b6f" translate="yes" xml:space="preserve">
          <source>The sum of all the elements in the range r.</source>
          <target state="translated">r 범위에있는 모든 요소의 합입니다.</target>
        </trans-unit>
        <trans-unit id="9be88f8537261298343db1ff319dde4340861d75" translate="yes" xml:space="preserve">
          <source>The supplied code as a delegate.</source>
          <target state="translated">제공된 코드는 델리게이트입니다.</target>
        </trans-unit>
        <trans-unit id="63d3a3cda8996c92ecd751aecdc230c95f7170d2" translate="yes" xml:space="preserve">
          <source>The swapping strategy parameter is not implemented yet; currently it is ignored.</source>
          <target state="translated">스와핑 전략 매개 변수는 아직 구현되지 않았습니다. 현재는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="80b980e073fe362e9683180ed237939256d93352" translate="yes" xml:space="preserve">
          <source>The swapping strategy to employ.</source>
          <target state="translated">사용할 스와핑 전략.</target>
        </trans-unit>
        <trans-unit id="170969e1d0fabb640f8089b36d7401a205bca51c" translate="yes" xml:space="preserve">
          <source>The swapping strategy to use.</source>
          <target state="translated">사용할 스와핑 전략.</target>
        </trans-unit>
        <trans-unit id="98e99ba24a8243b8fd6b17bc749b4554c5b7f75e" translate="yes" xml:space="preserve">
          <source>The swapping strategy.</source>
          <target state="translated">교환 전략.</target>
        </trans-unit>
        <trans-unit id="48042820d83937bec0797943750b58634bf67f60" translate="yes" xml:space="preserve">
          <source>The symbol containing the &lt;code&gt;static foreach&lt;/code&gt; variables.</source>
          <target state="translated">&lt;code&gt;static foreach&lt;/code&gt; 변수를 포함하는 기호 입니다.</target>
        </trans-unit>
        <trans-unit id="56e1148f66671625bb0c6990da38dc2d64edea1a" translate="yes" xml:space="preserve">
          <source>The symbol this &lt;code&gt;alias this&lt;/code&gt; resolves to</source>
          <target state="translated">이 &lt;code&gt;alias this&lt;/code&gt; 해석 되는 심볼</target>
        </trans-unit>
        <trans-unit id="dac6f5e28e8cd7e2f90032028de6bb0f0117f4f9" translate="yes" xml:space="preserve">
          <source>The symlink to create. A relative path is relative to the current working directory.</source>
          <target state="translated">만들 심볼릭 링크입니다. 상대 경로는 현재 작업 디렉토리에 상대적인 경로입니다.</target>
        </trans-unit>
        <trans-unit id="83a33998cfc84a9e39e9f0423cfd7357619092df" translate="yes" xml:space="preserve">
          <source>The synchronization gets released even if</source>
          <target state="translated">다음과 같은 경우에도 동기화가 해제됩니다</target>
        </trans-unit>
        <trans-unit id="f52720ebc8b4fb3263a1e381206af9d0efeeb0c2" translate="yes" xml:space="preserve">
          <source>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads.</source>
          <target state="translated">동기화 된 명령문은 여러 스레드간에 액세스를 동기화하기 위해 명령문을 mutex로 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="54b1dbc833575883512c8f1664c887a121ae9fd3" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;b&gt;/c/string/&lt;/b&gt;, where &lt;b&gt;c&lt;/b&gt; is either a single character, or multiple characters separated by whitespace or commas, and &lt;b&gt;string&lt;/b&gt; is the replacement text.</source>
          <target state="translated">구문은 &lt;b&gt;/ c / string /입니다&lt;/b&gt; . 여기서 &lt;b&gt;c&lt;/b&gt; 는 단일 문자이거나 공백 또는 쉼표로 구분 된 여러 문자이며 &lt;b&gt;string&lt;/b&gt; 은 대체 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="29a57978120d30d4470e32a4ab4fb731cec2bd76" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and determine the meaning of the program.</source>
          <target state="translated">구문 트리는 변수를 선언하고, 기호 테이블을로드하고, 유형을 할당하고, 프로그램의 의미를 결정하기 위해 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="d9da9fc28de038f5884f945667be4b8054f95702" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and in general determine the meaning of the program.</source>
          <target state="translated">구문 트리는 변수 선언, 기호 테이블로드, 유형 지정 및 일반적으로 프로그램의 의미를 결정하기 위해 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="fa94a6e6326b720f3ede8ff8d6c4dce16a4fa303" translate="yes" xml:space="preserve">
          <source>The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</source>
          <target state="translated">시스템 클럭 틱은 시스템이 제공하는 최고 정밀도의 시스템 클럭 틱입니다.</target>
        </trans-unit>
        <trans-unit id="5387aa28c9051257b0dae7b093c61c8a7eb3427d" translate="yes" xml:space="preserve">
          <source>The system-provided garbage-collector allocator. This should be the default fallback allocator tapping into system memory. It offers manual &lt;code&gt;free&lt;/code&gt; and dutifully collects litter.</source>
          <target state="translated">시스템이 제공 한 가비지 수집기 할당 자 이것은 시스템 메모리를 사용하는 기본 폴백 할당 자 여야합니다. 그것은 수동 &lt;code&gt;free&lt;/code&gt; 하고 정중하게 쓰레기를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="ec81049f6e21b9ea49ff325809160b315623cf2d" translate="yes" xml:space="preserve">
          <source>The table below gives a synopsis of predefined allocator building blocks, with their respective modules. Either &lt;code&gt;import&lt;/code&gt; the needed modules individually, or &lt;code&gt;import&lt;/code&gt;&lt;code&gt;std.experimental.building_blocks&lt;/code&gt;, which imports them all &lt;code&gt;public&lt;/code&gt;ly. The building blocks can be assembled in unbounded ways and also combined with your own. For a collection of typical and useful preassembled allocators and for inspiration in defining more such assemblies, refer to &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 표는 사전 정의 된 할당 자 구성 요소와 해당 모듈의 개요를 제공합니다. 어느 &lt;code&gt;import&lt;/code&gt; 필요한 개별 모듈 또는 &lt;code&gt;import&lt;/code&gt; &lt;code&gt;std.experimental.building_blocks&lt;/code&gt; 하는 모든 수입을, &lt;code&gt;public&lt;/code&gt; LY합니다. 빌딩 블록은 무한한 방법으로 조립할 수 있으며 자신의 것과 결합 할 수도 있습니다. 일반적이고 유용한 사전 조립 된 할당 자 모음과 이러한 어셈블리를 더 정의 할 때 영감을 얻으려면 &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d173662a2aa058963145fe71e5e20907062a55be" translate="yes" xml:space="preserve">
          <source>The target hardware does not have a floating point unit</source>
          <target state="translated">대상 하드웨어에 부동 소수점 단위가 없습니다</target>
        </trans-unit>
        <trans-unit id="c5cdb1793dc5882606089de2cbe88b09e1226416" translate="yes" xml:space="preserve">
          <source>The target hardware has a floating point unit</source>
          <target state="translated">대상 하드웨어에는 부동 소수점 단위가 있습니다</target>
        </trans-unit>
        <trans-unit id="b0979a69d6f3a7dae7324755cd1aa56f216e319b" translate="yes" xml:space="preserve">
          <source>The target object</source>
          <target state="translated">대상 객체</target>
        </trans-unit>
        <trans-unit id="0b824dcd9bca9b5db9480c831c6a63d26770ea48" translate="yes" xml:space="preserve">
          <source>The target of the search. Must be an input range. If any of &lt;code&gt;needles&lt;/code&gt; is a range with elements comparable to elements in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; such that the search can backtrack.</source>
          <target state="translated">검색 대상 입력 범위 여야합니다. &lt;code&gt;needles&lt;/code&gt; 중 하나라도 &lt;code&gt;haystack&lt;/code&gt; 의 요소와 비교할 수있는 요소가있는 범위 이면 &lt;code&gt;haystack&lt;/code&gt; 은 검색이 역 추적 할 수 있도록 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;정방향 범위&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1bfc030365108c10d6974605e9bd398b8361c092" translate="yes" xml:space="preserve">
          <source>The target range to copy common elements to.</source>
          <target state="translated">공통 요소를 복사 할 대상 범위입니다.</target>
        </trans-unit>
        <trans-unit id="829e896e39b70090cbc3b2de79f25fe9335f1b77" translate="yes" xml:space="preserve">
          <source>The target range.</source>
          <target state="translated">목표 범위.</target>
        </trans-unit>
        <trans-unit id="23350db16fa1f3e6288ccb87e5a181ba79379e10" translate="yes" xml:space="preserve">
          <source>The target supports interfacing with Objective-C</source>
          <target state="translated">대상은 Objective-C와의 인터페이스를 지원합니다</target>
        </trans-unit>
        <trans-unit id="eac1bff04784409ef03a30482f19ef41091d6414" translate="yes" xml:space="preserve">
          <source>The target type in the conversion or comparison</source>
          <target state="translated">변환 또는 비교의 대상 유형</target>
        </trans-unit>
        <trans-unit id="390654f1dbf50ff204a2f1fd9ed2609258c428a9" translate="yes" xml:space="preserve">
          <source>The target type of the cast</source>
          <target state="translated">캐스트의 대상 유형</target>
        </trans-unit>
        <trans-unit id="5431c3bccb7e8fdc6dc54d831207394bad385ccd" translate="yes" xml:space="preserve">
          <source>The target variable.</source>
          <target state="translated">대상 변수.</target>
        </trans-unit>
        <trans-unit id="b71a4a76d74bf9f8e3d2c97011ae3038c9fc6fff" translate="yes" xml:space="preserve">
          <source>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics.</source>
          <target state="translated">'특수 기능'이라는 전문 용어에는 여러 수학, 물리학 분야에 중요한 응용 프로그램이있는 초월 함수 계열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b45d76d889fde617363950e6293b054095035b5" translate="yes" xml:space="preserve">
          <source>The template API is slightly more efficient. It does not have to allocate memory dynamically, all memory is allocated on the stack. The OOP API has to allocate in the finish method if no buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate, but the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; classes still have to be created using &lt;code&gt;new&lt;/code&gt; which allocates them using the GC.  The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.  If just one specific digest type and backend is needed, the template API is usually a good fit. In this simplest case, the template API can even be used without templates: Just use the &quot;&lt;b&gt;x&lt;/b&gt;&quot; structs directly.</source>
          <target state="translated">템플릿 API가 약간 더 효율적입니다. 메모리를 동적으로 할당 할 필요는 없으며 모든 메모리는 스택에 할당됩니다. 버퍼가 제공되지 않은 경우 OOP API는 finish 메소드에 할당해야합니다. OOP API 종료 함수에 버퍼를 제공하는 경우 할당되지 않지만 GC를 사용하여 할당하는 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt; 클래스를 작성해야합니다 . OOP API는 '런타임'에서 다이제스트 기능 및 / 또는 다이제스트 백엔드를 변경하는 데 유용합니다. 여기에서 이점은 Phobos MD5Digest 및 OpenSSLMD5Digest 구현과 같은 전환이 ABI와 호환된다는 것입니다. 특정 다이제스트 유형과 백엔드가 하나만 필요한 경우 일반적으로 템플릿 API가 적합합니다. 이 가장 간단한 경우 템플릿 API는 템플릿 없이도 사용할 수 있습니다. &quot; &lt;b&gt;x&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&quot;는 직접 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="408001ca506523fa6af663497d5def923a607239" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;. If asking for &lt;code&gt;char&lt;/code&gt;, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</source>
          <target state="translated">템플리트 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 리턴 할 유형을 지정합니다. &lt;code&gt;char[]&lt;/code&gt; 또는 &lt;code&gt;ubyte[]&lt;/code&gt; 를 리턴 하는 &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;ubyte&lt;/code&gt; 값이 가능합니다 . &lt;code&gt;char&lt;/code&gt; 을 요청하면 컨텐츠가 연결 문자 세트 (기본적으로 ISO-8859-1 인 HTTP 응답 헤더 또는 FTP 연결 특성에 지정됨)에서 UTF-8로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d301625295a49a8e01e8072c1823836d6260302" translate="yes" xml:space="preserve">
          <source>The template picked to instantiate is the one that is most specialized that fits the types of the</source>
          <target state="translated">인스턴스화하기 위해 선택한 템플릿은 가장 전문화 된 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="02b51510e4339a80ea7cc2a65d41d079d75e78b8" translate="yes" xml:space="preserve">
          <source>The template to instantiate.</source>
          <target state="translated">인스턴스화 할 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="e41f924354ea35f5712eb828813900cd1d5f4161" translate="yes" xml:space="preserve">
          <source>The term and concept of a 'critical region' comes from &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono's SGen garbage collector&lt;/a&gt;.</source>
          <target state="translated">'핵심 영역'의 용어와 개념은 &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono의 SGen 가비지 수집기&lt;/a&gt; 에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="efe68f5f28809042f03e04ab3e7e40904902798b" translate="yes" xml:space="preserve">
          <source>The tested value</source>
          <target state="translated">테스트 된 값</target>
        </trans-unit>
        <trans-unit id="836717195b2e4f6e650af52f82b03152a0dc0a7a" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt; 의 텍스트</target>
        </trans-unit>
        <trans-unit id="0c61681518afaf906c5f5a155fa8319604abc839" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;https://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459f3d558c2480422a70a7a05484244d80510d43" translate="yes" xml:space="preserve">
          <source>The text to print at the beginning of the help output.</source>
          <target state="translated">도움말 출력의 시작 부분에 인쇄 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="b43a60a00dd34982ab5b9431db8979ee331c8fcd" translate="yes" xml:space="preserve">
          <source>The text to printed at the beginning of the help output.</source>
          <target state="translated">도움말 출력의 시작 부분에 인쇄 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="f99eb9686d85d18418cbec2f3108af60157b8372" translate="yes" xml:space="preserve">
          <source>The third form, &lt;code&gt;goto case;&lt;/code&gt;, transfers to the next &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">세 번째 형태 인 &lt;code&gt;goto case;&lt;/code&gt; , 가장 안쪽의 &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; 의 다음 &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; 로 전송합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="0d93a13c865f0a3f12bf9f0bb2248b62195335a7" translate="yes" xml:space="preserve">
          <source>The third version counts the elements for which &lt;code&gt;pred(x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">세 번째 버전은 &lt;code&gt;pred(x)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 요소를 계산 합니다 . &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) 평가를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="a7f1a71c5e73a907487dd15adada9e34f7e659b3" translate="yes" xml:space="preserve">
          <source>The thread function.</source>
          <target state="translated">스레드 기능.</target>
        </trans-unit>
        <trans-unit id="3959bc13b481b7efab32161f7b4d802658e73e9a" translate="yes" xml:space="preserve">
          <source>The thread identifier to search for.</source>
          <target state="translated">검색 할 스레드 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="5a0f4bf2e74aee3208cf1615166945a5d795e350" translate="yes" xml:space="preserve">
          <source>The thread module provides support for thread creation and management.</source>
          <target state="translated">스레드 모듈은 스레드 작성 및 관리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d7abe70146b93589cb3df68907f1263f3d11f70c" translate="yes" xml:space="preserve">
          <source>The thread object associated with the thread identifier, null if not found.</source>
          <target state="translated">스레드 식별자와 관련된 스레드 개체로, 찾지 못한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="ab55fec985d480d7e55fafd41bc48fa26e59c5c7" translate="yes" xml:space="preserve">
          <source>The thread object representing the calling thread. The result of deleting this object is undefined. If the current thread is not attached to the runtime, a null reference is returned.</source>
          <target state="translated">호출하는 스레드를 나타내는 스레드 객체입니다. 이 객체를 삭제 한 결과는 정의되지 않습니다. 현재 스레드가 런타임에 연결되지 않은 경우 널 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e5711fdf4eb878a460acdc3e1a74ec3adfd4c562" translate="yes" xml:space="preserve">
          <source>The thread to add.</source>
          <target state="translated">추가 할 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="7d29c86c6e1877f0c1dbf42c7ab48cb432ebae10" translate="yes" xml:space="preserve">
          <source>The thread to remove.</source>
          <target state="translated">제거 할 스레드.</target>
        </trans-unit>
        <trans-unit id="d0b4719e19dcec3e27e7ac05162455919bfcbe02" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;. The semantics of the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; are identical to the regular &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt; 의 스레드 세이프 버전입니다 . &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 의 의미 는 일반 &lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="59a01b618381df97fff6e53a1c501e32c03fcf01" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;code&gt;Region&lt;/code&gt; allocator. Allocations and deallocations are lock-free based using &lt;a href=&quot;core_atomic#cas&quot;&gt;&lt;code&gt;core.atomic.cas&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Region&lt;/code&gt; 할당 자의 스레드 세이프 버전입니다 . 할당 및 할당 해제는 &lt;a href=&quot;core_atomic#cas&quot;&gt; &lt;code&gt;core.atomic.cas&lt;/code&gt; &lt;/a&gt; 를 사용하여 잠금없이 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa46d46c716c543c618abaaa5d085bc00056cfe" translate="yes" xml:space="preserve">
          <source>The tick of the system clock (as a &lt;code&gt;TickDuration&lt;/code&gt;) when the application started.</source>
          <target state="translated">응용 프로그램이 시작될 때 시스템 시계의 눈금 ( &lt;code&gt;TickDuration&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="c9d9d06b3436a3b01b898cdc70083c5a552bbada" translate="yes" xml:space="preserve">
          <source>The tid register by name.</source>
          <target state="translated">이름으로 tid 레지스터.</target>
        </trans-unit>
        <trans-unit id="c95778519910f76a9057566bdc33da531d73931d" translate="yes" xml:space="preserve">
          <source>The time complexity of &lt;code&gt;resolveInternalPointer&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;), where &lt;code&gt;k&lt;/code&gt; is the size of the object within which the internal pointer is looked up.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; 의 시간 복잡도 는 &amp;Omicron; ( &lt;code&gt;k&lt;/code&gt; )이며, 여기서 &lt;code&gt;k&lt;/code&gt; 는 내부 포인터가 조회되는 객체의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="c6f885eba6e13ebbe7785527359e11e5b18d7b86" translate="yes" xml:space="preserve">
          <source>The time in this time zone that needs to be adjusted to UTC time.</source>
          <target state="translated">이 시간대에서 UTC 시간으로 조정해야하는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="36444ba6ba0b4c42e3d384843ef7cb9d529fafd9" translate="yes" xml:space="preserve">
          <source>The time it takes for a collection to complete is not bounded. While in practice it is very quick, this cannot normally be guaranteed.</source>
          <target state="translated">수집이 완료되는 데 걸리는 시간은 제한되지 않습니다. 실제로는 매우 빠르지 만 일반적으로 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="de1882702ad690d9d775a9f36384bf0f0cf2e003" translate="yes" xml:space="preserve">
          <source>The time point to check for inclusion in this interval.</source>
          <target state="translated">이 간격에 포함되는지 확인하는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="6e148efcac14a5504ed5ebc4915f1425f4ffaad7" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is after it.</source>
          <target state="translated">이 간격 이후인지 확인하는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="0af6ef24e2680b0852356a3c276c84d96252cda5" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is before it.</source>
          <target state="translated">이 간격이 이전인지 여부를 확인하는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="8a3820a8c6e406527bb35a80565a009d598d8a36" translate="yes" xml:space="preserve">
          <source>The time point to set &lt;code&gt;begin&lt;/code&gt; to.</source>
          <target state="translated">설정할 시점이 &lt;code&gt;begin&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cbec4c576826e4c65a07a27c4030261f911b3fc7" translate="yes" xml:space="preserve">
          <source>The time point to set end to.</source>
          <target state="translated">종료 시점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4e8c71e16602a3ead734892883c0297513fcb288" translate="yes" xml:space="preserve">
          <source>The time point which begins the interval.</source>
          <target state="translated">간격을 시작하는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="b2fbbe21f1348e2b8375bc085e626db9a6aa48c4" translate="yes" xml:space="preserve">
          <source>The time point which ends (but is not included in) the interval.</source>
          <target state="translated">간격이 끝나는 (그러나 포함되지는 않는) 시점.</target>
        </trans-unit>
        <trans-unit id="78c4a788ebf74ce66cd510d9291804e7429c59df" translate="yes" xml:space="preserve">
          <source>The time point which ends the interval.</source>
          <target state="translated">간격이 끝나는 시점.</target>
        </trans-unit>
        <trans-unit id="a07ced07ea48cf9efd3c59008997a5861e92661c" translate="yes" xml:space="preserve">
          <source>The time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 시간 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="eaefa3fbda7de51442bf3c3c08acb463add5f535" translate="yes" xml:space="preserve">
          <source>The time required of the base function</source>
          <target state="translated">기본 기능에 필요한 시간</target>
        </trans-unit>
        <trans-unit id="5dfcadc4d17bd6640e6259395ec434dc6bc95330" translate="yes" xml:space="preserve">
          <source>The time required of the target function</source>
          <target state="translated">대상 기능에 필요한 시간</target>
        </trans-unit>
        <trans-unit id="48cf786f30ef005c486cb7a01e2f10f8f8403d94" translate="yes" xml:space="preserve">
          <source>The time to return if the given file does not exist.</source>
          <target state="translated">주어진 파일이 존재하지 않는 경우 반환되는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4267537c103e163837339d1b65e1d8cf5f9910a8" translate="yes" xml:space="preserve">
          <source>The time to wait.</source>
          <target state="translated">기다릴 시간.</target>
        </trans-unit>
        <trans-unit id="fa99618f433466483613abfd766711a1f7a82462" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;Duration&lt;/code&gt; (e.g. &lt;code&gt;&quot;days&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 시간의 시간 단위 (예 : &lt;code&gt;&quot;days&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e6cd7e80f003f95225b75b6571da8250b5085bd4" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;TickDuration&lt;/code&gt; (e.g. &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 의 시간 단위 (예 : &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="da60824664e52c129d1706b86eb17c66b6fccefc" translate="yes" xml:space="preserve">
          <source>The time zone for the SysTime that's returned.</source>
          <target state="translated">반환 된 SysTime의 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="c438d5ef1eeaa45747297e85768ff04bc9674297" translate="yes" xml:space="preserve">
          <source>The time zone that the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; will be in (&lt;code&gt;FILETIME&lt;/code&gt;s are in UTC).</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 표준 시간대 ( &lt;code&gt;FILETIME&lt;/code&gt; 은 UTC입니다).</target>
        </trans-unit>
        <trans-unit id="8ed6f652fe44fd70fdb71a9b99c39e57d001f270" translate="yes" xml:space="preserve">
          <source>The time zone that the time in the &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct is assumed to be (if the &lt;code&gt;SYSTEMTIME&lt;/code&gt; was supplied by a Windows system call, the &lt;code&gt;SYSTEMTIME&lt;/code&gt; will either be in local time or UTC, depending on the call).</source>
          <target state="translated">의 시간 것을 시간대 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 의 구조체는 것으로 가정한다 (경우 생성 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 는 윈도우 시스템 콜에 의해 공급 된은 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 는 어느 호에 따라 로컬 시간과 UTC 될 것이다).</target>
        </trans-unit>
        <trans-unit id="e2b1325df63f2bced3800f46b247c623c3e4272e" translate="yes" xml:space="preserve">
          <source>The time zone to convert the given time to (no conversion occurs if null).</source>
          <target state="translated">지정된 시간을 변환 할 시간대입니다 (널 (NULL)이면 변환이 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="07061a5295594952467858d09a80f0ac4c6b93c5" translate="yes" xml:space="preserve">
          <source>The time zone which the DOS file time is assumed to be in.</source>
          <target state="translated">DOS 파일 시간이있는 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="ea5d10f63e5499e351af6e045b5284865995d1c6" translate="yes" xml:space="preserve">
          <source>The time-domain signal.</source>
          <target state="translated">시간 영역 신호.</target>
        </trans-unit>
        <trans-unit id="77a3aa828967d445cff64c8dd096774ce4063dcd" translate="yes" xml:space="preserve">
          <source>The timeout duration to set. Must not be negative.</source>
          <target state="translated">설정할 시간 초과 기간. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="d16c09d69ed3827cc0d9a393d7d97a0e7218d947" translate="yes" xml:space="preserve">
          <source>The times when endianness matters are:</source>
          <target state="translated">엔디안이 중요한시기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3fa37b42db66accd6b9bcd0e0be5ca501e23ea7" translate="yes" xml:space="preserve">
          <source>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">AD UTC 1 월 1 일 자정부터의 총 hnsecs 이것은 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 내부 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="1c5851853cba4938d9ece2d746e33f63f5ccc8b6" translate="yes" xml:space="preserve">
          <source>The total number of CPU cores available on the current machine, as reported by the operating system.</source>
          <target state="translated">운영 체제에서보고 한대로 현재 머신에서 사용 가능한 총 CPU 코어 수입니다.</target>
        </trans-unit>
        <trans-unit id="79b5fcc0a58019c01762b4288a59bbc0fed9cdab" translate="yes" xml:space="preserve">
          <source>The total number of fields minus the number of hidden fields.</source>
          <target state="translated">총 필드 수에서 숨겨진 필드 수를 뺀 값입니다.</target>
        </trans-unit>
        <trans-unit id="dc0f294e7939a4a8cc8e219285559a0f838c9d26" translate="yes" xml:space="preserve">
          <source>The total number of valid bits in the given bit array</source>
          <target state="translated">주어진 비트 배열에서 유효한 총 비트 수</target>
        </trans-unit>
        <trans-unit id="df0ace455640aad44a2f2df358df6cfc839cb3dc" translate="yes" xml:space="preserve">
          <source>The total size of a static array cannot exceed 16Mb.</source>
          <target state="translated">정적 배열의 총 크기는 16Mb를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="976a549fe53e07ee95927e3a3f5dc68542025ca7" translate="yes" xml:space="preserve">
          <source>The traditional C way of detecting and reporting errors is not traditional, it is ad-hoc and varies from function to function, including:</source>
          <target state="translated">오류를 감지하고보고하는 기존의 C 방식은 기존 방식이 아니며 임시 방식이며 다음을 포함하여 기능마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67c33a524b8d09894199c567d354a8e0cb98ab34" translate="yes" xml:space="preserve">
          <source>The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The &lt;b&gt;%|&lt;/b&gt; delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element:</source>
          <target state="translated">각 항목의 지정자 다음에 나오는 하위 형식 문자열의 끝은 배열 구분 기호로 해석되므로 마지막 배열 항목 다음에는 생략됩니다. &lt;b&gt;% | &lt;/b&gt;분리 문자 지정자를 사용하여 분리 문자가 시작되는 위치를 표시 할 수 있으므로, 그 앞에있는 형식 문자열의 일부가 마지막 배열 요소에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ba1799b6274ed3732b914694e0713f19f1425685" translate="yes" xml:space="preserve">
          <source>The transformation target</source>
          <target state="translated">변환 대상</target>
        </trans-unit>
        <trans-unit id="dc8b213c861da206308d6e24e6eb30fbdfae1604" translate="yes" xml:space="preserve">
          <source>The transformation to apply.</source>
          <target state="translated">적용 할 변환입니다.</target>
        </trans-unit>
        <trans-unit id="6b4ca3ee54513a021c5a032735367ac7e4c3f685" translate="yes" xml:space="preserve">
          <source>The transformation to apply. Either a unary function (&lt;code&gt;unaryFun!transform(element)&lt;/code&gt;), or a binary function (&lt;code&gt;binaryFun!transform(element, index)&lt;/code&gt;).</source>
          <target state="translated">적용 할 변형입니다. 단항 함수 ( &lt;code&gt;unaryFun!transform(element)&lt;/code&gt; ) 또는 이진 함수 ( &lt;code&gt;binaryFun!transform(element, index)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1e46c489c0f174beeea6508fe063266ccec2c4d" translate="yes" xml:space="preserve">
          <source>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</source>
          <target state="translated">횡단은 검증하지 않고 범위 범위의 요소가 모두 동일한 길이를 갖는다 고 가정합니다. 이 옵션은 범위 밖에서 이미 확인한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c892e981eb5136632b424a66b388d449fc7ea3de" translate="yes" xml:space="preserve">
          <source>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</source>
          <target state="translated">횡단은 범위 범위의 요소가 모두 같은 길이 (예 : 모두 같은 길이를 갖는 배열의 배열)를 갖도록 강제합니다. 횡단 범위 구성시 점검이 한 번 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="39be873b141578a1b5b94098b6cdd594b486bf6c" translate="yes" xml:space="preserve">
          <source>The try/catch/finally statements look a lot nicer than endless if (error) goto errorhandler; statements.</source>
          <target state="translated">try / catch / finally 문은 끝없는 if (error) goto errorhandler보다 훨씬 멋지게 보입니다. 진술.</target>
        </trans-unit>
        <trans-unit id="2180bb589eb009453566d9091bc41a602b56f38e" translate="yes" xml:space="preserve">
          <source>The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. &lt;code&gt;tuple(1, 3)&lt;/code&gt; means indices &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; but not &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">튜플은 왼쪽에 닫히고 오른쪽에 열려있는 범위를 통과합니다 (내장 슬라이스와 일치). 예를 들어 &lt;code&gt;tuple(1, 3)&lt;/code&gt; 은 인덱스 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 를 의미 하지만 &lt;code&gt;3&lt;/code&gt; 은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="07a7ad5d5f1c875f8f019e5586ed049f63bb8fa1" translate="yes" xml:space="preserve">
          <source>The two functions are almost identical semantically. The expressions in the first are lowered to contract blocks that look almost exactly like the second, except that a separate block is created for each expression in the first, thus avoiding shadowing variable names.</source>
          <target state="translated">두 기능은 의미 적으로 거의 동일합니다. 첫 번째의 표현식은 첫 번째의 각 표현식에 대해 별도의 블록이 작성되어 음영 변수 이름을 피하는 것을 제외하고는 거의 두 번째와 거의 유사한 계약 블록으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="28b3f8f71ef0f4ce43325479aa6cdea23771283e" translate="yes" xml:space="preserve">
          <source>The two sockets are indistinguishable.</source>
          <target state="translated">두 소켓은 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61509f7d94291812c28aff0f194b21e094315464" translate="yes" xml:space="preserve">
          <source>The type being allocated embeds no pointers. Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt; Tuple!(int, float)&lt;/code&gt;. The implicit conservative assumption is that the type has members with indirections so it needs to be scanned if garbage collected. Example of types with pointers: &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)&lt;/code&gt;.</source>
          <target state="translated">할당되는 타입은 포인터를 포함하지 않습니다. 예 : &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt; Tuple!(int, float)&lt;/code&gt; . 암시적인 보수적 가정은 유형에 간접적 인 멤버가 있으므로 가비지 수집시 스캔해야한다는 것입니다. 포인터가있는 유형의 예 : &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c92e87e9681d72db37be621f13a19e6f9ccab9d8" translate="yes" xml:space="preserve">
          <source>The type being allocated is &lt;code&gt;immutable&lt;/code&gt; and has no pointers. The thread that allocated it must also deallocate it. Example: &lt;code&gt;immutable(int)&lt;/code&gt;.</source>
          <target state="translated">할당되는 유형은 &lt;code&gt;immutable&lt;/code&gt; 없으며 포인터가 없습니다. 이를 할당 한 스레드도 할당 해제해야합니다. 예 : &lt;code&gt;immutable(int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e05464f951110a64f08a5f46efef5075a235c4f" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, embeds no indirections, and has fixed size.</source>
          <target state="translated">할당되는 유형은 스레드간에 공유 될 수 있으며, 간접적 인 내용을 포함하지 않으며 크기가 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e0418a4ffc820d767ece7d24f4809101c1c145" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has fixed size.</source>
          <target state="translated">할당되는 유형은 스레드간에 공유 될 수 있고, 간접적 (indirection)을 포함 할 수 있으며 크기가 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe4cebdd8e8add445c91158cc91cb4158edec6a" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has variable size.</source>
          <target state="translated">할당되는 유형은 스레드간에 공유 될 수 있고, 간접을 포함 할 수 있으며 가변 크기를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddfa6b8808ffdca7214f401f8531dd3f2c5d3a94" translate="yes" xml:space="preserve">
          <source>The type can be inferred from the initializer:</source>
          <target state="translated">이니셜 라이저에서 형식을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2bca00fd97360bf19d51b245e76c8ddf38d445e" translate="yes" xml:space="preserve">
          <source>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</source>
          <target state="translated">콜백 함수의 유형입니다. 이것은 레거시이며 더 이상 사용되지 않습니다. 과거 호환성을 위해 포함되었으며 문서화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="121e0a2d6317bfb42929d38aae907c92fbe1c037" translate="yes" xml:space="preserve">
          <source>The type for a unary expression is incompatible. Print error message.</source>
          <target state="translated">단항 표현식의 유형이 호환되지 않습니다. 인쇄 오류 메시지.</target>
        </trans-unit>
        <trans-unit id="6c3d19b0730f008ab63e19c7a8d36ffbf8fb1da1" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt; to handle.</source>
          <target state="translated">처리 할 수 있는 &lt;code&gt;Throwable&lt;/code&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3c9c6ef66ad21283731c4e03058407f8e8389f4f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt;s to catch. Defaults to &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">캐치 할 &lt;code&gt;Throwable&lt;/code&gt; 유형입니다 . 기본값은 &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="334019df59cb8690811d0f69b9dd1719fafb9c56" translate="yes" xml:space="preserve">
          <source>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is bool, followed by unsigned types, followed by signed types.</source>
          <target state="translated">비트 필드의 유형은 일체형 또는 열거 형일 수 있습니다. 비트 필드에 저장하는 가장 효율적인 유형은 부울, 부호없는 유형, 부호있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="94b6a8f2e23e23e45fa071980296e38bdaa78842" translate="yes" xml:space="preserve">
          <source>The type of a const declaration is itself const.</source>
          <target state="translated">const 선언의 유형 자체는 const입니다.</target>
        </trans-unit>
        <trans-unit id="f092f06205403400bf68aeecbf79e12113097113" translate="yes" xml:space="preserve">
          <source>The type of a string is determined by the semantic phase of compilation. The type is one of: char[], wchar[], dchar[], and is determined by implicit conversion rules. If there are two equally applicable implicit conversions, the result is an error. To disambiguate these cases, a cast or a postfix of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; can be used:</source>
          <target state="translated">문자열의 유형은 의미 체계적인 컴파일 단계에 의해 결정됩니다. 유형은 char [], wchar [], dchar [] 중 하나이며 내재적 변환 규칙에 의해 결정됩니다. 똑같이 적용 가능한 암시 적 변환이 두 개 있으면 결과는 오류입니다. 이러한 경우를 명확하게하기 위해 캐스트 또는 접미사 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 또는 &lt;code&gt;d&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca53c8f136489f724620c0090bfc2e63be277e6a" translate="yes" xml:space="preserve">
          <source>The type of an</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="31de113d851dba3763860dc7a09ef0a95ac4302d" translate="yes" xml:space="preserve">
          <source>The type of concurrency used when logical threads are created is determined by the Scheduler selected at initialization time. The default behavior is currently to create a new kernel thread per call to spawn, but other schedulers are available that multiplex fibers across the main thread or use some combination of the two approaches.</source>
          <target state="translated">논리 스레드가 작성 될 때 사용되는 동시성 유형은 초기화시 선택된 스케줄러에 의해 결정됩니다. 기본 동작은 현재 스폰 호출마다 새로운 커널 스레드를 생성하는 것입니다. 그러나 메인 스레드에서 멀티 플렉스 파이버를 사용하거나 두 가지 접근 방식의 일부 조합을 사용하는 다른 스케줄러를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98b545b7a4a8236494e660dadf828715e09984c5" translate="yes" xml:space="preserve">
          <source>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type.</source>
          <target state="translated">인코딩 유형을 추론 할 수 없습니다. 따라서 인코딩 유형을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="28559fdc7fafacf56a4b4aa4caf411513cf1a53a" translate="yes" xml:space="preserve">
          <source>The type of exception to catch.</source>
          <target state="translated">포착 할 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="e2db65940bfb878a54cfaaae819d3064fa148502" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 연관된 &lt;code&gt;TypeInfo&lt;/code&gt; 객체 의 유형</target>
        </trans-unit>
        <trans-unit id="3fe50288d353a1cb4576b8e3e05c3c630fa3b33c" translate="yes" xml:space="preserve">
          <source>The type of the array elements</source>
          <target state="translated">배열 요소의 유형</target>
        </trans-unit>
        <trans-unit id="d37e2aaad386c1ac5e9f0016c42e7b609226d289" translate="yes" xml:space="preserve">
          <source>The type of the expression.</source>
          <target state="translated">표현식의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="028c1d38d3da5ded0145ae38e0f7c2dbd53920e7" translate="yes" xml:space="preserve">
          <source>The type of the integer is resolved as follows:</source>
          <target state="translated">정수 유형은 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="212a76fc03c17bbe0ddb79883b2541fa9887cff9" translate="yes" xml:space="preserve">
          <source>The type of the integral subject to checking.</source>
          <target state="translated">점검 대상 정수 유형.</target>
        </trans-unit>
        <trans-unit id="c013517e503aa577ef8db2efdfe587a3e89caa97" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter.</source>
          <target state="translated">출력 유형을 추론 할 수 없습니다. 따라서 인코딩을 템플릿 매개 변수로 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="03cbac5dfebfa2a554890fbfd9c43c204a18bfcf" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter.</source>
          <target state="translated">출력 유형을 추론 할 수 없습니다. 따라서 템플리트 매개 변수에 인코딩 유형을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d39ec39bd451294d5515fb3a127cb955f855d7d6" translate="yes" xml:space="preserve">
          <source>The type of the previous</source>
          <target state="translated">이전의 유형</target>
        </trans-unit>
        <trans-unit id="033a19799f0fa5ac9cef064ceb5d1268d8f17524" translate="yes" xml:space="preserve">
          <source>The type of the resulting array elements</source>
          <target state="translated">결과 배열 요소의 유형</target>
        </trans-unit>
        <trans-unit id="81040b338b2e6abd79e9a3fdf3377720163baee6" translate="yes" xml:space="preserve">
          <source>The type of the return value.</source>
          <target state="translated">반환 값의 타입.</target>
        </trans-unit>
        <trans-unit id="dd58ac5452c68f3b56c536830be3fca377a108cc" translate="yes" xml:space="preserve">
          <source>The type of the slice is a dynamic array of the element type of the</source>
          <target state="translated">슬라이스의 유형은 요소 유형의 동적 배열입니다.</target>
        </trans-unit>
        <trans-unit id="cd785b1199a8635d3d151523c5ad55526bbbd6f9" translate="yes" xml:space="preserve">
          <source>The type of the symbol.</source>
          <target state="translated">심볼의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="452196a4318917b63a4cfe89691bc99e9fba3c75" translate="yes" xml:space="preserve">
          <source>The type of units to add (&quot;years&quot; or &quot;months&quot;).</source>
          <target state="translated">추가 할 단위 유형 ( &quot;년&quot;또는 &quot;달&quot;).</target>
        </trans-unit>
        <trans-unit id="f9dccb4c7e9a59ec9ebfcaaaf2ab57b17a652de7" translate="yes" xml:space="preserve">
          <source>The type returned by &lt;code&gt;takeOne&lt;/code&gt; is a random-access range with length regardless of &lt;code&gt;R&lt;/code&gt;'s capabilities, as long as it is a forward range. (another feature that distinguishes &lt;code&gt;takeOne&lt;/code&gt; from &lt;code&gt;take&lt;/code&gt;). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</source>
          <target state="translated">&lt;code&gt;takeOne&lt;/code&gt; 에 의해 리턴되는 타입 은 &lt;code&gt;R&lt;/code&gt; 범위에 관계없이 길이 가 포워드 범위 인 한 임의 접근 범위입니다 . ( &lt;code&gt;takeOne&lt;/code&gt; 과 &lt;code&gt;take&lt;/code&gt; 를 구별하는 다른 기능 ). (DR)이 입력 범위이지만 순방향 범위가 아닌 경우 반환 유형은 저장을 제외한 모든 임의 액세스 기능이있는 입력 범위입니다.</target>
        </trans-unit>
        <trans-unit id="df7e4abf69509dd860941f1b197de09e0d181452" translate="yes" xml:space="preserve">
          <source>The type stored inside &lt;code&gt;bomTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bomTable&lt;/code&gt; 안에 저장된 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="6da0e0e3a59ae4f419059fd79e6a5b2efe510dd1" translate="yes" xml:space="preserve">
          <source>The type to cast from. The programmer must ensure it is legal to make this cast.</source>
          <target state="translated">캐스팅 할 유형입니다. 프로그래머는이 캐스트를하는 것이 합법적인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fc6b3afd9d09c214bbb47deabcb3d5029a321f8" translate="yes" xml:space="preserve">
          <source>The type to cast to.</source>
          <target state="translated">캐스트 할 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7a12dddb89baf93f3c8ff660933719a4552a94a9" translate="yes" xml:space="preserve">
          <source>The type to check</source>
          <target state="translated">확인할 유형</target>
        </trans-unit>
        <trans-unit id="20caa9de7c60aa932980e2103bddf1b7c37802ff" translate="yes" xml:space="preserve">
          <source>The type to check Returns A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">확인할 유형 &lt;code&gt;bool&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="129cd5fe4646df1f906533b11f848d4c99ca621d" translate="yes" xml:space="preserve">
          <source>The type to check.</source>
          <target state="translated">확인할 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e0884902d15a178811c08946d7f41f322c3b3c6e" translate="yes" xml:space="preserve">
          <source>The type to convert to (either an integral type or a floating point type).</source>
          <target state="translated">변환 할 유형 (정수 유형 또는 부동 소수점 유형)입니다.</target>
        </trans-unit>
        <trans-unit id="731464fe86427c8aef65d3aa38988badaf10df11" translate="yes" xml:space="preserve">
          <source>The type to qualify</source>
          <target state="translated">자격을 갖춘 유형</target>
        </trans-unit>
        <trans-unit id="d4255aeb11f7f1166da5fe91079652809cb8c332" translate="yes" xml:space="preserve">
          <source>The type to transform</source>
          <target state="translated">변형 할 유형</target>
        </trans-unit>
        <trans-unit id="a182178d558aaac6dc8d492d1e7dc9ff9e25bdd0" translate="yes" xml:space="preserve">
          <source>The types bool, byte, ubyte, short, ushort, int, uint, pointer, Object, and interfaces are returned in EAX.</source>
          <target state="translated">bool, byte, ubyte, short, ushort, int, uint, pointer, Object 및 인터페이스 유형이 EAX로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0110212887a1a5d92fbf43e56315c07c9570e0ab" translate="yes" xml:space="preserve">
          <source>The types defined will all follow the naming convention:</source>
          <target state="translated">정의 된 유형은 모두 명명 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="04692c0de4f65115c6356357897fe3c8458aeb37" translate="yes" xml:space="preserve">
          <source>The types for a binary expression are incompatible. Print error message.</source>
          <target state="translated">이진 표현식의 유형이 호환되지 않습니다. 인쇄 오류 메시지.</target>
        </trans-unit>
        <trans-unit id="5522b90b8401affc194c75d94ed28b129ed2edae" translate="yes" xml:space="preserve">
          <source>The types of template parameters are deduced for a particular template instantiation by comparing the template argument with the corresponding template parameter.</source>
          <target state="translated">템플릿 인수를 해당 템플릿 매개 변수와 비교하여 특정 템플릿 인스턴스화에 대해 템플릿 매개 변수 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="066569f5b571624866c51a31fa6ddcb337821083" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;Tuple&lt;/code&gt;'s components.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 구성 요소 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3c8b9bedfec2099e1aa223db3144a32e496f4931" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;FILE*&lt;/code&gt; handle is maintained in a reference-counted manner, such that as soon as the last &lt;code&gt;File&lt;/code&gt; variable bound to a given &lt;code&gt;FILE*&lt;/code&gt; goes out of scope, the underlying &lt;code&gt;FILE*&lt;/code&gt; is automatically closed.</source>
          <target state="translated">지정된 &lt;code&gt;FILE*&lt;/code&gt; 바인딩 된 마지막 &lt;code&gt;File&lt;/code&gt; 변수 가 범위를 벗어나면 기본 &lt;code&gt;FILE*&lt;/code&gt; 가 자동으로 닫히도록 기본 &lt;code&gt;FILE*&lt;/code&gt; 핸들이 참조 계산 방식으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e4c90c054f0493a2822eb59e3b3bf2666457fe9" translate="yes" xml:space="preserve">
          <source>The underlying delegate of the &lt;code&gt;lazy&lt;/code&gt; parameter may be extracted by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; 매개 변수 의 기본 대리자 는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 를 사용하여 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afc75b662708321c7f89938e96034aeb600136f1" translate="yes" xml:space="preserve">
          <source>The unfilled part of target</source>
          <target state="translated">목표의 채워지지 않은 부분</target>
        </trans-unit>
        <trans-unit id="634a8a351a2208e39d6a5ada2c8d683b264478f7" translate="yes" xml:space="preserve">
          <source>The units of time to convert from.</source>
          <target state="translated">변환 할 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="ca496597d1b0052334d45f82b4d1ebb346322b8a" translate="yes" xml:space="preserve">
          <source>The units of time to convert to.</source>
          <target state="translated">변환 할 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="0be285da06571b223018436a72e418b7f4b54a74" translate="yes" xml:space="preserve">
          <source>The units of time to validate.</source>
          <target state="translated">검증 할 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="421844a18abe81313eecb91da7e35563552d941b" translate="yes" xml:space="preserve">
          <source>The units to add.</source>
          <target state="translated">추가 할 단위입니다.</target>
        </trans-unit>
        <trans-unit id="b4529f66e815e24cb45e91c0feb5284c7f7ff115" translate="yes" xml:space="preserve">
          <source>The units to add. Must be &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">추가 할 단위입니다. &lt;code&gt;&quot;days&quot;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a30f00fc7d9dabd0ab88732559ada44060afc844" translate="yes" xml:space="preserve">
          <source>The units to convert to. Accepts &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; and smaller only.</source>
          <target state="translated">변환 할 단위입니다. &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 이하 만 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="77097e55fb24c41c45ac8fd555bdb9f92cb58569" translate="yes" xml:space="preserve">
          <source>The unix time to convert.</source>
          <target state="translated">유닉스 시간은 변환합니다.</target>
        </trans-unit>
        <trans-unit id="20dd814c3aa8014ba5957f08ad17be1db064e4d2" translate="yes" xml:space="preserve">
          <source>The unsorted, right-hand side of the random access range to be sorted.</source>
          <target state="translated">랜덤 액세스 범위의 정렬되지 않은 오른쪽이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d3c14f93e1c2e8f53e8dab18a0c8184c6c7a98" translate="yes" xml:space="preserve">
          <source>The upper bound of the clamp.</source>
          <target state="translated">클램프의 상한.</target>
        </trans-unit>
        <trans-unit id="0983ef86eb34d76a2780b35b3edfbd68c63c7dea" translate="yes" xml:space="preserve">
          <source>The url to receive content from</source>
          <target state="translated">에서 콘텐츠를 수신 할 URL</target>
        </trans-unit>
        <trans-unit id="446e2b0a1f994283348417fe7415a244c477d8c8" translate="yes" xml:space="preserve">
          <source>The use in the example above is correct because &lt;code&gt;result&lt;/code&gt; was private to &lt;code&gt;letters&lt;/code&gt; and is inaccessible in writing after the function returns. The following example shows an incorrect use of &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 사용 된 &lt;code&gt;result&lt;/code&gt; 는 &lt;code&gt;letters&lt;/code&gt; 에만 적용되고 함수가 반환 된 후에는 쓰기에 액세스 할 수 없기 때문에 정확 합니다. 다음 예제는 &lt;code&gt;assumeUnique&lt;/code&gt; 의 잘못된 사용을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f765f067fdbcdb23f122179aadad4e3aab7633fe" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged - use either of &lt;a href=&quot;#matchAll&quot;&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#matchFirst&quot;&gt;&lt;code&gt;matchFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#matchAll&quot;&gt; &lt;code&gt;matchAll&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#matchFirst&quot;&gt; &lt;code&gt;matchFirst&lt;/code&gt; 를&lt;/a&gt; 사용하여이 기능을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="12cefe2def110643149592a34e2703038ffe95e9" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged, please use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">이 기능은 사용하지 않는 것이 좋습니다 . &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; 를&lt;/a&gt; 명시 적으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="258077ec71c841ca26961567df7573b36d2e9600" translate="yes" xml:space="preserve">
          <source>The user-defined attribute to search for</source>
          <target state="translated">검색 할 사용자 정의 속성</target>
        </trans-unit>
        <trans-unit id="aef8bf31a8de472e5ee4f185e2b79cc50024f24a" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:</source>
          <target state="translated">일반적인 산술 변환은 이진 연산자의 피연산자를 공통 유형으로 변환합니다. 피연산자는 이미 산술 유형이어야합니다. 기본 유형을보고 다음 규칙이 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed8ed81507c265fdc6ddf599aacfb34e442e2017" translate="yes" xml:space="preserve">
          <source>The value held internally by this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">이것에 의해 내부적으로 개최 값 &lt;code&gt;Nullable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c2cd4ec56e16370bc6d10103dd74ac049c5530" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;here&lt;/code&gt;.</source>
          <target state="translated">값은에 의해 이전에 보유하고 &lt;code&gt;here&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d539c77bb27b77f2df22dab504e881d99f6b5dd9" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 이 이전에 보유한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="758230c61eadaee99aa3c3ef284aa623718c1933" translate="yes" xml:space="preserve">
          <source>The value of 'val'.</source>
          <target state="translated">'val'의 값입니다.</target>
        </trans-unit>
        <trans-unit id="b06c415192563751b142dd5d437c6004b2e9459e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;expr&lt;/code&gt;, if any.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="efa4633a9b927147870c40861701a3a66f460ac4" translate="yes" xml:space="preserve">
          <source>The value of an</source>
          <target state="translated">의 가치</target>
        </trans-unit>
        <trans-unit id="e705d7da4d67602f093ecd07ec55976add979079" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; is given by its &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is the first</source>
          <target state="translated">값 &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember는&lt;/i&gt;&lt;/a&gt; 그 주어진다 &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; . &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 이없고 처음 인 경우</target>
        </trans-unit>
        <trans-unit id="cfdd678ef3efc50d4d19e113e22570e812ee97e8" translate="yes" xml:space="preserve">
          <source>The value of cos(y) + i sin(y).</source>
          <target state="translated">cos (y) + i sin (y)의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ce228048bba4c787805c0ea9367075ff06ba1fcc" translate="yes" xml:space="preserve">
          <source>The value of cosh(y) + i sinh(y)</source>
          <target state="translated">cosh (y) + i sinh (y)의 값</target>
        </trans-unit>
        <trans-unit id="dffcef37a6c60e8c1178ac476b670c4fbdc86276" translate="yes" xml:space="preserve">
          <source>The value of the bound being violated</source>
          <target state="translated">위반되는 경계의 가치</target>
        </trans-unit>
        <trans-unit id="911671dbc78d40ead01af236d912c34ae5fc15c4" translate="yes" xml:space="preserve">
          <source>The value of the selected choice.</source>
          <target state="translated">선택된 선택의 값.</target>
        </trans-unit>
        <trans-unit id="2079c7788ad766ba6207e480774a32436765df0d" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;long.max&lt;/code&gt;/&lt;code&gt;long.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">이 값 &lt;code&gt;BigInt&lt;/code&gt; A와 &lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;long.max&lt;/code&gt; / &lt;code&gt;long.min&lt;/code&gt; 표현할 수있는 범위를 초과하는 경우.</target>
        </trans-unit>
        <trans-unit id="bfb5bbd989c9054cc2b242d5eea3691758f09eed" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as an &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;int.max&lt;/code&gt;/&lt;code&gt;int.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">이 값 &lt;code&gt;BigInt&lt;/code&gt; 이 AS &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;int.max&lt;/code&gt; / &lt;code&gt;int.min&lt;/code&gt; 표현할 수있는 범위를 초과하는 경우.</target>
        </trans-unit>
        <trans-unit id="44a86e613513bb5b90f75505c846e4f1a8d5e443" translate="yes" xml:space="preserve">
          <source>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.</source>
          <target state="translated">x-i * y의 값. 여기서 i는 x에서 y를 완전히 뺄 수있는 횟수입니다. 결과는 x와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fbda37a05f283a201fa47e61f1a28829aac6ca57" translate="yes" xml:space="preserve">
          <source>The value that serves as the stopping criterion. This value is not included in the range.</source>
          <target state="translated">중지 기준으로 사용되는 값입니다. 이 값은 범위에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06ef9451ca2a6ddc30c31abb46ec77c558d2c434" translate="yes" xml:space="preserve">
          <source>The value to act as a proxy for all operations. It must be an lvalue.</source>
          <target state="translated">모든 작업의 ​​프록시 역할을하는 값입니다. lvalue 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c4437657364f8d6c0ea26bb67bc977fd2c3d6762" translate="yes" xml:space="preserve">
          <source>The value to add to the current value at each iteration.</source>
          <target state="translated">각 반복에서 현재 값에 더할 값입니다.</target>
        </trans-unit>
        <trans-unit id="71df2093c5012459c48815bda74ee8c58897d1c9" translate="yes" xml:space="preserve">
          <source>The value to add.</source>
          <target state="translated">추가 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="translated">추가 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="3e27e971fbf5a179f864e36ffcc71eeed5543b79" translate="yes" xml:space="preserve">
          <source>The value to be reference counted</source>
          <target state="translated">참조 할 값</target>
        </trans-unit>
        <trans-unit id="48cc3d885cf27d16c55ff2638b8883795263bff6" translate="yes" xml:space="preserve">
          <source>The value to bind to.</source>
          <target state="translated">바인딩 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="a802e0b8a3a2b83e804f3a0f0ce8a9cba9671bc8" translate="yes" xml:space="preserve">
          <source>The value to cast. It must be of type &lt;code&gt;From&lt;/code&gt;, otherwise a compile-time error is emitted.</source>
          <target state="translated">캐스트 할 값입니다. &lt;code&gt;From&lt;/code&gt; 유형이어야합니다 . 그렇지 않으면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62da9509e3333e477d714ba7dbd138814897fd19" translate="yes" xml:space="preserve">
          <source>The value to clamp.</source>
          <target state="translated">고정 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4ad7684bb8903fcc2f377acbdab0d055ec3933a5" translate="yes" xml:space="preserve">
          <source>The value to convert.</source>
          <target state="translated">변환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="50f2da1a55629d14637add94e8f4d0df9b3b3315" translate="yes" xml:space="preserve">
          <source>The value to divide from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TickDuration&lt;/code&gt; 에서 나눌 값 입니다.</target>
        </trans-unit>
        <trans-unit id="0a1bf08b423c514be4510f8c180b0baca8c3ce06" translate="yes" xml:space="preserve">
          <source>The value to divide from this duration.</source>
          <target state="translated">이 기간과 나눌 값입니다.</target>
        </trans-unit>
        <trans-unit id="1354007d97f6ba4733c332273819ddc621808569" translate="yes" xml:space="preserve">
          <source>The value to exchange.</source>
          <target state="translated">교환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="1212730d5cf61a8236b91aa2562728d9cffb815c" translate="yes" xml:space="preserve">
          <source>The value to initialize this &lt;code&gt;Nullable&lt;/code&gt; with.</source>
          <target state="translated">이 &lt;code&gt;Nullable&lt;/code&gt; 을 초기화 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d9870b988dc93826e41d9e14caae258236099356" translate="yes" xml:space="preserve">
          <source>The value to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 에 곱할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b63d59c749f4e3c4e27b5c62bc54fa60f14460d7" translate="yes" xml:space="preserve">
          <source>The value to multiply/divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 을 곱하거나 나누는 값 입니다.</target>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="translated">검색 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="26611747ab051faf83da9bb9d7c2556f3251cdff" translate="yes" xml:space="preserve">
          <source>The value to store.</source>
          <target state="translated">저장할 값입니다.</target>
        </trans-unit>
        <trans-unit id="623dc949267aac51bc4afc97ec71884d344d0223" translate="yes" xml:space="preserve">
          <source>The value to subtract.</source>
          <target state="translated">뺄 값입니다.</target>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="translated">테스트 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="19051782b6b3c278237f01645d39c916e236a933" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
          <target state="translated">쓸 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed8375fc18b2f2889a5d8178e1f4e71c024e1115" translate="yes" xml:space="preserve">
          <source>The value to yield.</source>
          <target state="translated">산출 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">가치.</target>
        </trans-unit>
        <trans-unit id="d9c7ac0f2459cf0fcaba3e1a3c53a1114b6dd604" translate="yes" xml:space="preserve">
          <source>The values of the statistics. Has the same length as &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">통계 값. &lt;code&gt;opts&lt;/code&gt; 와 길이가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="73dba46e865b8a15dc63f7dc2a467e9bb9da631f" translate="yes" xml:space="preserve">
          <source>The values to compare the value to.</source>
          <target state="translated">값을 비교할 값입니다.</target>
        </trans-unit>
        <trans-unit id="75999ceef9f4bfecc84eef7c1abce7ef1a1e25fa" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">최대 값을 선택할 값입니다. 두 개 이상의 인수가 전달되어야하며 &lt;code&gt;&amp;gt;&lt;/code&gt; 와 비교할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c472612eda8a57b671db853841e452b39218b0df" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed.</source>
          <target state="translated">최대 값을 선택할 값입니다. 최소한 두 개의 인수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a965cfb58b4af69ed40e336a152e8e938e3ae5e" translate="yes" xml:space="preserve">
          <source>The values to select the minimum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">최소값을 선택할 값입니다. 최소한 두 개의 인수를 전달해야하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 과 비교할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c4b476e00d554e5b462693564ced434266700cc" translate="yes" xml:space="preserve">
          <source>The vararg module is intended to facilitate vararg manipulation in D. It should be interface compatible with the C module &quot;stdarg,&quot; and the two modules may share a common implementation if possible (as is done here).</source>
          <target state="translated">vararg 모듈은 D에서 vararg 조작을 용이하게하기위한 것입니다. C 모듈 &quot;stdarg&quot;와 인터페이스 호환 가능해야하며 두 모듈은 가능한 경우 공통 구현을 공유 할 수 있습니다 (여기에서 수행됨).</target>
        </trans-unit>
        <trans-unit id="e58c51068f71cad0c83773e1d40394fdd897c493" translate="yes" xml:space="preserve">
          <source>The variable to initialize</source>
          <target state="translated">초기화 할 변수</target>
        </trans-unit>
        <trans-unit id="da94a792f23c83ccf884c163bc10a13c232be367" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="translated">가변성 인수는 일반적으로 순서대로 사용됩니다. POSIX 스타일 &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt;위치 매개 변수 구문&lt;/a&gt; 도 지원됩니다. 각 인수는 형식 스펙에 따라 일련의 문자로 형식화되며 문자는 &lt;code&gt;w&lt;/code&gt; . 형식 문자열에 지정된 수의 인수가 사용 및 형식화됩니다. 형식 지정자보다 인수가 적 으면 &lt;code&gt;FormatException&lt;/code&gt; 이 발생합니다. 형식 스펙에서 필요로하는 것보다 더 많은 인수가 있으면, 하나 이상의 인수가 형식화 된 경우에만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="216b723ca73a81fccb72adcc25ca697c2c2b2944" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;https://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8f9f636d8a6045425f97a32a164b87a688ed99" translate="yes" xml:space="preserve">
          <source>The variadic part is converted to a dynamic array and the rest is the same as for non-variadic functions.</source>
          <target state="translated">variadic 부분은 동적 배열로 변환되고 나머지는 가변적이지 않은 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4280e8c5fae666595a22ad15b85940850cfe38e7" translate="yes" xml:space="preserve">
          <source>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</source>
          <target state="translated">벡터 확장은 현재 OS X 32 비트 대상 및 모든 64 비트 대상에 대해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3f2a8776586397a6e7f50b19626acf584f35ca" translate="yes" xml:space="preserve">
          <source>The vendor specific version number, as in version_major.version_minor</source>
          <target state="translated">version_major.version_minor에서와 같이 공급 업체별 버전 번호</target>
        </trans-unit>
        <trans-unit id="00e7fe40797e665c537b4d388116b4be59e896ff" translate="yes" xml:space="preserve">
          <source>The version of the D Programming Language Specification supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 D 프로그래밍 언어 사양의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="349a4c5870066cd09694037d969de8543ecfc287" translate="yes" xml:space="preserve">
          <source>The version specification makes it straightforward to group a set of features under one major version, for example:</source>
          <target state="translated">버전 사양은 다음과 같이 하나의 주요 버전으로 일련의 기능을 쉽게 그룹화 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8bd1d61a79fbe94ca1f6332082364d1be24742ef" translate="yes" xml:space="preserve">
          <source>The vtable consists of:</source>
          <target state="translated">vtable은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b5820f28d3bae10a6ec27f163ae2a69ac3fe29" translate="yes" xml:space="preserve">
          <source>The way the type of</source>
          <target state="translated">유형의 방법</target>
        </trans-unit>
        <trans-unit id="0fcc6679e5070c2e4f446305491364698920c76a" translate="yes" xml:space="preserve">
          <source>The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right.</source>
          <target state="translated">이것을 읽는 방법은 다음의 숫자보다 작은 모든 숫자 가이 세트에 존재하지 않는다는 부정적인 의미로 시작합니다 (긍정적 인-반대). 그런 다음 각 숫자가 왼쪽에서 오른쪽으로 지나간 후에 양수 / 음수로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="ee95d5338e2cc507c044af212b980a2ccdb0be06" translate="yes" xml:space="preserve">
          <source>The week that each time point in the range will be.</source>
          <target state="translated">범위의 각 시점이되는 주입니다.</target>
        </trans-unit>
        <trans-unit id="cd65d21aaa17290a8030b106efe73434ab04b752" translate="yes" xml:space="preserve">
          <source>The worker threads in this pool will not stop until &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; is called, even if the main thread has finished already. This may lead to programs that never end. If you do not want this behaviour, you can set &lt;code&gt;isDaemon&lt;/code&gt; to true.</source>
          <target state="translated">이 풀의 작업자 스레드 는 기본 스레드가 이미 완료된 경우에도 &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;finish&lt;/code&gt; 가 호출 될 때까지 중지 되지 않습니다 . 이것은 결코 끝나지 않는 프로그램으로 이어질 수 있습니다. 이 동작을 원하지 않는 경우 &lt;code&gt;isDaemon&lt;/code&gt; 을 true로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccaf69d731f86b374a2484d6db7113668b98a057" translate="yes" xml:space="preserve">
          <source>The worker treads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by the &lt;code&gt;taskPool&lt;/code&gt; property are daemon by default. The worker threads of manually instantiated task pools are non-daemon by default.</source>
          <target state="translated">&lt;code&gt;taskPool&lt;/code&gt; 속성이 반환 한 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스 의 작업자 트레드는 기본적으로 데몬입니다. 수동으로 인스턴스화 된 작업 풀의 작업자 스레드는 기본적으로 데몬이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="032848bfda222930e013953265615c3e0ccbd961" translate="yes" xml:space="preserve">
          <source>The working directory for the new process. By default the child process inherits the parent's working directory.</source>
          <target state="translated">새 프로세스의 작업 디렉토리 기본적으로 자식 프로세스는 부모의 작업 디렉토리를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="5b0246698510343503660da61604a3af0a5e9947" translate="yes" xml:space="preserve">
          <source>The wrapped statement.</source>
          <target state="translated">랩핑 된 명령문.</target>
        </trans-unit>
        <trans-unit id="83d3fe39ddb643ccc2434ee8c1b4b3abc6a78d80" translate="yes" xml:space="preserve">
          <source>The wrapped type for which Nullable provides a null value.</source>
          <target state="translated">Nullable이 널값을 제공하는 랩핑 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="52054c2c6d64acc406d7bd018817d7a8a1e5c5bf" translate="yes" xml:space="preserve">
          <source>The write end of the pipe.</source>
          <target state="translated">파이프의 쓰기 끝입니다.</target>
        </trans-unit>
        <trans-unit id="d72f5499f6b8ab39b36f3e5d6ad25d6e2121747c" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 년도를 설정할 BC 연도입니다.</target>
        </trans-unit>
        <trans-unit id="70438f0b3fdbdd369345e88c2fd45090d92cb7e3" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 연도를 설정할 BC 연도입니다.</target>
        </trans-unit>
        <trans-unit id="744d36d482072547f2d6e876741e0a75ffde2547" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 연도를 설정하는 BC 연도입니다.</target>
        </trans-unit>
        <trans-unit id="645eb13622787fa8a0e2f12539a4222d12dcebc3" translate="yes" xml:space="preserve">
          <source>The year inside the ISO 8601 week calendar that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 있는 ISO 8601 주 달력 내의 연도 입니다.</target>
        </trans-unit>
        <trans-unit id="6f253f2171ebe80090cc18ce562187b7793a28ea" translate="yes" xml:space="preserve">
          <source>The year of the ISO 8601 week calendar that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 있는 ISO 8601 주 달력의 연도입니다 .</target>
        </trans-unit>
        <trans-unit id="90ffac4afd7dedd0db0cf62512494ecd5d03ce9b" translate="yes" xml:space="preserve">
          <source>The year of the day to validate.</source>
          <target state="translated">확인할 연도입니다.</target>
        </trans-unit>
        <trans-unit id="6a632533914c1a4222f015d798cec051375cb6c9" translate="yes" xml:space="preserve">
          <source>The year portion of the date.</source>
          <target state="translated">날짜의 연도 부분입니다.</target>
        </trans-unit>
        <trans-unit id="674f0ed2625d2fbf8d46e126ee7509b07e39337e" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 연도를 설정할 연도입니다.</target>
        </trans-unit>
        <trans-unit id="78b3d4944643d10e9690ce8b16f07cee0b861543" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 연도를 설정할 연도입니다.</target>
        </trans-unit>
        <trans-unit id="938c9fb56ce9737aba86f7a255d511c39f3f1219" translate="yes" xml:space="preserve">
          <source>The year to set this Date's year to.</source>
          <target state="translated">이 날짜의 연도를 설정할 연도입니다.</target>
        </trans-unit>
        <trans-unit id="25dac3542e9629d3c6f770b554d3c9420550d89e" translate="yes" xml:space="preserve">
          <source>The year to to be tested.</source>
          <target state="translated">테스트 할 연도입니다.</target>
        </trans-unit>
        <trans-unit id="6dbbdf11fc9d313a566bcf1e2531faa610eda60f" translate="yes" xml:space="preserve">
          <source>The zip file format version needed to extract this member.</source>
          <target state="translated">이 멤버를 추출하는 데 필요한 zip 파일 형식 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b05a3a1416ac42134535e13e8cceef19ad3efbf2" translate="yes" xml:space="preserve">
          <source>The ~= operator. It can have one of the following operators:</source>
          <target state="translated">~ = 연산자 다음 연산자 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483dc9258037e4ea0f71ce99febdf439cc645ac7" translate="yes" xml:space="preserve">
          <source>Then each of the arguments whose type does not match that of the delegate is converted to a delegate.</source>
          <target state="translated">그런 다음 대리자의 형식과 일치하지 않는 각 인수는 대리자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="51ac7bc32bb46bc23b3538364d227ae9bc701e39" translate="yes" xml:space="preserve">
          <source>Then you can import the package containing the extern C++ declarations as follows:</source>
          <target state="translated">그런 다음 다음과 같이 extern C ++ 선언이 포함 된 패키지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef903eb9cd7218e2998c6f06dec42c64cb3057d" translate="yes" xml:space="preserve">
          <source>ThenStatement</source>
          <target state="translated">ThenStatement</target>
        </trans-unit>
        <trans-unit id="cffa55acb530a469e1c0e72f460da047941e3e1e" translate="yes" xml:space="preserve">
          <source>There are advantages to storing bookkeeping data separated from the payload (as opposed to e.g. using &lt;code&gt;AffixAllocator&lt;/code&gt; to store metadata together with each allocation). The layout is more compact (overhead is one bit per block), searching for a free block during allocation enjoys better cache locality, and deallocation does not touch memory around the payload being deallocated (which is often cold).</source>
          <target state="translated">페이로드와 분리 된 부기 데이터를 저장하면 이점이 있습니다 (예를 들어 각 할당과 함께 메타 데이터를 저장하기 위해 &lt;code&gt;AffixAllocator&lt;/code&gt; 사용 ). 레이아웃은보다 간결하며 (오버 헤드는 블록 당 1 비트), 할당하는 동안 사용 가능한 블록을 검색하면 더 나은 캐시 위치를 누릴 수 있으며 할당 해제는 할당 해제되는 페이로드 주변의 메모리에 닿지 않습니다 (종종 콜드).</target>
        </trans-unit>
        <trans-unit id="71da829c4cc0769086794220605ec04ef8da0ce9" translate="yes" xml:space="preserve">
          <source>There are eight usable logging level. These level are</source>
          <target state="translated">사용 가능한 로깅 레벨은 8 가지입니다. 이 수준은</target>
        </trans-unit>
        <trans-unit id="88bbdd16439c34d51b5285ff9a938ae545ede756" translate="yes" xml:space="preserve">
          <source>There are four kinds of arrays:</source>
          <target state="translated">4 가지 종류의 배열이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e137971ce6d07a865f890bb2bb72e21617522984" translate="yes" xml:space="preserve">
          <source>There are four overloads of this function. The first two take an array of strings, &lt;code&gt;args&lt;/code&gt;, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, &lt;code&gt;program&lt;/code&gt;, which specifies the program name.</source>
          <target state="translated">이 기능에는 4 가지 과부하가 있습니다. 처음 두 개는 문자열 배열 &lt;code&gt;args&lt;/code&gt; 를 취하는데 , 여기에는 프로그램 이름을 0 번째 요소로 포함하고 후속 요소의 명령 줄 인수를 포함해야합니다. 세 번째와 네 번째 버전은 편의상 포함되었으며 명령 줄 인수가 없을 때 사용할 수 있습니다. 프로그램 이름을 지정 하는 단일 문자열 &lt;code&gt;program&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="72dc9dd21f6b2060d2cd40a0fb38433822ac81cb" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;bwdRange&lt;/code&gt; 에 전달할 공통 델리게이트를 생성하는 헬퍼 함수가 있습니다 . 문서는 &quot;범위 생성 기능&quot;으로 시작하여 쉽게 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5dd0af54e988a94be1d9ad088b9582f13489afd" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;bwdRange&lt;/code&gt; 에 전달할 공통 델리게이트를 생성하는 헬퍼 함수가 있습니다 . 이들의 문서는 쉽게 검색 할 수 있도록 &quot;범위 생성 기능&quot;으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7d94c1629b0bd4094ede841815962ed80d0586ef" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;fwdRange&lt;/code&gt; 에 전달할 공통 대리자를 생성하는 도우미 함수가 있습니다 . 문서는 &quot;범위 생성 기능&quot;으로 시작하여 쉽게 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9f6a69e089c92a07a88022f54475869259bbc2" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;fwdRange&lt;/code&gt; 에 전달할 공통 대리자를 생성하는 도우미 함수가 있습니다 . 이들의 문서는 쉽게 검색 할 수 있도록 &quot;범위 생성 기능&quot;으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fd1414ed61178080af45a1f5ca51914c6e9d26e1" translate="yes" xml:space="preserve">
          <source>There are many articles available that can bolster understanding ranges:</source>
          <target state="translated">이해 범위를 강화할 수있는 많은 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d037a1149b17d68159307022f28fe56d8f92d3" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt;&lt;/a&gt;, or other such C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;extended type modifiers&lt;/a&gt; in D. These are handled by &lt;a href=&quot;attribute#linkage&quot;&gt;linkage attributes&lt;/a&gt;, such as &lt;code&gt;extern (C)&lt;/code&gt;.</source>
          <target state="translated">D에는 &lt;code&gt;__cdecl&lt;/code&gt; , &lt;code&gt;__far&lt;/code&gt; , &lt;code&gt;__stdcall&lt;/code&gt; , &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt; &lt;/a&gt; 또는 기타 C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;확장 유형 수정자가 없습니다&lt;/a&gt; . 이들은 &lt;code&gt;extern (C)&lt;/code&gt; 와 같은 &lt;a href=&quot;attribute#linkage&quot;&gt;연결 특성에&lt;/a&gt; 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b9f66c209295069e84d0b1adcf2cd5cdb6933de" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, or other such nonstandard C++ extensions in D.</source>
          <target state="translated">D에는 &lt;code&gt;__cdecl&lt;/code&gt; , &lt;code&gt;__far&lt;/code&gt; , &lt;code&gt;__stdcall&lt;/code&gt; , &lt;code&gt;__declspec&lt;/code&gt; 또는 기타 이러한 비표준 C ++ 확장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b1bbd1ded800fb7f0f4f094477d38ab432c667c3" translate="yes" xml:space="preserve">
          <source>There are no volatile type modifiers in D.</source>
          <target state="translated">D에는 휘발성 유형 수정자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf7de3e93eae097ffa9c0cf65d8e97655fc5a893" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="translated">초보자를 돕기 위해 정규식에 다른 웹 리소스가 &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;있으며 자습서를 참조&lt;/a&gt; 하면 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2543503ec295753afb9344097b9b1cd50cfed3df" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;https://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5539350a7f6635346ecf0167abeb30fa2fea73" translate="yes" xml:space="preserve">
          <source>There are several forms of the</source>
          <target state="translated">몇 가지 형태가 있습니다</target>
        </trans-unit>
        <trans-unit id="6bdc06ec8e2f529ede508fc3fd01087470669fa0" translate="yes" xml:space="preserve">
          <source>There are several things going on here:</source>
          <target state="translated">여기에는 몇 가지 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fc1953f9bbd669c6940d581b7a118ebf65b6cd" translate="yes" xml:space="preserve">
          <source>There are several workarounds for this limitation:</source>
          <target state="translated">이 제한에 대한 몇 가지 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83683e99bdd11374a698bc33993ac450a4156b31" translate="yes" xml:space="preserve">
          <source>There are three categories of functions from the perspective of memory safety:</source>
          <target state="translated">메모리 안전성 관점에서 세 가지 범주의 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebb936bce7d3ae26cde36cf7bb35604dacc5791" translate="yes" xml:space="preserve">
          <source>There are three kinds of comments:</source>
          <target state="translated">다음과 같은 세 가지 종류의 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec3b7350c3966a7a5f315773f8a0d6461bc2b7c" translate="yes" xml:space="preserve">
          <source>There are two APIs for digests: The template API and the OOP API. The template API uses structs and template helpers like &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;. The OOP API implements digests as classes inheriting the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; interface. All digests are named so that the template API struct is called &quot;&lt;b&gt;x&lt;/b&gt;&quot; and the OOP API class is called &quot;&lt;b&gt;x&lt;/b&gt;Digest&quot;. For example we have &lt;code&gt;MD5&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt;, &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt;, etc.</source>
          <target state="translated">다이제스트를위한 두 가지 API가 있습니다 : 템플릿 API와 OOP API. 템플릿 API는 &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; 와 같은 구조체와 템플릿 도우미를 사용합니다 . OOP API는 &lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt; 인터페이스를 상속하는 클래스로 다이제스트를 구현 합니다. 템플릿 API 구조체는 &quot; &lt;b&gt;x&lt;/b&gt; &quot;, OOP API 클래스는 &quot; &lt;b&gt;x&lt;/b&gt; Digest&quot; 가 되도록 모든 다이제스트의 이름을 지정 합니다. 예를 들어 &lt;code&gt;MD5&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt; , &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt; 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36743287cbe9730e4d00f520be725403f6d9245" translate="yes" xml:space="preserve">
          <source>There are two broad kinds of operations to do on an array - affecting the handle to the array, and affecting the contents of the array.</source>
          <target state="translated">배열에 대해 수행 할 작업에는 배열에 대한 핸들과 배열의 내용에 영향을 미치는 두 가지 종류의 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="355137d832c3c393499aa7072985b4778468466a" translate="yes" xml:space="preserve">
          <source>There are two categories of overloads in this template: the first one does a simple compare-and-set, and returns a boolean if the operation happened. The value this is written (&lt;code&gt;writeThis&lt;/code&gt;) can be an rvalue. the second category does a compare-and-swap, or compare-and-exchange, and expects &lt;code&gt;writeThis&lt;/code&gt; to be a pointer type, where the previous value of &lt;code&gt;here&lt;/code&gt; will be written.</source>
          <target state="translated">이 템플릿에는 두 가지 범주의 오버로드가 있습니다. 첫 번째 범주는 간단한 비교 및 ​​설정을 수행하고 작업이 발생하면 부울을 반환합니다. 기록 된 값 ( &lt;code&gt;writeThis&lt;/code&gt; )은 rvalue 일 수 있습니다. 두 번째 범주는 비교 및 스왑, 또는 비교 및 교환, 그리고 예상하는의 수행 &lt;code&gt;writeThis&lt;/code&gt; 을 의 이전 값 포인터 타입으로 &lt;code&gt;here&lt;/code&gt; 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1096c19f131f18fc7530f2ce040303f511bfe2" translate="yes" xml:space="preserve">
          <source>There are two main ways of usage: Extracting files from a zip archive and storing files into a zip archive. These can be mixed though (e.g. read an archive, remove some files, add others and write the new archive).</source>
          <target state="translated">두 가지 주요 사용 방법이 있습니다. zip 아카이브에서 파일을 추출하고 zip 아카이브에 파일을 저장하는 것입니다. 그러나 이들은 혼합 될 수 있습니다 (예 : 아카이브 읽기, 일부 파일 제거, 다른 파일 추가 및 새 아카이브 쓰기).</target>
        </trans-unit>
        <trans-unit id="2f32e0774371c9709a85def64d98a62e794b8e4d" translate="yes" xml:space="preserve">
          <source>There are two options for handlers. The &lt;code&gt;bool&lt;/code&gt; version is deprecated but will be kept for legacy support. Returning &lt;code&gt;true&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.pass&lt;/code&gt; from the extended version. Returning &lt;code&gt;false&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.fail&lt;/code&gt; from the extended version.</source>
          <target state="translated">핸들러에는 두 가지 옵션이 있습니다. &lt;code&gt;bool&lt;/code&gt; 버전은 더 이상 사용되지 않고 레거시 지원을 위해 유지됩니다. 반환 &lt;code&gt;true&lt;/code&gt; 핸들러에서하는 것은 반환에 해당 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 을 확장 버전. 반환 &lt;code&gt;false&lt;/code&gt; 핸들러에서하는 것은 반환에 해당 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; 을 확장 버전.</target>
        </trans-unit>
        <trans-unit id="2ba98a9e569b41d605493fc4327d51d93311f773" translate="yes" xml:space="preserve">
          <source>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;. The second way is putting a username after the tilde (i.e. &lt;code&gt;~john/Mail&lt;/code&gt;). Here, the username will be searched for in the user database (i.e. &lt;code&gt;/etc/passwd&lt;/code&gt; on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator.</source>
          <target state="translated">경로에서 물결표 확장을 사용하는 방법에는 두 가지가 있습니다. 하나는 물결표를 단독으로 사용하거나 경로 구분 기호를 사용하는 것입니다. 이 경우 물결표는 환경 변수 &lt;code&gt;HOME&lt;/code&gt; 값으로 확장됩니다 . 두 번째 방법은 물결표 뒤에 사용자 이름을 넣는 것입니다 (예 : &lt;code&gt;~john/Mail&lt;/code&gt; ). 여기서 사용자 이름은 사용자 데이터베이스 (예 : Unix 시스템의 경우 &lt;code&gt;/etc/passwd&lt;/code&gt; ) 에서 검색되어 저장된 경로로 확장됩니다. 사용자 이름은 물결표 뒤의 경로 구분 기호의 첫 번째 인스턴스에서 끝나는 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4751b63f33932c16045492e8c9d0524f058f4c0a" translate="yes" xml:space="preserve">
          <source>There are two ways to declarate a symbol as member of a namespace: &lt;code&gt;Nspace&lt;/code&gt; and &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt;. The former creates a scope for the symbol, and inject them in the parent scope at the same time. The later, this class, has no semantic implications and is only used for mangling. Additionally, this class allows one to use reserved identifiers (D keywords) in the namespace.</source>
          <target state="translated">네임 스페이스의 멤버로 심볼을 선언하는 방법에는 &lt;code&gt;Nspace&lt;/code&gt; 와 &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; 의 두 가지가 있습니다 . 전자는 심볼의 범위를 생성하고 동시에 부모 범위에 주입합니다. 나중에이 클래스는 의미 적 의미가 없으며 맨 글링에만 사용됩니다. 또한이 클래스를 사용하면 네임 스페이스에서 예약 식별자 (D 키워드)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87bb5bc4a10799fcef3cdb638af33c37c5ac5274" translate="yes" xml:space="preserve">
          <source>There can be any number of unit test functions in a module, including within struct, union and class declarations. They are executed in lexical order.</source>
          <target state="translated">struct, union 및 class 선언을 포함하여 모듈에 여러 단위 테스트 함수가있을 수 있습니다. 어휘 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ed108d2e4ffaebbc3cca03de1cfa2dee10188c4a" translate="yes" xml:space="preserve">
          <source>There can be more than one invariant declared per class or struct.</source>
          <target state="translated">클래스 또는 구조체마다 둘 이상의 고정 변수가 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b99c3830a2a4bb0228e8b9b17dd7669ccd56c2" translate="yes" xml:space="preserve">
          <source>There can be multiple documented unittests and they can appear in any order. They will be attached to the last non-unittest declaration:</source>
          <target state="translated">문서화 된 여러 단위 테스트가있을 수 있으며 순서에 상관없이 나타날 수 있습니다. 그것들은 마지막 비유 니트 선언에 첨부됩니다 :</target>
        </trans-unit>
        <trans-unit id="a95e25d0165fbf5408fd68a513879e3e08629026" translate="yes" xml:space="preserve">
          <source>There can be multiple static constructors and static destructors within one module. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="translated">하나의 모듈 내에 여러 정적 생성자와 정적 소멸자가있을 수 있습니다. 정적 생성자는 어휘 순서로 실행되고 정적 소멸자는 어휘 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="079786d2cc065de51998cade65524ac448945bab" translate="yes" xml:space="preserve">
          <source>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual.</source>
          <target state="translated">클래스 당 하나의 소멸자 만있을 수 있으며 소멸자에는 매개 변수가 없으며 속성이 없습니다. 항상 가상입니다.</target>
        </trans-unit>
        <trans-unit id="a32fb137b8708f3a1060842effbe53862ee224b5" translate="yes" xml:space="preserve">
          <source>There can be only zero or one</source>
          <target state="translated">0 또는 1 만있을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="997178780ab769837ddb59d8efa52d7b04a80956" translate="yes" xml:space="preserve">
          <source>There can only be one such attribute per symbol.</source>
          <target state="translated">이러한 속성은 기호 당 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54e87553bcbc89bb92a0dbc881f7633b6a68acf" translate="yes" xml:space="preserve">
          <source>There has been a great deal of discussion in the D newsgroups over this, and several implementations:  &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;signal slots library&lt;/a&gt;</source>
          <target state="translated">이에 대한 D 뉴스 그룹과 여러 가지 구현에 대해 많은 논의가있었습니다 : &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;신호 슬롯 라이브러리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4241af492e556aa6aed9941d820f825c722aec" translate="yes" xml:space="preserve">
          <source>There have been several D implementations of Signals and Slots. This version makes use of several new features in D, which make using it simpler and less error prone. In particular, it is no longer necessary to instrument the slots.</source>
          <target state="translated">신호 및 슬롯의 몇 가지 D 구현이있었습니다. 이 버전은 D의 몇 가지 새로운 기능을 사용하므로보다 간단하고 오류 발생이 적습니다. 특히, 더 이상 슬롯을 계측 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="137e54850bfef26233dbe4876142a62cdeee9d88" translate="yes" xml:space="preserve">
          <source>There is a hierarchy of allocation kinds. When an allocator is implemented for a given combination of flags, it is used. Otherwise, the next down the list is chosen.</source>
          <target state="translated">할당 종류의 계층 구조가 있습니다. 지정된 플래그 조합에 대해 할당자가 구현되면 사용됩니다. 그렇지 않으면 목록에서 아래로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4bb1493d0166938db3cf214276bbc597f0dc3b" translate="yes" xml:space="preserve">
          <source>There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 모듈에 정의 된 문자열 처리를위한 다양한 기능이 있습니다. 유니 코드 및 ASCII와 관련된 함수는 각각 &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; &lt;/a&gt; 에 있습니다. 문자열보다 일반성이 더 큰 다른 함수는 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="567058ffed748f85071d989bbf1a314374e793b2" translate="yes" xml:space="preserve">
          <source>There is a special type of array which acts as a wildcard that can hold arrays of any kind, declared as &lt;code&gt;void[]&lt;/code&gt;. Void arrays are used for low-level operations where some kind of array data is being handled, but the exact type of the array elements are unimportant. The &lt;code&gt;.length&lt;/code&gt; of a void array is the length of the data in bytes, rather than the number of elements in its original type. Array indices in indexing and slicing operations are interpreted as byte indices.</source>
          <target state="translated">&lt;code&gt;void[]&lt;/code&gt; 로 선언 된 모든 종류의 배열을 보유 할 수있는 와일드 카드 역할을하는 특수한 유형의 배열이 있습니다 . Void 배열은 어떤 종류의 배열 데이터가 처리되는 낮은 수준의 작업에 사용되지만 정확한 배열 요소 유형은 중요하지 않습니다. void 배열 의 &lt;code&gt;.length&lt;/code&gt; 는 원래 유형의 요소 수가 아니라 바이트 단위의 데이터 길이입니다. 인덱싱 및 슬라이싱 작업의 배열 인덱스는 바이트 인덱스로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="33cea21ca6b34b343eb25bbde6ebec03ec759bdc" translate="yes" xml:space="preserve">
          <source>There is currently only one special token sequence, &lt;code&gt;#line&lt;/code&gt;.</source>
          <target state="translated">현재 하나의 특수 토큰 시퀀스, &lt;code&gt;#line&lt;/code&gt; 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef49fac97d8d2e188e2b78d1a813470cc50ed39b" translate="yes" xml:space="preserve">
          <source>There is currently work in progress to make the runtime library free of GC heap allocations, to allow its use in scenarios where the use of GC infrastructure is not possible.</source>
          <target state="translated">현재 런타임 라이브러리에 GC 힙 할당이 없어서 GC 인프라를 사용할 수없는 시나리오에서 사용할 수 있도록 진행중인 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d933b4164fe170e150ab2367873a597423583d2" translate="yes" xml:space="preserve">
          <source>There is no more need to translate error codes into human readable strings, the correct string is generated by the error detection code, not the error recovery code. This also leads to consistent error messages for the same error between applications.</source>
          <target state="translated">더 이상 오류 코드를 사람이 읽을 수있는 문자열로 변환 할 필요가 없습니다. 오류 복구 코드가 아니라 오류 감지 코드에 의해 올바른 문자열이 생성됩니다. 또한 응용 프로그램간에 동일한 오류에 대해 일관된 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f17b623fe683ff68f6ed189b8d0d74d5452c95d7" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">음의 무한대에서 양의 무한대로가는 간격 이 &lt;code&gt;NegInfInterval&lt;/code&gt; 하기 때문에 NegInfInterval 을 취하는 &lt;code&gt;merge&lt;/code&gt; 대한 과부하 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e26153f4d19858ed80c05ff7d79d4191b5074d49" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">음의 무한대에서 양의 무한대까지의 간격 이 &lt;code&gt;PosInfInterval&lt;/code&gt; 하기 때문에 PosInfInterval 을 취하는 &lt;code&gt;merge&lt;/code&gt; 대한 과부하 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f100a7a77aee94633ec1e2fffc1096ce477240e" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">음의 무한대에서 양의 무한대로가는 간격 이 &lt;code&gt;NegInfInterval&lt;/code&gt; 하기 때문에 NegInfInterval 을 취하는 &lt;code&gt;span&lt;/code&gt; 에 대한 과부하 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ac7b0e8d9f0ebf981b0a2590d75065c28e84b23" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">음의 무한대에서 양의 무한대로가는 간격 이 &lt;code&gt;PosInfInterval&lt;/code&gt; 하기 때문에 PosInfInterval 을 취하는 &lt;code&gt;span&lt;/code&gt; 에 대한 과부하 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2973bc2fd6add6e6231856c6dedc987f0924540" translate="yes" xml:space="preserve">
          <source>There is no remove command functionality. Do a &lt;a href=&quot;#clearCommands&quot;&gt;&lt;code&gt;clearCommands&lt;/code&gt;&lt;/a&gt; and set the needed commands instead.</source>
          <target state="translated">제거 명령 기능이 없습니다. DO가 &lt;a href=&quot;#clearCommands&quot;&gt; &lt;code&gt;clearCommands&lt;/code&gt; 를&lt;/a&gt; 대신 필요한 명령을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5030f2329ed730fd9eebd4cf5437fa2be5db1b38" translate="yes" xml:space="preserve">
          <source>There is no remove header functionality. Do a &lt;a href=&quot;#clearRequestHeaders&quot;&gt;&lt;code&gt;clearRequestHeaders&lt;/code&gt;&lt;/a&gt; and set the needed headers instead.</source>
          <target state="translated">헤더 제거 기능이 없습니다. DO가 &lt;a href=&quot;#clearRequestHeaders&quot;&gt; &lt;code&gt;clearRequestHeaders&lt;/code&gt; 를&lt;/a&gt; 대신 필요한 헤더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="97b11eff895aae8a00d7fa461823417d322a76c8" translate="yes" xml:space="preserve">
          <source>There is no virtual table.</source>
          <target state="translated">가상 테이블이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dac0a061658caed895ea08b3637f43c40d7da9d" translate="yes" xml:space="preserve">
          <source>There is no volatile type modifier in D. To declare a C function that uses volatile, just drop the keyword from the declaration.</source>
          <target state="translated">D에는 휘발성 유형 수정자가 없습니다. 휘발성을 사용하는 C 함수를 선언하려면 선언에서 키워드를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="2434d329704768f135cc60da2cb84c7ba22ac13f" translate="yes" xml:space="preserve">
          <source>There is one exception to the fact that the new type is not related to the old type. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Pseudo-member&lt;/a&gt; functions are usable with the new type; they will be forwarded on to the proxied value.</source>
          <target state="translated">새 유형이 이전 유형과 관련이 없다는 사실에는 예외가 있습니다. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;의사 멤버&lt;/a&gt; 함수는 새로운 유형으로 사용할 수 있습니다. 그들은 프록시 값으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ba21f8033d033a747c90b386e1729af20f18ceb8" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a class. They are applied in lexical order.</source>
          <target state="translated">클래스에는 여러 개의 불변이있을 수 있습니다. 그것들은 어휘 순서로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a039cc903df4604c54902450e403871fe046481" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a struct. They are applied in lexical order.</source>
          <target state="translated">구조체에 여러 불변이있을 수 있습니다. 그것들은 어휘 순서로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d77d0c2b7a22ee08dcc65faf1983734627d5bea1" translate="yes" xml:space="preserve">
          <source>There may be one or more callable entities (&lt;code&gt;functions&lt;/code&gt; argument) to apply.</source>
          <target state="translated">적용 할 하나 이상의 호출 가능 엔터티 ( &lt;code&gt;functions&lt;/code&gt; 인수)가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ca8690590fc77f40e2a27fd064159d0d52468b" translate="yes" xml:space="preserve">
          <source>There must be at least one non-variadic parameter declared.</source>
          <target state="translated">가변적이지 않은 매개 변수가 하나 이상 선언되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="60b895f637fb0461c08aa3c29c276b9513bb30e3" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a function symbol.</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 이 하나 있어야하며 컴파일시 함수 심볼로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed59ba7f34618cfcf4f2f62b488d49f3556f524b" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a string literal.</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 이 하나 있어야하며 컴파일시 문자열 리터럴로 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9800621b870999653a584633cd52d141e5fbaea7" translate="yes" xml:space="preserve">
          <source>There's only one instance of each module, and it is statically allocated.</source>
          <target state="translated">각 모듈의 인스턴스는 하나만 있으며 정적으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="2acf8c215fcf96c4f44ab4510da81603fd6cc2b3" translate="yes" xml:space="preserve">
          <source>Therefore, it is the programmer's responsibility to ensure that &lt;code&gt;opCmp&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; are consistent with each other. If &lt;code&gt;opEquals&lt;/code&gt; is not specified, the compiler provides a default version that does member-wise comparison. If this suffices, one may define only &lt;code&gt;opCmp&lt;/code&gt; to customize the behaviour of the inequality operators. But if not, then a custom version of &lt;code&gt;opEquals&lt;/code&gt; should be defined as well, in order to preserve consistent semantics between the two kinds of comparison operators.</source>
          <target state="translated">따라서 &lt;code&gt;opCmp&lt;/code&gt; 와 &lt;code&gt;opEquals&lt;/code&gt; 가 서로 일치 하는지 확인하는 것은 프로그래머의 책임 입니다. 경우 &lt;code&gt;opEquals&lt;/code&gt; 가 지정되지 않은, 컴파일러는 회원이 많다는 비교를 수행 기본 버전을 제공합니다. 이것이 충분하면, 불평등 연산자의 동작을 사용자 정의하기 위해 &lt;code&gt;opCmp&lt;/code&gt; 만 정의 할 수 있습니다 . 그러나 그렇지 않은 경우 두 종류의 비교 연산자간에 일관된 의미를 유지하려면 &lt;code&gt;opEquals&lt;/code&gt; 의 사용자 정의 버전 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6272f7f8273a14bd5544dddbcb1b98032093e68" translate="yes" xml:space="preserve">
          <source>These allow you to construct a &lt;code&gt;Duration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">이들은 당신이 구성 할 수 있도록 &lt;code&gt;Duration&lt;/code&gt; 주어진 길이 주어진 시간 단위에서.</target>
        </trans-unit>
        <trans-unit id="da7cf3cb33f506c60b3bae2d7621731fe8a25b5a" translate="yes" xml:space="preserve">
          <source>These are a temporary means of providing a GC hook for DLL use. They may be replaced with some other similar functionality later.</source>
          <target state="translated">DLL 사용을위한 GC 후크를 제공하는 임시 수단입니다. 그것들은 나중에 다른 유사한 기능으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b408f5f827798e4336b44c606a3a8049fa5f385" translate="yes" xml:space="preserve">
          <source>These are convenience aliases for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the SHA implementation.</source>
          <target state="translated">이들은 SHA 구현을 사용하는 &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; 의&lt;/a&gt; 편의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="cc11c250252b92e0b68a712fc50db2f954bbf31e" translate="yes" xml:space="preserve">
          <source>These are found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt/&lt;/a&gt;.</source>
          <target state="translated">이들은 Druntime의 &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt /에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82964c86f7448130324ef200af867ae90f45f65" translate="yes" xml:space="preserve">
          <source>These are mostly undocumented, as documentation for the functions these declarations provide bindings to can be found on external resources.</source>
          <target state="translated">이러한 선언이 바인딩을 제공하는 함수에 대한 문서가 외부 자원에서 찾을 수 있으므로 대부분 문서화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a0b799b4059387b1ffa81eb5e832597a15aaf9ea" translate="yes" xml:space="preserve">
          <source>These are not directly overloadable, but instead are rewritten in terms of the ++</source>
          <target state="translated">이들은 직접 오버로드 할 수 없지만 대신 ++로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="684251477ee92646066796884e053236894cc9d8" translate="yes" xml:space="preserve">
          <source>These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</source>
          <target state="translated">이것들은 원자 연산과 관련되어서는 안됩니다. 원 자성을 보장하지 않습니다. 이것은 대상에 사용 된 명령의 결과로 우연의 일치로 제공 될 수 있지만 휴대용 프로그램에 의존해서는 안됩니다. 또한 이러한 기능에 의해 메모리 펜스가 암시되지 않습니다. 스레드 간 통신에 사용해서는 안됩니다. 지정된 주소에서 쓰기 또는 읽기주기가 발생하도록 보장하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd50df5a290d3b9f19a683a307dc1ce5e6fed02" translate="yes" xml:space="preserve">
          <source>These are of type &lt;code&gt;bool&lt;/code&gt; and when cast to another integral type become the values 1 and 0, respectively.</source>
          <target state="translated">이들은 &lt;code&gt;bool&lt;/code&gt; 유형 이며 다른 정수 유형으로 캐스트 될 때 각각 값 1과 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="812c2acf872ebe10657aaa2bbdf1807e2d587d11" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-debug=&lt;/code&gt;</source>
          <target state="translated">이들은 아마도 명령 행에 의해 &lt;code&gt;-debug=&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47c1d2e1e32630d5e744bf290c6e49eb16fa04f9" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-version=n&lt;/code&gt; and &lt;code&gt;-version=identifier&lt;/code&gt;.</source>
          <target state="translated">이들은 아마도 명령 행에 의해 &lt;code&gt;-version=n&lt;/code&gt; 및 &lt;code&gt;-version=identifier&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ddfd41f42add825e0e95354286885963260165" translate="yes" xml:space="preserve">
          <source>These are the return codes for the seek callbacks</source>
          <target state="translated">이것들은 seek 콜백에 대한 리턴 코드입니다.</target>
        </trans-unit>
        <trans-unit id="402db899657981891e40b75b734371cded453058" translate="yes" xml:space="preserve">
          <source>These are the same kinds of scenarios where different optimization settings affect the results.</source>
          <target state="translated">서로 다른 최적화 설정이 결과에 영향을주는 동일한 종류의 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="1b6a4816df5dd7b7abf0b558eca9229ade75c78d" translate="yes" xml:space="preserve">
          <source>These arrays are statically allocated when they appear in global scope. Otherwise, they need to be marked with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; storage classes to make them statically allocated arrays.</source>
          <target state="translated">이러한 배열은 전역 범위에 나타날 때 정적으로 할당됩니다. 그렇지 않으면 정적으로 할당 된 배열로 만들려면 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 스토리지 클래스로 표시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89a145122969b840110b2fc3e84b6ee09c611afa" translate="yes" xml:space="preserve">
          <source>These attributes may appear after the formal parameter list, in which case they apply either to a method's &lt;code&gt;this&lt;/code&gt; parameter, or to a free function's first parameter</source>
          <target state="translated">이러한 속성은 공식 매개 변수 목록 뒤에 나타날 수 있으며,이 경우 메소드 &lt;code&gt;this&lt;/code&gt; 매개 변수 또는 자유 함수의 첫 번째 매개 변수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f7fc51e48ac814a4df7b5cf79166bee33de381" translate="yes" xml:space="preserve">
          <source>These attributes may be inferred when the compiler has the function body available, such as with templates.</source>
          <target state="translated">이러한 속성은 컴파일러에서 템플릿과 같은 함수 본문을 사용할 수있을 때 유추 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c92e5f8eec2fac65821b6ee901edef5b0d32346" translate="yes" xml:space="preserve">
          <source>These behaviors may be specified when a mailbox is full.</source>
          <target state="translated">이러한 동작은 사서함이 가득 찼을 때 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36131b1e9db1f47f4a6ae00babc38af51f8234a5" translate="yes" xml:space="preserve">
          <source>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras.</source>
          <target state="translated">이러한 문자는 설명되어 있지 않으면 일반적으로 분리되어 사용되지 않습니다. 여기에는 악센트, 발음 구별 부호, 히브리어 포인트, 아랍어 모음 표시 및 인도어 matras와 같은 문자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5af07f8dc23a2ff314c5b53d75ac93fc8390edf4" translate="yes" xml:space="preserve">
          <source>These compound format specifiers may be nested in the case of a nested array argument:</source>
          <target state="translated">이러한 복합 형식 지정자는 중첩 배열 인수의 경우 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="636ef2d434aea6975bee7e2e69eaea244d21ce1f" translate="yes" xml:space="preserve">
          <source>These constraints are addressed by techniques outlined in &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;Memory Management&lt;/a&gt;, including the mechanisms provided by D to control allocations outside the GC heap.</source>
          <target state="translated">이러한 제약 조건은 GC 힙 외부의 할당을 제어하기 위해 D에서 제공하는 메커니즘을 포함하여 &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;메모리 관리에&lt;/a&gt; 요약 된 기술로 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce5525a7da98014873ce5f20228128913e88d54f" translate="yes" xml:space="preserve">
          <source>These declarations are transformed into templates:</source>
          <target state="translated">이러한 선언은 템플릿으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd87aa675633720f30baafcf6365c73aa7dc6850" translate="yes" xml:space="preserve">
          <source>These directories are recognized by some tools, like the Objective-C compiler and linker, to be frameworks. To link with a framework from DMD, use the following flags:</source>
          <target state="translated">이러한 디렉토리는 Objective-C 컴파일러 및 링커와 같은 일부 도구에서 프레임 워크로 인식됩니다. DMD의 프레임 워크와 연결하려면 다음 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2db5010283f3eff8277b4bb683d65dd36da0605f" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_HTTP_VERSION option.</source>
          <target state="translated">이 열거 형은 CURLOPT_HTTP_VERSION 옵션과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66b51419f8ca45e5302436f93fca4afec04366fd" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_NETRC option.</source>
          <target state="translated">이 열거 형은 CURLOPT_NETRC 옵션과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="792d4e3a997f4a55954321b6a67c17e920eebf88" translate="yes" xml:space="preserve">
          <source>These equivalents hold for most C compilers. The C standard does not pin down the sizes of the types, so some care is needed.</source>
          <target state="translated">이러한 동등 물은 대부분의 C 컴파일러에 적용됩니다. C 표준은 유형의 크기를 고정하지 않으므로 약간의주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dd5b42710c6e5261013fdb1ae53fc4cbc41fd9bf" translate="yes" xml:space="preserve">
          <source>These equivalents hold when the D and C++ compilers used are companions on the host platform.</source>
          <target state="translated">이러한 동등 물은 사용 된 D 및 C ++ 컴파일러가 호스트 플랫폼의 동반자 일 때 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="90ade43ed5cb1a3092e67126f0f81a88dfd49b38" translate="yes" xml:space="preserve">
          <source>These extensions can be pretty-printed by &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;. The &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; debugger supports them.</source>
          <target state="translated">이 확장은 &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm에&lt;/a&gt; 의해 인쇄 될 수 있습니다 . &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg의&lt;/a&gt; 디버거를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ad13d21d22689769fb2cd4c608e9e8fc232324fc" translate="yes" xml:space="preserve">
          <source>These field were added in CURLVERSION_FOURTH. Same as 'libiconv_version' if built with HAVE_ICONV</source>
          <target state="translated">이 필드는 CURLVERSION_FOURTH에 추가되었습니다. HAVE_ICONV로 빌드 한 경우 'libiconv_version'과 동일</target>
        </trans-unit>
        <trans-unit id="507497a0514f5bd17890a554cbbbf16c831493b7" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent a complex attribute.</source>
          <target state="translated">이 플래그는 비트 단위 OR-ed로 복잡한 속성을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0046ed397526fe785a54f9113f894289f9d20106" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent complex storage class.</source>
          <target state="translated">이 플래그는 비트 단위 OR-ed로 복잡한 스토리지 클래스를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91bde2af8a3dc4b91f2f8c73ebb091513ee7a69a" translate="yes" xml:space="preserve">
          <source>These flags can be set/reset via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">이러한 플래그는 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 의 기능을 통해 설정 / 재설정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10b77f7a0eebb3e7a656fbdfd23d4cee9e1bc0e6" translate="yes" xml:space="preserve">
          <source>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</source>
          <target state="translated">이 플래그는 예외적 인 부동 소수점 조건이 발생했음을 나타냅니다. NaN 또는 무한대가 생성되었거나 결과가 정확하지 않거나 신호 NaN이 발생했음을 나타냅니다. 부동 소수점 예외가 활성화 (마스킹되지 않은 경우)되면 이러한 플래그를 설정하는 대신 하드웨어 예외가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e250dcdba1c724b4c5950d43225e8f190c1411c5" translate="yes" xml:space="preserve">
          <source>These functions allow getting and setting the OS scheduling priority of the worker threads in this &lt;code&gt;TaskPool&lt;/code&gt;. They forward to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;, so a given priority value here means the same thing as an identical priority value in &lt;code&gt;core.thread&lt;/code&gt;.</source>
          <target state="translated">이러한 기능을 통해이 &lt;code&gt;TaskPool&lt;/code&gt; 에서 작업자 스레드의 OS 예약 우선 순위를 가져오고 설정할 수 있습니다. 그것들은 &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; 로 전달 되므로 여기서 주어진 우선 순위 값은 &lt;code&gt;core.thread&lt;/code&gt; 에서 동일한 우선 순위 값과 동일한 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="563010f17028868ed8865c10ee72ad70b45bdc1f" translate="yes" xml:space="preserve">
          <source>These functions allow the creation of &lt;code&gt;Task&lt;/code&gt; objects on the stack rather than the GC heap. The lifetime of a &lt;code&gt;Task&lt;/code&gt; created by &lt;code&gt;scopedTask&lt;/code&gt; cannot exceed the lifetime of the scope it was created in.</source>
          <target state="translated">이러한 기능을 통해 GC 힙이 아닌 스택 에 &lt;code&gt;Task&lt;/code&gt; 객체를 생성 할 수 있습니다. (A)의 수명 &lt;code&gt;Task&lt;/code&gt; 에 의해 생성 &lt;code&gt;scopedTask&lt;/code&gt; 그것으로 만들어진 범위의 수명을 초과 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="4c3aa616b64e71a662b37e0ffc58b47e53c7d7a0" translate="yes" xml:space="preserve">
          <source>These functions are defined by</source>
          <target state="translated">이러한 기능은</target>
        </trans-unit>
        <trans-unit id="64a3eca56341ef165f9199f2a7eb38f22c9f31d6" translate="yes" xml:space="preserve">
          <source>These functions are only available if &lt;code&gt;hasPeek!T&lt;/code&gt; is true.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;hasPeek!T&lt;/code&gt; 가 true 인 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1095cd637088fb9ac4b341f976f96ce873e4a7" translate="yes" xml:space="preserve">
          <source>These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of &lt;code&gt;execv*&lt;/code&gt; by using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and terminating the current process once the child process has returned. For example:</source>
          <target state="translated">Windows 운영 체제는 현재 프로세스 이미지를 다른 프로세스 이미지로 겹쳐 쓸 수있는 기능을 제공하지 않기 때문에 이러한 기능은 POSIX 플랫폼에서만 지원됩니다. 단일 스레드 프로그램에서는 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 를 사용 하고 자식 프로세스가 반환되면 현재 프로세스를 종료 하여 &lt;code&gt;execv*&lt;/code&gt; 의 효과를 근사화 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="536f51437dc16a03b75f3b412228393928fdac5c" translate="yes" xml:space="preserve">
          <source>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread.</source>
          <target state="translated">이러한 함수는 컴파일러에 의해 인식되며 해당 스레드에 대한 호출이 제거되지 않거나 (데드 할당이 제거되거나 효과가없는 것으로 추정 됨) 동일한 스레드에서 재정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1689bc1bc5afab34bd94fef9d049d296d24218eb" translate="yes" xml:space="preserve">
          <source>These functions find the first occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and then split &lt;code&gt;haystack&lt;/code&gt; as follows.</source>
          <target state="translated">이 함수 는 &lt;code&gt;haystack&lt;/code&gt; 에서 처음으로 나타나는 &lt;code&gt;needle&lt;/code&gt; 을 찾은 다음 &lt;code&gt;haystack&lt;/code&gt; 를 다음과 같이 분할 합니다.</target>
        </trans-unit>
        <trans-unit id="4b1cfbf3893f882218472af28278eb2e9814bf0e" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;pred&lt;/code&gt; 를 적절히 선택하여 임의의 극한값을 계산하는 데 사용될 수 있습니다 . 올바른 기능을 위해서는 &lt;code&gt;pred&lt;/code&gt; 는 엄격한 부분적 순서, 즉 전 이적 ( &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; , &lt;code&gt;pred(a, c)&lt;/code&gt; ) 및 비 반사적 ( &lt;code&gt;pred(a, a)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; ) 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="add0a2e2f51a24f38416d0099f1fae2ea0488394" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algorithms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;pred&lt;/code&gt; 적절하게 선택하여 임의의 극값을 계산하는 데 사용할 수 있습니다 . 올바른 기능을 위해 &lt;code&gt;pred&lt;/code&gt; 는 엄격한 부분 순서 여야합니다. 즉, 전 이적 ( &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 이면 &lt;code&gt;pred(a, c)&lt;/code&gt; )이고 비반 성적 ( &lt;code&gt;pred(a, a)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; )입니다. 불평등의 삼분의 속성은 필요하지 않습니다 이러한 알고리즘 요소를 고려 와 &lt;code&gt;b&lt;/code&gt; 같음 (계산의 목적을) 경우 &lt;code&gt;pred&lt;/code&gt; 같은 등가 클래스 풋을, 즉 &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e60755fe688a68024196bc269a7db2354557a4c9" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algoritms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;pred&lt;/code&gt; 를 적절히 선택하여 임의의 극한값을 계산하는 데 사용될 수 있습니다 . 올바른 기능을 위해서는 &lt;code&gt;pred&lt;/code&gt; 는 엄격한 부분 순서, 즉 전 이적 ( &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 이면 &lt;code&gt;pred(a, c)&lt;/code&gt; ) 및 비 반사적 ( &lt;code&gt;pred(a, a)&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; ) 이어야 합니다. 불평등의 삼분 법적 특성은 필요하지 않다 : 만약이 &lt;code&gt;pred&lt;/code&gt; 가 그것들을 같은 동등성 클래스에 넣었 다면, 이 알고리즘들은 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 (계산의 목적으로) 동일하게 간주한다, 즉 &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4885c55c8f009fc55e3ded5c636baed4e8b1027a" translate="yes" xml:space="preserve">
          <source>These functions must be defined for any D program linked against this library.</source>
          <target state="translated">이 기능들은이 라이브러리에 링크 된 D 프로그램에 대해 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="863522dc2f55e2bd3557bec461908ee54bfe9148" translate="yes" xml:space="preserve">
          <source>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</source>
          <target state="translated">이 함수는 dynamic_cast를 대체합니다. 이전 버전의 gcc에서는 dynamic_cast가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f52bdfe03bd9c3b6aa669ea2216cab6aa5652c" translate="yes" xml:space="preserve">
          <source>These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to &lt;code&gt;(void*).sizeof&lt;/code&gt;, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used.</source>
          <target state="translated">이러한 기능은 가능한 경우 단일 작업으로로드 / 저장을 수행합니다. 일반적으로 이는 조작의 크기가 &lt;code&gt;(void*).sizeof&lt;/code&gt; 보다 작거나 같을 때 가능 하지만 일부 대상은 더 큰 조작을 지원할 수 있습니다. 로드 / 스토어를 단일 작업으로 수행 할 수없는 경우 여러 개의 작은 작업이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa2712a3447962365aa53a08ef19b228a050bafc" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to provide virtual function-based wrappers around input ranges with element type E. This is useful where a well-defined binary interface is required, such as when a DLL function or virtual function needs to accept a generic range as a parameter. Note that &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; and friends check for conformance to structural interfaces not for implementation of these &lt;code&gt;interface&lt;/code&gt; types.</source>
          <target state="translated">이 인터페이스는 요소 유형 E를 사용하여 입력 범위 주위에 가상 함수 기반 랩퍼를 제공하기위한 것입니다. 이는 DLL 함수 또는 가상 함수가 일반 범위를 매개 변수로 승인해야하는 경우와 같이 잘 정의 된 2 진 인터페이스가 필요한 경우에 유용합니다. . 참고 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; 과 친구가없는 이들의 구현을위한 구조 인터페이스에 적합성을 확인 &lt;code&gt;interface&lt;/code&gt; 유형.</target>
        </trans-unit>
        <trans-unit id="e7b0ea076cc1a10005c1bfd351e1967a3ff3876c" translate="yes" xml:space="preserve">
          <source>These interfaces are not capable of forwarding &lt;code&gt;ref&lt;/code&gt; access to elements.</source>
          <target state="translated">이러한 인터페이스는 요소에 대한 &lt;code&gt;ref&lt;/code&gt; 액세스를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8fa26313291d5018e0a3e59f0f8f336286abcb0a" translate="yes" xml:space="preserve">
          <source>These issues also apply to appending arrays with the ~= operator. Concatenation using the ~ operator is not affected since it always reallocates.</source>
          <target state="translated">이 문제는 ~ = 연산자로 배열을 추가 할 때도 적용됩니다. ~ 연산자를 사용한 연결은 항상 재 할당되므로 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ff0eb99086639c464f06ffda166431e591559b" translate="yes" xml:space="preserve">
          <source>These members are populated when one of the following functions are called successfully:</source>
          <target state="translated">이 멤버는 다음 함수 중 하나가 성공적으로 호출 될 때 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e69f6a6ea64238818e57857e50d3b4e6fac28582" translate="yes" xml:space="preserve">
          <source>These methods return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f2f532d1b48edcd9143f50919e4b67ad8068e5c5" translate="yes" xml:space="preserve">
          <source>These policies may be used alone, e.g. &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; defines a &lt;code&gt;uint&lt;/code&gt;-like type that reaches a stable NaN state for all erroneous operations. They may also be &quot;stacked&quot; on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include:</source>
          <target state="translated">이러한 정책은 단독으로 사용될 수 있습니다. 예를 들어 &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; 는 모든 잘못된 작업에 대해 안정적인 NaN 상태에 도달하는 &lt;code&gt;uint&lt;/code&gt; 와 유사한 유형을 정의 합니다. 또한 체크 된 적분이 실제 적분을 에뮬레이트하는 속성으로 인해 서로 &quot;스택&quot;될 수 있습니다. 이는 다른 확인 된 적분이 그 위에 구축 될 수 있음을 의미합니다. 관심있는 몇 가지 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7368ecff3f3d439be72be4fcfde0947c1e9f8e58" translate="yes" xml:space="preserve">
          <source>These prefix instructions do not appear in the same statement as the instructions they prefix; they appear in their own statement. For example:</source>
          <target state="translated">이 접두사 명령어는 접두사 명령어와 같은 명령문에 나타나지 않습니다. 그들은 자신의 진술에 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9636b646d702390220bc4fa38bc7bba209069d1d" translate="yes" xml:space="preserve">
          <source>These properties can be used to set and get this &lt;code&gt;Logger&lt;/code&gt;. Every modification to this &lt;code&gt;Logger&lt;/code&gt; will only be visible in the thread the modification has been done from.</source>
          <target state="translated">이러한 속성은이 &lt;code&gt;Logger&lt;/code&gt; 를 설정하고 가져 오는 데 사용할 수 있습니다 . 이 &lt;code&gt;Logger&lt;/code&gt; 대한 모든 수정 은 수정이 수행 된 스레드에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c185c1fb708b1056aa4da779b1949039005b7f" translate="yes" xml:space="preserve">
          <source>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated. A non-daemon thread will prevent a program from terminating as long as it has not terminated.</source>
          <target state="translated">이러한 특성은 작업자 스레드가 데몬 스레드인지 여부를 제어합니다. 데몬 스레드는 비 데몬 스레드가 모두 종료되면 자동으로 종료됩니다. 비 데몬 스레드는 프로그램이 종료되지 않는 한 프로그램이 종료되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="15376758dabe755dcb87d082399d9c18e9269e9e" translate="yes" xml:space="preserve">
          <source>These properties get and set the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by &lt;code&gt;taskPool&lt;/code&gt;. The default value is &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Calling the setter after the first call to &lt;code&gt;taskPool&lt;/code&gt; does not changes number of worker threads in the instance returned by &lt;code&gt;taskPool&lt;/code&gt;.</source>
          <target state="translated">이러한 속성은 &lt;code&gt;taskPool&lt;/code&gt; 에서 반환 한 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스 의 작업자 스레드 수를 가져오고 설정합니다 . 기본값은 &lt;code&gt;totalCPUs&lt;/code&gt; 에 대한 첫 번째 호출 후 1. 세터를 호출 - &lt;code&gt;taskPool&lt;/code&gt; 에 의해 반환되는 인스턴스에서 작업자 스레드의 수를 변경하지 않습니다 &lt;code&gt;taskPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="980ecd42d3382da4165c5745d3e514950a686c39" translate="yes" xml:space="preserve">
          <source>These pseudo ops are for inserting raw data directly into the code. &lt;code&gt;db&lt;/code&gt; is for bytes, &lt;code&gt;ds&lt;/code&gt; is for 16 bit words, &lt;code&gt;di&lt;/code&gt; is for 32 bit words, &lt;code&gt;dl&lt;/code&gt; is for 64 bit words, &lt;code&gt;df&lt;/code&gt; is for 32 bit floats, &lt;code&gt;dd&lt;/code&gt; is for 64 bit doubles, and &lt;code&gt;de&lt;/code&gt; is for 80 bit extended reals. Each can have multiple operands. If an operand is a string literal, it is as if there were</source>
          <target state="translated">이 의사 연산은 원시 데이터를 코드에 직접 삽입하기위한 것입니다. &lt;code&gt;db&lt;/code&gt; 는 바이트, &lt;code&gt;ds&lt;/code&gt; 는 16 비트 워드, &lt;code&gt;di&lt;/code&gt; 는 32 비트 워드, &lt;code&gt;dl&lt;/code&gt; 은 64 비트 워드, &lt;code&gt;df&lt;/code&gt; 는 32 비트 플로트, &lt;code&gt;dd&lt;/code&gt; 는 64 비트 더블, &lt;code&gt;de&lt;/code&gt; 는 80 비트 확장 실수입니다. 각각은 여러 피연산자를 가질 수 있습니다. 피연산자가 문자열 리터럴 인 경우 피연산자가있는 것처럼</target>
        </trans-unit>
        <trans-unit id="dc738e7762e036039780916cbdd5404d3269d8a0" translate="yes" xml:space="preserve">
          <source>These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions.</source>
          <target state="translated">이러한 재정렬 보증은 이러한 기능을 통해 수행되는 다른 작업과 관련하여 만 이루어집니다. 컴파일러는 이러한 기능을 통해 수행되는로드 / 스토어와 관련하여 정기적 인로드 / 스토어를 자유롭게 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c337390b522d2f745f8ff19e4af335466b8d80" translate="yes" xml:space="preserve">
          <source>These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.</source>
          <target state="translated">이러한 규칙은 D 소스 코드를 구문 분석 또는 의미 분석과 독립적으로 토큰화할 수 있도록하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="0c76e41e867d53b374fa782852a104df9aca82b4" translate="yes" xml:space="preserve">
          <source>These tokens are replaced with other tokens according to the following table:</source>
          <target state="translated">이 토큰은 다음 표에 따라 다른 토큰으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bdde0a231ee1346d31198eca44ed30c45d180a" translate="yes" xml:space="preserve">
          <source>These two functions are publicly imported by &lt;a href=&quot;std_string&quot;&gt;&lt;code&gt;std.string&lt;/code&gt;&lt;/a&gt; to be easily available.</source>
          <target state="translated">이 두 함수는 &lt;a href=&quot;std_string&quot;&gt; &lt;code&gt;std.string&lt;/code&gt; &lt;/a&gt; 에서 공개적으로 가져와 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d116b35a1d1eb38f8d6deaebff517f7281edce29" translate="yes" xml:space="preserve">
          <source>These two methods set and get the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 두 메소드 는 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 설정하고 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c31bee48bf9882a765ab31f12d60d8852693f17b" translate="yes" xml:space="preserve">
          <source>These two were added to Bionic in Lollipop.</source>
          <target state="translated">이 두 가지를 Lollipop의 Bionic에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="51b1a7127ec2cda2b11c1f4d950a66756e0a424a" translate="yes" xml:space="preserve">
          <source>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer.</source>
          <target state="translated">이러한 유형과 연산은 컴파일러가 대상으로하는 아키텍처에 대해 정의 된 것입니다. 특정 CPU 제품군이 벡터 유형을 다양하게 지원하는 경우 추가 런타임 검사가 필요할 수 있습니다. 컴파일러는 런타임 검사를 수행하지 않습니다. 그것들은 프로그래머가해야합니다.</target>
        </trans-unit>
        <trans-unit id="23aa9ed08051d1b26b975da56b7c482018edf989" translate="yes" xml:space="preserve">
          <source>These use the &lt;code&gt;zd&lt;/code&gt; and &lt;code&gt;dt&lt;/code&gt; format specifiers respectively:</source>
          <target state="translated">이들은 각각 &lt;code&gt;zd&lt;/code&gt; 및 &lt;code&gt;dt&lt;/code&gt; 형식 지정자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6f060e83954cb7bb657a24fc206a36f49a7d93ba" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjuction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="translated">이 가변 함수에는 &lt;code&gt;_argptr&lt;/code&gt; 이라는 특수 로컬 변수가 선언되어 있는데 ,이 변수는 첫 번째 가변 인수에 대한 &lt;code&gt;core.vararg&lt;/code&gt; 참조입니다. 인수에 액세스하려면 &lt;code&gt;va_arg&lt;/code&gt; 와 함께 &lt;code&gt;_argptr&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8252040edcfa70507497891f3e37c3388deec3b" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjunction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="translated">이러한 가변 함수에는 첫 번째 가변 인수에 대한 &lt;code&gt;core.vararg&lt;/code&gt; 참조 인 &lt;code&gt;_argptr&lt;/code&gt; 이라는 특수 지역 변수가 선언되어 있습니다 . 인수에 액세스하려면 &lt;code&gt;_argptr&lt;/code&gt; 을 &lt;code&gt;va_arg&lt;/code&gt; 와 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="234027e68858253217a4940ca8276de49e1921e6" translate="yes" xml:space="preserve">
          <source>They cannot be accessed directly, but can be when converted to an array type:</source>
          <target state="translated">직접 액세스 할 수 없지만 배열 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221e10b06207df21853c30ac081dc011d76ee4a6" translate="yes" xml:space="preserve">
          <source>Things that are reliable and can be done:</source>
          <target state="translated">신뢰할 수 있고 수행 할 수있는 것들 :</target>
        </trans-unit>
        <trans-unit id="3c0e4517dcdbca852a34fee2578fdfec0c6193f9" translate="yes" xml:space="preserve">
          <source>This 6-digit (24 bits) hexadecimal number does not show pre-release number, and it is always a greater number in a more recent release. It makes comparisons with greater than and less than work.</source>
          <target state="translated">이 6 자리 (24 비트) 16 진수는 시험판 번호를 표시하지 않으며 최신 릴리스에서는 항상 더 큰 숫자입니다. 작업보다 크거나 작게 비교합니다.</target>
        </trans-unit>
        <trans-unit id="229cd848f340b1059ab841306649066eb2235f02" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt;&lt;code&gt;NSLog&lt;/code&gt;&lt;/a&gt; function prints a message to the System Log facility, i.e. to stderr and Console.</source>
          <target state="translated">이 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt; &lt;code&gt;NSLog&lt;/code&gt; &lt;/a&gt; 기능은 시스템 로그 기능, 즉 stderr 및 Console에 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d3784623518bf5135672133e5b2128ce4da1e03a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; implementation writes log messages to the associated file. The name of the file has to be passed on construction time. If the file is already present new log messages will be append at its end.</source>
          <target state="translated">이 &lt;code&gt;Logger&lt;/code&gt; 구현은 로그 메시지를 관련 파일에 씁니다. 파일 이름은 생성 시간에 전달되어야합니다. 파일이 이미 있으면 새 로그 메시지가 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="713e6c7267281da115b32a479fb632b10a4676bf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</source>
          <target state="translated">이 &lt;code&gt;Logger&lt;/code&gt; 는 독립형 로그 기능에 의해 호출됩니다. 이를 통해 스레드 로컬 경로 재 지정을 작성하고 독립형 로그 기능을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1905487aa2f3222c1f92ca85d42ee6ef82cec0b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;delegate&lt;/code&gt; is called in case a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; gets logged.</source>
          <target state="translated">이 &lt;code&gt;delegate&lt;/code&gt; 는 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 이 있는 로그 메시지 가 기록 되는 경우에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="742a25561151a973ba133d1f0c2d43dea4909a81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 파일 이름을 비교하고 대소 문자를 구분하는지 여부를 결정하는 함수에 대한 템플릿 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6a1b7ec8e15b4671a0723320a6b157081a9b40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used to select the primitives of the range to handle by the &lt;a href=&quot;#handle&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; range wrapper. The values of the &lt;code&gt;enum&lt;/code&gt; can be &lt;code&gt;OR&lt;/code&gt;'d to select multiple primitives to be handled.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;#handle&quot;&gt; &lt;code&gt;handle&lt;/code&gt; &lt;/a&gt; 범위 랩퍼 가 처리 할 범위의 기본 요소를 선택하는 데 사용됩니다 . 처리 할 여러 프리미티브를 선택하기 위해 &lt;code&gt;enum&lt;/code&gt; 의 값을 &lt;code&gt;OR&lt;/code&gt; 'd로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60302f8f7437eabfe1118a9f0d4373fe741b982e" translate="yes" xml:space="preserve">
          <source>This &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, U)(U rhs)</source>
          <target state="translated">이 &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (스트링 op, U) (U rhs)</target>
        </trans-unit>
        <trans-unit id="0844f4e216523548601b41cd5d7151c085ad2d4f" translate="yes" xml:space="preserve">
          <source>This Element is stored inside the &lt;code&gt;MultiLogger&lt;/code&gt; and associates a &lt;code&gt;Logger&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">이 요소는 &lt;code&gt;MultiLogger&lt;/code&gt; 내부에 저장되며 &lt;code&gt;Logger&lt;/code&gt; 를 &lt;code&gt;string&lt;/code&gt; 연결 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f3ba7f1176ff2dafbb0e0f64e80accd29320699" translate="yes" xml:space="preserve">
          <source>This Exception is thrown if something goes wrong when encoding or decoding a URI.</source>
          <target state="translated">URI를 인코딩하거나 디코딩 할 때 문제가 발생하면이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="808758fad2f8e432c6429e19e97ca8ce38bd7755" translate="yes" xml:space="preserve">
          <source>This UDA is not transitive, and inner scope do not inherit outer scopes' ABI tag. See examples below for how to translate a C++ declaration to D. Also note that entries in this UDA will be automatically sorted alphabetically, hence &lt;code&gt;gnuAbiTag(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)&lt;/code&gt; will appear as &lt;code&gt;@gnuAbiTag(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 UDA는 전 이적이지 않으며 내부 범위는 외부 범위의 ABI 태그를 상속하지 않습니다. C ++ 선언을 D로 변환하는 방법은 아래 예제를 참조하십시오. 또한이 UDA의 항목은 자동으로 알파벳순으로 정렬되므로 &lt;code&gt;gnuAbiTag(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)&lt;/code&gt; 는 &lt;code&gt;@gnuAbiTag(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)&lt;/code&gt; 로 나타납니다. &quot;B&quot;, &quot;C&quot;) .</target>
        </trans-unit>
        <trans-unit id="7f52bee84df158d351adbe607d7ed92c29a830ca" translate="yes" xml:space="preserve">
          <source>This access can span multiple nesting levels:</source>
          <target state="translated">이 액세스는 여러 중첩 수준에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b73948545ca0a17466100c56872304c05fd8262" translate="yes" xml:space="preserve">
          <source>This advice applies only to static references or references embedded inside other objects. There is not much point for such stored on the stack to be nulled because new stack frames are initialized anyway.</source>
          <target state="translated">이 조언은 정적 참조 또는 다른 객체에 포함 된 참조에만 적용됩니다. 어쨌든 새로운 스택 프레임이 초기화되기 때문에 스택에 저장된 그러한 것들이 널이 될 지점은별로 없습니다.</target>
        </trans-unit>
        <trans-unit id="b180cae02977110add927a1c4e0c64f40292d64f" translate="yes" xml:space="preserve">
          <source>This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by &lt;code&gt;ref&lt;/code&gt;, output becomes a range with mutable &lt;code&gt;front&lt;/code&gt; (and &lt;code&gt;back&lt;/code&gt; where appropriate) that reflects in the original inputs.  If any of the inputs &lt;code&gt;rs&lt;/code&gt; is infinite so is the result (&lt;code&gt;empty&lt;/code&gt; being always &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">이 알고리즘은 게으 르며 요소가 결과에서 벗어나면서 점진적으로 작업을 수행합니다. 시간 복잡도는 모든 입력에 대한 요소 수의 합에 비례합니다. 모든 입력이 동일한 요소 유형을 갖고 &lt;code&gt;ref&lt;/code&gt; 로 제공하는 경우 출력은 원래 입력에 반영되는 가변 &lt;code&gt;front&lt;/code&gt; (및 적절한 경우 &lt;code&gt;back&lt;/code&gt; ) 이있는 범위가됩니다 . 입력 &lt;code&gt;rs&lt;/code&gt; 중 하나라도 무한하면 결과도 마찬가지입니다 ( &lt;code&gt;empty&lt;/code&gt; 은 항상 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="17ac7dad87e44aee326cfad5b437dc8fb209353e" translate="yes" xml:space="preserve">
          <source>This allocator sits on top of &lt;code&gt;ParentAllocator&lt;/code&gt; and quantizes allocation sizes, usually from arbitrary positive numbers to a small set of round numbers (e.g. powers of two, page sizes etc). This technique is commonly used to:</source>
          <target state="translated">이 할당자는 &lt;code&gt;ParentAllocator&lt;/code&gt; 위에 위치 하며 일반적으로 임의의 양수부터 소수의 소수 (예 : 2의 거듭 제곱, 페이지 크기 등)까지 할당 크기를 양자화합니다. 이 기술은 일반적으로 다음과 같은 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c92308ef13d80d3dc1f8f963c2ddd3981e8c6bde" translate="yes" xml:space="preserve">
          <source>This allows you to construct a &lt;code&gt;TickDuration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">이를 통해 주어진 시간 단위로 주어진 시간 단위에서 &lt;code&gt;TickDuration&lt;/code&gt; 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75add17a5265c1c86eea3c10773eb85a2a082611" translate="yes" xml:space="preserve">
          <source>This also checks if T passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">또한 T가 &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; 를&lt;/a&gt; 통과 하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="21d1b39871e7f1893df45ac1736d0defe8bdb68b" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="translated">이러한 정렬 방법 은 Python과 Lisp의 데코레이션-정렬-비 장식 패턴이라고도 하는 &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian 변환&lt;/a&gt; 과 유사합니다 . 복잡성은 해당 &lt;code&gt;sort&lt;/code&gt; 의 복잡도와 동일 하지만 &lt;code&gt;schwartzSort&lt;/code&gt; 는 &lt;code&gt;r.length&lt;/code&gt; 시간 만 &lt;code&gt;transform&lt;/code&gt; 평가 합니다 (정기 정렬과 비교할 때 절반 미만). 사용법은 예제를 통해 가장 잘 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f8486469f092657a95697764606a80ec125f33a" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;https://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d88f963aa92f920cdc8aeb7a00bc154db20bbb5" translate="yes" xml:space="preserve">
          <source>This array can be used by a precise GC to avoid false pointers.</source>
          <target state="translated">이 배열은 정확한 GC에서 잘못된 포인터를 피하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35154b2193fa21859ceac41f1d4b9a67330be66" translate="yes" xml:space="preserve">
          <source>This attack can also be mitigated via rate limiting and banning IPs which have too many rejected requests. However, this does not completely solve the problem, as the attacker could be in control of a bot net. To fully defend against the timing attack, rate limiting, banning IPs, and using this function should be used together.</source>
          <target state="translated">거부 된 요청이 너무 많은 속도 제한 및 금지 IP를 통해이 공격을 완화 할 수도 있습니다. 그러나 공격자가 봇넷을 제어 할 수 있기 때문에 문제가 완전히 해결되지는 않습니다. 타이밍 공격을 완전히 방어하려면 속도 제한, IP 금지 및이 기능을 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a9127e0dd3d0b5214532b99c1123e71d947a773" translate="yes" xml:space="preserve">
          <source>This binary operator returns a narrower, built-in integer type where applicable, according to the following table.</source>
          <target state="translated">이 이항 연산자는 다음 표에 따라 해당되는 경우 더 좁은 내장 정수 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37d90ec49bcad1514fffff07ef5725f0a4ce3b52" translate="yes" xml:space="preserve">
          <source>This block contains the info to allow appending.</source>
          <target state="translated">이 블록에는 추가 할 수있는 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bf616d2c8bb18a1f79e9b94bb01fac01a9f85e97" translate="yes" xml:space="preserve">
          <source>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</source>
          <target state="translated">이 블록은 살아있는 동안베이스에 대한 포인터를 보장합니다. 내부 포인터는 무시해도됩니다. 이 속성은 매우 큰 데이터 구조에서 잘못된 포인터를 제거하는 데 유용하며 최소한 한 페이지 크기의 데이터 구조에만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="bf3bcec7830ceded3b9368b09e74254cb38823f2" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. It's highly platform dependent.</source>
          <target state="translated">이것은 타입을 레지스터의 함수로 전달되고 레지스터로 리턴 될 수있는 '더 단순한'타입으로 나눕니다. 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c8f37b58b4d0486e147bae447382fe4c40e89ace" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. This is the implementation for the x86_64 System V ABI (not used for Win64), based on &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</source>
          <target state="translated">이것은 타입을 레지스터의 함수로 전달되고 레지스터로 리턴 될 수있는 '더 단순한'타입으로 나눕니다. 이것은 &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf를&lt;/a&gt; 기반으로하는 x86_64 System V ABI (Win64에 사용되지 않음)에 대한 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="0bd70fd848ca13dea85fa0c9ed45a1bd7458ccab" translate="yes" xml:space="preserve">
          <source>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt;. In particular, it can be placed after a call to &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or before a call &lt;a href=&quot;std_range#filter&quot;&gt;&lt;code&gt;std.range.filter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range#tee&quot;&gt;&lt;code&gt;std.range.tee&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; 에&lt;/a&gt; 대한 게으른 대안으로 값 비싼 평가를 거친 함수 후에 체인에 배치하는 유용한 함수일 수 있습니다 . 특히 &lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 호출 &lt;a href=&quot;std_range#filter&quot;&gt; &lt;code&gt;std.range.filter&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_range#tee&quot;&gt; &lt;code&gt;std.range.tee&lt;/code&gt; &lt;/a&gt; 또는 std.range.tee 호출 전에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b2e989aa67544fd1198815cd532b63a0f766b8f" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = File.readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">각 호출에 대해 버퍼를 재사용 할 수 있기 때문에 &lt;code&gt;line = File.readln()&lt;/code&gt; 보다 빠를 수 있습니다 . 버퍼를 다시 사용한다는 것은 이전 내용을 유지하려면 복사해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9135461de3ded4b1c69a8c8663d6dc1b7b1298f3" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">각 호출에 대해 버퍼를 재사용 할 수 있기 때문에 &lt;code&gt;line = readln()&lt;/code&gt; 보다 빠를 수 있습니다 . 버퍼를 다시 사용한다는 것은 이전 내용을 유지하려면 복사해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0948e8d31ea2c28fe26752cedea06ec0ba1ce2b0" translate="yes" xml:space="preserve">
          <source>This can be generalized to a graph of memory objects interconnected by pointers, where only a single pointer connects to that graph from elsewhere. That single pointer becomes the</source>
          <target state="translated">이것은 포인터로 상호 연결된 메모리 개체의 그래프로 일반화 할 수 있으며, 여기서 단일 포인터 만 다른 곳에서 해당 그래프에 연결됩니다. 그 단일 포인터는</target>
        </trans-unit>
        <trans-unit id="cffa42c18f8e5280df0dc347c1adc3088bd2e98b" translate="yes" xml:space="preserve">
          <source>This can be mitigated by using type-specific pools:</source>
          <target state="translated">이는 유형별 풀을 사용하여 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a112b2327f090d0fc1bf3af12645c6807ea32f38" translate="yes" xml:space="preserve">
          <source>This can be used to manually allocate arrays. Initial slice size is 0.</source>
          <target state="translated">배열을 수동으로 할당하는 데 사용할 수 있습니다. 초기 슬라이스 크기는 0입니다.</target>
        </trans-unit>
        <trans-unit id="77b164cf465602d02b3ffc40b53faf3928b97c45" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;_init&lt;/code&gt; to its original state.</source>
          <target state="translated">&lt;code&gt;_init&lt;/code&gt; 로 설정된 상태를 원래 상태 로 복원하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd9b6c28efb844ef78e5e1874ec7103f9aedb900" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;builtin_init&lt;/code&gt; to its original state.</source>
          <target state="translated">이것은 &lt;code&gt;builtin_init&lt;/code&gt; 에 의해 설정된 상태를 원래 상태 로 복원하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf855a97cfb23a3029962fde96c07063d751f784" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initDMD&lt;/code&gt; to its original state. Useful if there's a need for multiple sessions of the DMD compiler in the same application.</source>
          <target state="translated">이것은 &lt;code&gt;initDMD&lt;/code&gt; 에 의해 설정된 상태를 원래 상태 로 복원하는 데 사용될 수 있습니다 . 동일한 애플리케이션에서 여러 세션의 DMD 컴파일러가 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8b9d5f27029fa9824ee5b1d78b90c2ec7ef5fd1e" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initialize&lt;/code&gt; to its original state.</source>
          <target state="translated">원래 상태 로 &lt;code&gt;initialize&lt;/code&gt; 하여 설정된 상태를 복원하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab6e2c03932762345b65936a6392947f9f7fc40e" translate="yes" xml:space="preserve">
          <source>This causes the array to be reallocated in place, and the existing contents copied over to the new array. If the new array length is shorter, the array is not reallocated, and no data is copied. It is equivalent to slicing the array:</source>
          <target state="translated">이로 인해 어레이가 재 할당되고 기존 내용이 새 어레이로 복사됩니다. 새 배열 길이가 더 짧으면 배열이 재 할당되지 않고 데이터가 복사되지 않습니다. 배열을 슬라이스하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2dc8c51a26f6ef694173726a55aa90d7d6530cc8" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a read lock for the enclosing mutex.</source>
          <target state="translated">이 클래스는 그 자체로 뮤텍스로 간주 될 수 있으며 둘러싸는 뮤텍스에 대한 읽기 잠금을 협상하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c087ce5411ffc17188818ec319892aeaf2de87df" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a write lock for the enclosing mutex.</source>
          <target state="translated">이 클래스는 그 자체로 뮤텍스로 간주 될 수 있으며 둘러싸는 뮤텍스에 대한 쓰기 잠금을 협상하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6fa3f3a70f061e4c741e7043e9f128e38434b5c" translate="yes" xml:space="preserve">
          <source>This class contains only static methods, and cannot be instantiated. See below for examples of use.</source>
          <target state="translated">이 클래스에는 정적 메서드 만 포함되어 있으며 인스턴스화 할 수 없습니다. 사용 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e74dd67572321fcf836dd082da1156043102db48" translate="yes" xml:space="preserve">
          <source>This class encapsulates a task queue and a set of worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that executes the &lt;code&gt;Task&lt;/code&gt; at the front of the queue when one is available and sleeps when the queue is empty.</source>
          <target state="translated">이 클래스는 작업 대기열과 일련의 작업자 스레드를 캡슐화합니다. 그 목적은 많은 수의 &lt;code&gt;Task&lt;/code&gt; 를 더 적은 수의 스레드 에 효율적으로 매핑하는 것 입니다. 작업 대기열은 &lt;code&gt;TaskPool&lt;/code&gt; 에 제출되어 실행을 기다리는 &lt;code&gt;Task&lt;/code&gt; 객체 의 FIFO 대기열입니다 . 작업자 스레드는 사용 가능한 경우 &lt;code&gt;Task&lt;/code&gt; 을 대기열 앞쪽에서 실행 하고 대기열이 비어있는 경우 휴면 상태 인 스레드입니다 .</target>
        </trans-unit>
        <trans-unit id="cb7ed7def5fa337d461b92cc10d68f83905440de" translate="yes" xml:space="preserve">
          <source>This class encapsulates all threading functionality for the D programming language. As thread manipulation is a required facility for garbage collection, all user threads should derive from this class, and instances of this class should never be explicitly deleted. A new thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">이 클래스는 D 프로그래밍 언어에 대한 모든 스레딩 기능을 캡슐화합니다. 스레드 조작은 가비지 수집에 필요한 기능이므로 모든 사용자 스레드는이 클래스에서 파생되어야하며이 클래스의 인스턴스는 명시 적으로 삭제해서는 안됩니다. 다음 예제와 같이 파생 또는 구성을 사용하여 새 스레드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060824159317cc2ae0b94150653daf83c3c520fb" translate="yes" xml:space="preserve">
          <source>This class is Windows-Only.</source>
          <target state="translated">이 클래스는 Windows 전용입니다.</target>
        </trans-unit>
        <trans-unit id="74950bb501f7c21fc01a4eeb41b151e182fd4b25" translate="yes" xml:space="preserve">
          <source>This class is intended to simplify certain common programming techniques.</source>
          <target state="translated">이 클래스는 일반적인 프로그래밍 기술을 단순화하기 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="23197b76b4ee940fb447d39ecd365edbbb4617e7" translate="yes" xml:space="preserve">
          <source>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the &lt;code&gt;writeLogMsg&lt;/code&gt; method. By default this is not thread-safe.</source>
          <target state="translated">이 클래스는 모든 로거의 기본입니다. 새로운 종류의 로거를 만들려면 파생 클래스가 &lt;code&gt;writeLogMsg&lt;/code&gt; 메서드 를 구현해야합니다 . 기본적으로 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5087e482a877ae3c12085be27794a8883c7a901f" translate="yes" xml:space="preserve">
          <source>This class provides a cooperative concurrency mechanism integrated with the threading and garbage collection functionality. Calling a fiber may be considered a blocking operation that returns when the fiber yields (via Fiber.yield()). Execution occurs within the context of the calling thread so synchronization is not necessary to guarantee memory visibility so long as the same thread calls the fiber each time. Please note that there is no requirement that a fiber be bound to one specific thread. Rather, fibers may be freely passed between threads so long as they are not currently executing. Like threads, a new fiber thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">이 클래스는 스레딩 및 가비지 콜렉션 기능과 통합 된 협업 동시성 메커니즘을 제공합니다. 파이버를 호출하는 것은 파이버 수율 (Fibre.yield ()를 통해)을 반환하는 차단 작업으로 간주 될 수 있습니다. 실행은 호출 스레드 컨텍스트 내에서 발생하므로 동일한 스레드가 매번 파이버를 호출하는 한 메모리 가시성을 보장하기 위해 동기화가 필요하지 않습니다. 광섬유를 하나의 특정 스레드에 바인딩 할 필요는 없습니다. 오히려, 파이버는 현재 실행되고 있지 않는 한 스레드간에 자유롭게 전달 될 수 있습니다. 스레드와 마찬가지로 다음 예와 같이 파생 또는 구성을 사용하여 새 파이버 스레드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a75ec7718c8b6f47e4366c93dbe98cf77e29de" translate="yes" xml:space="preserve">
          <source>This class represents a barrier across which threads may only travel in groups of a specific size.</source>
          <target state="translated">이 클래스는 스레드가 특정 크기의 그룹으로 만 이동할 수있는 장벽을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="766ad20f64361ee3b240dfaf608ee851aeb433ae" translate="yes" xml:space="preserve">
          <source>This class represents a condition variable as conceived by C.A.R. Hoare. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">이 클래스는 CAR Hoare가 생각한 조건 변수를 나타냅니다. 그러나 Mesa 유형 모니터에 따라 &quot;신호&quot;는 &quot;알림&quot;으로 바뀌어 알림이 전송 될 때 제어가 웨이터에게 전송되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ebd970226df03dbe75e13571a9e96c6ff81d3f8" translate="yes" xml:space="preserve">
          <source>This class represents a general counting semaphore as concieved by Edsger Dijkstra. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">이 클래스는 Edsger Dijkstra가 인정한 일반적인 세마포어를 나타냅니다. 그러나 Mesa 유형 모니터에 따라 &quot;신호&quot;는 &quot;알림&quot;으로 바뀌어 알림이 전송 될 때 제어가 웨이터에게 전송되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c8cd845734952865e5a8f06563815740028af34a" translate="yes" xml:space="preserve">
          <source>This class represents a general purpose, recursive mutex.</source>
          <target state="translated">이 클래스는 범용 재귀 뮤텍스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="59a28f2816234c02947ecfa7c34d28fcd7aff787" translate="yes" xml:space="preserve">
          <source>This class represents a mutex that allows any number of readers to enter, but when a writer enters, all other readers and writers are blocked.</source>
          <target state="translated">이 클래스는 다수의 독자가 입장 할 수있는 뮤텍스를 나타내지 만, 작가가 입장하면 다른 모든 독자와 작가가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="869079d3acf8bad41ab545f5cd5b6ff38c3d966c" translate="yes" xml:space="preserve">
          <source>This class should usually be used via the global instantiation available via the &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt; property. Occasionally it is useful to explicitly instantiate a &lt;code&gt;TaskPool&lt;/code&gt;:</source>
          <target state="translated">이 클래스는 일반적으로 &lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt; 속성을 통해 사용 가능한 전역 인스턴스화를 통해 사용해야 합니다. 때때로 &lt;code&gt;TaskPool&lt;/code&gt; 을 명시 적으로 인스턴스화하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="67a778401b8293f4ab050d1d10ec2027dc2c3143" translate="yes" xml:space="preserve">
          <source>This class uses a high-performance counter. On Windows systems, it uses &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;, and on Posix systems, it uses &lt;code&gt;clock_gettime&lt;/code&gt; if available, and &lt;code&gt;gettimeofday&lt;/code&gt; otherwise.</source>
          <target state="translated">이 클래스는 고성능 카운터를 사용합니다. Windows 시스템에서는 &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; 를 사용 하고 Posix 시스템에서는 사용 가능한 경우 &lt;code&gt;clock_gettime&lt;/code&gt; 을 사용 하고 그렇지 않으면 &lt;code&gt;gettimeofday&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="aaa98a68eef2ad7cd1dc56f0e12cad2e4ff0ed1d" translate="yes" xml:space="preserve">
          <source>This code handles backtrace generation using DWARF debug_line section in ELF and Mach-O files for Posix.</source>
          <target state="translated">이 코드는 Posix 용 ELF 및 Mach-O 파일에서 DWARF debug_line 섹션을 사용하여 역 추적 생성을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6140309682aaa69b6ff498f8a25796d0edfd215e" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">이 코드는 foreach 루프에 대한 UTF 문자열 디코딩을 처리합니다. char, wchar 및 dchar간에 6 가지 변환 조합이 있으며 각각 2 개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="982470496432064145436b3b7c81c481f591fd15" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach_reverse loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">이 코드는 foreach_reverse 루프에 대한 UTF 문자열 디코딩을 처리합니다. char, wchar 및 dchar간에 6 가지 변환 조합이 있으며 각각 2 개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76eacdedc4fa73ee336ac22c18ef834f35805af" translate="yes" xml:space="preserve">
          <source>This code reads ELF files and sections using memory mapped IO.</source>
          <target state="translated">이 코드는 메모리 매핑 IO를 사용하여 ELF 파일과 섹션을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="db89b4b4bb5b2f93ea6d6ff02b4131b5059932ab" translate="yes" xml:space="preserve">
          <source>This combining of the environment and the function is called a</source>
          <target state="translated">이러한 환경과 기능의 결합을</target>
        </trans-unit>
        <trans-unit id="f04a03c616b5e70e398965fd9e6bb2d3b0919b13" translate="yes" xml:space="preserve">
          <source>This command-line parameter does not affect custom unit test handlers.</source>
          <target state="translated">이 명령 행 매개 변수는 사용자 정의 단위 테스트 핸들러에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="230aa360bfc55c5cf21e968f489f8b1241790aa2" translate="yes" xml:space="preserve">
          <source>This compile-time flag is &lt;code&gt;true&lt;/code&gt; if logging is not statically disabled.</source>
          <target state="translated">이 컴파일 타임 플래그는 로깅이 정적으로 비활성화되지 않은 경우 에 &lt;code&gt;true&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d82eb07cfddf77181a4fa8aca621ce6591fd7ca9" translate="yes" xml:space="preserve">
          <source>This constructor is only called when we figured out which function template to instantiate.</source>
          <target state="translated">이 생성자는 인스턴스화 할 함수 템플릿을 알아 낸 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aa95214feed626f5e6eebb5c6959ff1d8bcafc67" translate="yes" xml:space="preserve">
          <source>This constructor is the inverse of &lt;a href=&quot;#opCast&quot;&gt;&lt;code&gt;opCast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 생성자는 &lt;a href=&quot;#opCast&quot;&gt; &lt;code&gt;opCast&lt;/code&gt; &lt;/a&gt; 와 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="a8fcfb06ab6c25d2bbe46e5cfe782e5b576ac2d4" translate="yes" xml:space="preserve">
          <source>This contains the copyright notice. The macro COPYRIGHT is set to the contents of the section when it documents the module declaration. The copyright section only gets this special treatment when it is for the module declaration.</source>
          <target state="translated">여기에는 저작권 고지가 포함됩니다. 매크로 COPYRIGHT는 모듈 선언을 문서화 할 때 섹션의 내용으로 설정됩니다. 저작권 섹션은 모듈 선언과 관련해서 만이 특별한 대우를받습니다.</target>
        </trans-unit>
        <trans-unit id="822ca8d08b221bc29495c95da9984e8cee76c282" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage decoding buffers.</source>
          <target state="translated">이 편리한 방법은 디코딩 버퍼를 수동으로 관리 할 필요성을 줄여줍니다.</target>
        </trans-unit>
        <trans-unit id="cf045283f89baa3e44e42e507f01aa06b96bde31" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage output buffers.</source>
          <target state="translated">이 편리한 방법으로 출력 버퍼를 수동으로 관리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="16b88e43157a2f6f2c5142b90b7d5fe45695bbef" translate="yes" xml:space="preserve">
          <source>This created a new Fiber for the supplied op and adds it to the dispatch list.</source>
          <target state="translated">제공된 op에 대한 새 파이버를 작성하여 디스패치 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdc94e4392e59112302f3c3212c7174cb2489e38" translate="yes" xml:space="preserve">
          <source>This creates a new Fiber for the supplied op and then starts the dispatcher.</source>
          <target state="translated">제공된 op에 대한 새 파이버를 작성한 다음 디스패처를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="af45f3f128eb584feb53ad796c2bd75a57d5180c" translate="yes" xml:space="preserve">
          <source>This defines a new type &lt;code&gt;X&lt;/code&gt; which has values &lt;code&gt;X.A=0&lt;/code&gt;, &lt;code&gt;X.B=1&lt;/code&gt;, &lt;code&gt;X.C=2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X.A=0&lt;/code&gt; , &lt;code&gt;X.B=1&lt;/code&gt; , &lt;code&gt;X.C=2&lt;/code&gt; 값을 갖는 새로운 유형 &lt;code&gt;X&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0d27799b2bf9fed9292a027676e909387c978ddb" translate="yes" xml:space="preserve">
          <source>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</source>
          <target state="translated">가변 함수의 이러한 정의는 모든 상태가 내부적으로 생성되거나 인수를 통해 도달 할 수있는 한 D 순수 함수가 상태 돌연변이를 사용할 수 있기 때문에 순수 기능 언어에서 전통적으로 사용되는 것보다 더 일반적입니다. 특히, 순수한 함수는 특별한 경우가 아니라 &lt;code&gt;new&lt;/code&gt; 또는 &lt;code&gt;malloc&lt;/code&gt; 을 통해 메모리를 할당 할 수 있습니다 . 순수한 함수는 무한정 반복하거나 프로그램을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="524100fdceb69609090212fc4caf6a68ca169c00" translate="yes" xml:space="preserve">
          <source>This deletes the key e1 from the associative array e2</source>
          <target state="translated">연관 배열 e2에서 키 e1을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e594f9c668086e01075383fb67708b16f0e2344d" translate="yes" xml:space="preserve">
          <source>This describes the OOP API. To understand when to use the template API and when to use the OOP API, see the module documentation at the top of this page.</source>
          <target state="translated">OOP API에 대해 설명합니다. 템플릿 API 사용시기 및 OOP API 사용시기를 이해하려면이 페이지 상단의 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3007dc64e992f88997b93bf75939ee91b3bf45cf" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; implementations of the inline assembler. The inline assembler platform support that a compiler provides is indicated by the &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; and &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; version identifiers, respectively.</source>
          <target state="translated">이 문서 는 인라인 어셈블러 의 &lt;code&gt;x86&lt;/code&gt; 및 &lt;code&gt;x86_64&lt;/code&gt; 구현에 대해 설명합니다 . 컴파일러가 제공하는 인라인 어셈블러 플랫폼 지원은 각각 &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; 및 &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; 버전 식별자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="569cf1450215141639c3396e75fe3e0e30e8cd78" translate="yes" xml:space="preserve">
          <source>This document is the reference manual for the D Programming Language. For more information and other documents, see &lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;.</source>
          <target state="translated">이 문서는 D 프로그래밍 언어에 대한 참조 매뉴얼입니다. 자세한 내용 및 기타 문서 &lt;a href=&quot;https://dlang.org/&quot;&gt;는 D 언어 웹 사이트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b76c1da48d91edda64500d21af760a6ce3c2286" translate="yes" xml:space="preserve">
          <source>This document specifies how to interface with C++ directly.</source>
          <target state="translated">이 문서는 C ++과 직접 인터페이스하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4eaa9b84c7822b2e3e77fa7e5df36263689f6cc9" translate="yes" xml:space="preserve">
          <source>This documents the general structure of a Digest in the template API. All digest implementations should implement the following members and therefore pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="translated">템플릿 API에서 다이제스트의 일반적인 구조를 설명합니다. 모든 다이제스트 구현은 다음 멤버를 구현해야하므로 &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; 테스트를 통과해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac0dd62d84db23b0de6fee189b1020c75493d355" translate="yes" xml:space="preserve">
          <source>This does not assign the pointer of &lt;code&gt;rhs&lt;/code&gt; to this &lt;code&gt;RefRange&lt;/code&gt;. Rather it assigns the range pointed to by &lt;code&gt;rhs&lt;/code&gt; to the range pointed to by this &lt;code&gt;RefRange&lt;/code&gt;. This is because</source>
          <target state="translated">이것에 의해 &lt;code&gt;rhs&lt;/code&gt; 의 포인터는 이 &lt;code&gt;RefRange&lt;/code&gt; 에 할당되지 않습니다 . 오히려 &lt;code&gt;rhs&lt;/code&gt; 가 가리키는 범위를이 &lt;code&gt;RefRange&lt;/code&gt; 가 가리키는 범위에 할당합니다 . 이 때문입니다</target>
        </trans-unit>
        <trans-unit id="e81812302527d63ee87960159e6a1b9dd25fb020" translate="yes" xml:space="preserve">
          <source>This does not include any time during which the StopWatch was stopped but does include</source>
          <target state="translated">여기에는 StopWatch가 중지 된 시간은 포함되지 않지만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c432390e6bbf7d9fb981f314323bac09cd4ec391" translate="yes" xml:space="preserve">
          <source>This does not mean, however, that one can change the data:</source>
          <target state="translated">그러나 이것이 데이터를 변경할 수 있음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d63844eee394540a61e05092a78018f8dcdacad" translate="yes" xml:space="preserve">
          <source>This doesn't include '\n', '\r', \t' and other non-space &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. For commonly used less strict semantics see &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기에는 '\ n', '\ r', \ t '및 기타 공백이 아닌 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 는 포함되지 않습니다 . 일반적으로 덜 엄격한 의미론을 사용하려면 &lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b899c5918773ae82ab7898c96cd3e0a68f5b5e5e" translate="yes" xml:space="preserve">
          <source>This doesn't work for TLS memory, though.</source>
          <target state="translated">그러나 TLS 메모리에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="add950f77c9072c48dcd0ff96facedd547735caa" translate="yes" xml:space="preserve">
          <source>This easy handle has completed. 'result' contains the CURLcode of the transfer</source>
          <target state="translated">이 손쉬운 손잡이가 완성되었습니다. 'result'에는 전송의 CURLcode가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ef5d8951fd69c70c7d61e2bd1231248df49b6d3e" translate="yes" xml:space="preserve">
          <source>This example creates a DOM (Document Object Model) tree from an XML file.</source>
          <target state="translated">이 예제는 XML 파일에서 DOM (Document Object Model) 트리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="74ec60c9c14341e9d9e5373aa773d98804f76f30" translate="yes" xml:space="preserve">
          <source>This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power.</source>
          <target state="translated">이 예제는 파일을 수동으로 구성 및 재구성한다는 점을 제외하고는 거의 동일한 기능을 수행합니다. 이것은 더 많은 작업이지만 관련된 기술은 훨씬 더 많은 힘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a4cbb05cb72419e58f855fffb51071ca39f119b" translate="yes" xml:space="preserve">
          <source>This example encodes the input data one byte at a time.</source>
          <target state="translated">이 예제는 한 번에 한 바이트 씩 입력 데이터를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="efc529b5b8a635fe0248f0e1b5570f3e5c62ec50" translate="yes" xml:space="preserve">
          <source>This example encodes the input one line at a time.</source>
          <target state="translated">이 예제는 한 번에 한 줄씩 입력을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="709f6883e08535336d0975187381366956732f0d" translate="yes" xml:space="preserve">
          <source>This example of template foo has a value parameter that is specialized for 10:</source>
          <target state="translated">이 템플릿 foo 예제에는 10에 특화된 값 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c7fc0bf8d7d58bae3c653e435da196f5834dccc" translate="yes" xml:space="preserve">
          <source>This example shows decoding one byte at a time.</source>
          <target state="translated">이 예제는 한 번에 한 바이트를 디코딩하는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca9412e6a6a265cc25cdadaa2feca886b99350b4" translate="yes" xml:space="preserve">
          <source>This example shows decoding over a range of input data lines.</source>
          <target state="translated">이 예는 다양한 입력 데이터 라인에 대한 디코딩을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3ca157dc5296c9dbda3b67885000d1a3d169c64b" translate="yes" xml:space="preserve">
          <source>This example uses a mixin to implement a generic Duff's device for an arbitrary statement (in this case, the arbitrary statement is in bold). A nested function is generated as well as a delegate literal, these can be inlined by the compiler:</source>
          <target state="translated">이 예제에서는 믹스 인을 사용하여 임의의 명령문에 대한 일반 Duff의 디바이스를 구현합니다 (이 경우 임의의 명령문은 굵게 표시됨). 중첩 함수뿐만 아니라 델리게이트 리터럴도 생성되며 컴파일러에서 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd04b9d165e95a5b5d46f431bdbd8794b151b29" translate="yes" xml:space="preserve">
          <source>This example will create an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;, and log the message using &lt;code&gt;NSLog&lt;/code&gt; to stderr.</source>
          <target state="translated">이 예제는 Objective-C 문자열 &lt;code&gt;NSString&lt;/code&gt; 을 작성하고 &lt;code&gt;NSLog&lt;/code&gt; 를 사용 하여 stderr에 메시지를 로그합니다 .</target>
        </trans-unit>
        <trans-unit id="5b44fd2927053fecf7f02a805bef21a73969e7c8" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an error occurs when parsing a UUID from a string.</source>
          <target state="translated">문자열에서 UUID를 구문 분석 할 때 오류가 발생하면이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83cf2ca3dac976d4903c104f6cecb54eca32e9c0" translate="yes" xml:space="preserve">
          <source>This exists in order to find where &lt;code&gt;STC.maybescope&lt;/code&gt; is getting turned off.</source>
          <target state="translated">&lt;code&gt;STC.maybescope&lt;/code&gt; 가 꺼져 있는 위치를 찾기 위해 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="ec12e985e5f97029a4fdcc178a312496ababfe99" translate="yes" xml:space="preserve">
          <source>This fiber must be in state HOLD.</source>
          <target state="translated">이 파이버는 HOLD 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="050dfac3109c2719a43b56525c7b1b2f0f5442dd" translate="yes" xml:space="preserve">
          <source>This fiber must be in state TERM or HOLD.</source>
          <target state="translated">이 파이버는 TERM 또는 HOLD 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8069d75e504b5df60eaae8b05121a6dfce90e592" translate="yes" xml:space="preserve">
          <source>This field has been deprecated. Please use &lt;code&gt;cacheLevels&lt;/code&gt; instead.</source>
          <target state="translated">이 필드는 더 이상 사용되지 않습니다. 사용하십시오 &lt;code&gt;cacheLevels&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="a88f12f8698a93effebf4b21ac2fcaaf1ed6557e" translate="yes" xml:space="preserve">
          <source>This field is populated when using &lt;a href=&quot;#csvReader&quot;&gt;&lt;code&gt;csvReader&lt;/code&gt;&lt;/a&gt; but not by &lt;a href=&quot;#csvNextToken&quot;&gt;&lt;code&gt;csvNextToken&lt;/code&gt;&lt;/a&gt; as this data will have already been fed to the output range.</source>
          <target state="translated">이 필드는 &lt;a href=&quot;#csvReader&quot;&gt; &lt;code&gt;csvReader&lt;/code&gt; 를&lt;/a&gt; 사용할 때 채워지 지만 &lt;a href=&quot;#csvNextToken&quot;&gt; &lt;code&gt;csvNextToken&lt;/code&gt; &lt;/a&gt; 이 아닌 경우이 데이터는 이미 출력 범위에 공급되므로 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="00b3ae505bfa7b5877d4290b9bf62b73f3526eab" translate="yes" xml:space="preserve">
          <source>This field was added in CURLVERSION_THIRD</source>
          <target state="translated">이 필드는 CURLVERSION_THIRD에 추가되었습니다</target>
        </trans-unit>
        <trans-unit id="ded4afb1457e0f04e1bc6ce625b9a154f7bfa729" translate="yes" xml:space="preserve">
          <source>This flag has no effect on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">이 기능</target>
        </trans-unit>
        <trans-unit id="63a837cbc01e12716c2a63542540dfd3d20ec868" translate="yes" xml:space="preserve">
          <source>This function allocates memory.</source>
          <target state="translated">이 기능은 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="92814a3bf729ba0c96c36e96433e5f0d828849bd" translate="yes" xml:space="preserve">
          <source>This function allows user-defined subclasses of EncodingScheme to be declared in other modules.</source>
          <target state="translated">이 함수를 사용하면 EncodingScheme의 사용자 정의 서브 클래스를 다른 모듈에서 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="471f7413c5ebea16f57422410a8bf930e30c75d3" translate="yes" xml:space="preserve">
          <source>This function also decomposes hangul syllables as prescribed by the standard.</source>
          <target state="translated">이 기능은 표준에 규정 된 한글 음절을 분해합니다.</target>
        </trans-unit>
        <trans-unit id="534457dcd59761dcb843df10d6fcec190ed3b4c4" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if &lt;code&gt;paths&lt;/code&gt; is a forward range.</source>
          <target state="translated">이 함수는 항상 결과 경로를 유지하기 위해 메모리를 할당합니다. 가변 &lt;code&gt;paths&lt;/code&gt; 는 경로 가 순방향 범위 인 경우 범위 버전과 마찬가지로 단일 할당 만 수행하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd9256b25c3dea2b100b91fc151d4d49aa057003" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#asNormalizedPath&quot;&gt;&lt;code&gt;asNormalizedPath&lt;/code&gt;&lt;/a&gt; to not allocate memory.</source>
          <target state="translated">이 함수는 항상 결과 경로를 유지하기 위해 메모리를 할당합니다. 메모리를 할당하지 &lt;a href=&quot;#asNormalizedPath&quot;&gt; &lt;code&gt;asNormalizedPath&lt;/code&gt; &lt;/a&gt; 려면 asNormalizedPath 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="187779b43f44c34c6b32550dd282a3cd2f13a1e6" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#buildNormalizedPath&quot;&gt;&lt;code&gt;buildNormalizedPath&lt;/code&gt;&lt;/a&gt; to allocate memory and return a string.</source>
          <target state="translated">이 함수는 항상 결과 경로를 유지하기 위해 메모리를 할당합니다. &lt;a href=&quot;#buildNormalizedPath&quot;&gt; &lt;code&gt;buildNormalizedPath&lt;/code&gt; &lt;/a&gt; 를 사용 하여 메모리를 할당하고 문자열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="565ae089ae893ce04d0723fbc06da8efba3b5449" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="translated">이 함수 는 파일 핸들에 대해 Windows에서 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt; &lt;code&gt;FlushFileBuffers&lt;/code&gt; &lt;/a&gt; 를 호출 하고 POSIX에서 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt; &lt;code&gt;fsync&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d989c6dc339b51f4794a097923e996539197f19d" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c2e50367d22c68b1ef6bf70b530cf16359f88a" translate="yes" xml:space="preserve">
          <source>This function can allocate if the &lt;code&gt;Yes.allocateGC&lt;/code&gt; flag is passed. This has the benefit of have better complexity than the &lt;code&gt;Yes.allocateGC&lt;/code&gt; option. However, this option is only available for ranges whose equality can be determined via each element's &lt;code&gt;toHash&lt;/code&gt; method. If customized equality is needed, then the &lt;code&gt;pred&lt;/code&gt; template parameter can be passed, and the function will automatically switch to the non-allocating algorithm. See &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; for more details on how to define &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 플래그가 전달 되면 할당 할 수 있습니다 . 이것은 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 옵션 보다 더 복잡하다는 이점이 있습니다 . 그러나이 옵션은 각 요소의 &lt;code&gt;toHash&lt;/code&gt; 메소드 를 통해 동등성을 판별 할 수있는 범위에만 사용할 수 있습니다 . 사용자 정의 된 동등성이 필요한 경우 &lt;code&gt;pred&lt;/code&gt; 템플릿 매개 변수를 전달할 수 있으며 함수는 비 할당 알고리즘으로 자동 전환됩니다. &lt;code&gt;pred&lt;/code&gt; 정의 방법에 대한 자세한 내용 은 &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b1f8d9be7c40727aeac47ccfd7444f517f04172" translate="yes" xml:space="preserve">
          <source>This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">이 기능 할 수 &lt;code&gt;@trusted&lt;/code&gt; 의 대응 생성자 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287c25734ab50e3ae9a7c39776861bb5646f4c1c" translate="yes" xml:space="preserve">
          <source>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the &lt;code&gt;cs&lt;/code&gt; template parameter which, if not specified, is given by &lt;a href=&quot;#CaseSensitive&quot;&gt;&lt;code&gt;CaseSensitive&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.osDefault&lt;/code&gt;.</source>
          <target state="translated">이 기능은 대소 문자를 구분하거나 대소 문자를 구분하지 않고 비교할 수 있습니다. 이는 지정되지 않은 경우 &lt;a href=&quot;#CaseSensitive&quot;&gt; &lt;code&gt;CaseSensitive&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.osDefault&lt;/code&gt; 에 의해 제공되는 &lt;code&gt;cs&lt;/code&gt; 템플리트 매개 변수를 통해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e873b6c5b5805640016d4214ee3463e370b995d" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">이 기능은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt;'basename'쉘 유틸리티의 POSIX 요구 사항을&lt;/a&gt; 준수 합니다 (Windows 경로에 적합하게 조정).</target>
        </trans-unit>
        <trans-unit id="271fe9a4358104e29e9baaf0f70ca7697a626f35" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">이 기능은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt;'dirname'쉘 유틸리티에 대한 POSIX 요구 사항을&lt;/a&gt; 준수 합니다 (Windows 경로에 적합하게 조정).</target>
        </trans-unit>
        <trans-unit id="ff866808f96c1b68713349130ffb6a559a607397" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cbc5071d857be05bbf5253561a5cc2d4864616" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f911814cd134bf58a8ba7e68aae37ec618511b50" translate="yes" xml:space="preserve">
          <source>This function consumes the input. After each call the input will start with either a delimiter or record break (\n, \r\n, \r) which must be removed for subsequent calls.</source>
          <target state="translated">이 기능은 입력을 소비합니다. 각 호출 후 입력은 분리 문자 또는 레코드 구분 (\ n, \ r \ n, \ r)으로 시작하여 후속 호출에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="82adca51d2d89c2e52168f23c5014dcf4b09b7e3" translate="yes" xml:space="preserve">
          <source>This function creates a complete DOM (Document Object Model) tree.</source>
          <target state="translated">이 함수는 완전한 DOM (Document Object Model) 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="34f7e14685f9dc1d8824f48b2307f8cd989b3e43" translate="yes" xml:space="preserve">
          <source>This function decodes the entities &amp;amp;amp;, &amp;amp;quot;, &amp;amp;apos;, &amp;amp;lt; and &amp;amp;gt, as well as decimal and hexadecimal entities such as &amp;amp;#x20AC;</source>
          <target state="translated">이 함수는 엔티티 &amp;amp; amp ;, &amp;amp; apos; &amp;amp; lt; &amp;amp;&amp;amp; gt;뿐만 아니라 &amp;amp; # x20AC와 같은 10 진수 및 16 진 엔터티;</target>
        </trans-unit>
        <trans-unit id="37bc9985a8792341b2d7a8d50dc7ab55bd1e93ad" translate="yes" xml:space="preserve">
          <source>This function defends against this attack by always comparing every single item in the array if the two arrays are the same length. Therefore, this function is always &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) for ranges of the same length.</source>
          <target state="translated">이 함수는 두 배열의 길이가 같은 경우 배열의 모든 단일 항목을 항상 비교하여이 공격을 방지합니다. 따라서이 함수는 길이가 같은 범위에 대해 항상 &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="07fbd70f1f7940fca06c0a8a3c74b8aabe9ac979" translate="yes" xml:space="preserve">
          <source>This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</source>
          <target state="translated">이 함수는 구현 방법에 대한 명확한 대답이 없으므로 wstring 및 dstring에 대한 과부하를 제공하지 않습니다. 문자열, wstring 및 dstring 입력은 동일한 출력을 가져야하지만 문자열과 wstring에 대해 다른 출력을 생성하는 Boost와 호환되지 않을 것이라고 주장 할 수 있습니다. ubyte [] 함수 오버로드를 사용하여 wstring과 dstring을 전달하는 것이 항상 가능합니다 (그러나 엔디안 문제를 알고 있습니다!).</target>
        </trans-unit>
        <trans-unit id="a7eab1a520623d1ac5e68ed2c102542d0c568c2a" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference.</source>
          <target state="translated">이 함수는 단일 코드 포인트를 하나 이상의 코드 단위로 인코딩합니다. 코드 단위는 사용자가 제공 한 고정 크기 배열에 저장되며 참조로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4dfecb064dc08682e5d5f6ff6e2a923d6c06c55" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. It returns a string containing those code units.</source>
          <target state="translated">이 함수는 단일 코드 포인트를 하나 이상의 코드 단위로 인코딩합니다. 해당 코드 단위가 포함 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d23af3939d6f49cb27a211fdfb01f49551cd4f68" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate.</source>
          <target state="translated">이 함수는 단일 코드 포인트를 하나 이상의 코드 단위로 인코딩합니다. 코드 단위는 제공된 델리게이트로 한 번에 하나씩 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fd5007482279246870e612a2f7b9d7848a9ec8a9" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.)</source>
          <target state="translated">이 함수는 단일 코드 포인트를 하나 이상의 ubyte로 인코딩합니다. 제공된 버퍼는 코드 단위로 정렬되어야합니다. 예를 들어, UTF-16LE 또는 UTF-16BE는 wchar로 정렬되어야하고 UTF-32LE 또는 UTF-32BE는 dchar로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a399e2ee90c7d22546000e946a9cf8427b4a082" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">이 함수 는 정확한 형식이 무엇인지 신경 쓰지 않는 코드를 위해 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 문자열 로 쉽게 변환 할 수 있도록하기 위해 존재합니다 . 또한 toString을 사용하여 사용자 정의 형식을 변환하는 &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; 또는 &lt;code&gt;writeln&lt;/code&gt; 과 같은 함수를 사용할 때 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 문자열 로 쉽게 변환 할 수 있습니다. 따라서 많은 코드가 toString을 직접 호출하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c7ed4f81f0a82e13d48bb2e31cd6ec82cd2b86c" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">이 함수 는 정확한 형식이 무엇이든 상관 없이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 문자열 로 쉽게 변환 할 수 있도록하기 위해 존재합니다 . 또한 toString을 사용하여 사용자 정의 형식을 변환하는 &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; 또는 &lt;code&gt;writeln&lt;/code&gt; 과 같은 함수를 사용할 때 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 문자열 로 쉽게 변환 할 수 있습니다. 따라서 많은 코드가 toString을 직접 호출하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a64dc24e50c98de86395100f53371f383577cde" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 정확한 형식이 무엇인지 신경 쓰지 않는 코드를위한 문자열 로 쉽게 변환 할 수 있도록하기 위해 존재합니다 . 또한 toString을 사용하여 사용자 정의 형식을 변환하는 &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; 또는 &lt;code&gt;writeln&lt;/code&gt; 과 같은 함수를 사용할 때 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 문자열 로 쉽게 변환 할 수 있습니다. 따라서 많은 코드가 toString을 직접 호출하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="14f41e253b823f745b15c2cc550803f474f520f9" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 정확한 형식이 무엇인지 신경 쓰지 않는 코드의 문자열 로 쉽게 변환 할 수 있도록하기 위해 존재합니다 . 또한 toString을 사용하여 사용자 정의 형식을 변환하는 &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; 또는 &lt;code&gt;writeln&lt;/code&gt; 과 같은 함수를 사용할 때 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 를 문자열 로 쉽게 변환 할 수 있습니다. 따라서 많은 코드가 toString을 직접 호출하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1148e69f156783aee95aaac3af378446a842c947" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">이 함수는 네임 스페이스 UUID 및 이름에서 이름 기반 (버전 3) UUID를 생성합니다. 네임 스페이스 UUID가 전달되지 않은 경우 빈 UUID &lt;code&gt;UUID.init&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66eef894e5457f79fe590d4b75d5bdb426faba8d" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">이 함수는 네임 스페이스 UUID 및 이름에서 이름 기반 (버전 5) UUID를 생성합니다. 네임 스페이스 UUID가 전달되지 않은 경우 빈 UUID &lt;code&gt;UUID.init&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebad38cdc822b58300e9d455ffae98ef3b8355b1" translate="yes" xml:space="preserve">
          <source>This function generates a random number based UUID from a random number generator.</source>
          <target state="translated">이 함수는 난수 생성기에서 난수 기반 UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f6f7c9706e6dcaec3dbc1161d8b30b320ab44ea3" translate="yes" xml:space="preserve">
          <source>This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</source>
          <target state="translated">이 기능은 0에서 멀리 떨어진 x 값에 대한 상대 정확도가 높습니다. 0에 가까운 값의 경우 erf (x)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e015cb774f65ac50bf4cc869720d1f86b5a714ec" translate="yes" xml:space="preserve">
          <source>This function is #1 on the list of functions that eat cpu time. Be very, very careful about slowing it down.</source>
          <target state="translated">이 함수는 CPU 시간을 먹는 함수 목록에서 # 1입니다. 속도를 늦추는 데 매우 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="3d30b43ff787a8dfba63ef7540785dda2309b0ec" translate="yes" xml:space="preserve">
          <source>This function is &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="60a203a8ffe09817c002b043b4f7c89faa37bc5d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;@safe&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;@safe&lt;/code&gt; 의 대응 생성자 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b9e96c1bd954c7d66e5b95c40487111fc7a052" translate="yes" xml:space="preserve">
          <source>This function is POSIX-Only.</source>
          <target state="translated">이 기능은 POSIX 전용입니다.</target>
        </trans-unit>
        <trans-unit id="6f04b8551bbda2b81d8696beac9a1b771dca8c71" translate="yes" xml:space="preserve">
          <source>This function is Posix-Only.</source>
          <target state="translated">이 기능은 Posix-Only입니다.</target>
        </trans-unit>
        <trans-unit id="fbf60467a7efe2e24827c64edfe554cec3d53403" translate="yes" xml:space="preserve">
          <source>This function is Windows-Only.</source>
          <target state="translated">이 기능은 Windows 전용입니다.</target>
        </trans-unit>
        <trans-unit id="ad2fac1ecb2ded333fe1cd86ddc09c5fee778c2d" translate="yes" xml:space="preserve">
          <source>This function is a public API, exposed in &lt;code&gt;core.runtime&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;core.runtime&lt;/code&gt; 에 노출 된 공개 API 입니다.</target>
        </trans-unit>
        <trans-unit id="103c72135b781967b4b7d6c0026bb26f7259605d" translate="yes" xml:space="preserve">
          <source>This function is also useful in checking for the existence of an environment variable.</source>
          <target state="translated">이 기능은 환경 변수가 있는지 확인하는 데에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ff6b0b14fd4304f9c34b27c03cced94d986e4033" translate="yes" xml:space="preserve">
          <source>This function is character-range specific and, contrary to &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt;, runs of whitespace will be merged together (no empty tokens will be produced).</source>
          <target state="translated">이 함수는 문자 범위에 따라 &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt; 와 달리 공백 문자가 병합됩니다 (빈 토큰이 생성되지 않음).</target>
        </trans-unit>
        <trans-unit id="65b5ee7f9fec25cbb593bdce1cbdc98ea5f973e1" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and calls &lt;code&gt;deallocateAll&lt;/code&gt; for them in turn.</source>
          <target state="translated">이 함수는 두 할당자가 정의한 경우에만 정의되며 &lt;code&gt;deallocateAll&lt;/code&gt; 을 차례로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8e12c13033743e308c93ef7b1af47f1c5b48d3a7" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and forwards appropriately depending on &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">이 함수는 두 할당자가 정의한 경우에만 정의되며 &lt;code&gt;b.length&lt;/code&gt; 에 따라 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebd4634555bf7b1d8d38cdad8559fbd72f2f0cbb" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and returns the conjunction of &lt;code&gt;empty&lt;/code&gt; calls for the two.</source>
          <target state="translated">이 함수는 두 할당자가 정의한 경우에만 정의되며 둘에 대한 &lt;code&gt;empty&lt;/code&gt; 호출 의 결합을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0fd9509d9dd53b0824e520cb29e4d50f69f4b9cc" translate="yes" xml:space="preserve">
          <source>This function is never used when autodecoding is turned off.</source>
          <target state="translated">이 기능은 자동 디코딩이 꺼져있을 때는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72987efb86a1c65d967d861a8683d92ed7f13b9d" translate="yes" xml:space="preserve">
          <source>This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead.</source>
          <target state="translated">이 기능은 일반적으로별로 유용하지 않습니다. 빠른 함수 nextUp () 또는 nextDown ()을 대신 사용하는 것이 거의 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ee8874e9697da79fd0874b41752112f89149a3af" translate="yes" xml:space="preserve">
          <source>This function is not implemented for Digital Mars C runtime.</source>
          <target state="translated">이 기능은 Digital Mars C 런타임에서 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7e3e7b8bfa4b21481d77f68ea65de0d9b8237c1" translate="yes" xml:space="preserve">
          <source>This function is not supported at compile time.</source>
          <target state="translated">이 기능은 컴파일 타임에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1569b54f86e9b2550627b7e8e8f05e326ad676e8" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe!</source>
          <target state="translated">이 기능은 스레드로부터 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="41af9d14cc682c76550081ea13492c59097f2bca" translate="yes" xml:space="preserve">
          <source>This function is only aware of EncodingSchemes which have been registered with the register() function.</source>
          <target state="translated">이 함수는 register () 함수로 등록 된 EncodingSchemes 만 인식합니다.</target>
        </trans-unit>
        <trans-unit id="290ee1b0991973abcaa58bca7c5f6871e5deb008" translate="yes" xml:space="preserve">
          <source>This function is only implemented to 80 bit precision.</source>
          <target state="translated">이 기능은 80 비트 정밀도로만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ee429d1ffe9a170a1a75d5b4a2ff165cd4f65550" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</source>
          <target state="translated">이 기능은 오류 발생에 대해 다시 입력됩니다. false를 반환하면 tiargs의 모든 요소가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a118a63c84fce3cf7c06f5f8756bac60c7cca3ac" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</source>
          <target state="translated">이 기능은 오류 발생에 대해 다시 입력됩니다. false를 반환하면이 개체의 멤버가 수정되지 않으며 반복 호출에서 동일한 오류가 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="45e502c95c63dd3997ac1ae57545286a53eaf26c" translate="yes" xml:space="preserve">
          <source>This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</source>
          <target state="translated">이 기능은 CTFE 코드에서 지원됩니다. 컴파일 타임에 구문 분석 된 잘못된 UUID로 인해 발생하는 오류 메시지는 암호화 할 수 있지만 오류는 컴파일 타임에 감지 및보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5bb3aca496547a19019cbfbd46c1d03c7dd418c6" translate="yes" xml:space="preserve">
          <source>This function is tentatively defined as &lt;code&gt;nothrow&lt;/code&gt; to prevent &lt;code&gt;opPostMove&lt;/code&gt; from being defined without &lt;code&gt;nothrow&lt;/code&gt;, which would allow for possibly confusing changes in program flow.</source>
          <target state="translated">이 함수는 일시적으로 &lt;code&gt;nothrow&lt;/code&gt; 로 정의되어 &lt;code&gt;opPostMove&lt;/code&gt; 가 &lt;code&gt;nothrow&lt;/code&gt; 없이 정의되지 않도록 하여 프로그램 흐름의 혼란스러운 변경을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="185d734d5fc912e0041185bf79a2b6f944b2db35" translate="yes" xml:space="preserve">
          <source>This function is used to (re)initialize the digest. It must be called before using the digest and it also works as a 'reset' function if the digest has already processed data.</source>
          <target state="translated">이 기능은 다이제스트를 (재) 초기화하는 데 사용됩니다. 다이제스트를 사용하기 전에 호출해야하며 다이제스트가 이미 데이터를 처리 한 경우 '재설정'기능으로도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="99071cc1c1c24be1d51b7e6eda1e08791479ed2b" translate="yes" xml:space="preserve">
          <source>This function is used to read the content of DFLAGS. Flags are separated based on spaces and tabs.</source>
          <target state="translated">이 기능은 DFLAGS의 내용을 읽는 데 사용됩니다. 공백과 탭을 기준으로 플래그가 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="2d39d375bb67b5bea56b7ea75d0a2e4ee34a5fe2" translate="yes" xml:space="preserve">
          <source>This function is useful for maintaining worker-local resources.</source>
          <target state="translated">이 기능은 작업자 로컬 리소스를 유지 관리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c37fe60667a42f9d7da86b803e8b5052d66d498d" translate="yes" xml:space="preserve">
          <source>This function is, in particular, meant to help maintain garbage collector invariants when a lock is not used.</source>
          <target state="translated">이 기능은 특히 잠금을 사용하지 않을 때 가비지 콜렉터 불변량을 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="aa18c6da596117f8b9e11fbedcdfb9a943118fde" translate="yes" xml:space="preserve">
          <source>This function logs data in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="77ac69a4b95956005ebe3b90c8e1ca91567efe01" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 데이터를 &lt;code&gt;sharedLog&lt;/code&gt; 에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="98febaf749a97b9336fc523ba35aa7fdcff34cf1" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;, optionally depending on a condition.</source>
          <target state="translated">이 함수 는 선택적으로 조건에 따라 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 에 데이터를 로깅합니다 .</target>
        </trans-unit>
        <trans-unit id="eda414e04cca7c9801e1364601be4f243d02a0be" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 조건에 따라 사용 된 &lt;code&gt;Logger&lt;/code&gt; 에 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="66789021f1f75fa2b910c0e9aaed002765517585" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition.</source>
          <target state="translated">이 기능 은 조건에 따라 사용 된 &lt;code&gt;Logger&lt;/code&gt; 에 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="ea29ac02cb23a3225768859acfa66ad70cf0ae39" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a explicitly passed condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 기능은 사용 데이터 로깅 &lt;code&gt;Logger&lt;/code&gt; 함께 명시 적으로 전달 조건에 따라 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a8c9b909022c7e8d9e73cb0c216e864ba19a51" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 사용 된 &lt;code&gt;Logger&lt;/code&gt; 에 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="628f5766ea3ce125dda3efbe604aac9ecda078eb" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; and depending on a condition in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식 의 조건에 따라 특정 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 사용 된 &lt;code&gt;Logger&lt;/code&gt; 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="f75a8e8d5f3578debc1682e9b8a4e7729b3c532e" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 함수 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 특정 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 사용 된 &lt;code&gt;Logger&lt;/code&gt; 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="ca804d9917691f26fc7fe486237e02550749abb2" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 특정 &lt;code&gt;LogLevel&lt;/code&gt; 과 함께 사용 된 &lt;code&gt;Logger&lt;/code&gt; 데이터를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="3ca01c9755ef83db66052e862db8bfa8416b4a46" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 함수는 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 사용 된 Logger에 데이터를 &lt;code&gt;Logger&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="32b20bbe0e9053ff439b8531776b44b5d48b2b21" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 함수는 사용 된 &lt;code&gt;Logger&lt;/code&gt; 데이터를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="de4891742f4a098eab831566cf8b20847dcaef47" translate="yes" xml:space="preserve">
          <source>This function logs data.</source>
          <target state="translated">이 기능은 데이터를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f6a6f2512cc3b6d3cec5f7eabcb2475f26f787b9" translate="yes" xml:space="preserve">
          <source>This function modifies &lt;code&gt;inp&lt;/code&gt; and thus &lt;code&gt;inp&lt;/code&gt; must be an L-value.</source>
          <target state="translated">이 함수는 &lt;code&gt;inp&lt;/code&gt; 를 수정 하므로 &lt;code&gt;inp&lt;/code&gt; 는 L 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e7aa3a07169729c5a673fe4e99d00fd959fedfe3" translate="yes" xml:space="preserve">
          <source>This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension).</source>
          <target state="translated">이 함수는 일반적으로 새 문자열을 할당합니다 (경로를 변경할 수없고 아직 확장자가없는 경우는 예외입니다).</target>
        </trans-unit>
        <trans-unit id="7c7d082480a49d72cdaa9587898253b55870d5fe" translate="yes" xml:space="preserve">
          <source>This function only handles 1:1 &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; mapping and thus is not sufficient for certain alphabets like German, Greek and few others.</source>
          <target state="translated">이 함수는 1 : 1 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 매핑 만 처리 하므로 독일어, 그리스어 및 기타 알파벳과 같은 특정 알파벳에는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d4c84cebd7adfe7f4082a2a17dcc09bc723efd3" translate="yes" xml:space="preserve">
          <source>This function performs several memory allocations.</source>
          <target state="translated">이 기능은 여러 메모리 할당을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="36f6f15315bfa28fc8956871508424ecedf0dc3c" translate="yes" xml:space="preserve">
          <source>This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">이 함수는 패턴 특성에 따라 가장 적합한 정규식 엔진을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="34bd902809c0b5255b567c50dd18197e0b398a33" translate="yes" xml:space="preserve">
          <source>This function prints the passed &lt;code&gt;Option&lt;/code&gt;s and text in an aligned manner on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">이 함수는 전달 된 &lt;code&gt;Option&lt;/code&gt; 과 텍스트를 &lt;code&gt;stdout&lt;/code&gt; 에 정렬 된 방식으로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="770ded5804f61f67694592c9314c6c39ad348096" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">이 함수는 문자열 끝에서 하나 이상의 코드 단위를 제거하고 해당 코드 단위가 나타내는 디코딩 된 코드 포인트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63d27ce6c5e48781869a5f906f514c111b2ab498" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">이 함수는 문자열의 시작 부분에서 하나 이상의 코드 단위를 제거하고 해당 코드 단위가 나타내는 디코딩 된 코드 포인트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="991bbd196cea9f8531404b722484d52c7268693c" translate="yes" xml:space="preserve">
          <source>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent.</source>
          <target state="translated">이 함수는 배열의 시작에서 하나 이상의 ubyte를 제거하고 해당 ubyte가 나타내는 디코딩 된 코드 포인트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bd8d3ae1218b20b89d6f5e7ab875d1f322ea2c00" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; on Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; on POSIX, and &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; on Android.</source>
          <target state="translated">이 함수가 반환 &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; Windows에서, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; POSIX에, 그리고 &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; 안드로이드에.</target>
        </trans-unit>
        <trans-unit id="cfc5056dabba79a946af25fc1dd8feac3fe04895" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to a static copy of the version info struct. See above.</source>
          <target state="translated">이 함수는 버전 정보 구조체의 정적 복사본에 대한 포인터를 반환합니다. 위 참조.</target>
        </trans-unit>
        <trans-unit id="bb8f6db61ab479424f86bd4d40e2eb70c3733a62" translate="yes" xml:space="preserve">
          <source>This function returns a thread unique &lt;code&gt;Logger&lt;/code&gt;, that by default propergates all data logged to it to the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">이 함수는 스레드 고유 &lt;code&gt;Logger&lt;/code&gt; 반환하며 , 기본적으로 로그에 기록 된 모든 데이터를 &lt;code&gt;sharedLog&lt;/code&gt; 에 적절하게 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="85a54448d469e795c947752c78a6d4cb2de70c6f" translate="yes" xml:space="preserve">
          <source>This function searches with policy &lt;code&gt;sp&lt;/code&gt; to find the largest right subrange on which &lt;code&gt;pred(value, x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly greater than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정책이 함수 검색 &lt;code&gt;sp&lt;/code&gt; 가장 큰 오른쪽 부분 범위 찾을 &lt;code&gt;pred(value, x)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 모든 &lt;code&gt;x&lt;/code&gt; (경우, 예 &lt;code&gt;pred&lt;/code&gt; &quot;보다 작음&quot;보다 확실히 큰 요소 범위의 부분 반환 &lt;code&gt;value&lt;/code&gt; ). 검색 일정과 그 복잡성에 설명되어 있습니다 &lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86863ccd0cc5913a3769149726c682b13dc136f9" translate="yes" xml:space="preserve">
          <source>This function sets an association in the multi handle between the given socket and a private pointer of the application. This is (only) useful for curl_multi_socket uses.</source>
          <target state="translated">이 함수는 주어진 소켓과 응용 프로그램의 전용 포인터 사이의 다중 핸들에서 연관을 설정합니다. curl_multi_socket 사용에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="45ebc1498e7faf85df00e384f08e7ba59324aaf5" translate="yes" xml:space="preserve">
          <source>This function should be used for expensive functions, as waiting on a condition variable introduces latency, but avoids wasted CPU cycles.</source>
          <target state="translated">조건 변수를 대기하면 대기 시간이 길어 지지만 CPU 사이클 낭비를 피할 수 있으므로이 기능은 비싼 기능에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e6634f9a998d963ab6d1c10d0d15ad19ccda248" translate="yes" xml:space="preserve">
          <source>This function should be used when you expect the result of the &lt;code&gt;Task&lt;/code&gt; to be available on a timescale shorter than that of an OS context switch.</source>
          <target state="translated">이 기능은 &lt;code&gt;Task&lt;/code&gt; 결과가 OS 컨텍스트 스위치보다 짧은 시간 단위로 제공 될 것으로 예상 될 때 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="84d0dda7f69c92e937d2c85cb930b35b5906bc64" translate="yes" xml:space="preserve">
          <source>This function simply returns the &lt;code&gt;Rebindable&lt;/code&gt; object passed in. It's useful in generic programming cases when a given object may be either a regular &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;Rebindable&lt;/code&gt;.</source>
          <target state="translated">이 함수는 단순히 전달 된 &lt;code&gt;Rebindable&lt;/code&gt; 객체 를 반환합니다 . 주어진 객체가 일반 &lt;code&gt;class&lt;/code&gt; 이거나 &lt;code&gt;Rebindable&lt;/code&gt; 일 수있는 일반적인 프로그래밍 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="75bbfb153afd3973808d9088100797f6903e565d" translate="yes" xml:space="preserve">
          <source>This function supercedes &lt;a href=&quot;#toUCSindex&quot;&gt;&lt;code&gt;toUCSindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#toUCSindex&quot;&gt; &lt;code&gt;toUCSindex&lt;/code&gt; &lt;/a&gt; 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="82566e279c83708bdcc5beef2341e2cb52b9d496" translate="yes" xml:space="preserve">
          <source>This function supersedes &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt; 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="c8a982375de1de2eaf1b0bfc6ef749e37da8e235" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently.</source>
          <target state="translated">이 함수는 std.utf.decode ()보다 우선하지만 codePoints () 함수는보다 편리하게 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3610464c0d3095b814b50eec2269b0b83ec7dc6a" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode().</source>
          <target state="translated">이 함수는 std.utf.decode ()를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3ed87f3ac177989d1d591be6e146c6a7ad9b003c" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently.</source>
          <target state="translated">이 함수는 std.utf.encode ()를 대체하지만 codeUnits () 함수는이를보다 편리하게 대체합니다.</target>
        </trans-unit>
        <trans-unit id="98db0a10ff6e0809060d25a9c9ccbac61cd894c8" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode().</source>
          <target state="translated">이 함수는 std.utf.encode ()를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="6581afa2c255deba8c9a51b34c12340690fe56e5" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently).</source>
          <target state="translated">이 함수는 std.utf.toUTF8 (), std.utf.toUTF16 () 및 std.utf.toUTF32 ()를 대체합니다 (그러나! ()는보다 편리하게 대체합니다).</target>
        </trans-unit>
        <trans-unit id="b48f04fdfd63524d418640a2544c0d752dc1f11b" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTFindex().</source>
          <target state="translated">이 함수는 std.utf.toUTFindex ()를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="463c192ee5d4e01c6f9684913be662a0a7946d01" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception.</source>
          <target state="translated">이 함수는 std.utf.validate ()를 대체하지만이 함수는 입력이 유효한지 여부를 나타내는 부울을 반환하지만 이전 함수는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="b42d760296ed5ca95af88ffb26c20168d2a48b77" translate="yes" xml:space="preserve">
          <source>This function takes a non-scope delegate, meaning it can be used with closures. If you can't allocate a closure due to objects on the stack that have scoped destruction, see &lt;code&gt;scopedTask&lt;/code&gt;, which takes a scope delegate.</source>
          <target state="translated">이 함수는 범위가 아닌 대리자를 사용하므로 클로저와 함께 사용할 수 있습니다. 범위가 삭제 된 스택의 객체로 인해 클로저를 할당 할 수없는 경우 범위 위임을 &lt;code&gt;scopedTask&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df71b7c251663548a0f5121464d05a78978a7d9e" translate="yes" xml:space="preserve">
          <source>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by &lt;a href=&quot;#isAbsolute&quot;&gt;&lt;code&gt;isAbsolute&lt;/code&gt;&lt;/a&gt;), the preceding segments will be dropped.</source>
          <target state="translated">이 함수는 문자열 요소의 입력 범위 또는 문자열 인수 세트로 제공된 경로 세그먼트 세트를 가져와 서로 연결합니다. 필요한 경우 디렉토리 구분 기호가 세그먼트 사이에 삽입됩니다. 경로 세그먼트 중 하나가 절대적이면 ( &lt;a href=&quot;#isAbsolute&quot;&gt; &lt;code&gt;isAbsolute&lt;/code&gt; 에&lt;/a&gt; 정의 된대로 ) 이전 세그먼트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3df6f1df50a9028bb24157314b57114720f745cc" translate="yes" xml:space="preserve">
          <source>This function template needs be between the compiler and a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">이 함수 템플릿은 컴파일러와 안전성, 순도 및 throwabilty 검사를 우회 한 훨씬 오래된 런타임 후크 사이에 있어야합니다. 기존 코드가 손상되는 것을 방지하기 위해이 함수 템플릿은 구현이 최신 D 기대치에 &lt;code&gt;@trusted pure&lt;/code&gt; 할 때까지 @trusted pure 로 일시적으로 선언 됩니다.</target>
        </trans-unit>
        <trans-unit id="c911ca2b3e26ac7f7502675d63ee542618ab2fa0" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure nothrow&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">이 함수 템플릿은 안전성, 순도 및 투척 검사를 우회 한 훨씬 오래된 런타임 후크에서 이식되었습니다. 기존 코드가 손상되는 것을 방지하기 위해이 함수 템플릿은 구현이 최신 D 기대치에 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; 할 때까지 @trusted pure nothrow로 일시적으로 선언 됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd88572c57bc63342adb7e4bba717ecc664649b" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">이 함수 템플릿은 안전성, 순도 및 투척 검사를 우회 한 훨씬 오래된 런타임 후크에서 이식되었습니다. 기존 코드가 손상되는 것을 방지하기 위해이 함수 템플릿은 구현이 최신 D 기대치에 &lt;code&gt;@trusted pure&lt;/code&gt; 할 때까지 @trusted pure 로 일시적으로 선언 됩니다.</target>
        </trans-unit>
        <trans-unit id="54aa9e4c989c8754e09bfc948cb90d22fd4c28bf" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">이 함수 템플릿은 안전성, 순도 및 투척 검사를 우회 한 훨씬 오래된 런타임 후크에서 이식되었습니다. 기존 코드가 손상되는 것을 방지하기 위해이 함수 템플릿은 구현이 최신 D 기대치에 &lt;code&gt;@trusted&lt;/code&gt; 할 때까지 @trusted 로 일시적으로 선언 됩니다.</target>
        </trans-unit>
        <trans-unit id="c6faa363e2dc5b5097ffda67002301974586de4b" translate="yes" xml:space="preserve">
          <source>This function transforms &lt;code&gt;decimal&lt;/code&gt; value into a value in the factorial number system stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;decimal&lt;/code&gt; 값을 &lt;code&gt;fac&lt;/code&gt; 에 저장된 계승 시스템의 값으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="8756d8490c0c80f8a3d6e17d81badb070e1ac3c5" translate="yes" xml:space="preserve">
          <source>This function uses a search with policy &lt;code&gt;sp&lt;/code&gt; to find the largest left subrange on which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly smaller than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 정책 &lt;code&gt;sp&lt;/code&gt; 를 사용한 검색을 사용하여 모든 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;pred(x, value)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가장 큰 왼쪽 하위 범위를 찾습니다 (예 : &lt;code&gt;pred&lt;/code&gt; 가 &quot;보다 작음&quot;인 경우 &lt;code&gt;value&lt;/code&gt; 보다 엄격하게 작은 요소를 갖는 범위의 일부를 반환 함) ). 검색 일정과 그 복잡성에 설명되어 있습니다 &lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d6e17a7f140767c7776fa94ca98edbcfe8ab26" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">이 함수는 잘못 인코딩 된 배열을 입력으로 받아들입니다. 문자열의 시작에서 유효하지 않은 시퀀스가 ​​발견되면이 함수는 해당 시퀀스를 제거하고 INVALID_SEQUENCE 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b3cc6b0a88ba3b96758bad3549ef80853faeb94e" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">이 함수는 잘못 인코딩 된 문자열을 입력으로 받아들입니다. 문자열의 시작에서 유효하지 않은 시퀀스가 ​​발견되면이 함수는 해당 시퀀스를 제거하고 INVALID_SEQUENCE 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b4c790e3c00edf06c3c523e9a96acaa7028222ba" translate="yes" xml:space="preserve">
          <source>This function will also strip &lt;code&gt;\n\r&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;\n\r&lt;/code&gt; 도 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e2b84c3cd64925b3bc63cc6da8970f088bb9f6ed" translate="yes" xml:space="preserve">
          <source>This function will be called when an exception is constructed. The user-supplied trace handler will be called if one has been supplied, otherwise no trace will be generated.</source>
          <target state="translated">이 함수는 예외가 구성 될 때 호출됩니다. 사용자 제공 추적 핸들러가 제공되면 호출되며, 그렇지 않으면 추적이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d78c169d84f9e0fc354575058eb3e604cfbfdad" translate="yes" xml:space="preserve">
          <source>This function will be called with elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">이 함수는 반복이 진행됨 에 &lt;code&gt;inputRange&lt;/code&gt; 점진적으로 inputRange 요소와 함께 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="68ba6b0b259ab19a35f9197082fe2ab6d70f5d70" translate="yes" xml:space="preserve">
          <source>This function will generate a module called &lt;code&gt;__entrypoint&lt;/code&gt;, and set the globals &lt;code&gt;entrypoint&lt;/code&gt; and &lt;code&gt;rootHasMain&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;__entrypoint&lt;/code&gt; 라는 모듈을 생성 하고 전역 &lt;code&gt;entrypoint&lt;/code&gt; 및 &lt;code&gt;rootHasMain&lt;/code&gt; 을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dc2b9580fcf2b39177541158722d4ae408a87a59" translate="yes" xml:space="preserve">
          <source>This function works by splitting the range to be reduced into work units, which are slices to be reduced in parallel. Once the results from all work units are computed, a final serial reduction is performed on these results to compute the final answer. Therefore, care must be taken to choose the seed value appropriately.</source>
          <target state="translated">이 기능은 축소 할 범위를 작업 단위로 분할하여 작동하며 슬라이스는 병렬로 축소됩니다. 모든 작업 단위의 결과가 계산되면이 결과에 대한 최종 연속 축소가 수행되어 최종 답변을 계산합니다. 따라서 시드 값을 적절히 선택하도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="85b846fd97be25d80f095623caef21705cf01c55" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;, unless the style option is used.</source>
          <target state="translated">이 함수는 style 옵션이 사용되지 않는 한 &lt;code&gt;defaultGetoptPrinter&lt;/code&gt; 함수의 문서에 설명 된 방식으로 전달 된 텍스트 및 &lt;code&gt;Option&lt;/code&gt; 을 출력 범위에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d3aad905401dc04f581b2c6077d97923bbd2a8dd" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;.</source>
          <target state="translated">이 함수는 전달 된 텍스트 및 &lt;code&gt;Option&lt;/code&gt; 을 &lt;code&gt;defaultGetoptPrinter&lt;/code&gt; 함수의 문서에 설명 된 방식으로 출력 범위에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="055b5453fa39d56b283008b9edaf05dd119fac56" translate="yes" xml:space="preserve">
          <source>This functions is equivalent to &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3de8acad7b682bb3660ea91b4edba8b390f1f531" translate="yes" xml:space="preserve">
          <source>This functions is used at runtime to determine if a &lt;code&gt;LogLevel&lt;/code&gt; is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</source>
          <target state="translated">이 기능은 런타임에 &lt;code&gt;LogLevel&lt;/code&gt; 이 활성화 되어 있는지 확인하는 데 사용됩니다 . 이전에 정의 된 것과 동일한 버전 설명을 사용하여 특정 수준을 비활성화합니다. 버전 문은 다시 컴파일 단위와 연관되므로 다른 컴파일 단위에서 로깅을 사용 불가능하게 할 수 없습니다. 순수한 bool isLoggingEnabled () (LogLevel ll) @safe nothrow @nogc</target>
        </trans-unit>
        <trans-unit id="9f907426d2ef951648d87f5cd993e54c9a2f733d" translate="yes" xml:space="preserve">
          <source>This functions returns a trace handler, allowing to inspect the current stack trace.</source>
          <target state="translated">이 함수는 트레이스 핸들러를 반환하여 현재 스택 트레이스를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84eb391f18a28223816cf561bff30465c4000886" translate="yes" xml:space="preserve">
          <source>This gets replaced by the number of local bytes in the local stack frame. It is most handy when the &lt;code&gt;naked&lt;/code&gt; is invoked and a custom stack frame is programmed.</source>
          <target state="translated">이것은 로컬 스택 프레임의 로컬 바이트 수로 대체됩니다. &lt;code&gt;naked&lt;/code&gt; 가 호출되고 사용자 지정 스택 프레임이 프로그래밍 된 경우 가장 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="e8e4bebddf13552333bc85ebe7b11a4e7247c831" translate="yes" xml:space="preserve">
          <source>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; with the same value as &lt;a href=&quot;#Pid.processID&quot;&gt;&lt;code&gt;Pid.processID&lt;/code&gt;&lt;/a&gt;, while on Windows it returns a &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt;.</source>
          <target state="translated">이 핸들은 OS 별 API에서 프로세스를 지정하는 데 사용됩니다. POSIX에서,이 함수는 반환 &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; 와 같은 값으로 &lt;a href=&quot;#Pid.processID&quot;&gt; &lt;code&gt;Pid.processID&lt;/code&gt; 를&lt;/a&gt; 윈도우에이 반환하면서, &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="33c852a0522cad2c2b4928299e850452d227ef5f" translate="yes" xml:space="preserve">
          <source>This handler overrides any legacy module unit tester set by the moduleUnitTester property.</source>
          <target state="translated">이 핸들러는 moduleUnitTester 특성으로 설정된 모든 레거시 모듈 단위 테스터를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c35e1bd5e0e6a04521fa5520ade57041fbf6240b" translate="yes" xml:space="preserve">
          <source>This hasher is compatible with the &lt;code&gt;Digest&lt;/code&gt; API:</source>
          <target state="translated">이 hasher는 &lt;code&gt;Digest&lt;/code&gt; API 와 호환됩니다 :</target>
        </trans-unit>
        <trans-unit id="3993e1a9197061dc1bf704959d048cb51b8578f3" translate="yes" xml:space="preserve">
          <source>This implements a standard critical section.</source>
          <target state="translated">이것은 표준 임계 섹션을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e2f62226ce4de7b0f3cba225bd19bb063907d826" translate="yes" xml:space="preserve">
          <source>This initialization is done before any constructors are called.</source>
          <target state="translated">이 초기화는 생성자가 호출되기 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9f56ef2bea3abd9b78b212cb634ac700d5b66a" translate="yes" xml:space="preserve">
          <source>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</source>
          <target state="translated">이 인스턴스에는 이름을 관리하기위한 식별자가 필요합니다. 템플리트 선언 이름을 가져 와서 형식 서명을 추가하여 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="912f09d79c05dc09ba32bc17497f7cccd43f92de" translate="yes" xml:space="preserve">
          <source>This is a D version 2 compiler</source>
          <target state="translated">이것은 D 버전 2 컴파일러입니다</target>
        </trans-unit>
        <trans-unit id="e5c32108063ea48a95f2ccade44899e02af1ccaa" translate="yes" xml:space="preserve">
          <source>This is a best-effort implementation of &lt;code&gt;length&lt;/code&gt; for any kind of range.</source>
          <target state="translated">이것은 모든 종류의 범위에 대한 최선의 노력의 &lt;code&gt;length&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="05c823d62e8c286f879871b1e12c6f9007211866" translate="yes" xml:space="preserve">
          <source>This is a compiler magic function - it doesn't behave like regular D functions.</source>
          <target state="translated">이것은 컴파일러의 마술 함수입니다. 일반적인 D 함수처럼 동작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b09964b15b26c39a9ce61274e2f775777d6323e9" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC32 implementation.</source>
          <target state="translated">이것은 CRC32 구현을 사용하는 &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt; 의 편의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="512068cf15e63810e132140770d7648100089a8e" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ECMA implementation.</source>
          <target state="translated">이것은의 편의를 별명이다 &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt; CRC64-ECMA 구현을 사용.</target>
        </trans-unit>
        <trans-unit id="b3d4ec4ec88de63e322958e6b0d979a689b11d53" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the MD5 implementation.</source>
          <target state="translated">MD5 구현을 사용하는 &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt; 의 편의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="bd636dcefd273f520355be9a0afa2783ad66dbef" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the RIPEMD160 implementation.</source>
          <target state="translated">RIPEMD160 구현을 사용하는 &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt; 의 편의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="29b73ef07a42490f2884582abd8be259990a85c2" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ISO implementation.</source>
          <target state="translated">이것은의 편의를 별명이다 &lt;a href=&quot;std_digest_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest.digest&lt;/code&gt; &lt;/a&gt; CRC64-ISO 구현을 사용.</target>
        </trans-unit>
        <trans-unit id="69463742eb10b8885c85b63b60e71b70ccfdbb6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function similar to &lt;a href=&quot;#digest&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt;, but it returns the string representation of the hash. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">이것은 &lt;a href=&quot;#digest&quot;&gt; &lt;code&gt;digest&lt;/code&gt; &lt;/a&gt; 와 비슷한 편리한 함수 이지만 해시의 문자열 표현을 반환합니다. &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; 테스트를 통과 한 모든 다이제스트를 이 기능과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d797c320e5f08f4ede0b091329f09c40bcd4c23b" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate a hash using the template API. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">템플릿 API를 사용하여 해시를 계산하는 편리한 함수입니다. &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; 테스트를 통과 한 모든 다이제스트를 이 기능과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b7feb30ef91eb966259d553831f946792e76d5" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate the hash of a value using the OOP API.</source>
          <target state="translated">OOP API를 사용하여 값의 해시를 계산하는 편리한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3fbe8b98c7fb42d7985a89e6cebbca4b22e50702" translate="yes" xml:space="preserve">
          <source>This is a convenience function which returns an initialized digest, so it's not necessary to call start manually.</source>
          <target state="translated">초기화 된 다이제스트를 반환하는 편리한 함수이므로 수동으로 start를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b07fdbfd8e90c114315c0c22212b8f6590899cf6" translate="yes" xml:space="preserve">
          <source>This is a dmd specific setting.</source>
          <target state="translated">이것은 dmd 특정 설정입니다.</target>
        </trans-unit>
        <trans-unit id="87a04bae60dfddd5f321bbf38e370a4d6f98d8c6" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="translated">이것은 카테고리별로 중첩 된 특정 헬퍼와 ​​함께 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 를 통해 액세스 할 수있는 유니 코드 특성의 전체 목록입니다 . 특정 세트의 내용 이 &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;확실하지 않은&lt;/a&gt; 경우 CLDR 유틸리티를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6d2aea77104c57ced3c43790bb2428921b1bca8" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;https://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8f19a42bba7727a8ce8284636a08320c4e65f1" translate="yes" xml:space="preserve">
          <source>This is a general replacement tool that construct a new string by replacing matches of pattern &lt;code&gt;re&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor &lt;code&gt;fun&lt;/code&gt; that returns a new string to use as replacement.</source>
          <target state="translated">이것은 &lt;code&gt;input&lt;/code&gt; 에서 패턴 &lt;code&gt;re&lt;/code&gt; 의 일치를 대체하여 새 문자열을 구성하는 일반적인 대체 도구입니다 . 다른 오버로드와 달리 형식 문자열은 대신 캡처가 사용자 정의 functor &lt;code&gt;fun&lt;/code&gt; 로 전달 되어 대체로 사용할 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48a52f467fdd89c347f6d4a8f50f81ff656d5562" translate="yes" xml:space="preserve">
          <source>This is a great way to implement simple circular buffers.</source>
          <target state="translated">이것은 간단한 순환 버퍼를 구현하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="02adbf08da9a4c46841118c88fd0ba75eb2c489f" translate="yes" xml:space="preserve">
          <source>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules:</source>
          <target state="translated">이것은 UUID 생성자에서 사용되는 파서에 비해 덜 엄격한 파서입니다. 다음 규칙을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="ecac55bd6998bb669ca8527fad92e747f31aecf4" translate="yes" xml:space="preserve">
          <source>This is a low-level messaging API upon which more structured or restrictive APIs may be built. The general idea is that every messageable entity is represented by a common handle type called a Tid, which allows messages to be sent to logical threads that are executing in both the current process and in external processes using the same interface. This is an important aspect of scalability because it allows the components of a program to be spread across available resources with few to no changes to the actual implementation.</source>
          <target state="translated">이는보다 구조적이거나 제한적인 API를 구축 할 수있는 저수준 메시징 API입니다. 일반적으로 모든 메시지 가능 엔티티는 Tid라는 공통 핸들 유형으로 표시되므로 현재 인터페이스와 동일한 인터페이스를 사용하여 외부 프로세스에서 실행중인 논리 스레드로 메시지를 보낼 수 있습니다. 이는 실제 구현을 거의 또는 전혀 변경하지 않고도 프로그램의 구성 요소를 사용 가능한 리소스에 분산시킬 수 있기 때문에 확장 성의 중요한 측면입니다.</target>
        </trans-unit>
        <trans-unit id="c99b5a617247c271e1cb66e28acf2ff8127a04e2" translate="yes" xml:space="preserve">
          <source>This is a magic return code for the write callback that, when returned, will signal libcurl to pause receiving on the current transfer.</source>
          <target state="translated">이것은 쓰기 콜백에 대한 마술 리턴 코드이며, 리턴 될 때 libcurl이 현재 전송에서 수신을 중지하도록 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8a547f3bc057670af878d63b618663f30d9c888a" translate="yes" xml:space="preserve">
          <source>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid (negative) process ID.</source>
          <target state="translated">최소한 프로세스가 실행되는 동안 운영 체제에서 프로세스를 고유하게 식별하는 숫자입니다. &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 가 호출 되면 이 메소드는 유효하지 않은 (음수) 프로세스 ID를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ba143cb17d230b35dd3e77b4d46b42bf59cd667" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="translated">이것은 Boost 프로젝트 의 &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt;boost.uuid&lt;/a&gt; 포트로, D와 같은 API를 위해 약간의 추가 및 API 변경이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8b81f289573312616e1ec9878dc693193c87264" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;https://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3639c2b895158186c93cfc3d4a942fd3a8a4bcfc" translate="yes" xml:space="preserve">
          <source>This is a public domain version of qsort.d. All it does is call C's qsort().</source>
          <target state="translated">이것은 qsort.d의 공개 도메인 버전입니다. C의 qsort ()를 호출하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2506c523fc3fb4d236735f105644ec414dfd3b6c" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will const signal libcurl to pause sending data on the current transfer.</source>
          <target state="translated">이것은 리턴 될 때 현재 전송에서 데이터 전송을 일시 중지하도록 신호 libcurl을 구성하는 읽기 콜백의 리턴 코드입니다.</target>
        </trans-unit>
        <trans-unit id="a5f3cb2b8bae68d0d790adf6bf0c62982e12ad3f" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will signal libcurl to immediately abort the current transfer.</source>
          <target state="translated">이것은 리턴 될 때 현재 전송을 즉시 중단하도록 libcurl에 신호를 보내는 읽기 콜백의 리턴 코드입니다.</target>
        </trans-unit>
        <trans-unit id="0df6a7dff27cb6ce3775bea09f58211a06e0fa4d" translate="yes" xml:space="preserve">
          <source>This is a shell around a back end symbol</source>
          <target state="translated">이것은 백엔드 심볼 주위의 쉘입니다</target>
        </trans-unit>
        <trans-unit id="dc048af9db69350bf7d515c9bc813c09c6660d30" translate="yes" xml:space="preserve">
          <source>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol.</source>
          <target state="translated">이것은 유형 또는 기호로 해석 될 수있는 TraitsExp를 포함하는 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="5ad2832faed57297a9408dcd8abe79e66f2c28ae" translate="yes" xml:space="preserve">
          <source>This is a simplified declaration of the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt;&lt;code&gt;NSString&lt;/code&gt;&lt;/a&gt; class. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; method allocates an instance of the class. The &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt;&lt;code&gt;initWithUTF8String:&lt;/code&gt;&lt;/a&gt; method will be used to convert a C string in UTF-8 to an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method is used to release an deallocate the string. Since D doesn't support &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; it's needed to manually release Objective-C instances.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;/a&gt; 클래스 의 단순화 된 선언입니다 . &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; 있어서, 상기 클래스의 인스턴스를 할당한다. &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt; &lt;code&gt;initWithUTF8String:&lt;/code&gt; &lt;/a&gt; 방법은 목표 - C 문자열로 UTF-8의 C 문자열을 변환하는 데 사용됩니다 &lt;code&gt;NSString&lt;/code&gt; . &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 방법은 할당을 취소에게 문자열을 해제하는 데 사용됩니다. D는 &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC를&lt;/a&gt; 지원하지 않기 때문에 Objective-C 인스턴스를 수동으로 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="fad6a93ca5b80ae2dfec457b0ce1d7b04f69cf3b" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has a few requirements, which all will be enforced by the compiler:</source>
          <target state="translated">이것은 컴파일러가 인식하는 특수한 속성으로, 몇 가지 요구 사항이 있으며 모두 컴파일러에 의해 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b885a66018a314237093b8fb5cb095cdbb3b8c2" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has several requirements, which all will be enforced by the compiler:</source>
          <target state="translated">이것은 특수한 컴파일러 인식 속성으로, 몇 가지 요구 사항이 있으며 모두 컴파일러에 의해 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae39fd6f553ae7cbf7dc06cf4c01bdb3470af4ef" translate="yes" xml:space="preserve">
          <source>This is a speed optimization, a good guess at the maximum size of the resulting buffer will improve performance by eliminating reallocations and copying.</source>
          <target state="translated">이것은 속도 최적화이며 결과 버퍼의 최대 크기를 잘 추측하면 재 할당 및 복사를 제거하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d1d3de86a677e769796c4bc667e5033e36cade" translate="yes" xml:space="preserve">
          <source>This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above.</source>
          <target state="translated">이것은 엄격한 파서입니다. 위의 패턴 만 허용합니다. 선행 또는 후행 문자는 지원하지 않습니다. 16 진수에 사용되는 문자 만 허용하며 문자열에는 위와 같은 하이픈이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5ae5fdcefc9284313dd41ba3b8a3e36e9a73a45c" translate="yes" xml:space="preserve">
          <source>This is a subclass of ElementParser. Most of the useful functions are documented there.</source>
          <target state="translated">이것은 ElementParser의 서브 클래스입니다. 유용한 기능은 대부분 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e662785d1d5993dfe200ed0cd32d243953366c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic algorithms that implement set operations.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 여기에는 집합 연산을 구현하는 일반 알고리즘이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b41f495bf4c79d2ddcbf0100179c8d893eed73" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic comparison algorithms.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 일반적인 비교 알고리즘이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5ed9bdf36ce4d3eb2f4fa31e710341bfe1a347" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic iteration algorithms.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 일반적인 반복 알고리즘을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a1ca49a48babc2bf7a88dc2f9edada29da0b74aa" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic mutation algorithms.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 그것은 일반적인 돌연변이 알고리즘을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9256c3179b28cb98f2ccafcbf01fa1114c7ffabd" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic searching algorithms.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 일반적인 검색 알고리즘이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d621cd2fb3907321fd3307426e0197b19ae1cd6c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic sorting algorithms.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 의 서브 모듈입니다 . 일반적인 정렬 알고리즘이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6a835a510bef24f9a4d09ad766e6b4789c5a10" translate="yes" xml:space="preserve">
          <source>This is accessible via the ClassData, but since it is frequently needed directly (like for rtti comparisons), make it directly accessible.</source>
          <target state="translated">이것은 ClassData를 통해 액세스 할 수 있지만 rtti 비교와 같이 자주 직접 필요하므로 직접 액세스 할 수있게하십시오.</target>
        </trans-unit>
        <trans-unit id="7c814acc56ca032045c3a40a509dc625dc91c4d4" translate="yes" xml:space="preserve">
          <source>This is actually what &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; does internally, so its usage is recommended if you want to process a complete file.</source>
          <target state="translated">이것은 실제로 &lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt; 이 내부적으로 수행하는 작업이므로 전체 파일을 처리하려는 경우 사용법을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="90cce6858fc6a3ac3c07d99643429177baeef347" translate="yes" xml:space="preserve">
          <source>This is also known as</source>
          <target state="translated">이것은 또한 알려진</target>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="d562af56401d0e00dc584df85564d362806b263a" translate="yes" xml:space="preserve">
          <source>This is an advanced type manipulation necessary e.g. for replacing the placeholder type &lt;code&gt;This&lt;/code&gt; in &lt;a href=&quot;std_variant#Algebraic&quot;&gt;&lt;code&gt;std.variant.Algebraic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;std_variant#Algebraic&quot;&gt; &lt;code&gt;std.variant.Algebraic&lt;/code&gt; &lt;/a&gt; 에서 플레이스 홀더 유형 &lt;code&gt;This&lt;/code&gt; 를 대체하는 데 필요한 고급 유형 조작 입니다.</target>
        </trans-unit>
        <trans-unit id="3325f1bf2305c77a1849c9f8a9c2843663095726" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt;, see there for more information.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="991e65c6e6968487ccb7bb69ca7320b94e4ca93f" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt;, see there for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4ce5ff6ecd05c751170313d80d40096c853a878" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt;, see there for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9558990a88eaad4533f53210d24e334b473686d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt;, see there for more information.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57c783fecd68424a831ee827a2afa820a6eb2e72" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt;, see there for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0181596da443b5ba169ba47d5e2dd20f026611e" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt;, see there for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt; 의 별명입니다 . 자세한 정보는 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d3c5e22d15f79f627e001b482acc6838518ff93" translate="yes" xml:space="preserve">
          <source>This is an example Scheduler that mirrors the default scheduling behavior of creating one kernel thread per call to spawn. It is fully functional and may be instantiated and used, but is not a necessary part of the default functioning of this module.</source>
          <target state="translated">이것은 스폰 호출마다 하나의 커널 스레드를 작성하는 기본 스케줄링 동작을 반영하는 스케줄러의 예입니다. 완전히 작동하며 인스턴스화되어 사용될 수 있지만이 모듈의 기본 기능에 필요한 부분은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6ff549d63c3ff212a46a7da946a73dffb4f080d9" translate="yes" xml:space="preserve">
          <source>This is an example scheduler that creates a new Fiber per call to spawn and multiplexes the execution of all fibers within the main thread.</source>
          <target state="translated">이것은 호출마다 새로운 파이버를 생성하고 메인 스레드 내의 모든 파이버의 실행을 다중화하는 스케줄러의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9b07c47f7921db818ae08b3487fd61d30861252d" translate="yes" xml:space="preserve">
          <source>This is an infinite range, so it is never empty.</source>
          <target state="translated">이 범위는 무한하므로 절대로 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12f3a1e35d9244804e6a51ca5a2db8f208c379f7" translate="yes" xml:space="preserve">
          <source>This is an interface to the libcurl library.</source>
          <target state="translated">이것은 libcurl 라이브러리에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0ecf41c17b4ddd40e8365245329f080912127dd4" translate="yes" xml:space="preserve">
          <source>This is an overload of &lt;code&gt;translate&lt;/code&gt; which takes an existing buffer to write the contents to.</source>
          <target state="translated">기존 버퍼를 사용하여 내용을 쓰는 &lt;code&gt;translate&lt;/code&gt; 의 오버로드입니다 .</target>
        </trans-unit>
        <trans-unit id="1ecb65db27289cae51fc17448747e90751d9751d" translate="yes" xml:space="preserve">
          <source>This is by design. During construction the &lt;code&gt;Variant&lt;/code&gt; needs static type information about the type being held, so as to store a pointer to function for fast retrieval.</source>
          <target state="translated">이것은 의도적으로 설계된 동작입니다. 구성하는 동안 &lt;code&gt;Variant&lt;/code&gt; 는 보유중인 유형에 대한 정적 유형 정보가 필요하므로 빠른 검색을 위해 포인터를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="60ab54d413619310ad332327e4504502f2306f23" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.compare(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">이것은 TypeInfo.compare (p1, p2)에 의해 호출됩니다. 구조체가 const 객체 비교를 지원하지 않으면 런타임에서 &quot;구현되지 않음&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c89ac618e64974e5137c2fd8360adb505768057f" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.equals(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">이것은 TypeInfo.equals (p1, p2)에 의해 호출됩니다. 구조체가 const 객체 비교를 지원하지 않으면 런타임에서 &quot;구현되지 않음&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="165808d159b6f286bb50d6195dc7d22725a89812" translate="yes" xml:space="preserve">
          <source>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</source>
          <target state="translated">삭제되는 값이 소멸자가있는 구조체에 대한 포인터이지만 과부하 된 삭제 연산자가없는 삭제 명령문에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="15901451d4d385b73b656d146d0381611e4eadbc" translate="yes" xml:space="preserve">
          <source>This is collectively called an</source>
          <target state="translated">이를 통칭하여</target>
        </trans-unit>
        <trans-unit id="d0a5f292f669550cd589beb4131f8032cf765ed1" translate="yes" xml:space="preserve">
          <source>This is defined to be in exactly the reverse order of static construction. Static destructors for individual modules will only be run if the corresponding static constructor successfully completed.</source>
          <target state="translated">이것은 정적 생성의 역순으로 정의됩니다. 개별 모듈의 정적 소멸자는 해당 정적 생성자가 성공적으로 완료된 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="252a57647acdf0a645523b6daf74e75444387572" translate="yes" xml:space="preserve">
          <source>This is designed for efficient memory reuse with some value-semantics structs, eg. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt;&lt;code&gt;std.bigint.BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 예를 들어 몇 가지 가치-시맨틱 구조체와 함께 효율적인 메모리 재사용을 위해 설계되었습니다. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt; &lt;code&gt;std.bigint.BigInt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06ae0b36fee3b8fd0ea0e39cba211a57066e0aad" translate="yes" xml:space="preserve">
          <source>This is done by matching the C compiler's data types, layouts, and function call/return sequences.</source>
          <target state="translated">이는 C 컴파일러의 데이터 유형, 레이아웃 및 함수 호출 / 반환 시퀀스를 일치시켜 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="11029a896ea23a30143fb56e21fe3c178f1a4a41" translate="yes" xml:space="preserve">
          <source>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out.</source>
          <target state="translated">이는 실제 유형 이름을 철자 할 수없는 일반 코드의 유형에 속성을 추가하거나 제거 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b13063fd35605a68f66f22b807caf15b21927ce2" translate="yes" xml:space="preserve">
          <source>This is especially useful when used with inheritance. For example, you might want to implement a final base method which returns a derived class type. Typically you would return a base type, but this won't allow you to call or access derived properties of the type:</source>
          <target state="translated">상속과 함께 사용할 때 특히 유용합니다. 예를 들어 파생 클래스 유형을 반환하는 최종 기본 메서드를 구현할 수 있습니다. 일반적으로 기본 유형을 반환하지만 유형의 파생 속성을 호출하거나 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="33a5219de6733b72248cb459ae3c108de0b27b6d" translate="yes" xml:space="preserve">
          <source>This is for cases where you need a value representing the OS at runtime. If you're doing something which should compile differently on different OSes, then please use &lt;code&gt;version (Windows)&lt;/code&gt;, &lt;code&gt;version (linux)&lt;/code&gt;, etc.</source>
          <target state="translated">런타임시 OS를 나타내는 값이 필요한 경우에 해당합니다. 다른 OS에서 다르게 컴파일 해야하는 작업을 수행하는 경우 &lt;code&gt;version (Windows)&lt;/code&gt; , &lt;code&gt;version (linux)&lt;/code&gt; 등을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9085623d5748a41a60ced02ac9ea7374a5eb5654" translate="yes" xml:space="preserve">
          <source>This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's &lt;code&gt;ticks&lt;/code&gt; property and keep all calculations in ticks rather than using &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 괜찮으며 본질적으로 시스템 틱에서 초 단위 (hnsecs, nsecs 등)로 변환하면 반올림 오류가 발생하지만 코드가 변환으로 인해 발생한 작은 반올림 오류를 피해야하는 경우 MonoTime의 &lt;code&gt;ticks&lt;/code&gt; 속성을 사용하고 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; 을&lt;/a&gt; 사용하는 대신 모든 계산을 틱으로 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88fe60e9205a837e1c893e74b0d472fd048224ed" translate="yes" xml:space="preserve">
          <source>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</source>
          <target state="translated">이것은 일반적으로 부동 소수점 숫자를 정수로 변환하는 가장 빠른 방법입니다. 이 함수의 결과는 x의 소수 부분이 정확히 0.5 인 경우 반올림 모드에 따라 달라집니다. 기본 반올림 모드를 사용하는 경우 (정수로 반올림) lrint (4.5) == 4, lrint (5.5) == 6.</target>
        </trans-unit>
        <trans-unit id="f53ca66b2923ca36935e7ce2bb35685de87690d9" translate="yes" xml:space="preserve">
          <source>This is intended for cases where you need to deal with endianness at runtime. If you're doing something which should compile differently depending on whether you're compiling on a big endian or little endian machine, then please use &lt;code&gt;version (BigEndian)&lt;/code&gt; and &lt;code&gt;version (LittleEndian)&lt;/code&gt;.</source>
          <target state="translated">런타임에 엔디안을 처리해야하는 경우를위한 것입니다. 빅 엔디안 또는 리틀 엔디안 컴퓨터에서 컴파일하는지에 따라 다르게 컴파일 해야하는 작업을 수행하는 경우 &lt;code&gt;version (BigEndian)&lt;/code&gt; 및 &lt;code&gt;version (LittleEndian)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b3b92fb9499542d848207397387795d022c0de6" translate="yes" xml:space="preserve">
          <source>This is intended to be called at the start of the program to yield all scheduling to the active Scheduler instance. This is necessary for schedulers that explicitly dispatch threads rather than simply relying on the operating system to do so, and so start should always be called within main() to begin normal program execution.</source>
          <target state="translated">프로그램 시작시 호출되어 활성 스케줄러 인스턴스에 대한 모든 스케줄링을 생성합니다. 이것은 단순히 운영 체제에 의존하지 않고 스레드를 명시 적으로 디스패치하는 스케줄러에 필요하므로 정상적인 프로그램 실행을 시작하려면 항상 main () 내에서 start를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="168edfe34c09b55f1deed4c37990e3c71a1ca3c1" translate="yes" xml:space="preserve">
          <source>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</source>
          <target state="translated">이것은 조금씩 채워진 비트 세트에서 각 비트를 테스트하는 것보다 효율적입니다. 비트 세트의 첫 번째 비트는 비트 0입니다.</target>
        </trans-unit>
        <trans-unit id="8fcde002524d5c331c8548b6dca27a95656e7bce" translate="yes" xml:space="preserve">
          <source>This is most handy when the array indices are given by enums:</source>
          <target state="translated">배열 인덱스가 열거 형으로 제공 될 때 가장 편리합니다.</target>
        </trans-unit>
        <trans-unit id="c31ac80c96aa26f46ec6ee9192e9e74924da45e0" translate="yes" xml:space="preserve">
          <source>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</source>
          <target state="translated">AssignExp가 CommaExp를 다시 쓰므로 더 이상 사용되지 않아야하므로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e7738cc186f07169467da57ea636fc910ff8ff41" translate="yes" xml:space="preserve">
          <source>This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</source>
          <target state="translated">이것은 재귀 적이 지 않습니다. 중첩 된 구조체 나 공용체와 같은 기호 내의 기호는 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79018f9004b6204ff482d1449a187f60021b161a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;takeWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">다른 언어의 &lt;code&gt;takeWhile&lt;/code&gt; 과 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="da1506be46b53535dcad92fb4d88063b66606cfa" translate="yes" xml:space="preserve">
          <source>This is so we can slice a TypeTuple</source>
          <target state="translated">이렇게하면 TypeTuple을 슬라이스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1ea183190e1a8d4a5c65894e3d7aa69b999c8015" translate="yes" xml:space="preserve">
          <source>This is the D way, and is used consistently in the D runtime library and examples.</source>
          <target state="translated">이것은 D 방식이며 D 런타임 라이브러리 및 예제에서 일관되게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b87f9cb349c407cc69c74e007c81d9397e42baeb" translate="yes" xml:space="preserve">
          <source>This is the FILE * or void * the regular output should be written to.</source>
          <target state="translated">이것은 일반 출력을 기록해야하는 FILE * 또는 void *입니다.</target>
        </trans-unit>
        <trans-unit id="e03f57cd49f977fe295ada31586860acb7b55e0d" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the socket callback</source>
          <target state="translated">소켓 콜백에 전달되는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="be469fab3c85ca74b768977fadfadf33a82814bf" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the timer callback</source>
          <target state="translated">타이머 콜백에 전달되는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="47d1ba0ce023e632a01bb533e80836298674478a" translate="yes" xml:space="preserve">
          <source>This is the date and time when the full source package was created. The timestamp is not stored in git, as the timestamp is properly set in the tarballs by the maketgz script.</source>
          <target state="translated">전체 소스 패키지가 작성된 날짜 및 시간입니다. 타임 스탬프는 maketgz 스크립트에 의해 타르볼에서 올바르게 설정되므로 타임 스탬프는 git에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcb4b4d07cd24ad03f4d73cf2a834d60bf057434" translate="yes" xml:space="preserve">
          <source>This is the global package copyright</source>
          <target state="translated">이것은 글로벌 패키지 저작권입니다</target>
        </trans-unit>
        <trans-unit id="00bd1884cd8f1f3700cdc8b2d576c08ba85d63de" translate="yes" xml:space="preserve">
          <source>This is the length in bytes of the hash value which is returned by &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;. It's also the required size of a buffer passed to &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 해시 값의 길이 (바이트)입니다 . 또한 &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; 에&lt;/a&gt; 전달 된 버퍼의 필수 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="629c1787bf8dac085ebe6f000afbc79766608202" translate="yes" xml:space="preserve">
          <source>This is the most specific allocation policy: the memory being allocated is thread local, has no indirections at all, and will not be reallocated. Examples of types fitting this description: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">이것은 가장 구체적인 할당 정책입니다. 할당되는 메모리는 스레드 로컬이며, 간접적 인 지시가 없으며 재 할당되지 않습니다. 이 설명을 맞는 유형의 예 : &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)&lt;/code&gt; ,하지만 &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 간접 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d53bdfa25144b5efcd12699a648c0b943568037" translate="yes" xml:space="preserve">
          <source>This is the numeric version of the libcurl version number, meant for easier parsing and comparions by programs. The LIBCURL_VERSION_NUM define will always follow this syntax:</source>
          <target state="translated">이것은 libcurl 버전 번호의 숫자 버전으로, 프로그램별로 쉽게 구문 분석하고 비교할 수 있습니다. LIBCURL_VERSION_NUM 정의는 항상 다음 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f516424ebe0c21d1c77be3938d4dc4c573211582" translate="yes" xml:space="preserve">
          <source>This is the old ctor sorting algorithm that does not find all cycles.</source>
          <target state="translated">이것은 모든 사이클을 찾지 못하는 오래된 ctor 정렬 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="0b9ca6f8eacc1a78a90edd54d83160d4086f02d3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on POSIX systems.</source>
          <target state="translated">이것은 POSIX 시스템에서는 불가능한 파일 생성 시간을 제공한다는 점을 제외하면 &lt;code&gt;getTimes&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6e92c9060948634b2691b12a3f666bd6c1016991" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on Posix systems.</source>
          <target state="translated">이것은 파일 작성 시간을 제공한다는 점을 제외하고 &lt;code&gt;getTimes&lt;/code&gt; 와 동일 합니다. Posix 시스템에서는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="d8bc2540cd8cdfdea3a8a5b982374faccf0dd6c1" translate="yes" xml:space="preserve">
          <source>This is the socket callback function pointer</source>
          <target state="translated">소켓 콜백 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="61598e1f6a7ec5d30e11d3aead7284998d0c4762" translate="yes" xml:space="preserve">
          <source>This is the timer callback function pointer</source>
          <target state="translated">타이머 콜백 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c718912a86bcbf8011f76f57098fa90f1498a69a" translate="yes" xml:space="preserve">
          <source>This is the version number of the libcurl package from which this header file origins:</source>
          <target state="translated">이 헤더 파일이 시작된 libcurl 패키지의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a98c5dbd73e5200bae0821dc0199531a02a94575" translate="yes" xml:space="preserve">
          <source>This is to support compiling expressions within the context of a function.</source>
          <target state="translated">이는 함수 컨텍스트 내에서 식 컴파일을 지원하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f258032a2e34908ad83c367bba4f67f9bf0d8fc" translate="yes" xml:space="preserve">
          <source>This is true even if the</source>
          <target state="translated">이 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="915f3d07336b61352341e4f59f1cdec1c322cabb" translate="yes" xml:space="preserve">
          <source>This is useful for:</source>
          <target state="translated">이것은 다음에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fcc8360025ee8f837157968edcf3a60c6d678ceb" translate="yes" xml:space="preserve">
          <source>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</source>
          <target state="translated">이것은 사용자가 알려진 문자열 세트 중 하나를 입력해야하는 경우에 유용하며, 고유 한 식별을 위해 충분한 문자를 입력하면 프로그램이 자동으로 문자열을 자동 완성합니다.</target>
        </trans-unit>
        <trans-unit id="e4e34d37acfaa90ff5c5cdca9c0444e2392c7b7c" translate="yes" xml:space="preserve">
          <source>This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location.</source>
          <target state="translated">이는 점포가 단순히 값을 쓰는 것 이외의 영향을 줄 수있는 저장소 또는 중간 저장소가없는 순차로드가 외부 저장소로 인해 같은 위치에서 다른 값을 검색 할 수있는 MMIO (memory-mapped I / O)를 처리 할 때 유용합니다. 위치</target>
        </trans-unit>
        <trans-unit id="130a13f443489357f62d68edb3556823f7774c09" translate="yes" xml:space="preserve">
          <source>This is usually the default diagnostic reporter.</source>
          <target state="translated">일반적으로 기본 진단 리포터입니다.</target>
        </trans-unit>
        <trans-unit id="6b8bd52c73d65472e04e60bf842e33bc426a473d" translate="yes" xml:space="preserve">
          <source>This is very useful as a template constraint (see examples)</source>
          <target state="translated">템플릿 제약 조건으로 매우 유용합니다 (예 참조).</target>
        </trans-unit>
        <trans-unit id="c9c38689ba29d74fc53f435aaf473866b312b836" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="translated">그러나 이것은 POSIX ' &lt;code&gt;execv*&lt;/code&gt; 와 동일하지 않습니다 . 우선, 실행 된 프로그램은 별도의 프로세스로 시작되며이 모든 것이 수반됩니다. 둘째, 다중 스레드 프로그램에서 현재 스레드가 하위 프로세스가 완료되기를 기다리는 동안 다른 스레드는 계속 작동합니다. 더 나은 옵션은 때때로 자식 프로세스를 생성 한 직후에 현재 프로그램을 종료하는 것입니다. 이것은 Microsoft의 C 런타임 라이브러리에서 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt; &lt;code&gt;__exec&lt;/code&gt; &lt;/a&gt; 함수 가 나타내는 동작이며, D에서 현재 사용되지 않는 Windows &lt;code&gt;execv*&lt;/code&gt; 함수가 작동하는 방식입니다. 예:</target>
        </trans-unit>
        <trans-unit id="11c3ec9d0243e9d96bbec3c005c414e3dafe476d" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cd963d96c400e127b41fb5e1c683fd1645332a" translate="yes" xml:space="preserve">
          <source>This level is used to display information about the program.</source>
          <target state="translated">이 레벨은 프로그램에 대한 정보를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7bd1213d23d1dea834726c3d604226e3f0bd7985" translate="yes" xml:space="preserve">
          <source>This library provides a mechanism whereby other modules may add &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for any other encoding.</source>
          <target state="translated">이 라이브러리는 다른 모듈이 다른 인코딩에 대해 &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; 서브 클래스를 추가 할 수있는 메커니즘을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a3c0ccf8cf8329e21b5b2e67a76439bedab69306" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="translated">이 라이브러리는 &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt; 에 따라 전체 레벨 1 지원 *을 제공합니다 . 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="7714a289de7bf8ef97b0cff4e1eea43fa7a50143" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;https://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4904626a5781bdaca7da93c6ed4103629917781b" translate="yes" xml:space="preserve">
          <source>This library supplies &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.</source>
          <target state="translated">이 라이브러리 용품 &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; ASCII 하위 클래스, ISO-8859-1, ISO-8859-2 (라틴-2), 윈도우 1250, 윈도우-1251 WINDOWS-1252, UTF-8, 및 (라틴-1이라고 함) (little-endian 아키텍처에서) UTF-16LE 및 UTF-32LE; 또는 (빅 엔디안 아키텍처에서) UTF-16BE 및 UTF-32BE.</target>
        </trans-unit>
        <trans-unit id="2ab23006d99b3e64b2eb41b8a2440b3e86ff5b16" translate="yes" xml:space="preserve">
          <source>This library uses a remarkably common ECMAScript syntax flavor with the following extensions:</source>
          <target state="translated">이 라이브러리는 다음과 같은 확장 기능으로 매우 일반적인 ECMAScript 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1d7d527b40f488b0b076be50f2a630625a4b71d6" translate="yes" xml:space="preserve">
          <source>This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="translated">이 라이브러리는 시작 태그가 발견 된 요소 내부를 구문 분석하거나 요소의 태그 속성 등을 식별하는 데 사용할 수있는 ElementHandler의 새 인스턴스를 함수에 제공합니다.이 함수는 둘 다에 대해 호출됩니다. 시작 태그와 빈 태그. 즉, &amp;lt;br&amp;gt; &amp;lt;/br&amp;gt;와 &amp;lt;br/&amp;gt;를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bcb738af6294ebb159f7ef50c2f4ed098badaa1" translate="yes" xml:space="preserve">
          <source>This macro below was added in 7.16.3 to push users who recompile to use the new curl_multi_socket_action() instead of the old curl_multi_socket()</source>
          <target state="translated">아래이 매크로는 7.16.3에서 추가되어 재 컴파일 된 사용자가 이전 curl_multi_socket () 대신 새로운 curl_multi_socket_action ()을 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="05317d0fb9b73229e7a4b236f6860aa4bc992df1" translate="yes" xml:space="preserve">
          <source>This makes the intent clearer, because the first statement can easily be misread as the following code:</source>
          <target state="translated">첫 번째 문장을 다음 코드와 같이 쉽게 읽을 수 없기 때문에 의도가 더 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="4d0a27a35faef1bf1f6ffad88638e7121e05700e" translate="yes" xml:space="preserve">
          <source>This means that pointers to elements of an &lt;code&gt;Array&lt;/code&gt; will become dangling as soon as the element is removed from the &lt;code&gt;Array&lt;/code&gt;. On the other hand the memory allocated by an &lt;code&gt;Array&lt;/code&gt; will be scanned by the GC and GC managed objects referenced from an &lt;code&gt;Array&lt;/code&gt; will be kept alive.</source>
          <target state="translated">이것은 요소가 &lt;code&gt;Array&lt;/code&gt; 에서 제거 되 자마자 &lt;code&gt;Array&lt;/code&gt; 요소에 대한 포인터 가 매달려 있는 것을 의미합니다 . 반면, &lt;code&gt;Array&lt;/code&gt; 에 의해 할당 된 메모리 는 GC에 의해 스캔되고 &lt;code&gt;Array&lt;/code&gt; 에서 참조 된 GC 관리 객체는 활성 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="604c9cc6344fc7f1b954e8b21d2a6ca0c3ac4133" translate="yes" xml:space="preserve">
          <source>This member holds all &lt;code&gt;Logger&lt;/code&gt;s stored in the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">이 멤버는 &lt;code&gt;MultiLogger&lt;/code&gt; 에 저장된 모든 &lt;code&gt;Logger&lt;/code&gt; 를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="2222d90d3dcd66aaa74b009940ed8d8638bced76" translate="yes" xml:space="preserve">
          <source>This memoizes all values of &lt;code&gt;fact&lt;/code&gt; up to the largest argument. To only cache the final result, move &lt;code&gt;memoize&lt;/code&gt; outside the function as shown below.</source>
          <target state="translated">이것은 &lt;code&gt;fact&lt;/code&gt; 모든 가치를 가장 큰 논거로 기억합니다. 최종 결과 만 캐시하려면 아래 그림과 같이 &lt;code&gt;memoize&lt;/code&gt; 기능 외부 로 이동 하십시오.</target>
        </trans-unit>
        <trans-unit id="3a167a300836fdd4ab2e0e008d931c833538789e" translate="yes" xml:space="preserve">
          <source>This method allows expansion within the respective bucket range. It succeeds if both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;b.length + delta&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;.</source>
          <target state="translated">이 방법을 사용하면 각 버킷 범위 내에서 확장 할 수 있습니다. &lt;code&gt;b.length&lt;/code&gt; 와 &lt;code&gt;b.length + delta&lt;/code&gt; 가 모두 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 형식으로 범위 가되면 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="4461edb18d36faaf19bc846025f3b95c67801b6c" translate="yes" xml:space="preserve">
          <source>This method allows forwarding log entries from one logger to another.</source>
          <target state="translated">이 방법을 사용하면 한 로거에서 다른 로거로 로그 항목을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3816a6346828017f335a6081c798a8a0dd6de4dd" translate="yes" xml:space="preserve">
          <source>This method allows reallocation within the respective bucket range. If both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;, then reallocation is in place. Otherwise, reallocation with moving is attempted.</source>
          <target state="translated">이 방법을 사용하면 각 버킷 범위 내에서 재 할당 할 수 있습니다. &lt;code&gt;b.length&lt;/code&gt; 와 &lt;code&gt;size&lt;/code&gt; 가 모두 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 형식으로 범위가 바뀌면 재 할당됩니다. 그렇지 않으면 이동하여 재 할당을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b9a458cd0b30230c45418803529ca936bac85057" translate="yes" xml:space="preserve">
          <source>This method can be more efficient than the one in the previous example because &lt;code&gt;stdin.readln(buf)&lt;/code&gt; reuses (if possible) memory allocated for &lt;code&gt;buf&lt;/code&gt;, whereas &lt;code&gt;line = stdin.readln()&lt;/code&gt; makes a new memory allocation for every line.  For even better performance you can help &lt;code&gt;readln&lt;/code&gt; by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by &lt;code&gt;readln&lt;/code&gt;:</source>
          <target state="translated">때문에이 방법은, 이전 예에서보다 더 효율적일 수 &lt;code&gt;stdin.readln(buf)&lt;/code&gt; 재 재사용 가능한 경우 메모리에 할당 &lt;code&gt;buf&lt;/code&gt; 반면, &lt;code&gt;line = stdin.readln()&lt;/code&gt; 모든 라인에 대한 새로운 메모리 할당한다. 더 나은 성능 을 위해 메모리 재 할당을 피하기 위해 큰 버퍼를 전달하여 &lt;code&gt;readln&lt;/code&gt; 을 도울 수 있습니다 . &lt;code&gt;readln&lt;/code&gt; 이 반환 한 가장 큰 버퍼를 재사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f7c9ac03db99dc39088ab7814b92a020b0c3ad1" translate="yes" xml:space="preserve">
          <source>This method inserts a new Logger into the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 새로운 Logger를 &lt;code&gt;MultiLogger&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="7e456631bd1026dc4c8384262111ee00c2ae6280" translate="yes" xml:space="preserve">
          <source>This method is defined if both allocators define it, and forwards to &lt;code&gt;SmallAllocator&lt;/code&gt; or &lt;code&gt;LargeAllocator&lt;/code&gt; appropriately.</source>
          <target state="translated">이 메소드는 두 할당자가 정의한 경우에 정의되고 &lt;code&gt;SmallAllocator&lt;/code&gt; 또는 &lt;code&gt;LargeAllocator&lt;/code&gt; 로 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c6c590b7cd5abdf60b16e55a89efa8f2694069" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it, and work similarly to &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 할당 자 중 하나 이상이 정의한 경우에만 정의되며 &lt;code&gt;reallocate&lt;/code&gt; 와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c403891dca13c06af654365809bbef8d64860536" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt;. If &lt;code&gt; LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 방법은 할당 자 중 하나 이상이 정의한 경우에만 정의됩니다. 경우 &lt;code&gt;SmallAllocator&lt;/code&gt; 의 정의가 &lt;code&gt;expand&lt;/code&gt; 및 &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt; , 호출이 전달됩니다 &lt;code&gt;SmallAllocator&lt;/code&gt; . 경우 &lt;code&gt; LargeAllocator&lt;/code&gt; 의 정의가 &lt;code&gt;expand&lt;/code&gt; 및 &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt; , 호출이 전달됩니다 &lt;code&gt;LargeAllocator&lt;/code&gt; . 그렇지 않으면 호출은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cc308051788a72be786da5419b09693d8595fa4d" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;reallocate&lt;/code&gt; and &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; SmallAllocator&lt;/code&gt;. If &lt;code&gt;LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 방법은 할당 자 중 하나 이상이 정의한 경우에만 정의됩니다. 경우 &lt;code&gt;SmallAllocator&lt;/code&gt; 을 정의 &lt;code&gt;reallocate&lt;/code&gt; 및 &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt; , 호출이 전달됩니다 &lt;code&gt; SmallAllocator&lt;/code&gt; . 경우 &lt;code&gt;LargeAllocator&lt;/code&gt; 의 정의가 &lt;code&gt;expand&lt;/code&gt; 및 &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt; , 통화가 전달됩니다 &lt;code&gt; LargeAllocator&lt;/code&gt; . 그렇지 않으면 호출은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="620e46438ddff127931a59ae1ef3a8f250fd07f0" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. The good allocation size is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise. (If one of the allocators does not define &lt;code&gt;goodAllocSize&lt;/code&gt;, the default implementation in this module applies.)</source>
          <target state="translated">이 방법은 할당 자 중 하나 이상이 정의한 경우에만 정의됩니다. 좋은 할당 크기로부터 얻어지는 &lt;code&gt;SmallAllocator&lt;/code&gt; 만약 &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt; 또는 &lt;code&gt;LargeAllocator&lt;/code&gt; 그렇지. 할당 자 중 하나가 &lt;code&gt;goodAllocSize&lt;/code&gt; 를 정의하지 않으면 이 모듈의 기본 구현이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d239e7b226a63994c92bb5f28f2af2cc148e0855" translate="yes" xml:space="preserve">
          <source>This method is defined only if both allocators define it. The call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt; LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">이 방법은 두 할당자가 모두 정의한 경우에만 정의됩니다. &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt; 이면 호출이 &lt;code&gt;SmallAllocator&lt;/code&gt; 로 전달되고 , 그렇지 않으면 &lt;code&gt; LargeAllocator&lt;/code&gt; 로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="b5f2a8f9e894a52f7a4a03fd41c115c5a28e5d48" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="translated">이 방법은 기본 범위가 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위 인&lt;/a&gt; 경우에만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8fd044a02e3e694fc797ffa7b6155202b89056a3" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;.</source>
          <target state="translated">이 방법은 기본 범위가 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위 인&lt;/a&gt; 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="832bf9b6aa94575865959f7e42866388acb50190" translate="yes" xml:space="preserve">
          <source>This method is only defined if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">경우이 방법은 정의 &lt;code&gt;Allocator&lt;/code&gt; 정의가 &lt;code&gt;deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d110cb43a292fbf904825bc3d4bb27446be41655" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; deallocateAll&lt;/code&gt;, and calls it for each bucket in turn. Returns &lt;code&gt;true&lt;/code&gt; if all allocators could deallocate all.</source>
          <target state="translated">이 메소드는 관련된 모든 할당자가 &lt;code&gt; deallocateAll&lt;/code&gt; 을 정의 하고 각 버킷에 대해 차례로 호출하는 경우에만 정의됩니다 . 모든 할당자가 모두 할당을 취소 할 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="39358dd310cc162f2c05e4b4ad0f8504cf1a91af" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; resolveInternalPointer&lt;/code&gt;, and tries it for each bucket in turn.</source>
          <target state="translated">이 메소드는 관련된 모든 할당 &lt;code&gt; resolveInternalPointer&lt;/code&gt; 정의 하고 각 버킷에 대해 차례로 시도하는 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dbdb0a556e3c7305bbb92177faa9a39d0b98a27" translate="yes" xml:space="preserve">
          <source>This method logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the this &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;printf&lt;/code&gt; 스타일 방식 으로이 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 사용 된 &lt;code&gt;Logger&lt;/code&gt; 에 데이터를 로깅합니다 .</target>
        </trans-unit>
        <trans-unit id="b6f8a28a408a1ebec1b43e9856020fe703ce80ce" translate="yes" xml:space="preserve">
          <source>This method logs data with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용 하여 데이터를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="3c1dde3d6319c6f9ff98c98c06a035679376bc16" translate="yes" xml:space="preserve">
          <source>This method removes a Logger from the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">이 방법은에서 로거 제거 &lt;code&gt;MultiLogger&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="2129521b769d915727dcb1e653df38210cfe3143" translate="yes" xml:space="preserve">
          <source>This method takes a &lt;code&gt;bool&lt;/code&gt; as first argument. In order for the data to be processed the &lt;code&gt;bool&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;LogLevel&lt;/code&gt; of the Logger must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">이 방법은 &lt;code&gt;bool&lt;/code&gt; 을 첫 번째 인수로 사용합니다. 데이터를 처리하려면 &lt;code&gt;bool&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 Logger 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0cb43593777a49c6e95ba5b0dcc72f45a57113c" translate="yes" xml:space="preserve">
          <source>This methods get and set the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 전역 &lt;code&gt;LogLevel&lt;/code&gt; 을 가져오고 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7803a9c22a232513790fa103468328fa0b2565b" translate="yes" xml:space="preserve">
          <source>This might affect your application if it has threads that are not suspended during the mark phase of the collection. You can configure the number of additional threads used for marking by GC option &lt;code&gt;parallel&lt;/code&gt;, e.g. by passing &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; on the command line or embedding the option into the binary via &lt;code&gt;rt_options&lt;/code&gt;. The number of threads actually created is limited to &lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt;&lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt;&lt;/a&gt;. A value of &lt;code&gt;0&lt;/code&gt; disables parallel marking completely.</source>
          <target state="translated">콜렉션의 마크 단계 중에 일시 중단되지 않은 스레드가있는 경우 애플리케이션에 영향을 줄 수 있습니다. 명령 행에서 &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; 를 전달 하거나 &lt;code&gt;rt_options&lt;/code&gt; 를 통해 옵션을 바이너리에 임베드하여 GC 옵션 &lt;code&gt;parallel&lt;/code&gt; 표시에 사용되는 추가 스레드 수를 구성 할 수 있습니다 . 실제로 작성된 스레드 수는 &lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt; &lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt; 로&lt;/a&gt; 제한됩니다 . 값이 &lt;code&gt;0&lt;/code&gt; 이면 병렬 표시가 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="abf107b5c6e2c3e95aef57b0f00ce4199d6e77e4" translate="yes" xml:space="preserve">
          <source>This module allows content to be iterated by record stored in a struct, class, associative array, or as a range of fields. Upon detection of an error an CSVException is thrown (can be disabled). csvNextToken has been made public to allow for attempted recovery.  Disabling exceptions will lift many restrictions specified above. A quote can appear in a field if the field was not quoted. If in a quoted field any quote by itself, not at the end of a field, will end processing for that field. The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">이 모듈을 사용하면 구조체, 클래스, 연관 배열 또는 필드 범위에 저장된 레코드로 내용을 반복 할 수 있습니다. 오류를 감지하면 CSVException이 발생합니다 (비활성화 할 수 있음). 복구 시도를 허용하기 위해 csvNextToken이 공개되었습니다. 예외를 비활성화하면 위에서 지정한 많은 제한이 해제됩니다. 필드가 인용되지 않은 경우 견적이 필드에 나타날 수 있습니다. 따옴표로 묶은 필드에 필드의 끝이 아닌 그 자체로 따옴표가 있으면 해당 필드에 대한 처리가 종료됩니다. 따옴표가 닫히지 않아도 입력이 없으면 필드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0c12be692d1a1b6196ff193f230f2b2b54e371d1" translate="yes" xml:space="preserve">
          <source>This module and its documentation are inspired by Perl's &lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt::Long&lt;/a&gt; module. The syntax of D's &lt;code&gt;getopt&lt;/code&gt; is simpler than its Perl counterpart because &lt;code&gt; getopt&lt;/code&gt; infers the expected parameter types from the static types of the passed-in pointers.</source>
          <target state="translated">이 모듈과 설명서는 Perl의 &lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt :: Long&lt;/a&gt; 모듈 에서 영감을 받았습니다 . D의 구문 &lt;code&gt;getopt&lt;/code&gt; 에는 자사의 펄 대응보다 간단하기 때문에 &lt;code&gt; getopt&lt;/code&gt; 는 추론한다 포인터 건네의 정적 유형에서 예상되는 매개 변수 유형.</target>
        </trans-unit>
        <trans-unit id="e9ef4feea1926afdb50fb401e193258058409682" translate="yes" xml:space="preserve">
          <source>This module and its documentation are inspired by Perl's &lt;a href=&quot;https://perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt::Long&lt;/a&gt; module. The syntax of D's &lt;code&gt;getopt&lt;/code&gt; is simpler than its Perl counterpart because &lt;code&gt; getopt&lt;/code&gt; infers the expected parameter types from the static types of the passed-in pointers.</source>
          <target state="translated">이 모듈과 설명서는 Perl의 &lt;a href=&quot;https://perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt :: Long&lt;/a&gt; 모듈 에서 영감을 받았습니다 . D의 구문 &lt;code&gt;getopt&lt;/code&gt; 에는 자사의 펄 대응보다 간단하기 때문에 &lt;code&gt; getopt&lt;/code&gt; 는 추론한다 포인터 건네의 정적 유형에서 예상되는 매개 변수 유형.</target>
        </trans-unit>
        <trans-unit id="7f09ec381e380d7513f44d1a9c117509cf562d32" translate="yes" xml:space="preserve">
          <source>This module centers around two functions:</source>
          <target state="translated">이 모듈은 두 가지 기능을 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="20c669a98c4868307d434ad05bfdc4a3a51a1300" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.  This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 에&lt;/a&gt; 정의 된 API를 준수합니다 . 이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a16008011138e31550b797755a77e5d03cd02e" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 에&lt;/a&gt; 정의 된 API를 준수합니다 . 템플릿과 OOP API의 차이점을 이해하려면 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17ae71bfaa531ddd2da20bee8e617777975ac653" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;code&gt;std.digest&lt;/code&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;std.digest&lt;/code&gt; 에 정의 된 API를 준수합니다 . 템플릿과 OOP API의 차이점을 이해하려면 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d23cc75f3120c33113ac064a49eabf3de54b0fa" translate="yes" xml:space="preserve">
          <source>This module consists of the following submodules:</source>
          <target state="translated">이 모듈은 다음과 같은 하위 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="acafb5c32c70d9aae6c63b01f760110057442f4d" translate="yes" xml:space="preserve">
          <source>This module contains UDA's (User Defined Attributes) either used in the runtime or special UDA's recognized by compiler.</source>
          <target state="translated">이 모듈에는 런타임에서 사용되는 UDA (사용자 정의 속성) 또는 컴파일러가 인식하는 특수 UDA가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="85899b400fb24fe82d032611b825cbfb9b44e4d4" translate="yes" xml:space="preserve">
          <source>This module contains a collection of bit-level operations.</source>
          <target state="translated">이 모듈에는 비트 수준 작업 모음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1389c215e1a5264fea083894c94780e9d38b766" translate="yes" xml:space="preserve">
          <source>This module contains all functions related to an object's lifetime: allocation, resizing, deallocation, and finalization.</source>
          <target state="translated">이 모듈에는 개체 수명과 관련된 모든 기능 (할당, 크기 조정, 할당 해제 및 마무리)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e22ee3bb8cbf087613e536d6224ea16946bb6a9" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt;&lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt; &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0790e73d68257f0feac07da73031d54a40efb1ec" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt;&lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt; &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e99994de35a20a0e314dc2374362a82960544" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b921fc7078621d7eaa8b76c016bec3d37b2ea8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt;&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt; &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3184aa12179289bb1bc9cc36d8ce4348bfa946fe" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt;&lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt; &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb2c62940c679e140d89cb9017957cd6a4ba64f" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt;&lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt; &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e3f25e60216c815c395312071e29f7c8ca0ddd" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt;&lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt; &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f313b0f4d7c80470b377169af784edeeb810ec9d" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt;&lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt; &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889ac9c43694fc79bd24e61dceed4e6fda688b35" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt;&lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt; &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bd014e9d5a4fdbad34dcb7fb8420e937c0abc85" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt;&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt; &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc16180c80d567a16457d88550f7aa27a1b419aa" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt;&lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt; &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5971b6bf8e57282688ff4449029781d4b3a236d4" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b580515d9fbf0a4ef7b9e421dec5768897b813d8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt;&lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt; &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95281628a03db4872107318eb8c99b1bea13ccc2" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ba870a61bb5fb732f12f00ebdf0f6bdf33ab08" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d9cbc1fb19908d75c057b6e010d377eada4d77" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050d1037c01667ef5f3b8f67c4951211e12ccacf" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt; &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f549cd509c6cf2035fd5afdb0920eaa5d4d5e84e" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt;&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt; &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택된 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c64533f70dfc4fd8955bc0b3a2834ad07751af" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt;&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt; &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92aabdabf0e70387e5a38f4c231411efd14217e3" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt;&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt; &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec277ffc9998ff3f0f63d9eedcde3635f0eb758" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">이 모듈에는 표준 C 헤더 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 선택한 유형 및 함수에 대한 바인딩이 포함되어 있습니다 . 이것은 자동으로 생성되지 않으며 원래 C 헤더에서 일부 유형 / 기능을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eae2d8842b4a5ea2342a711443bdc99050523af" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt;&lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dab5b6e88da0ec5dcd72dc16ace81ec7be0ada5" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt;&lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc1bdadc9da2467042c1b3493dd4dc07108f360" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9128a5cd699680fcb8910390b43c01c23fb29f1" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt;&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd6d131f6f02253326969d26b8eede75514b4f3" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt;&lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84233284071209ba1c9c0efc3f3d25f463e7d1b" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt;&lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776522f2b97f6d4abf0a1c0f986b288411205cf0" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt;&lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17edef5e3cbf009109d7b6788701cfd154f3316a" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt;&lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e20e9c80af805bd36ee07aed01d66c879e74fd" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt;&lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5a7cbec3ecd930c9929700a5ece8e9c9e69074" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt;&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc6fb47652f74563782d674a7b26e2ce0358f04" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt;&lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f730bfd68a02ab588c2cffef30ced71ba897d70" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a61d11623697df2ea6eafa0cf8bfa1ee29d9fd5" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt;&lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f27c6f30da804fa319d8c7610a9d164b7089e" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710634fa53e750ed0677b53ce7c95ec5bc52f3d4" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8649e70ba087fe53dd99d1dd76924265f941bb3d" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2590fc42c6b1a888a25b33d9ee2d85767905016d" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81ff4d365ffcef47424b52cd4d07b88ca7eedc5" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt;&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c4397f7768c49beb27a4949e6a7e89807214b3" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt;&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75eab9bbb8acdf6899b67e74a2552289831559b7" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt;&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ff63de6e269e8bce59e79f5bfc11a4e39005e7" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4332c56ae7f44bffd58f114ac37e892a2b103dd8" translate="yes" xml:space="preserve">
          <source>This module contains compiler support determining equality of dynamic arrays.</source>
          <target state="translated">이 모듈에는 동적 배열의 동등성을 결정하는 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9409989c24e53c52350805b177653fd011bfa05" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for casting dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 캐스팅을위한 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98da9476138dd631b9aa80ca4972d86126ed52a1" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for comparing dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 비교를위한 컴파일러 지원이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="ea25ff08ceea8b6974ce0811b1a4d3c03f3a2b61" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for constructing dynamic arrays</source>
          <target state="translated">이 모듈에는 동적 배열 구성을위한 컴파일러 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="130d46533e13acaf0b0f736ae469ff9f68d6ff23" translate="yes" xml:space="preserve">
          <source>This module contains high-level interfaces for interacting with DMD as a library.</source>
          <target state="translated">이 모듈에는 라이브러리로서 DMD와 상호 작용하기위한 고급 인터페이스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df04f2ddca174e21d081429f9f3c53ebccb78b8" translate="yes" xml:space="preserve">
          <source>This module contains some common utilities used by containers.</source>
          <target state="translated">이 모듈에는 컨테이너가 사용하는 몇 가지 일반적인 유틸리티가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcac3a1b4da6941734058525116d97065268b549" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' appending</source>
          <target state="translated">이 모듈은 동적 배열의 추가 제어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c49eb9ff2d1c37482fee0bb60748312c2292f298" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' capacity and length</source>
          <target state="translated">이 모듈에는 동적 어레이의 용량 및 길이 제어 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a472e4841c397ed8a20c7da34116a395a9f78db" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' concatenation</source>
          <target state="translated">이 모듈은 동적 배열의 연결 제어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d58f6f902fb5917dee8fa5b768555a18fd9ff404" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;#Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; type, which is used to represent complex numbers, along with related mathematical operations and functions.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;#Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 유형과 관련 수학 연산 및 함수를 나타내는 데 사용되는 복소수 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cafe10d55f1a2961b685e59594325a88af3e24c" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;Id&lt;/code&gt; struct with a list of predefined symbols the compiler knows about.</source>
          <target state="translated">이 모듈에는 컴파일러가 알고있는 사전 정의 된 기호 목록이 있는 &lt;code&gt;Id&lt;/code&gt; 구조체가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99093b5cfdcc5707f50f9cafa8f212b7442853a6" translate="yes" xml:space="preserve">
          <source>This module contains utilities for TypeInfo implementation.</source>
          <target state="translated">이 모듈에는 TypeInfo 구현을위한 유틸리티가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a058b7e236eb5ab7c537629e84966c190eced743" translate="yes" xml:space="preserve">
          <source>This module contains utility functions to help the implementation of the runtime hook</source>
          <target state="translated">이 모듈에는 런타임 후크 구현을 돕는 유틸리티 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d6317f5849751724969636691ef1f8625b672f7" translate="yes" xml:space="preserve">
          <source>This module contains various string related functions.</source>
          <target state="translated">이 모듈에는 다양한 문자열 관련 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d02a1f1d4e42f0ca255a0d80699556c671a1024b" translate="yes" xml:space="preserve">
          <source>This module declares intrinsics for volatile operations.</source>
          <target state="translated">이 모듈은 휘발성 작업에 대한 내장 함수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="9a531226ad2342a85a7cda80bcc56003e90c7e5a" translate="yes" xml:space="preserve">
          <source>This module defines &lt;code&gt;TypedAllocator&lt;/code&gt;, a statically-typed allocator that aggregates multiple untyped allocators and uses them depending on the static properties of the types allocated. For example, distinct allocators may be used for thread-local vs. thread-shared data, or for fixed-size data (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt; objects) vs. resizable data (arrays).</source>
          <target state="translated">이 모듈은 유형이 지정되지 않은 여러 할당자를 집계하고 할당 된 유형의 정적 속성에 따라 사용하는 정적 유형 할당 &lt;code&gt;TypedAllocator&lt;/code&gt; 정의합니다 . 예를 들어, 별개의 할당자는 스레드 로컬 데이터와 스레드 공유 데이터 또는 고정 크기 데이터 ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; 객체)와 크기 조정 가능 데이터 (배열)에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="259e74bca77eb48b491beebe7a35554776cb2efb" translate="yes" xml:space="preserve">
          <source>This module defines a number of primitives that work with graphemes: &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decodeGrapheme&quot;&gt;&lt;code&gt;decodeGrapheme&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#graphemeStride&quot;&gt;&lt;code&gt;graphemeStride&lt;/code&gt;&lt;/a&gt;. All of them are using</source>
          <target state="translated">이 모듈은 프리미티브의 수를 정의하는 작업을 제자로 : &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decodeGrapheme&quot;&gt; &lt;code&gt;decodeGrapheme&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#graphemeStride&quot;&gt; &lt;code&gt;graphemeStride&lt;/code&gt; &lt;/a&gt; . 그들 모두가 사용하고 있습니다</target>
        </trans-unit>
        <trans-unit id="99bc02ede476ad853ab518e42294b5202a998289" translate="yes" xml:space="preserve">
          <source>This module defines facilities for efficient checking of integral operations against overflow, casting with loss of precision, unexpected change of sign, etc. The checking (and possibly correction) can be done at operation level, for example &lt;a href=&quot;#opChecked&quot;&gt;&lt;code&gt;opChecked&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; adds two integrals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and sets &lt;code&gt;overflow&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if an overflow occurred. The flag &lt;code&gt;overflow&lt;/code&gt; (a &lt;code&gt;bool&lt;/code&gt; passed by reference) is not touched if the operation succeeded, so the same flag can be reused for a sequence of operations and tested at the end.</source>
          <target state="translated">이 모듈은 오버플로에 대한 적분 연산의 효율적인 점검, 정밀도 손실로 인한 캐스팅, 예상치 못한 부호 변경 등의 기능을 정의합니다. 점검 (및 가능한 수정)은 조작 레벨에서 수행 될 수 있습니다 (예 : &lt;a href=&quot;#opChecked&quot;&gt; &lt;code&gt;opChecked&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; 는 두 개의 정수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 더하고 오버플로가 발생하면 &lt;code&gt;overflow&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정합니다 . 작업이 성공하면 플래그 &lt;code&gt;overflow&lt;/code&gt; ( 참조로 전달 된 &lt;code&gt;bool&lt;/code&gt; )는 건드리지 않으므로 동일한 플래그를 작업 시퀀스에 재사용하고 마지막에 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e33eb3468c635b3f1b1bf8d7ab1a84f24b11f39" translate="yes" xml:space="preserve">
          <source>This module defines functions related to exceptions and general error handling. It also defines functions intended to aid in unit testing.</source>
          <target state="translated">이 모듈은 예외 및 일반적인 오류 처리와 관련된 기능을 정의합니다. 또한 단위 테스트를 돕기위한 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2f439ece9b3ae412ebb6e407781c8a8d19e803e8" translate="yes" xml:space="preserve">
          <source>This module defines generic containers.</source>
          <target state="translated">이 모듈은 일반 컨테이너를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7716ef353856b8c8fdc336f0f551c1520abef4d6" translate="yes" xml:space="preserve">
          <source>This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as &lt;a href=&quot;std_algorithm_searching#find&quot;&gt;&lt;code&gt;std.algorithm.searching.find&lt;/code&gt;&lt;/a&gt; works not just for arrays, but for linked-lists, input files, incoming network data, etc.</source>
          <target state="translated">이 모듈은 범위의 개념을 정의합니다. 범위는 배열, 목록 또는 순차적 액세스와 관련된 모든 개념을 일반화합니다. 이러한 추상화를 통해 동일한 알고리즘 세트 ( &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 참조 )를 다양한 콘크리트 유형과 함께 사용할 수 있습니다. 예를 들어 &lt;a href=&quot;std_algorithm_searching#find&quot;&gt; &lt;code&gt;std.algorithm.searching.find&lt;/code&gt; &lt;/a&gt; 와 같은 선형 검색 알고리즘 은 배열뿐만 아니라 링크 된 목록, 입력 파일, 수신 네트워크 데이터 등에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c2b133a65c34666134047443b875c3c6bf1823e" translate="yes" xml:space="preserve">
          <source>This module describes the digest APIs used in Phobos. All digests follow these APIs. Additionally, this module contains useful helper methods which can be used with every digest type.</source>
          <target state="translated">이 모듈은 Phobos에서 사용되는 다이제스트 API를 설명합니다. 모든 다이제스트는이 API를 따릅니다. 또한이 모듈에는 모든 다이제스트 유형에 사용할 수있는 유용한 도우미 메서드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eac267b2bca3c4e62e74376d6d1858e8b30f305" translate="yes" xml:space="preserve">
          <source>This module extracts debug info from the currently running Mach-O executable.</source>
          <target state="translated">이 모듈은 현재 실행중인 Mach-O 실행 파일에서 디버그 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2b3bde835b97011d3a24374bdd792ad0a067b596" translate="yes" xml:space="preserve">
          <source>This module has two submodules:</source>
          <target state="translated">이 모듈에는 두 개의 하위 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c364d07bb94ddbade750564cb1b9de747e163c33" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;discriminated union&lt;/a&gt; type (a.k.a. &lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged union&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;algebraic type&lt;/a&gt;). Such types are useful for type-uniform binary interfaces, interfacing with scripting languages, and comfortable exploratory programming.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;구별 된 공용체&lt;/a&gt; 유형 (일명 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;태그 된 공용체&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;대수 형&lt;/a&gt; )을 구현합니다. 이러한 유형은 유형 균일 이진 인터페이스, 스크립팅 언어와의 인터페이스 및 편안한 탐색 프로그래밍에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9aaacdf0b609be68642fdd296a12c2e25e4bfd14" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;discriminated union&lt;/a&gt; type (a.k.a. &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged union&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;algebraic type&lt;/a&gt;). Such types are useful for type-uniform binary interfaces, interfacing with scripting languages, and comfortable exploratory programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf874427a131dcde8af3f16bcfbe7028972cb86" translate="yes" xml:space="preserve">
          <source>This module implements a generic doubly-linked list container. It can be used as a queue, dequeue or stack.</source>
          <target state="translated">이 모듈은 일반적인 이중 연결 목록 컨테이너를 구현합니다. 대기열, 대기열 제거 또는 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276f012505f8a462f31b45a6f4a35457a2d35dbc" translate="yes" xml:space="preserve">
          <source>This module implements a red-black tree container.</source>
          <target state="translated">이 모듈은 레드-블랙 트리 컨테이너를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7870ea3fc10596df955abb619b60da2851a384ad" translate="yes" xml:space="preserve">
          <source>This module implements a singly-linked list container. It can be used as a stack.</source>
          <target state="translated">이 모듈은 단일 링크 목록 컨테이너를 구현합니다. 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ec77e995992fa015630679195d60252ee43e89" translate="yes" xml:space="preserve">
          <source>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types.</source>
          <target state="translated">이 모듈은 다양한 유형 생성자, 즉 새롭고 유용한 범용 유형을 생성 할 수있는 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="64f274b864d84b8337845eb1c9cfcbc24ac5038e" translate="yes" xml:space="preserve">
          <source>This module implements experimental additions/modifications to &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; 에&lt;/a&gt; 실험 추가 / 수정을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="eaa4498639b5fb5cabef3038967389ce127f79a8" translate="yes" xml:space="preserve">
          <source>This module implements integral arithmetic primitives that check for out-of-range results.</source>
          <target state="translated">이 모듈은 범위를 벗어난 결과를 확인하는 필수 산술 프리미티브를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="19bff9c3e2a27e1a7382004762c10f34a531050a" translate="yes" xml:space="preserve">
          <source>This module implements the formatting functionality for strings and I/O. It's comparable to C99's &lt;code&gt;vsprintf()&lt;/code&gt; and uses a similar format encoding scheme.</source>
          <target state="translated">이 모듈은 문자열 및 I / O의 형식화 기능을 구현합니다. C99의 &lt;code&gt;vsprintf()&lt;/code&gt; 와 비슷하며 유사한 형식 인코딩 체계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c014fbea053ad61d3a5ae1fc743fb6c3131c1dfb" translate="yes" xml:space="preserve">
          <source>This module is a port of a growing fragment of the numeric header in Alexander Stepanov's &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;Standard Template Library&lt;/a&gt;, with a few additions.</source>
          <target state="translated">이 모듈은 Alexander Stepanov의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;표준 템플릿 라이브러리&lt;/a&gt; 에서 숫자 헤더 부분이 점점 더 늘어나는 포트입니다 .</target>
        </trans-unit>
        <trans-unit id="186b66046159293951af2f7bf5b6d370eaa1c7f1" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_container&quot;&gt;&lt;code&gt;std.container&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_container&quot;&gt; &lt;code&gt;std.container&lt;/code&gt; &lt;/a&gt; 의 하위 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="b888919ea96721208483544ffecc9a20b885369e" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 하위 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="66276a22645692b59d3aafb558b5c8800653b392" translate="yes" xml:space="preserve">
          <source>This module is used to manipulate path strings.</source>
          <target state="translated">이 모듈은 경로 문자열을 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb13153b51d693dc351aaf671b676f52a55b77c" translate="yes" xml:space="preserve">
          <source>This module only supports DWARF 3 and 4.</source>
          <target state="translated">이 모듈은 DWARF 3 및 4 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="676c0f1d3f6966f52d6837dedf54ff7909b0c357" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;BinaryHeap&lt;/code&gt; (aka priority queue) adaptor that makes a binary heap out of any user-provided random-access range.</source>
          <target state="translated">이 모듈은 &lt;code&gt;BinaryHeap&lt;/code&gt; (일명 우선 순위 큐) 어댑터를 제공하여 사용자가 제공 한 임의 액세스 범위에서 이진 힙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="71c4856d53f3e5b6efc2d0b1e712b1b6dc800220" translate="yes" xml:space="preserve">
          <source>This module provides a few predefined hooks (below) that add useful behavior to &lt;code&gt;Checked&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 &lt;code&gt;Checked&lt;/code&gt; 에 유용한 동작을 추가하는 미리 정의 된 후크 (아래)를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b737fcac62cfd177fb2788c39a8e794c75cf3e63" translate="yes" xml:space="preserve">
          <source>This module provides all kinds of functions to create, manipulate or convert arrays:</source>
          <target state="translated">이 모듈은 배열을 생성, 조작 또는 변환하는 모든 종류의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="744c3d7cd21f0164caf9f95d6fbb778bc3ca3903" translate="yes" xml:space="preserve">
          <source>This module provides an &lt;code&gt;Array&lt;/code&gt; type with deterministic memory usage not reliant on the GC, as an alternative to the built-in arrays.</source>
          <target state="translated">이 모듈은 내장 어레이의 대안으로 GC에 의존하지 않는 결정적인 메모리 사용량을 가진 &lt;code&gt;Array&lt;/code&gt; 유형을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="223a76451a573bc8bae5a7f8a3df3aee7f1c9bdf" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the garbage collector used by applications written in the D programming language. It allows the garbage collector in the runtime to be swapped without affecting binary compatibility of applications.</source>
          <target state="translated">이 모듈은 D 프로그래밍 언어로 작성된 응용 프로그램에서 사용하는 가비지 수집기에 대한 인터페이스를 제공합니다. 응용 프로그램의 이진 호환성에 영향을 미치지 않으면 서 런타임의 가비지 수집기를 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45492b4e65c39718d334c504b40cf5ab9383e9f9" translate="yes" xml:space="preserve">
          <source>This module provides functions for compile time function composition. These functions are helpful when constructing predicates for the algorithms in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 컴파일 타임 함수 구성을위한 함수를 제공합니다. 이 함수는 &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 알고리즘에 대한 술어를 구성 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="5d2a6ed25bc583d8e01cfa972338639c00d25698" translate="yes" xml:space="preserve">
          <source>This module provides two default implementations of Base64 encoding, &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; with a standard encoding alphabet, and a variant &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; that has a modified encoding alphabet designed to be safe for embedding in URLs and filenames.</source>
          <target state="translated">이 모듈은 Base64 인코딩의 두 가지 기본 구현 , 표준 인코딩 알파벳이있는 &lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt; 및 URL 및 파일 이름에 안전하게 포함되도록 설계된 수정 된 인코딩 알파벳이있는 변형 &lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt; 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="14ea77a508973ad119aa38dedb9cc8889215b5e7" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 를&lt;/a&gt; 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="821aad4a4d60f837d17e068e658c2b293af2fa2e" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;code&gt;std.digest&lt;/code&gt; and can be used as a stand-alone module.</source>
          <target state="translated">이 모듈은 &lt;code&gt;std.digest&lt;/code&gt; 를 공개적으로 가져 오고 독립형 모듈로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b024b98a208b935e325d89f7c0523c717e6fc717" translate="yes" xml:space="preserve">
          <source>This module tells the garbage collector about the static data and bss segments, so the GC can scan them for roots. It does not deal with thread local static data.</source>
          <target state="translated">이 모듈은 가비지 수집기에 정적 데이터 및 bss 세그먼트에 대해 알려주므로 GC가 루트를 검색 할 수 있습니다. 스레드 로컬 정적 데이터를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0394ab52f6a74bfd6653d7622a7e2f41048f71f6" translate="yes" xml:space="preserve">
          <source>This module uses two main sources for generating human-readable data. First, it uses &lt;code&gt;backtrace_symbols&lt;/code&gt; to obtain the name of the symbols (functions or methods) associated with the addresses. Since the names are mangled, it will also call into &lt;code&gt;core.demangle&lt;/code&gt;, and doesn't need to use any DWARF information for this, however a future extension could make use of the call frame information (See DWARF4 &quot;6.4 Call Frame Information&quot;, PDF page 126).</source>
          <target state="translated">이 모듈은 사람이 읽을 수있는 데이터를 생성하기 위해 두 가지 주요 소스를 사용합니다. 먼저 &lt;code&gt;backtrace_symbols&lt;/code&gt; 를 사용 하여 주소와 관련된 기호 (함수 또는 메서드)의 이름을 얻습니다. 이름이 엉망이기 때문에 &lt;code&gt;core.demangle&lt;/code&gt; 을 호출하고 이를 위해 DWARF 정보를 사용할 필요가 없습니다. PDF 126 페이지).</target>
        </trans-unit>
        <trans-unit id="463dc59b1d8043356600fc31e94afe8ce61592b7" translate="yes" xml:space="preserve">
          <source>This modules defines some utility functions for DMD.</source>
          <target state="translated">이 모듈은 DMD에 대한 일부 유틸리티 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="43097636fc7721cda69a3011b02706b476fb53a5" translate="yes" xml:space="preserve">
          <source>This modules defines the entry point (main) for DMD, as well as related utilities needed for arguments parsing, path manipulation, etc... This file is not shared with other compilers which use the DMD front-end.</source>
          <target state="translated">이 모듈은 DMD의 진입 점 (메인)과 인수 구문 분석, 경로 조작 등에 필요한 관련 유틸리티를 정의합니다.이 파일은 DMD 프런트 엔드를 사용하는 다른 컴파일러와 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c5c0a58905cfb5b439b5201a82885c00dee51e2" translate="yes" xml:space="preserve">
          <source>This modules defines the help texts for the CLI options offered by DMD. This file is not shared with other compilers which use the DMD front-end. However, this file will be used to generate the &lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;online documentation&lt;/a&gt; and MAN pages.</source>
          <target state="translated">이 모듈은 DMD가 제공하는 CLI 옵션에 대한 도움말 텍스트를 정의합니다. 이 파일은 DMD 프런트 엔드를 사용하는 다른 컴파일러와 공유되지 않습니다. 그러나이 파일은 &lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;온라인 문서&lt;/a&gt; 및 MAN 페이지 를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d366277495521395d02d0e8919a008889699c8b6" translate="yes" xml:space="preserve">
          <source>This modules implements the serialization of a lambda function. The serialization is computed by visiting the abstract syntax subtree of the given lambda function. The serialization is a string which contains the type of the parameters and the string represantation of the lambda expression.</source>
          <target state="translated">이 모듈은 람다 함수의 직렬화를 구현합니다. 직렬화는 주어진 람다 함수의 추상 구문 서브 트리를 방문하여 계산됩니다. 직렬화는 매개 변수의 유형과 람다 식의 문자열 표현을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4686239dc1c916453ca8175a0c8f0fd5b10fd0f8" translate="yes" xml:space="preserve">
          <source>This mostly means checking that the &lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf format specifier&lt;/a&gt; matches the corresponding D data type. Although printf is designed to handle 0 terminated strings, not D dynamic arrays of chars, it turns out that since D dynamic arrays are a length followed by a pointer to the data, the &lt;code&gt;%.*s&lt;/code&gt; format works:</source>
          <target state="translated">이것은 대부분 &lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf 형식 지정자가&lt;/a&gt; 해당 D 데이터 유형과 일치 하는지 확인하는 것을 의미 합니다. printf는 문자의 D 동적 배열이 아닌 0으로 끝나는 문자열을 처리하도록 설계되었지만 D 동적 배열의 길이와 데이터에 대한 포인터가 있기 때문에 &lt;code&gt;%.*s&lt;/code&gt; 형식이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d2a9ab8f340972eb23caaae774d32f80fccc2570" translate="yes" xml:space="preserve">
          <source>This must be called when a scheduled thread terminates. It tears down the messaging system for the thread and notifies interested parties of the thread's termination.</source>
          <target state="translated">예약 된 스레드가 종료 될 때 호출해야합니다. 스레드에 대한 메시징 시스템을 분리하고 관련 당사자에게 스레드 종료를 통지합니다.</target>
        </trans-unit>
        <trans-unit id="a87fd9a7f939391e41bf76be573f03fa79c258b5" translate="yes" xml:space="preserve">
          <source>This opcode is not supported by the assembler, instead use</source>
          <target state="translated">이 opcode는 어셈블러에서 지원하지 않으며 대신</target>
        </trans-unit>
        <trans-unit id="475523109cd4bf257a07dadc9f0c389730bafbbb" translate="yes" xml:space="preserve">
          <source>This operation is both lock-free and atomic.</source>
          <target state="translated">이 작업은 잠금이없고 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="5080314419c68e07e9fbf46cb969bb8f7aec2b87" translate="yes" xml:space="preserve">
          <source>This overload converts a character input range to a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">이 과부하는 문자 입력 범위를 &lt;code&gt;bool&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f77cb81e183ee70aaac158a6010f060479e211" translate="yes" xml:space="preserve">
          <source>This overload of the digest function handles arrays.</source>
          <target state="translated">다이제스트 함수의이 오버로드는 배열을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5b5704e7eb61d0c1141594f127f54400ac726629" translate="yes" xml:space="preserve">
          <source>This overload of the hexDigest function handles arrays.</source>
          <target state="translated">hexDigest 함수의이 오버로드는 배열을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9b517602563a0a0437638b7de42771ba24220c9c" translate="yes" xml:space="preserve">
          <source>This override handles the following two cases: static foreach (i, i; [0]) { ... } and static foreach (i; [0]) { enum i = 2; }</source>
          <target state="translated">이 대체는 다음 두 가지 경우를 처리합니다. static foreach (i, i; [0]) {...} 및 static foreach (i; [0]) {enum i = 2; }</target>
        </trans-unit>
        <trans-unit id="4b5c72b79cb5cdac8aa14be60be09b9790cb2ce2" translate="yes" xml:space="preserve">
          <source>This package also implements untyped composable memory allocators. They are</source>
          <target state="translated">이 패키지는 형식화되지 않은 작성 가능한 메모리 할당자를 구현합니다. 그들은</target>
        </trans-unit>
        <trans-unit id="5b7998033b82c18a421be4c93bdff9f111ea8e70" translate="yes" xml:space="preserve">
          <source>This package implements generic algorithms oriented towards the processing of sequences. Sequences processed by these functions define range-based interfaces. See also &lt;a href=&quot;std_range&quot;&gt;Reference on ranges&lt;/a&gt; and &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 시퀀스 처리를위한 일반적인 알고리즘을 구현합니다. 이러한 기능으로 처리 된 시퀀스는 범위 기반 인터페이스를 정의합니다. 참조 &lt;a href=&quot;std_range&quot;&gt;범위에 참조&lt;/a&gt; 및 &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;범위에 튜토리얼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c7d9c8a3cee8b3cf80c6b3b4132f86a95f5343" translate="yes" xml:space="preserve">
          <source>This package implements the hash-based message authentication code (HMAC) algorithm as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104&lt;/a&gt;. See also the corresponding &lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia article&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104에&lt;/a&gt; 정의 된 해시 기반 메시지 인증 코드 (HMAC) 알고리즘을 구현합니다 . 해당 &lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia 기사&lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c456d1a63a6715ba3105365cc39ffcc9f965cfb" translate="yes" xml:space="preserve">
          <source>This package implements the hash-based message authentication code (HMAC) algorithm as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104&lt;/a&gt;. See also the corresponding &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia article&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54b15a9491f8b22812d70e97f6e30656fbe4637" translate="yes" xml:space="preserve">
          <source>This points to a linked list of headers, struct curl_slist kind</source>
          <target state="translated">이것은 연결된 헤더 목록, 구조체 curl_slist 종류를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4fa3e3f63776b5b0936a2fb2bebc42c79d485368" translate="yes" xml:space="preserve">
          <source>This points to a linked list of post entries, struct curl_httppost</source>
          <target state="translated">이것은 struct curl_httppost에 연결된 게시물 항목 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4709ade7923d0d8282a3479562e2dbd3f6142a8c" translate="yes" xml:space="preserve">
          <source>This points to a linked list of telnet options</source>
          <target state="translated">이것은 텔넷 옵션의 링크 된 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2d122d6794084d92dff4c8603b8a998294750f13" translate="yes" xml:space="preserve">
          <source>This pragma must directly precede an &lt;code&gt;extern(C)&lt;/code&gt; function declaration that must take no argument, even default ones. The function this pragma applies to will be inserted in &lt;code&gt;.init_array&lt;/code&gt; or &lt;code&gt;.ctors&lt;/code&gt;, depending on the target and compiler implementation. It is equivalent to GCC's &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html&quot;&gt;&lt;code&gt;__attribute__((constructor))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 기본 인수를 포함하여 인수가 없어야 하는 &lt;code&gt;extern(C)&lt;/code&gt; 함수 선언 바로 앞에 와야 합니다. 이 pragma가 적용되는 함수 는 타겟 및 컴파일러 구현에 따라 &lt;code&gt;.init_array&lt;/code&gt; 또는 &lt;code&gt;.ctors&lt;/code&gt; 에 삽입 됩니다 . GCC의 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html&quot;&gt; &lt;code&gt;__attribute__((constructor))&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="62f59d77929e72a8f25d40e635e0a3a32957778c" translate="yes" xml:space="preserve">
          <source>This predicate must be an equivalence relation, that is, it must be reflexive (&lt;code&gt;pred(x,x)&lt;/code&gt; is always true), symmetric (&lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt;), and transitive (&lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; implies &lt;code&gt;pred(x,z)&lt;/code&gt;). If this is not the case, the range returned by chunkBy may assert at runtime or behave erratically.</source>
          <target state="translated">이 술어는 동등성 관계 여야합니다. 즉, 반사적 ( &lt;code&gt;pred(x,x)&lt;/code&gt; 는 항상 참), 대칭 ( &lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt; ) 및 전 이적 ( &lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; &lt;code&gt;pred(x,z)&lt;/code&gt; 의미 합니다. 그렇지 않은 경우, chunkBy가 리턴 한 범위는 런타임시 어설 션되거나 잘못 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a267b44ef886d9c8baf429e8671183b625c8796" translate="yes" xml:space="preserve">
          <source>This program reads standard in and writes it to standard out, pretty-printing any found D mangled names.</source>
          <target state="translated">이 프로그램은 표준 입력을 읽고 표준 출력에 기록하여 발견 된 D 맹 글링 된 이름을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="afdb5e2e48fdacd7a6c8694592ad8b718667d89f" translate="yes" xml:space="preserve">
          <source>This property is overridden because the local time of the system could change while the program is running and we need to determine it dynamically rather than it being fixed like it would be with most time zones.</source>
          <target state="translated">이 속성은 프로그램이 실행되는 동안 시스템의 현지 시간이 변경 될 수 있으므로 대부분의 표준 시간대와 같이 고정되지 않고 동적으로 결정해야하므로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6d74dd10b5c800dca0bea3aabcacb84d776dbed7" translate="yes" xml:space="preserve">
          <source>This property sets and gets the default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">이 속성은 기본 &lt;code&gt;Logger&lt;/code&gt; 설정하고 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="233904e9ff09001991edcef153035ddd2dc72e31" translate="yes" xml:space="preserve">
          <source>This property should not be used, but is supported for legacy purposes.</source>
          <target state="translated">이 속성은 사용하지 않아야하지만 레거시 목적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0985b965d550bee9a97d40f84d906e5dd41300" translate="yes" xml:space="preserve">
          <source>This prototype applies to all conversion callbacks</source>
          <target state="translated">이 프로토 타입은 모든 전환 콜백에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="362936247c39185758bfe185928298d458cd1898" translate="yes" xml:space="preserve">
          <source>This provides a transition from the non-promoting behavior of unary + - ~ to the C-like integral promotion behavior.</source>
          <target state="translated">이는 단항 +-~의 비 촉진 동작에서 C와 같은 통합 승격 동작으로의 전환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42fdb37f7871dd64abfac735f6f1948def69313b" translate="yes" xml:space="preserve">
          <source>This provides a way to add functions to a class externally as if they were public final member functions, which enables &lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt; function chaining and component programming&lt;/a&gt;.</source>
          <target state="translated">이를 통해 공개 최종 멤버 함수 인 것처럼 외부에 클래스에 함수를 추가 할 수 있으므로 &lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt;함수 체인 및 구성 요소 프로그래밍이 가능&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b5e3135a675f967dd5c5470ea386f16d7ad31f41" translate="yes" xml:space="preserve">
          <source>This range iterates over fixed-sized chunks of size &lt;code&gt;chunkSize&lt;/code&gt; of a &lt;code&gt;source&lt;/code&gt; range. &lt;code&gt;Source&lt;/code&gt; must be an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. &lt;code&gt;chunkSize&lt;/code&gt; must be greater than zero.</source>
          <target state="translated">이 범위 는 &lt;code&gt;source&lt;/code&gt; 범위의 &lt;code&gt;chunkSize&lt;/code&gt; 크기의 고정 크기 청크에 대해 반복 됩니다. &lt;code&gt;Source&lt;/code&gt; 는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 여야합니다 . &lt;code&gt;chunkSize&lt;/code&gt; 는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="ffdad1d5b9cd516ba877128f5377fd43732ba01e" translate="yes" xml:space="preserve">
          <source>This range splits a &lt;code&gt;source&lt;/code&gt; range into &lt;code&gt;chunkCount&lt;/code&gt; chunks of approximately equal length. &lt;code&gt;Source&lt;/code&gt; must be a forward range with known length.</source>
          <target state="translated">이 범위는 &lt;code&gt;source&lt;/code&gt; 범위를 대략 동일한 길이의 &lt;code&gt;chunkCount&lt;/code&gt; 청크 로 나눕니다 . &lt;code&gt;Source&lt;/code&gt; 는 길이가 알려진 포워드 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="99784cdd841b29b6c6c458a6a98700cdba67e67d" translate="yes" xml:space="preserve">
          <source>This range will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the underlying data source is at least a forward range.</source>
          <target state="translated">이 범위는 것이다 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 영역&lt;/a&gt; 내부 데이터 소스는 적어도 전진 레인지이면.</target>
        </trans-unit>
        <trans-unit id="87508ea3111ce555c431f5b202f7db1e58a43a32" translate="yes" xml:space="preserve">
          <source>This range will receive elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">이 범위는 반복이 진행됨에 따라 &lt;code&gt;inputRange&lt;/code&gt; 의 요소를 점진적으로 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="76aba1f55c69e82481c98e4e2c1338584cc1691e" translate="yes" xml:space="preserve">
          <source>This represents the category of &lt;code&gt;Throwable&lt;/code&gt; objects that are &lt;b&gt;not&lt;/b&gt; safe to catch and handle. In principle, one should not catch Error objects, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="translated">이것은 잡거나 다루기가 안전 &lt;b&gt;하지 않은 &lt;/b&gt; &lt;code&gt;Throwable&lt;/code&gt; 객체 의 범주를 나타냅니다 . 원칙적으로 오류 개체는 복구 할 수없는 런타임 오류를 나타내므로 오류 개체를 잡아서는 안됩니다. 이러한 오류가 발생하면 특정 런타임 보증이 유지되지 않아 오류를 발견 한 후에도 계속 실행하는 것이 안전하지 않을 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5f588659c6a58c1ddf047b3a2039449d9c56d1c" translate="yes" xml:space="preserve">
          <source>This returns the evaluation value of performance as the ratio of baseFunc's time over targetFunc's time. If performance is high, this returns a high value.</source>
          <target state="translated">targetFunc 시간에 대한 baseFunc 시간의 비율로 성능 평가 값을 리턴합니다. 성능이 높으면 높은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6949b897dc88b2038c4de24c6845ff78a726d87" translate="yes" xml:space="preserve">
          <source>This routine allows the runtime to process any special per-thread handling for the GC. This is needed for taking into account any memory that is referenced by non-scanned pointers but is about to be freed. That currently means the array append cache.</source>
          <target state="translated">이 루틴을 통해 런타임은 GC에 대한 스레드 별 처리를 처리 할 수 ​​있습니다. 이것은 스캔되지 않은 포인터가 참조하지만 해제하려고하는 메모리를 고려하기 위해 필요합니다. 이는 현재 어레이 추가 캐시를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="08f408a77465437e08636b8afacc3919eb737cd7" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static constructors when called. If full functionality as a D thread is desired, the following function must be called after thread_attachThis:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 생성자를 실행하지 않습니다. D 스레드로서의 모든 기능이 필요한 경우 thread_attachThis 다음에 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="29f29aed6bb63f2bb71ea82e3247723ea06a2ff1" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called after thread_detachThis, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 소멸자를 실행하지 않습니다. D 스레드로서의 완전한 기능이 필요한 경우 thread_detach 다음에 다음 함수를 호출해야합니다. 특히 프로그램 종료 전에 특정 시간에 스레드가 분리되는 경우 :</target>
        </trans-unit>
        <trans-unit id="e2210ae223e7d7387e02e70f648478605beed923" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called by the detached thread, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">이 루틴은 호출 될 때 스레드 로컬 정적 소멸자를 실행하지 않습니다. D 스레드로서의 완전한 기능이 필요한 경우, 특히 프로그램 종료 전에 특정 시간에 스레드가 분리되는 경우 분리 된 스레드가 다음 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="47826c4895a3860e96fcff125901760f36d390ea" translate="yes" xml:space="preserve">
          <source>This routine is called at various points within concurrency-aware APIs to provide a scheduler a chance to yield execution when using some sort of cooperative multithreading model. If this is not appropriate, such as when each logical thread is backed by a dedicated kernel thread, this routine may be a no-op.</source>
          <target state="translated">이 루틴은 동시성 인식 API 내의 다양한 지점에서 호출되어 스케줄러가 일종의 협력 멀티 스레딩 모델을 사용할 때 실행을 생성 할 수있는 기회를 제공합니다. 각 논리 스레드가 전용 커널 스레드에 의해 백업되는 경우와 같이 이것이 적절하지 않은 경우이 루틴은 작동하지 않을 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
