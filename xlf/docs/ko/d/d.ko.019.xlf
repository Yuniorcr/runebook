<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="9629b284d8cc44b6dfe8df63c6a3f0d4084cc53c" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;doesPointTo(x, x)&lt;/code&gt; checks whether &lt;code&gt;x&lt;/code&gt; has internal pointers. This should only be done as an assertive test, as the language is free to assume objects don't have internal pointers (TDPL 7.1.3.5).</source>
          <target state="translated">&lt;code&gt;doesPointTo(x, x)&lt;/code&gt; 평가 하면 &lt;code&gt;x&lt;/code&gt; 에 내부 포인터가 있는지 확인합니다 . 언어는 객체에 내부 포인터가 없다고 가정 할 수 있기 때문에 독단적 테스트로만 수행해야합니다 (TDPL 7.1.3.5).</target>
        </trans-unit>
        <trans-unit id="0a4344337a70f4c33150fb408f68890c00d456e4" translate="yes" xml:space="preserve">
          <source>Evaluation is</source>
          <target state="translated">평가는</target>
        </trans-unit>
        <trans-unit id="66a21e1a42d0f889ed11cc2d4d6f241490fc741c" translate="yes" xml:space="preserve">
          <source>Evaluation is short-circuited if a true result is encountered; the template predicate must be instantiable with one of the given items.</source>
          <target state="translated">실제 결과가 나오면 평가가 단락됩니다. 템플리트 술어는 주어진 항목 중 하나를 사용하여 인스턴스화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d17d4bfeca546c47272dfcbb85f447b4b26bf12" translate="yes" xml:space="preserve">
          <source>Evaluation order of options is &lt;code&gt;rt_options&lt;/code&gt;, then environment variables, then command line arguments, i.e. if command line arguments are not disabled, they can override options specified through the environment or embedded in the executable.</source>
          <target state="translated">옵션의 평가 순서는 &lt;code&gt;rt_options&lt;/code&gt; , 환경 변수, 명령 줄 인수입니다. 즉, 명령 줄 인수가 비활성화되지 않은 경우 환경을 통해 지정되거나 실행 파일에 포함 된 옵션을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="180eef85054f4fcea96ca798ddcbe7751670c0c9" translate="yes" xml:space="preserve">
          <source>Evaluation value</source>
          <target state="translated">평가 가치</target>
        </trans-unit>
        <trans-unit id="6f02f12a41e5810b607c7f2ac63bab107ad16369" translate="yes" xml:space="preserve">
          <source>Even if template arguments are implicitly converted to the same template parameter type, they still refer to the same instance. This example uses a &lt;a href=&quot;#aggregate_templates&quot;&gt;&lt;code&gt;struct&lt;/code&gt; template&lt;/a&gt;:</source>
          <target state="translated">템플릿 인수가 암시 적으로 동일한 템플릿 매개 변수 유형으로 변환 되더라도 여전히 동일한 인스턴스를 참조합니다. 이 예제는 &lt;a href=&quot;#aggregate_templates&quot;&gt; &lt;code&gt;struct&lt;/code&gt; 템플릿을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="becac2a7bbc3661ded85df34941db446bcb8fc99" translate="yes" xml:space="preserve">
          <source>Even permutations are useful for generating coordinates of certain geometric shapes. Here's a non-trivial example:</source>
          <target state="translated">순열도 특정 기하학적 모양의 좌표를 생성하는 데 유용합니다. 사소한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff9e5997c4690a9137a05954ed088426938f9897" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;B.foo(int)&lt;/code&gt; is a better match than &lt;code&gt; A.foo(long)&lt;/code&gt; for &lt;code&gt;foo(1)&lt;/code&gt;, it is an error because the two matches are in different overload sets.</source>
          <target state="translated">비록 &lt;code&gt;B.foo(int)&lt;/code&gt; 보다 더 나은 일치 &lt;code&gt; A.foo(long)&lt;/code&gt; 에 대한 &lt;code&gt;foo(1)&lt;/code&gt; 두 경기가 다른 과부하 세트에 있기 때문에, 그것은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b34452177e48c546c9017df7b18cba01909144f" translate="yes" xml:space="preserve">
          <source>Even though a new scope is introduced, local symbol declarations cannot shadow (hide) other local symbol declarations in the same function.</source>
          <target state="translated">새로운 범위가 도입 되었음에도, 로컬 심볼 선언은 동일한 함수에서 다른 로컬 심볼 선언을 숨길 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b53b461e5519dc40d2d9c94f0001bf7d1b8053d1" translate="yes" xml:space="preserve">
          <source>Even trivially sub-classing an exception involves writing boilerplate code for the constructor to: 1) correctly pass in the source file and line number the exception was thrown from; 2) be usable with &lt;a href=&quot;#enforce&quot;&gt;&lt;code&gt;enforce&lt;/code&gt;&lt;/a&gt; which expects exception constructors to take arguments in a fixed order. This mixin provides that boilerplate code.</source>
          <target state="translated">예외를 사소하게 서브 클래 싱하는 경우에도 생성자를위한 상용구 코드를 작성하여 다음을 수행 할 수 있습니다. 2) 예외 생성자가 고정 된 순서로 인수를 취할 것으로 예상 하는 &lt;a href=&quot;#enforce&quot;&gt; &lt;code&gt;enforce&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 . 이 믹스 인은 그 상용구 코드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="646505488568f65dc2d08be5e7c3988051fbafd1" translate="yes" xml:space="preserve">
          <source>Even worse, good error handling code is itself error prone, tends to be the least tested (and therefore buggy) part of the project, and is frequently simply omitted. The end result is likely a &quot;blue screen of death&quot; as the program failed to deal with some unanticipated error.</source>
          <target state="translated">더 나쁜 것은, 좋은 오류 처리 코드 자체는 오류가 발생하기 쉬우 며 프로젝트에서 테스트가 가장 적고 (따라서 버그가있는) 경향이 있으며 종종 생략되는 경우가 많습니다. 프로그램이 예상치 못한 오류를 처리하지 못해 최종 결과는 &quot;죽음의 블루 스크린&quot;일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd3204ba4b70213492f01a9c5c68e7ab2ed1ff96" translate="yes" xml:space="preserve">
          <source>EvenChunks!Source &lt;strong id=&quot;evenChunks&quot;&gt;evenChunks&lt;/strong&gt;(Source)(Source source, size_t chunkCount)</source>
          <target state="translated">EvenChunks! Source &lt;strong id=&quot;evenChunks&quot;&gt;evenChunks&lt;/strong&gt; (소스) (소스 소스, size_t chunkCount)</target>
        </trans-unit>
        <trans-unit id="a4a0cc71be8cf518b622bbb5bc79c5bc5de1b789" translate="yes" xml:space="preserve">
          <source>Eventually, the attacker is able to determine the first character in the correct token because the sever takes slightly longer to return a rejection. This is due to the comparison moving on to second item in the two arrays, seeing they are different, and then sending the rejection.</source>
          <target state="translated">결국 공격자는 서버가 거부를 반환하는 데 약간의 시간이 걸리기 때문에 올바른 토큰의 첫 번째 문자를 확인할 수 있습니다. 이것은 두 배열의 두 번째 항목으로 비교하여 서로 다른 것을보고 거부를 보내기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f00b8f841e4cef948de65d22226c93fa103650fa" translate="yes" xml:space="preserve">
          <source>Every data logged to this &lt;code&gt;MultiLogger&lt;/code&gt; will be distributed to all the &lt;code&gt;Logger&lt;/code&gt;s inserted into it. This &lt;code&gt;MultiLogger&lt;/code&gt; implementation can hold multiple &lt;code&gt;Logger&lt;/code&gt;s with the same name. If the method &lt;code&gt;removeLogger&lt;/code&gt; is used to remove a &lt;code&gt;Logger&lt;/code&gt; only the first occurrence with that name will be removed.</source>
          <target state="translated">이 &lt;code&gt;MultiLogger&lt;/code&gt; 에 기록 된 모든 데이터 는 삽입 된 모든 &lt;code&gt;Logger&lt;/code&gt; 에 분배됩니다 . 이 &lt;code&gt;MultiLogger&lt;/code&gt; 구현은 동일한 이름을 가진 여러 &lt;code&gt;Logger&lt;/code&gt; 를 보유 할 수 있습니다 . &lt;code&gt;removeLogger&lt;/code&gt; 메소드 를 사용하여 &lt;code&gt;Logger&lt;/code&gt; 를 제거하면 해당 이름을 가진 첫 번째 항목 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4e61dc390abff2fed88336a14c32d2472d4eb8ec" translate="yes" xml:space="preserve">
          <source>Every log message with a &lt;code&gt;LogLevel&lt;/code&gt; lower as the global &lt;code&gt;LogLevel&lt;/code&gt; will be discarded before it reaches &lt;code&gt;writeLogMessage&lt;/code&gt; method of any &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;code&gt;LogLevel&lt;/code&gt; 로 &lt;code&gt;LogLevel&lt;/code&gt; 이 낮은 모든 로그 메시지는 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;writeLogMessage&lt;/code&gt; 메소드에 도달하기 전에 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="299691262b0966820ccb1f9ef81cef23f22ecbaf" translate="yes" xml:space="preserve">
          <source>Every subclass of &lt;code&gt;Logger&lt;/code&gt; has to call this constructor from their constructor. It sets the &lt;code&gt;LogLevel&lt;/code&gt;, and creates a fatal handler. The fatal handler will throw an &lt;code&gt;Error&lt;/code&gt; if a log call is made with level &lt;code&gt;LogLevel.fatal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 의 모든 서브 클래스는 생성자에서이 생성자를 호출해야합니다. &lt;code&gt;LogLevel&lt;/code&gt; 을 설정하고 치명적인 처리기를 만듭니다. &lt;code&gt;LogLevel.fatal&lt;/code&gt; 레벨로 로그를 호출하면 치명적 핸들러에서 &lt;code&gt;Error&lt;/code&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e6bc748f9fbc0549e63a017cd5636a311c15fde2" translate="yes" xml:space="preserve">
          <source>Every symbol, type, and expression has properties that can be queried:</source>
          <target state="translated">모든 기호, 유형 및 표현식에는 쿼리 할 수있는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71e20220eb46bc48ab7853c8f64b255dfcc7b90" translate="yes" xml:space="preserve">
          <source>Exact Alias</source>
          <target state="translated">정확한 별명</target>
        </trans-unit>
        <trans-unit id="8659b6d121f9dcc98345ea85f4be6011035d4e4c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n - 1&lt;/code&gt; comparisons are needed.</source>
          <target state="translated">정확히 &lt;code&gt;n - 1&lt;/code&gt; 비교가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="447595f030e16a9c11484fc6f4099975f890557c" translate="yes" xml:space="preserve">
          <source>Examine function signature for parameter p and see if the value of p can 'escape' the scope of the function. This is useful to minimize the needed annotations for the parameters.</source>
          <target state="translated">매개 변수 p에 대한 함수 서명을 검사하고 p 값이 함수 범위를 '탈출'할 수 있는지 확인하십시오. 이는 매개 변수에 필요한 주석을 최소화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3a8d7c39720f8b36996668ba6047e485a42fa9dc" translate="yes" xml:space="preserve">
          <source>Example for reading an existing zip archive:</source>
          <target state="translated">기존 zip 아카이브를 읽는 예 :</target>
        </trans-unit>
        <trans-unit id="0c98a62db0de4db40cb83954f78ce2a6a8b61f57" translate="yes" xml:space="preserve">
          <source>Example for writing files into a zip archive:</source>
          <target state="translated">zip 아카이브에 파일을 쓰는 예 :</target>
        </trans-unit>
        <trans-unit id="c57552c19fd7d2da63a30f68727e3bb36eb45b21" translate="yes" xml:space="preserve">
          <source>Example from &quot;Introduction to Algorithms&quot; Cormen et al, p 146</source>
          <target state="translated">&quot;알고리즘 소개&quot;의 예 Cormen et al, p 146</target>
        </trans-unit>
        <trans-unit id="71d13cfc872d9ac46d96e5966fcea949405ebbc4" translate="yes" xml:space="preserve">
          <source>Example of a simple program printing its stack trace</source>
          <target state="translated">스택 추적을 인쇄하는 간단한 프로그램의 예</target>
        </trans-unit>
        <trans-unit id="529363f48295f0e991d2c61b1b24a9fe1aecfa01" translate="yes" xml:space="preserve">
          <source>Example predicate that compares individual elements in reverse lexical order</source>
          <target state="translated">개별 요소를 역 어휘 순으로 비교하는 예제 술어</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="3ac96cc54ccaf408a3aa9265ec618b7d8d9688f3" translate="yes" xml:space="preserve">
          <source>Example using a custom predicate. Note that the needle appears as the second argument of the predicate.</source>
          <target state="translated">사용자 정의 술어를 사용하는 예. 바늘이 술어의 두 번째 인수로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7c5d41ac96fe781891640f2cc6ae31d7dac093fe" translate="yes" xml:space="preserve">
          <source>Example: in the expression &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt;, the smallest short-circuit expression of the subexpression &lt;code&gt;f() * 2&lt;/code&gt; is &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt;. In the expression &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt;, the subexpression &lt;code&gt;h()&lt;/code&gt; has no smallest short-circuit expression.</source>
          <target state="translated">예 : 표현식에서 &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt; 에서 하위 표현식 &lt;code&gt;f() * 2&lt;/code&gt; 의 가장 작은 단락 표현 은 &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt; 입니다. 표현식 &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt; 에서 하위 표현식 &lt;code&gt;h()&lt;/code&gt; 에는 가장 작은 단락 표현식 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b6e410f2f289a8e54fbc074511ef251ffbf64e5" translate="yes" xml:space="preserve">
          <source>Example: in the statement &lt;code&gt;return f() + g() * 2;&lt;/code&gt;, the full expression of &lt;code&gt;g() * 2&lt;/code&gt; is &lt;code&gt;f() + g() * 2&lt;/code&gt;, but not the full expression of &lt;code&gt;f() + g()&lt;/code&gt; because the latter is not parsed as a subexpression.</source>
          <target state="translated">예 : 명령문에서 &lt;code&gt;return f() + g() * 2;&lt;/code&gt; , &lt;code&gt;g() * 2&lt;/code&gt; 의 전체 표현식 은 &lt;code&gt;f() + g() * 2&lt;/code&gt; 이지만 &lt;code&gt;f() + g()&lt;/code&gt; 의 전체 표현식은 하위 표현식으로 구문 분석되지 않기 때문에 전체 표현식 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2b57735b929f758540f6f204a80a85ed5455f140" translate="yes" xml:space="preserve">
          <source>Exception Flags</source>
          <target state="translated">예외 플래그</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="8e3da5af2290e454a8dda9f1e0d4340536bda871" translate="yes" xml:space="preserve">
          <source>Exception allocation, cloning, and release compiler support routines.</source>
          <target state="translated">예외 할당, 복제 및 릴리스 컴파일러 지원 루틴.</target>
        </trans-unit>
        <trans-unit id="fffb66a488035e580bbe4d9dfb0563a4cf976029" translate="yes" xml:space="preserve">
          <source>Exception containing the row and column for when an exception was thrown.</source>
          <target state="translated">예외가 발생했을 때의 행과 열을 포함하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="04ccd57adc7199b9320005b31e59d240c692ae76" translate="yes" xml:space="preserve">
          <source>Exception handling is done with the try-catch-finally statement.</source>
          <target state="translated">try-catch-finally 문으로 예외 처리가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5dd8fbbbac9a5ffa8a85c3407866002bfd2a943a" translate="yes" xml:space="preserve">
          <source>Exception handling is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">예외 처리가 지원됩니다. 평가 &lt;code&gt;false&lt;/code&gt; 명령 줄 스위치를 사용하여 컴파일 할 때 &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7977347a7a7188c09ab63d88a93b935cd78760c4" translate="yes" xml:space="preserve">
          <source>Exception handling method</source>
          <target state="translated">예외 처리 방법</target>
        </trans-unit>
        <trans-unit id="989c0eb85b5a41ecfef7a4557f1cdced37ec6bb0" translate="yes" xml:space="preserve">
          <source>Exception handling stack unwinding is a relatively slow process.</source>
          <target state="translated">예외 처리 스택 해제는 상대적으로 느린 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="d5701a5b5f69ab1f2d7097d5d051b3d32981e410" translate="yes" xml:space="preserve">
          <source>Exception handling support for Dwarf-style portable exceptions.</source>
          <target state="translated">드워프 스타일 휴대용 예외에 대한 예외 처리 지원.</target>
        </trans-unit>
        <trans-unit id="9829d9ff9d8698ea752a98d4a92c4ea756a83270" translate="yes" xml:space="preserve">
          <source>Exception if it fails.</source>
          <target state="translated">실패하면 예외입니다.</target>
        </trans-unit>
        <trans-unit id="a3fa8f21629b3a2bb2c1e659bd0f396554feda8e" translate="yes" xml:space="preserve">
          <source>Exception if there is an error while parsing the given XML.</source>
          <target state="translated">지정된 XML을 구문 분석하는 동안 오류가 발생하면 예외입니다.</target>
        </trans-unit>
        <trans-unit id="04d466ab829f02b64659284da536680cd0cead15" translate="yes" xml:space="preserve">
          <source>Exception interoperability is a work in progress.</source>
          <target state="translated">예외적 인 상호 운용성은 진행중인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="ac3a987430d7002abc0aeb021e7b76ae195d4418" translate="yes" xml:space="preserve">
          <source>Exception object thrown in case of errors during regex compilation.</source>
          <target state="translated">정규식 컴파일 중 오류가 발생하면 예외 객체가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3b36ed4e90f7895ab9c1f841d81e354fcc19912" translate="yes" xml:space="preserve">
          <source>Exception thrown for file I/O errors.</source>
          <target state="translated">파일 I / O 오류에 대해 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="cb3e9f844a01a0b96967f3dd6a290735d00840ed" translate="yes" xml:space="preserve">
          <source>Exception thrown on HTTP request failures, e.g. 404 Not Found.</source>
          <target state="translated">HTTP 요청 실패시 예외 발생 (예 : 404 찾을 수 없음)</target>
        </trans-unit>
        <trans-unit id="bfe22b35920246b957f97d99d530bac8696b368e" translate="yes" xml:space="preserve">
          <source>Exception thrown on JSON errors</source>
          <target state="translated">JSON 오류에서 예외 발생</target>
        </trans-unit>
        <trans-unit id="a84a6e62adad93da512146dbeb0d45a3dc267b49" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.net.curl functions.</source>
          <target state="translated">std.net.curl 함수의 오류에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="253a6febbe3430c64130d06fa5981a03478c1db8" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.string functions.</source>
          <target state="translated">std.string 함수의 오류에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="da2cac7a810249d2d11cee22b4057ecee00f3eee" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.utf functions.</source>
          <target state="translated">std.utf 함수의 오류에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a2ac6072f2d36ac52160e487df22a74f63da3" translate="yes" xml:space="preserve">
          <source>Exception thrown on timeout errors in std.net.curl functions.</source>
          <target state="translated">std.net.curl 함수에서 시간 종료 오류에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="5a4bbb2d3d63ddeb86708dd8ce427adf6b7d165d" translate="yes" xml:space="preserve">
          <source>Exception thrown under different conditions based on the type of &lt;code&gt; Contents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; Contents&lt;/code&gt; 유형에 따라 다른 조건에서 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0b352a0dfd2cdf2adffdd6d799e3b32a8a9e3145" translate="yes" xml:space="preserve">
          <source>Exception thrown upon encountering Base64 encoding or decoding errors.</source>
          <target state="translated">Base64 인코딩 또는 디코딩 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66069ad3e21b6e2e8b6ef96e5b841bffb3ffeb38" translate="yes" xml:space="preserve">
          <source>Exception thrown when a Token is identified to not be completed: a quote is found in an unquoted field, data continues after a closing quote, or the quoted field was not closed before data was empty.</source>
          <target state="translated">토큰이 완료되지 않은 것으로 식별되면 예외가 발생합니다. 따옴표가없는 필드에서 따옴표를 찾거나 닫는 따옴표 후에 데이터가 계속되거나 데이터가 비어 있기 전에 따옴표로 묶인 필드가 닫히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="905fb856166761ef9b7e30ba12340557f71b5efe" translate="yes" xml:space="preserve">
          <source>Exception type thrown upon any failure.</source>
          <target state="translated">실패시 예외 유형이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f1d0d4844845d6b370b77234d0e77115c51b19af" translate="yes" xml:space="preserve">
          <source>Exception type to throw if the value evaluates to false.</source>
          <target state="translated">값이 false로 평가되면 예외 유형이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f928a890db6dee56e7f09963fd1b5750c95236a4" translate="yes" xml:space="preserve">
          <source>Exception type used by core.time.</source>
          <target state="translated">core.time에서 사용되는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="653b9fe3f50eddc9f59c435dd81774a198a4bfb2" translate="yes" xml:space="preserve">
          <source>Exception type used by std.datetime. It's an alias to &lt;a href=&quot;core_time#TimeException&quot;&gt;&lt;code&gt;core.time.TimeException&lt;/code&gt;&lt;/a&gt;. Either can be caught without concern about which module it came from.</source>
          <target state="translated">std.datetime에서 사용되는 예외 유형입니다. &lt;a href=&quot;core_time#TimeException&quot;&gt; &lt;code&gt;core.time.TimeException&lt;/code&gt; &lt;/a&gt; 의 별명 입니다. 어느 모듈에서 왔는지 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="15839feb51f6c7eb57eb20c2122df74004e3811b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader to free</source>
          <target state="translated">ExceptionHeader 무료</target>
        </trans-unit>
        <trans-unit id="668deca20711f80b1c2101115452f3a6ad56520b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader* &lt;code&gt;eh&lt;/code&gt;</source>
          <target state="translated">ExceptionHeader * &lt;code&gt;eh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="787a8beff59b551fcef4298de1a9187c800df51d" translate="yes" xml:space="preserve">
          <source>Exchange &lt;code&gt;exchangeWith&lt;/code&gt; with the memory referenced by &lt;code&gt;here&lt;/code&gt;. This operation is both lock-free and atomic.</source>
          <target state="translated">교환 &lt;code&gt;exchangeWith&lt;/code&gt; 에 의해 참조되는 메모리 &lt;code&gt;here&lt;/code&gt; . 이 작업은 잠금이없고 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="947665622c6a0247540f1769e4059f113b774915" translate="yes" xml:space="preserve">
          <source>Execute and wait for completion, collect output</source>
          <target state="translated">실행 및 완료 대기, 출력 수집</target>
        </trans-unit>
        <trans-unit id="9c247b36eae520ff5acf986006d217ce9ca4609a" translate="yes" xml:space="preserve">
          <source>Execute any unittests present. For each that fails, print the stack trace and continue.</source>
          <target state="translated">존재하는 모든 단위 테스트를 실행합니다. 실패한 각각에 대해 스택 추적을 인쇄하고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="9bf71057cfbf7879eaf07dde87aff1966a094423" translate="yes" xml:space="preserve">
          <source>Executed expressions may not reference any global or local static variables.</source>
          <target state="translated">실행 된 표현식은 전역 또는 로컬 정적 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f05efa3a0f330761f283964056bd4c437269064" translate="yes" xml:space="preserve">
          <source>Executes and returns one of a collection of handlers based on the type of the switch object.</source>
          <target state="translated">스위치 개체의 유형에 따라 처리기 모음 중 하나를 실행하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b2e599dd9da60b7076bf647f704ce6535a25f893" translate="yes" xml:space="preserve">
          <source>Executes the given program or shell command and returns its exit code and output.</source>
          <target state="translated">주어진 프로그램이나 쉘 명령을 실행하고 종료 코드와 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67781825ef8399fa41b8bb55aee1e69bf3a817d6" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by &lt;code&gt;Tid&lt;/code&gt;. The calling thread is designated as the owner of the new thread. When the owner thread terminates an &lt;code&gt;OwnerTerminated&lt;/code&gt; message will be sent to the new thread, causing an &lt;code&gt;OwnerTerminated&lt;/code&gt; exception to be thrown on &lt;code&gt;receive()&lt;/code&gt;.</source>
          <target state="translated">제공된 함수를 &lt;code&gt;Tid&lt;/code&gt; 로 표시되는 새로운 논리 스레드에서 실행합니다 . 호출 스레드는 새 스레드의 소유자로 지정됩니다. 소유자 스레드가 종료되면 &lt;code&gt;OwnerTerminated&lt;/code&gt; 메시지가 새 스레드로 전송되어 &lt;code&gt;receive()&lt;/code&gt; 에서 &lt;code&gt;OwnerTerminated&lt;/code&gt; 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="89a3e381c5ed655eb3aa0b9b587d8ce12bdc9bba" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by Tid. This new thread is linked to the calling thread so that if either it or the calling thread terminates a LinkTerminated message will be sent to the other, causing a LinkTerminated exception to be thrown on receive(). The owner relationship from spawn() is preserved as well, so if the link between threads is broken, owner termination will still result in an OwnerTerminated exception to be thrown on receive().</source>
          <target state="translated">Tid로 표시되는 새로운 논리 스레드에서 제공된 기능을 실행합니다. 이 새로운 스레드는 호출 스레드에 연결되므로 호출 스레드 또는 호출 스레드가 종료되면 LinkTerminated 메시지가 다른 메시지로 전송되어 receive ()에서 LinkTerminated 예외가 발생합니다. spawn ()의 소유자 관계도 유지되므로 스레드 간 링크가 끊어지면 소유자 종료로 인해 receive ()에서 OwnerTerminated 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a3ee996ad5df75a0a1bb42a960cc73553d41928" translate="yes" xml:space="preserve">
          <source>Executing functions via CTFE can take considerably longer than executing it at run time. If the function goes into an infinite loop, it will hang at compile time (rather than hanging at run time).</source>
          <target state="translated">CTFE를 통한 기능 실행은 런타임에 실행하는 것보다 상당히 오래 걸릴 수 있습니다. 함수가 무한 루프 상태가되면 런타임에 정지하지 않고 컴파일 타임에 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="b3ad6d830cba01933bdd4eadf0962b5afcdb48bf" translate="yes" xml:space="preserve">
          <source>Execution of a single thread on thread-local and immutable memory locations is</source>
          <target state="translated">스레드 로컬 및 변경 불가능한 메모리 위치에서 단일 스레드를 실행하는 것은</target>
        </trans-unit>
        <trans-unit id="5b3292962bd3ae1aa2ceee38161b97042acb69b4" translate="yes" xml:space="preserve">
          <source>Expand alias this tuples.</source>
          <target state="translated">이 튜플 별칭을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="dfc518ef6c3dabb73461eac4a36f80d62e55ffe4" translate="yes" xml:space="preserve">
          <source>Expand any response files in command line. Response files are arguments that look like: @NAME The name is first searched for in the environment. If it is not there, it is searched for as a file name. Arguments are separated by spaces, tabs, or newlines. These can be imbedded within arguments by enclosing the argument in '' or &quot;&quot;. Recursively expands nested response files.</source>
          <target state="translated">명령 행에서 응답 파일을 펼치십시오. 응답 파일은 다음과 같은 인수입니다. @NAME 환경에서 이름을 처음 검색합니다. 존재하지 않으면 파일 이름으로 검색됩니다. 인수는 공백, 탭 또는 줄 바꿈으로 구분됩니다. 인수는 ''또는 &quot;&quot;로 묶어 인수에 포함시킬 수 있습니다. 중첩 된 응답 파일을 재귀 적으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="39c5e7d251d329155aba4b991a2b7a09613fc576" translate="yes" xml:space="preserve">
          <source>Expand tuples.</source>
          <target state="translated">튜플을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="308231a343f14ac3d5860b3570b1a37c81713ba1" translate="yes" xml:space="preserve">
          <source>Expanded Data.</source>
          <target state="translated">확장 된 데이터.</target>
        </trans-unit>
        <trans-unit id="a3ed1860547be833e11502cb37798024cc995fdb" translate="yes" xml:space="preserve">
          <source>Expands &lt;code&gt;b&lt;/code&gt; by &lt;code&gt;delta&lt;/code&gt; bytes. If &lt;code&gt;delta == 0&lt;/code&gt;, succeeds without changing &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b is null&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt; (the null pointer cannot be expanded in place). Otherwise, &lt;code&gt;b&lt;/code&gt; must be a buffer previously allocated with the same allocator. If expansion was successful, &lt;code&gt;expand&lt;/code&gt; changes &lt;code&gt;b&lt;/code&gt;'s length to &lt;code&gt;b.length + delta&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Upon failure, the call effects no change upon the allocator object, leaves &lt;code&gt;b&lt;/code&gt; unchanged, and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 바이트로 &lt;code&gt;b&lt;/code&gt; 를 확장 합니다. 경우 &lt;code&gt;delta == 0&lt;/code&gt; , 변경없이 성공할 &lt;code&gt;b&lt;/code&gt; . 경우 &lt;code&gt;b is null&lt;/code&gt; , 반환 &lt;code&gt;false&lt;/code&gt; (널 포인터 위치에 확장 할 수 없습니다). 그렇지 않으면, &lt;code&gt;b&lt;/code&gt; 는 이전에 동일한 할당 자로 할당 된 버퍼 여야합니다. 확장이 성공하면, &lt;code&gt;expand&lt;/code&gt; 변경 &lt;code&gt;b&lt;/code&gt; 로의 길이 &lt;code&gt;b.length + delta&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; . 실패시, 호출자는 할당 자 객체에 변경 사항을 적용 하지 않고 &lt;code&gt;b&lt;/code&gt; 를 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d2b86b700bfa590be9e2b589c48ee8ac8959eaae" translate="yes" xml:space="preserve">
          <source>Expands a memory block in place and returns &lt;code&gt;true&lt;/code&gt; if successful. Implementations that don't support this primitive should always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메모리 블록을 제자리로 확장하고 성공하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이 프리미티브를 지원하지 않는 구현은 항상 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b262eee9273f1fc433f6691461d187672e0c5b45" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated.</source>
          <target state="translated">할당 된 블록을 제자리로 확장합니다. 블록이 마지막으로 할당 된 경우에만 확장이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="626d5a99aecb87499fb1f3a504d6e69914d2e4c6" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated. Defined only if &lt;code&gt;growDownwards&lt;/code&gt; is &lt;code&gt;No.growDownwards&lt;/code&gt;.</source>
          <target state="translated">할당 된 블록을 제자리로 확장합니다. 블록이 마지막으로 할당 된 경우에만 확장이 성공합니다. &lt;code&gt;growDownwards&lt;/code&gt; 가 &lt;code&gt;No.growDownwards&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb2e7f8c65f285e69f36d6abb516fbfe712839e3" translate="yes" xml:space="preserve">
          <source>Expands attribute declarations in members in depth first order. Calls dg(size_t symidx, Dsymbol *sym) for each member. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">멤버의 속성 선언을 깊이 우선적으로 확장합니다. 각 멤버에 대해 dg (size_t symidx, Dsymbol * sym)를 호출합니다. dg가! = 0을 리턴하면 중지하고 해당 값을 리턴하고 그렇지 않으면 0을 리턴합니다.이 함수를 사용하여 희미한 계산 및 N 번 getNth 호출의 O (N + N ^ 2 / 2) 복잡성을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="084a0336b3e0fa1cfbc75a4e2da9be624da8ae6d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;BitmappedBlock&lt;/code&gt;. If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, the expansion fails if the new length exceeds &lt;code&gt;theBlockSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitmappedBlock&lt;/code&gt; 에 의해 이전에 할당 된 버퍼를 확장합니다 . &lt;code&gt;No.multiblock&lt;/code&gt; 으로 인스턴스화 하면 새 길이가 &lt;code&gt;theBlockSize&lt;/code&gt; 초과하면 확장이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="797c11627b7043dd4bdb15c59a63cf420baa3b9d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;. Expansion fails if the new length exceeds the block size.</source>
          <target state="translated">&lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 에 의해 이전에 할당 된 버퍼를 확장합니다 . 새 길이가 블록 크기를 초과하면 확장이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="34de05ada292b06170f1d6656265bf476c629815" translate="yes" xml:space="preserve">
          <source>Expands or shrinks allocated block to an allocated size of &lt;code&gt; goodAllocSize(s)&lt;/code&gt;. Expansion occurs in place under the conditions required by &lt;code&gt;expand&lt;/code&gt;. Shrinking occurs in place if &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt;.</source>
          <target state="translated">할당 된 블록을 &lt;code&gt; goodAllocSize(s)&lt;/code&gt; 의 할당 된 크기로 확장하거나 축소 합니다. 확장에 필요한 조건 하에서 장소에 발생합니다 &lt;code&gt;expand&lt;/code&gt; . &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt; 경우 축소가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3ede9dbe92d17709e10217ef41b4cbf32ac479af" translate="yes" xml:space="preserve">
          <source>Expands the interval backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt;.</source>
          <target state="translated">시간 간격을 거꾸로 확장합니다. 효과적으로 &lt;code&gt;begin -= duration&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b57a74d337ac5a259427e1f3ea04c84032512812" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it adds the given number of months/years to end.</source>
          <target state="translated">시간 간격을 앞으로 및 / 또는 뒤로 확장합니다. 효과적으로, 주어진 개월 / 년 수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e16a1c93e572148be3e3c1e14d575c1803a317a6" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt; and/or &lt;code&gt;end += duration&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">시간 간격을 앞으로 및 / 또는 뒤로 확장합니다. 효과적으로 &lt;code&gt;begin -= duration&lt;/code&gt; 및 / 또는 &lt;code&gt;end += duration&lt;/code&gt; 합니다. 시간이 앞뒤로 확장되는지 여부는 dir에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6115ade81a85a7f10953103eafa7ac7f27f7341b" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt; and adds them to &lt;code&gt;end&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">시간 간격을 앞으로 및 / 또는 뒤로 확장합니다. 효과적으로 &lt;code&gt;begin&lt;/code&gt; 부터 주어진 개월 / 년 수를 빼고 &lt;code&gt;end&lt;/code&gt; 추가합니다 . 시간이 앞뒤로 확장되는지 여부는 dir에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8f900e50b202dc7b5f34257efaca3c038012cd3e" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt;.</source>
          <target state="translated">시간 간격을 앞으로 및 / 또는 뒤로 확장합니다. 효과적으로 &lt;code&gt;begin&lt;/code&gt; 부터 주어진 개월 / 년 수를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="316269b9bcff090b5279a8dfef454d19bf6429c9" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards in time. Effectively, it does &lt;code&gt;end += duration&lt;/code&gt;.</source>
          <target state="translated">시간 간격을 넓 힙니다. 효과적으로, 그것은 &lt;code&gt;end += duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc5691de73841ad488b58382733ae62e16cc0fbb" translate="yes" xml:space="preserve">
          <source>Expands to a named anchor used for hyperlinking to a particular declaration section. Argument &amp;amp;dollar;1 expands to the qualified declaration name.</source>
          <target state="translated">특정 선언 섹션에 대한 하이퍼 링크에 사용되는 명명 된 앵커로 확장됩니다. 인수 &amp;amp; dollar; 1은 규정 된 선언 이름으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="076b445912ca06b9147fd4ce226d6bbff02a82c5" translate="yes" xml:space="preserve">
          <source>Expands tuples in args in depth first order. Calls dg(void *ctx, size_t argidx, Parameter *arg) for each Parameter. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">깊이의 순서대로 args에서 튜플을 확장합니다. 각 매개 변수에 대해 dg (void * ctx, size_t argidx, Parameter * arg)를 호출합니다. dg가! = 0을 리턴하면 중지하고 해당 값을 리턴하고 그렇지 않으면 0을 리턴합니다.이 함수를 사용하여 희미한 계산 및 N 번 getNth 호출의 O (N + N ^ 2 / 2) 복잡성을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="bcedc51cce47a902790753d67bea2312fe893839" translate="yes" xml:space="preserve">
          <source>Experienced FORTRAN numerics programmers know that multidimensional &quot;rectangular&quot; arrays for things like matrix operations are much faster than trying to access them via pointers to pointers resulting from &quot;array of pointers to array&quot; semantics. For example, the D syntax:</source>
          <target state="translated">숙련 된 FORTRAN 숫자 프로그래머는 행렬 연산과 같은 것에 대한 다차원 &quot;직사각형&quot;배열이 &quot;배열에 대한 포인터 배열&quot;시맨틱에서 발생하는 포인터에 대한 포인터를 통해 배열에 액세스하는 것보다 훨씬 빠르다는 것을 알고 있습니다. 예를 들어 D 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06490b0b5dc2e6f349a0c0ddde37643f5a5ac75c" translate="yes" xml:space="preserve">
          <source>Experimental network access via the File interface</source>
          <target state="translated">File 인터페이스를 통한 실험적인 네트워크 액세스</target>
        </trans-unit>
        <trans-unit id="15a7ffb04c4605a09649beb118c20c17de19ede4" translate="yes" xml:space="preserve">
          <source>Explains the return value of the function. If the function returns &lt;b&gt;void&lt;/b&gt;, don't redundantly document it.</source>
          <target state="translated">함수의 반환 값을 설명합니다. 함수가 &lt;b&gt;void를&lt;/b&gt; 반환하면 중복으로 문서화하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="08c2201d6cdd5e0c73a89bc468a1c568ad04f452" translate="yes" xml:space="preserve">
          <source>Explicit Instantiation</source>
          <target state="translated">명시 적 인스턴스화</target>
        </trans-unit>
        <trans-unit id="20774c9957e71e2e463d16df16c4cfff77b34323" translate="yes" xml:space="preserve">
          <source>Explicit Template Instantiation</source>
          <target state="translated">명시 적 템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="fbaa54eaab210a4cb9cfc7d9c1378fcdc2b85e52" translate="yes" xml:space="preserve">
          <source>Explicit cast to bool. Useful as a shorthand for !(x.empty) in if and assert statements.</source>
          <target state="translated">부울로 명시 적 캐스트. if 및 assert 문에서! (x.empty)의 속기로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3d8f05eb6d48b04794152e7b23638cae9f48f278" translate="yes" xml:space="preserve">
          <source>Explicit suffixes</source>
          <target state="translated">명시 적 접미사</target>
        </trans-unit>
        <trans-unit id="a78d73b55b840cefe1a0a0daca2e42e60edecac9" translate="yes" xml:space="preserve">
          <source>Exponentiation &amp;amp; Logarithms</source>
          <target state="translated">지수와 로그</target>
        </trans-unit>
        <trans-unit id="1cd8e8a364673d3411b700d793c596d01bc2b145" translate="yes" xml:space="preserve">
          <source>Exposes the given root Array as a standard D array.</source>
          <target state="translated">지정된 루트 배열을 표준 D 배열로 노출합니다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="124e31831c2789749ceb9147facc91550d3ce84a" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b421f69102c781d75346243b5587cc88f90fb6" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e0&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;e0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7007fb43c92f8963b348d85ed11e388b0552e1c3" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e1&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;e1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f394df42c68efb7c3038933322adc5a961a6b555" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e60c9324dd44b217718e5d601d55424f1b4789b" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;earg1&lt;/code&gt;</source>
          <target state="translated">표현 &lt;code&gt;earg1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f910b8428605cbf862e3d1bb322d73f52f00aea1" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;elem&lt;/code&gt;</source>
          <target state="translated">표현 &lt;code&gt;elem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2346f54fcfa8df07417dbd8829090b55118464" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;emsg&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;emsg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cbf5e84e80504f53dddbdea7c64954b155cb357" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">표현 &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37aac93cf0d495815e578c5699ff35828cf6f52d" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;feaggr&lt;/code&gt;</source>
          <target state="translated">표현 &lt;code&gt;feaggr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a953ed52efeca5916127c7919696beebfa3bd1fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;firstArg&lt;/code&gt;</source>
          <target state="translated">식 &lt;code&gt;firstArg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="793cca28c8f3f384b396f7adfd08149a1c0bf195" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;instantiated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instantiated&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="4d6980b81fee04c7b5a70125a6146240a73039e9" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;original&lt;/code&gt;</source>
          <target state="translated">표현 &lt;code&gt;original&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0759ebb987367a96a51a5d1b5ffa1b699e18ec08" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt;(Expression e, int result, bool keepLvalue);</source>
          <target state="translated">발현 &lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt; (식 e, 정수 결과, bool keepLvalue);</target>
        </trans-unit>
        <trans-unit id="e7eb0ac731fa465a7e553c45917e50e97836c4c4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">식 &lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt; (Scope * sc);</target>
        </trans-unit>
        <trans-unit id="79e7a3e2a6b6bb028e3dee36c35a16bbcac64b57" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt;(ref const Loc loc, Scope* sc, AggregateDeclaration ad, VarDeclaration vthis);</source>
          <target state="translated">표현식 &lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt; (ref const Loc loc, Scope * sc, AggregateDeclaration ad, VarDeclaration vthis 참조);</target>
        </trans-unit>
        <trans-unit id="c7de6a20914bd0188b326ef7d4369047d4127694" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinAssignExp e, Scope* sc);</source>
          <target state="translated">식 &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt; (BinAssignExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="38cbef71fac259fb3e5addd6010c78720766a7e4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">발현 &lt;strong id=&quot;arrayOp&quot;&gt;어레이 연산&lt;/strong&gt; (BinExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="d05e7a6332b506aff76d8910b31057f52e8e38f0" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;basis&quot;&gt;basis&lt;/strong&gt;;</source>
          <target state="translated">발현 &lt;strong id=&quot;basis&quot;&gt;기초&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ce914de3f03e3182cbb394d12e8e44d61e13a1f4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">발현 &lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt; (BinExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="07cd4a6028fc596b40b13d6d0458444d8de8c8ab" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;build_overload&quot;&gt;build_overload&lt;/strong&gt;(ref const Loc loc, Scope* sc, Expression ethis, Expression earg, Dsymbol d);</source>
          <target state="translated">표현식 &lt;strong id=&quot;build_overload&quot;&gt;빌드 오버로드&lt;/strong&gt; (참조 const Loc loc, Scope * sc, Expression ethis, Expression earg, Dsymbol d);</target>
        </trans-unit>
        <trans-unit id="6871fa1d9cef9535c1f853ab6b02a766a657fbfb" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;castTo&quot;&gt;castTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">발현 &lt;strong id=&quot;castTo&quot;&gt;캐스트 토&lt;/strong&gt; (Expression e, Scope * sc, 타입 t);</target>
        </trans-unit>
        <trans-unit id="2b45466acfd0d3d2ded6118c9809d1350d706c46" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">식 &lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt; (식 e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="3411c26ed41d2305da3a489d8bf4719326ae9f77" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;condition&quot;&gt;condition&lt;/strong&gt;;</source>
          <target state="translated">발현 &lt;strong id=&quot;condition&quot;&gt;조건&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e6931cb91b1ae0e41a9ee765db1152dfb33ce0d4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt;(Expression e);</source>
          <target state="translated">발현 &lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="f1f6d0f109e3e21ea56ab0c366d0d61e14ee4c7d" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt;(Type mt, ref const Loc loc);</source>
          <target state="translated">표현식 &lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt; (Type mt, ref const Loc loc);</target>
        </trans-unit>
        <trans-unit id="d97a47c0800d46fd3cd2e538e048bb178e515f0c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt;(ref const Loc loc);</source>
          <target state="translated">표현식 &lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt; (ref const Loc loc 참조);</target>
        </trans-unit>
        <trans-unit id="0a092a26bbbc3c916453f449b7418f845d33b41c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt;(Scope* sc, Expression e, Type t = null);</source>
          <target state="translated">식 &lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt; (Scope * sc, 식 e, 유형 t = null);</target>
        </trans-unit>
        <trans-unit id="34a3fc99823ccdc5563fe45ca6f4cc54c969827f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt;(Type mt, Scope* sc, Expression e, Identifier ident, int flag);</source>
          <target state="translated">Expression &lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt; (Type mt, Scope * sc, Expression e, Identifier ident, int flag);</target>
        </trans-unit>
        <trans-unit id="192530034d665cef7795047e56ecf307c8762064" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt;(Loc loc, FuncDeclaration fd, Expressions* arguments);</source>
          <target state="translated">&lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt; 식 (Loc loc, FuncDeclaration fd, Expressions * arguments);</target>
        </trans-unit>
        <trans-unit id="80a303e71b3ae3f7d7217b7e5618f20dbd2535a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">발현 &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6eb2e3ce9ac3932da76f3de31bbf848ad262e34e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt;(int result, VarDeclaration v);</source>
          <target state="translated">expression &lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt; (int 결과, VarDeclaration v);</target>
        </trans-unit>
        <trans-unit id="dfb3029a50e65b9de4b512fbdb1d29b5615172e3" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt;(Scope* sc, const char* name, ref Expression e0, Expression e, bool alwaysCopy = false);</source>
          <target state="translated">Expression &lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt; (Scope * sc, const char * 이름, ref Expression e0, Expression e, bool alwaysCopy = false);</target>
        </trans-unit>
        <trans-unit id="efcc60927be71d26c3c816535424c83c4bde8e5a" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt;(Type type, uint offset);</source>
          <target state="translated">표현식 &lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt; (유형 유형, uint 오프셋);</target>
        </trans-unit>
        <trans-unit id="5c869349f6aded66c0c7140fab666e82c3d45d29" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt;(ref const Loc loc, Identifier id);</source>
          <target state="translated">식 &lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt; (참조 const Loc loc, 식별자 id);</target>
        </trans-unit>
        <trans-unit id="cf05303975b50b18a00371bfbf097a643287e833" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt;(Type t, ref const Loc loc, Identifier ident, int flag);</source>
          <target state="translated">식 &lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt; (타입 t, 참조 const Loc loc, 식별자 ident, int 플래그);</target>
        </trans-unit>
        <trans-unit id="1ed9d54715957ffd3217c453236ae0352ea8d40c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt;(const(char)* name, ref const Loc loc);</source>
          <target state="translated">식 &lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt; (const (char) * 이름, 참조 const Loc loc);</target>
        </trans-unit>
        <trans-unit id="a06617afbe33da227ef8899ec1e3a2bf9eda75fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, AggregateDeclaration ad, Expression e1, Type t, Dsymbol var, bool flag = false);</source>
          <target state="translated">Expression &lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt; (참조 const Loc loc, Scope * sc, Dsymbol s, AggregateDeclaration ad, Expression e1, Type t, Dsymbol var, bool flag = false 참조);</target>
        </trans-unit>
        <trans-unit id="5182dc71276170cd9c912e2c20da5b0104e0baed" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt;;</source>
          <target state="translated">표현식 &lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6002f1b5688ee38493cb8bf57b584c7ad904867f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">&lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt; 표현식 (식 e, Scope * sc, 타입 t);</target>
        </trans-unit>
        <trans-unit id="d9fbd63977c9b0f6b381d61e7486228255c3141c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Expression e, Type t, int flag = 0);</source>
          <target state="translated">표현식 &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt; (식 e, 유형 t, int 플래그 = 0);</target>
        </trans-unit>
        <trans-unit id="e4eed1230d55b4f7ffdb0f2946ec6b81e685c4d5" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt;(Initializer init, Type itype = null);</source>
          <target state="translated">Expression &lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt; (초기화 기 초기화, 유형 itype = null);</target>
        </trans-unit>
        <trans-unit id="9fd9077340336bbdc42e5a0e55ae876cf74bf052" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">식 &lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt; (식 e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="a93d5e116a77484a91fb6b2216ee9f2c3ab792bc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;integralPromotions&quot;&gt;integralPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">발현 &lt;strong id=&quot;integralPromotions&quot;&gt;적분 프로모션&lt;/strong&gt; (Expression e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="119f4b90e73b2490c0b337b5c2892ee45abe1b1b" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt;(Expression e, Scope* sc, TOK* pop = null);</source>
          <target state="translated">식 &lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt; (식 e, Scope * sc, TOK * pop = null);</target>
        </trans-unit>
        <trans-unit id="ce92783572475e6e71bead0fd27548b7a7fa8d60" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveLoc&quot;&gt;resolveLoc&lt;/strong&gt;(ref const Loc loc, Scope* sc);</source>
          <target state="translated">표현식 &lt;strong id=&quot;resolveLoc&quot;&gt;resolveLoc&lt;/strong&gt; (참조 const Loc loc, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="20d217b5757071adb84549bfb94bd0bc8a5ef317" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, Expression* pe0);</source>
          <target state="translated">식 &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt; (적용 범위 SC, ArrayExp AE 표현 * PE0);</target>
        </trans-unit>
        <trans-unit id="35eac18ed0785aafed68f419dd6c566022d1d5a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* pe0);</source>
          <target state="translated">표현 &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt; (범위 * 사우스 캐롤라이나, ArrayExp AE, IntervalExp 즉, 표현 * PE0);</target>
        </trans-unit>
        <trans-unit id="24fb0ae31138927857d9517f368cb6748955cf0f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolvePropertiesOnly&lt;/strong&gt;(Scope* sc, Expression e1);</source>
          <target state="translated">Expression &lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolvePropertiesOnly&lt;/strong&gt; (Scope * sc, Expression e1);</target>
        </trans-unit>
        <trans-unit id="9f1dd720666b1ebbdeaf1330037ca49680382277" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveSlice&quot;&gt;resolveSlice&lt;/strong&gt;(Expression e, UnionExp* pue = null);</source>
          <target state="translated">표현식 &lt;strong id=&quot;resolveSlice&quot;&gt;resolveSlice&lt;/strong&gt; (표현식 e, UnionExp * pue = null);</target>
        </trans-unit>
        <trans-unit id="399afa038530894af01c66997652832c22521978" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">발현 &lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt; (BinExp be, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="79986118a4e6a934ff5fac083ee5a2d91f44d14e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt;(Dsymbol s, ref const Loc loc, Scope* sc, bool hasOverloads);</source>
          <target state="translated">Expression &lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt; (심볼 s, 참조 const Loc loc, Scope * sc, bool hasOverloads);</target>
        </trans-unit>
        <trans-unit id="ffc4deb0c336cdfa09b1452db6e63631f5d4122f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;toAssocArrayLiteral&lt;/strong&gt;(ArrayInitializer ai);</source>
          <target state="translated">&lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;AssocArrayLiteral에 대한&lt;/strong&gt; 발현 (ArrayInitializer ai);</target>
        </trans-unit>
        <trans-unit id="c6bce8f2be572a14af244cca194d546909ce6bb7" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">Expression &lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt; (Scope * sc);</target>
        </trans-unit>
        <trans-unit id="bdb106e8f5a606a6dce675cd4ddbebbc5666068f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toDelegate&quot;&gt;toDelegate&lt;/strong&gt;(Expression e, Type t, Scope* sc);</source>
          <target state="translated">&lt;strong id=&quot;toDelegate&quot;&gt;위임&lt;/strong&gt; 식 (식 e, 타입 t, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="6cdc4080dafbc4371980fa1b4330711247ff8eee" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt;(Scope* sc, Expression e);</source>
          <target state="translated">식 &lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt; (적용 범위 (SC), 식 E);</target>
        </trans-unit>
        <trans-unit id="6c7b6596f94002291db7dced4938937fd23206f2" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt;(Expression exp, Scope* sc);</source>
          <target state="translated">표현 &lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt; (표현식 exp, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="2c47e576a24251679ce842e21fa63efaeebfa5ca" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeCombine&quot;&gt;typeCombine&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">발현 &lt;strong id=&quot;typeCombine&quot;&gt;유형 조합&lt;/strong&gt; (BinExp be, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="590987c28b7350e9354ffa20860fe52c9ed58235" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt;(Type t);</source>
          <target state="translated">식 &lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt; (Type t);</target>
        </trans-unit>
        <trans-unit id="6e7f226bf5b1c59c07426bc48bf791f755e82872" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;unaSemantic&quot;&gt;unaSemantic&lt;/strong&gt;(UnaExp e, Scope* sc);</source>
          <target state="translated">표현 비의 &lt;strong id=&quot;unaSemantic&quot;&gt;미적&lt;/strong&gt; (UnaExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="25e7bb0649743e5711f99aca2d79a2a5b5648501" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;valueNoDtor&quot;&gt;valueNoDtor&lt;/strong&gt;(Expression e);</source>
          <target state="translated">발현 값 &lt;strong id=&quot;valueNoDtor&quot;&gt;NoDtor&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="bf3f22e25aac5a5716bd2ddc48521dc242830fb5" translate="yes" xml:space="preserve">
          <source>Expression Parser</source>
          <target state="translated">식 파서</target>
        </trans-unit>
        <trans-unit id="d9c4f2202566f51697b377f90555653846292193" translate="yes" xml:space="preserve">
          <source>Expression Statement</source>
          <target state="translated">표현 문</target>
        </trans-unit>
        <trans-unit id="eabfa2441c13d974e2af574b0d99a70f4bb9a0d6" translate="yes" xml:space="preserve">
          <source>Expression for the requested targetInfo</source>
          <target state="translated">요청 된 targetInfo에 대한 표현식</target>
        </trans-unit>
        <trans-unit id="6063917999bbfe2ce9b3fa075874599a6ebc96e5" translate="yes" xml:space="preserve">
          <source>Expression representing the &lt;code&gt;this&lt;/code&gt; for the var</source>
          <target state="translated">var에 &lt;code&gt;this&lt;/code&gt; 나타내는 표현</target>
        </trans-unit>
        <trans-unit id="df6caa2f45ca5f6946eb55c0501e737ddb8bf27f" translate="yes" xml:space="preserve">
          <source>Expression to convert</source>
          <target state="translated">변환 할 표현</target>
        </trans-unit>
        <trans-unit id="cf9f917167bd00b70d460bca475535ddcbe6fc7e" translate="yes" xml:space="preserve">
          <source>Expression to determine cost of</source>
          <target state="translated">비용을 결정하는 표현</target>
        </trans-unit>
        <trans-unit id="2f055d0b3e4b8725a9090bf4d8f45363b46775b9" translate="yes" xml:space="preserve">
          <source>Expression to look at</source>
          <target state="translated">보는 표정</target>
        </trans-unit>
        <trans-unit id="fbcc420f7af639d45c5081500755a47ce6367c0a" translate="yes" xml:space="preserve">
          <source>Expression which expected as a string</source>
          <target state="translated">문자열로 예상되는 표현</target>
        </trans-unit>
        <trans-unit id="d8e5fdfc95019b0e8b971e0729223c011b90611f" translate="yes" xml:space="preserve">
          <source>Expression* &lt;code&gt;pe&lt;/code&gt;</source>
          <target state="translated">표현 * &lt;code&gt;pe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bc014e6d10451a8147b649b688eca472ffab8da" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">식 [] &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7feaf7d6885e2aeae1d7088bcce98f228aa60c" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">식 [] &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="17b61fb742fe0544a0738e346e8b68266f8e6c2c" translate="yes" xml:space="preserve">
          <source>Expressions and statements may create and/or consume rvalues. Such values are called</source>
          <target state="translated">표현과 문장은 rvalue를 생성 및 / 또는 소비 할 수 있습니다. 이러한 가치는</target>
        </trans-unit>
        <trans-unit id="827d05e6a3f1241aa29022321190716d0bac015a" translate="yes" xml:space="preserve">
          <source>Expressions are used to compute values with a resulting type. These values can then be assigned, tested, or ignored. Expressions can also have side effects.</source>
          <target state="translated">표현식은 결과 유형으로 값을 계산하는 데 사용됩니다. 그런 다음이 값을 할당, 테스트 또는 무시할 수 있습니다. 식에도 부작용이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="213f37939286b76ce58e9d750cb8625a9de8b877" translate="yes" xml:space="preserve">
          <source>Expressions connected by commas</source>
          <target state="translated">쉼표로 연결된 표현식</target>
        </trans-unit>
        <trans-unit id="eeda38d97c1591b472912826aeaaf79dee7875cf" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;a != b&lt;/code&gt; are rewritten as &lt;code&gt;!(a == b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a != b&lt;/code&gt; 형식 의 표현식은 &lt;code&gt;!(a == b)&lt;/code&gt; 로 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9790c7ed767b515e2db3f5032fee145b7d8f3f2d" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;arr[&lt;/code&gt;</source>
          <target state="translated">폼의 식 &lt;code&gt;arr[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="296ed9970d463ab72dec34118964f9a6a98b21b4" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless the are cast to void.</source>
          <target state="translated">&lt;code&gt;(x + x)&lt;/code&gt; 와 같이 효과가없는 표현식은 무효화되지 않는 한 표현식 명령문으로 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13135cffec267a2714ee700a44376c037a46555b" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless they are cast to void.</source>
          <target state="translated">&lt;code&gt;(x + x)&lt;/code&gt; 와 같이 효과가없는 표현식은 void로 캐스트되지 않는 한 표현식 문으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d9ba85aff37987e9f1d9fafb80136e7c416676a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;elements&lt;/code&gt;</source>
          <target state="translated">표현식 * &lt;code&gt;elements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="137b1c280f96de72078b78ad7d25efffd1250b2a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;exps&lt;/code&gt;</source>
          <target state="translated">식 * &lt;code&gt;exps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87db2601150b379b388e1556ff809504a78b747" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;fargs&lt;/code&gt;</source>
          <target state="translated">식 * &lt;code&gt;fargs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e0b234b24cbc1fb165bd79fe8e05526407f3b36" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">표현식 * &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd03daa888a0e583ceb40e2e00dacb30660a10cc" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;elements&quot;&gt;elements&lt;/strong&gt;;</source>
          <target state="translated">표현식 * &lt;strong id=&quot;elements&quot;&gt;요소&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="37783cf5e7c87b4f591a55d79dbb7ea52f941431" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt;;</source>
          <target state="translated">식 * &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="026b50f17d896e63ced46249a059380f8e6cbae1" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt;;</source>
          <target state="translated">식 * &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b7c9df0f13515170e90ad55a4b53a6f772217b57" translate="yes" xml:space="preserve">
          <source>Extend an array &lt;code&gt;px&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements. Caller must initialize those elements.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 요소 로 배열 &lt;code&gt;px&lt;/code&gt; 를 확장합니다 . 호출자는 해당 요소를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d9ec6e863a0af2e6c6f8b6330f856c27efe720" translate="yes" xml:space="preserve">
          <source>Extend an array by n elements. Caller must initialize those elements.</source>
          <target state="translated">n 개의 요소만큼 배열을 확장합니다. 호출자는 해당 요소를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5d8573dd5bcf3e6c45847ffd98818bf7ecfc27" translate="yes" xml:space="preserve">
          <source>Extend may also be used to extend slices (or memory blocks with &lt;a href=&quot;#APPENDABLE&quot;&gt;&lt;code&gt;APPENDABLE&lt;/code&gt;&lt;/a&gt; info). However, use the return value only as an indicator of success. &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; should be used to retrieve actual usable slice capacity.</source>
          <target state="translated">확장은 슬라이스 (또는 &lt;a href=&quot;#APPENDABLE&quot;&gt; &lt;code&gt;APPENDABLE&lt;/code&gt; &lt;/a&gt; 정보가있는 메모리 블록)를 확장하는 데에도 사용될 수 있습니다 . 그러나 리턴 값을 성공의 지표로만 사용하십시오. 실제로 사용 가능한 슬라이스 용량을 검색하려면 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="43ee2587f2dee7414c6f7fffb20316fc7cc9240d" translate="yes" xml:space="preserve">
          <source>Extend the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the end of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then the contents of &lt;code&gt;r&lt;/code&gt; are returned.</source>
          <target state="translated">요소 &lt;code&gt;e&lt;/code&gt; 로 범위의 끝을 채워서 입력 범위 &lt;code&gt;r&lt;/code&gt; 의 길이를 연장하십시오 . 요소 &lt;code&gt;e&lt;/code&gt; 는 &lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; 에&lt;/a&gt; 정의 된대로 범위 &lt;code&gt;r&lt;/code&gt; 의 요소 유형과 공통 유형이어야합니다 . 경우 &lt;code&gt;n&lt;/code&gt; 이 의의 길이보다 작은 &lt;code&gt;r&lt;/code&gt; , 다음의 내용을 &lt;code&gt;r&lt;/code&gt; 은 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa833620006d2c6c6571801ae931036999a293ae" translate="yes" xml:space="preserve">
          <source>Extend, shrink or allocate a new block of memory keeping the contents of an existing block</source>
          <target state="translated">기존 블록의 내용을 유지하면서 새로운 메모리 블록을 확장, 축소 또는 할당</target>
        </trans-unit>
        <trans-unit id="1f14c54998b149072f5f4807010db7ef4def6435" translate="yes" xml:space="preserve">
          <source>ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9b77ddd59e96e949c32c9e07059de1e0868c54d" translate="yes" xml:space="preserve">
          <source>Extender</source>
          <target state="translated">Extender</target>
        </trans-unit>
        <trans-unit id="ca6a41cfa1be0460478758700e28ed97e69b6db4" translate="yes" xml:space="preserve">
          <source>Extends the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the start of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then &lt;code&gt;r&lt;/code&gt; is returned unmodified.</source>
          <target state="translated">요소 &lt;code&gt;e&lt;/code&gt; 로 범위의 시작을 채워서 입력 범위 &lt;code&gt;r&lt;/code&gt; 의 길이를 연장합니다 . 요소 &lt;code&gt;e&lt;/code&gt; 는 &lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; 에&lt;/a&gt; 정의 된대로 범위 &lt;code&gt;r&lt;/code&gt; 의 요소 유형과 공통 유형이어야합니다 . 경우 &lt;code&gt;n&lt;/code&gt; 은 의 길이보다 작은 &lt;code&gt;r&lt;/code&gt; 후, &lt;code&gt;r&lt;/code&gt; 수정되지 않은 리턴된다.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="006d500cd51d10312fee9a378180dd1c0dbff085" translate="yes" xml:space="preserve">
          <source>Extension to add (should not include '.')</source>
          <target state="translated">추가 할 확장자 ( '.'를 포함하지 않아야 함)</target>
        </trans-unit>
        <trans-unit id="6482035493770d2e055c43b47e6d26c77dd6c0ef" translate="yes" xml:space="preserve">
          <source>Extern Declarations</source>
          <target state="translated">외계인 선언</target>
        </trans-unit>
        <trans-unit id="d4c9ef3b0f468eee8df0924f820ebf154b375ffb" translate="yes" xml:space="preserve">
          <source>External functions don't have a function body visible to the compiler:</source>
          <target state="translated">외부 함수에는 컴파일러에서 볼 수있는 함수 본문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3748f7f3cb478d80788fa4224db3fc0a78eefd90" translate="yes" xml:space="preserve">
          <source>ExternallyMangledName</source>
          <target state="translated">ExternallyMangledName</target>
        </trans-unit>
        <trans-unit id="346cbbedcd46a1663dd5b1cc744bd9a949537eb2" translate="yes" xml:space="preserve">
          <source>Extra characters were found after the end of the domain literal</source>
          <target state="translated">도메인 리터럴 끝 이후에 추가 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">테이블 열에 대한 메타 데이터 추출</target>
        </trans-unit>
        <trans-unit id="9faa5d876b6179e6ba25ab15280e90240372d01c" translate="yes" xml:space="preserve">
          <source>Extract an integral payload from a NAN.</source>
          <target state="translated">NAN에서 통합 페이로드를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2c4b7673b033687b78b5842c4817a13b02fefd97" translate="yes" xml:space="preserve">
          <source>Extract information about types and symbols at compile time.</source>
          <target state="translated">컴파일시 유형 및 기호에 대한 정보를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="f06fb7685dce7967eb2226a2da1b90f2b56a47a7" translate="yes" xml:space="preserve">
          <source>Extract object previously wrapped by &lt;a href=&quot;#wrap&quot;&gt;&lt;code&gt;wrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#wrap&quot;&gt; &lt;code&gt;wrap&lt;/code&gt; 에&lt;/a&gt; 의해 이전에 랩핑 된 오브젝트를 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd69f2de6f5ccb7abb3ebb23adba928b9189680b" translate="yes" xml:space="preserve">
          <source>Extracting keys or values from an associative array</source>
          <target state="translated">연관 배열에서 키 또는 값 추출</target>
        </trans-unit>
        <trans-unit id="33b53849a6a696afc1cd80915cbb26c701295344" translate="yes" xml:space="preserve">
          <source>Extracts the exponent of x as a signed integral value.</source>
          <target state="translated">x의 지수를 부호있는 정수 값으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f72287d204f2105b0fd97e600ee98c5cba938ca4" translate="yes" xml:space="preserve">
          <source>Extracts the norm of a complex number.</source>
          <target state="translated">복소수의 노름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="92e79f4fb4307210226b4892ad6cd4e88db84d8e" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193f1d2a7d28460babdd5dae282bd85494298779" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fp&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;fp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24cceb382e88b5a613ffd52b108c408d0048ef0f" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a08f0857a21894d4669365254c28abd314ff69d5" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(F, uint N)(ref scope const F[N] a, ref scope const F[N] b)</source>
          <target state="translated">F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt; (F, uint N) (참조 범위 const F [N] a, 참조 범위 const F [N] b)</target>
        </trans-unit>
        <trans-unit id="2667ca0e687195a6570d57ab0089486c7bee46ff" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedSimilarity&lt;/strong&gt;(alias comp = &quot;a == b&quot;, R1, R2, F)(R1 s, R2 t, F lambda)</source>
          <target state="translated">F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedSimilarity&lt;/strong&gt; (별칭 comp = &quot;a == b&quot;, R1, R2, F) (R1 s, R2 t, F 람다)</target>
        </trans-unit>
        <trans-unit id="fe6176f13577b4b75c6e15efab6754698b9c3bee" translate="yes" xml:space="preserve">
          <source>FE FF</source>
          <target state="translated">FE FF</target>
        </trans-unit>
        <trans-unit id="3e02b936dfd78b3c5ebed8632cb4cc204b3750a2" translate="yes" xml:space="preserve">
          <source>FF FE</source>
          <target state="translated">FF FE</target>
        </trans-unit>
        <trans-unit id="c498915b8f02917da6f0c028707f1c34277fe255" translate="yes" xml:space="preserve">
          <source>FF FE 00 00</source>
          <target state="translated">FF FE 00 00</target>
        </trans-unit>
        <trans-unit id="d2a0477ef856e83464b14c113e56b5dc50816ccb" translate="yes" xml:space="preserve">
          <source>FILE* &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="translated">FILE * &lt;code&gt;stream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2605a67597f1a10f5c96696e2424ee2db911144" translate="yes" xml:space="preserve">
          <source>FILETIME* &lt;code&gt;ft&lt;/code&gt;</source>
          <target state="translated">FILETIME * &lt;code&gt;ft&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="716c88fa55348f124b797e571db1aebe854236a3" translate="yes" xml:space="preserve">
          <source>FIPS PUB180-2</source>
          <target state="translated">FIPS PUB180-2</target>
        </trans-unit>
        <trans-unit id="1267dff51655e0a3bdc33fc1076bec75984a3f57" translate="yes" xml:space="preserve">
          <source>FLAGS /////////////////////////////////////</source>
          <target state="translated">플래그 //////////////////////////////////////////</target>
        </trans-unit>
        <trans-unit id="e96a8a604f9b6179e311fa3d5f24abcd71fc841e" translate="yes" xml:space="preserve">
          <source>FNMATCH_FUNCTION user pointer</source>
          <target state="translated">FNMATCH_FUNCTION 사용자 포인터</target>
        </trans-unit>
        <trans-unit id="cd00fd89694c9543bbff899304d998d7ecf5294f" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="0d8442da2a84281783f8838ad22bc5dbea8b7a72" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f033c2d3e8e972e4ef1768896ccae5d11b59035e" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="33526cf6b3de29bbe86a32df97a3317f13177146" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0</source>
          <target state="translated">FP_ILOGB0</target>
        </trans-unit>
        <trans-unit id="3ca2eaac7e96ce045c763f71e8ad21f82a4121ef" translate="yes" xml:space="preserve">
          <source>FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="acb28212fba0272ee990cebd571ebe09b463312e" translate="yes" xml:space="preserve">
          <source>FTP</source>
          <target state="translated">FTP</target>
        </trans-unit>
        <trans-unit id="efd9df5bd03a5bb6ecc42cd9b76d43f3c4b84813" translate="yes" xml:space="preserve">
          <source>FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="a156047c4af729c2fac38d529049b3b9938c1d8f" translate="yes" xml:space="preserve">
          <source>FTP Option that causes missing dirs to be created on the remote server. In 7.19.4 we introduced the convenience enums for this option using the CURLFTP_CREATE_DIR prefix.</source>
          <target state="translated">원격 서버에서 누락 된 디렉토리가 작성되게하는 FTP 옵션. 7.19.4에서는 CURLFTP_CREATE_DIR 접두사를 사용하여이 옵션의 편의 열거를 소개했습니다.</target>
        </trans-unit>
        <trans-unit id="fbfe183e82b68040592bf183fc081e933272629b" translate="yes" xml:space="preserve">
          <source>FTP access to the specified url.</source>
          <target state="translated">지정된 URL에 대한 FTP 액세스</target>
        </trans-unit>
        <trans-unit id="79d1ddd73bbfe55930046d43cf864f9b3aca2fb2" translate="yes" xml:space="preserve">
          <source>FTP client functionality.</source>
          <target state="translated">FTP 클라이언트 기능.</target>
        </trans-unit>
        <trans-unit id="296657dabd1e7526b0c3bd8986b54a229ec9f74e" translate="yes" xml:space="preserve">
          <source>FTP option that changes the timeout, in seconds, associated with getting a response. This is different from transfer timeout time and essentially places a demand on the FTP server to acknowledge commands in a timely manner.</source>
          <target state="translated">응답 받기와 관련된 시간 초과를 초 단위로 변경하는 FTP 옵션. 이는 전송 시간 초과 시간과 다르며 FTP 서버에 명령을 적시에 승인하도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="1e9d5102532c80cabb71bedd22459f048605a2a0" translate="yes" xml:space="preserve">
          <source>FUNCFLAG.xxxxx</source>
          <target state="translated">FUNCFLAG.xxxxx</target>
        </trans-unit>
        <trans-unit id="04a22d510848e72d972438b2303f4bb0f8cefe40" translate="yes" xml:space="preserve">
          <source>F[] &lt;strong id=&quot;uniformDistribution&quot;&gt;uniformDistribution&lt;/strong&gt;(F = double)(size_t n, F[] useThis = null)</source>
          <target state="translated">F [] &lt;strong id=&quot;uniformDistribution&quot;&gt;균일 분포&lt;/strong&gt; (F = double) (size_t n, F [] useThis = null)</target>
        </trans-unit>
        <trans-unit id="885d20f30c6997f28727cb3b1c03c026a0423304" translate="yes" xml:space="preserve">
          <source>Facilities for random number generation.</source>
          <target state="translated">난수 생성 기능.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="9d80a11d6c9cd9d8129231038cc99dcf9cfe6c31" translate="yes" xml:space="preserve">
          <source>Fails: char[] has mutable aliasing.</source>
          <target state="translated">실패 : char []에 변경 가능한 앨리어싱이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca23f275cf26c43dc6cb80deec7cc73ebd0d6be" translate="yes" xml:space="preserve">
          <source>Fake a struct symbol.</source>
          <target state="translated">구조체 심볼을 가짜로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f92a31e5dc809226adfcdd7266d92ffe4d097f29" translate="yes" xml:space="preserve">
          <source>Fake class which holds the thrown exception. Used for implementing exception handling.</source>
          <target state="translated">던져진 예외를 유지하는 가짜 클래스. 예외 처리를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="187b6d7e012db85d9f53b228f8b221e037e5b215" translate="yes" xml:space="preserve">
          <source>Fallback &lt;strong id=&quot;fallback&quot;&gt;fallback&lt;/strong&gt;;</source>
          <target state="translated">폴백 &lt;strong id=&quot;fallback&quot;&gt;폴백&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1d00915c3eb36b1f76efd0ec12a2e2bfdb9c88e2" translate="yes" xml:space="preserve">
          <source>FallbackAllocator!(Primary, Fallback) &lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt;(Primary, Fallback)(auto ref Primary p, auto ref Fallback f);</source>
          <target state="translated">FallbackAllocator! (기본, 대체) &lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt; (기본, 대체) (자동 참조 기본 p, 자동 참조 대체 f);</target>
        </trans-unit>
        <trans-unit id="5d505b3f95c1c85d725f5b643bd03f8f11c638e3" translate="yes" xml:space="preserve">
          <source>Families of transcendental functions.</source>
          <target state="translated">초월적인 기능의 가족.</target>
        </trans-unit>
        <trans-unit id="c15afdf4366c1e5e116d4655301026b41771feaa" translate="yes" xml:space="preserve">
          <source>Family of this address.</source>
          <target state="translated">이 주소의 가족.</target>
        </trans-unit>
        <trans-unit id="9784de560abfd12a3df7edbfce43582579bd83ea" translate="yes" xml:space="preserve">
          <source>Fast Alias</source>
          <target state="translated">빠른 별명</target>
        </trans-unit>
        <trans-unit id="b30639e5d7da09380f8d189ea58cefd7706fb2d8" translate="yes" xml:space="preserve">
          <source>Fast Integer Overflow Checks</source>
          <target state="translated">빠른 정수 오버플로 검사</target>
        </trans-unit>
        <trans-unit id="0b12a136aeae505dcc0b7dbbf0dd96b9dfb9b43f" translate="yes" xml:space="preserve">
          <source>Fast implementation of SHA1</source>
          <target state="translated">SHA1의 빠른 구현</target>
        </trans-unit>
        <trans-unit id="f52bc5a79d93a586d9fd5f867d9e97fd2c1e94ed" translate="yes" xml:space="preserve">
          <source>Fast power modulus calculation for &lt;a href=&quot;#BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; operands.</source>
          <target state="translated">&lt;a href=&quot;#BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 피연산자에 대한 빠른 전력 계수 계산 .</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="5e04f2d50cdd060bbfcbfee4c55990dc2c53ebb6" translate="yes" xml:space="preserve">
          <source>Feeds a piece of data into the hash computation. This method allows the type to be used as an &lt;a href=&quot;std_range#OutputRange&quot;&gt;&lt;code&gt;std.range.OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해시 계산에 데이터를 공급합니다. 이 메소드를 사용하면 유형을 &lt;a href=&quot;std_range#OutputRange&quot;&gt; &lt;code&gt;std.range.OutputRange&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef2e953b973aaaad728788af9fe005332250cfb9" translate="yes" xml:space="preserve">
          <source>Fetch a range that spans all the elements in the container.</source>
          <target state="translated">컨테이너의 모든 요소에 걸쳐있는 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="806c6077cb7a78f983cf9f3141f3488ff76bfb62" translate="yes" xml:space="preserve">
          <source>Fetch a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have the given hangul syllable type.</source>
          <target state="translated">주어진 한글 음절 형식이있는 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 세트를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="f82305ed0f65639966ae3ed3933a92d710f2e1b5" translate="yes" xml:space="preserve">
          <source>Fetches a portion of the container from key &lt;code&gt;a&lt;/code&gt; to key &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">컨테이너의 일부를 키 &lt;code&gt;a&lt;/code&gt; 에서 키 &lt;code&gt;b&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="25fd3d77a2c1246116e41ea65fe998403f8ec08d" translate="yes" xml:space="preserve">
          <source>Fiber which embeds a ThreadInfo</source>
          <target state="translated">ThreadInfo를 포함하는 Fiber</target>
        </trans-unit>
        <trans-unit id="941f1ba20ae720e9df7d97f37ddc2a546949a068" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers, using function in explicit form:</source>
          <target state="translated">명시 적 형태의 함수를 사용하는 피보나치 수 :</target>
        </trans-unit>
        <trans-unit id="d046974a209aaf1dc186931ea0c33a691fda7aee" translate="yes" xml:space="preserve">
          <source>Field Properties</source>
          <target state="translated">필드 속성</target>
        </trans-unit>
        <trans-unit id="107eaaea9a6cf7bffdc6f5831dadf9f4ae6e6dff" translate="yes" xml:space="preserve">
          <source>Field initialization inside a constructor</source>
          <target state="translated">생성자 내부의 필드 초기화</target>
        </trans-unit>
        <trans-unit id="4bc4c6a8400a8c6f02130bcea08f292997d6b9f9" translate="yes" xml:space="preserve">
          <source>Field initialization inside constructor</source>
          <target state="translated">생성자 내부의 필드 초기화</target>
        </trans-unit>
        <trans-unit id="c5a099fc15efbba12a358705f6143f4d6be98777" translate="yes" xml:space="preserve">
          <source>FieldInit[] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt;;</source>
          <target state="translated">FieldInit [] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="0de912d25f2bf66472286b09fc92107582e1704b" translate="yes" xml:space="preserve">
          <source>Fields are by default initialized to the default initializer for their type (usually 0 for integer types and NAN for floating point types). If the field declaration has an optional &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; that will be used instead of the default.</source>
          <target state="translated">필드는 기본적으로 유형에 따라 기본 이니셜 라이저로 초기화됩니다 (일반적으로 정수 유형의 경우 0, 부동 소수점 유형의 경우 NAN). 필드 선언 에 기본값 대신 사용되는 선택적 &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;이니셜 라이저&lt;/i&gt;&lt;/a&gt; 가있는 경우</target>
        </trans-unit>
        <trans-unit id="23cca95a6cdd188e6c7fc8755e8efb38d2d70c0e" translate="yes" xml:space="preserve">
          <source>Fields not specified in the</source>
          <target state="translated">에 지정되지 않은 필드</target>
        </trans-unit>
        <trans-unit id="208ad1de91661d0ad0a36ff8e397f7fa368d919b" translate="yes" xml:space="preserve">
          <source>Fields of &lt;code&gt;extern(Objective-C)&lt;/code&gt; classes have a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink.</source>
          <target state="translated">&lt;code&gt;extern(Objective-C)&lt;/code&gt; 클래스의 필드 에는 동적 오프셋이 있습니다. 이는 서브 클래스가 재 컴파일 또는 재 링크 할 필요없이 기본 클래스가 변경 (인스턴스 변수 추가 또는 제거) 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="853d0fada94e86615dc6538f25f88964cc917132" translate="yes" xml:space="preserve">
          <source>Figure out what is being foreach'd over by looking at the ForeachAggregate.</source>
          <target state="translated">ForeachAggregate를보고 무엇을 극복해야하는지 파악하십시오.</target>
        </trans-unit>
        <trans-unit id="30ce9f687ac35a29ae0ceb7c01a007d763160966" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">파일 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e98c320744b7f0c7cb60ef318110b857423c138" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">파일 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f3f2227118512e7ca5c3ada9f680151527105c3" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/a.d&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ns/a.d&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="748ef850240024ab9b9dfd885345924583894351" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/b.d&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ns/b.d&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="f3af95125686bb3393a41be2e1f0fecd04615870" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/package.d&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ns/package.d&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="1aadfe8f43e9471a7ccd0a6d9513aa2d158d8fc8" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stderr&lt;/code&gt;</source>
          <target state="translated">파일 &lt;code&gt;stderr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d5fc4ef533b94b6bad75f0391ad7ad10de8f26" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdin&lt;/code&gt;</source>
          <target state="translated">파일 &lt;code&gt;stdin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e9228910eade205bba9f1037b88441eb129b20" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdout&lt;/code&gt;</source>
          <target state="translated">파일 &lt;code&gt;stdout&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9483d4c2825aba0712cc0561ced9af3cb73ecdf9" translate="yes" xml:space="preserve">
          <source>File &lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt;(string host, ushort port);</source>
          <target state="translated">파일 &lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt; (문자열 호스트, ushort 포트);</target>
        </trans-unit>
        <trans-unit id="ce4206968eedd48fffee1e859866cc73f7755263" translate="yes" xml:space="preserve">
          <source>File descriptor to associate with this &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">파일 기술자는이에 관련 &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e536d6d6e792234f9c45a8b85837120144d1507" translate="yes" xml:space="preserve">
          <source>File name to get times for.</source>
          <target state="translated">시간을 얻을 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="593c7807cce6682849c08e792d67a7b54a30c7c5" translate="yes" xml:space="preserve">
          <source>File names are case insensitive</source>
          <target state="translated">파일 이름은 대소 문자를 구분하지 않습니다</target>
        </trans-unit>
        <trans-unit id="bba1cee852025b35d3e3478cf86257fa54326950" translate="yes" xml:space="preserve">
          <source>File names are case sensitive</source>
          <target state="translated">파일 이름은 대소 문자를 구분합니다</target>
        </trans-unit>
        <trans-unit id="ddde036ce2875cbf396f907c8d72a294c865d6ee" translate="yes" xml:space="preserve">
          <source>File names on the DMD command line with the extension .ddoc are text files that are read and processed in order.</source>
          <target state="translated">확장자가 .ddoc 인 DMD 명령 행의 파일 이름은 순서대로 읽고 처리되는 텍스트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="7b51622761aa9ab4147a65c01ed7a2f997bd6b63" translate="yes" xml:space="preserve">
          <source>File names to dispatch</source>
          <target state="translated">발송할 파일 이름</target>
        </trans-unit>
        <trans-unit id="ab2a2923359cc254d1142cb254fa079493ce8064" translate="yes" xml:space="preserve">
          <source>File opened that is not a database file</source>
          <target state="translated">데이터베이스 파일이 아닌 열린 파일</target>
        </trans-unit>
        <trans-unit id="600941bc483d702b3e6700aa5c9df8eaacfc769f" translate="yes" xml:space="preserve">
          <source>File separator</source>
          <target state="translated">파일 구분자</target>
        </trans-unit>
        <trans-unit id="b8751b87838fad8e9c09877c3fcf2d38b742badf" translate="yes" xml:space="preserve">
          <source>File that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 이라는 파일</target>
        </trans-unit>
        <trans-unit id="f6025d963ff7d5ab00dd321537b1088bcf0aa15c" translate="yes" xml:space="preserve">
          <source>File to read and split into its lines.</source>
          <target state="translated">읽고 해당 행으로 분할 할 파일입니다.</target>
        </trans-unit>
        <trans-unit id="4d239ce96517581903eea3ad6a5e5f8f129445d3" translate="yes" xml:space="preserve">
          <source>File to read lines from.</source>
          <target state="translated">줄을 읽을 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2a39297edcbf92570f7009a9439afaa0ade4a510" translate="yes" xml:space="preserve">
          <source>File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</source>
          <target state="translated">File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba5924daeca1702606731ee6e33f3d6f5d8aeff" translate="yes" xml:space="preserve">
          <source>File/Folder name to get times for.</source>
          <target state="translated">시간을 구할 파일 / 폴더 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b1281649a36423bcd13a1e5734562778e5a449fb" translate="yes" xml:space="preserve">
          <source>FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt;(Loc loc, const(char)* filename);</source>
          <target state="translated">FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt; (Loc loc, const (char) * filename);</target>
        </trans-unit>
        <trans-unit id="adb0ed28c9f6c61c2c5292ae0018a0dbd403f831" translate="yes" xml:space="preserve">
          <source>FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt;(const(char)[] name, const(char)[] dir, const(char)[] arg, const(char)[] ext);</source>
          <target state="translated">FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt; (const (char) [] 이름, const (char) [] dir, const (char) [] arg, const (char) [] ext);</target>
        </trans-unit>
        <trans-unit id="2cdd52dc9b2dc3c92972beb5c0ac073541e5c497" translate="yes" xml:space="preserve">
          <source>Filename NULL</source>
          <target state="translated">파일 이름 NULL</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="ac721011f794b0e8baf53f6a4a3ded5e6b587bdc" translate="yes" xml:space="preserve">
          <source>Files are dispatched in the various arrays (global.params.{ddocfiles,dllfiles,jsonfiles,etc...}) according to their extension. Binary files are added to libmodules.</source>
          <target state="translated">파일은 확장명에 따라 다양한 배열 (global.params. {ddocfiles, dllfiles, jsonfiles 등)로 전달됩니다. 이진 파일이 libmodules에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c458791c8711a4da04ab0a8024c24f9c4200994" translate="yes" xml:space="preserve">
          <source>Fill in new entries below here!</source>
          <target state="translated">아래에 새 항목을 작성하십시오!</target>
        </trans-unit>
        <trans-unit id="fec9699a2804108f414d1cbff9f937ab31b1059b" translate="yes" xml:space="preserve">
          <source>Fill in vtbl[] for base class based on member functions of class cd.</source>
          <target state="translated">클래스 cd의 멤버 함수를 기반으로 기본 클래스의 vtbl []을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="43d8814469e2dd06b7a4446e3a72fe3fb9b94b8b" translate="yes" xml:space="preserve">
          <source>Fill out remainder of elements[] with default initializers for fields[].</source>
          <target state="translated">필드 []의 기본 이니셜 라이저로 나머지 요소 []를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ce95d41d5dfbc8ae874f5267cf6c9192895a26f6" translate="yes" xml:space="preserve">
          <source>Fills a range (assumed uninitialized) with a value.</source>
          <target state="translated">범위 (초기화되지 않은 것으로 가정)를 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="4af7384f97004098d0ba2d1490a26bd5ae8dc06c" translate="yes" xml:space="preserve">
          <source>Fills a range with a pattern, e.g., if &lt;code&gt;a = new int[3]&lt;/code&gt;, then &lt;code&gt;fill(a, 4)&lt;/code&gt; leaves &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; and &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; leaves &lt;code&gt;a = [3, 4, 3]&lt;/code&gt;.</source>
          <target state="translated">범위를 패턴으로 채 웁니다 (예 : &lt;code&gt;a = new int[3]&lt;/code&gt; 이면 &lt;code&gt;fill(a, 4)&lt;/code&gt; 는 &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; 을 &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; 후 fill (a, [3, 4]) 는 &lt;code&gt;a = [3, 4, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58c13531d89cbfd81b826ad0e0207a8e8f855efc" translate="yes" xml:space="preserve">
          <source>Fills in properties extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, expandedData[], name[], extra[].</source>
          <target state="translated">extractVersion, flags, compressionMethod, time, crc32, compressSize, extendedSize, extendedData [], name [], extra [] 속성을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="c839d156063c44cb328b154ceff7d45b6cd1f2d8" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="translated">data [], diskNumber, diskStartDir, numEntries, totalEntries 및 directory [] 특성을 채 웁니다. 각 ArchiveMember에 대해 crc32, 압축 크기, 압축 데이터 [] 특성을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ac430f749392cd86ab81a1eba5a5fa6084a02035" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], diskNumber, internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="translated">data [], diskNumber, diskStartDir, numEntries, totalEntries, comment [] 및 directory [] 특성을 채 웁니다. 각 ArchiveMember에 대해 madeVersion, extractVersion, 플래그, compressionMethod, 시간, crc32, 압축 크기, 확장 크기, 압축 데이터 [], diskNumber, internalAttributes, externalAttributes, name [], extra [], comment [] 특성을 채 웁니다. 각 ArchiveMember에 대해 확장 된 데이터를 가져 오려면 expand ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="46a5ea9f87c0b1df74d151c62691fe2ef4bb053c" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="translated">data [], totalEntries 및 directory [] 속성을 채 웁니다. 각 ArchiveMember에 대해 crc32, compressSize, compressData [] 속성을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b346bd7916857edb9b3b4a990fd8d299ee339598" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="translated">data [], totalEntries, comment [] 및 directory [] 속성을 채 웁니다. 각 ArchiveMember에 대해 madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressSize, extendedSize, compressData [], internalAttributes, externalAttributes, name [], extra [], comment [] 속성을 채 웁니다. expand ()를 사용하여 각 ArchiveMember에 대한 확장 된 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="753c7b4dfb03e4b323218bfbcf8e9ce9e83fd215" translate="yes" xml:space="preserve">
          <source>Filter (higher-order function)</source>
          <target state="translated">필터 (고차 기능)</target>
        </trans-unit>
        <trans-unit id="e010e248c9fcbc07279b28e2d9cf39a816edeedc" translate="yes" xml:space="preserve">
          <source>Filtering Log Messages</source>
          <target state="translated">로그 메시지 필터링</target>
        </trans-unit>
        <trans-unit id="b9cfd7e1924fe46ff476048bb232046b2445c30d" translate="yes" xml:space="preserve">
          <source>Filters an &lt;code&gt;AliasSeq&lt;/code&gt; using a template predicate. Returns an &lt;code&gt;AliasSeq&lt;/code&gt; of the elements which satisfy the predicate.</source>
          <target state="translated">필터 &lt;code&gt;AliasSeq&lt;/code&gt; 템플릿 술어를 사용합니다. 술어를 만족시키는 요소 의 &lt;code&gt;AliasSeq&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d3a871296194a1fb868a45ed782c53f0637a842f" translate="yes" xml:space="preserve">
          <source>Final Classes</source>
          <target state="translated">최종 수업</target>
        </trans-unit>
        <trans-unit id="c054c76415f8cf9cbfa3c705550abf7d2a659de6" translate="yes" xml:space="preserve">
          <source>Final Switch Statement</source>
          <target state="translated">최종 스위치 진술</target>
        </trans-unit>
        <trans-unit id="f28c69a57fd5a00b8c460d98af841dbdfc2cf776" translate="yes" xml:space="preserve">
          <source>Final classes cannot be subclassed:</source>
          <target state="translated">최종 클래스는 서브 클래 싱 될 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="ce6f1f9e3ddcc894278135e4f17b933043c105ab" translate="yes" xml:space="preserve">
          <source>Final variables cannot be directly mutated or rebound, but references reached through the variable are typed with their original mutability. It is equivalent to &lt;code&gt;final&lt;/code&gt; variables in D1 and Java, as well as &lt;code&gt;readonly&lt;/code&gt; variables in C#.</source>
          <target state="translated">최종 변수는 직접 변경하거나 리바운드 할 수 없지만 변수를 통해 도달 한 참조는 원래 변경 가능성으로 입력됩니다. C #의 &lt;code&gt;readonly&lt;/code&gt; 변수 뿐만 아니라 D1 및 Java의 &lt;code&gt;final&lt;/code&gt; 변수 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0e2b4800b08f795f43f812ffedaf0e687b6d6874" translate="yes" xml:space="preserve">
          <source>Final!T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt;(T)(T t);</source>
          <target state="translated">결승! T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt; (T) (T t);</target>
        </trans-unit>
        <trans-unit id="9e3e2e2f543272fd4cd5df84fdd43fdaeaef1da0" translate="yes" xml:space="preserve">
          <source>Final_Punctuation</source>
          <target state="translated">Final_Punctuation</target>
        </trans-unit>
        <trans-unit id="5651425846864705935b85d871957e1ebe78f459" translate="yes" xml:space="preserve">
          <source>Finalization hook, called FOR each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">각 스레드마다 호출되는 종료 후크. 모듈 초기화 상태에 대한 가정은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">동적 문자열 마무리</target>
        </trans-unit>
        <trans-unit id="c5174f6c9ec806f743432561800d7fb3cdce6c10" translate="yes" xml:space="preserve">
          <source>Finalize the data in this block on collect.</source>
          <target state="translated">수집시이 블록의 데이터를 마무리합니다.</target>
        </trans-unit>
        <trans-unit id="1487ab4833797a8fe86e9e688a3c4af63df81678" translate="yes" xml:space="preserve">
          <source>Finalizes the computation of the hash and returns the computed value. Note that &lt;code&gt;finish&lt;/code&gt; can be called only once and that no subsequent calls to &lt;code&gt;put&lt;/code&gt; is allowed.</source>
          <target state="translated">해시 계산을 완료하고 계산 된 값을 반환합니다. 참고 &lt;code&gt;finish&lt;/code&gt; 한 번만 호출 할 수 있으며, 아무런 후속 호출 것을 &lt;code&gt;put&lt;/code&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edf7957cb21bb43e8c1e9e16262a7f52655c315a" translate="yes" xml:space="preserve">
          <source>Finally, any combination of integral offsets and tuples composed of two integral offsets can be passed in:</source>
          <target state="translated">마지막으로, 2 개의 적분 오프셋으로 구성된 적분 오프셋과 튜플의 조합을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8318badcbf1d40a64d4bffbf97bd0efd4cae1f40" translate="yes" xml:space="preserve">
          <source>Finally, if the user-defined type is to be used as a key in the built-in associative arrays, then the programmer must ensure that the semantics of &lt;code&gt;opEquals&lt;/code&gt; and &lt;code&gt;toHash&lt;/code&gt; are consistent. If not, the associative array may not work in the expected manner.</source>
          <target state="translated">마지막으로, 사용자 정의 유형을 내장 연관 배열에서 키로 사용하려면 프로그래머가 &lt;code&gt;opEquals&lt;/code&gt; 및 &lt;code&gt;toHash&lt;/code&gt; 의 의미 가 일관 되도록해야합니다 . 그렇지 않으면 연관 배열이 예상 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63ebc2a4bae0f29d985262d1e0a7882d311b33e0" translate="yes" xml:space="preserve">
          <source>Finally, it includes some convenience functions for manipulating ranges:</source>
          <target state="translated">마지막으로 범위 조작을위한 몇 가지 편리한 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="957ad37fd6f0cb718a9dbc02f2623b3113168bed" translate="yes" xml:space="preserve">
          <source>Finally, there is no guarantee that using &lt;code&gt;FPTemporary!F&lt;/code&gt; will always be fastest, as the speed of floating-point calculations depends on very many factors.</source>
          <target state="translated">마지막으로 &lt;code&gt;FPTemporary!F&lt;/code&gt; 를 사용하는 것이 항상 가장 빠르다는 보장은 없습니다 . 부동 소수점 계산의 속도는 매우 많은 요소에 달려 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1e7650a8c491fd4a8a63008ab0b8ff54cd68ebd3" translate="yes" xml:space="preserve">
          <source>FinallyStatement</source>
          <target state="translated">FinallyStatement</target>
        </trans-unit>
        <trans-unit id="af66114eea030ebc5f2464aa23997a938e455374" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;ident&lt;/code&gt; in an array of identifiers.</source>
          <target state="translated">식별자 배열에서 &lt;code&gt;ident&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="88937cdca6cc08c5d7dbfa18ae72ed67be952ed2" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;value&lt;/code&gt; among &lt;code&gt;values&lt;/code&gt;, returning the 1-based index of the first matching value in &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is not among &lt;code&gt;values&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used to compare values, and uses equality by default.</source>
          <target state="translated">찾기 &lt;code&gt;value&lt;/code&gt; 중 &lt;code&gt;values&lt;/code&gt; 1을 기반으로 첫 번째 일치하는 값의 인덱스 반환 &lt;code&gt;values&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 이 경우 &lt;code&gt;value&lt;/code&gt; 중 하나가 아닌 &lt;code&gt;values&lt;/code&gt; . 술어 &lt;code&gt;pred&lt;/code&gt; 는 값을 비교하는 데 사용되며 기본적으로 동일성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">준비된 명령문의 데이터베이스 핸들 찾기</target>
        </trans-unit>
        <trans-unit id="8ed4d78384609c747738b51bd99d57a7cbe3bca7" translate="yes" xml:space="preserve">
          <source>Find a common root between &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;. If there is no common root, return &lt;code&gt;path&lt;/code&gt; unaltered.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;base&lt;/code&gt; 사이의 공통 루트를 찾으십시오 . 공통 루트가없는 경우 &lt;code&gt;path&lt;/code&gt; 변경 하지 않고 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cc4bdb526e48e9b0169cef3864d16c67f747c87" translate="yes" xml:space="preserve">
          <source>Find a real minimum of a real function &lt;code&gt;f(x)&lt;/code&gt; via bracketing. Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;(ax .. bx)&lt;/code&gt;, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a minimum of &lt;code&gt;f(x)&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is never evaluted at the endpoints of &lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one minimum in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN or -Infinity, &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">브라케팅을 통해 실제 함수 &lt;code&gt;f(x)&lt;/code&gt; 의 실제 최소값 을 찾으십시오. 함수 &lt;code&gt;f&lt;/code&gt; 와 범위 &lt;code&gt;(ax .. bx)&lt;/code&gt; 주어지면 최소 &lt;code&gt;f(x)&lt;/code&gt; 가장 가까운 범위에서 &lt;code&gt;x&lt;/code&gt; 값을 반환합니다 . &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;ax&lt;/code&gt; 및 &lt;code&gt;bx&lt;/code&gt; 의 끝점에서 절대로 사라지지 않습니다 . 경우 &lt;code&gt;f(x)&lt;/code&gt; 범위의 하나 이상의 최소값을 갖고, 하나는 임의로 선택된다. 경우 &lt;code&gt;f(x)&lt;/code&gt; NaN이 -Infinity 또는 리턴 &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; 반환한다; 그렇지 않으면이 알고리즘이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="dc439799cd4737f8236f05600fc64a52e0bdee1d" translate="yes" xml:space="preserve">
          <source>Find a real root of a real function f(x) via bracketing.</source>
          <target state="translated">브라케팅을 통해 실제 함수 f (x)의 실제 근을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d9ea8a7553428e4555c42a356e28f37d1f30dc20" translate="yes" xml:space="preserve">
          <source>Find all instance fields, then push them into &lt;code&gt;fields&lt;/code&gt;.</source>
          <target state="translated">다음으로 그들을 밀어, 모든 인스턴스 필드 찾기 &lt;code&gt;fields&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f0f2515c2b37286fa318cf443dfdda11744bc3e" translate="yes" xml:space="preserve">
          <source>Find all variables accessed by this delegate that are in functions enclosing it.</source>
          <target state="translated">이 델리게이트가 액세스하는 모든 변수를 둘러싼 모든 변수를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="41ae1d4488620fcf9a1fa1a9eea694e8dd8ef394" translate="yes" xml:space="preserve">
          <source>Find function in overload list that exactly matches t.</source>
          <target state="translated">과부하 목록에서 t와 정확히 일치하는 함수를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="edff7cacecc816c7b2bf341caacbadeda732cdfa" translate="yes" xml:space="preserve">
          <source>Find function in overload list that matches to the 'this' modifier. There's four result types.</source>
          <target state="translated">과부하 목록에서 'this'수정 자와 일치하는 함수를 찾으십시오. 네 가지 결과 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c98c985999ca34facaa820a09d254832cfa98f" translate="yes" xml:space="preserve">
          <source>Find index of function in vtbl[0..dim] that this function overrides. Prefer an exact match to a covariant one.</source>
          <target state="translated">이 함수가 재정의 한 vtbl [0..dim]에서 함수의 인덱스를 찾으십시오. 공변량과 정확히 일치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a869c31c58148141fe2bb0252ad8f9ecb8a528b" translate="yes" xml:space="preserve">
          <source>Find last statement in a sequence of statements.</source>
          <target state="translated">일련의 명령문에서 마지막 명령문을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d69cdad0f7e718c4389bc96b6e8484b75621891a" translate="yes" xml:space="preserve">
          <source>Find root of a real function f(x) by bracketing, allowing the termination condition to be specified.</source>
          <target state="translated">종료 조건을 지정할 수 있도록 대괄호로 실제 함수 f (x)의 근을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2fb393ab419b2e3f0988a888618d55945a606a1c" translate="yes" xml:space="preserve">
          <source>Find template declaration corresponding to template instance.</source>
          <target state="translated">템플릿 인스턴스에 해당하는 템플릿 선언을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e56b93cf2f4450a7eaf19462aacfb88f33166737" translate="yes" xml:space="preserve">
          <source>Find the config file</source>
          <target state="translated">구성 파일 찾기</target>
        </trans-unit>
        <trans-unit id="d2dd908c00ec01e1d2253d53d434daf6a1857fe3" translate="yes" xml:space="preserve">
          <source>Find the first (leftmost) slice of the &lt;code&gt;input&lt;/code&gt; that matches the pattern &lt;code&gt;re&lt;/code&gt;. This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">패턴 &lt;code&gt;re&lt;/code&gt; 와 일치하는 &lt;code&gt;input&lt;/code&gt; 의 첫 번째 (가장 왼쪽) 슬라이스를 찾으십시오 . 이 함수는 패턴 특성에 따라 가장 적합한 정규식 엔진을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b74109ae76fb090044e9df5875f1c38828f427c5" translate="yes" xml:space="preserve">
          <source>Find the first non-comma expression.</source>
          <target state="translated">쉼표가 아닌 첫 번째 표현식을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6cc3fb2f138f676cf6a94d5a2c6b5519efc51d83" translate="yes" xml:space="preserve">
          <source>Find the last non-comma expression.</source>
          <target state="translated">쉼표가 아닌 마지막 표현식을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="19feb6b0e0b231038a55e2bf709f34b7a893df27" translate="yes" xml:space="preserve">
          <source>Find virtual function matching identifier and type. Used to build virtual function tables for interface implementations.</source>
          <target state="translated">가상 함수 일치 식별자 및 유형을 찾으십시오. 인터페이스 구현을위한 가상 함수 테이블을 빌드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f779fad43ff937e8c60b5135580f17f7fea9279" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and positions &lt;code&gt;haystack&lt;/code&gt; right after the first occurrence of &lt;code&gt;needle&lt;/code&gt;.</source>
          <target state="translated">발견은 &lt;code&gt;needle&lt;/code&gt; 의 &lt;code&gt;haystack&lt;/code&gt; 및 위치 &lt;code&gt;haystack&lt;/code&gt; 처음 발견 직후 &lt;code&gt;needle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dffa198dc7c767b46fa65ebc9d63a3a8195c5965" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; efficiently using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore&lt;/a&gt; 방법을 사용하여 &lt;code&gt;haystack&lt;/code&gt; 효율적으로 &lt;code&gt;needle&lt;/code&gt; 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d4aab22f9bf13ade683a53be805bd158b6756b54" translate="yes" xml:space="preserve">
          <source>Finds a &lt;code&gt;dmd.conf&lt;/code&gt; and parses it for import paths. This depends on the &lt;code&gt;$DMD&lt;/code&gt; environment variable. If &lt;code&gt;$DMD&lt;/code&gt; is set to &lt;code&gt;ldmd&lt;/code&gt;, it will try to detect and parse a &lt;code&gt;ldc2.conf&lt;/code&gt; instead.</source>
          <target state="translated">찾아 &lt;code&gt;dmd.conf&lt;/code&gt; 을 수입 경로를 위해 그것을 구문 분석합니다. 이는 &lt;code&gt;$DMD&lt;/code&gt; 환경 변수 에 따라 다릅니다 . 경우 &lt;code&gt;$DMD&lt;/code&gt; 설정되어 &lt;code&gt;ldmd&lt;/code&gt; , 그것을 감지하고 분석하려고합니다 &lt;code&gt;ldc2.conf&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="db4503384752d61843483992d0609b3513a269cd" translate="yes" xml:space="preserve">
          <source>Finds an individual element in an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. Elements of &lt;code&gt;haystack&lt;/code&gt; are compared with &lt;code&gt;needle&lt;/code&gt; by using predicate &lt;code&gt;pred&lt;/code&gt; with &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt;. &lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 에서 개별 요소를 찾습니다 . &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt; 와 pred &lt;code&gt;pred&lt;/code&gt; 를 사용하여 &lt;code&gt;haystack&lt;/code&gt; 의 요소를 &lt;code&gt;needle&lt;/code&gt; 과 비교 합니다. &lt;code&gt;find&lt;/code&gt; 는 &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;walkLength(haystack)&lt;/code&gt; ) 평가를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="494b5c575695991289f1af6c553e989e7554d283" translate="yes" xml:space="preserve">
          <source>Finds multiple attributes</source>
          <target state="translated">여러 속성을 찾습니다</target>
        </trans-unit>
        <trans-unit id="dc6ca4363cb66199d14c81638ae0bacb275a040f" translate="yes" xml:space="preserve">
          <source>Finds nothing if there is no member with specific UDA</source>
          <target state="translated">특정 UDA를 가진 멤버가 없으면 아무것도 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="372b352a9faabc1d4848c96cff7df7512a64b542" translate="yes" xml:space="preserve">
          <source>Finds the mean (colloquially known as the average) of a range.</source>
          <target state="translated">범위의 평균 (구체적으로 평균이라고 함)을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="acc839859781d1a6fe4c1aa11b5d0cad6c9f277f" translate="yes" xml:space="preserve">
          <source>Finds the quotient and remainder for the given dividend and divisor in one operation.</source>
          <target state="translated">한 번의 작업으로 주어진 배당 및 제수에 대한 몫과 나머지를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1f42db37e0be1957bbb7a73bd93bbacc6f6971b6" translate="yes" xml:space="preserve">
          <source>Finds two or more &lt;code&gt;needles&lt;/code&gt; into a &lt;code&gt;haystack&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used throughout to compare elements. By default, elements are compared for equality.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 두 개 이상의 &lt;code&gt;needles&lt;/code&gt; 을 찾습니다 . 술어 &lt;code&gt;pred&lt;/code&gt; 는 요소를 비교하기 위해 전체적으로 사용됩니다. 기본적으로 요소는 동일한 지 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="e49c750f94dfbe0f01c55cba7ce3a3fca1cb43ad" translate="yes" xml:space="preserve">
          <source>Finish and return completed data structure.</source>
          <target state="translated">완료 및 리턴 된 데이터 구조.</target>
        </trans-unit>
        <trans-unit id="910917ab298e1770af3ee0a6c87f4500d8fc3b35" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given Windows &lt;code&gt;HANDLE&lt;/code&gt; with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the access attributes of the handle. Windows only.</source>
          <target state="translated">먼저 &lt;code&gt;detach&lt;/code&gt; (실패시 throw)를 호출 한 다음 지정된 Windows &lt;code&gt;HANDLE&lt;/code&gt; 을 &lt;code&gt;File&lt;/code&gt; 과 연결하려고 시도합니다 . 모드는 핸들의 액세스 속성과 호환 가능해야합니다. Windows 만 해당</target>
        </trans-unit>
        <trans-unit id="dcaf56d0ddc5fc561f47a3812f5bb4243cf6c321" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the mode of the file descriptor.</source>
          <target state="translated">먼저 &lt;code&gt;detach&lt;/code&gt; (실패시 throw)를 호출 한 다음 지정된 파일 디스크립터를 &lt;code&gt;File&lt;/code&gt; 과 연관 시키려고 시도합니다 . 모드는 파일 디스크립터 모드와 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f59c090d80233a5077fc16f2881b79e76399aaf" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;, and sets the file's name to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;detach&lt;/code&gt; (실패시 발생)를 호출 한 다음 주어진 파일 설명자를 &lt;code&gt;File&lt;/code&gt; 에 연결하고 파일 이름을 &lt;code&gt;null&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f9a4e48dd9c9e9c16b3c2bdc21882e910e46f414" translate="yes" xml:space="preserve">
          <source>First checks whether there's enough slack memory preallocated for &lt;code&gt;b&lt;/code&gt; by evaluating &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt;. If that's the case, expands &lt;code&gt;b&lt;/code&gt; in place. Otherwise, attempts to use &lt;code&gt;parent.expand&lt;/code&gt; appropriately if present.</source>
          <target state="translated">먼저 &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt; 를 평가 하여 &lt;code&gt;b&lt;/code&gt; 에 사전 할당 된 여유 메모리가 충분한 지 확인합니다 . 이 경우 &lt;code&gt;b&lt;/code&gt; 를 제자리로 확장하십시오 . 그렇지 않으면 &lt;code&gt;parent.expand&lt;/code&gt; 가있는 경우 적절하게 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="232d9e5b94637d4aff68a5613d4eb2c442d5e710" translate="yes" xml:space="preserve">
          <source>First element of range is the whole match.</source>
          <target state="translated">범위의 첫 번째 요소는 전체 일치입니다.</target>
        </trans-unit>
        <trans-unit id="19eb5d2bea28d68e63b34cd9da02ecb96eb4de74" translate="yes" xml:space="preserve">
          <source>First element, null if *plist is null</source>
          <target state="translated">첫 번째 요소. * plist가 null 인 경우 null</target>
        </trans-unit>
        <trans-unit id="56336174ab5678a8f418a8043d57e8c559fdf20f" translate="yes" xml:space="preserve">
          <source>First enum member value</source>
          <target state="translated">첫 번째 열거 형 멤버 값</target>
        </trans-unit>
        <trans-unit id="61c434e488f86b8e6b440a94d71c3f4ce5c76af6" translate="yes" xml:space="preserve">
          <source>First item to compare.</source>
          <target state="translated">비교할 첫 번째 항목입니다.</target>
        </trans-unit>
        <trans-unit id="eb036d61b03c52aec70ded61cf94c0bb2799a5dc" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;S(1)&lt;/code&gt; and &lt;code&gt;S(2)&lt;/code&gt; are evaluated in lexical order. Per the rules, they will be destroyed at the end of the full expression and in reverse order. The comparison &lt;code&gt;S(1) == S(2)&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt;, so the right-hand side of the &lt;code&gt;||&lt;/code&gt; is evaluated causing &lt;code&gt;S(3)&lt;/code&gt; and &lt;code&gt;S(4)&lt;/code&gt; to be evaluated, also in lexical order. However, their destruction is not deferred to the end of the full expression. Instead, &lt;code&gt;S(4)&lt;/code&gt; and then &lt;code&gt;S(3)&lt;/code&gt; are destroyed at the end of the &lt;code&gt;||&lt;/code&gt; expression. Following their destruction, &lt;code&gt;S(5)&lt;/code&gt; and &lt;code&gt;S(6)&lt;/code&gt; are constructed in lexical order. Again they are not destroyed at the end of the full expression, but right at the end of the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression. Consequently, the destruction of &lt;code&gt;S(6)&lt;/code&gt; and &lt;code&gt;S(5)&lt;/code&gt; is carried before that of &lt;code&gt;S(2)&lt;/code&gt; and &lt;code&gt;S(1)&lt;/code&gt;.</source>
          <target state="translated">먼저, &lt;code&gt;S(1)&lt;/code&gt; 및 &lt;code&gt;S(2)&lt;/code&gt; 가 어휘 순서로 평가됩니다. 규칙에 따라 전체 표현이 끝나면 반대 순서로 파기됩니다. 비교 &lt;code&gt;S(1) == S(2)&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; 를 생성 하므로 &lt;code&gt;||&lt;/code&gt; 의 오른쪽 일으키는 평가 &lt;code&gt;S(3)&lt;/code&gt; 및 &lt;code&gt;S(4)&lt;/code&gt; 또한 어휘 위해 평가되어야한다. 그러나 그들의 파멸은 완전한 표현의 끝까지 연기되지 않습니다. 대신 &lt;code&gt;S(4)&lt;/code&gt; 와 &lt;code&gt;S(3)&lt;/code&gt; 은 &lt;code&gt;||&lt;/code&gt; 표현. 그들의 파괴에 따라 &lt;code&gt;S(5)&lt;/code&gt; 와 &lt;code&gt;S(6)&lt;/code&gt; 어휘 순서로 구성됩니다. 다시 전체 표현의 끝에서 파괴되지 않고 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 표현 의 끝에서 바로 파괴됩니다 . 결과적으로, &lt;code&gt;S(6)&lt;/code&gt; 및 &lt;code&gt;S(5)&lt;/code&gt; 의 파괴는 S &lt;code&gt;S(2)&lt;/code&gt; 및 &lt;code&gt;S(1)&lt;/code&gt; 의 파괴 이전에 수행된다 .</target>
        </trans-unit>
        <trans-unit id="35821ff9eaf82cccb4cd374c06db922677ab7c04" translate="yes" xml:space="preserve">
          <source>First, an instance of the reference-counted HTTP struct is created. Then the custom delegates are set. These will be called whenever the HTTP instance receives a header and a data buffer, respectively. In this simple example, the headers are written to stdout and the data is ignored. If the request should be stopped before it has finished then return something less than data.length from the onReceive callback. See &lt;a href=&quot;#onReceiveHeader&quot;&gt;&lt;code&gt;onReceiveHeader&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#onReceive&quot;&gt;&lt;code&gt;onReceive&lt;/code&gt;&lt;/a&gt; for more information. Finally the HTTP request is effected by calling perform(), which is synchronous.</source>
          <target state="translated">먼저, 참조 카운트 된 HTTP 구조체의 인스턴스가 생성됩니다. 그런 다음 사용자 지정 대리자가 설정됩니다. HTTP 인스턴스가 각각 헤더와 데이터 버퍼를 수신 할 때마다 호출됩니다. 이 간단한 예에서 헤더는 stdout에 기록되고 데이터는 무시됩니다. 요청이 완료되기 전에 중지해야하는 경우 onReceive 콜백에서 data.length보다 작은 것을 반환하십시오. 자세한 내용은 &lt;a href=&quot;#onReceiveHeader&quot;&gt; &lt;code&gt;onReceiveHeader&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#onReceive&quot;&gt; &lt;code&gt;onReceive&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. 마지막으로 HTTP 요청은 동기식 인 perform ()을 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ddff6cdec0a5bb1099424737e7832e8c05999395" translate="yes" xml:space="preserve">
          <source>First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done on the operands. The result type of a relational expression is &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">먼저, &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 은 피연산자에서 수행됩니다. 관계식의 결과 유형은 &lt;code&gt;bool&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4957bf53799feeb05b63a3d6e973fd8fa8760f6f" translate="yes" xml:space="preserve">
          <source>FirstExp</source>
          <target state="translated">FirstExp</target>
        </trans-unit>
        <trans-unit id="5613e8ed3a8c422a59b73ed2d59f778f438baaf8" translate="yes" xml:space="preserve">
          <source>Fit elements[] to the corresponding types of the struct's fields.</source>
          <target state="translated">element []를 구조체 필드의 해당 유형에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="2fdb1b8027c76adc716597ecea40dafd0a1d1761" translate="yes" xml:space="preserve">
          <source>Fixed-size allocation (unlikely to get reallocated later). Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, any &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; type. By default it is assumed that the allocation is variable-size, i.e. susceptible to later reallocation (for example all array types). This flag is advisory, i.e. in-place resizing may be attempted for &lt;code&gt;fixedSize&lt;/code&gt; allocations and may succeed. The flag is just a hint to the compiler it may use allocation strategies that work well with objects of fixed size.</source>
          <target state="translated">고정 크기 할당 (나중에 재 할당되지 않을 수 있음). 예 : &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 모든 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 유형 기본적으로 할당은 가변 크기, 즉 이후의 재 할당 (예 : 모든 배열 유형)에 영향을 받기 쉬운 것으로 가정합니다. 이 플래그는, 즉 크기 조정을 위해 시도 할 수있다 자리에서 자문이다 &lt;code&gt;fixedSize&lt;/code&gt; 할당하고 성공할 수 있습니다. 플래그는 컴파일러에 대한 힌트 일 뿐이며 고정 된 크기의 객체와 잘 작동하는 할당 전략을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="6349adf8f4924cf71432b2cc8b99298a02da104f" translate="yes" xml:space="preserve">
          <source>Flag for indicating if the isEmail function should perform a DNS check or not.</source>
          <target state="translated">isEmail 기능이 DNS 확인을 수행해야하는지 여부를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="01fd2d670ffad32f041db95fdb5fd34e662c1fd5" translate="yes" xml:space="preserve">
          <source>Flag indicating if help was requested</source>
          <target state="translated">도움 요청 여부를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="4839649a06c4517e676f395e7fb017b70b5e26a6" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a search is case-sensitive.</source>
          <target state="translated">검색이 대소 문자를 구분하는지 여부를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="728d7e2f5a2090a340dd62e4890170496eb26f90" translate="yes" xml:space="preserve">
          <source>Flag to control rethrow behavior of &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 투사 동작을 제어하는 ​​플래그</target>
        </trans-unit>
        <trans-unit id="e2bb64de167476df8d3672619e1590b0a282bc6b" translate="yes" xml:space="preserve">
          <source>Flag to specify whether or not an exception is thrown on error.</source>
          <target state="translated">오류 발생시 예외 발생 여부를 지정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="c2cc357fb7c03c09f92dcb1aaffc28e51837dbc6" translate="yes" xml:space="preserve">
          <source>Flag used by &lt;a href=&quot;#resolveFuncCall&quot;&gt;&lt;code&gt;resolveFuncCall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resolveFuncCall&quot;&gt; &lt;code&gt;resolveFuncCall&lt;/code&gt; 가&lt;/a&gt; 사용하는 플래그 .</target>
        </trans-unit>
        <trans-unit id="dfa1ebe73458327f2f1b2331e7d2bc64bda02225" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Iterable)(auto ref Iterable r)</source>
          <target state="translated">플래그! &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; (반복 가능) (자동 참조 반복 가능 r)</target>
        </trans-unit>
        <trans-unit id="2e29bfd584368e0b6c450b93dff8e2b4b7d7e79b" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">깃발! &quot; &lt;strong id=&quot;each&quot;&gt;각각&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;각&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="a98a30dbf66202f4a1ca6fcfeff706e1cb961f9b" translate="yes" xml:space="preserve">
          <source>Flags affect formatting depending on the specifier as follows.</source>
          <target state="translated">플래그는 다음과 같이 지정자에 따라 형식화에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="517da122a2fd8a775a91cf3934a2421fdfecad5e" translate="yes" xml:space="preserve">
          <source>Flags may be OR'ed together:</source>
          <target state="translated">플래그는 함께 OR 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9a817b12d43958a297fe78c774ef0aab232c3032" translate="yes" xml:space="preserve">
          <source>Flags that can be passed to &lt;a href=&quot;#pipeProcess&quot;&gt;&lt;code&gt;pipeProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</source>
          <target state="translated">자식 프로세스의 표준 스트림 중 리디렉션되는 것을 지정 하기 위해 &lt;a href=&quot;#pipeProcess&quot;&gt; &lt;code&gt;pipeProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt; 에 전달할 수있는 플래그입니다 . 비트 OR을 사용하여 플래그를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="d7bf08131e02f1b45b6731cfdb8ac81266998286" translate="yes" xml:space="preserve">
          <source>Flags that control how json is encoded and parsed.</source>
          <target state="translated">json의 인코딩 및 구문 분석 방법을 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="9101e63c4b97693993f5de7e6caad68a3e230e45" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags, and note that the &lt;code&gt;retainStd...&lt;/code&gt; flags have no effect in this function.</source>
          <target state="translated">프로세스 생성을 제어하는 ​​플래그. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 . &lt;code&gt;retainStd...&lt;/code&gt; 플래그는이 기능에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fa52f42ca8ff70a9db0dc2e586798abb191d35d" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">프로세스 생성을 제어하는 ​​플래그. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0978ac0b3ccfd7282e3c33d010ed6583a1755a4" translate="yes" xml:space="preserve">
          <source>Flags that control the behaviour of process creation functions in this module. Most flags only apply to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에서 프로세스 작성 기능의 동작을 제어하는 ​​플래그. 대부분의 플래그는 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a98c5de453c2c7c3caf6bb14f159914e55de8b90" translate="yes" xml:space="preserve">
          <source>Flags that determine which streams are redirected, and how. See &lt;a href=&quot;#Redirect&quot;&gt;&lt;code&gt;Redirect&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">리디렉션되는 스트림과 방법을 결정하는 플래그입니다. 사용 가능한 플래그에 대한 개요는 &lt;a href=&quot;#Redirect&quot;&gt; &lt;code&gt;Redirect&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b620409ddfc3fc2bb8b14e73ba7780a044ad90c9" translate="yes" xml:space="preserve">
          <source>Flatten out the scope by presenting the statement as an array of statements.</source>
          <target state="translated">명령문을 명령문 배열로 표시하여 범위를 평평하게하십시오.</target>
        </trans-unit>
        <trans-unit id="69f2ec628a1c75aed5c37949245c44cc81da511d" translate="yes" xml:space="preserve">
          <source>Flips a single bit, specified by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 로 지정된 단일 비트를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a4e1ce065ff47fa12c8210de50047287b30b8075" translate="yes" xml:space="preserve">
          <source>Flips all the bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 의 모든 비트를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="f980f6669a99ae97aa471b598c62ac0c3e1f823b" translate="yes" xml:space="preserve">
          <source>Floating Point</source>
          <target state="translated">부동 소수점</target>
        </trans-unit>
        <trans-unit id="a7a463a748e16b2f5b0e11e3ae1b317ccea7b0fc" translate="yes" xml:space="preserve">
          <source>Floating Point Constant Folding</source>
          <target state="translated">부동 소수점 상수 폴딩</target>
        </trans-unit>
        <trans-unit id="d66cb8936a51df45efbb55e9f325e90025cbbefc" translate="yes" xml:space="preserve">
          <source>Floating Point Intermediate Values</source>
          <target state="translated">부동 소수점 중간 값</target>
        </trans-unit>
        <trans-unit id="a6c4e80d19a5698157c68955c5feabc616b55ad5" translate="yes" xml:space="preserve">
          <source>Floating Point Literals</source>
          <target state="translated">부동 소수점 리터럴</target>
        </trans-unit>
        <trans-unit id="549c1462b87072d7712396a53e8de6f7b9f76688" translate="yes" xml:space="preserve">
          <source>Floating Point Transformations</source>
          <target state="translated">부동 소수점 변환</target>
        </trans-unit>
        <trans-unit id="2bed0fff60a5113135f273ef65f90946ade02e38" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters to improve readability, and which are ignored.</source>
          <target state="translated">부동 리터럴에는 가독성을 높이기 위해 '_'문자가 포함될 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="00848e3da3c10e7ab7937982dcd4c2d2c3dffaaa" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">부동 리터럴에는 '_'문자가 포함될 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f633a3ecaf3e65628ed43650f2d2e7563e4708a" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. Floating literals followed by &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; are of type &lt;code&gt;float&lt;/code&gt;, and those followed by &lt;b&gt;L&lt;/b&gt; are of type &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">접미사가없는 부동 리터럴은 &lt;code&gt;double&lt;/code&gt; 유형 입니다. &lt;b&gt;f&lt;/b&gt; 또는 &lt;b&gt;F&lt;/b&gt; 가 뒤 따르는 부동 리터럴 은 &lt;code&gt;float&lt;/code&gt; 유형 이고 &lt;b&gt;L&lt;/b&gt; 이 뒤 따르는 것은 &lt;code&gt;real&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="01668267e3349ef380ebd600403f931fc5d66ef9" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. They can be followed by one &lt;b&gt;f&lt;/b&gt;, &lt;b&gt;F&lt;/b&gt;, or &lt;b&gt;L&lt;/b&gt; suffix. The &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; suffix types it is a &lt;code&gt;float&lt;/code&gt;, and &lt;b&gt;L&lt;/b&gt; types it is a &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">접미사가없는 부동 리터럴은 &lt;code&gt;double&lt;/code&gt; 유형 입니다. 그 뒤에 하나의 &lt;b&gt;f&lt;/b&gt; , &lt;b&gt;F&lt;/b&gt; 또는 &lt;b&gt;L&lt;/b&gt; 접미 부가 올 수 있습니다. &lt;b&gt;F&lt;/b&gt; 또는 &lt;b&gt;F의&lt;/b&gt; 접미사 유형 그것은 인 &lt;code&gt;float&lt;/code&gt; 와 &lt;b&gt;L의&lt;/b&gt; 유형이다 그것은 &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4195feb88e405b4996ac5dcca713ad5c6175c1" translate="yes" xml:space="preserve">
          <source>Floating point NaN's are formatted as &lt;b&gt;nan&lt;/b&gt; if the</source>
          <target state="translated">부동 소수점의 NaN의이 같은 형식이 &lt;b&gt;유모&lt;/b&gt; 는 IF</target>
        </trans-unit>
        <trans-unit id="afa8bdea6b3525811aead9f74976b708a0d15aba" translate="yes" xml:space="preserve">
          <source>Floating point comparison operators</source>
          <target state="translated">부동 소수점 비교 연산자</target>
        </trans-unit>
        <trans-unit id="ed4b0ae6cd9ee0a107d7642401f3d58f692c98b4" translate="yes" xml:space="preserve">
          <source>Floating point comparisons</source>
          <target state="translated">부동 소수점 비교</target>
        </trans-unit>
        <trans-unit id="51fe49d981df10fc2a3ca0c38f66d9ec597eda64" translate="yes" xml:space="preserve">
          <source>Floating point computations can be carried out at a higher precision than the size of the floating point variable can hold. Floating point algorithms should continue to work properly if precision is arbitrarily increased.</source>
          <target state="translated">부동 소수점 계산은 부동 소수점 변수가 보유 할 수있는 것보다 더 높은 정밀도로 수행 될 수 있습니다. 정밀도가 임의로 증가하면 부동 소수점 알고리즘이 계속 제대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbc0ff66a82e332f74b6f7f08625c15927132156" translate="yes" xml:space="preserve">
          <source>Floating point constants are internally represented in the implementation in at least &lt;code&gt;real&lt;/code&gt; precision, regardless of the constant's type. The extra precision is available for constant folding. Committing to the precision of the result is done as late as possible in the compilation process. For example:</source>
          <target state="translated">부동 소수점 상수는 구현에서 상수 유형에 관계없이 최소한 &lt;code&gt;real&lt;/code&gt; 정밀도 로 내부적으로 표시됩니다 . 지속적인 접힘을 위해 추가 정밀도가 제공됩니다. 결과의 정확성에 대한 커밋은 컴파일 프로세스에서 가능한 한 늦게 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35c2559ddef9cb0435b556f187c76ca13d0d375f" translate="yes" xml:space="preserve">
          <source>Floating point numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="95bc83092a43ba79dea2ddad11b46e7cfef6083c" translate="yes" xml:space="preserve">
          <source>Floating point numerics functions.</source>
          <target state="translated">부동 소수점 숫자 기능.</target>
        </trans-unit>
        <trans-unit id="160661b47177ecb78c896bad472b47b4dfd37f9e" translate="yes" xml:space="preserve">
          <source>Floating point return values are returned on the FPU stack. These must be cleaned off by the caller, even if they are not used.</source>
          <target state="translated">부동 소수점 반환 값은 FPU 스택에 반환됩니다. 사용하지 않더라도 발신자가 청소해야합니다.</target>
        </trans-unit>
        <trans-unit id="33856b075b952fb87e57ad69006f9b871108ab99" translate="yes" xml:space="preserve">
          <source>Floating point types cannot be implicitly converted to integral types. Complex or imaginary floating point types cannot be implicitly converted to non-complex floating point types. Non-complex floating point types cannot be implicitly converted to imaginary floating point types.</source>
          <target state="translated">부동 소수점 유형은 암시 적으로 정수 유형으로 변환 될 수 없습니다. 복소수 또는 허수 부동 소수점 유형은 암시 적으로 비 복잡 부동 소수점 유형으로 변환 될 수 없습니다. 비 복합 부동 소수점 유형은 내재적으로 가상 부동 소수점 유형으로 변환 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3a01c245469b7e18ff38a92dc5c6ea9b1ec4c23" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf]</source>
          <target state="translated">부동 소수점 수 : (cfloat, cdouble 및 creal) [ '+'| '-'] 자리수 [.] [자리수] [[e- | e +] 자리수] [+] [자리 (들) [.] [자리 (들)] [[e- | e +] 자리] [i | f | L | Li | fi]] 또는 [nan | nani | nan + nani | inf | -inf]</target>
        </trans-unit>
        <trans-unit id="6d2316f26e5bf23de4ad985a49ccce2c80f4f913" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf]</source>
          <target state="translated">부동 소수점 수 : (float, double, real, ifloat, idouble 및 ireal) [ '+'| '-'] 자리수 [.] [자리수] [[e- | e +] 자리수 ( s)] [i | f | L | Li | fi]] 또는 [nan | nani | inf | -inf]</target>
        </trans-unit>
        <trans-unit id="4e439c8e69a24e7d54c5622205640014d4f59099" translate="yes" xml:space="preserve">
          <source>Floating-Point manipulation</source>
          <target state="translated">부동 소수점 조작</target>
        </trans-unit>
        <trans-unit id="417d3791f22357e1adf665e28ee4d505d124a89d" translate="yes" xml:space="preserve">
          <source>Floating-point operations</source>
          <target state="translated">부동 소수점 연산</target>
        </trans-unit>
        <trans-unit id="e0d24bd6f36291462113f127088f35f4090a373d" translate="yes" xml:space="preserve">
          <source>Floating-point random variate of type &lt;code&gt;T&lt;/code&gt; drawn from the uniform distribution across the half-open interval [0, 1).</source>
          <target state="translated">반 개방 구간 [0, 1)에 걸쳐 균일 한 분포에서 도출 된 유형 &lt;code&gt;T&lt;/code&gt; 의 부동 소수점 랜덤 변이입니다 .</target>
        </trans-unit>
        <trans-unit id="f2714b106a05319f2ace1ce68d8ac69bcf4f5ff7" translate="yes" xml:space="preserve">
          <source>Floating-point values are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">부동 소수점 값은 &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; 와 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c6b8da4fa90bdf05e2c05a6593125f02a7d82431" translate="yes" xml:space="preserve">
          <source>Floats can be in decimal or hexadecimal format.</source>
          <target state="translated">플로트는 10 진수 또는 16 진수 형식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee4c734dc6fd3c7a89584d7e5348d40237e1949" translate="yes" xml:space="preserve">
          <source>Flush cookie jar to disk.</source>
          <target state="translated">쿠키 병을 디스크에 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="7f0c95d2e99f8f6f791a3dcf13701e05342006cc" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;FILE&lt;/code&gt; buffers.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; 버퍼를 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="bebb80c78ce429db39d79d68feeba680b58038de" translate="yes" xml:space="preserve">
          <source>Folding White Space contains consecutive CRLF sequences</source>
          <target state="translated">접는 공백에는 연속적인 CRLF 시퀀스가 ​​포함됩니다</target>
        </trans-unit>
        <trans-unit id="67f0ed9d72f8298bdd413ec634b75103f7a22dc1" translate="yes" xml:space="preserve">
          <source>Folding White Space ends with a CRLF sequence</source>
          <target state="translated">접는 공백은 CRLF 시퀀스로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="08097cc4ab9f5b9568ed73c27e3a597381bce1b4" translate="yes" xml:space="preserve">
          <source>Following arguments works the same way as &lt;code&gt;bitfield&lt;/code&gt;'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</source>
          <target state="translated">다음 인수는 &lt;code&gt;bitfield&lt;/code&gt; 와 같은 방식으로 작동합니다 . 포인터 정렬 때문에 비트 필드는 0으로 알려진 비트에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="6cfe2219958a5948a49371cf65d64e832c75a6f7" translate="yes" xml:space="preserve">
          <source>Following initialization, the &lt;code&gt;HashTable&lt;/code&gt; object would consistently use its &lt;code&gt;allocator&lt;/code&gt; object for acquiring memory. Furthermore, setting &lt;code&gt;HashTable.allocator&lt;/code&gt; to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</source>
          <target state="translated">초기화 후 &lt;code&gt;HashTable&lt;/code&gt; 개체는 메모리를 얻기 위해 &lt;code&gt;allocator&lt;/code&gt; 개체를 일관되게 사용합니다 . 또한 &lt;code&gt;HashTable.allocator&lt;/code&gt; 가 다른 할당자를 가리 키 도록 설정 하는 것은 합법적이지만 객체가 비어있는 경우에만 가능합니다. 그렇지 않으면 객체가 기존 상태를 할당 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c77938fcdf67aea78282407b90406b49eb71c3e5" translate="yes" xml:space="preserve">
          <source>Follows Itanium C++ ABI 1.86 section 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; which is where the grammar comments come from.</source>
          <target state="translated">문법 주석의 출처 인 Itanium C ++ ABI 1.86 섹션 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; 을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="2496332383d78a1d33c27c0e38fa6de47dc78a49" translate="yes" xml:space="preserve">
          <source>For &quot;store&quot; operations of the form: op1 op= op2</source>
          <target state="translated">다음과 같은 형식의 &quot;저장&quot;조작의 경우 : op1 op = op2</target>
        </trans-unit>
        <trans-unit id="97c9b61a869134f6120476fe4a99b3b11a45291d" translate="yes" xml:space="preserve">
          <source>For 16 bit generator, this is always a (targ_short) sign-extended value.</source>
          <target state="translated">16 비트 생성기의 경우 항상 (targ_short) 부호 확장 값입니다.</target>
        </trans-unit>
        <trans-unit id="78b280836f07395eef32226ce729d39d05fd0d6b" translate="yes" xml:space="preserve">
          <source>For 64 bit code, follows Itanium C++ ABI 1.86 Chapter 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</source>
          <target state="translated">64 비트 코드의 경우 Itanium C ++ ABI 1.86 3 장 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls를&lt;/a&gt; 따릅니다.</target>
        </trans-unit>
        <trans-unit id="11a5de5d335b50e0f5cf5b3413b2f30e630b28c1" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;type#basic-data-types&quot;&gt;basic data types&lt;/a&gt;, all possible bit patterns are safe.</source>
          <target state="translated">의 경우 &lt;a href=&quot;type#basic-data-types&quot;&gt;기본 데이터 유형&lt;/a&gt; , 모든 가능한 비트 패턴은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b23dde54b23d16d77035a1e0e2b0833121f3ea89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; or the operation would result in an overflow, sets &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">들어 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; 경우 &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; 또는 작업이 오버 플로우가 발생할 것이다, 세트는 &lt;code&gt;v&lt;/code&gt; 에 에 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . 그렇지 않으면 의미는 내장 연산자의 의미와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c0328592d323a259faf0da7a348a86fd52092b62" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">들어 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;~&lt;/code&gt; , 경우 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . 그렇지 않으면 의미는 내장 연산자의 의미와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4e56b23a72d6de96ffb1933a70486eb64d0dea7d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;foreach&lt;/code&gt;, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For &lt;code&gt;foreach_reverse&lt;/code&gt;, the array elements are visited in the reverse order.</source>
          <target state="translated">들면 &lt;code&gt;foreach&lt;/code&gt; 는 상기 어레이의 요소는 인덱스 0에서 시작하여, 배열의 최대 지속 동안 반복된다. 들면 &lt;code&gt;foreach_reverse&lt;/code&gt; 배열 요소 역순 방문했다.</target>
        </trans-unit>
        <trans-unit id="d0ceede7c3735e19c4f9e84dfec5a98cdaa80c75" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;windowSize = 1&lt;/code&gt; it splits the range into single element groups (aka &lt;code&gt;unflatten&lt;/code&gt;) For &lt;code&gt;windowSize = 2&lt;/code&gt; it is similar to &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;windowSize = 1&lt;/code&gt; 은 하나의 요소 그룹으로 영역 분할 (일명 &lt;code&gt;unflatten&lt;/code&gt; ) 용 &lt;code&gt;windowSize = 2&lt;/code&gt; 가 비슷 &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fde640aa4409bbb47d5287c2ea78c26d39f59e9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt;: The function returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt; :이 함수는 &lt;code&gt;void&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5ba5d0612e564fafee84b671c5c4d115f7c0b6e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt;: If &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, the function returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise it returns the normal result of the operator.</source>
          <target state="translated">를 들어 &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt; : &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; 인 경우 함수는 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 반환합니다 . 그렇지 않으면 연산자의 정상적인 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d465e34c13d15e0333f8cd7f1c7c1944ae2b7911" translate="yes" xml:space="preserve">
          <source>For C++ class cd, generate an instance of _cpp_type_info_ptr and populate it with a pointer to the C++ type info.</source>
          <target state="translated">C ++ 클래스 cd의 경우 _cpp_type_info_ptr의 인스턴스를 생성하고 C ++ 유형 정보에 대한 포인터로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="84fc2ed3d82dfac4fe4b1db7e54128df57816954" translate="yes" xml:space="preserve">
          <source>For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list.</source>
          <target state="translated">Posix / x86_64의 경우 va_list 유형의 인수를 전달하는 데 실제로 사용될 유형을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">성명</target>
        </trans-unit>
        <trans-unit id="1658d59f02098b291dd70d6afbe72baf35b0b46e" translate="yes" xml:space="preserve">
          <source>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</source>
          <target state="translated">TypeFunction의 경우 함수 반환 유형이 유추되고 semantic ()이 아직 함수에서 실행되지 않은 경우 nextOf ()는 NULL을 반환 할 수 있습니다. semantic () 이후에는 더 이상 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed4c1eb6664e08f8534b1fe769460ebc44281875" translate="yes" xml:space="preserve">
          <source>For a lazy version, refer to &lt;a href=&quot;std_range#repeat&quot;&gt;&lt;code&gt;std.range.repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게으른 버전은 &lt;a href=&quot;std_range#repeat&quot;&gt; &lt;code&gt;std.range.repeat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cd7374ae5703f87c90badd0385e4fb829226681" translate="yes" xml:space="preserve">
          <source>For a lazy version, see &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt;&lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">게으른 버전에 대해서는 &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt; &lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20ca13cf71a91c26b14ec6bf15dd84151e56cf9e" translate="yes" xml:space="preserve">
          <source>For a lazy, non-allocating version of these functions, see &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 함수의 게으르고 할당되지 않은 버전은 &lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="567c03cab3251ca5dd2f65be01f597e8de5b789b" translate="yes" xml:space="preserve">
          <source>For a less strict parser, see &lt;a href=&quot;#parseUUID&quot;&gt;&lt;code&gt;parseUUID&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">덜 엄격한 파서는 &lt;a href=&quot;#parseUUID&quot;&gt; &lt;code&gt;parseUUID&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3242f7887a56a8199a86141fd1d3d295d57af7c" translate="yes" xml:space="preserve">
          <source>For a nested class instance, the &lt;code&gt;.outer&lt;/code&gt; property is the &lt;code&gt;this&lt;/code&gt; reference for the enclosing class's instance. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would be a &lt;code&gt;void*&lt;/code&gt; to the enclosing function frame.</source>
          <target state="translated">중첩 된 클래스 인스턴스의 경우 &lt;code&gt;.outer&lt;/code&gt; 속성은 포함하는 클래스의 인스턴스에 대한 &lt;code&gt;this&lt;/code&gt; 참조입니다. 둘러싸는 클래스 컨텍스트가 없으면 &lt;code&gt;.outer&lt;/code&gt; 는 둘러싸는 함수 프레임에 대해 &lt;code&gt;void*&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="32cf17cd505298c5983970817a14f4d4aa02e1a3" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; and the setter has no effect.</source>
          <target state="translated">크기가 0 인 풀의 경우 getter는 임의로 &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; 을 반환 하며 setter는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703bdcc05cee4b856a950e3e2494d43650695c33" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns true and the setter has no effect.</source>
          <target state="translated">크기가 0 인 풀의 경우 getter는 임의로 true를 반환하고 setter는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7062424b6df58f7b0070477aac1caffce7eac347" translate="yes" xml:space="preserve">
          <source>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue.</source>
          <target state="translated">모든 대입 식에 대해 왼쪽 피연산자는 수정 가능한 lvalue 여야합니다. 어사 인 표현식의 유형은 왼쪽 피연산자의 유형이며 값은 대입이 발생한 후 왼쪽 피연산자의 값입니다. 결과 표현식은 수정 가능한 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="4c1c5870b4b89a912a0f2d752c3a6fab5551a649" translate="yes" xml:space="preserve">
          <source>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</source>
          <target state="translated">다른 모든 경우에 함수를 호출하기 위해 생성 된 임시는 전체 표현식의 끝으로 연기됩니다. 파괴의 순서는 건설 순서와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="95e2e0ca2da36fd3882b011dd82190d8d5ee7297" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;std.format&lt;/b&gt; 의 기능과이 모듈을 사용하는 방법에 대한 소개 는 전용 &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="076ae6cb1419d1feff35ba4b7e6bb266176337c6" translate="yes" xml:space="preserve">
          <source>For another example:</source>
          <target state="translated">다른 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4f7c5dea21579ef43f50bda4d8b8e7dd5ee9236e" translate="yes" xml:space="preserve">
          <source>For any given platform/compiler curl_off_t must be typedef'ed to a 64-bit wide signed integral data type. The width of this data type must remain constant and independent of any possible large file support settings.</source>
          <target state="translated">주어진 플랫폼 / 컴파일러의 경우 curl_off_t는 64 비트의 부호있는 정수 데이터 유형으로 typedef되어야합니다. 이 데이터 유형의 너비는 일정하고 가능한 큰 파일 지원 설정과 무관하게 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="078912245b32cd2a66bf3a96da7307acc2485fbe" translate="yes" xml:space="preserve">
          <source>For any other declaration even if &lt;code&gt;@disable&lt;/code&gt; is a syntactically valid attribute &lt;code&gt;false&lt;/code&gt; is returned because the annotation has no effect.</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; 이 구문 상 유효한 속성 인 경우에도 다른 선언의 경우 주석이 적용되지 않으므로 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="701d1a14380c65e4a855899951d9d7a65d27e60f" translate="yes" xml:space="preserve">
          <source>For any values &lt;code&gt;v1&lt;/code&gt; on the right-hand side and &lt;code&gt;v2&lt;/code&gt; on the left-hand side:</source>
          <target state="translated">오른쪽의 &lt;code&gt;v1&lt;/code&gt; 값 과 왼쪽의 &lt;code&gt;v2&lt;/code&gt; 값 :</target>
        </trans-unit>
        <trans-unit id="f1e77f1044f99821b0b2c5cfb9d3d37a079ad5ec" translate="yes" xml:space="preserve">
          <source>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed.</source>
          <target state="translated">명령 줄 스위치 처리와 같은 응용 프로그램의 경우 훨씬 더 간단한 코드를 사용하여보다 명확하고 오류 발생이 줄어 듭니다. char, wchar 및 dchar 문자열이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b8d2445b680cd8ee27f3fc95623cb30af7a286" translate="yes" xml:space="preserve">
          <source>For arguments of built-in types, assignment operator expressions such as</source>
          <target state="translated">내장 유형의 인수의 경우 다음과 같은 대입 연산자 표현식</target>
        </trans-unit>
        <trans-unit id="0f5d29eff2633e7fd841d0a6738a98ac739e92a9" translate="yes" xml:space="preserve">
          <source>For arrays:</source>
          <target state="translated">배열의 경우 :</target>
        </trans-unit>
        <trans-unit id="dc14ba04c2c4629e1d2d0d30f5dc9d2a1dddd9e2" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">이전 버전과의 호환성을 &lt;code&gt;a[]&lt;/code&gt; 및 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="542878137297059fb68730fd24d9158d8fdb95d5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;multiwayMerge&lt;/code&gt; is available under the name &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; under the name of &lt;code&gt;NWayUnion&lt;/code&gt; . Future code should use &lt;code&gt;multiwayMerge&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; as &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;NWayUnion&lt;/code&gt; will be deprecated.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;multiwayMerge&lt;/code&gt; 는 이름에서 볼 수 있습니다 &lt;code&gt;nWayUnion&lt;/code&gt; 및 &lt;code&gt;MultiwayMerge&lt;/code&gt; 의 이름으로 &lt;code&gt;NWayUnion&lt;/code&gt; . 미래의 코드를 사용해야 &lt;code&gt;multiwayMerge&lt;/code&gt; 및 &lt;code&gt;MultiwayMerge&lt;/code&gt; 을 같이 &lt;code&gt;nWayUnion&lt;/code&gt; 및 &lt;code&gt;NWayUnion&lt;/code&gt; 는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3a3c169dbbfe63cc4460a15c98153cda1f6881e" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if rewriting &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">호환성을 위해, 경우에 재기록 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92276f55c3cccb89a03bd28b0c6443429cb6df1c" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail and &lt;code&gt;opSliceOpAssign&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; are tried, respectively.</source>
          <target state="translated">이전 버전과의 호환성을 위해 위의 다시 &lt;code&gt;opSliceOpAssign&lt;/code&gt; 가 실패하고 opSliceOpAssign 이 정의 된 경우 다시 &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; 및 &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; 가 각각 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a6a2446de90976e232d13603325c19c48a5a94" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail to compile and &lt;code&gt;opSliceUnary&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; are tried instead, respectively.</source>
          <target state="translated">이전 버전과의 호환성을 위해 위의 다시 &lt;code&gt;opSliceUnary&lt;/code&gt; 가 컴파일되지 않고 opSliceUnary 가 정의 된 경우 다시 &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; 및 &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; 가 각각 대신 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="757d4d7a3dccc207f58716a0eadde379a304a5d2" translate="yes" xml:space="preserve">
          <source>For binary operators, the result is as follows:</source>
          <target state="translated">이진 연산자의 경우 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aeea5f41f2c7d1bd01e14aae86afc3b17192c6d2" translate="yes" xml:space="preserve">
          <source>For blocks &amp;gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important.</source>
          <target state="translated">블록&amp;gt; = pagesize의 경우 길이는 size_t이며 블록의 시작 부분에 있습니다. 우리가 해야하는 이유는 블록이 더 많은 페이지로 확장 될 수 있기 때문에 블록의 길이가 블록의 끝에 있으면 블록 길이가 확장되었을 수 있기 때문에 블록 길이를 신뢰할 수 없기 때문입니다. 나중에 블록이 공유되지 않았다는 것을 증명할 수 있으면이를 변경할 수 있지만 중요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6435d22c869fa126d1d0aea9e7983183ab7f918e" translate="yes" xml:space="preserve">
          <source>For both ++i and --i</source>
          <target state="translated">++ i 및 --i 모두</target>
        </trans-unit>
        <trans-unit id="93107872cedc76cc5719158670858cf146f5ce57" translate="yes" xml:space="preserve">
          <source>For both i++ and i--</source>
          <target state="translated">i ++와 i--</target>
        </trans-unit>
        <trans-unit id="c2f1745a5232cce644154e5a3850452a31978021" translate="yes" xml:space="preserve">
          <source>For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to &lt;a href=&quot;#total&quot;&gt;&lt;code&gt;total&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 과부하 모두, Duration의 전체 값은 모든 Unit에 Duration을 분할 한 다음 요청 된 Unit에 대한 값만 제공하는 것이 아니라 Unit간에 분할되므로 하나의 Unit 만 제공하면 결과는 &lt;a href=&quot;#total&quot;&gt; &lt;code&gt;total&lt;/code&gt; &lt;/a&gt; 과 같습니다. .</target>
        </trans-unit>
        <trans-unit id="ad0f0aabfe7ebb013586fcfb45b89ab392324a84" translate="yes" xml:space="preserve">
          <source>For built-in numerical types, accurate Knuth &amp;amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter &lt;code&gt;seed&lt;/code&gt; is needed in order to correctly seed the summation with the equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">내장 숫자 유형의 경우 정확한 Knuth &amp;amp; Welford 평균 계산이 사용됩니다. 사용자 정의 유형의 경우 요소 별 요약이 사용됩니다. 또한 &lt;code&gt;0&lt;/code&gt; 과 동등한 합계를 올바르게 시드하려면 추가 매개 변수 &lt;code&gt;seed&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a4cc9dd81eb95c3553b97b6dbcaf73ca851ceabc" translate="yes" xml:space="preserve">
          <source>For calendar-based operations that don't care about time zones, then &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; would be the type to use. For system time, use &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">시간대를 신경 쓰지 않는 달력 기반 작업의 경우 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 이 사용되는 유형입니다. 시스템 시간의 경우 &lt;code&gt;SysTime&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7199c84f095b28abf14901a280827544df19151" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization.</source>
          <target state="translated">컴파일 타임에 인코딩이 알려진 경우, 문자의 임의 인코딩 및 디코딩, 다른 유형의 문자열 간 임의의 트랜스 코딩, 유효성 검사 및 살균을위한 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a53a545de095bd4f4e296c839d801de6e744e030" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g.</source>
          <target state="translated">컴파일 타임에는 인코딩은 없지만 런타임에는 &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; 있는 경우 추상 클래스 EncodingScheme 및 해당 서브 클래스가 제공됩니다. 런타임 인코더 / 디코더를 구성하기 위해 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d53cba26ee6cdc76a4ea74c67f57bac33bebf848" translate="yes" xml:space="preserve">
          <source>For class and struct objects, the expression &lt;code&gt;(a == b)&lt;/code&gt; is rewritten as &lt;code&gt;a.opEquals(b)&lt;/code&gt;, and &lt;code&gt;(a != b)&lt;/code&gt; is rewritten as &lt;code&gt;!a.opEquals(b)&lt;/code&gt;.</source>
          <target state="translated">클래스 및 구조체 객체의 경우 &lt;code&gt;(a == b)&lt;/code&gt; 표현식 은 &lt;code&gt;a.opEquals(b)&lt;/code&gt; 로 다시 작성 되고 &lt;code&gt;(a != b)&lt;/code&gt; 는 &lt;code&gt;!a.opEquals(b)&lt;/code&gt; 로 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6164499db4fd6a0a2e064668be7de8146561558" translate="yes" xml:space="preserve">
          <source>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">클래스 객체의 경우 객체 참조가 동일한 객체에 대한 것이므로 아이디가 정의됩니다. null 클래스 객체는 &lt;code&gt;is&lt;/code&gt; 와 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95c093eaf464e50c213285367cf108a1f21af7e6" translate="yes" xml:space="preserve">
          <source>For class objects, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators are intended to compare the contents of the objects, however an appropriate &lt;code&gt;opEquals&lt;/code&gt; override must be defined for this to work. The default &lt;code&gt;opEquals&lt;/code&gt; provided by the root &lt;code&gt;Object&lt;/code&gt; class is equivalent to the &lt;code&gt;is&lt;/code&gt; operator. Comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents. Use the &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; operators instead.</source>
          <target state="translated">클래스 객체의 경우 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자는 객체의 내용을 비교하기위한 것이지만 이를 위해서는 적절한 &lt;code&gt;opEquals&lt;/code&gt; 재정의를 정의해야합니다. 루트 &lt;code&gt;Object&lt;/code&gt; 클래스 에서 제공하는 기본 &lt;code&gt;opEquals&lt;/code&gt; 는 &lt;code&gt;is&lt;/code&gt; 연산자 와 같습니다 . 에 대해 비교 &lt;code&gt;null&lt;/code&gt; 같은 유효하지 않은 &lt;code&gt;null&lt;/code&gt; 어떤 내용이 없습니다. (가) 사용 &lt;code&gt;is&lt;/code&gt; 와 &lt;code&gt;!is&lt;/code&gt; 대신 운영자.</target>
        </trans-unit>
        <trans-unit id="d5b1405cc3330cccfdcfd53a468de428485e9157" translate="yes" xml:space="preserve">
          <source>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents.</source>
          <target state="translated">클래스 객체의 경우 관계 연산자는 객체의 내용을 비교합니다. 따라서,에 대한 비교 &lt;code&gt;null&lt;/code&gt; 등, 무효 &lt;code&gt;null&lt;/code&gt; 에 내용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab366bbd1fd34ad6f5b2cd340e858e3c25d5bb75" translate="yes" xml:space="preserve">
          <source>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</source>
          <target state="translated">클래스 객체의 경우 Object.opCmp ()의 결과는 왼쪽 피연산자를 형성하고 0은 오른쪽 피연산자를 형성합니다. 관계식 (o1 op o2)의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e894f77d4bc27bedbf87e79de7b7a21550ebd3e1" translate="yes" xml:space="preserve">
          <source>For class objects:</source>
          <target state="translated">클래스 객체의 경우 :</target>
        </trans-unit>
        <trans-unit id="6ae638739525d1c55b35c525b46eec46d1197fc5" translate="yes" xml:space="preserve">
          <source>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as &lt;code&gt;bool&lt;/code&gt;). See also &lt;a href=&quot;#BitPacked&quot;&gt;&lt;code&gt;BitPacked&lt;/code&gt;&lt;/a&gt; for enforcing it manually. The major size advantage however comes from the fact that multiple &lt;b&gt;identical pages on every level are merged&lt;/b&gt; by construction.</source>
          <target state="translated">완전성을 위해 레벨 1 트리는 단순히 배열입니다. 현재 구현에서는 범위가 미리 제한되어있는 것으로 알려진 경우 (예 : &lt;code&gt;bool&lt;/code&gt; ) 비트 패킹 값을 활용 합니다. 수동으로 적용 &lt;a href=&quot;#BitPacked&quot;&gt; &lt;code&gt;BitPacked&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 그러나 주요한 크기 이점 &lt;b&gt;은 모든 수준에서&lt;/b&gt; 여러 &lt;b&gt;동일한 페이지&lt;/b&gt; 가 구성에 의해 &lt;b&gt;병합&lt;/b&gt; 된다는 사실에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ebdc89d7f40766ce711349010ffd3cd409b6e68" translate="yes" xml:space="preserve">
          <source>For complex numbers, equality is defined as equivalent to:</source>
          <target state="translated">복소수의 경우, 평등은 다음과 같은 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c92d80178cde078393b89e6d6a1bab596929a28f" translate="yes" xml:space="preserve">
          <source>For consistency and predictability, there are several standard sections. None of these are required to be present.</source>
          <target state="translated">일관성과 예측 성을 위해 몇 가지 표준 섹션이 있습니다. 이들 중 어느 것도 존재하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b5df2d0a44db277a01e403815ff3d6ffbf0a4688" translate="yes" xml:space="preserve">
          <source>For console programs, &lt;code&gt;main()&lt;/code&gt; serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. &lt;code&gt;main()&lt;/code&gt; must be declared using one of the following forms:</source>
          <target state="translated">콘솔 프로그램의 경우 &lt;code&gt;main()&lt;/code&gt; 이 진입 점 역할을합니다. 모든 모듈 이니셜 라이저가 실행 된 후 그리고 단위 테스트가 실행 된 후에 호출됩니다. 돌아온 후 모든 모듈 소멸자가 실행됩니다. &lt;code&gt;main()&lt;/code&gt; 은 다음 형식 중 하나를 사용하여 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="a87a16b2108087eba4cfd4c27e06f2199e9c9ea6" translate="yes" xml:space="preserve">
          <source>For convenience</source>
          <target state="translated">편의상</target>
        </trans-unit>
        <trans-unit id="c28923eb8e6fce56c97d1e69a2459b17db795a95" translate="yes" xml:space="preserve">
          <source>For convenience, if the seed is const, or has qualified fields, then &lt;code&gt;reduce&lt;/code&gt; will operate on an unqualified copy. If this happens then the returned type will not perfectly match &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">편의상 시드가 const이거나 규정 된 필드가있는 경우 &lt;code&gt;reduce&lt;/code&gt; 는 규정되지 않은 사본에서 작동합니다. 이 경우 반환 된 형식은 &lt;code&gt;S&lt;/code&gt; 와 완벽하게 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db55a017e4d8880bceaa15cbff12d8e02dda2446" translate="yes" xml:space="preserve">
          <source>For convenience, this module publicly imports &lt;a href=&quot;core_time&quot;&gt;&lt;code&gt;core.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상이 모듈은 공개적으로 &lt;a href=&quot;core_time&quot;&gt; &lt;code&gt;core.time&lt;/code&gt; 을&lt;/a&gt; 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0750ffdd6d85bc11bd3ef50c265df606e3d06eba" translate="yes" xml:space="preserve">
          <source>For conversion of strings to signed types, the grammar recognized is:</source>
          <target state="translated">문자열을 부호있는 유형으로 변환하는 경우 인식되는 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d295d9ab6e17239455a68d95e6a9009da2b2b99" translate="yes" xml:space="preserve">
          <source>For conversion to unsigned types, the grammar recognized is:</source>
          <target state="translated">부호없는 유형으로 변환하는 경우 인식되는 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cbf49f210f0c77ac5cb0d36bff7e0a64b475c82" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal.</source>
          <target state="translated">올바른 비교를 위해 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양의 정수를, &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음의 정수를 , 두 값이 같은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb5e30aca486d38067e5e0193c4b1bb0345617f" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal. Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">올바른 비교를 위해 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 인 경우 양의 정수를, &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 인 경우 음의 정수를 , 두 값이 같은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환합니다. &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; 과 같은 비교가 잘못되면 함수가 프로그램을 중단하기 때문에 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa11ef91f282359e697ab411a2105694aa1fc413" translate="yes" xml:space="preserve">
          <source>For debuggers that can be modified to accept new types, the following extensions help them fully support the types.</source>
          <target state="translated">새 유형을 허용하도록 수정 될 수있는 디버거의 경우 다음 확장은 유형을 완전히 지원하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="70f5609ca5e86e5be455bc08ca5f8a240497ea5a" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are always passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">항상 참조로 전달되는 동적 배열 및 객체 매개 변수의 경우 in / out / ref는 내용이 아닌 참조에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="63e9558b3c028e1d9a23d1722de151ab9342540d" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">참조로 전달되는 동적 배열 및 객체 매개 변수의 경우, 입 / 출력 / 참조는 내용이 아닌 참조에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="26ffddfdbc1c41c2be1034e80310b3f852b74078" translate="yes" xml:space="preserve">
          <source>For each active attribute (ref/const/nogc/etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">각 활성 속성 (ref / const / nogc / etc) 에 대해 작업 매개 변수에 대해 void *와 속성의 문자열 표시를 사용하여 &lt;code&gt;fp&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="8eea3bce7669308b1434c353731e136dc4b97c1c" translate="yes" xml:space="preserve">
          <source>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">각 활성 수정 자 (MODFlags.const_, MODFlags.immutable_ 등) 에 대해 작업 매개 변수 및 속성의 문자열 표시에 대해 void *와 함께 &lt;code&gt;fp&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="3203682624a9b4a1635c6de69e488d06fa56e15c" translate="yes" xml:space="preserve">
          <source>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</source>
          <target state="translated">임시 값을 산출하는 각 평가에 대해, 해당 임시의 수명은 표현식으로 초기화 된 일반적인 명명 된 값을 작성하는 것과 유사하게 평가 지점에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7caa6316d56bf976ab623e5dd0b440be2fe098" translate="yes" xml:space="preserve">
          <source>For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt; for ranges, and &lt;code&gt;ForeachType!R&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 의 각 함수 &lt;code&gt;f&lt;/code&gt; 에 대해 해당 시드 유형 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; . 여기서 &lt;code&gt;e&lt;/code&gt; 는 범위에 대한 &lt;code&gt;r&lt;/code&gt; : &lt;code&gt;ElementType!R&lt;/code&gt; &lt;code&gt;ForeachType!R&lt;/code&gt; 그렇지 않으면 ForeachType! R 입니다.</target>
        </trans-unit>
        <trans-unit id="89f96ba2b9022471ac4b3f99072ac57893d52c5d" translate="yes" xml:space="preserve">
          <source>For each function that has exception handlers, an EH table entry is generated.</source>
          <target state="translated">예외 핸들러가있는 각 함수에 대해 EH 테이블 항목이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c170bc5a2dcbb7f263f34807c28c73343f6168e3" translate="yes" xml:space="preserve">
          <source>For each template parameter, the following rules are applied in order until a type is deduced for each parameter:</source>
          <target state="translated">각 템플릿 매개 변수에 대해 각 매개 변수에 대해 유형이 추론 될 때까지 다음 규칙이 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="de2d36eb496ad6425d4fddf01b0f74d4997c1c21" translate="yes" xml:space="preserve">
          <source>For each type &lt;code&gt;T&lt;/code&gt; on the left-hand side and each type &lt;code&gt;U&lt;/code&gt; on the right-hand side, values of type &lt;code&gt;T&lt;/code&gt; can be compared with values of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">왼쪽의 각 유형 &lt;code&gt;T&lt;/code&gt; 와 오른쪽의 각 유형 &lt;code&gt;U&lt;/code&gt; 에 대해 &lt;code&gt;T&lt;/code&gt; 유형의 값을 &lt;code&gt;U&lt;/code&gt; 유형의 값과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e27d5d7f20198430510bed8d554d11950a10ed02" translate="yes" xml:space="preserve">
          <source>For each value &lt;code&gt;v1&lt;/code&gt; on the left-hand side and each value &lt;code&gt;v2&lt;/code&gt; on the right-hand side, the expression &lt;code&gt;v1 == v2&lt;/code&gt; is true.</source>
          <target state="translated">왼쪽의 각 값 &lt;code&gt;v1&lt;/code&gt; 과 오른쪽의 각 값 &lt;code&gt;v2&lt;/code&gt; 에 대해 식 &lt;code&gt;v1 == v2&lt;/code&gt; 는 true입니다.</target>
        </trans-unit>
        <trans-unit id="9025d5cca105be0e8976e2851061cc835c9a962a" translate="yes" xml:space="preserve">
          <source>For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; is true. Empty UUIDs are equal to &lt;code&gt;UUID.init&lt;/code&gt;, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID.</source>
          <target state="translated">효율성을 위해 UUID는 구조체로 구현됩니다. 따라서 UUID는 명시 적으로 초기화되지 않은 경우 비어 있습니다. &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; 가 true이면 UUID가 비어 있습니다. 빈 UUID는 16 바이트가 모두 0으로 설정된 UUID 인 &lt;code&gt;UUID.init&lt;/code&gt; 와 같습니다. UUID의 생성자 또는 UUID 생성기 함수를 사용하여 초기화 된 UUID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="62d0aac1e2c0659f1732b0c95533d24eac16f4a7" translate="yes" xml:space="preserve">
          <source>For example the primitives &lt;code&gt;c.remove(r)&lt;/code&gt; and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; both remove the sequence of elements in range &lt;code&gt;r&lt;/code&gt; from the container &lt;code&gt;c&lt;/code&gt;. The primitive &lt;code&gt;c.remove(r)&lt;/code&gt; guarantees &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;) complexity in the worst case and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; relaxes this guarantee to &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;).  Since a sequence of elements can be removed from a &lt;a href=&quot;std_container_dlist&quot;&gt;doubly linked list&lt;/a&gt; in constant time, &lt;code&gt;DList&lt;/code&gt; provides the primitive &lt;code&gt;c.remove(r)&lt;/code&gt; as well as &lt;code&gt;c.linearRemove(r)&lt;/code&gt;. On the other hand &lt;a href=&quot;std_container_array&quot;&gt;Array&lt;/a&gt; only offers &lt;code&gt;c.linearRemove(r)&lt;/code&gt;.  The following table describes the common set of primitives that containers implement. A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the &lt;b&gt;syntax&lt;/b&gt; column with the semantics described in the &lt;b&gt;description&lt;/b&gt; column, and it must not have a worst-case complexity worse than denoted in big-O notation in the &amp;Omicron;(&lt;code&gt;&amp;middot;&lt;/code&gt;) column. Below, &lt;code&gt;C&lt;/code&gt; means a container type, &lt;code&gt;c&lt;/code&gt; is a value of container type, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; represents the effective length of value &lt;code&gt;x&lt;/code&gt;, which could be a single element (in which case &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;), a container, or a range.</source>
          <target state="translated">예를 들어 프리미티브 &lt;code&gt;c.remove(r)&lt;/code&gt; 및 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 는 컨테이너 &lt;code&gt;c&lt;/code&gt; 에서 &lt;code&gt;r&lt;/code&gt; 범위의 요소 시퀀스를 제거합니다 . 프리미티브 &lt;code&gt;c.remove(r)&lt;/code&gt; 는 최악의 경우 &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;r&lt;/sub&gt; log n &lt;sub&gt;c&lt;/sub&gt; ) 복잡성을 보장 하고 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 은이 보증을 &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;c&lt;/sub&gt; ) 로 완화합니다 . 일정한 시간에 &lt;a href=&quot;std_container_dlist&quot;&gt;이중 연결 목록&lt;/a&gt; 에서 일련의 요소를 제거 할 수 있으므로 &lt;code&gt;DList&lt;/code&gt; 는 기본 &lt;code&gt;c.remove(r)&lt;/code&gt; 및 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 합니다. 반면에 &lt;a href=&quot;std_container_array&quot;&gt;배열&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt; &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 만 제공합니다 . 다음 표는 컨테이너가 구현하는 공통 기본 세트를 설명합니다. 컨테이너는 모든 프리미티브를 구현할 필요는 없지만 프리미티브가 구현 된 경우 &lt;b&gt;설명&lt;/b&gt; 열에 설명 된 의미론 을 사용하여 &lt;b&gt;구문&lt;/b&gt; 열에 설명 된 구문을 지원 해야하며, 큰 경우에 표시된 것보다 최악의 복잡도를 갖지 않아야합니다. &amp;Omicron; ( &lt;code&gt;&amp;middot;&lt;/code&gt; ) 열의 O 표기법 . 아래에서 &lt;code&gt;C&lt;/code&gt; 는 컨테이너 유형을 의미하고, &lt;code&gt;c&lt;/code&gt; 는 컨테이너 유형 의 값을 의미하며 , &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;x&lt;/sub&gt; 는 &lt;code&gt;x&lt;/code&gt; 값의 유효 길이를 나타냅니다 . 단일 요소 일 수 있습니다 (이 경우 &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;x&lt;/sub&gt; 는&lt;b&gt;&lt;/b&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt; &lt;code&gt;1&lt;/code&gt; ), 용기 또는 범위.</target>
        </trans-unit>
        <trans-unit id="d00edd8f12a04d1befc302c87668dfdb2d903e2a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\U0001F603&lt;/code&gt; represents the Unicode character U+1F603 (SMILING FACE WITH OPEN MOUTH).</source>
          <target state="translated">예를 들어, &lt;code&gt;\U0001F603&lt;/code&gt; 은 유니 코드 문자 U + 1F603 (SMILING FACE WITH OPEN MOUTH)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bddb2b6572ea79b1700e73180c6a9ef4a9e2c7be" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\u03B3&lt;/code&gt; represents the Unicode character &amp;gamma; (U+03B3 - GREEK SMALL LETTER GAMMA).</source>
          <target state="translated">예를 들어, &lt;code&gt;\u03B3&lt;/code&gt; 은 유니 코드 문자 &amp;gamma; (U + 03B3-GREEK SMALL LETTER GAMMA)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8c9021af829ec2346f217a33bffab12b0880918" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;a[index]&lt;/code&gt; is really &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;s.f&lt;/code&gt; is really &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;a[index]&lt;/code&gt; 는 실제로 &lt;code&gt;a&lt;/code&gt; 이고 &lt;code&gt;s.f&lt;/code&gt; 는 실제로 &lt;code&gt;s&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="429a44b7b476fadc40e55c9fb2ea9f99eab49de1" translate="yes" xml:space="preserve">
          <source>For example, a programmatic equivalent of Unix's &lt;code&gt;chmod +x name&lt;/code&gt; to make a file executable is &lt;code&gt;name.setAttributes(name.getAttributes | octal!700)&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 파일을 실행 가능하게 만드는 Unix의 &lt;code&gt;chmod +x name&lt;/code&gt; 에 해당하는 프로그래밍 방식 은 &lt;code&gt;name.setAttributes(name.getAttributes | octal!700)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aee49e2b5de63bc28985d9e3f5b2391109f50868" translate="yes" xml:space="preserve">
          <source>For example, consider a class that is a container for two elements:</source>
          <target state="translated">예를 들어, 두 요소의 컨테이너 인 클래스를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="f4060213712449048c8c23e8aed13169261c66f1" translate="yes" xml:space="preserve">
          <source>For example, for the Intel Pentium:</source>
          <target state="translated">예를 들어, Intel Pentium의 경우 :</target>
        </trans-unit>
        <trans-unit id="56a66959fa3d6d051e3f2985a858c24aef88cfec" translate="yes" xml:space="preserve">
          <source>For example, given a class &lt;code&gt;Sum&lt;/code&gt; that is used to add two values, a unit test can be given:</source>
          <target state="translated">예를 들어, 두 개의 값을 추가하는 데 사용되는 클래스 &lt;code&gt;Sum&lt;/code&gt; 이 주어지면 단위 ​​테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa20f7fd4e06e98278c1c050fed1f04af8aa95d" translate="yes" xml:space="preserve">
          <source>For example, here is how to remove a single element from an array:</source>
          <target state="translated">예를 들어, 배열에서 단일 요소를 제거하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="664b22b4de56d86a94d4d1f08efe5f39ea8b5955" translate="yes" xml:space="preserve">
          <source>For example, if this qualifies to 'a1.a2' and pkg - to 'a1.a2.a3', this function returns 'true'. If it is other way around or qualified package paths conflict function returns 'false'.</source>
          <target state="translated">예를 들어, 이것이 'a1.a2'및 pkg- 'a1.a2.a3'에 해당되면이 함수는 'true'를 리턴합니다. 다른 방법이거나 한정된 패키지 경로 인 경우 충돌 함수는 'false'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f4a0bc25491ad453cd52460e2badab7db117513" translate="yes" xml:space="preserve">
          <source>For example, in order to overload the &lt;code&gt;-&lt;/code&gt; (negation) operator for struct S, and no other operator:</source>
          <target state="translated">예를 들어, 구조체 S에 대해 &lt;code&gt;-&lt;/code&gt; (음수) 연산자 를 오버로드하고 다른 연산자 는 오버로드 하지 않으 려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1db4a09c9c6a230d99b45c4869c4f6e84c23d582" translate="yes" xml:space="preserve">
          <source>For example, one could redefine &lt;code&gt;DDOC_SUMMARY&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;DDOC_SUMMARY&lt;/code&gt; 를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e5d29b3a3287b6048a7baf84989543162cfde72" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;immutable&lt;/code&gt; type qualifier can be used to create variables of immutable type, such as:</source>
          <target state="translated">예를 들어, &lt;code&gt;immutable&lt;/code&gt; 유형 한정자는 다음과 같은 불변 유형의 변수를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a7c81f27baa62d867db8143dafce975505e522" translate="yes" xml:space="preserve">
          <source>For example, the expression &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; is permitted when &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; are expressions yielding pointers to memory block</source>
          <target state="translated">예를 들어, &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;p2&lt;/code&gt; 가 메모리 블록에 대한 포인터를 생성 하는 표현식 인 경우 표현식 &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="afa193b836783a5ecabcde946cad5a9128e2b421" translate="yes" xml:space="preserve">
          <source>For example, the following function template only matches with odd values of &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 함수 템플릿은 홀수 값 &lt;code&gt;N&lt;/code&gt; 과만 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38096dc369d1ebe6ec7ec60de5ac2d73db72feee" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\101&lt;/code&gt; represents the character with the value 65 (&lt;code&gt;'A'&lt;/code&gt;). Analogous to hexadecimal characters, the largest byte value is &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; in hexadecimal or &lt;code&gt;255&lt;/code&gt; in decimal)</source>
          <target state="translated">예를 들어, &lt;code&gt;\101&lt;/code&gt; 은 값이 65 ( &lt;code&gt;'A'&lt;/code&gt; ) 인 문자를 나타냅니다 . 16 진 문자와 유사하게, 가장 큰 바이트 값은 &lt;code&gt;\377&lt;/code&gt; (= 16 진 &lt;code&gt;\xFF&lt;/code&gt; 또는 10 진 &lt;code&gt;255&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8187ba92149a37ed481170300ec07180dd3c8361" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\xFF&lt;/code&gt; represents the character with the value 255.</source>
          <target state="translated">예를 들어, &lt;code&gt;\xFF&lt;/code&gt; 는 값이 255 인 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d1688fe7c391489009113fe8f20b160cce3978f" translate="yes" xml:space="preserve">
          <source>For examples see the &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">예를 들어 아래의 &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79381ea951fd6aadf813123f5b529dd772681030" translate="yes" xml:space="preserve">
          <source>For finite ranges, the result of &lt;code&gt;opSlice&lt;/code&gt; must be of the same type as the original range type. If the range defines &lt;code&gt;opDollar&lt;/code&gt;, then it must support subtraction.</source>
          <target state="translated">유한 범위의 경우 &lt;code&gt;opSlice&lt;/code&gt; 의 결과 는 원래 범위 유형과 동일한 유형이어야합니다. 범위가 &lt;code&gt;opDollar&lt;/code&gt; 를 정의하면 빼기를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="c77ba69b2b7b1720fb5f6b789826c71a3c605b97" translate="yes" xml:space="preserve">
          <source>For float, double, and real values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. The values &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal. If either or both operands are NAN, then &lt;code&gt;==&lt;/code&gt; returns false and &lt;code&gt;!=&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the bit patterns of the common type are compared for equality.</source>
          <target state="translated">float, double 및 real 값의 경우 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 을 적용하여 비교 전에 공통 유형으로 가져옵니다. 값 &lt;code&gt;-0&lt;/code&gt; 과 &lt;code&gt;+0&lt;/code&gt; 은 동일한 것으로 간주됩니다. 피연산자 중 하나 또는 둘 다가 NAN이면 &lt;code&gt;==&lt;/code&gt; 는 false를 반환하고 &lt;code&gt;!=&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 공통 유형의 비트 패턴이 동일한 지 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ec28333c5408aa27a2824def03dd893394acfa05" translate="yes" xml:space="preserve">
          <source>For floating point inputs, calculations are made in &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt; precision for &lt;code&gt;real&lt;/code&gt; inputs and in &lt;code&gt;double&lt;/code&gt; precision otherwise (Note this is a special case that deviates from &lt;code&gt;fold&lt;/code&gt;'s behavior, which would have kept &lt;code&gt;float&lt;/code&gt; precision for a &lt;code&gt;float&lt;/code&gt; range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;integral promotion&lt;/a&gt;).</source>
          <target state="translated">부동 소수점 입력의 경우 &lt;code&gt;real&lt;/code&gt; 입력에 대해 &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; 정밀도 로 계산 하고 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 밀도로 계산합니다 (이 경우 &lt;code&gt;float&lt;/code&gt; 범위 에 대해 부동 &lt;code&gt;float&lt;/code&gt; 정밀도를 유지 한 &lt;code&gt;fold&lt;/code&gt; 동작 에서 벗어난 특수한 경우입니다 ). 다른 모든 유형의 경우 범위의 두 요소를 추가하여 얻은 동일한 유형으로 계산이 수행되는데, 이는 요소 자체와 다른 유형일 수 있습니다 (예 : &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;통합 승격의&lt;/a&gt; 경우 ).</target>
        </trans-unit>
        <trans-unit id="765c4ec4b98b1848bab9c8fba86795001e6760ec" translate="yes" xml:space="preserve">
          <source>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0.</source>
          <target state="translated">부동 소수점 피연산자의 경우 * 및 / 연산은 IEEE 754 부동 소수점에 해당합니다. %는 IEEE 754 나머지와 동일하지 않습니다. 예를 들어, 15.0 % 10.0 == 5.0 인 반면 IEEE 754의 경우 나머지 (15.0,10.0) == -5.0입니다.</target>
        </trans-unit>
        <trans-unit id="311831dfcbe2aa85299a9b7419ec3f7edbd674b9" translate="yes" xml:space="preserve">
          <source>For floating point operations and expression intermediate values, a greater precision can be used than the type of the expression. Only the minimum precision is set by the types of the operands, not the maximum. &lt;b&gt;Implementation Note:&lt;/b&gt; On Intel x86 machines, for example, it is expected (but not required) that the intermediate calculations be done to the full 80 bits of precision implemented by the hardware.</source>
          <target state="translated">부동 소수점 연산 및 표현식 중간 값의 경우 표현식 유형보다 더 큰 정밀도를 사용할 수 있습니다. 최대 정밀도가 아닌 피연산자의 유형에 의해 최소 정밀도 만 설정됩니다. &lt;b&gt;구현 참고 사항 :&lt;/b&gt; 예를 들어 Intel x86 시스템에서는 중간 계산이 하드웨어에 의해 구현 된 전체 80 비트 정밀도로 수행 될 것으로 예상됩니다 (필요하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="a8f36fac9b0314aa81c6e99d081aedbe4af658c5" translate="yes" xml:space="preserve">
          <source>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</source>
          <target state="translated">플로트의 경우 가능한 최대 페이로드는 0x3F_FFFF입니다. 복식의 경우 0x3_FFFF_FFFF_FFFF입니다. 80 비트 또는 128 비트 실수의 경우 0x3FFF_FFFF_FFFF_FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="f68bb29877591d4b489a9f6fff54379ee749f0f3" translate="yes" xml:space="preserve">
          <source>For forward compatibility, the CPU is compared against different microarchitectures. For 32-bit x86, comparisons are made against the Intel PPro/PII/PIII/PM family.</source>
          <target state="translated">순방향 호환성을 위해 CPU는 다른 마이크로 아키텍처와 비교됩니다. 32 비트 x86의 경우 인텔 PPro / PII / PIII / PM 제품군과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cb68f2aaef1107ffda2b00fc87de858154352d8d" translate="yes" xml:space="preserve">
          <source>For functions which operate on Unicode characters, see &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유니 코드 문자에서 작동하는 함수는 &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c427f88fad780106904fb230a561fe45ae8afed" translate="yes" xml:space="preserve">
          <source>For functions, the &lt;code&gt;auto&lt;/code&gt; attribute means return type inference. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">함수의 경우 &lt;code&gt;auto&lt;/code&gt; 속성은 반환 유형 유추를 의미합니다. &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;자동 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb6e8700842932cee5fe004d021df4907ea6dd83" translate="yes" xml:space="preserve">
          <source>For further information see the the two functions defined inside of this template.</source>
          <target state="translated">자세한 내용은이 템플릿 내에 정의 된 두 가지 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d45ac630dd39944ad55493060e8c4dac92d7fc5" translate="yes" xml:space="preserve">
          <source>For garbage collected pointers and references, however, there are some restrictions. These restrictions are minor, but they are intended to enable the maximum flexibility in garbage collector design.</source>
          <target state="translated">그러나 가비지 수집 포인터 및 참조의 경우 몇 가지 제한 사항이 있습니다. 이러한 제한은 미미하지만 가비지 수집기 디자인에서 최대한의 유연성을 발휘하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7afa355fcaa31af2cd3f80d70dbcf199acfca98" translate="yes" xml:space="preserve">
          <source>For historical compatibility when &lt;code&gt;nbits == 192&lt;/code&gt; and &lt;code&gt;UIntType&lt;/code&gt; is &lt;code&gt;uint&lt;/code&gt; a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of &lt;code&gt;2^^160 - 1&lt;/code&gt; and &lt;code&gt;2^^32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nbits == 192&lt;/code&gt; 이고 &lt;code&gt;UIntType&lt;/code&gt; 이 &lt;code&gt;uint&lt;/code&gt; 인 경우 기록 호환성을 위해 레거시 하이브리드 PRNG는 32 비트 카운터와 결합 된 160 비트 xorshift로 구성됩니다. 이 결합 된 생성기는 &lt;code&gt;2^^160 - 1&lt;/code&gt; 과 &lt;code&gt;2^^32&lt;/code&gt; 의 최소 ​​공배수와 동일한주기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="184c65349a2ddaab04f57fbc0fe983f92c59a278" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worth profiling to see if the void initializer actually improves results.</source>
          <target state="translated">핫 코드 경로의 경우 void 이니셜 라이저가 실제로 결과를 개선하는지 확인하기 위해 프로파일 링 할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="373d2d5153ba00f28887ffdca247e026ee396782" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</source>
          <target state="translated">핫 코드 경로의 경우, void 초기화 프로그램이 실제로 사용하기 전에 결과를 향상시키는 지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4f4bd7aa4cad79620e1f6020bf4450eeadc7446" translate="yes" xml:space="preserve">
          <source>For illustration purposes only, every method call results in assertion failure. Use &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</source>
          <target state="translated">설명 목적으로 만 모든 메서드 호출로 어설 ​​션 오류가 발생합니다. UTF-8 또는 UTF-16 인코딩을위한 구체적 매처를 얻으려면 &lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cd5f2dc243960435d23cc958481129bcfb42bcc" translate="yes" xml:space="preserve">
          <source>For infinite ranges, when</source>
          <target state="translated">무한 범위의 경우</target>
        </trans-unit>
        <trans-unit id="aae2fd6469d641f1e8d553dabcf2fe7c0be1babf" translate="yes" xml:space="preserve">
          <source>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using &lt;code&gt;PopFirst.yes&lt;/code&gt; would tell the function which returned the range that &lt;code&gt;popFront&lt;/code&gt; was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original &lt;code&gt;front&lt;/code&gt;, while when iterating backward, it would be the Easter prior to the original &lt;code&gt;front&lt;/code&gt;). If &lt;code&gt;PopFirst.no&lt;/code&gt; were used, then &lt;code&gt;front&lt;/code&gt; would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval).</source>
          <target state="translated">예를 들어, 일련의 시점을 생성하는 데 사용 된 함수가 연속적인 부활절을 생성 한 경우 (즉, 간격 내 모든 부활절을 반복하는 경우) 초기 날짜는 부활절이 아닐 수 있습니다. 사용 &lt;code&gt;PopFirst.yes&lt;/code&gt; 을 하는 범위에서 반환 된 기능 말할 것 &lt;code&gt;popFront&lt;/code&gt; 가 그 앞에 다음 부활절 될 수 있도록 호출했다 - 기능 (에 의해 생성 된 다음의 일을하는 반복하는 앞으로 원래 다음 부활절 될 때 &lt;code&gt;front&lt;/code&gt; 때 동안, 거꾸로 반복하면 원래 &lt;code&gt;front&lt;/code&gt; 보다 먼저 부활절이 됩니다. &lt;code&gt;PopFirst.no&lt;/code&gt; 가 사용 된 경우 &lt;code&gt;front&lt;/code&gt; 원래 시점을 유지하고 반드시 범위 생성 기능에 의해 생성되는 시점 일 필요는 없습니다 (예를 들어, 간격의 시작에서 시작하여 매일 반복되는 경우). .</target>
        </trans-unit>
        <trans-unit id="1a761bf1c3bac8790220dd0e044887eeb25a2cc8" translate="yes" xml:space="preserve">
          <source>For instructions with the imm8 version: PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</source>
          <target state="translated">imm8 버전에 대한 지침 : PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</target>
        </trans-unit>
        <trans-unit id="abfb408bf733bafad2f02f380cf2ab1c7688837d" translate="yes" xml:space="preserve">
          <source>For instructions: CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</source>
          <target state="translated">지시 사항 : CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</target>
        </trans-unit>
        <trans-unit id="c9f96708c73215da1e5407fa5ce762f21c941725" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 정수 피연산자의 경우 몫은 0으로 반올림되고 나머지는 피제수와 동일한 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2912089b8e4b5f7fb17c30aa7f29625c50f1f39a" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. If the divisor is zero, an Exception is thrown.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 정수 피연산자의 경우 몫은 0으로 반올림되며 나머지는 피제수와 같은 부호를 갖습니다. 제수가 0이면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00fe6a3ea358be700add2733e7f987f7657eccea" translate="yes" xml:space="preserve">
          <source>For integral operands, the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type.</source>
          <target state="translated">정수 피연산자의 경우 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 는 곱하기, 나누기 및 모듈러스 연산에 해당합니다. 곱하기 위해 오버플로는 무시되고 간단하게 정수 유형에 맞게 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f8089e9fce56a8de104b1a2fd89f78f4e3794e38" translate="yes" xml:space="preserve">
          <source>For large file support, there is also a LARGE version of the key which takes an off_t type, allowing platforms with larger off_t sizes to handle larger files. See below for INFILESIZE_LARGE.</source>
          <target state="translated">큰 파일 지원을 위해 off_t 유형을 사용하는 큰 버전의 키도 있으므로 off_t 크기가 큰 플랫폼에서 더 큰 파일을 처리 할 수 ​​있습니다. INFILESIZE_LARGE에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4573bc72a0b35e6968fbc43281884135acda5317" translate="yes" xml:space="preserve">
          <source>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply</source>
          <target state="translated">많은 프로세스에서 grapheme 클러스터는 grapheme base와 동일한 속성을 가진 단일 문자 인 것처럼 동작합니다. 효과적으로 비 간격 표시가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="d9d2c4569580379d483d010c37b2df4e739e00dd" translate="yes" xml:space="preserve">
          <source>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</source>
          <target state="translated">메소드의 경우 메소드가 호출되는 클래스 오브젝트 또는 구조체 값입니다. 중첩 함수의 경우 둘러싸는 함수의 스택 프레임이됩니다.</target>
        </trans-unit>
        <trans-unit id="c658e43c1de6b0fdb8fb67e28199ecda730200d8" translate="yes" xml:space="preserve">
          <source>For more control than the high level functions provide, use the low level API:</source>
          <target state="translated">고수준 함수가 제공하는 것보다 더 많은 제어를 위해서는 저수준 API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="62fcc5c0c32d14129884b840a9ef5db5f9b4d71a" translate="yes" xml:space="preserve">
          <source>For more info about callbacks read the &lt;a href=&quot;function#closures&quot;&gt;closures&lt;/a&gt; section.</source>
          <target state="translated">콜백에 대한 자세한 내용은 &lt;a href=&quot;function#closures&quot;&gt;클로저&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71b3018631aa22db33f776c9f67587180199aba3" translate="yes" xml:space="preserve">
          <source>For more information and a</source>
          <target state="translated">더 많은 정보와</target>
        </trans-unit>
        <trans-unit id="4e48b9f8da2dcff74dfa76b614f30e09e82d9357" translate="yes" xml:space="preserve">
          <source>For more information on normalization forms see the &lt;a href=&quot;#Normalization&quot;&gt;normalization section&lt;/a&gt;.</source>
          <target state="translated">정규화 양식에 대한 자세한 내용은 &lt;a href=&quot;#Normalization&quot;&gt;정규화 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70774a3bc49910eb2a297e31d36c248a26d7f7c" translate="yes" xml:space="preserve">
          <source>For more information please see the full section on &lt;a href=&quot;unittest#documented-unittests&quot;&gt;documented unit tests&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;unittest#documented-unittests&quot;&gt;문서화 된 단위 테스트&lt;/a&gt; 에 대한 전체 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4836c4e8b6fd2beb1b18962cae04c16a239752f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;reference documentation&lt;/a&gt; and the &lt;code&gt;ld&lt;/code&gt; man page.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;참조 설명서&lt;/a&gt; 및 &lt;code&gt;ld&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d343011cf3b0f9c5af4eccef2d47be216bb18517" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;은 D의 최신 COM 프로그래밍을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3833d3948eb765db1f448508cd33cee5954a145d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c75305c01a420c526f9930f5f2afef16712fe3db" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Compile-time Sequences&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;컴파일 타임 시퀀스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="232f8923a5b9a1c36aaeed4b764cc4a027de9c86" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;template#function-templates&quot;&gt;function templates&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;template#function-templates&quot;&gt;함수 템플리트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14fe53fd058540daece4c12310ac08fab7493096" translate="yes" xml:space="preserve">
          <source>For more information, see: &lt;a href=&quot;attribute#uda&quot;&gt;User-Defined Attributes&lt;/a&gt;</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;attribute#uda&quot;&gt;사용자 정의 속성을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b01b147c4aa5229fbefd3dfcace458d961ffaae" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="translated">고유성을 &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;유추&lt;/a&gt; 하는 것에 대한 자세한 내용 은 ArchJava 언어 의 &lt;b&gt;고유&lt;/b&gt; 하고 &lt;b&gt;빌려준&lt;/b&gt; 키워드를 참조하십시오 . &lt;code&gt;assumeUnique&lt;/code&gt; 의 규칙 기반 사용법 을 사용하는 단점은 현재 가정의 정확성에 대한 공식적인 점검이 없다는 것입니다. 거꾸로, &lt;code&gt;assumeUnique&lt;/code&gt; 의 관용적 인 사용 은 간단하고 견딜 수있을 정도로 희귀합니다.</target>
        </trans-unit>
        <trans-unit id="9821fa00e5b3937536d63348fff48dbf21802af0" translate="yes" xml:space="preserve">
          <source>For most purposes, direct usage of this template is not necessary; instead, this module provides default implementations: &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt;, implementing basic Base64 encoding, and &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base64URLNoPadding&quot;&gt;&lt;code&gt;Base64URLNoPadding&lt;/code&gt;&lt;/a&gt;, that implement the Base64 variant for use in URLs and filenames, with and without padding, respectively.</source>
          <target state="translated">대부분의 경우이 템플릿을 직접 사용하지 않아도됩니다. 대신,이 모듈은 기본 구현을 제공 &lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; 로를&lt;/a&gt; 기본 Base64 인코딩을 구현하고, &lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base64URLNoPadding&quot;&gt; &lt;code&gt;Base64URLNoPadding&lt;/code&gt; 은&lt;/a&gt; , 그와 각각 패딩없이 URL과 파일 이름에 사용하기 위해 Base64로 변형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1227b6928512c13bafca17372e6fc839cf749e01" translate="yes" xml:space="preserve">
          <source>For negative durations, all of the split values will be negative.</source>
          <target state="translated">음수 지속 시간의 경우 모든 분할 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="45d1ac4eefadfd952fb52f8057a9eb1805d7b858" translate="yes" xml:space="preserve">
          <source>For non-struct types, &lt;code&gt;move&lt;/code&gt; just performs &lt;code&gt;target = source&lt;/code&gt;:</source>
          <target state="translated">구조체가 아닌 유형의 경우 &lt;code&gt;move&lt;/code&gt; 은 &lt;code&gt;target = source&lt;/code&gt; 만 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="3570c921d353ad6046f6122f9d8cb40d604f2aae" translate="yes" xml:space="preserve">
          <source>For other operand types, identity is defined as being the same as equality.</source>
          <target state="translated">다른 피연산자 유형의 경우 동일성은 동일성과 동일한 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c79c85aac54555c7fe4b24d5b33131b97310e7b3" translate="yes" xml:space="preserve">
          <source>For other sized structs and static arrays, the return value is stored through a hidden pointer passed as an argument to the function.</source>
          <target state="translated">다른 크기의 구조체와 정적 배열의 경우 반환 값은 함수에 인수로 전달 된 숨겨진 포인터를 통해 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c922333737093f82b45fffe13ff631745c29e34e" translate="yes" xml:space="preserve">
          <source>For other types, the argument is built with itself, as in:</source>
          <target state="translated">다른 유형의 경우 인수는 다음과 같이 자체적으로 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="936523f8bfb5590c510abb12f08771cbe0e0675b" translate="yes" xml:space="preserve">
          <source>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</source>
          <target state="translated">t에서 유형으로 구성된 새로운 유형 'this'의 경우 cto, ito, sto, scto, wto 단축키를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4b41c44e66bd12d32d9b45595720696363ec412b" translate="yes" xml:space="preserve">
          <source>For popular C libraries, the first place to look for the corresponding D interface file is the &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;. If it isn't there already, and you write one, please contribute it to the Deimos Project.</source>
          <target state="translated">널리 사용되는 C 라이브러리의 경우 해당 D 인터페이스 파일을 찾는 첫 번째 장소는 &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt; 입니다. 아직 존재하지 않고 작성했다면 Deimos 프로젝트에 공헌하십시오.</target>
        </trans-unit>
        <trans-unit id="dd500fbbdcecf0b15b4a7bec7168a77dbb809b02" translate="yes" xml:space="preserve">
          <source>For precise typing of that area, you can also let the compiler generate the class instance into the DATA segment for you:</source>
          <target state="translated">해당 영역을 정확하게 입력하기 위해 컴파일러가 클래스 인스턴스를 DATA 세그먼트로 생성하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d95500d6486dd9976894874f4bc1686c74984f1a" translate="yes" xml:space="preserve">
          <source>For pretty-printing a type.</source>
          <target state="translated">예쁘게 인쇄 할 때 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6beaf38011ce8934c0bf0fe14801463a84176de7" translate="yes" xml:space="preserve">
          <source>For printing two types with qualification when necessary.</source>
          <target state="translated">필요한 경우 자격을 갖춘 두 가지 유형을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b457b27aba75e0c9b673db93afc4a6454c8737c9" translate="yes" xml:space="preserve">
          <source>For ranges that do not offer random access, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; is the default.</source>
          <target state="translated">임의 액세스를 제공하지 않는 범위의 경우 &lt;code&gt;SearchPolicy.linear&lt;/code&gt; 가 허용되는 유일한 정책입니다 (사용자 코드가 예기치 않은 비 효율성에 노출되지 않도록 명시 적으로 지정해야 함). 임의 액세스 검색의 경우 모든 정책이 허용되며 &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ed3956141d9c50632728180436f8b91fa73ece41" translate="yes" xml:space="preserve">
          <source>For reals, logGamma is equivalent to log(fabs(gamma(x))).</source>
          <target state="translated">실수의 경우 logGamma는 log (fabs (gamma (x)))와 같습니다.</target>
        </trans-unit>
        <trans-unit id="96cc49076f4a58f629be6c15f8c505a83f5ad981" translate="yes" xml:space="preserve">
          <source>For runtime testing to see if certain vector instructions are available, see the functions in &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt;.</source>
          <target state="translated">특정 벡터 명령어를 사용할 수 있는지 확인하기위한 런타임 테스트는 &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt; 의 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0f737f02cc74529ec3e1d25c3b2fb5c37d91021" translate="yes" xml:space="preserve">
          <source>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</source>
          <target state="translated">D에서 C 로의 변환기와 같은 일부 D 구현의 경우 인라인 어셈블러가 의미가 없으며 구현할 필요가 없습니다. 버전 설명을 사용하여이를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432250ecd3da26b3dac3ea1fed77d588163ee5c7" translate="yes" xml:space="preserve">
          <source>For stateless allocators, this does nothing.</source>
          <target state="translated">상태 비 저장 할당 자에게는이 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="098a57b35500f4f0a012b83d59f1556df0c13332" translate="yes" xml:space="preserve">
          <source>For statements implement loops with initialization, test, and increment clauses.</source>
          <target state="translated">For 문은 초기화, 테스트 및 증가 절을 사용하여 루프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="53f702e5ced5b4f4e7dbc696e5107fe16283acd0" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal.</source>
          <target state="translated">정적 및 동적 배열의 경우, 동일성은 배열의 길이가 일치하는 것으로 정의되며 모든 요소가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa40b68079370408167ad68be5b40bbec28bf002" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements.</source>
          <target state="translated">정적 및 동적 배열의 경우 동일성은 동일한 배열 요소와 동일한 수의 요소를 참조하는 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0ec6b65a9ed5b90b70c026136f3fd68edfea3f4e" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as &quot;less&quot; than the longer array.</source>
          <target state="translated">정적 및 동적 배열의 경우 관계형 op의 결과는 연산자가 배열의 첫 번째 같지 않은 요소에 적용된 결과입니다. 두 배열이 동일하지만 길이가 다른 경우 더 짧은 배열은 더 긴 배열보다 &quot;낮음&quot;으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b8a81160066cc4e2c9823b604d02970c2dda27" translate="yes" xml:space="preserve">
          <source>For static arrays:</source>
          <target state="translated">정적 배열의 경우 :</target>
        </trans-unit>
        <trans-unit id="e3e34261f3141bf464d51f74f924244b763433b8" translate="yes" xml:space="preserve">
          <source>For struct objects and floating point values, identity is defined as the bits in the operands being identical.</source>
          <target state="translated">구조체 객체와 부동 소수점 값의 경우 항등은 피연산자의 비트가 동일한 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="dacb4ed6715c30c5a9147d7fcd6915634bae0082" translate="yes" xml:space="preserve">
          <source>For struct objects, equality means the result of the &lt;a href=&quot;operatoroverloading#equals&quot;&gt;&lt;code&gt;opEquals()&lt;/code&gt; member function&lt;/a&gt;. If an &lt;code&gt;opEquals()&lt;/code&gt; is not provided, equality is defined as the logical product of all equality results of the corresponding object fields.</source>
          <target state="translated">구조체 객체의 경우 항등은 &lt;a href=&quot;operatoroverloading#equals&quot;&gt; &lt;code&gt;opEquals()&lt;/code&gt; 멤버 함수&lt;/a&gt; 의 결과를 의미합니다 . 는 IF &lt;code&gt;opEquals()&lt;/code&gt; 제공되지 않고, 평등 해당 개체의 모든 필드 평등 결과의 논리 곱으로 정의된다.</target>
        </trans-unit>
        <trans-unit id="77b81660c87ba600c859281896d0e680dc7a0639" translate="yes" xml:space="preserve">
          <source>For struct types, operator overloading for the identity assignment is allowed.</source>
          <target state="translated">구조체 유형의 경우 아이디 할당에 대한 연산자 오버로드가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6ebd4bd1de4cb13975d6ad6d6494f493e36039" translate="yes" xml:space="preserve">
          <source>For structs that do not define &lt;code&gt;toString&lt;/code&gt;, the conversion to string produces the list of fields.</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 을 정의하지 않은 구조체의 경우 문자열로 변환하면 필드 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24c5ae67500605fc6fe25591d513c37d81e53fba" translate="yes" xml:space="preserve">
          <source>For the &quot;this&quot; parameter to member functions</source>
          <target state="translated">멤버 함수에 대한 &quot;this&quot;매개 변수</target>
        </trans-unit>
        <trans-unit id="1c01d80e91a2499949025f2280ab6ed6d2555900" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; objects which does not have &lt;code&gt;toString&lt;/code&gt;,</source>
          <target state="translated">를 들어 &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;union&lt;/code&gt; 객체하지 않는 &lt;code&gt;toString&lt;/code&gt; 을 ,</target>
        </trans-unit>
        <trans-unit id="4f49cbadbf80fd5534728dbb0a52da7243f0e4cf" translate="yes" xml:space="preserve">
          <source>For the class objects which have input range interface,</source>
          <target state="translated">입력 범위 인터페이스가있는 클래스 객체의 경우</target>
        </trans-unit>
        <trans-unit id="3fe70e23dba2fe2f6a6436972a79f198b1023846" translate="yes" xml:space="preserve">
          <source>For the default implementation, &lt;code&gt;notifyAll&lt;/code&gt;will behave like &lt;code&gt;notify&lt;/code&gt;.</source>
          <target state="translated">기본 구현을 위해, &lt;code&gt;notifyAll&lt;/code&gt; 처럼 행동합니다 &lt;code&gt;notify&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a32f3e2bbec4c5b80346149779ed01edefc9b85" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, a further check is made to see if the function can be called.</source>
          <target state="translated">&lt;code&gt;__traits(compiles, exp)&lt;/code&gt; 표현식의 경우 &lt;code&gt;exp&lt;/code&gt; 는 &lt;code&gt;@property&lt;/code&gt; 입니다. 기능 추가 확인은 함수가 호출 될 수 있는지를 확인하기위한 검사가 행해진 다.</target>
        </trans-unit>
        <trans-unit id="b458b5efdd66ae7f2f84dbe61163a34a752450a1" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;typeof(exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, the type is the return type of the function, rather than the type of the function.</source>
          <target state="translated">표현식 &lt;code&gt;typeof(exp)&lt;/code&gt; 경우 &lt;code&gt;exp&lt;/code&gt; 는 &lt;code&gt;@property&lt;/code&gt; 입니다. 기능, 종류가 함수의 리턴 타입보다는 기능 유형이다.</target>
        </trans-unit>
        <trans-unit id="4da3489e77815a3f59254a16848fd39b736c2ccf" translate="yes" xml:space="preserve">
          <source>For the given module, perform any post parsing analysis. Certain compiler backends (ie: GDC) have special placeholder modules whose source are empty, but code gets injected immediately after loading.</source>
          <target state="translated">지정된 모듈에 대해 사후 분석 분석을 수행하십시오. 특정 컴파일러 백엔드 (예 : GDC)에는 소스가 비어있는 특수 자리 표시 자 모듈이 있지만로드 후 즉시 코드가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="eee09d9bd02ca0e040c01e0c78e4b5fbf6e37934" translate="yes" xml:space="preserve">
          <source>For this CRC32 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 CRC32 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cffc81d750572e8587c7a4c64f2343abc051fae9" translate="yes" xml:space="preserve">
          <source>For this MD5 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 MD5 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed2c37418037d9b0c7a9812c6d18534a64e6ecf7" translate="yes" xml:space="preserve">
          <source>For this RIPEMD160 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 RIPEMD160 다이제스트 구현의 경우 기본 구성 후 start를 호출 할 필요가 없습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="249161f18b734896a386ad2283f2254a90cd8dc8" translate="yes" xml:space="preserve">
          <source>For this SHA Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">이 SHA 다이제스트 구현의 경우 기본 구성 후 start 호출이 필요하지 않습니다. 호출 시작은 다이제스트를 재설정하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29b834a88118650bc23043a0e1a119bc9548636a" translate="yes" xml:space="preserve">
          <source>For unary &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;onOverflow&lt;/code&gt; is called if &lt;code&gt;lhs == Lhs.min&lt;/code&gt; and &lt;code&gt;Lhs&lt;/code&gt; is a signed type. The function returns &lt;code&gt;Lhs.max&lt;/code&gt;.</source>
          <target state="translated">단항의 경우 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;onOverflow&lt;/code&gt; 는 경우라고 &lt;code&gt;lhs == Lhs.min&lt;/code&gt; 및 &lt;code&gt;Lhs&lt;/code&gt; 서명 유형입니다. 이 함수는 &lt;code&gt;Lhs.max&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3735f46e74c34d876c612b5f0d45ae5d470195b4" translate="yes" xml:space="preserve">
          <source>For unsatisfied conditions, the conditionally compiled code need only be syntactically correct. It does not have to be semantically correct.</source>
          <target state="translated">만족스럽지 않은 조건의 경우 조건부로 컴파일 된 코드는 구문 상 정확해야합니다. 의미 적으로 정확할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbc5de8d1ef5491a35e3c236ec7889a9c2c4a94d" translate="yes" xml:space="preserve">
          <source>For use by application</source>
          <target state="translated">응용 프로그램에서 사용</target>
        </trans-unit>
        <trans-unit id="e74c782f1ffbeab9de3e921ce4304765a91d12e2" translate="yes" xml:space="preserve">
          <source>For use by application VFS</source>
          <target state="translated">응용 프로그램 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="3505b0edb5eee92682026f8144fd82b24c70a4f7" translate="yes" xml:space="preserve">
          <source>For use by built-in VFS</source>
          <target state="translated">내장 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="88dbc145581c8c0573b319436a71bb181cd0808c" translate="yes" xml:space="preserve">
          <source>For use by extension VFS</source>
          <target state="translated">확장 VFS에서 사용</target>
        </trans-unit>
        <trans-unit id="230bac78e67f31568eb4729e25ce498036be0132" translate="yes" xml:space="preserve">
          <source>For user defined types. Should be equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 유형의 경우. &lt;code&gt;0&lt;/code&gt; 과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5f2524697bf575ce5005555e479cdd81f208227" translate="yes" xml:space="preserve">
          <source>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue.</source>
          <target state="translated">사용자 정의 형식의 경우 할당 연산자 식은 이진 연산자와 별도로 오버로드됩니다. 여전히 왼쪽 피연산자는 lvalue 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0fb758f20654c3c8f3d278d2ed2c4c22389d5933" translate="yes" xml:space="preserve">
          <source>For using time zones other than local time or UTC, use &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Posix systems (or on Windows, if providing the TZ Database files), and use &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt; on Windows systems. The time in &lt;code&gt;SysTime&lt;/code&gt; is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a &lt;code&gt;SysTime&lt;/code&gt;. &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents the local time, and &lt;code&gt;UTC&lt;/code&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents UTC. &lt;code&gt;SysTime&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; if no &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; is provided. For more details on time zones, see the documentation for &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현지 시간 또는 UTC를 사용 이외의 시간대에 사용하기 위해 &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; POSIX 시스템에서 (또는 Windows에서 TZ 데이터베이스 파일을 제공하는 경우) 및 사용 &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; Windows 시스템을. &lt;code&gt;SysTime&lt;/code&gt; 의 시간은 AD UTC 1 월 1 일 자정부터 내부적 으로 hnsecs 로 유지됩니다. &lt;code&gt;SysTime&lt;/code&gt; 의 시간대를 변경할 때 변환 오류가 발생할 수 없습니다 . &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 은 현지 시간을 나타내는 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 클래스이고 &lt;code&gt;UTC&lt;/code&gt; 는 UTC를 나타내는 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 클래스입니다. &lt;code&gt;SysTime&lt;/code&gt; 은&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 제공되지 않은 경우&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;표준 시간대에 대한 자세한 내용은&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab8570d227afb15f540b536d5d1262c12c2ed538" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="translated">매우 많은 수의 경우 대신 &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP 라이브러리&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb0aaa1972b9827ddaeaa8c903dd012d64dc52a6" translate="yes" xml:space="preserve">
          <source>For very small x, expm1(x) is more accurate than exp(x)-1.</source>
          <target state="translated">매우 작은 x의 경우 expm1 (x)가 exp (x) -1보다 정확합니다.</target>
        </trans-unit>
        <trans-unit id="f6a75d7a9f98a84894db843b9fa129f7e85e4ad5" translate="yes" xml:space="preserve">
          <source>For very small x, log1p(x) will be more accurate than log(1 + x).</source>
          <target state="translated">매우 작은 x의 경우 log1p (x)가 log (1 + x)보다 정확합니다.</target>
        </trans-unit>
        <trans-unit id="d5e2ba36b5f0fe67d03dfd60aced704179f8dc15" translate="yes" xml:space="preserve">
          <source>For virtual tables.</source>
          <target state="translated">가상 테이블의 경우</target>
        </trans-unit>
        <trans-unit id="9b2f5f01d7f036017bc44e0f5e7dd87067f218dd" translate="yes" xml:space="preserve">
          <source>For when the array has a non-zero initializer.</source>
          <target state="translated">배열에 0이 아닌 이니셜 라이저가있는 경우.</target>
        </trans-unit>
        <trans-unit id="62235af30d4d3e83911b7f668444bdadcbf6e31f" translate="yes" xml:space="preserve">
          <source>For which &lt;code&gt;TargetOS&lt;/code&gt; the flags are applicable</source>
          <target state="translated">어떤 &lt;code&gt;TargetOS&lt;/code&gt; 에 플래그를 적용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0512a8baa5c7d81d4b0fde3207bf25c16a72e5f5" translate="yes" xml:space="preserve">
          <source>ForStatement</source>
          <target state="translated">ForStatement</target>
        </trans-unit>
        <trans-unit id="2d317e6f14c862c7eb4252c51b1bf37d642b8a8c" translate="yes" xml:space="preserve">
          <source>ForStatements</source>
          <target state="translated">ForStatements</target>
        </trans-unit>
        <trans-unit id="809149a8ad9a0028e99b6a9d68c6c4147cc5a5e7" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by printing an error message to &lt;code&gt;stderr&lt;/code&gt; and then abort the program. &lt;code&gt;Abort&lt;/code&gt; is the default second argument for &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 오류 메시지를 인쇄 한 후 프로그램을 중단하여 모든 오류를 강제로 실패 하십시오. &lt;code&gt;Abort&lt;/code&gt; 은 &lt;code&gt;Checked&lt;/code&gt; 의 기본 두 번째 인수입니다. .</target>
        </trans-unit>
        <trans-unit id="cb769685cb2418f96e7eb5cd6f3bc4bc9cdba76c" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by throwing an exception of type &lt;code&gt;Throw.CheckFailure&lt;/code&gt;. The message coming with the error is similar to the one printed by &lt;code&gt;Warn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Throw.CheckFailure&lt;/code&gt; 유형의 예외를 발생시켜 모든 적분 오류가 발생하지 않도록 합니다. 오류와 함께 제공되는 메시지는 &lt;code&gt;Warn&lt;/code&gt; 이 인쇄 한 메시지와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="568ec7a75ae095d53209f55c9ce73fe37d60ef50" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;capacity&lt;/code&gt; to at least &lt;code&gt;x&lt;/code&gt; without reducing it.</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; 을 줄이지 않고 최소 &lt;code&gt;x&lt;/code&gt; 로 강제 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="19149ba839181262b9bdb188174930e36e6f0df9" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;this&lt;/code&gt; to the null state.</source>
          <target state="translated">강제로 &lt;code&gt;this&lt;/code&gt; 널 상태로.</target>
        </trans-unit>
        <trans-unit id="a8db5e83b8a35fac9d3b32ebcc923950ddcc52de" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber and then throws obj in the calling fiber.</source>
          <target state="translated">컨텍스트 전환이 호출 파이버에서 멀어 지도록 강제 한 다음 호출 파이버에서 obj를 던집니다.</target>
        </trans-unit>
        <trans-unit id="2f48cbfa34abf44639ec829c0d55463cc9494c97" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber.</source>
          <target state="translated">컨텍스트 전환이 호출 파이버에서 멀어 지도록 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="80579a9d1e587d7b0ea440174e72821dab14c81a" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling thread.</source>
          <target state="translated">컨텍스트 전환이 호출 스레드에서 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="13258c0abcfb4cca178a3b35d4e0664b60f42a89" translate="yes" xml:space="preserve">
          <source>Forces any data buffered by the OS to be written to disk. Call &lt;a href=&quot;#flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before calling this function to flush the C &lt;code&gt;FILE&lt;/code&gt; buffers first.</source>
          <target state="translated">OS에 의해 버퍼링 된 데이터가 디스크에 기록되도록합니다. 전화 &lt;a href=&quot;#flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 는 C 플러시이 함수를 호출하기 전에 &lt;code&gt;FILE&lt;/code&gt; 첫번째 버퍼를.</target>
        </trans-unit>
        <trans-unit id="23e389c62cad5bc7af8046c1d45faa80b7add735" translate="yes" xml:space="preserve">
          <source>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</source>
          <target state="translated">자유 목록 모드를 강제합니다. 이미 사용 가능 목록 모드 인 경우 아무 것도 수행하지 않습니다. 그렇지 않으면 지금까지 누적 된 무료 목록을 정렬하고 향후 할당을위한 전략을 KR 스타일로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="7438f3f3f123487789d348d295cbd3a74e9f3636" translate="yes" xml:space="preserve">
          <source>Forces the number of elements in the container to &lt;code&gt;n&lt;/code&gt;. If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with &lt;code&gt;T.init&lt;/code&gt;).</source>
          <target state="translated">컨테이너의 요소 수를 &lt;code&gt;n&lt;/code&gt; 으로 강제합니다 . 컨테이너가 &lt;code&gt;T.init&lt;/code&gt; 추가 된 요소는 컨테이너에 따라 달라집니다 (일반적으로 T.init 사용 ).</target>
        </trans-unit>
        <trans-unit id="41991c2a7e01e941592d10ca1b4c7b6d194af71f" translate="yes" xml:space="preserve">
          <source>Forcibly deallocates all memory allocated by this allocator, making it available for further allocations. Does not return memory to &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">이 할당자가 할당 한 모든 메모리를 강제로 할당 해제하여 추가 할당에 사용할 수 있도록합니다. &lt;code&gt;ParentAllocator&lt;/code&gt; 에 메모리를 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e05b71be24859a77e2790b0d8e71bc9f4dd8c1f8" translate="yes" xml:space="preserve">
          <source>Foreach</source>
          <target state="translated">Foreach</target>
        </trans-unit>
        <trans-unit id="24a9bd4ac18d7ddab41be52adbe896067b46f066" translate="yes" xml:space="preserve">
          <source>Foreach Range Methods</source>
          <target state="translated">Foreach 범위 방법</target>
        </trans-unit>
        <trans-unit id="2c53155a2e00768b8f625193cebda30089ce0843" translate="yes" xml:space="preserve">
          <source>Foreach Range Properties</source>
          <target state="translated">Foreach 범위 속성</target>
        </trans-unit>
        <trans-unit id="45b6dd48295de07cd5e6e8af0d02a0aba0d48189" translate="yes" xml:space="preserve">
          <source>Foreach Range Statement</source>
          <target state="translated">Foreach 범위 설명</target>
        </trans-unit>
        <trans-unit id="3e61286776c3201ae4e25284f6e9997d2d997281" translate="yes" xml:space="preserve">
          <source>Foreach Ref Parameters</source>
          <target state="translated">Foreach Ref 파라미터</target>
        </trans-unit>
        <trans-unit id="a6c2c1398fe7e48f653dc8f0a8caddaee072679f" translate="yes" xml:space="preserve">
          <source>Foreach Restrictions</source>
          <target state="translated">Foreach 제한 사항</target>
        </trans-unit>
        <trans-unit id="0553132dc6cdd5f87cabaeda4197e661d068c9f8" translate="yes" xml:space="preserve">
          <source>Foreach Statement</source>
          <target state="translated">Foreach 문</target>
        </trans-unit>
        <trans-unit id="da94ac95aa14d4788d7fd4a24d8272c7d97d35a8" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays</source>
          <target state="translated">배열에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="b1b911444dc098ad04d8c1492527b6551f0916f7" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays of Characters</source>
          <target state="translated">여러 문자 배열</target>
        </trans-unit>
        <trans-unit id="2a77599ec0f128dc2ac0586f465739ede0b37cd8" translate="yes" xml:space="preserve">
          <source>Foreach over Associative Arrays</source>
          <target state="translated">연관 배열에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="140fe06b456ed9f1ae3d0c4efbee66b6a7732580" translate="yes" xml:space="preserve">
          <source>Foreach over Delegates</source>
          <target state="translated">위의 대표단</target>
        </trans-unit>
        <trans-unit id="2118d2308b39d4304cee2cfe11851139c70627b5" translate="yes" xml:space="preserve">
          <source>Foreach over Sequences</source>
          <target state="translated">Foreach over 시퀀스</target>
        </trans-unit>
        <trans-unit id="2f65a25f9fa525fd78d322a8ac805a6f39540fba" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with Ranges</source>
          <target state="translated">범위가있는 구조체와 클래스에 대한 Foreach</target>
        </trans-unit>
        <trans-unit id="3d5dd8a83fe426ccb28e159ceb15528fef952829" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with opApply</source>
          <target state="translated">opApply를 사용하여 구조체와 클래스에 대해 Foreach</target>
        </trans-unit>
        <trans-unit id="f667fe9347feaa7cb4e621c258d2edcbe22519e9" translate="yes" xml:space="preserve">
          <source>ForeachAggregate</source>
          <target state="translated">ForeachAggregate</target>
        </trans-unit>
        <trans-unit id="df2d328871cd71e3623bbdef344f4992bcecf2e1" translate="yes" xml:space="preserve">
          <source>ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt;;</source>
          <target state="translated">ForeachRangeStatement 범위 &lt;strong id=&quot;rangefe&quot;&gt;fe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e19df85959b2b1a13377a372c2de5cdf84d1b37" translate="yes" xml:space="preserve">
          <source>ForeachStatement</source>
          <target state="translated">ForeachStatement</target>
        </trans-unit>
        <trans-unit id="9e64b4731b7dbeb3175b639030eb1b4587e3cf60" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;code&gt;fes&lt;/code&gt;</source>
          <target state="translated">ForeachStatement &lt;code&gt;fes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a17c7a682fe18e111c85eb3ffb6f2a4cbaae0f4" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1330e14342be598ec267758faf0b9d03bb95ce41" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="856f0cb9ba209b9b76b5f3f3110e190ba107f316" translate="yes" xml:space="preserve">
          <source>ForeachType</source>
          <target state="translated">ForeachType</target>
        </trans-unit>
        <trans-unit id="9c4e220b832fdde833e953123e22e947e7b36940" translate="yes" xml:space="preserve">
          <source>ForeachType!(PointerTarget!Range)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! (PointerTarget! Range) [] &lt;strong id=&quot;array&quot;&gt;배열&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="b97cbae09882028f8cf2caca90479d52c2db87df" translate="yes" xml:space="preserve">
          <source>ForeachType!Range[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! Range [] &lt;strong id=&quot;array&quot;&gt;배열&lt;/strong&gt; (범위) (범위 r)</target>
        </trans-unit>
        <trans-unit id="6c99353d4eb960ce958a85dea4dafad1de143866" translate="yes" xml:space="preserve">
          <source>ForeachTypeAttribute</source>
          <target state="translated">ForeachTypeAttribute</target>
        </trans-unit>
        <trans-unit id="7ce9ed7c2184e929a253429a20b37b4560fb165d" translate="yes" xml:space="preserve">
          <source>ForeachTypeList</source>
          <target state="translated">ForeachTypeList</target>
        </trans-unit>
        <trans-unit id="3432f720952ad1ef45f41182f803dfead87c5b2b" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Methods</source>
          <target state="translated">Foreach_reverse 범위 방법</target>
        </trans-unit>
        <trans-unit id="b050df33fa944ca9312b95dbcf3146816b9fa5f7" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Properties</source>
          <target state="translated">Foreach_reverse 범위 속성</target>
        </trans-unit>
        <trans-unit id="4f7e5954df7c830e01a29a86da382389a582afe9" translate="yes" xml:space="preserve">
          <source>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</source>
          <target state="translated">식 유형에서 튜플 유형 튜플. exps []가 이미 튜플 확장되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2d244117783206496417e62aa99112e2aad4b472" translate="yes" xml:space="preserve">
          <source>Form feed (FF) (U+000C).</source>
          <target state="translated">용지 공급 (FF) (U + 000C).</target>
        </trans-unit>
        <trans-unit id="676f10eb2f485163d62fd19ea9c8545ba45ba1b3" translate="yes" xml:space="preserve">
          <source>Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">공식적으로 최소 값이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(a, x)&lt;/code&gt; 되는 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; . 반대로, 최대 값이며 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; 되도록 &lt;code&gt;pred(x, a)&lt;/code&gt; 되어 &lt;code&gt;false&lt;/code&gt; 모든 값 의 &lt;code&gt;range&lt;/code&gt; (교체하는 인수를 참고 &lt;code&gt;pred&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="150d9f841097f64a42b925806fe3290abd9bc35d" translate="yes" xml:space="preserve">
          <source>Format String</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="683303f489ff84a56879ace6d1310dfe54be7ff4" translate="yes" xml:space="preserve">
          <source>Format a static condition as a tree-like structure, marking failed and bypassed expressions.</source>
          <target state="translated">정적 조건을 트리와 유사한 구조로 형식화하여 실패하고 무시 된 표현식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="51e82ebaf2db5ec167460d9fcf90c1ef8ea0f2d7" translate="yes" xml:space="preserve">
          <source>Format arguments into a string.</source>
          <target state="translated">인수를 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="b0fb6e308cc109a50167ee0e6731cc7e72eb7494" translate="yes" xml:space="preserve">
          <source>Format arguments into buffer</source>
          <target state="translated">인수를 버퍼로 포맷</target>
        </trans-unit>
        <trans-unit id="926bb79848aace359e9158738e215805c41e663b" translate="yes" xml:space="preserve">
          <source>Format data into strings.</source>
          <target state="translated">데이터를 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="23e10a3db64de41eba0cd45a912f85a4b56f3f1b" translate="yes" xml:space="preserve">
          <source>Format flags for CustomFloat.</source>
          <target state="translated">CustomFloat의 형식 플래그</target>
        </trans-unit>
        <trans-unit id="9bc6c7decb7638f7f45249d89d49acf2bfdc2a16" translate="yes" xml:space="preserve">
          <source>Format like &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt; 과 같은 형식 ! (유형) (각각 % s로 형식이 지정된 요소) .</target>
        </trans-unit>
        <trans-unit id="02e42cbae72865d54225666f797f795a1b96d6bb" translate="yes" xml:space="preserve">
          <source>Format specifier</source>
          <target state="translated">형식 지정자</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">형식 문자열.</target>
        </trans-unit>
        <trans-unit id="ee3b46d05547f4e1ed0fb6b16e92db78c1a30405" translate="yes" xml:space="preserve">
          <source>Format string. For detailed specification, see &lt;a href=&quot;#formattedWrite&quot;&gt;&lt;code&gt;formattedWrite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열. 자세한 사양은 &lt;a href=&quot;#formattedWrite&quot;&gt; &lt;code&gt;formattedWrite&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9e1764b317ef266e49f202653a88a32e68ea2fd" translate="yes" xml:space="preserve">
          <source>Format to a string such as: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt; 와 같은 문자열로 형식을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="69dbb2a04350f8cee981103c2cb9db39585e38b6" translate="yes" xml:space="preserve">
          <source>Format version needed to extract this member.</source>
          <target state="translated">이 멤버를 추출하는 데 필요한 형식 버전입니다.</target>
        </trans-unit>
        <trans-unit id="e7a8c4c502d36efd7cdb40b63094b0c90409c783" translate="yes" xml:space="preserve">
          <source>FormatChar</source>
          <target state="translated">FormatChar</target>
        </trans-unit>
        <trans-unit id="d7ab63d27b9f2759987e52fd620d64164025e796" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb9d269d7b56db9164861bd1ad68cf391c388350" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb49409d4c929c4b7d5f9fa3a44391c37114d5" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;spec&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;spec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f215319169c289fbb719f3b0d628a3b737f8eded" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;(Char)(Char[] fmt);</source>
          <target state="translated">FormatSpec! Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt; (Char) (Char [] fmt);</target>
        </trans-unit>
        <trans-unit id="ff3a107be5350e9cbdf489fea1b9a3cb189415cc" translate="yes" xml:space="preserve">
          <source>FormatSpec!char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d214509fa791f89f2be58f52b1b3767a22ec982d" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;Tuple&lt;/code&gt; with either &lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%(inner%)&lt;/code&gt; or &lt;code&gt;%(inner%|sep%)&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;Tuple&lt;/code&gt; 하나와 &lt;code&gt;%s&lt;/code&gt; , &lt;code&gt;%(inner%)&lt;/code&gt; 또는 &lt;code&gt;%(inner%|sep%)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36fd923e1d2f6994803ec17defea621b9f080f14" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer, followed by a newline.</source>
          <target state="translated">인수를 텍스트 형식으로 OutBuffer에 형식화하고 그 뒤에 줄 바꾸기를 씁니다.</target>
        </trans-unit>
        <trans-unit id="7071823457762f9707da94f7448fddbd240e7baf" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer.</source>
          <target state="translated">인수를 텍스트 형식으로 OutBuffer에 형식화하고 씁니다.</target>
        </trans-unit>
        <trans-unit id="a51cf9b2e5a5b055fe6bcc1d2693b2624065293b" translate="yes" xml:space="preserve">
          <source>Formats any value into &lt;code&gt;Char&lt;/code&gt; accepting &lt;code&gt;OutputRange&lt;/code&gt;, using the given &lt;code&gt;FormatSpec&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;FormatSpec&lt;/code&gt; 을 사용하여 모든 값을 &lt;code&gt;Char&lt;/code&gt; 로 &lt;code&gt;OutputRange&lt;/code&gt; 허용 .</target>
        </trans-unit>
        <trans-unit id="6b1857e4f5a36639d321cc75f53c946b6701eca2" translate="yes" xml:space="preserve">
          <source>Formats its arguments according to the format string and puts them to an OutputRange.</source>
          <target state="translated">형식 문자열에 따라 인수를 형식화하고 OutputRange에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7b102bb156b0812a82b4b3cc910bf7cff6a74f11" translate="yes" xml:space="preserve">
          <source>Formats supported by Tuple</source>
          <target state="translated">Tuple에서 지원하는 형식</target>
        </trans-unit>
        <trans-unit id="1eebc61a97141f60643e629482bce7edcfb75fe1" translate="yes" xml:space="preserve">
          <source>Formats the &lt;code&gt;Options&lt;/code&gt; for CLI printing.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 형식 CLI 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="026cf84e486080b485be195c8355623b05fc9001" translate="yes" xml:space="preserve">
          <source>Formats the RedBlackTree into a sink function. For more info see &lt;code&gt; std.format.formatValue&lt;/code&gt;. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</source>
          <target state="translated">RedBlackTree를 싱크 함수로 포맷합니다. 자세한 정보는 &lt;code&gt; std.format.formatValue&lt;/code&gt; 를 참조하십시오 . . 요소 유형을 형식화 할 수있는 경우에만 사용할 수 있습니다. 그렇지 않으면 Object의 기본 toString이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1c1d1c97be2b241e71fcbcd57b8c7212c71103" translate="yes" xml:space="preserve">
          <source>Formats the stored value as a string.</source>
          <target state="translated">저장된 값을 문자열로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">형식화 된 문자열 인쇄 기능</target>
        </trans-unit>
        <trans-unit id="fc5187ca67d19625ec5705d6a55febca2c516352" translate="yes" xml:space="preserve">
          <source>Formatted number of arguments.</source>
          <target state="translated">형식화 된 인수 수</target>
        </trans-unit>
        <trans-unit id="dfdf9e737f02222e3b629df49845cd2f57eea582" translate="yes" xml:space="preserve">
          <source>Formatting a struct by defining a method &lt;code&gt;toString&lt;/code&gt;, which takes an output range.  It's recommended that any &lt;code&gt;toString&lt;/code&gt; using &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output ranges&lt;/a&gt; use &lt;a href=&quot;std_range_primitives#put&quot;&gt;&lt;code&gt;std.range.primitives.put&lt;/code&gt;&lt;/a&gt; rather than use the &lt;code&gt;put&lt;/code&gt; method of the range directly.</source>
          <target state="translated">출력 범위를 취하는 &lt;code&gt;toString&lt;/code&gt; 메소드를 정의하여 구조체를 형식화합니다 . &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위를&lt;/a&gt; 사용 하는 모든 &lt;code&gt;toString&lt;/code&gt; 은 &lt;code&gt;put&lt;/code&gt; 을 사용하지 않고 &lt;a href=&quot;std_range_primitives#put&quot;&gt; &lt;code&gt;std.range.primitives.put&lt;/code&gt; 을&lt;/a&gt; 사용 하는 것이 좋습니다. 은 범위 메소드를 직접 .</target>
        </trans-unit>
        <trans-unit id="8e465166e94e67eebeab101e4359626150ec10a5" translate="yes" xml:space="preserve">
          <source>Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported.</source>
          <target state="translated">모든 D 프로그램에서 사용할 수있는 기호를 형성합니다. 클래스 객체 계층의 루트 인 Object를 포함합니다. 이 모듈은 내재적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="be4f9eeadbcbd0250352284fb3cd5289c89dd0aa" translate="yes" xml:space="preserve">
          <source>Forward range primitive.</source>
          <target state="translated">순방향 범위 기본 요소.</target>
        </trans-unit>
        <trans-unit id="f29ecd0a8c2e85a8dd0a05e6e1849d59d6e26721" translate="yes" xml:space="preserve">
          <source>Forward range primitives.</source>
          <target state="translated">순방향 프리미티브.</target>
        </trans-unit>
        <trans-unit id="0aa520a29c82bb14e915d25c13dc5e309db9aa45" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Always present.</source>
          <target state="translated">순방향 프리미티브. 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="d22e131c3ac191040ab33d51c37ffdb89ec4f5bd" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Only present if &lt;code&gt;Source&lt;/code&gt; is a forward range.</source>
          <target state="translated">순방향 프리미티브. &lt;code&gt;Source&lt;/code&gt; 가 순방향 범위 인 경우에만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="97bc99924d633226857a96f6afec14fc043cb16b" translate="yes" xml:space="preserve">
          <source>Forward range to check for sortedness.</source>
          <target state="translated">정렬을 점검하기위한 정방향 범위.</target>
        </trans-unit>
        <trans-unit id="7657ababded98f92f21842f17fb3c2a8cd28a85d" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opSlice().back&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="f670785452e24c08e6662a674722599db21dae68" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().front&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opSlice().front&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="406d6f916ef4dc2cf86b7e71d06ceb89e750f775" translate="yes" xml:space="preserve">
          <source>Forward.</source>
          <target state="translated">Forward.</target>
        </trans-unit>
        <trans-unit id="619c49003b4924854c54d8f88890d01e742d1cdb" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;back&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;back&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef30f2488fc02c13b78587f98f5f66b1ed09c755" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;choices&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;choices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="073a409c0a0f8fb805007ded8e0840b82337c88e" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;filler&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;filler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d735aafe3953821674bcc047eed0a464f448083f" translate="yes" xml:space="preserve">
          <source>Forwarding</source>
          <target state="translated">Forwarding</target>
        </trans-unit>
        <trans-unit id="59753dcda35fa8785a7cb0df7205b2d4bd41fb72" translate="yes" xml:space="preserve">
          <source>Forwarding ScopeDsymbol. Used by ForwardingAttribDeclaration and ForwardingScopeDeclaration to forward symbol insertions to another scope. See &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; for more details.</source>
          <target state="translated">전달 범위 기호 ForwardingAttribDeclaration 및 ForwardingScopeDeclaration에서 심볼 삽입을 다른 범위로 전달하는 데 사용됩니다. 자세한 내용은 &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8c3c38ee76d4f3b54240c75f491818942150299" translate="yes" xml:space="preserve">
          <source>ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt;;</source>
          <target state="translated">ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="350d94101794444e552e24c257a1f22a4fbe99df" translate="yes" xml:space="preserve">
          <source>ForwardingStatements are distributed over the flattened sequence of statements. This prevents flattening to be &quot;blocked&quot; by a ForwardingStatement and is necessary, for example, to support generating scope guards with `static foreach`:</source>
          <target state="translated">ForwardingStatement는 평탄화 된 일련의 명령문으로 분산됩니다. 이는 FlatingStatement에 의해 평탄화가 &quot;차단&quot;되는 것을 방지하며, 예를 들어 'static foreach'를 사용하여 스코프 가드 생성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="692658a69283f7fb6a21aa51f11e5d6d2994d5d3" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="5654a0e021e96bad526eccdeb7cb0d25a7be5435" translate="yes" xml:space="preserve">
          <source>Forwards each of the methods in &lt;code&gt;funs&lt;/code&gt; (if defined) to &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funs&lt;/code&gt; (정의 된 경우)의 각 메소드 를 &lt;code&gt;member&lt;/code&gt; 에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="e165afdb83bce78d5a7427c72318f24d46092f4d" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while keeping &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; on the parameters.</source>
          <target state="translated">유지하면서 앞으로 인수를 작동 &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , 그리고 &lt;code&gt;lazy&lt;/code&gt; 매개 변수에.</target>
        </trans-unit>
        <trans-unit id="9385c6728b753fbb370a1c4f1034c150548b8bf1" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while saving ref-ness.</source>
          <target state="translated">참조를 저장하면서 함수 인수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9bf1ea57d6c29870d04450f92da2598f5a795126" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e78d71ac4fe9046b06039c1f36978f900fc90d21" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt;. Should be used with blocks obtained with &lt;code&gt;allocate&lt;/code&gt; otherwise the custom alignment passed with &lt;code&gt;alignedAllocate&lt;/code&gt; can be lost.</source>
          <target state="translated">이 전진 &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt; . &lt;code&gt;allocate&lt;/code&gt; 얻은 블록과 함께 사용해야합니다. 그렇지 않으면 &lt;code&gt;alignedAllocate&lt;/code&gt; 와 함께 전달 된 사용자 지정 정렬 이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d788f6c07eb5fb2e6319214dbdc4af6789c0f502" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.alignedReallocate&lt;/code&gt; if defined, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;impl.alignedReallocate&lt;/code&gt; 로 전달하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8bd9cee5dc99654ad10a48eac7f3712c848d2492" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.empty()&lt;/code&gt; if defined, otherwise returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;impl.empty()&lt;/code&gt; 전달하고 그렇지 않으면 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="acf2453169c3a58c2868738f1fc21eb777d091c4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;insertBack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insertBack&lt;/code&gt; 으로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="60a899e29a86abcd90907c95435a5280010cfeb4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.alignedAllocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.alignedAllocate&lt;/code&gt; 로 전달합니다 . 인스턴스에 미치는 영향 : &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 및 &lt;code&gt;bytesHighTide&lt;/code&gt; . 호출 당 영향 : &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 및 &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de51b91db75956f253cd2e990aebff215db91a5" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.allocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt; numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate&lt;/code&gt; 로 전달합니다 . 인스턴스에 미치는 영향 : &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAllocateOK&lt;/code&gt; 및 &lt;code&gt;bytesHighTide&lt;/code&gt; . 호출 당 영향 : &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt; numAllocateOK&lt;/code&gt; 및 &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcaf3b31885140c27644f437101ba9113ddebba0" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.expand(b, delta)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.expand(b, delta)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="b27aa4f3be329203334bb86f539151cb305c808b" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.goodAllocSize&lt;/code&gt; (which accounts for the management overhead).</source>
          <target state="translated">관리 오버 헤드를 설명 하는 &lt;code&gt;parent.goodAllocSize&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8e660798dc338a8a1471f38403abdf431c688a" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.owns(b)&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c49defce19fbb5c360ddd5f8418442bee4a9e756" translate="yes" xml:space="preserve">
          <source>Found function if it satisfies &lt;code&gt;isThis()&lt;/code&gt;, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isThis()&lt;/code&gt; 만족하면 함수를 찾았습니다 . 그렇지 않으면 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5b2644294a615403e1d25df5a0697b50b1f11f" translate="yes" xml:space="preserve">
          <source>Fractional seconds past the second (i.e. the portion of a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is less than a second).</source>
          <target state="translated">초를 지나는 분수 초 (즉, 1 초 미만 의 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 부분 ).</target>
        </trans-unit>
        <trans-unit id="379f2457e03cb11d9fb2efb285637d5db4d20d0e" translate="yes" xml:space="preserve">
          <source>Framework Paths</source>
          <target state="translated">프레임 워크 경로</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="76f3bbf403c0a1d06091b2e954aa5148b52956ac" translate="yes" xml:space="preserve">
          <source>Free ExceptionHeader that was created by create().</source>
          <target state="translated">create ()로 작성된 무료 ExceptionHeader입니다.</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">데이터베이스 연결에 사용 된 여유 메모리</target>
        </trans-unit>
        <trans-unit id="ebc0d55c1803ae64cbd97a59b9b2802ad68ac4a1" translate="yes" xml:space="preserve">
          <source>Free a data definition struct.</source>
          <target state="translated">데이터 정의 구조체를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b863a7908826b1af85e7908ab51bda44bf1ecda4" translate="yes" xml:space="preserve">
          <source>Free a multipart formpost previously built with curl_formadd().</source>
          <target state="translated">curl_formadd ()로 이전에 빌드 한 멀티 파트 폼 포스트를 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="3195ad8b795496334c672bd13584f65569ba68b7" translate="yes" xml:space="preserve">
          <source>Free a prior allocation</source>
          <target state="translated">사전 할당 해제</target>
        </trans-unit>
        <trans-unit id="b1f545998e095b9a06b4728df726ebf0dad217f2" translate="yes" xml:space="preserve">
          <source>Free blocks have variable size and are linked in a singly-linked list.</source>
          <target state="translated">사용 가능한 블록의 크기는 가변적이며 단일 연결 목록으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8b5134a1b2ec3e5e93b6a487571bc8ad9bf630" translate="yes" xml:space="preserve">
          <source>Free free list.</source>
          <target state="translated">무료 무료 목록.</target>
        </trans-unit>
        <trans-unit id="0917613170fb85672a58086626671da808078654" translate="yes" xml:space="preserve">
          <source>Free idxStr using sqlite3_free() if true</source>
          <target state="translated">true 인 경우 sqlite3_free ()를 사용하여 무료 idxStr</target>
        </trans-unit>
        <trans-unit id="98a1ae48a4466ad89a88d462e43c40189625122d" translate="yes" xml:space="preserve">
          <source>Free list built on top of exactly one contiguous block of memory. The block is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;, and is released in &lt;code&gt;ContiguousFreeList&lt;/code&gt;'s destructor (unless &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;).</source>
          <target state="translated">정확히 하나의 연속 된 메모리 블록 위에 구축 된 사용 가능 목록. 블록이 할당 된 것으로 가정한다 &lt;code&gt;ParentAllocator&lt;/code&gt; 및 해제에 &lt;code&gt;ContiguousFreeList&lt;/code&gt; (않는 소멸자 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 있다 &lt;code&gt;NullAllocator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10d99eecb5370b60ca034187daa4ef1e45d53646" translate="yes" xml:space="preserve">
          <source>Free list.</source>
          <target state="translated">무료 목록.</target>
        </trans-unit>
        <trans-unit id="56d7e4661565975bfba4769fa7e3d64507696d05" translate="yes" xml:space="preserve">
          <source>Free memory allocated by FileName routines</source>
          <target state="translated">FileName 루틴에 의해 할당 된 사용 가능한 메모리</target>
        </trans-unit>
        <trans-unit id="f7c1a4f30544ddc6377c5a280a73f14897416990" translate="yes" xml:space="preserve">
          <source>Free returned value with FileName::free()</source>
          <target state="translated">FileName :: free ()를 사용하여 반환 된 값을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="3b18d56d2ee33e5deee0527f6a5620f9d07c8560" translate="yes" xml:space="preserve">
          <source>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions.</source>
          <target state="translated">자유 형식 구문은 패턴의 공백을 무시하고 복잡한 정규식을 형식화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="927e12a7e999b3e0f18d3a882968560f012cc81f" translate="yes" xml:space="preserve">
          <source>FreeBSD-Only</source>
          <target state="translated">FreeBSD-Only</target>
        </trans-unit>
        <trans-unit id="736e4cd346eb715c4446b514550578d814d7d0e0" translate="yes" xml:space="preserve">
          <source>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has &lt;code&gt;CLOCK_SECOND&lt;/code&gt; to use with &lt;code&gt;clock_gettime&lt;/code&gt; which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting &lt;code&gt;SysTime&lt;/code&gt; will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than &lt;code&gt;ClockType.normal&lt;/code&gt;, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions.</source>
          <target state="translated">FreeBSD / DragonFlyBSD는이를 위해 특별히 클럭을 설정 한 유일한 시스템입니다 (클럭 내 캐시 된 값 을 이용하는 &lt;code&gt;clock_gettime&lt;/code&gt; 과 함께 사용할 &lt;code&gt;CLOCK_SECOND&lt;/code&gt; 가 있음 ). 다른 시스템에서는 가장 빠른 기능이 사용됩니다. 사용 된 클럭이 더 정확한 해상도로 시간을 &lt;code&gt;SysTime&lt;/code&gt; 결과 SysTime 은 초로 반올림됩니다. 따라서 시간은 1 초의 정밀도로 보장 되며 시스템에서 저해상도에서 시간을 얻는 여러 옵션이있는 경향이 있기 때문에 &lt;code&gt;ClockType.normal&lt;/code&gt; 보다 빠를 가능성이 높습니다. 고해상도에서 시간을 보내는 것보다 빠른 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9cdca34912cf1be0977006662f6f41677329f87" translate="yes" xml:space="preserve">
          <source>FreeList shared across threads. Allocation and deallocation are lock-free. The parameters have the same semantics as for &lt;code&gt;FreeList&lt;/code&gt;.</source>
          <target state="translated">스레드간에 FreeList가 공유되었습니다. 할당 및 할당 해제는 잠금이 없습니다. 매개 변수는 &lt;code&gt;FreeList&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdbf1c9047d64cde03eaed8b92301afb24c8b3e" translate="yes" xml:space="preserve">
          <source>Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.</source>
          <target state="translated">활성 포인터가없고 소멸자를 실행할 필요가없는 모든 GC 할당 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9c1d262fbf3a7e284bb2c20e67267943ef09c825" translate="yes" xml:space="preserve">
          <source>Freeing any remaining unreachable memory.</source>
          <target state="translated">연결할 수없는 나머지 메모리를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b1843177cd4be06555f8650438e2f5cee23b6d7c" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated for &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is a reference to a class or interface, the memory allocated for the underlying instance is freed. If &lt;code&gt;x&lt;/code&gt; is a pointer, the memory allocated for the pointed-to object is freed. If &lt;code&gt;x&lt;/code&gt; is a built-in array, the memory allocated for the array is freed. If &lt;code&gt;x&lt;/code&gt; does not refer to memory previously allocated with &lt;code&gt;new&lt;/code&gt; (or the lower-level equivalents in the GC API), the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 할당 된 메모리를 해제합니다 . &lt;code&gt;x&lt;/code&gt; 가 클래스 또는 인터페이스에 대한 참조 인 경우 기본 인스턴스에 할당 된 메모리가 해제됩니다. 경우 &lt;code&gt;x&lt;/code&gt; 는 포인터이며, 메모리는 지적-에 객체가 해제됩니다에 할당. 경우 &lt;code&gt;x&lt;/code&gt; 되는 내장 된 어레이 배열에 할당 된 메모리가 해제된다. 경우 &lt;code&gt;x&lt;/code&gt; 는 이전에 할당 된 메모리를 참조하지 않는 &lt;code&gt;new&lt;/code&gt; (GC가 API 나 낮은 수준의 당량), 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="306cb21df3375fca60d15a5cf9f358aab2a447e3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db2022114f51428d23663985d9512c4f397b106d" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dcadc69133dc56548eb2198fe024d580cc53763" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e8638502dca540c07f22be8e25e01957c58dc0f" translate="yes" xml:space="preserve">
          <source>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</source>
          <target state="translated">포스트 블릿 관점에서, 구조체 정의를 규정하면 포스트 블릿을 명시 적으로 규정하는 것과 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4300cea6afd6c5c0528f1834abaff027668e0ed" translate="yes" xml:space="preserve">
          <source>From units</source>
          <target state="translated">단위에서</target>
        </trans-unit>
        <trans-unit id="87b5b5d7f217c54f10b305679e84d27b0ffddee6" translate="yes" xml:space="preserve">
          <source>Front-end expression rewriting should create temporary variables for non trivial sub-expressions in order to: 1. save evaluation order 2. prevent sharing of sub-expression in AST</source>
          <target state="translated">프론트 엔드 표현식 재 작성은 다음을 수행하기 위해 사소한 하위 표현식에 대한 임시 변수를 작성해야합니다. 1. 평가 순서 저장 2. AST에서 하위 표현식의 공유 방지</target>
        </trans-unit>
        <trans-unit id="d866f093f3136af5a6cee1f9313a0fdd24da6c23" translate="yes" xml:space="preserve">
          <source>FrontTransversal!(RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr);</source>
          <target state="translated">FrontTransversal! (RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr);</target>
        </trans-unit>
        <trans-unit id="b96493999dfb84df4fdc104ae8dc68c5ab28eeb6" translate="yes" xml:space="preserve">
          <source>Full Usage Example</source>
          <target state="translated">전체 사용 예</target>
        </trans-unit>
        <trans-unit id="dd2159a885b04c76ad21acb9e9df96e1b3df4a78" translate="yes" xml:space="preserve">
          <source>Full content of the file to be written</source>
          <target state="translated">쓸 파일의 전체 내용</target>
        </trans-unit>
        <trans-unit id="890fb87ee1e5cddd39317993afd9de0de79b7d45" translate="yes" xml:space="preserve">
          <source>Full metaprogramming facilities</source>
          <target state="translated">완전한 메타 프로그래밍 시설</target>
        </trans-unit>
        <trans-unit id="0c7ebd23a12a9077c88a3e9d528a97811a94a547" translate="yes" xml:space="preserve">
          <source>Fully sequenced (acquire + release). Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">완전히 시퀀싱되었습니다 (획득 + 릴리스). 에 해당하는 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; 및 C ++ 11 / C11의 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="244c67389fed3259f84c95197cc9eb3648ddcb0d" translate="yes" xml:space="preserve">
          <source>Fully working example is available at &lt;a href=&quot;#usage-example&quot;&gt;the bottom&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#usage-example&quot;&gt;아래&lt;/a&gt; 에서 완전한 작업 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d32cb0b70d83396fe47823d8472eaa9476a37437" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c96c463b9529c91720bbc72354f9466bd3c26f" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;fd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fd968926da674858b925b704767caf618b18035" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</source>
          <target state="translated">기능 선언 &lt;code&gt;fdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e24cae0141215bceece007770b580c50fd2f38" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">선언 &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3b288cb44551e47fdefb27fe0ea167fb4d1483" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="2e19843cd5ed176434a3efaeff7d8bda7426dc57" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="03359c276bccc50045b57bc8ace08bc6d8f2ae59" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="507d5c363210e3f23b2c42085b0c0ff39e10c2cc" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="859ef670635a842eaebad8ac23f82e95392d9e8c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="dc070bb95306fb1a92b40edce98353f4664181ad" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="a30ba00bb5d45e8e8a6da89f6ff22fb9cbecb606" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt; (TemplateInstance ti, Scope * sc2, FuncDeclaration fd, 타입 tthis, Expressions * fargs);</target>
        </trans-unit>
        <trans-unit id="d05a566062ec8864bd0d4c9e283c124ce8c44dfa" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt;;</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e42a220d72031c5ac346bcdb8b0d4dc5655921c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d75bdbbe19a26e762aba1b2f76a15fde383c64a0" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="fb1ead50f11e27697b705598972fc6d1ffead188" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">기능 선언에는 &lt;strong id=&quot;hasThis&quot;&gt;이것&lt;/strong&gt; (Scope * sc)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8e5d63f59418c4c2add44a220d39f8eb8d7843" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt;;</source>
          <target state="translated">기능 선언 &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e92604a27d4e8a86aead189ab657e429f7804d91" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt; (참조 const Loc loc, Scope * sc, Dsymbol s, Objects * tiargs, 유형 tthis, Expressions * fargs, FuncResolveFlag 플래그 참조);</target>
        </trans-unit>
        <trans-unit id="6bc7f2dda0d8c4f33d8fa77e2a6866f9c3e063da" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;(StructDeclaration sd);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt; (StructDeclaration의 SD);</target>
        </trans-unit>
        <trans-unit id="d2f8d9014611a673032f33ed2918b0db3cbea6e7" translate="yes" xml:space="preserve">
          <source>FuncDeclaration of &lt;code&gt;toString()&lt;/code&gt; if found, &lt;code&gt;null&lt;/code&gt; if not</source>
          <target state="translated">발견되면 &lt;code&gt;toString()&lt;/code&gt; FuncDeclaration , 없으면 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0de7865b78f78b6942752a1607fa8f3decdf8f8b" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cefac5fb4c4f6f7aad7982a9de7b94425bbd152a" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1147d19864a2f24679061fb745f4f2745312dc4d" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</source>
          <target state="translated">FuncLiteral 선언 &lt;code&gt;l1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34754aacf81ddb7c1a4c8be9c611413058146f76" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</source>
          <target state="translated">FuncLiteral 선언 &lt;code&gt;l2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df7e78750c597d40962880c788feb5d42d0507c" translate="yes" xml:space="preserve">
          <source>FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d148d41b57da4467de12a195094eac776bca54d" translate="yes" xml:space="preserve">
          <source>Function Attribute Inference</source>
          <target state="translated">함수 속성 추론</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">기능 보조 데이터</target>
        </trans-unit>
        <trans-unit id="7cb4de12c910c8d000862c6b8806ba33b405085e" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading</source>
          <target state="translated">함수 호출 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="b257168e280b545833c00a892f5a9654498e1038" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading &lt;code&gt;f()&lt;/code&gt;</source>
          <target state="translated">함수 호출 연산자 오버로드 &lt;code&gt;f()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287c317aff3ca62b6d115ccce3c3993c93d19bb1" translate="yes" xml:space="preserve">
          <source>Function Calling Conventions</source>
          <target state="translated">함수 호출 규칙</target>
        </trans-unit>
        <trans-unit id="897aa7901cb2b135a5d5c44d09b74d23db3807ca" translate="yes" xml:space="preserve">
          <source>Function Default Arguments</source>
          <target state="translated">함수 기본 인수</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">기능 플래그</target>
        </trans-unit>
        <trans-unit id="d8861f5c13214753c72cc4ec28a42da4d33141ab" translate="yes" xml:space="preserve">
          <source>Function Inheritance and Overriding</source>
          <target state="translated">함수 상속과 재정의</target>
        </trans-unit>
        <trans-unit id="5bcb901ef2c2acd0ad4fdd3aaa4dbd63df1c459e" translate="yes" xml:space="preserve">
          <source>Function Literals</source>
          <target state="translated">함수 리터럴</target>
        </trans-unit>
        <trans-unit id="a9ab374cd6bd246bd36d7f40fb0af05f53c4d5a7" translate="yes" xml:space="preserve">
          <source>Function Name</source>
          <target state="translated">기능 이름</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">함수 오버로딩</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="27e4c7203c9643477f2a066182da530038d7af91" translate="yes" xml:space="preserve">
          <source>Function Return Values</source>
          <target state="translated">함수 반환 값</target>
        </trans-unit>
        <trans-unit id="564f4636a468d710ec718d52c0a86615388f886e" translate="yes" xml:space="preserve">
          <source>Function Safety</source>
          <target state="translated">기능 안전</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">함수 템플릿</target>
        </trans-unit>
        <trans-unit id="26851646d4034fb238c1b8a8d1cbdf65764b94ab" translate="yes" xml:space="preserve">
          <source>Function Templates with Auto Ref Parameters</source>
          <target state="translated">자동 기준 파라미터가있는 기능 템플릿</target>
        </trans-unit>
        <trans-unit id="2a828a2f47a94f98e25eacb43fb34ce3a0a927e6" translate="yes" xml:space="preserve">
          <source>Function argument initializes a &lt;code&gt;return&lt;/code&gt; parameter, and that parameter gets assigned to &lt;code&gt;firstArg&lt;/code&gt;. Essentially, treat as &lt;code&gt;firstArg = arg;&lt;/code&gt;</source>
          <target state="translated">함수 인수는 &lt;code&gt;return&lt;/code&gt; 매개 변수를 초기화 하고 해당 매개 변수는 &lt;code&gt;firstArg&lt;/code&gt; 에 할당됩니다 . 본질적으로 &lt;code&gt;firstArg = arg;&lt;/code&gt; 로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="87a4aa72b8e4acaa8f362e2eba871dd25b95962b" translate="yes" xml:space="preserve">
          <source>Function attributes</source>
          <target state="translated">기능 속성</target>
        </trans-unit>
        <trans-unit id="a3518d2ba96341cb705a0844010da23ec63c4f60" translate="yes" xml:space="preserve">
          <source>Function attributes are emitted in the order as listed above.</source>
          <target state="translated">함수 속성은 위에 나열된 순서대로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="090cdc3abee08672ecc88627488c127b4dd88e47" translate="yes" xml:space="preserve">
          <source>Function bodies cannot be empty:</source>
          <target state="translated">함수 본문은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">기능 바디</target>
        </trans-unit>
        <trans-unit id="daa6044eeb443eca769ad767c0b819da1d93de92" translate="yes" xml:space="preserve">
          <source>Function calls to these are generated by the compiler and inserted into the object code.</source>
          <target state="translated">이것에 대한 함수 호출은 컴파일러에 의해 생성되고 객체 코드에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd2bd5d9c9b442091f087f1d3ab7d165c7a6f01" translate="yes" xml:space="preserve">
          <source>Function contracts</source>
          <target state="translated">기능 계약</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="60f82695f39f080d8446d9390fdbf10f4625d827" translate="yes" xml:space="preserve">
          <source>Function declarations annotated with the &lt;code&gt;@live&lt;/code&gt; attribute are checked for compliance with the Ownership/Borrowing rules. The checks are run after other semantic processing is complete. The checking does not influence code generation.</source>
          <target state="translated">&lt;code&gt;@live&lt;/code&gt; 속성으로 주석이 달린 함수 선언 은 소유권 / 차입 규칙을 준수하는지 확인됩니다. 다른 시맨틱 처리가 완료된 후에 검사가 실행됩니다. 검사는 코드 생성에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd0e134160bc0255e9ac645522671a4ceac9664b" translate="yes" xml:space="preserve">
          <source>Function for starting to a stop watch time when the function is called and stopping it when its return value goes out of scope and is destroyed.</source>
          <target state="translated">함수가 호출 될 때 감시 중지 시간을 시작하고 반환 값이 범위를 벗어나 파괴 될 때 중지하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="aae2ba6220f8db51d41c8edbd64b6b01f43243fd" translate="yes" xml:space="preserve">
          <source>Function is a C-style variadic function, which uses &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</source>
          <target state="translated">함수는 C 스타일의 가변 함수이며 &lt;code&gt;core.stdc.stdarg&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="87d2f358ca186efbcb568c16e606003520afa9cd" translate="yes" xml:space="preserve">
          <source>Function is a D-style variadic function, which uses &lt;code&gt;__argptr&lt;/code&gt; and &lt;code&gt;__arguments&lt;/code&gt;.</source>
          <target state="translated">함수는 D 스타일의 가변 함수이며 &lt;code&gt;__argptr&lt;/code&gt; 및 &lt;code&gt;__arguments&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d3435b54d43e95cebfb7003ed401ba2d6c58be33" translate="yes" xml:space="preserve">
          <source>Function is a typesafe variadic function.</source>
          <target state="translated">함수는 형식이 안전한 가변 함수입니다.</target>
        </trans-unit>
        <trans-unit id="02eaa479f3aca73ffbcbe24d76bdcbcb5f2a00b8" translate="yes" xml:space="preserve">
          <source>Function is not variadic.</source>
          <target state="translated">기능은 가변적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f04ac1afcdca4559aaa061f6f7593d6d3478e357" translate="yes" xml:space="preserve">
          <source>Function parameter &lt;code&gt;par&lt;/code&gt; is being initialized to &lt;code&gt;arg&lt;/code&gt;, and &lt;code&gt;par&lt;/code&gt; may escape. Detect if scoped values can escape this way. Print error messages when these are detected.</source>
          <target state="translated">함수 매개 변수 &lt;code&gt;par&lt;/code&gt; 가 &lt;code&gt;arg&lt;/code&gt; 로 초기화되고 있으며 &lt;code&gt;par&lt;/code&gt; 이스케이프 될 수 있습니다. 범위가 지정된 값이 이런 식으로 벗어날 수 있는지 감지합니다. 오류 메시지가 감지되면 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="3029155acb4ac5fc232abd3463c11350cc2d960a" translate="yes" xml:space="preserve">
          <source>Function parameter declarations can have default values:</source>
          <target state="translated">함수 매개 변수 선언은 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6a6b4c753629a0ad23be9a19a0def5754916cb7" translate="yes" xml:space="preserve">
          <source>Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</source>
          <target state="translated">함수 매개 변수는 매개 변수 섹션에 나열하여 문서화 할 수 있습니다. 식별자로 시작하고 그 뒤에 '='가 오는 각 행은 새로운 매개 변수 설명을 시작합니다. 설명은 여러 줄에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6678c5d32e09052e0172ebd3cea351dcf7ca2766" translate="yes" xml:space="preserve">
          <source>Function parameters: Pident identifier of parameter Ptype type of argument Pelem default value for argument Psym symbol corresponding to Pident when using the parameter list as a symbol table For template-parameter-list: Pident identifier of parameter Ptype if NULL, this is a type-parameter else the type for a parameter-declaration value argument Pelem default value for value argument Pdeftype default value for type-parameter Pptpl template-parameter-list for template-template-parameter Psym default value for template-template-parameter For template-arg-list: (actual arguments) Pident NULL Ptype type-name Pelem expression (either Ptype or Pelem is NULL) Psym SCtemplate for template-template-argument</source>
          <target state="translated">함수 매개 변수 : 매개 변수의 Pident ID 매개 변수의 Ptype 유형 인수의 Plem 기본값 Psym 기호는 매개 변수 목록을 기호 테이블로 사용할 때 Pident에 해당함 template-parameter-list의 경우 : 매개 변수 Ptype의 Pident ID NULL 인 경우, 이는 매개 변수 else 매개 변수 선언 값 인수의 유형 값 인수의 Pelem 기본값 Pdeftype 유형의 매개 변수의 기본값 Pptpl template-parameter-template-template-parameter의 템플릿 -template-template-parameter의 템플릿 기본값 template-arg-의 경우 list : (실제 인수) Pident NULL Ptype type-name Pelem 식 (Ptype 또는 Pelem이 NULL 임) 템플릿-템플릿 인수에 대한 Psym SCtemplate</target>
        </trans-unit>
        <trans-unit id="4e74811387b8309f2eba7069545da73ad882b5db" translate="yes" xml:space="preserve">
          <source>Function pointers can be passed to functions taking a delegate argument by passing them through the &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt;&lt;code&gt;std.functional.toDelegate&lt;/code&gt;&lt;/a&gt; template, which converts any callable to a delegate without context.</source>
          <target state="translated">함수 포인터는 &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt; &lt;code&gt;std.functional.toDelegate&lt;/code&gt; &lt;/a&gt; 템플릿을 통해 대리자 인수를 사용하여 함수에 전달할 수 있습니다. std.functional.toDelegate 템플릿은 호출 가능한 컨텍스트를 컨텍스트없이 대리자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2f4d971f1b9568ee68d3c3afd0afa4bb0664e45b" translate="yes" xml:space="preserve">
          <source>Function results are returned from &lt;code&gt;yieldForce&lt;/code&gt;, &lt;code&gt;spinForce&lt;/code&gt; and &lt;code&gt;workForce&lt;/code&gt; by ref. If &lt;code&gt;fun&lt;/code&gt; returns by ref, the reference will point to the returned reference of &lt;code&gt;fun&lt;/code&gt;. Otherwise it will point to a field in this struct.</source>
          <target state="translated">&lt;code&gt;yieldForce&lt;/code&gt; , &lt;code&gt;spinForce&lt;/code&gt; 및 &lt;code&gt;workForce&lt;/code&gt; 로부터 함수 결과가 ref로 리턴 됩니다. 경우 &lt;code&gt;fun&lt;/code&gt; 심판에 의해 반환 기준은 반환 된 참조를 가리 킵니다 &lt;code&gt;fun&lt;/code&gt; . 그렇지 않으면이 구조체의 필드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c3097f849806cf699273164feb8e2d0ccfb12c15" translate="yes" xml:space="preserve">
          <source>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">함수 반환 값은 rvalue로 간주됩니다. 이는 다른 함수를 참조하여 전달할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7004e7f868eeb59bcb8e6e80ff83ca5a6d46adf" translate="yes" xml:space="preserve">
          <source>Function return values not marked as &lt;code&gt;ref&lt;/code&gt; are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 로 표시되지 않은 함수 반환 값 은 rvalue로 간주됩니다. 이는 다른 함수에 대한 참조로 전달할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="828053ed1d877ebcde1ff06a5dea505b651e20d3" translate="yes" xml:space="preserve">
          <source>Function template type parameters that are to be implicitly deduced may not have specializations:</source>
          <target state="translated">암시 적으로 추론되는 함수 템플릿 유형 매개 변수에는 전문화가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7d00ef56bc1d2f06bd67eb8bc21de19e80c263d" translate="yes" xml:space="preserve">
          <source>Function templates can be explicitly instantiated with a !(</source>
          <target state="translated">함수 템플릿은! (</target>
        </trans-unit>
        <trans-unit id="3b8df2ef7fc72848cf8d0bce3a9220b3a898f0b1" translate="yes" xml:space="preserve">
          <source>Function templates can have their return types deduced based on the &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function, just as with normal functions. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">함수 템플릿은 일반 함수와 마찬가지로 함수 의 &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt; 에 따라 반환 유형을 추론 할 수 있습니다 . &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;자동 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b6f95d2a2736a8bfaa71fcc12b1d0a3c85769f" translate="yes" xml:space="preserve">
          <source>Function that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 을 호출 한 함수</target>
        </trans-unit>
        <trans-unit id="8c7a2db7de16ccd53dc1b73193b31c814b7489e6" translate="yes" xml:space="preserve">
          <source>Function that does not take any parameters</source>
          <target state="translated">매개 변수를 사용하지 않는 기능</target>
        </trans-unit>
        <trans-unit id="85ff978df4b7d827c80c5b427bf2c4db1e2ed45d" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of the internal progress display function. This function should be defined as the curl_progress_callback prototype defines.</source>
          <target state="translated">내부 진행 표시 기능 대신 호출되는 기능. 이 함수는 curl_progress_callback 프로토 타입이 정의한대로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="23533f8923b79f1dc08d42a47fdcce75663a40c0" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from UTF8 (instead of using the iconv calls in libcurl) Note that this is used only for SSL certificate processing</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 UTF8에서 변환하기 위해 호출되는 함수 이는 SSL 인증서 처리에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9149aa5e3f56e9141da81bbd147711474255a324" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 네트워크 인코딩에서 변환하기 위해 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="cffc93dc9124a77261edd44618001f6b42f32854" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">libcurl에서 iconv 호출을 사용하는 대신 네트워크 인코딩으로 변환하기 위해 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="53a515cf174973bb65a87a5952e5c03252c9695d" translate="yes" xml:space="preserve">
          <source>Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.</source>
          <target state="translated">입력을 읽기 위해 호출되는 함수 (fread 대신). 매개 변수는 fread () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="babcbdb82bd11f7164bb99107054b2a484fb1682" translate="yes" xml:space="preserve">
          <source>Function that will be called to store headers (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">fwrite 대신 헤더를 저장하기 위해 호출되는 함수입니다. 매개 변수는 fwrite () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="233d456dba50e927381d10867821a9bfe1f04637" translate="yes" xml:space="preserve">
          <source>Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">fwrite 대신 출력을 저장하기 위해 호출되는 함수입니다. 매개 변수는 fwrite () 구문을 사용하므로 반드시 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="e221c711ff99df59e968c914d1979c6a0ad3ee61" translate="yes" xml:space="preserve">
          <source>Function to apply to each element of range</source>
          <target state="translated">범위의 각 요소에 적용하는 기능</target>
        </trans-unit>
        <trans-unit id="b844384b07c0f5d9caaa10fd46cb397be8c61ded" translate="yes" xml:space="preserve">
          <source>Function to be analyzed</source>
          <target state="translated">분석 할 기능</target>
        </trans-unit>
        <trans-unit id="b78a95743121775c17568fcabf9200b6a902bef0" translate="yes" xml:space="preserve">
          <source>Function to check, followed by a variadic number of function attributes as strings</source>
          <target state="translated">확인할 함수, 문자열로 다양한 함수 속성 수</target>
        </trans-unit>
        <trans-unit id="aefc954f08bca71e2e39ec093b9e23048430f8af" translate="yes" xml:space="preserve">
          <source>Function traits</source>
          <target state="translated">기능 특성</target>
        </trans-unit>
        <trans-unit id="2e40e24355bdf1170d50a1d6ead524ba20679656" translate="yes" xml:space="preserve">
          <source>Function/Delegate literal</source>
          <target state="translated">함수 / 위임 리터럴</target>
        </trans-unit>
        <trans-unit id="8ebd95c8f1ce3b6070bf21aaa16655aa94a89c6b" translate="yes" xml:space="preserve">
          <source>FunctionLiteral</source>
          <target state="translated">FunctionLiteral</target>
        </trans-unit>
        <trans-unit id="a3d450d75bfa53b89f98aa6dae8be36130018cbb" translate="yes" xml:space="preserve">
          <source>FunctionLiteralBody</source>
          <target state="translated">FunctionLiteralBody</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="a03b0f45370db4b978978138169257e95bfff4b6" translate="yes" xml:space="preserve">
          <source>Functionality for processing subsequent matches of global regexes via range interface:</source>
          <target state="translated">범위 인터페이스를 통해 전역 정규 표현식의 후속 일치를 처리하는 기능 :</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5687015bfcd81aa78a69312ebd359e3273b183cc" translate="yes" xml:space="preserve">
          <source>Functions Without Bodies</source>
          <target state="translated">시체없는 기능</target>
        </trans-unit>
        <trans-unit id="bba90169e567d9c68b308641b7cc0ffd3300695b" translate="yes" xml:space="preserve">
          <source>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer &lt;code&gt;.ptr&lt;/code&gt; is initialized to null.</source>
          <target state="translated">모듈 범위에서 선언 된 함수 및 대리자는 기본적으로 0으로 초기화됩니다. 그러나 둘 다 함수 리터럴을 포함한 모든 함수 포인터로 초기화 할 수 있습니다. 델리게이트의 경우 컨텍스트 포인터 &lt;code&gt;.ptr&lt;/code&gt; 이 널로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9443a12c52c106d6f6936a59aa4d60507110962" translate="yes" xml:space="preserve">
          <source>Functions and types that manipulate built-in arrays and associative arrays.</source>
          <target state="translated">내장 배열 및 연관 배열을 조작하는 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="1fcc64ae1b70c55efc217545c066c056d0513c2e" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interface with extern(C++) ABI.</source>
          <target state="translated">extern (C ++) ABI와의 인터페이스에 특정한 함수 및 변수.</target>
        </trans-unit>
        <trans-unit id="fd8851f8cc2c81bc5719fd2159093b00e7797298" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interfacing with extern(C) ABI.</source>
          <target state="translated">extern (C) ABI와의 인터페이스에 특정한 기능 및 변수.</target>
        </trans-unit>
        <trans-unit id="7f5a53c5e8af7e00f9774b9397648dd6e21fd328" translate="yes" xml:space="preserve">
          <source>Functions are never inlined.</source>
          <target state="translated">함수는 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4713c57b4dfbd0d2f4ef062d96b18f64a40c55bc" translate="yes" xml:space="preserve">
          <source>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the</source>
          <target state="translated">함수에 대한 인수가 매개 변수와 얼마나 잘 일치하는지에 따라 함수가 오버로드됩니다. 기능</target>
        </trans-unit>
        <trans-unit id="a7f661a74f02a377df2091c16fea97336e40806f" translate="yes" xml:space="preserve">
          <source>Functions as Array Properties</source>
          <target state="translated">배열 속성으로서의 기능</target>
        </trans-unit>
        <trans-unit id="e47c1a27abfc73a2fed656e28cc0a5aa9ab7a938" translate="yes" xml:space="preserve">
          <source>Functions can also be declared as &lt;code&gt;ref&lt;/code&gt;, meaning their return value is passed by reference:</source>
          <target state="translated">함수는 &lt;code&gt;ref&lt;/code&gt; 로 선언 될 수도 있는데 , 이는 반환 값이 참조로 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fc9e94fc77751f7a520ef1950989f7a0e1c7828b" translate="yes" xml:space="preserve">
          <source>Functions can be nested within member functions:</source>
          <target state="translated">함수는 멤버 함수 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e69a10d10797495520ab6d16edfbd50e9742682" translate="yes" xml:space="preserve">
          <source>Functions declared at the same scope overload against each other, and are called an</source>
          <target state="translated">동일한 범위에서 서로에 대해 과부하로 선언 된 함수를</target>
        </trans-unit>
        <trans-unit id="c566e2fda222bdb6e383ab5ff3c3433df764aa7f" translate="yes" xml:space="preserve">
          <source>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account.</source>
          <target state="translated">비 D 연결로 정의 된 함수는 오버로드 할 수 없습니다. 이름 변경은 매개 변수 유형을 고려하지 않을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="988f1aa7ff1ca669378942571abfebb6288e682f" translate="yes" xml:space="preserve">
          <source>Functions executed via CTFE can give different results from run time in the following scenarios:</source>
          <target state="translated">CTFE를 통해 실행 된 함수는 다음 시나리오에서 런타임과 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="419aab857f4bb8c6136ba89e91fb3714fd5cb75f" translate="yes" xml:space="preserve">
          <source>Functions for starting and interacting with other processes, and for working with the current process' execution environment.</source>
          <target state="translated">다른 프로세스를 시작하고 다른 프로세스와 상호 작용하고 현재 프로세스의 실행 환경과 작업하기위한 기능</target>
        </trans-unit>
        <trans-unit id="50b5e5b232695481bdd4d283f8038b839689e2f6" translate="yes" xml:space="preserve">
          <source>Functions marked as &lt;code&gt;final&lt;/code&gt; may not be overridden in a derived class, unless they are also &lt;code&gt;private&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 로 표시된 함수 는 &lt;code&gt;private&lt;/code&gt; 이 아닌 한 파생 클래스에서 재정의 될 수 없습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c40c48a24043c849a46e19c95c7d6f6bb43d3af4" translate="yes" xml:space="preserve">
          <source>Functions may be nested within other functions:</source>
          <target state="translated">함수는 다른 함수 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab842017af8570439bf6ba4b27c54b5312a024b2" translate="yes" xml:space="preserve">
          <source>Functions nested inside safe functions default to being safe functions.</source>
          <target state="translated">안전 기능 안에 중첩 된 기능은 기본적으로 안전 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e7c3eeba379274331a0b9c881db32559bea140a9" translate="yes" xml:space="preserve">
          <source>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</source>
          <target state="translated">가변 개수의 인수를 취하는 함수를 가변 함수라고합니다. variadic 함수는 다음 세 가지 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8dcbed7cf260c12b9f8f40b2d592ffce349a24" translate="yes" xml:space="preserve">
          <source>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</source>
          <target state="translated">동일성을 갖는 변경 가능, const 또는 불변 유형을 처리하는 함수는 종종 유형을 리턴 값으로 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cc0d5a6974c142e0e42bd69101ee5cdc41acf88" translate="yes" xml:space="preserve">
          <source>Functions that manipulate other functions.</source>
          <target state="translated">다른 기능을 조작하는 기능.</target>
        </trans-unit>
        <trans-unit id="d4e8675aa25a2bddb84bf8fd8b778e29fe3cf68c" translate="yes" xml:space="preserve">
          <source>Functions that meet these requirements may be &lt;a href=&quot;#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trusted-functions&quot;&gt;&lt;code&gt;@trusted&lt;/code&gt;&lt;/a&gt;. Function that do not meet these requirements can only be &lt;a href=&quot;#system-functions&quot;&gt;&lt;code&gt;@system&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 요구 사항을 충족하는 함수는 &lt;a href=&quot;#safe-functions&quot;&gt; &lt;code&gt;@safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trusted-functions&quot;&gt; &lt;code&gt;@trusted&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . 이러한 요구 사항을 충족하지 않는 함수는 &lt;a href=&quot;#system-functions&quot;&gt; &lt;code&gt;@system&lt;/code&gt; &lt;/a&gt; 만 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="9283433eaa6818c4d57146ef0bb556e3d0ffc12f" translate="yes" xml:space="preserve">
          <source>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</source>
          <target state="translated">이식 가능하고 전역 부작용이없는 기능은 컴파일 타임에 실행될 수 있습니다. 특정 상황에서 이러한 컴파일 시간 실행이 보장됩니다. 그런 다음 CTFE (Compile Time Function Execution)라고합니다. CTFE를 트리거하는 컨텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="670fb705837790471a38cafc20ec80fbf30c8bf6" translate="yes" xml:space="preserve">
          <source>Functions which operate on ASCII characters.</source>
          <target state="translated">ASCII 문자에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="7c0d365cb94dab42778d857cad063abfc3d8f3b6" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage has an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">&lt;code&gt;Objective-C&lt;/code&gt; 연계가있는 함수에는 이름이 지정되지 않은 추가 숨겨진 매개 변수가 있으며이 매개 변수는 호출 된 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="2f12c7ced7f8f22b29fa0338695211d8c0538660" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage have an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">&lt;code&gt;Objective-C&lt;/code&gt; 연결을 사용하는 함수에는 호출 된 선택자인 이름이 지정되지 않은 숨겨진 추가 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbb7352ab0b0a6abe4eb4d50fb47e8061479506" translate="yes" xml:space="preserve">
          <source>Functions with non-D linkage cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">D 연결이 아닌 함수는 가상이 될 수 없으므로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaad94952abd8178c9c878e428d9910f2e427164" translate="yes" xml:space="preserve">
          <source>Functions with the &lt;code&gt;@live&lt;/code&gt; attribute enable diagnosing these sorts of errors by tracking the status of owner pointers.</source>
          <target state="translated">&lt;code&gt;@live&lt;/code&gt; 속성 이있는 함수를 사용하면 소유자 포인터의 상태를 추적하여 이러한 종류의 오류를 진단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2adb6747d6f26e87d983ed577d7da81919733d7b" translate="yes" xml:space="preserve">
          <source>Functions without bodies:</source>
          <target state="translated">신체가없는 기능 :</target>
        </trans-unit>
        <trans-unit id="d783b16a7b27b910940b783d5fcc870c6c683d47" translate="yes" xml:space="preserve">
          <source>Fundamental Unicode algorithms and data structures.</source>
          <target state="translated">기본 유니 코드 알고리즘 및 데이터 구조</target>
        </trans-unit>
        <trans-unit id="ba469f1bc17cb15fca5f5581188a0b34ac4471eb" translate="yes" xml:space="preserve">
          <source>Furthermore, even with orderable types, the order relation may not be linear. For example, one may define an ordering on sets via the subset relation, such that &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true if &lt;code&gt;x&lt;/code&gt; is a (strict) subset of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are disjoint sets, then neither &lt;code&gt;x &amp;lt; y&lt;/code&gt; nor &lt;code&gt;y &amp;lt; x&lt;/code&gt; holds, but that does not imply that &lt;code&gt;x == y&lt;/code&gt;. Thus, it is insufficient to determine equality purely based on &lt;code&gt;opCmp&lt;/code&gt; alone. For this reason, &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt;. The equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; always employ &lt;code&gt;opEquals&lt;/code&gt; instead.</source>
          <target state="translated">또한 주문 가능한 유형의 경우에도 주문 관계는 선형이 아닐 수 있습니다. 예를 들어, 하나가되도록, 상기 서브 세트 관계를 통해 세트에 순서를 정의 할 수있다 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 있는 경우 true &lt;code&gt;x&lt;/code&gt; 의 (엄격한) 부분이고 &lt;code&gt;y&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 개별 세트이다 후도 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 나 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 보유하고 있지만, 그 것을 의미하지는 않으며 &lt;code&gt;x == y&lt;/code&gt; . 따라서 &lt;code&gt;opCmp&lt;/code&gt; 만으로 만 순등 을 결정하는 것만으로는 충분하지 않습니다 . 이러한 이유로 &lt;code&gt;opCmp&lt;/code&gt; 는 부등호 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; . 동등 연산자 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 항상 대신 &lt;code&gt;opEquals&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="869bc7df187eb57c1861571c27bf80367e22db67" translate="yes" xml:space="preserve">
          <source>Furthermore, predefined version identifiers from this list cannot be set from the command line or from version statements. (This prevents things like both &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;linux&lt;/code&gt; being simultaneously set.)</source>
          <target state="translated">또한이 목록의 사전 정의 된 버전 ID는 명령 행 또는 버전 명령문에서 설정할 수 없습니다. (이것은 &lt;code&gt;Windows&lt;/code&gt; 와 &lt;code&gt;linux&lt;/code&gt; 모두 가 동시에 설정되는 것을 방지 합니다.)</target>
        </trans-unit>
        <trans-unit id="2b04009b8ca8039e0507f25a9f0361986b70a3e6" translate="yes" xml:space="preserve">
          <source>Future policies may offer a more even balance between reader and writer precedence.</source>
          <target state="translated">미래의 정책은 독자와 작가 우선 순위 사이의 균형을보다 균등하게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d254d35351117c9cff18872b82ba6d91c00e60" translate="yes" xml:space="preserve">
          <source>G &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">G의 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="227e2edf0447cd04a773c3b823f1c89795158178" translate="yes" xml:space="preserve">
          <source>GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;(string name);</source>
          <target state="translated">GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt; (문자열 이름);</target>
        </trans-unit>
        <trans-unit id="17686e6502ad0f3cdaf4206e0191cbc522cc8283" translate="yes" xml:space="preserve">
          <source>GC FAQ</source>
          <target state="translated">GC FAQ</target>
        </trans-unit>
        <trans-unit id="2715953d0812423734ebffeea6a105ce46d2c5b2" translate="yes" xml:space="preserve">
          <source>GC allocated string</source>
          <target state="translated">GC 할당 문자열</target>
        </trans-unit>
        <trans-unit id="8b2c6daf9a150d506a85e85cb9bcb053667888f2" translate="yes" xml:space="preserve">
          <source>GC allocated string with spaces replaced with tabs; use &lt;a href=&quot;#entabber&quot;&gt;&lt;code&gt;entabber&lt;/code&gt;&lt;/a&gt; to not allocate.</source>
          <target state="translated">공백이있는 GC 할당 문자열이 탭으로 대체되었습니다. 할당하지 않으 려면 &lt;a href=&quot;#entabber&quot;&gt; &lt;code&gt;entabber&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="86e1b687d8486a9dcb7b4165bc8e5226d854f2c7" translate="yes" xml:space="preserve">
          <source>GC allocated string with tabs replaced with spaces</source>
          <target state="translated">공백이있는 탭이있는 GC 할당 문자열</target>
        </trans-unit>
        <trans-unit id="6b9746104b4c3bc7be22e5b6d74741bddee5a6bf" translate="yes" xml:space="preserve">
          <source>GC implementations are added to a registry that allows to supply more implementations by just linking them into the binary. To do so add a function that is executed before the D runtime initialization using &lt;code&gt;pragma(crt_constructor)&lt;/code&gt;:</source>
          <target state="translated">GC 구현은 레지스트리에 추가되어 더 많은 구현을 바이너리에 연결함으로써 더 많은 구현을 제공 할 수 있습니다. &lt;code&gt;pragma(crt_constructor)&lt;/code&gt; 사용하여 D 런타임 초기화 전에 실행되는 함수를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5951ff6858fe229e78c3aef61db342f3d5f757a1" translate="yes" xml:space="preserve">
          <source>GC scan hook, called FOR each thread. Can be used to scan additional thread local memory.</source>
          <target state="translated">각 스레드에 대해 호출되는 GC 스캔 후크. 추가 스레드 로컬 메모리를 스캔하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44da27f9ddec555cbd5fcd60022e2b6c8808bbdc" translate="yes" xml:space="preserve">
          <source>GC sweep hook, called FOR each thread. Can be used to free additional thread local memory or associated data structures. Note that only memory allocated from the GC can have marks.</source>
          <target state="translated">각 스레드마다 호출되는 GC 스윕 후크. 추가 스레드 로컬 메모리 또는 관련 데이터 구조를 해제하는 데 사용할 수 있습니다. GC에서 할당 된 메모리에만 마크가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="152e90dd32518be928b899f58b1e3835f65ca8cc" translate="yes" xml:space="preserve">
          <source>GCFactory &lt;code&gt;factory&lt;/code&gt;</source>
          <target state="translated">GC &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a69c000934b632336629d0d827590961013d5f" translate="yes" xml:space="preserve">
          <source>GDC (GNU D Compiler) is the compiler</source>
          <target state="translated">GDC (GNU D Compiler)는 컴파일러입니다</target>
        </trans-unit>
        <trans-unit id="c6b9fdbe9b835ce607d5f9465603dc2e9dd09b8c" translate="yes" xml:space="preserve">
          <source>GNU D Compiler (GDC)</source>
          <target state="translated">GNU D 컴파일러 (GDC)</target>
        </trans-unit>
        <trans-unit id="1ced0cf23647bda25b46395cd7423d5899e8cec5" translate="yes" xml:space="preserve">
          <source>GNU Hurd</source>
          <target state="translated">GNU 허드</target>
        </trans-unit>
        <trans-unit id="c9744a883d88a359c771c7c407727c811697e7d9" translate="yes" xml:space="preserve">
          <source>GSS-Negotiate</source>
          <target state="translated">GSS-Negotiate</target>
        </trans-unit>
        <trans-unit id="649101d4277d8226d1453ed4ac0ae23fef3f6651" translate="yes" xml:space="preserve">
          <source>GapWeightedSimilarityIncremental!(R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;(R, F)(R r1, R r2, F penalty);</source>
          <target state="translated">GapWeightedSimilarityIncremental! (R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;간격 WeightedSimilarityIncremental&lt;/strong&gt; (R, F) (R r1, R r2, F 페널티);</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="b68927a1fc8d1a3e9f2d3afdf28381f11e58bc69" translate="yes" xml:space="preserve">
          <source>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</source>
          <target state="translated">가비지 콜렉션 : 자동 동적 메모리 관리를위한 알고리즘</target>
        </trans-unit>
        <trans-unit id="26ed33deae58e27843afa7f067144cf4cc6aa56f" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are faster to develop and debug, because there's no need for developing, debugging, testing, or maintaining the explicit deallocation code.</source>
          <target state="translated">가비지 수집 프로그램은 명시 적 할당 해제 코드를 개발, 디버깅, 테스트 또는 유지 관리 할 필요가 없기 때문에 개발 및 디버깅 속도가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b5b34cabae6ba38a27f9919e85bfc06a08059602" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are often faster. This is counterintuitive, but the reasons are:</source>
          <target state="translated">가비지 수집 프로그램은 종종 더 빠릅니다. 이것은 직관적이지 않지만 그 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8b92a6daa02321044a81fa8b11e153716774a33" translate="yes" xml:space="preserve">
          <source>Garbage collected programs do not suffer from gradual deterioration due to an accumulation of memory leaks.</source>
          <target state="translated">가비지 수집 프로그램은 메모리 누수가 누적되어 점진적으로 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b3b619bb8bd26c9ff456e8cbc3e5bc6b3b1d018" translate="yes" xml:space="preserve">
          <source>Garbage collected programs have fewer hard-to-find pointer bugs. This is because there are no dangling references to freed memory. There is no code to explicitly manage memory, hence no bugs in such code.</source>
          <target state="translated">가비지 수집 프로그램은 찾기 어려운 포인터 버그가 적습니다. 해제 된 메모리에 매달려있는 참조가 없기 때문입니다. 메모리를 명시 적으로 관리하는 코드가 없으므로 그러한 코드에는 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6274199ad9ef2c79ed1df932fffcb7da577e7439" translate="yes" xml:space="preserve">
          <source>Garbage collection doesn't solve every memory deallocation problem. For example, if a pointer to a large data structure is kept, the garbage collector cannot reclaim it, even if it is never referred to again. To eliminate this problem, it is good practice to set a reference or pointer to an object to null when no longer needed.</source>
          <target state="translated">가비지 콜렉션이 모든 메모리 할당 해제 문제점을 해결하지는 않습니다. 예를 들어, 큰 데이터 구조에 대한 포인터가 유지되면 다시 참조되지 않더라도 가비지 수집기가이를 회수 할 수 없습니다. 이 문제를 해결하려면 더 이상 필요하지 않은 객체에 대한 참조 또는 포인터를 null로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a483157166b15cc6add50950e71104545209b12" translate="yes" xml:space="preserve">
          <source>Garbage collection is not a panacea. There are some downsides:</source>
          <target state="translated">가비지 콜렉션은 만병 통치약이 아닙니다. 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc8494b0a1f3be26c109010c1300b5540a63f86" translate="yes" xml:space="preserve">
          <source>Garbage collection kicks in only when memory gets tight. When memory is not tight, the program runs at full speed and does not spend any time tracing and freeing memory.</source>
          <target state="translated">가비지 콜렉션은 메모리가 부족할 때만 시작됩니다. 메모리가 부족하지 않은 경우 프로그램은 최고 속도로 실행되며 메모리를 추적하고 해제하는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43e630068e8d3af90d5baf5c490d09a820b5fe43" translate="yes" xml:space="preserve">
          <source>Garbage collection should be implemented as a basic operating system kernel service. But since it is not, garbage collecting programs must carry around with them the garbage collection implementation. While this can be a shared library, it is still there.</source>
          <target state="translated">가비지 콜렉션은 기본 운영 체제 커널 서비스로 구현되어야합니다. 그러나 가비지 수집 프로그램은 그렇지 않으므로 가비지 수집 구현을 수행해야합니다. 이 라이브러리는 공유 라이브러리 일 수 있지만 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de09af360c7bfc02cd9b07759c0be1a92997bf1" translate="yes" xml:space="preserve">
          <source>Garbage collectors can keep around some memory that an explicit deallocator would not.</source>
          <target state="translated">가비지 콜렉터는 명시 적 할당 취소 기가 원하지 않는 일부 메모리를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f128a6c5d8578ad64f58e212419d6613dc978b" translate="yes" xml:space="preserve">
          <source>Garbage collectors reclaim unused memory, therefore they do not suffer from &quot;memory leaks&quot; which can cause long running applications to gradually consume more and more memory until they bring down the system. GC programs have longer term stability.</source>
          <target state="translated">가비지 콜렉터는 사용되지 않은 메모리를 회수하므로 &quot;메모리 누수&quot;로 인한 영향을받지 않아 장기 실행 애플리케이션이 시스템을 중단 할 때까지 점점 더 많은 메모리를 점진적으로 소비 할 수 있습니다. GC 프로그램은 장기적인 안정성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5929f6c7d4d9ef8bac1c480f80dfd125a208b5f6" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol</source>
          <target state="translated">게이트웨이 대 게이트웨이 프로토콜</target>
        </trans-unit>
        <trans-unit id="6b850d9a8cc2ef5b85b6581a88258447107ac8f9" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol level</source>
          <target state="translated">게이트웨이 대 게이트웨이 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="8e56a55c1f12981e7b0c87a44da833cae0277f14" translate="yes" xml:space="preserve">
          <source>Gcc Cpp runtime</source>
          <target state="translated">Gcc Cpp 런타임</target>
        </trans-unit>
        <trans-unit id="f0db25c1007f1ac431f102d1b6f3db7e823e1c1d" translate="yes" xml:space="preserve">
          <source>GccAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">GccAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="cc2b80e244c5b3f85b819f8e001f39a8b1778b1c" translate="yes" xml:space="preserve">
          <source>General Punctuation</source>
          <target state="translated">문장 부호</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="fd7aec0ee16d41be57526539a4c6ef8ef63c34e9" translate="yes" xml:space="preserve">
          <source>General case =&amp;gt; symmetric calls to method opEquals</source>
          <target state="translated">일반적인 경우 =&amp;gt; opEquals 메소드에 대한 대칭 호출</target>
        </trans-unit>
        <trans-unit id="2def4e3aff28a0804ab7417604344f41584fcca9" translate="yes" xml:space="preserve">
          <source>General category sets listed below are only accessible with the &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; shorthand accessor.</source>
          <target state="translated">아래에 나열된 일반 범주 세트는 &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; 속기 접근 자를 통해서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2083d118900999f8d32dc5f2e8254d3f52ea6bf1" translate="yes" xml:space="preserve">
          <source>General use synchronization semaphore.</source>
          <target state="translated">일반적인 사용 동기화 세마포어.</target>
        </trans-unit>
        <trans-unit id="15c16d502337718b40d0beb9afa9790ccdf94859" translate="yes" xml:space="preserve">
          <source>Generally useful building blocks for customized normalization: &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt; for querying combining class and &lt;a href=&quot;#allowedIn&quot;&gt;&lt;code&gt;allowedIn&lt;/code&gt;&lt;/a&gt; for testing the Quick_Check property of a given normalization form.</source>
          <target state="translated">사용자 정의 정규화에 일반적으로 유용한 구성 요소 : &lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt; 클래스를 쿼리 하기위한 &lt;a href=&quot;#allowedIn&quot;&gt; &lt;code&gt;allowedIn&lt;/code&gt; &lt;/a&gt; 및 주어진 정규화 양식의 Quick_Check 속성을 테스트하기 위해 allowedIn.</target>
        </trans-unit>
        <trans-unit id="9641d9bcb23b576cc813cade93d2589aaa993fe5" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;stable&lt;/code&gt; ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, &lt;code&gt;semistable&lt;/code&gt; may be costlier than &lt;code&gt;unstable&lt;/code&gt;. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by &lt;code&gt;SwapStrategy&lt;/code&gt; all choose &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; as the default.</source>
          <target state="translated">일반적으로, &lt;code&gt;stable&lt;/code&gt; 순서 전략은 추가적인 제약을 부과하기 때문에 다른 것보다 시간 및 / 또는 공간이 더 비쌀 수있다. 마찬가지로 &lt;code&gt;semistable&lt;/code&gt; 은 &lt;code&gt;unstable&lt;/code&gt; 보다 비용이 많이 듭니다 . (반) 안정성이 자주 필요하지 않기 때문에, &lt;code&gt;SwapStrategy&lt;/code&gt; 에 의해 매개 변수화 된이 모듈의 순서 알고리즘은 모두 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 을 기본값으로 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="05d74eaaa124507aed1ad66047271caa648813e4" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;std&lt;/code&gt; namespace is used for the main modules in the Phobos standard library. The &lt;code&gt;etc&lt;/code&gt; namespace is used for external C/C++ library bindings. The &lt;code&gt;core&lt;/code&gt; namespace is used for low-level D runtime functions.</source>
          <target state="translated">일반적으로 &lt;code&gt;std&lt;/code&gt; 네임 스페이스는 Phobos 표준 라이브러리의 기본 모듈에 사용됩니다. &lt;code&gt;etc&lt;/code&gt; 네임 스페이스는 외부 C / C ++ 라이브러리 바인딩에 사용됩니다. &lt;code&gt;core&lt;/code&gt; 네임 스페이스는 낮은 수준의 D 런타임 기능을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="270a807f0de4d20f0d7b86a3f7b8a65802e708dd" translate="yes" xml:space="preserve">
          <source>Generally, this function checks that &lt;code&gt;path&lt;/code&gt; is not empty, and that each component of the path either satisfies &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; or is equal to &lt;code&gt;&quot;.&quot;&lt;/code&gt; or &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">일반적으로이 함수는 &lt;code&gt;path&lt;/code&gt; 가 비어 있지 않고 경로의 각 구성 요소가 &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; 을&lt;/a&gt; 만족 하는지 또는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 같은지 확인합니다 . 또는 &lt;code&gt;&quot;..&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3d74ace2e58f845d2e516e7b9c956be3febfc4" translate="yes" xml:space="preserve">
          <source>Generate .obj file for Module.</source>
          <target state="translated">모듈에 대한 .obj 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f9dad7b8a1ce93a4eb80b95d85ef1cf88d8f4597" translate="yes" xml:space="preserve">
          <source>Generate C main() in response to seeing D main().</source>
          <target state="translated">D main ()을보고 C main ()을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="345123c70e49b34125173495f611953054f48574" translate="yes" xml:space="preserve">
          <source>Generate Expression to call the invariant.</source>
          <target state="translated">불변을 호출하는 식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d90320355fd64aadd68db9a959d0db877a879578" translate="yes" xml:space="preserve">
          <source>Generate HALT instruction.</source>
          <target state="translated">HALT 명령을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f40cd732815b9b227c307d8a881eabcde883c532" translate="yes" xml:space="preserve">
          <source>Generate Symbol of C++ type info for C++ class cd.</source>
          <target state="translated">C ++ 클래스 cd에 대한 C ++ 유형 정보의 기호를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="71428fcf71b36719232a357b20981c579d5f795c" translate="yes" xml:space="preserve">
          <source>Generate a FuncDeclaration for a runtime library function.</source>
          <target state="translated">런타임 라이브러리 함수에 대한 FuncDeclaration을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c1f38d03f2f34b3b4a976dcf593b7574be546eff" translate="yes" xml:space="preserve">
          <source>Generate a convenient string for identifying this Tid. This is only useful to see if Tid's that are currently executing are the same or different, e.g. for logging and debugging. It is potentially possible that a Tid executed in the future will have the same toString() output as another Tid that has already terminated.</source>
          <target state="translated">이 Tid를 식별하기위한 편리한 문자열을 생성하십시오. 이것은 현재 실행중인 Tid가 동일하거나 다른지 (예 : 로깅 및 디버깅) 경우에만 유용합니다. 나중에 실행되는 Tid는 이미 종료 된 다른 Tid와 동일한 toString () 출력을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a4983512e25bdf4577cfbc7ade2d3d9ef11551" translate="yes" xml:space="preserve">
          <source>Generate a copy from e2 to e1.</source>
          <target state="translated">e2에서 e1로 사본을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e990bafe6b9623ad15b6163c4381e1e24f60827" translate="yes" xml:space="preserve">
          <source>Generate and output scope table.</source>
          <target state="translated">범위 테이블 생성 및 출력</target>
        </trans-unit>
        <trans-unit id="d887428fee6838e30b863f3266f3121541d951d0" translate="yes" xml:space="preserve">
          <source>Generate call to C's assert failure function. One of exp, emsg, or str must not be null.</source>
          <target state="translated">C의 주장 실패 함수에 대한 호출을 생성하십시오. exp, emsg 또는 str 중 하나가 널이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0e2deeef3299cd274df6c669c731ce070bbe521" translate="yes" xml:space="preserve">
          <source>Generate data for instance of _cpp_type_info_ptr that refers to the C++ RTTI symbol for cd.</source>
          <target state="translated">cd의 C ++ RTTI 기호를 참조하는 _cpp_type_info_ptr의 예를 들어 데이터를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="92ed283aad401b73892410374fb18c0200210984" translate="yes" xml:space="preserve">
          <source>Generate deterministic named identifier based on a source location, such that the name is consistent across multiple compilations. A new unique name is generated. If the prefix+location is already in the stringtable, an extra suffix is added (starting the count at &quot;1&quot;).</source>
          <target state="translated">소스 위치를 기반으로 결정적 명명 된 식별자를 생성하여 이름이 여러 컴파일에서 일관되게합니다. 새로운 고유 이름이 생성됩니다. 접두사 + 위치가 이미 문자열 테이블에 있으면 추가 접미사가 추가됩니다 ( &quot;1&quot;에서 카운트 시작).</target>
        </trans-unit>
        <trans-unit id="e688f516a8d461fb5372c55840691f744fd51391" translate="yes" xml:space="preserve">
          <source>Generate import symbol from symbol.</source>
          <target state="translated">심볼에서 가져 오기 심볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9978fdec524f341bfac18807618c73a3b51b46c1" translate="yes" xml:space="preserve">
          <source>Generate symbol of type ty at DATA:offset</source>
          <target state="translated">DATA : offset에서 ty 유형의 심볼 생성</target>
        </trans-unit>
        <trans-unit id="821fb78c5c9319cc69fa8057c9c2cd2d48fedaf8" translate="yes" xml:space="preserve">
          <source>Generate two operand instruction with XMM 128 bit operands.</source>
          <target state="translated">XMM 128 비트 피연산자로 두 개의 피연산자 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5c437f1471923979723873169275d327e196c1fa" translate="yes" xml:space="preserve">
          <source>Generated Macro Definitions</source>
          <target state="translated">생성 된 매크로 정의</target>
        </trans-unit>
        <trans-unit id="b53fd19a2486af4f399d146936aa03eb7d82a727" translate="yes" xml:space="preserve">
          <source>Generated code is inserted in the scope of &lt;code&gt;std.typecons&lt;/code&gt; module. Thus, any useful functions outside &lt;code&gt;std.typecons&lt;/code&gt; cannot be used in the generated code. To workaround this problem, you may &lt;code&gt;import&lt;/code&gt; necessary things in a local struct, as done in the &lt;code&gt;generateLogger()&lt;/code&gt; template in the above example.</source>
          <target state="translated">생성 된 코드는 &lt;code&gt;std.typecons&lt;/code&gt; 모듈 의 범위에 삽입됩니다 . 따라서 &lt;code&gt;std.typecons&lt;/code&gt; 외부의 유용한 함수 는 생성 된 코드에서 사용할 수 없습니다. 이 문제를 해결하려면 위 예제 의 &lt;code&gt;generateLogger()&lt;/code&gt; 템플릿에서와 같이 로컬 구조체에서 필요한 것을 &lt;code&gt;import&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6857b9e8cb1c55a9a2f9226a5b4dc0cf595f501" translate="yes" xml:space="preserve">
          <source>Generates a hash for &lt;code&gt;this&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookToHash&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; does not implement &lt;code&gt;hookToHash&lt;/code&gt;, but it has state, a hash will be generated for the &lt;code&gt;Hook&lt;/code&gt; using the built-in function and it will be xored with the hash of the &lt;code&gt;payload&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 대한 해시를 생성합니다 . 경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookToHash&lt;/code&gt; 를 호출은 즉시 반환 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; . 경우 &lt;code&gt;Hook&lt;/code&gt; 구현하지 않는 &lt;code&gt;hookToHash&lt;/code&gt; 을 하지만 상태가, 해시가 생성됩니다 &lt;code&gt;Hook&lt;/code&gt; 내장 기능을 사용하고 그것은의 해시 약하게 될 것이다 &lt;code&gt;payload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feba4b72ab473cbf0cd5ea105195b64ec1ac1f2d" translate="yes" xml:space="preserve">
          <source>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</source>
          <target state="translated">트리의 해시를 생성합니다. 사용자 정의 비교 함수를 사용하면 두 개의 rbtree가 동일하면 트리의 해시가 동일하다는 것을 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57845456ec25b869fe6d9c20ab2d9cba380674de" translate="yes" xml:space="preserve">
          <source>Generates a human-readable stack-trace on POSIX targets using DWARF</source>
          <target state="translated">DWARF를 사용하여 POSIX 대상에서 사람이 읽을 수있는 스택 추적을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="398b1403000b9404acc8a7edce2480693602dfc5" translate="yes" xml:space="preserve">
          <source>Generates a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;boundaries&lt;/code&gt; parameter controls the shape of the interval (open vs. closed on either side). Valid values for &lt;code&gt;boundaries&lt;/code&gt; are &lt;code&gt;&quot;[]&quot;&lt;/code&gt;, &lt;code&gt;&quot;(]&quot;&lt;/code&gt;, &lt;code&gt;&quot;[)&quot;&lt;/code&gt;, and &lt;code&gt;&quot;()&quot;&lt;/code&gt;. The default interval is closed to the left and open to the right. The version that does not take &lt;code&gt;urng&lt;/code&gt; uses the default generator &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 숫자를 생성합니다 . &lt;code&gt;boundaries&lt;/code&gt; 제어 파라미터 간격의 형태 (개방 대 양쪽에 폐쇄). &lt;code&gt;boundaries&lt;/code&gt; 유효한 값 은 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; , &lt;code&gt;&quot;(]&quot;&lt;/code&gt; , &lt;code&gt;&quot;[)&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 입니다. 기본 간격은 왼쪽에서 닫히고 오른쪽에서 열립니다. &lt;code&gt;urng&lt;/code&gt; 을 사용 하지 않는 버전 은 기본 생성기 &lt;code&gt;rndGen&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="31d5a7a72aa7d6403397ac8f8b98d7136fb359b8" translate="yes" xml:space="preserve">
          <source>Generates a uniform probability distribution of size &lt;code&gt;n&lt;/code&gt;, i.e., an array of size &lt;code&gt;n&lt;/code&gt; of positive numbers of type &lt;code&gt;F&lt;/code&gt; that sum to &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;useThis&lt;/code&gt; is provided, it is used as storage.</source>
          <target state="translated">크기 &lt;code&gt;n&lt;/code&gt; 의 균일 한 확률 분포 , 즉 &lt;code&gt;1&lt;/code&gt; 에 합산 된 &lt;code&gt;F&lt;/code&gt; 유형의 양수 의 크기 &lt;code&gt;n&lt;/code&gt; 의 배열을 생성합니다 . 경우 &lt;code&gt;useThis&lt;/code&gt; 가 제공되는데, 이는 저장 장치로 사용된다.</target>
        </trans-unit>
        <trans-unit id="e2682a8625295cc7a75ade62ec910662e42eb1ad" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed floating point number of type &lt;code&gt;T&lt;/code&gt; in the range [0, 1). If no random number generator is specified, the default RNG &lt;code&gt;rndGen&lt;/code&gt; will be used as the source of randomness.</source>
          <target state="translated">[0, 1) 범위에서 유형 &lt;code&gt;T&lt;/code&gt; 의 균일하게 분포 된 부동 소수점 수를 생성합니다 . 난수 생성기가 지정되지 않은 경우 기본 RNG &lt;code&gt;rndGen&lt;/code&gt; 이 난수의 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="590a92dca2ec49812f71151418c5576ff9ad8ac5" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed number in the range &lt;code&gt;[T.min, T.max]&lt;/code&gt; for any integral or character type &lt;code&gt;T&lt;/code&gt;. If no random number generator is passed, uses the default &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">정수 또는 문자 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 &lt;code&gt;[T.min, T.max]&lt;/code&gt; 범위에서 균일하게 분포 된 숫자를 생성합니다 . 난수 생성기가 전달되지 않으면 기본 &lt;code&gt;rndGen&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a3dd4ef1d89d221f34cd8efe42c23a94aa835c2" translate="yes" xml:space="preserve">
          <source>Generates string with D source code of unary function with name of &lt;code&gt;funcName&lt;/code&gt; taking a single &lt;code&gt;dchar&lt;/code&gt; argument. If &lt;code&gt;funcName&lt;/code&gt; is empty the code is adjusted to be a lambda function.</source>
          <target state="translated">단일 &lt;code&gt;dchar&lt;/code&gt; 인수 를 사용하여 &lt;code&gt;funcName&lt;/code&gt; 이라는 이름으로 단항 함수의 D 소스 코드로 문자열을 생성합니다 . 경우 &lt;code&gt;funcName&lt;/code&gt; 비어 코드는 람다 함수로 조정된다.</target>
        </trans-unit>
        <trans-unit id="4b3935a65e18852e853df767745851e9e88c4154" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;torig&lt;/code&gt; if it hasn't already been generated</source>
          <target state="translated">생성 &lt;code&gt;TypeInfo&lt;/code&gt; 와 관련된 객체 &lt;code&gt;torig&lt;/code&gt; 를 이미 생성되어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="c898dd30458bc82445a94b03bf4338f7812ed73c" translate="yes" xml:space="preserve">
          <source>Generates the following:</source>
          <target state="translated">다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ef2e0bcfe378859fb93a76e38ab31870b5aaab4c" translate="yes" xml:space="preserve">
          <source>Generating UUIDs</source>
          <target state="translated">UUID 생성</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="7282cafe7ab4dcfbd06151ce87eab6a8cb7b662e" translate="yes" xml:space="preserve">
          <source>Generic Template API used for CRC32 and CRC64 implementations.</source>
          <target state="translated">CRC32 및 CRC64 구현에 사용되는 일반 템플릿 API.</target>
        </trans-unit>
        <trans-unit id="48d04e2739718c3b5809e3d93e9ab17e0175ee79" translate="yes" xml:space="preserve">
          <source>Generic algorithms for processing sequences.</source>
          <target state="translated">시퀀스 처리를위한 일반 알고리즘.</target>
        </trans-unit>
        <trans-unit id="7bca8ef182b8f3deaa44e5a838347a3d8559084e" translate="yes" xml:space="preserve">
          <source>Generic algorithms that work with &lt;a href=&quot;std_range&quot;&gt;ranges&lt;/a&gt; of any type, including strings, arrays, and other kinds of sequentially-accessed data. Algorithms include searching, comparison, iteration, sorting, set operations, and mutation.</source>
          <target state="translated">문자열, 배열 및 순차적으로 액세스되는 다른 종류의 데이터를 포함하여 모든 유형의 &lt;a href=&quot;std_range&quot;&gt;범위&lt;/a&gt; 에서 작동하는 일반 알고리즘 . 알고리즘에는 검색, 비교, 반복, 정렬, 설정 작업 및 돌연변이가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e37a68ed0e7f2e44e67335effd984a4809f41f52" translate="yes" xml:space="preserve">
          <source>Generic code which deals with different Digest types should always call start though.</source>
          <target state="translated">다른 다이제스트 유형을 처리하는 일반 코드는 항상 start를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4fe6a7b8d8e501df226058c573d01d9418d71dd" translate="yes" xml:space="preserve">
          <source>Generic error</source>
          <target state="translated">일반적인 오류</target>
        </trans-unit>
        <trans-unit id="070a5062376a825143c54fc921ea5b5a3350219e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt;&lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt; &lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5f39e04859e495f02a94a4f09ad4d9de0e5160e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14b5394baf94216f2e7707c45724f2e122958d4a" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">범위의 일반 스트리핑 : &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9464f7b462f8074504ba78be947c4f876e0fc5c" translate="yes" xml:space="preserve">
          <source>Generic type value getter A convenience getter that returns this &lt;code&gt;JSONValue&lt;/code&gt; as the specified D type.</source>
          <target state="translated">일반 유형 값 getter이 &lt;code&gt;JSONValue&lt;/code&gt; 를 지정된 D 유형으로 리턴하는 편리한 getter입니다 .</target>
        </trans-unit>
        <trans-unit id="9d110955c054077a9782bc3e9dc049c8ed9e192f" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units.</source>
          <target state="translated">두 시간 단위 사이의 일반적인 변환 방법.</target>
        </trans-unit>
        <trans-unit id="fdfe3a8efedde26bb169021d4c0add270ebc9913" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year).</source>
          <target state="translated">두 시간 단위 사이의 일반적인 변환 방법. 더 작은 단위로 변환하면 잘림 나누기가 사용됩니다. 연도와 월은 서로 변환 될 수 있고, 작은 단위는 서로 변환 될 수 있지만, 연도와 월은 작은 단위로 변환하거나 작은 단위로 변환 할 수 없습니다 (달 또는 연도의 다양한 일 수로 인해).</target>
        </trans-unit>
        <trans-unit id="8351f1bd421bb3c2f34de06d3708adb7a974a3d4" translate="yes" xml:space="preserve">
          <source>Geometric Shapes</source>
          <target state="translated">기하학적 모양</target>
        </trans-unit>
        <trans-unit id="aca441ddd2e8d07643b87c1b24a828fa5b4b3e42" translate="yes" xml:space="preserve">
          <source>Georgian</source>
          <target state="translated">Georgian</target>
        </trans-unit>
        <trans-unit id="c559cff938d372579d74b90c80d2874125e4b5d4" translate="yes" xml:space="preserve">
          <source>Georgian Supplement</source>
          <target state="translated">그루지야 어 보충</target>
        </trans-unit>
        <trans-unit id="2e85da619ae334aca9d3221727062ef17b60edd9" translate="yes" xml:space="preserve">
          <source>Get Pointer to Thrown Object if type of thrown object is implicitly convertible to the catch type.</source>
          <target state="translated">던져진 객체의 타입이 캐치 타입으로 암시 적으로 변환 될 수 있다면 포인터를 던져진 객체로 가져 오기</target>
        </trans-unit>
        <trans-unit id="49759c09a6285b1e1c3c2442b86bed6b17c79b57" translate="yes" xml:space="preserve">
          <source>Get RTTI mangling of the given class declaration for C++ ABI.</source>
          <target state="translated">C ++ ABI에 대해 주어진 클래스 선언의 RTTI 조작을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="30af4ba10b05a5544d5e9caa6adff1c6bc3df069" translate="yes" xml:space="preserve">
          <source>Get TypeInfo for 'next' type, as defined by what kind of type this is, null if none.</source>
          <target state="translated">어떤 유형의 유형으로 정의 된 '다음'유형에 대한 TypeInfo를 가져옵니다 (없는 경우).</target>
        </trans-unit>
        <trans-unit id="c92e7f5f377e9154bb8151fe8cde1e5454a8ad6b" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of</source>
          <target state="translated">AliasSeq of</target>
        </trans-unit>
        <trans-unit id="2697c6709922de4b4eb3a504173797b3b2d2f222" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of the base class and base interfaces of this class or interface. BaseTypeTuple!Object returns the empty type tuple.</source>
          <target state="translated">이 클래스 또는 인터페이스의 기본 클래스 및 기본 인터페이스의 AliasSeq를 가져옵니다. BaseTypeTuple! Object는 빈 유형 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="debff9d835c323dd33cb0eb8c68915f9979c7a6c" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;gt; e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라&amp;gt; e 인 모든 요소가있는 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f427a0e190ea30b9ef773b930557ceb28c95c24" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;lt; e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라 &amp;lt;e 인 모든 요소를 ​​가진 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a49fd135d74779940e67901f3680596c3cb7489" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are == e according to the less comparator</source>
          <target state="translated">덜 비교기에 따라 == e 인 모든 요소가있는 컨테이너에서 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="57416603cdc2a4317e5cef5fc1df8438a0dc691d" translate="yes" xml:space="preserve">
          <source>Get a socket option.</source>
          <target state="translated">소켓 옵션을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="ab0526a6b77b2a6ea32e278479a2c15bfc6233f8" translate="yes" xml:space="preserve">
          <source>Get a text description of this socket's error status, and clear the socket's error status.</source>
          <target state="translated">이 소켓의 에러 상태에 관한 텍스트 설명을 취득 해, 소켓의 에러 상태를 클리어합니다.</target>
        </trans-unit>
        <trans-unit id="cb65e9616425e0463e1160c764ce114f293c53ad" translate="yes" xml:space="preserve">
          <source>Get a timeout (duration) option.</source>
          <target state="translated">시간 초과 (지속 기간) 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 유형을 튜플로 가져옵니다. 이것은 가상 함수 테이블 포인터 또는 중첩 유형에 대한 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 하나의 요소 &lt;code&gt;T&lt;/code&gt; 가있는 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 이름을 튜플로 표현하십시오. 이것은 가상 함수 테이블 포인터 또는 중첩 유형에 대한 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. 상속 된 필드 (클래스 용)는 포함되지 않습니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 빈 문자열이있는 표현식 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 의 생성 / 액세스 / 수정 된 시간을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="691bafc770aff46bbe0856f713e81a3d1edbf405" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in SIMD register(s) if available</source>
          <target state="translated">유형에 대한 플래그 가져 오기 : 1은 GC가 포인터를 스캔해야 함을 의미하고, 2는이 유형의 arg가 가능한 경우 SIMD 레지스터에 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">유형에 대한 플래그 가져 오기 : 1은 GC가 포인터를 스캔해야 함을 의미하고 2는이 유형의 arg가 XMM 레지스터에 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">필드 인덱스를 가져옵니다. 찾지 못하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">튜플로 접는 n 번째 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">csym 시작에서 기본 클래스의 vtbl [] 이니셜 라이저 오프셋을 가져옵니다. 이 csym이 아닌 경우 ~ 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="188a425106e789190ec847f6a6792e93a54341a7" translate="yes" xml:space="preserve">
          <source>Get or set compression method used for this member.</source>
          <target state="translated">이 멤버에 사용되는 압축 방법을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2ee99e17347439a45b11edd2de3c4f3e29784dd4" translate="yes" xml:space="preserve">
          <source>Get or set data of member in uncompressed form. When an existing archive is read &lt;code&gt;ZipArchive.expand&lt;/code&gt; needs to be called before this can be accessed.</source>
          <target state="translated">압축되지 않은 형태로 멤버의 데이터를 가져 오거나 설정합니다. 기존 아카이브를 읽을 때 &lt;code&gt;ZipArchive.expand&lt;/code&gt; 를 호출해야 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7d46f4532c87d8a4e544df5791739440cc36ce" translate="yes" xml:space="preserve">
          <source>Get or set the OS specific file attributes for this archive member.</source>
          <target state="translated">이 아카이브 멤버에 대한 OS 특정 파일 속성을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1296d6fdc83b6b554050c4b4aa7fef3699ac90e1" translate="yes" xml:space="preserve">
          <source>Get or set the last modification time for this member.</source>
          <target state="translated">이 멤버의 마지막 수정 시간을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 의&lt;/a&gt; 모든 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 간격에 걸쳐있는 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 크기를 바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">타이의 크기를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">키로 targetInfo 가져 오기</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">연관 배열의 키 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">아카이브 멤버의 OS 특정 파일 속성을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">연관 배열의 값 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 또는 폴더 &lt;code&gt;name&lt;/code&gt; 의 액세스 및 수정 시간을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">내부 포인터의 캐시 된 블록 정보를 가져옵니다. 내부 포인터의 블록이 캐시되지 않은 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">인덱스 i에서 코드 단위 가져 오기</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">현재 스레드의 인스턴스를 가져옵니다. 심판에 의해 반환합니다. 이 인스턴스를 만든 &lt;code&gt;TaskPool&lt;/code&gt; 외부의 스레드에서 &lt;code&gt;get&lt;/code&gt; 을 호출 하면 동일한 참조가 반환되므로 작업자 로컬 저장소의 인스턴스는 해당 인스턴스를 만든 풀 외부의 한 스레드에서만 액세스해야합니다. 이 규칙을 위반하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 으로 현재 시간 가져 오기</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">시스템 시계에서 현재 시간을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">플랫폼에 대한 기본 &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">경로의 드라이브 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">&lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; 테스트 를 통과 한 첫 번째 인수 &lt;code&gt;a&lt;/code&gt; 를 가져옵니다 . 인수가 테스트를 통과하지 못하면 마지막 인수를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 전체 패키지 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">형식이나 기호의 정규화 된 이름을 가져옵니다. 지능형 유형 / 기호-문자열 변환기로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">호출 가능한 객체 &lt;code&gt;func&lt;/code&gt; 에서 함수 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">이 멤버의 마지막 수정 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">느린 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">오류를 설명하는 메시지를 받으십시오. 기본 동작은 &lt;code&gt;Throwable.msg&lt;/code&gt; 필드 를 반환하는 것 입니다. 다른 오류 메시지를 반환하도록 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 모듈 이름 (패키지 포함)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">구조체 또는 클래스 필드의 기본 유형을 토폴로지 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">파일의 크기를 가져옵니다. 파일을 검색 할 수없는 경우 ulong.max이지만 실제 오류가 발생하면 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">소켓의 주소 패밀리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">형식의 기본 초기화 식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수의 반환 값의 유형, 함수에 대한 포인터, 대리인, opCall, opCall, 또는있는 클래스와 구조체에 대한 포인터와 구조체 가져 &lt;code&gt;opCall&lt;/code&gt; 을 . 그 심판 유형의 일부가 아닌 참고하지만, 함수의 속성 (템플릿 참조하십시오 &lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">다항 산술 식에서 스칼라 형식 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;승격시킬&lt;/a&gt; 형식을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">모든 유형을 암시 적으로 변환 할 수있는 유형을 가져옵니다. 많은 초기화 값에서 배열 유형을 알아내는 데 유용합니다. 빈 목록을 전달했거나 형식에 공통 형식이없는 경우 void를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">주어진 인수를 &lt;code&gt;extern(C++)&lt;/code&gt; 함수 에 전달하는 데 실제로 사용될 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">기본 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Typedef&lt;/code&gt; 가 랩핑 하는 기본 유형을 가져옵니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;Typedef&lt;/code&gt; 는 자체의 별명합니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">.max / .min 속성 값을 Expression으로 가져옵니다. Lazily는 값을 계산하고 maxval / minval로 캐시합니다. 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">이름 조회 시간, 총 시간, 연결 시간 등과 같은 다양한 타이밍을 가져옵니다. 타이밍 값이 val에 저장되는 동안 타이밍 범주가 타이밍 매개 변수를 통과합니다. res가 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 와 같은 경우에만 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">매개 변수의 스토리지 클래스에 대해 함수 매개 변수 당 하나씩 튜플을 가져옵니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
