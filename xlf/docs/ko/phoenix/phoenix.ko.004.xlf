<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="ca20f1fc38a83abc4fe1f015f1e4a61f6d344ca3" translate="yes" xml:space="preserve">
          <source>Ecto.Association.BelongsTo</source>
          <target state="translated">Ecto.Association.BelongsTo</target>
        </trans-unit>
        <trans-unit id="bab53a05091b2ada117882673397ba808e865699" translate="yes" xml:space="preserve">
          <source>Ecto.Association.Has</source>
          <target state="translated">Ecto.Association.Has</target>
        </trans-unit>
        <trans-unit id="5b5db5b2170f1ce4d827994851108a6d1ee7d5b2" translate="yes" xml:space="preserve">
          <source>Ecto.Association.HasThrough</source>
          <target state="translated">Ecto.Association.HasThrough</target>
        </trans-unit>
        <trans-unit id="19e40c29077106de6b4120c7850a32444efff935" translate="yes" xml:space="preserve">
          <source>Ecto.Association.ManyToMany</source>
          <target state="translated">Ecto.Association.ManyToMany</target>
        </trans-unit>
        <trans-unit id="3e9d659ba5926e1ffb6a9e2eb6ce68fe1b43f568" translate="yes" xml:space="preserve">
          <source>Ecto.Association.NotLoaded</source>
          <target state="translated">Ecto.Association.NotLoaded</target>
        </trans-unit>
        <trans-unit id="f5d903958036e8e9d5b98f8ead032495c636fa97" translate="yes" xml:space="preserve">
          <source>Ecto.CastError</source>
          <target state="translated">Ecto.CastError</target>
        </trans-unit>
        <trans-unit id="359261cc36e3c68943f7642959e3a7879245c174" translate="yes" xml:space="preserve">
          <source>Ecto.CastError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.CastError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="87f7561d3d03785d252cdce4cff69685e660886d" translate="yes" xml:space="preserve">
          <source>Ecto.ChangeError</source>
          <target state="translated">Ecto.ChangeError</target>
        </trans-unit>
        <trans-unit id="eecc0c345ee7d1bc75637e20508b14c21e90d5ae" translate="yes" xml:space="preserve">
          <source>Ecto.ChangeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.ChangeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="67418d61e9ba76e8391116ba7958917020d802e6" translate="yes" xml:space="preserve">
          <source>Ecto.Changeset</source>
          <target state="translated">Ecto.Changeset</target>
        </trans-unit>
        <trans-unit id="04974eb9c173298cc8ee0461a1b8ea7c060f1a7b" translate="yes" xml:space="preserve">
          <source>Ecto.ConstraintError</source>
          <target state="translated">Ecto.ConstraintError</target>
        </trans-unit>
        <trans-unit id="8a42dff4520c0f3dad83eab70460eba2239a1c5f" translate="yes" xml:space="preserve">
          <source>Ecto.ConstraintError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.ConstraintError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9ce1aee0af48a2f8651b751987fa8bc0f4e35a20" translate="yes" xml:space="preserve">
          <source>Ecto.InvalidChangesetError</source>
          <target state="translated">Ecto.InvalidChangesetError</target>
        </trans-unit>
        <trans-unit id="ce67b142a1bb80cf9c2a2867d44ea6a8c3578c02" translate="yes" xml:space="preserve">
          <source>Ecto.InvalidChangesetError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.InvalidChangesetError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c5d1477ae3fb400821f1242b9bb3dc4a61c20190" translate="yes" xml:space="preserve">
          <source>Ecto.InvalidURLError</source>
          <target state="translated">Ecto.InvalidURLError</target>
        </trans-unit>
        <trans-unit id="4f08c43270c41104629098a7c2219b5dc40b37cf" translate="yes" xml:space="preserve">
          <source>Ecto.InvalidURLError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.InvalidURLError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="70da37d2af0a5953603574326abc9ac655050e10" translate="yes" xml:space="preserve">
          <source>Ecto.LogEntry</source>
          <target state="translated">Ecto.LogEntry</target>
        </trans-unit>
        <trans-unit id="35c9fc73d2d00ac9bcf8cdabe8534e91ab794279" translate="yes" xml:space="preserve">
          <source>Ecto.MigrationError</source>
          <target state="translated">Ecto.MigrationError</target>
        </trans-unit>
        <trans-unit id="a9ceb2554ab2c7eeb30e6a3c180ef6e2b319e425" translate="yes" xml:space="preserve">
          <source>Ecto.MigrationError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.MigrationError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4ca20044e173c84dd6302ce5e5cf9074c593be6" translate="yes" xml:space="preserve">
          <source>Ecto.Multi</source>
          <target state="translated">Ecto.Multi</target>
        </trans-unit>
        <trans-unit id="9907ae967fed0c4dc1e86c3721c118b3891d1fea" translate="yes" xml:space="preserve">
          <source>Ecto.MultiplePrimaryKeyError</source>
          <target state="translated">Ecto.MultiplePrimaryKeyError</target>
        </trans-unit>
        <trans-unit id="c1f9b9fe432a00f35560ba356a40f39920f1f051" translate="yes" xml:space="preserve">
          <source>Ecto.MultiplePrimaryKeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.MultiplePrimaryKeyError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="24182395079f3e39b19794e38a815c33b9b1dfef" translate="yes" xml:space="preserve">
          <source>Ecto.MultipleResultsError</source>
          <target state="translated">Ecto.MultipleResultsError</target>
        </trans-unit>
        <trans-unit id="7a94e3e2049d8814ddba5b9ced7f31db2e7e29c7" translate="yes" xml:space="preserve">
          <source>Ecto.MultipleResultsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.MultipleResultsError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b4b837c1b562905d62ed1b14e00149c2ac6f6807" translate="yes" xml:space="preserve">
          <source>Ecto.NoPrimaryKeyFieldError</source>
          <target state="translated">Ecto.NoPrimaryKeyFieldError</target>
        </trans-unit>
        <trans-unit id="d7ea505a6cd593eabd8c281c2d19d2e9112b9283" translate="yes" xml:space="preserve">
          <source>Ecto.NoPrimaryKeyFieldError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.NoPrimaryKeyFieldError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5a80b5c4c8ef26db11186fd6e9a5e8f2d97f9f5b" translate="yes" xml:space="preserve">
          <source>Ecto.NoPrimaryKeyValueError</source>
          <target state="translated">Ecto.NoPrimaryKeyValueError</target>
        </trans-unit>
        <trans-unit id="0338e60f705ec07827b6de702273e130cc6ecba3" translate="yes" xml:space="preserve">
          <source>Ecto.NoPrimaryKeyValueError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.NoPrimaryKeyValueError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="67d9f373ca10f601f6578faac7affe911846f2c7" translate="yes" xml:space="preserve">
          <source>Ecto.NoResultsError</source>
          <target state="translated">Ecto.NoResultsError</target>
        </trans-unit>
        <trans-unit id="3b3df04e61c31360e8b11f8666b9fe1d610f05b1" translate="yes" xml:space="preserve">
          <source>Ecto.NoResultsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.NoResultsError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c2609bbb3bacd4e67c3f9412afeeeadf7ac8e15" translate="yes" xml:space="preserve">
          <source>Ecto.Query</source>
          <target state="translated">Ecto.Query</target>
        </trans-unit>
        <trans-unit id="c13b3224c69630c615aec89551d2087bc042356a" translate="yes" xml:space="preserve">
          <source>Ecto.Query metadata fields (stored in cache)</source>
          <target state="translated">Ecto. 쿼리 메타 데이터 필드 (캐시에 저장 됨)</target>
        </trans-unit>
        <trans-unit id="541f8c403ffae2f4def036ce1baec276f67f4d63" translate="yes" xml:space="preserve">
          <source>Ecto.Query.API</source>
          <target state="translated">Ecto.Query.API</target>
        </trans-unit>
        <trans-unit id="3bbd7e221f68e1527e309cad7aba8114992aab8d" translate="yes" xml:space="preserve">
          <source>Ecto.Query.CastError</source>
          <target state="translated">Ecto.Query.CastError</target>
        </trans-unit>
        <trans-unit id="60b00c79bb2a8de43e5fae787ea603d53a3c8a03" translate="yes" xml:space="preserve">
          <source>Ecto.Query.CastError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.Query.CastError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="322683d4c482d9d4887697a585690a94b1c37b60" translate="yes" xml:space="preserve">
          <source>Ecto.Query.CompileError</source>
          <target state="translated">Ecto.Query.CompileError</target>
        </trans-unit>
        <trans-unit id="f6bb3386062941386362beaf0414a6747bab26f7" translate="yes" xml:space="preserve">
          <source>Ecto.Query.CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.Query.CompileError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7dafa0a51a47382e1e63f70ed8f204dca6da2b81" translate="yes" xml:space="preserve">
          <source>Ecto.Query.WindowAPI</source>
          <target state="translated">Ecto.Query.WindowAPI</target>
        </trans-unit>
        <trans-unit id="bc2486ab3f1e159284df09db70205a20ecc2201b" translate="yes" xml:space="preserve">
          <source>Ecto.QueryError</source>
          <target state="translated">Ecto.QueryError</target>
        </trans-unit>
        <trans-unit id="4c241d42a8511f3b16e8e651c93c41a6e57fd732" translate="yes" xml:space="preserve">
          <source>Ecto.QueryError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.QueryError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8bd6a5e6bbbba374ec54882523a3dd6aa01f6bf0" translate="yes" xml:space="preserve">
          <source>Ecto.Queryable</source>
          <target state="translated">Ecto.Queryable</target>
        </trans-unit>
        <trans-unit id="5f5fb9bbe4d236231c4e0c9a1f430c532e1b61df" translate="yes" xml:space="preserve">
          <source>Ecto.Queryable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">엑서 터블 쿼리 가능 &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="23d0b05d82025970e8643b6c2b44b5c9cc5422bf" translate="yes" xml:space="preserve">
          <source>Ecto.Queryable.t (0)</source>
          <target state="translated">Ecto.Queryable.t (0)</target>
        </trans-unit>
        <trans-unit id="2c66da9b2fb68c8d72ed4f1fdd408f25acf7b28f" translate="yes" xml:space="preserve">
          <source>Ecto.Queryable.to_query (1)</source>
          <target state="translated">Ecto.Queryable.to_query (1)</target>
        </trans-unit>
        <trans-unit id="b2b785210b6db93332cdd4d8ac8b14e9a6c8f2ec" translate="yes" xml:space="preserve">
          <source>Ecto.Repo</source>
          <target state="translated">Ecto.Repo</target>
        </trans-unit>
        <trans-unit id="abe003d38251fd11493b7aebc84a41065c8194a8" translate="yes" xml:space="preserve">
          <source>Ecto.Repo &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">엑토 레포 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1c38674c5108afb7eaab34bd7a717b13c34f6ea4" translate="yes" xml:space="preserve">
          <source>Ecto.Schema</source>
          <target state="translated">Ecto.Schema</target>
        </trans-unit>
        <trans-unit id="7213ca12b7254752de375b48ed69b6ac5c7591bd" translate="yes" xml:space="preserve">
          <source>Ecto.Schema metadata fields</source>
          <target state="translated">Ecto. 스키마 메타 데이터 필드</target>
        </trans-unit>
        <trans-unit id="9a7f68db592f84a9943fcb5b898c5e74891071ee" translate="yes" xml:space="preserve">
          <source>Ecto.Schema.Metadata</source>
          <target state="translated">Ecto.Schema.Metadata</target>
        </trans-unit>
        <trans-unit id="5755ba5b43e2e121bb26c6314858c4dc73dcc16c" translate="yes" xml:space="preserve">
          <source>Ecto.StaleEntryError</source>
          <target state="translated">Ecto.StaleEntryError</target>
        </trans-unit>
        <trans-unit id="d751e1a6e5e77ee622ddb5ffa9aab3299c04d4ac" translate="yes" xml:space="preserve">
          <source>Ecto.StaleEntryError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.StaleEntryError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee0b6d1251bf780cf3082c668fa6afbd815e531c" translate="yes" xml:space="preserve">
          <source>Ecto.SubQuery</source>
          <target state="translated">Ecto.SubQuery</target>
        </trans-unit>
        <trans-unit id="5c5767f0467eff752742c91059c0f52a0d6da85b" translate="yes" xml:space="preserve">
          <source>Ecto.SubQueryError</source>
          <target state="translated">Ecto.SubQueryError</target>
        </trans-unit>
        <trans-unit id="af82c0bc574ed28a1bae0825f4ff83faf8642aa4" translate="yes" xml:space="preserve">
          <source>Ecto.SubQueryError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Ecto.SubQueryError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bb89049cf6c1b37baa9267def3cd2d5e6e580a10" translate="yes" xml:space="preserve">
          <source>Ecto.Type</source>
          <target state="translated">Ecto.Type</target>
        </trans-unit>
        <trans-unit id="fd40802d5250133cf255ced53966159d4b5335d7" translate="yes" xml:space="preserve">
          <source>Ecto.Type &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Ecto.Type &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1d464328ab2db0790a29e4a5a61c2b51b36dc9" translate="yes" xml:space="preserve">
          <source>Ecto.UUID</source>
          <target state="translated">Ecto.UUID</target>
        </trans-unit>
        <trans-unit id="6bddcb552c6a1068cf1e007274938eab003f3107" translate="yes" xml:space="preserve">
          <source>Elixir type</source>
          <target state="translated">엘릭서 타입</target>
        </trans-unit>
        <trans-unit id="2f0de64ee8f6d9722cf5b6928af715bb95ebc664" translate="yes" xml:space="preserve">
          <source>Embedded schemas are defined similarly to source-based schemas. For example, you can use an embedded schema to represent your UI, mapping and validating its inputs, and then you convert such embedded schema to other schemas that are persisted to the database:</source>
          <target state="translated">임베디드 스키마는 소스 기반 스키마와 유사하게 정의됩니다. 예를 들어, 임베디드 스키마를 사용하여 UI를 표시하고 해당 입력을 맵핑하고 유효성 검증 한 후 해당 임베디드 스키마를 데이터베이스에 지속되는 다른 스키마로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d321b43810ec712e82ac71b26aa2669c35cc9ab5" translate="yes" xml:space="preserve">
          <source>Embedded schemas by default set the primary key type to &lt;code&gt;:binary_id&lt;/code&gt; but such can be configured with the &lt;code&gt;@primary_key&lt;/code&gt; attribute.</source>
          <target state="translated">기본적으로 임베드 된 스키마는 기본 키 유형을 &lt;code&gt;:binary_id&lt;/code&gt; 로 설정하지만 &lt;code&gt;@primary_key&lt;/code&gt; 속성 으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a74c4dff63d6eb182129f486224163ded7dd1010" translate="yes" xml:space="preserve">
          <source>Embeds</source>
          <target state="translated">Embeds</target>
        </trans-unit>
        <trans-unit id="15ec2a27c2b613ef9d1246405878528dbe70f066" translate="yes" xml:space="preserve">
          <source>Empty values</source>
          <target state="translated">빈 값</target>
        </trans-unit>
        <trans-unit id="e12c4bc51c7f80baf2d58cd60b0b72befe9d7fc3" translate="yes" xml:space="preserve">
          <source>Emulates the client closing the channel</source>
          <target state="translated">채널을 닫는 클라이언트를 에뮬레이트합니다</target>
        </trans-unit>
        <trans-unit id="0a0d1d460ed7ae24bb26447eb441939d7594f965" translate="yes" xml:space="preserve">
          <source>Emulates the client closing the channel.</source>
          <target state="translated">채널을 닫는 클라이언트를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="556d7fd9dce7e339a9e21896427d0e9df9216df4" translate="yes" xml:space="preserve">
          <source>Emulates the client closing the socket.</source>
          <target state="translated">소켓을 닫는 클라이언트를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="ed1383e73a934ae5dd38c4adeabafed7e4cdc135" translate="yes" xml:space="preserve">
          <source>Emulates the client leaving the channel</source>
          <target state="translated">채널을 떠나는 클라이언트를 에뮬레이트합니다</target>
        </trans-unit>
        <trans-unit id="17db6b3bc54f57ff281b3281cff48c1f91f0d117" translate="yes" xml:space="preserve">
          <source>Emulates the client leaving the channel.</source>
          <target state="translated">채널을 떠나는 클라이언트를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="4833d68fa15ee9411ff3f9f19c84f736625b93d0" translate="yes" xml:space="preserve">
          <source>Enables CSRF protection</source>
          <target state="translated">CSRF 보호 가능</target>
        </trans-unit>
        <trans-unit id="840448d9ff6144dc12b1d62bf7566dd85976712b" translate="yes" xml:space="preserve">
          <source>Enables CSRF protection.</source>
          <target state="translated">CSRF 보호를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="36f7f260eacff8ce7935340ac25cfe6dfe22d818" translate="yes" xml:space="preserve">
          <source>Enables or disables recursive mode for CTEs.</source>
          <target state="translated">CTE에 대한 재귀 모드를 활성화하거나 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4439d359c8275177c11416f7d623055571b3b559" translate="yes" xml:space="preserve">
          <source>Encodes &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; struct to transport representation</source>
          <target state="translated">&lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 구조체를 인코딩 하여 표현을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="33640f5ec22b24bf0f0de171e9a5b8b2a0b764cc" translate="yes" xml:space="preserve">
          <source>Encodes and signs data into a token you can send to clients.</source>
          <target state="translated">클라이언트에 보낼 수있는 토큰으로 데이터를 인코딩하고 서명합니다.</target>
        </trans-unit>
        <trans-unit id="4136cdced053cd2d3ad4a24cfaebe880c4880600" translate="yes" xml:space="preserve">
          <source>Encodes data and signs it resulting in a token you can send to clients</source>
          <target state="translated">데이터를 인코딩하고 서명하여 고객에게 보낼 수있는 토큰을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5bd32fbf8fb4988c6f06bf34be67709564d0ac19" translate="yes" xml:space="preserve">
          <source>Encodes data and signs it resulting in a token you can send to clients.</source>
          <target state="translated">데이터를 인코딩하고 서명하여 클라이언트에게 보낼 수있는 토큰을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fc00694b284fbf0ca6ed4b59333c21bf7da11346" translate="yes" xml:space="preserve">
          <source>Encodes the HTML templates to iodata</source>
          <target state="translated">HTML 템플릿을 iodata로 인코딩</target>
        </trans-unit>
        <trans-unit id="bfb6909ba137b13bf90db64457d8678c524bc153" translate="yes" xml:space="preserve">
          <source>Encodes the HTML templates to iodata.</source>
          <target state="translated">HTML 템플릿을 iodata로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="bfa7ce5698a8c9a272f9b42da04c2bba3f9d1ada" translate="yes" xml:space="preserve">
          <source>Encodes the given cookies as expected in a response header</source>
          <target state="translated">응답 헤더에 예상대로 주어진 쿠키를 인코딩합니다</target>
        </trans-unit>
        <trans-unit id="f48a0503bd24012813e0aede68caa5bd3d5aa5e1" translate="yes" xml:space="preserve">
          <source>Encodes the given cookies as expected in a response header.</source>
          <target state="translated">응답 헤더에 예상대로 주어진 쿠키를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="cb350517064b72d7a25e5f65ef89d41643ca3680" translate="yes" xml:space="preserve">
          <source>Encodes the given map or list of tuples</source>
          <target state="translated">주어진 맵 또는 튜플 목록을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="c1ab5b445561e7ceefe285404758fbc9608784a0" translate="yes" xml:space="preserve">
          <source>Encodes the given map or list of tuples.</source>
          <target state="translated">주어진 맵 또는 튜플 목록을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="96e127ce8d6455e372c5fd56ea665af369ae1ea3" translate="yes" xml:space="preserve">
          <source>Encodes, encrypts, and signs data into a token you can send to clients.</source>
          <target state="translated">클라이언트에 보낼 수있는 토큰으로 데이터를 인코딩, 암호화 및 서명합니다.</target>
        </trans-unit>
        <trans-unit id="21b846476300f853d85d13d5947f9d2d00aa2516" translate="yes" xml:space="preserve">
          <source>Encoding and decoding</source>
          <target state="translated">인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="a020f6241ab7166f95774e91599ed46cf2bafaa1" translate="yes" xml:space="preserve">
          <source>Encoding keyword lists preserves the order of the fields:</source>
          <target state="translated">키워드 목록 인코딩은 필드 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7a2e6e7d7f545bf8d74f9cf21ea1d5f909b9251c" translate="yes" xml:space="preserve">
          <source>Encoding named lists:</source>
          <target state="translated">명명 된 목록 인코딩 :</target>
        </trans-unit>
        <trans-unit id="506c5c945e0ce764f280c5d79fc55cd83adbe7a0" translate="yes" xml:space="preserve">
          <source>Encoding nested structures:</source>
          <target state="translated">중첩 구조 인코딩 :</target>
        </trans-unit>
        <trans-unit id="ec278d1a15f13618c39a6bd06f27ddc94e905d46" translate="yes" xml:space="preserve">
          <source>Endpoint API</source>
          <target state="translated">엔드 포인트 API</target>
        </trans-unit>
        <trans-unit id="bf921ae468046a48c903c965f5551969f48378ce" translate="yes" xml:space="preserve">
          <source>Endpoint configuration</source>
          <target state="translated">엔드 포인트 구성</target>
        </trans-unit>
        <trans-unit id="ee8e5c078cab8ccf1fa5878d9e0a129082bd3e77" translate="yes" xml:space="preserve">
          <source>Endpoint configuration is split into two categories. Compile-time configuration means the configuration is read during compilation and changing it at runtime has no effect. The compile-time configuration is mostly related to error handling and instrumentation.</source>
          <target state="translated">엔드 포인트 구성은 두 가지 범주로 나뉩니다. 컴파일 타임 구성은 컴파일 중에 구성을 읽고 런타임에 구성을 변경해도 아무런 영향이 없음을 의미합니다. 컴파일 타임 구성은 주로 오류 처리 및 계측과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e59e51cf292e385731745bc10fe86792b75ae2e2" translate="yes" xml:space="preserve">
          <source>Endpoint configuration is split into two categories. Compile-time configuration means the configuration is read during compilation and changing it at runtime has no effect. The compile-time configuration is mostly related to error handling.</source>
          <target state="translated">끝점 구성은 두 가지 범주로 나뉩니다. 컴파일 시간 구성은 컴파일 중에 구성을 읽고 런타임에 변경해도 효과가 없음을 의미합니다. 컴파일 타임 구성은 대부분 오류 처리와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86c04bf06c2268868838496ad24090854ec6e5c4" translate="yes" xml:space="preserve">
          <source>Endpoint testing</source>
          <target state="translated">엔드 포인트 테스트</target>
        </trans-unit>
        <trans-unit id="b71c52711a24936e87649f5f6c786f704fc55482" translate="yes" xml:space="preserve">
          <source>Endpoints</source>
          <target state="translated">Endpoints</target>
        </trans-unit>
        <trans-unit id="48909b7ad855199bfe59cea5c9a40d133ce3f9b8" translate="yes" xml:space="preserve">
          <source>Endpoints must be explicitly started as part of your application supervision tree. Endpoints are added by default to the supervision tree in generated applications. Endpoints can be added to the supervision tree as follows:</source>
          <target state="translated">엔드 포인트는 애플리케이션 감독 트리의 일부로 명시 적으로 시작해야합니다. 엔드 포인트는 기본적으로 생성 된 애플리케이션의 감독 트리에 추가됩니다. 다음과 같이 엔드 포인트를 감독 트리에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83aa16682d0c2ba817fe74261af7a04ddcc5cc37" translate="yes" xml:space="preserve">
          <source>Enforce UTF-8</source>
          <target state="translated">UTF-8 시행</target>
        </trans-unit>
        <trans-unit id="c1849eb0be9af6564e6d0e3b62d673d25b59cf17" translate="yes" xml:space="preserve">
          <source>Engines must implement the &lt;code&gt;compile/2&lt;/code&gt; function, that receives the template file and the template name and outputs the template quoted expression:</source>
          <target state="translated">엔진은 템플릿 파일과 템플릿 이름을 받아서 템플릿 인용 표현식을 출력하는 &lt;code&gt;compile/2&lt;/code&gt; 함수를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="196d7b3309d1e5eb9850884afec4c4bae3450d0c" translate="yes" xml:space="preserve">
          <source>Ensure all applications necessary to run the adapter are started</source>
          <target state="translated">어댑터를 실행하는 데 필요한 모든 응용 프로그램이 시작되었는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="97c96b97adefd31804b306b76be9c18601ec510f" translate="yes" xml:space="preserve">
          <source>Ensure all applications necessary to run the adapter are started.</source>
          <target state="translated">어댑터를 실행하는 데 필요한 모든 응용 프로그램이 시작되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6880556f20877e4f8a52af36bc2d3b199805feb2" translate="yes" xml:space="preserve">
          <source>Ensures the connection is recycled if it wasn&amp;rsquo;t already</source>
          <target state="translated">연결이 아직 재생되지 않은 경우 재활용</target>
        </trans-unit>
        <trans-unit id="0e60a03980aee027fe1691a01cc5bb11c0cbee85" translate="yes" xml:space="preserve">
          <source>Ensures the connection is recycled if it wasn&amp;rsquo;t already.</source>
          <target state="translated">연결이 아직 재생되지 않은 경우 재활용합니다.</target>
        </trans-unit>
        <trans-unit id="11fb9b2b2a3e23b06b060112d12641a59b79933d" translate="yes" xml:space="preserve">
          <source>Ensures the connection is recycled if it wasn't already.</source>
          <target state="translated">연결이 아직 재활용되지 않은 경우 재활용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="7f320b643659b7061b5946fbb621cc2591e2c14e" translate="yes" xml:space="preserve">
          <source>Ensures the given module is an Ecto.Repo</source>
          <target state="translated">주어진 모듈이 Ecto인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6c59a3a6076875ecee6278d9f31718bdc8f04fc7" translate="yes" xml:space="preserve">
          <source>Ensures the given module is an Ecto.Repo.</source>
          <target state="translated">주어진 모듈이 Ecto.Repo인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ad5a4781c158db980d641100598f0a814961f62" translate="yes" xml:space="preserve">
          <source>Equivalent to multiple &lt;a href=&quot;#put_private/3&quot;&gt;&lt;code&gt;put_private/3&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">여러 &lt;a href=&quot;#put_private/3&quot;&gt; &lt;code&gt;put_private/3&lt;/code&gt; &lt;/a&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="665844873eba6677ffd80e2288163b49c7de89ff" translate="yes" xml:space="preserve">
          <source>Equivalent to multiple calls to &lt;a href=&quot;#assign/3&quot;&gt;&lt;code&gt;assign/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#assign/3&quot;&gt; &lt;code&gt;assign/3&lt;/code&gt; 에&lt;/a&gt; 대한 여러 호출과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="96b4673ef94aee0279f00bdec8bef7af091ed539" translate="yes" xml:space="preserve">
          <source>Error raised when CSRF token is invalid.</source>
          <target state="translated">CSRF 토큰이 유효하지 않은 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="cd4dd7806db221ae8f85315297f1933628bac6af" translate="yes" xml:space="preserve">
          <source>Error raised when no response is sent in a request</source>
          <target state="translated">요청에 응답이 없을 때 발생하는 오류</target>
        </trans-unit>
        <trans-unit id="80aac7a600595cc614c5a8707716e2680a856d60" translate="yes" xml:space="preserve">
          <source>Error raised when non-XHR requests are used for Javascript responses.</source>
          <target state="translated">XHR이 아닌 요청이 Javascript 응답에 사용될 때 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4fd4c12633060915842a7adbf471e8f2c4de38a5" translate="yes" xml:space="preserve">
          <source>Error raised when the cookie exceeds the maximum size of 4096 bytes.</source>
          <target state="translated">쿠키가 최대 크기 인 4096 바이트를 초과하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0075b7b1699d63ab98e1352564607df567a7b11" translate="yes" xml:space="preserve">
          <source>Error raised when the request body cannot be parsed.</source>
          <target state="translated">요청 본문을 구문 분석 할 수없는 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c83423323bd0f9e7dca7dc133f2e9d8c07a67c72" translate="yes" xml:space="preserve">
          <source>Error raised when the request body is malformed.</source>
          <target state="translated">요청 본문이 잘못된 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="355600e5fa5b646a0b7fd10a605ecbb4bd27c88c" translate="yes" xml:space="preserve">
          <source>Error raised when the request is too large.</source>
          <target state="translated">요청이 너무 클 때 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="6e12f9a35ca688371e35697f765ed55461d289eb" translate="yes" xml:space="preserve">
          <source>Error raised when trying to modify or send an already sent response</source>
          <target state="translated">이미 보낸 응답을 수정하거나 보내려고 할 때 발생하는 오류</target>
        </trans-unit>
        <trans-unit id="296513012a971b48d8b833aad634bbe05b65f96e" translate="yes" xml:space="preserve">
          <source>Error raised when trying to send a header that has errors, for example:</source>
          <target state="translated">오류가있는 헤더를 보내려고하면 오류가 발생합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="777544a1e5e3a2890c9d11e0670e4f90afe4ee49" translate="yes" xml:space="preserve">
          <source>Escapes the given HTML to iodata</source>
          <target state="translated">주어진 HTML을 iodata로 이스케이프 처리</target>
        </trans-unit>
        <trans-unit id="55a6457b3b6b83f90cbc23a5b6f6ef249a6e461d" translate="yes" xml:space="preserve">
          <source>Escapes the given HTML to iodata.</source>
          <target state="translated">주어진 HTML을 iodata로 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="d428b221d3f388b6985a15759340115a82a01a85" translate="yes" xml:space="preserve">
          <source>Escapes the given HTML to string</source>
          <target state="translated">주어진 HTML을 문자열로 이스케이프</target>
        </trans-unit>
        <trans-unit id="9aae0e2d943bc79363acc16d6ad4f9539adf131a" translate="yes" xml:space="preserve">
          <source>Escapes the given HTML to string.</source>
          <target state="translated">주어진 HTML을 문자열로 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="a43c02952028f58987da67d94d91c06959d88ae7" translate="yes" xml:space="preserve">
          <source>Establishing the socket connection</source>
          <target state="translated">소켓 연결 설정</target>
        </trans-unit>
        <trans-unit id="8700cd4e26a53398fa836080d8b671414211c9bd" translate="yes" xml:space="preserve">
          <source>Evaluates to true if the provided subquery returns 1 or more rows.</source>
          <target state="translated">제공된 하위 쿼리가 1 개 이상의 행을 반환하면 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="fdf79b8896d2f81e42819bef253ab78ee4c76232" translate="yes" xml:space="preserve">
          <source>Evaluates whether all values returned from the provided subquery match in a comparison operation.</source>
          <target state="translated">제공된 하위 쿼리에서 반환 된 모든 값이 비교 작업에서 일치하는지 여부를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="818dc1bf0883b7b0cc6401f2614dc09f23ea8627" translate="yes" xml:space="preserve">
          <source>Even though 404 has been overridden, the &lt;code&gt;:not_found&lt;/code&gt; atom can still be used to set the status to 404 as well as the new atom &lt;code&gt;:actually_this_was_found&lt;/code&gt; inflected from the reason phrase &quot;Actually This Was Found&quot;.</source>
          <target state="translated">404가 재정의 되었음에도 불구하고 &lt;code&gt;:not_found&lt;/code&gt; 원자를 사용하여 상태를 404로 설정하고 &quot;Actually This Was Found&quot;이유 구문에서 변경된 새 원자 &lt;code&gt;:actually_this_was_found&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a62606f152b68877966f1c848b191cb7d5bb8c" translate="yes" xml:space="preserve">
          <source>Even though 404 has been overridden, the &lt;code&gt;:not_found&lt;/code&gt; atom can still be used to set the status to 404 as well as the new atom &lt;code&gt;:actually_this_was_found&lt;/code&gt; inflected from the reason phrase &amp;ldquo;Actually This Was Found&amp;rdquo;.</source>
          <target state="translated">404가 재정의 된 경우에도 &lt;code&gt;:not_found&lt;/code&gt; 원자를 사용하여 상태를 404로 설정하고 새 원자 &lt;code&gt;:actually_this_was_found&lt;/code&gt; 를 &amp;ldquo;Actually This Was Found&amp;rdquo;라는 이유 문구에서 그대로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab36676f1a0bc49dcaa9c690d2a0dbaa36bbae83" translate="yes" xml:space="preserve">
          <source>Every occurence of the &lt;code&gt;?&lt;/code&gt; character will be interpreted as a place for additional argument. If the literal character &lt;code&gt;?&lt;/code&gt; is required, it can be escaped with &lt;code&gt;\\?&lt;/code&gt; (one escape for strings, another for fragment).</source>
          <target state="translated">의 모든 발생 &lt;code&gt;?&lt;/code&gt; 캐릭터는 추가 논쟁의 장소로 해석됩니다. 문자 그대로 문자 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;\\?&lt;/code&gt; 로 이스케이프 할 수 있습니까? (하나는 문자열, 다른 하나는 조각)를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="06148d94ade3c0c8e812063e3f93749008214d86" translate="yes" xml:space="preserve">
          <source>Every time &lt;a href=&quot;#pipe_through/1&quot;&gt;&lt;code&gt;pipe_through/1&lt;/code&gt;&lt;/a&gt; is called, the new pipelines are appended to the ones previously given.</source>
          <target state="translated">&lt;a href=&quot;#pipe_through/1&quot;&gt; &lt;code&gt;pipe_through/1&lt;/code&gt; &lt;/a&gt; 이 호출 될 때마다 새 파이프 라인이 이전에 제공된 파이프 라인에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3685f8a3ac8c0bf5bdecefe13889f6e26ac09c" translate="yes" xml:space="preserve">
          <source>Every time the &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; function is invoked, it must return a changeset. Once the parent changeset is given to an &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt; function, all entries will be inserted/updated/deleted within the same transaction.</source>
          <target state="translated">&lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 함수가 호출 될 때마다 변경 집합을 반환해야합니다. 상위 변경 세트가 &lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt; 함수에 제공되면 모든 항목이 동일한 트랜잭션 내에서 삽입 / 업데이트 / 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0e8f95beda0ca71a4e23af9a8fcd9870cd58bde0" translate="yes" xml:space="preserve">
          <source>Every time the &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; function is invoked, it must return a changeset. This changeset will be applied to your Repo with the proper action accordingly.</source>
          <target state="translated">&lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 함수가 호출 될 때마다 변경 세트를 리턴해야합니다. 이 변경 세트는 적절한 조치를 취하여 Repo에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="290663b1782b5ce0b5e5b56fd01c5c1316fbf708" translate="yes" xml:space="preserve">
          <source>Every time the &lt;code&gt;fetch&lt;/code&gt; callback is invoked, it is done from a separate process. Given those processes run asynchronously, it is often necessary to guarantee they have been shutdown at the end of every test. This can be done by using ExUnit's &lt;code&gt;on_exit&lt;/code&gt; hook plus &lt;code&gt;fetchers_pids&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 콜백이 호출 될 때마다 별도의 프로세스에서 수행됩니다. 이러한 프로세스는 비동기식으로 실행되므로 모든 테스트가 끝날 때마다 종료되었는지 확인해야하는 경우가 많습니다. 이것은 ExUnit의 &lt;code&gt;on_exit&lt;/code&gt; 후크와 &lt;code&gt;fetchers_pids&lt;/code&gt; 함수 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0635cb9ca58a4094467b83d74344825171cb1066" translate="yes" xml:space="preserve">
          <source>Every time you join a channel, you need to choose which particular topic you want to listen to. The topic is just an identifier, but by convention it is often made of two parts: &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt;. Using the &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; approach pairs nicely with the &lt;a href=&quot;phoenix.socket#channel/2&quot;&gt;&lt;code&gt;Phoenix.Socket.channel/2&lt;/code&gt;&lt;/a&gt; allowing you to match on all topics starting with a given prefix:</source>
          <target state="translated">채널에 참여할 때마다 듣고 싶은 특정 주제를 선택해야합니다. 주제는 식별자 일 뿐이지 만 일반적으로 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 의 두 부분으로 구성 됩니다. 사용 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 접근 방식 쌍을 멋지게로 &lt;a href=&quot;phoenix.socket#channel/2&quot;&gt; &lt;code&gt;Phoenix.Socket.channel/2&lt;/code&gt; 가&lt;/a&gt; 주어진 접두사로 시작하는 모든 주제에 맞게 수 :</target>
        </trans-unit>
        <trans-unit id="76c3074c4726c5b0a0c12202067bba3916d6bea0" translate="yes" xml:space="preserve">
          <source>Every time you join a channel, you need to choose which particular topic you want to listen to. The topic is just an identifier, but by convention it is often made of two parts: &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt;. Using the &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; approach pairs nicely with the &lt;a href=&quot;phoenix.socket#channel/3&quot;&gt;&lt;code&gt;Phoenix.Socket.channel/3&lt;/code&gt;&lt;/a&gt; allowing you to match on all topics starting with a given prefix by using a splat (the &lt;code&gt;*&lt;/code&gt; character) as the last character in the topic pattern:</source>
          <target state="translated">채널에 가입 할 때마다 듣고 싶은 특정 주제를 선택해야합니다. 주제는 식별자 일 뿐이지 만 일반적으로 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 이라는 두 부분으로 구성되는 경우가 많습니다 . 사용 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 접근 방식 쌍을 멋지게로 &lt;a href=&quot;phoenix.socket#channel/3&quot;&gt; &lt;code&gt;Phoenix.Socket.channel/3&lt;/code&gt; 는&lt;/a&gt; 당신이 플랫합니다 (사용하여 특정 접두어로 시작하는 모든 주제에 일치 할 수 있도록 &lt;code&gt;*&lt;/code&gt; 주제 패턴의 마지막 문자로 문자) :</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="654d7a479004b2b26e7de7b5ed9cd79a331ded80" translate="yes" xml:space="preserve">
          <source>Example Usage</source>
          <target state="translated">사용법 예</target>
        </trans-unit>
        <trans-unit id="5d036abf17a95029249be5aac0478db70ae0589a" translate="yes" xml:space="preserve">
          <source>Example of generated files:</source>
          <target state="translated">생성 된 파일의 예 :</target>
        </trans-unit>
        <trans-unit id="f6ebfe315ec41fe5880d8cb59f91359c8d74ad8b" translate="yes" xml:space="preserve">
          <source>Example: Adding a comment to a post</source>
          <target state="translated">예 : 게시물에 댓글 추가</target>
        </trans-unit>
        <trans-unit id="09f5a191bd1aa3c4c2a2bf0180871d036a7576ef" translate="yes" xml:space="preserve">
          <source>Example: Adding tags to a post</source>
          <target state="translated">예 : 게시물에 태그 추가</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d566c7c0b5a5e7655a937e7a2e0f690197fca27b" translate="yes" xml:space="preserve">
          <source>Examples and detailed documentation for each of those are available in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; module. Functions supported in queries are listed in &lt;a href=&quot;ecto.query.api&quot;&gt;&lt;code&gt;Ecto.Query.API&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt; 모듈 에서 각각에 대한 예제와 자세한 문서를 볼 수 있습니다 . 쿼리에서 지원되는 함수는 &lt;a href=&quot;ecto.query.api&quot;&gt; &lt;code&gt;Ecto.Query.API&lt;/code&gt; 에&lt;/a&gt; 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cad0d61f681eb1c78a7b0c3f38376aef13625b3" translate="yes" xml:space="preserve">
          <source>Except expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the difference of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#except_all/2&quot;&gt;&lt;code&gt;except_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표현식을 제외하고 각 쿼리가 고유 한 결과를 반환 한 것처럼 고유 한 행만 반환합니다. 성능이 저하 될 수 있습니다. 중복 행을 제거하지 않고 여러 결과 세트의 차이를 취해야하는 경우 &lt;a href=&quot;#except_all/2&quot;&gt; &lt;code&gt;except_all/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="c64d530f7d597c09275505d5c9c0d4f66100c4ec" translate="yes" xml:space="preserve">
          <source>Exception raised when a template cannot be found.</source>
          <target state="translated">템플릿을 찾을 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bfb3c666085af96fb301a2c7a36585a27fc21e9" translate="yes" xml:space="preserve">
          <source>Exception raised when no route is found.</source>
          <target state="translated">경로를 찾지 못하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="7bc817333cbc1bf3d1de15d9550396d9326905ac" translate="yes" xml:space="preserve">
          <source>Excluded hosts tuple</source>
          <target state="translated">제외 된 호스트 튜플</target>
        </trans-unit>
        <trans-unit id="5eab5b7fe3dcdd0495cd43577dcd643b59994032" translate="yes" xml:space="preserve">
          <source>Executes a previously prepared query</source>
          <target state="translated">이전에 준비된 쿼리를 실행합니다</target>
        </trans-unit>
        <trans-unit id="d81e8be29cc9dcb9a67e4318db7a32eb8dbb7f4a" translate="yes" xml:space="preserve">
          <source>Executes a previously prepared query.</source>
          <target state="translated">이전에 준비된 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0020e8f63dedbf5b6f61e98b567f1e0eaed81a9d" translate="yes" xml:space="preserve">
          <source>Exit reasons when stopping a channel</source>
          <target state="translated">채널을 중지 할 때 종료 이유</target>
        </trans-unit>
        <trans-unit id="edcdd1f5abd2799866e34eea3610d6b92c1f5229" translate="yes" xml:space="preserve">
          <source>Expression examples</source>
          <target state="translated">식 예</target>
        </trans-unit>
        <trans-unit id="1bbb977db38c4f253c4cea64b8d8a87132fc3861" translate="yes" xml:space="preserve">
          <source>Expressions example</source>
          <target state="translated">식 예</target>
        </trans-unit>
        <trans-unit id="3ee48fdc5db523f40497a2ed53ecc18e5f483f7e" translate="yes" xml:space="preserve">
          <source>Expressions examples</source>
          <target state="translated">식 예</target>
        </trans-unit>
        <trans-unit id="512ffac0536256b0a077954b2b56ec3d00cd8027" translate="yes" xml:space="preserve">
          <source>Extend presence information with additional data.</source>
          <target state="translated">추가 데이터로 현재 상태 정보를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="93374886ac70b6fcf67cc4422c2dd8f97aa99cba" translate="yes" xml:space="preserve">
          <source>External values and Elixir expressions can be injected into a query expression with &lt;code&gt;^&lt;/code&gt;:</source>
          <target state="translated">외부 값과 Elixir 표현식은 &lt;code&gt;^&lt;/code&gt; 를 사용하여 쿼리 표현식에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4ee136a95ce0e250b26a775c6a4f304eb49e9fb" translate="yes" xml:space="preserve">
          <source>External vs internal data</source>
          <target state="translated">외부 데이터와 내부 데이터</target>
        </trans-unit>
        <trans-unit id="1d55c1fe9b22bbea495440d9e994c00b34d01cff" translate="yes" xml:space="preserve">
          <source>Extracts connection information from &lt;code&gt;conn&lt;/code&gt; and returns a map.</source>
          <target state="translated">&lt;code&gt;conn&lt;/code&gt; 에서 연결 정보를 추출 하고 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44e6613f45ea30af9e65d715a73b23d35854f291" translate="yes" xml:space="preserve">
          <source>Extracts the resource name from an alias</source>
          <target state="translated">별명에서 자원 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b9a7f83f64bd9961bbffb73d9a101603d5fc422d" translate="yes" xml:space="preserve">
          <source>Extracts the resource name from an alias.</source>
          <target state="translated">별명에서 자원 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f06ac061a76b4ebd4a18e48b816bda1ba2a2c77c" translate="yes" xml:space="preserve">
          <source>Extracts the set&amp;rsquo;s elements from ets into a mergeable list</source>
          <target state="translated">세트의 요소를 ets에서 병합 가능한 목록으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3b06a14d516933eb29357d012c46511d38c29b2b" translate="yes" xml:space="preserve">
          <source>Extracts the set&amp;rsquo;s elements from ets into a mergeable list.</source>
          <target state="translated">세트의 요소를 ets에서 병합 가능한 목록으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3e4e6627a5b44408d225b0820df0658946bef555" translate="yes" xml:space="preserve">
          <source>Extracts the set's elements from ets into a mergeable list.</source>
          <target state="translated">집합의 요소를 ets에서 병합 가능한 목록으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="cd676bc8d0bb7e9a6ce51caa1747e0a5855e3e9e" translate="yes" xml:space="preserve">
          <source>Fetchable fields</source>
          <target state="translated">가져 오기 가능한 필드</target>
        </trans-unit>
        <trans-unit id="e284d893dbc745af72e66058a0b6fcabca9a0795" translate="yes" xml:space="preserve">
          <source>Fetches a change from the given changeset</source>
          <target state="translated">주어진 변경 세트에서 변경 사항을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="df9d063215383f5d43ff6bd8f28d50b17f990df3" translate="yes" xml:space="preserve">
          <source>Fetches a change from the given changeset.</source>
          <target state="translated">주어진 변경 세트에서 변경 사항을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fcadf1bd67677a18f8d7729c638f9317d92bc9ab" translate="yes" xml:space="preserve">
          <source>Fetches a single result from the query</source>
          <target state="translated">쿼리에서 단일 결과를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6b017414662aa05a81aef4aa976822b02de76df8" translate="yes" xml:space="preserve">
          <source>Fetches a single result from the query.</source>
          <target state="translated">쿼리에서 단일 결과를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="08719e85d959bee2a1ad16c16f9a61c7c481cd87" translate="yes" xml:space="preserve">
          <source>Fetches a single struct from the data store where the primary key matches the given id</source>
          <target state="translated">기본 키가 지정된 ID와 일치하는 데이터 저장소에서 단일 구조체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0bd85e97f228082f7016f38d8dc8a785d578d92e" translate="yes" xml:space="preserve">
          <source>Fetches a single struct from the data store where the primary key matches the given id.</source>
          <target state="translated">기본 키가 지정된 ID와 일치하는 데이터 저장소에서 단일 구조체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="11876e00e55507ddc1f33effa9a28d5147b077b6" translate="yes" xml:space="preserve">
          <source>Fetches all entries from the data store matching the given query</source>
          <target state="translated">주어진 쿼리와 일치하는 데이터 저장소에서 모든 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d5e5f6e8487bddc32e7596312ed1bb5dac35bd0a" translate="yes" xml:space="preserve">
          <source>Fetches all entries from the data store matching the given query.</source>
          <target state="translated">주어진 쿼리와 일치하는 데이터 저장소에서 모든 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3163fd5d81253261c2a50f52a695753603eb3406" translate="yes" xml:space="preserve">
          <source>Fetches cookies from the request headers</source>
          <target state="translated">요청 헤더에서 쿠키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0fe8d31a288e49b7e5cacce395d79fb5e4019e40" translate="yes" xml:space="preserve">
          <source>Fetches cookies from the request headers.</source>
          <target state="translated">요청 헤더에서 쿠키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="64380f0b804c02ac2677f51e3be474a17762a74b" translate="yes" xml:space="preserve">
          <source>Fetches query parameters from the query string</source>
          <target state="translated">쿼리 문자열에서 쿼리 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="39f3908de6fa352816ba9add06ec6c62e6ec9216" translate="yes" xml:space="preserve">
          <source>Fetches query parameters from the query string.</source>
          <target state="translated">쿼리 문자열에서 쿼리 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03d548c192ce1d24785783d7cd261cf87725704e" translate="yes" xml:space="preserve">
          <source>Fetches the flash storage</source>
          <target state="translated">플래시 스토리지를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="0d58eda1295145111b598fd2ee9110335edd72a9" translate="yes" xml:space="preserve">
          <source>Fetches the flash storage.</source>
          <target state="translated">플래시 스토리지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="faff5731b0098ef6d06e0e3b0ab84e1f24767239" translate="yes" xml:space="preserve">
          <source>Fetches the given field from changes or from the data</source>
          <target state="translated">변경 또는 데이터에서 지정된 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="00c47ed90a14976a1fe975f63cadebf282fe500b" translate="yes" xml:space="preserve">
          <source>Fetches the given field from changes or from the data.</source>
          <target state="translated">변경 또는 데이터에서 지정된 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="274968e4217f4aac81cf7e7d092480224b04e65a" translate="yes" xml:space="preserve">
          <source>Fetches the session from the session store. Will also fetch cookies</source>
          <target state="translated">세션 저장소에서 세션을 가져옵니다. 쿠키도 가져옵니다</target>
        </trans-unit>
        <trans-unit id="0b70c54cb87368611ee01ded3dee3728ea2684c7" translate="yes" xml:space="preserve">
          <source>Fetches the session from the session store. Will also fetch cookies.</source>
          <target state="translated">세션 저장소에서 세션을 가져옵니다. 쿠키도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0eb0f2ebbd898fe11ee1adea5bfdeebe9c932ccf" translate="yes" xml:space="preserve">
          <source>Fetching Presence Information</source>
          <target state="translated">현재 상태 정보 가져 오기</target>
        </trans-unit>
        <trans-unit id="b7725b2aa5514d3fb80276bbee807899c2709959" translate="yes" xml:space="preserve">
          <source>Ff there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null.</source>
          <target state="translated">그러한 행이 없으면 대신 기본값을 리턴하십시오 (값과 유형이 같아야 함). 오프셋과 기본값은 현재 행과 관련하여 평가됩니다. 생략하면 오프셋의 기본값은 1이고 기본값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="9f345d16da1171009c2d07d7e162059e89a99f42" translate="yes" xml:space="preserve">
          <source>Fields that are not present in the schema (or &lt;code&gt;types&lt;/code&gt; map) are ignored. If any of the values has invalid type, an error is raised.</source>
          <target state="translated">스키마 (또는 &lt;code&gt;types&lt;/code&gt; 맵)에 없는 필드 는 무시됩니다. 값이 유효하지 않은 유형 인 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f315ee9e3108a80c179abb06fe33569d756f7ff5" translate="yes" xml:space="preserve">
          <source>File handling</source>
          <target state="translated">파일 처리</target>
        </trans-unit>
        <trans-unit id="b563507a845353e1d9b91b6064b7fe3ba43015a7" translate="yes" xml:space="preserve">
          <source>Filtering associations</source>
          <target state="translated">필터링 연관</target>
        </trans-unit>
        <trans-unit id="7dcc155505178bbe138e3135c40148f03651670f" translate="yes" xml:space="preserve">
          <source>Filters out those present on downed replicas.</source>
          <target state="translated">다운 된 복제본에있는 항목을 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="8e9555e0facd6e903d9ec04caa3ca1e02ec43549" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;options&lt;/code&gt; is a keyword list of options given to the &lt;code&gt;Repo&lt;/code&gt; operation that triggered the adapter call. Any option is allowed, as this is a mechanism to allow users of Ecto to customize how the adapter behaves per operation.</source>
          <target state="translated">마지막으로 &lt;code&gt;options&lt;/code&gt; 는 어댑터 호출을 트리거 한 &lt;code&gt;Repo&lt;/code&gt; 작업에 제공된 옵션의 키워드 목록입니다 . 이것은 Ecto 사용자가 어댑터가 작업별로 작동하는 방식을 사용자 정의 할 수 있도록하는 메커니즘이므로 모든 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2346c7af5d6980b8986c812d4411f43cd6d5d34" translate="yes" xml:space="preserve">
          <source>Finally, Phoenix ships with a &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt; task that nicely formats all routes in a given router. We can use it to verify all routes included in the router above:</source>
          <target state="translated">마지막으로 Phoenix 는 주어진 라우터의 모든 경로를 멋지게 형식화 하는 &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt; &lt;code&gt;mix phx.routes&lt;/code&gt; &lt;/a&gt; 작업을 제공합니다. 위의 라우터에 포함 된 모든 경로를 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5a408906e0f613586519b719c8fb8988afdde0" translate="yes" xml:space="preserve">
          <source>Finally, Phoenix ships with a &lt;code&gt;mix phx.routes&lt;/code&gt; task that nicely formats all routes in a given router. We can use it to verify all routes included in the router above:</source>
          <target state="translated">마지막으로 Phoenix 는 주어진 라우터의 모든 경로를 멋지게 포맷 하는 &lt;code&gt;mix phx.routes&lt;/code&gt; 작업 과 함께 제공됩니다. 이를 사용하여 위 라우터에 포함 된 모든 경로를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f99f4376e4980be4bbc9016c10d32de768a5d866" translate="yes" xml:space="preserve">
          <source>Finally, a diff of presence join and leave events will be sent to the client as they happen in real-time with the &quot;presence_diff&quot; event. The diff structure will be a map of &lt;code&gt;:joins&lt;/code&gt; and &lt;code&gt;:leaves&lt;/code&gt; of the form:</source>
          <target state="translated">마지막으로, &quot;presence_diff&quot;이벤트와 함께 실시간으로 발생하는 상태 차이 참여 및 탈퇴 이벤트가 클라이언트에 전송됩니다. diff 구조는 다음 과 같은 형식 의 &lt;code&gt;:joins&lt;/code&gt; 및 &lt;code&gt;:leaves&lt;/code&gt; 의 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="ef21b0ab2a337cbb5d3cb905bb5c0c2daaee7d04" translate="yes" xml:space="preserve">
          <source>Finally, a diff of presence join and leave events will be sent to the client as they happen in real-time with the &amp;ldquo;presence_diff&amp;rdquo; event. The diff structure will be a map of &lt;code&gt;:joins&lt;/code&gt; and &lt;code&gt;:leaves&lt;/code&gt; of the form:</source>
          <target state="translated">마지막으로&amp;ldquo;presence_diff&amp;rdquo;이벤트와 함께 실시간으로 발생하는 현재 상태 참가 및 휴가 이벤트 차이가 클라이언트로 전송됩니다. diff 구조는 &lt;code&gt;:joins&lt;/code&gt; 및 &lt;code&gt;:leaves&lt;/code&gt; 형식 의 맵 이됩니다.</target>
        </trans-unit>
        <trans-unit id="8d783e0fbd65008c8d3daf828f44798d62b28819" translate="yes" xml:space="preserve">
          <source>Finally, a general &lt;code&gt;match&lt;/code&gt; function is also supported:</source>
          <target state="translated">마지막으로 일반 &lt;code&gt;match&lt;/code&gt; 기능도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="371bdbfa9b024c89cc2bf0370822b67c2b7ebd0c" translate="yes" xml:space="preserve">
          <source>Finally, every time a message is pushed to the channel, a reference is returned. We can use this reference to assert a particular reply was sent from the server:</source>
          <target state="translated">마지막으로, 메시지가 채널로 푸시 될 때마다 참조가 리턴됩니다. 이 참조를 사용하여 서버에서 특정 응답을 보냈다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fba42c006127501a9d4eee7b63ae677c340c271" translate="yes" xml:space="preserve">
          <source>Finally, for the simple cases, preloading can also be done after a collection was fetched:</source>
          <target state="translated">마지막으로 간단한 경우 컬렉션을 가져온 후 사전로드를 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c2275b05254f6a0d55c69f791dee63e59b770f" translate="yes" xml:space="preserve">
          <source>Finally, if the values are a list or a map, we use the keys for grouping:</source>
          <target state="translated">마지막으로 값이 목록 또는 맵이면 그룹화에 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be70f9966d578a92f0d14739730beade1450e72e" translate="yes" xml:space="preserve">
          <source>Finally, if you need an escape hatch, Ecto provides fragments (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) to inject SQL (and non-SQL) fragments into queries. Also, most adapters provide direct APIs for queries, like &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt;, allowing developers to completely bypass Ecto queries.</source>
          <target state="translated">마지막으로 이스케이프 해치가 필요한 경우 Ecto는 조각 ( &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt; 참조 )을 제공하여 SQL (및 비 SQL) 조각을 쿼리에 삽입합니다. 또한 대부분의 어댑터는 &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt; 와 같은 쿼리에 대한 직접 API를 제공 하므로 개발자가 Ecto 쿼리를 완전히 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5211a28dd43f79dbabf7887d2a6fa7e2af5965c5" translate="yes" xml:space="preserve">
          <source>Finally, schemas can also have virtual fields by passing the &lt;code&gt;virtual: true&lt;/code&gt; option. These fields are not persisted to the database and can optionally not be type checked by declaring type &lt;code&gt;:any&lt;/code&gt;.</source>
          <target state="translated">마지막으로 스키마에는 &lt;code&gt;virtual: true&lt;/code&gt; 옵션 을 전달하여 가상 필드를 가질 수도 있습니다 . 이 필드는 데이터베이스에 유지되지 않으며 type &lt;code&gt;:any&lt;/code&gt; 를 선언하여 선택적으로 유형을 검사 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c3c3d8b92a64a4d3df3c071e9b5af6207dda5c2c" translate="yes" xml:space="preserve">
          <source>Finally, we recommend developers to invoke &lt;a href=&quot;#delete_csrf_token/0&quot;&gt;&lt;code&gt;delete_csrf_token/0&lt;/code&gt;&lt;/a&gt; every time after they log a user in, to avoid CSRF fixation attacks.</source>
          <target state="translated">마지막으로 개발자는 CSRF 수정 공격을 방지하기 위해 사용자가 로그인 한 후 매번 &lt;a href=&quot;#delete_csrf_token/0&quot;&gt; &lt;code&gt;delete_csrf_token/0&lt;/code&gt; &lt;/a&gt; 을 호출 할 것을 권장 합니다 .</target>
        </trans-unit>
        <trans-unit id="500092afa233e9b7ad3757e9635614d60d69c53f" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s fetch the post with all existing comments:</source>
          <target state="translated">먼저 기존의 모든 의견이 포함 된 게시물을 가져 오겠습니다.</target>
        </trans-unit>
        <trans-unit id="a5e339d4995b9e83dffba1422acecfda7bc67bf4" translate="yes" xml:space="preserve">
          <source>First, let's fetch the post with all existing comments:</source>
          <target state="translated">먼저 기존의 모든 댓글이있는 게시물을 가져 오겠습니다.</target>
        </trans-unit>
        <trans-unit id="db0a693e52d129229b723bca090f9d3722799b28" translate="yes" xml:space="preserve">
          <source>Floats: &lt;code&gt;1.0&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt;, &lt;code&gt;3.0&lt;/code&gt;</source>
          <target state="translated">수레 : &lt;code&gt;1.0&lt;/code&gt; , &lt;code&gt;2.0&lt;/code&gt; , &lt;code&gt;3.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d702e59f6da409d30f01ac24ca19a1531facd89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;has_many :through&lt;/code&gt; - it behaves similarly to a regular &lt;code&gt;has_many&lt;/code&gt; but note that the IDs received are of the last association. Imagine for example a post has many comments and each comment has an author. Therefore, a post may have many comments_authors, written as &lt;code&gt;has_many :comments_authors, through: [:comments, :author]&lt;/code&gt;. When preloading authors with a custom function via &lt;code&gt;:comments_authors&lt;/code&gt;, the function will receive the IDs of the authors as the last step</source>
          <target state="translated">들어 &lt;code&gt;has_many :through&lt;/code&gt; - 그것은 정기적와 유사하게 작동 &lt;code&gt;has_many&lt;/code&gt; 하지만 참고받은 ID는 마지막으로 협회의 것을. 예를 들어 게시물에 많은 댓글이 있고 각 댓글에 작성자가 있다고 상상해보세요. 따라서 게시물에는 &lt;code&gt;has_many :comments_authors, through: [:comments, :author]&lt;/code&gt; 로 작성된 comments_authors가 많이있을 수 있습니다 . &lt;code&gt;:comments_authors&lt;/code&gt; 를 통해 사용자 정의 함수로 작성자를 미리로드 할 때 함수는 마지막 단계로 작성자의 ID를받습니다.</target>
        </trans-unit>
        <trans-unit id="ad82d88c263f197ac3ab09327378400e810ffc46" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;has_many :through&lt;/code&gt; - it behaves similarly to a regular &lt;code&gt;has_many&lt;/code&gt; but note that the IDs received are the ones from the closest parent and not the furthest one. Imagine for example a post has many comments and each comment has an author. Therefore, a post may have many comments_authors, written as &lt;code&gt;has_many :comments_authors, through: [:comments, :author]&lt;/code&gt;. When preloading authors with a custom function via &lt;code&gt;:comments_authors&lt;/code&gt;, the function will receive the IDs of the comments and not of the posts. That&amp;rsquo;s because through associations are still loaded step by step</source>
          <target state="translated">들어 &lt;code&gt;has_many :through&lt;/code&gt; - 그것은 정기적와 유사하게 작동 &lt;code&gt;has_many&lt;/code&gt; 받은 ID가 가장 가까운 부모로부터 사람이 아니라 멀리 한 것을하지만 참고. 예를 들어 게시물에 많은 댓글이 있고 각 댓글에 작성자가 있다고 가정하십시오. 따라서 게시물에는 &lt;code&gt;has_many :comments_authors, through: [:comments, :author]&lt;/code&gt; 로 작성된 여러 개의 comment_authors 가있을 수 있습니다 . &lt;code&gt;:comments_authors&lt;/code&gt; 를 통해 사용자 정의 함수를 사용하여 작성자를 사전로드 하면 함수는 게시물이 아닌 주석의 ID를 수신합니다. 연결을 통해 단계별로 계속로드되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ffb76a65010dd96e5304011352d8d89308a77ae9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;has_many&lt;/code&gt; and &lt;code&gt;belongs_to&lt;/code&gt; - the function receives the IDs of the parent association and it must return a list of maps or structs with the associated entries. The associated map/struct must contain the &quot;foreign_key&quot; field. For example, if a post has many comments, when preloading the comments with a custom function, the function will receive a list of &quot;post_ids&quot; as argument and it must return maps or structs representing the comments. The maps/structs must include the &lt;code&gt;:post_id&lt;/code&gt; field</source>
          <target state="translated">대한 &lt;code&gt;has_many&lt;/code&gt; 와 &lt;code&gt;belongs_to&lt;/code&gt; - 함수가 부모 협회의 ID를 수신하고 관련 항목이지도 또는 구조체의 목록을 반환해야합니다. 연결된 맵 / 구조체에는 &quot;foreign_key&quot;필드가 있어야합니다. 예를 들어 게시물에 댓글이 많은 경우 사용자 정의 함수로 댓글을 미리로드 할 때 함수는 &quot;post_ids&quot;목록을 인수로 수신하고 댓글을 나타내는 맵 또는 구조체를 반환해야합니다. 맵 / &lt;code&gt;:post_id&lt;/code&gt; 에는 : post_id 필드 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="63600b6a2d1ec5af0fc9e5cad2bc261fd1af2888" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;has_many&lt;/code&gt; and &lt;code&gt;belongs_to&lt;/code&gt; - the function receives the IDs of the parent association and it must return a list of maps or structs with the associated entries. The associated map/struct must contain the &amp;ldquo;foreign_key&amp;rdquo; field. For example, if a post has many comments, when preloading the comments with a custom function, the function will receive a list of &amp;ldquo;post_ids&amp;rdquo; as argument and it must return maps or structs representing the comments. The maps/structs must include the &lt;code&gt;:post_id&lt;/code&gt; field</source>
          <target state="translated">대한 &lt;code&gt;has_many&lt;/code&gt; 와 &lt;code&gt;belongs_to&lt;/code&gt; - 함수가 부모 협회의 ID를 수신하고 관련 항목이지도 또는 구조체의 목록을 반환해야합니다. 연관된 맵 / 구조는 &quot;foreign_key&quot;필드를 포함해야합니다. 예를 들어, 게시물에 주석이 많은 경우 사용자 정의 함수를 사용하여 주석을 미리로드하면 함수는 &quot;post_ids&quot;목록을 인수로 받고 주석을 나타내는 맵 또는 구조체를 반환해야합니다. 지도 / 구조는 &lt;code&gt;:post_id&lt;/code&gt; 필드를 포함해야 합니다</target>
        </trans-unit>
        <trans-unit id="c8a4d730c3f703463989c4fcb32605397783f881" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;many_to_many&lt;/code&gt; - the function receives the IDs of the parent association and it must return a tuple with the parent id as first element and the association map or struct as second. For example, if a post has many tags, when preloading the tags with a custom function, the function will receive a list of &quot;post_ids&quot; as argument and it must return a tuple in the format of &lt;code&gt;{post_id, tag}&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;many_to_many&lt;/code&gt; - 함수는 상위 협회의 ID를 수신하고, 우선 소자 및 제와 연관 맵 또는 구조체로서 상위 ID와 튜플을 반환해야한다. 예를 들어 게시물에 태그가 많은 경우 사용자 정의 함수로 태그를 미리로드 할 때 함수는 &quot;post_ids&quot;목록을 인수로 받고 &lt;code&gt;{post_id, tag}&lt;/code&gt; 형식의 튜플을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="354d0273d07d15de05f231450470ee0eae6bac34" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;many_to_many&lt;/code&gt; - the function receives the IDs of the parent association and it must return a tuple with the parent id as first element and the association map or struct as second. For example, if a post has many tags, when preloading the tags with a custom function, the function will receive a list of &amp;ldquo;post_ids&amp;rdquo; as argument and it must return a tuple in the format of &lt;code&gt;{post_id, tag}&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;many_to_many&lt;/code&gt; - 함수는 상위 협회의 ID를 수신하고, 우선 소자 및 제와 연관 맵 또는 구조체로서 상위 ID와 튜플을 반환해야한다. 예를 들어 게시물에 많은 태그가있는 경우 사용자 정의 함수를 사용하여 태그를 미리로드하면 함수는 &quot;post_ids&quot;목록을 인수로 받고 &lt;code&gt;{post_id, tag}&lt;/code&gt; 형식으로 튜플을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab02655daa3427bb066f0ca4f1a125c696573e23" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;{:array, CustomType}&lt;/code&gt; or &lt;code&gt;{:map, CustomType}&lt;/code&gt; the returned keyword list will be erased and the default error will be shown.</source>
          <target state="translated">들어 &lt;code&gt;{:array, CustomType}&lt;/code&gt; 또는 &lt;code&gt;{:map, CustomType}&lt;/code&gt; 반환 된 키워드 목록이 삭제되고 기본 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7cc044c113cf8e5e48b53bc0a83f10daddc97b" translate="yes" xml:space="preserve">
          <source>For a complete guide on HTTPS and best pratices, see &lt;a href=&quot;https&quot;&gt;our Plug HTTPS Guide&lt;/a&gt;.</source>
          <target state="translated">HTTPS 및 모범 사례에 대한 전체 가이드는 &lt;a href=&quot;https&quot;&gt;플러그 HTTPS 가이드를&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="20523aba079cc2fef42cacf60a4081c3373e6471" translate="yes" xml:space="preserve">
          <source>For a given topic, the client may only establish a single channel subscription. When attempting to create a duplicate subscription, &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; will close the existing channel, log a warning, and spawn a new channel for the topic. When sending the &lt;code&gt;&quot;phx_close&quot;&lt;/code&gt; event from the closed channel, the message will contain the &lt;code&gt;ref&lt;/code&gt; the client sent when joining. This allows the client to uniquely identify &lt;code&gt;&quot;phx_close&quot;&lt;/code&gt; and &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; messages when force-closing a channel on duplicate joins.</source>
          <target state="translated">주어진 주제에 대해 클라이언트는 단일 채널 구독 만 설정할 수 있습니다. 중복 구독을 만들려고 할 때 &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 는 기존 채널을 닫고 경고를 기록하며 주제에 대한 새 채널을 생성합니다. 송신 할 때 &lt;code&gt;&quot;phx_close&quot;&lt;/code&gt; 닫힌 채널에서 이벤트를 메시지가 포함됩니다 &lt;code&gt;ref&lt;/code&gt; 에 가입 할 때 클라이언트가 전송합니다. 이를 통해 클라이언트 는 중복 조인에서 채널을 강제 종료 할 때 &lt;code&gt;&quot;phx_close&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; 메시지 를 고유하게 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bade354c9ba82812949a02768fabd726d9aaec1" translate="yes" xml:space="preserve">
          <source>For a keyword query the &lt;code&gt;:join&lt;/code&gt; keyword can be changed to &lt;code&gt;:inner_join&lt;/code&gt;, &lt;code&gt;:left_join&lt;/code&gt;, &lt;code&gt;:right_join&lt;/code&gt;, &lt;code&gt;:cross_join&lt;/code&gt;, &lt;code&gt;:full_join&lt;/code&gt;, &lt;code&gt;:inner_lateral_join&lt;/code&gt; or &lt;code&gt;:left_lateral_join&lt;/code&gt;. &lt;code&gt;:join&lt;/code&gt; is equivalent to &lt;code&gt;:inner_join&lt;/code&gt;.</source>
          <target state="translated">키워드 쿼리의 경우 &lt;code&gt;:join&lt;/code&gt; 키워드를 &lt;code&gt;:inner_join&lt;/code&gt; , &lt;code&gt;:left_join&lt;/code&gt; , &lt;code&gt;:right_join&lt;/code&gt; , &lt;code&gt;:cross_join&lt;/code&gt; , &lt;code&gt;:full_join&lt;/code&gt; , &lt;code&gt;:inner_lateral_join&lt;/code&gt; 또는 &lt;code&gt;:left_lateral_join&lt;/code&gt; 으로 변경할 수 있습니다. &lt;code&gt;:join&lt;/code&gt; 은 &lt;code&gt;:inner_join&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="13fa3b4c889e783b80aba2740c5d064e7244dcf1" translate="yes" xml:space="preserve">
          <source>For a post to match in the above example it must be visited at least as much as the average post in all categories.</source>
          <target state="translated">위의 예에서 일치하는 게시물의 경우 최소한 모든 카테고리의 평균 게시물만큼 방문해야합니다.</target>
        </trans-unit>
        <trans-unit id="092362cd5c107f7d58b5a88b716fd6f320a6243c" translate="yes" xml:space="preserve">
          <source>For a regular application:</source>
          <target state="translated">일반 신청의 경우 :</target>
        </trans-unit>
        <trans-unit id="673a530e87febb813a7a46d378a8f00c25c57993" translate="yes" xml:space="preserve">
          <source>For actual upserts, where an insert or update may happen, the situation is slightly more complex, as the database does not actually inform us if an insert or update happened. Let&amp;rsquo;s insert a post with the same title but use a query to update the body column in case of conflicts:</source>
          <target state="translated">삽입 또는 업데이트가 발생할 수있는 실제 upsert의 경우 데이터베이스가 삽입 또는 업데이트가 발생했는지 실제로 알려주지 않기 때문에 상황이 약간 더 복잡합니다. 제목이 같은 게시물을 삽입하지만 충돌이있을 경우 쿼리를 사용하여 본문 열을 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="32ff300c68a5dfad5204cf92bbf5f1e21f8c1612" translate="yes" xml:space="preserve">
          <source>For actual upserts, where an insert or update may happen, the situation is slightly more complex, as the database does not actually inform us if an insert or update happened. Let's insert a post with the same title but use a query to update the body column in case of conflicts:</source>
          <target state="translated">삽입 또는 업데이트가 발생할 수있는 실제 upsert의 경우 데이터베이스가 삽입 또는 업데이트가 발생했는지 실제로 알려주지 않기 때문에 상황이 약간 더 복잡합니다. 제목이 같은 게시물을 삽입하되 충돌이 발생하는 경우 쿼리를 사용하여 본문 열을 업데이트 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7a13facc0573c1f5cd17a8b774fa022f5c62da50" translate="yes" xml:space="preserve">
          <source>For an umbrella application:</source>
          <target state="translated">우산 용도 :</target>
        </trans-unit>
        <trans-unit id="962775a35a8e3effc603b8ed3f7045d2def77954" translate="yes" xml:space="preserve">
          <source>For associations with cardinality one, &lt;code&gt;nil&lt;/code&gt; can be used to remove the existing entry. For associations with many entries, an empty list may be given instead.</source>
          <target state="translated">카디널리티 1과의 연관의 경우 &lt;code&gt;nil&lt;/code&gt; 을 사용하여 기존 항목을 제거 할 수 있습니다. 많은 항목이있는 연결의 경우 빈 목록이 대신 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d675f9e27fb9e8e0ca2759e0f26a064b102571e" translate="yes" xml:space="preserve">
          <source>For both suites we&amp;rsquo;ve specified ceritifcate curves secp256r1, ecp384r1 and secp521r1. Since OWASP doesn&amp;rsquo;t perscribe curves we&amp;rsquo;ve based the selection on the following Mozilla recommendations: https://wiki.mozilla.org/Security/Server_Side_TLS#Cipher_names_correspondence_table</source>
          <target state="translated">두 제품군 모두 ceritifcate 곡선 인 secp256r1, ecp384r1 및 secp521r1을 지정했습니다. OWASP는 곡선을 정의하지 않으므로 다음 Mozilla 권장 사항을 기반으로 선택했습니다. https://wiki.mozilla.org/Security/Server_Side_TLS#Cipher_names_correspondence_table</target>
        </trans-unit>
        <trans-unit id="eb99d644dfcf16338551e4823aea9b3594dc6c41" translate="yes" xml:space="preserve">
          <source>For both suites we've specified certificate curves secp256r1, ecp384r1 and secp521r1. Since OWASP doesn't prescribe curves we've based the selection on &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS#Cipher_names_correspondence_table&quot;&gt;Mozilla's recommendations&lt;/a&gt;</source>
          <target state="translated">두 제품군에 대해 인증서 곡선 secp256r1, ecp384r1 및 secp521r1을 지정했습니다. OWASP는 곡선을 규정하지 않기 때문에 &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS#Cipher_names_correspondence_table&quot;&gt;Mozilla의 권장 사항을&lt;/a&gt; 기반으로 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="3f6bbe3b038afe3e8f9ff34c83ffef5985f40d11" translate="yes" xml:space="preserve">
          <source>For calendar types with and without microseconds, the precision is enforced when persisting to the DB. For example, casting &lt;code&gt;~T[09:00:00]&lt;/code&gt; as &lt;code&gt;:time_usec&lt;/code&gt; will succeed and result in &lt;code&gt;~T[09:00:00.000000]&lt;/code&gt;, but persisting a type without microseconds as &lt;code&gt;:time_usec&lt;/code&gt; will fail. Similarly, casting &lt;code&gt;~T[09:00:00.000000]&lt;/code&gt; as &lt;code&gt;:time&lt;/code&gt; will succeed, but persisting will not. This is the same behaviour as seen in other types, where casting has to be done explicitly and is never performed implicitly when loading from or dumping to the database.</source>
          <target state="translated">마이크로 초가 있거나없는 캘린더 유형의 경우 DB에 지속될 때 정밀도가 적용됩니다. 예를 들어, &lt;code&gt;~T[09:00:00]&lt;/code&gt; 을 &lt;code&gt;:time_usec&lt;/code&gt; 로 캐스팅 하면 &lt;code&gt;~T[09:00:00.000000]&lt;/code&gt; 으로 성공하지만 &lt;code&gt;:time_usec&lt;/code&gt; 로 마이크로 초없이 유형을 유지 하면 실패합니다. 마찬가지로 &lt;code&gt;~T[09:00:00.000000]&lt;/code&gt; 을 &lt;code&gt;:time&lt;/code&gt; 으로 캐스팅 하면 지속되지만 지속되지는 않습니다. 이는 다른 유형에서 볼 수있는 것과 같은 동작으로, 캐스팅을 명시 적으로 수행해야하며 데이터베이스에서로드하거나 덤프 할 때 암시 적으로 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2973a602c365a52563d58be264616b79cb7c18bd" translate="yes" xml:space="preserve">
          <source>For convenience, trims whitespace at the end of the token. Returns &lt;code&gt;false&lt;/code&gt; if the token is invalid.</source>
          <target state="translated">편의를 위해 토큰 끝에 공백을 제거합니다. 토큰이 유효하지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4f08b434d1b24246ad947903380678d6f4a6b89" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;https://hexdocs.pm/telemetry/&quot;&gt;the telemetry documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://hexdocs.pm/telemetry/&quot;&gt;은 원격 분석 문서를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="514d7ef5662d3b01249f86c0c31d4d15ac5d464f" translate="yes" xml:space="preserve">
          <source>For dynamically configuring the endpoint, such as loading data from environment variables or configuration files, Phoenix invokes the &lt;code&gt;init/2&lt;/code&gt; callback on the endpoint, passing a &lt;code&gt;:supervivsor&lt;/code&gt; atom as first argument and the endpoint configuration as second.</source>
          <target state="translated">환경 변수 또는 구성 파일에서 데이터로드와 같은 엔드 포인트를 동적으로 구성하기 위해 Phoenix는 엔드 포인트 에서 &lt;code&gt;init/2&lt;/code&gt; 콜백을 호출하여 &lt;code&gt;:supervivsor&lt;/code&gt; atom을 첫 번째 인수로, 엔드 포인트 구성을 두 번째로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2f8c675d666ad72551f01bb83bb87c5a8e014d43" translate="yes" xml:space="preserve">
          <source>For dynamically configuring the endpoint, such as loading data from environment variables or configuration files, Phoenix invokes the &lt;code&gt;init/2&lt;/code&gt; callback on the endpoint, passing the atom &lt;code&gt;:supervisor&lt;/code&gt; as the first argument and the endpoint configuration as second.</source>
          <target state="translated">환경 변수 또는 구성 파일에서 데이터를로드하는 것과 같이 엔드 포인트를 동적으로 구성하기 위해 Phoenix는 엔드 포인트 에서 &lt;code&gt;init/2&lt;/code&gt; 콜백을 호출 하여 atom &lt;code&gt;:supervisor&lt;/code&gt; 를 첫 번째 인수로 전달하고 엔드 포인트 구성을 두 번째로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="83f8140a10617f209a9bbd2bf22394889c256c68" translate="yes" xml:space="preserve">
          <source>For each file under the given input path, Phoenix will generate a digest and also compress in &lt;code&gt;.gz&lt;/code&gt; format. The filename and its digest will be used to generate the cache manifest file. It also avoids duplication, checking for already digested files.</source>
          <target state="translated">지정된 입력 경로 아래의 각 파일에 대해 Phoenix는 다이제스트를 생성하고 &lt;code&gt;.gz&lt;/code&gt; 형식 으로 압축 합니다. 파일 이름과 다이제스트는 캐시 매니페스트 파일을 생성하는 데 사용됩니다. 또한 이미 다이제스트 된 파일을 검사하여 중복을 피합니다.</target>
        </trans-unit>
        <trans-unit id="18d9a991082460c8bd6c583a8988c97a924a27a3" translate="yes" xml:space="preserve">
          <source>For each message received from the client, the transport must call &lt;a href=&quot;#c:handle_in/2&quot;&gt;&lt;code&gt;handle_in/2&lt;/code&gt;&lt;/a&gt; on the socket. For each informational message the transport receives, it should call &lt;a href=&quot;#c:handle_info/2&quot;&gt;&lt;code&gt;handle_info/2&lt;/code&gt;&lt;/a&gt; on the socket.</source>
          <target state="translated">클라이언트로부터 수신 된 각 메시지에 대해 전송은 소켓에서 &lt;a href=&quot;#c:handle_in/2&quot;&gt; &lt;code&gt;handle_in/2&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 . 전송이 수신하는 각 정보 메시지 에 대해 소켓에서 &lt;a href=&quot;#c:handle_info/2&quot;&gt; &lt;code&gt;handle_info/2&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="447756883e51de19d636b53e26dcc7baf4d56194" translate="yes" xml:space="preserve">
          <source>For each request, Phoenix checks if any of the modules previously compiled requires recompilation via &lt;code&gt;__phoenix_recompile__?/0&lt;/code&gt; and then calls &lt;code&gt;mix compile&lt;/code&gt; for sources exclusive to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">각 요청에 대해 Phoenix는 이전에 컴파일 된 모듈 중 어느 것이 &lt;code&gt;__phoenix_recompile__?/0&lt;/code&gt; 통해 재 컴파일 해야하는지 확인한 다음 &lt;code&gt;web&lt;/code&gt; 디렉토리 전용 소스에 대해 &lt;code&gt;mix compile&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d6fc0dc53e4e25ba42c0881b47aaaa466ec949e0" translate="yes" xml:space="preserve">
          <source>For each request, Phoenix goes through all modules and checks if any of them implement a &lt;code&gt;__phoenix_recompile__?/0&lt;/code&gt; function. If they do and it returns true, the module source file is touched, forcing it to be recompiled. For this functionality to work, Phoenix requires you to add the &lt;code&gt;:phoenix&lt;/code&gt; compiler to your list of compilers:</source>
          <target state="translated">각 요청에 대해 Phoenix는 모든 모듈을 살펴보고 그중에서 &lt;code&gt;__phoenix_recompile__?/0&lt;/code&gt; 함수를 구현하는지 확인 합니다. 그렇게하여 true를 반환하면 모듈 소스 파일이 터치되어 다시 컴파일됩니다. 이 기능이 작동하려면 Phoenix는 컴파일러 목록에 &lt;code&gt;:phoenix&lt;/code&gt; 컴파일러를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="358da0baaab9435646b120f9050f3589abaf1432" translate="yes" xml:space="preserve">
          <source>For encoding and decoding of embeds, please read the docs for &lt;a href=&quot;#embeds_one/3&quot;&gt;&lt;code&gt;embeds_one/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임베드의 인코딩 및 디코딩에 대해서는 &lt;a href=&quot;#embeds_one/3&quot;&gt; &lt;code&gt;embeds_one/3&lt;/code&gt; &lt;/a&gt; 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f485276f616bd26adc829af0ee47c57b85d1ff61" translate="yes" xml:space="preserve">
          <source>For example, PostgreSQL will store embeds on top of JSONB columns, which means types in embedded schemas won&amp;rsquo;t go through the usual dump-&amp;gt;DB-&amp;gt;load cycle but rather encode-&amp;gt;DB-&amp;gt;decode-&amp;gt;cast. This means that, when using embedded schemas with databases like PG or MySQL, make sure all of your types can be JSON encoded/decoded correctly. Ecto provides this guarantee for all built-in types.</source>
          <target state="translated">예를 들어 PostgreSQL은 JSONB 열 위에 임베드를 저장합니다. 즉, 임베드 된 스키마의 유형은 일반적인 덤프-&amp;gt; DB-&amp;gt;로드 사이클을 거치지 않고 인 코드-&amp;gt; DB-&amp;gt; 디코딩-&amp;gt; 캐스트를 거치게됩니다. 즉, PG 또는 MySQL과 같은 데이터베이스에 포함 된 스키마를 사용할 때는 모든 유형을 JSON으로 인코딩 / 디코딩 할 수 있어야합니다. Ecto는 모든 내장 유형에 대해이 보증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="99769121a189d81523d323cd7f2adb019f95f488" translate="yes" xml:space="preserve">
          <source>For example, PostgreSQL will store embeds on top of JSONB columns, which means types in embedded schemas won't go through the usual dump-&amp;gt;DB-&amp;gt;load cycle but rather encode-&amp;gt;DB-&amp;gt;decode-&amp;gt;cast. This means that, when using embedded schemas with databases like PG or MySQL, make sure all of your types can be JSON encoded/decoded correctly. Ecto provides this guarantee for all built-in types.</source>
          <target state="translated">예를 들어 PostgreSQL은 JSONB 열 위에 임베딩을 저장합니다. 즉, 임베디드 스키마의 유형은 일반적인 덤프-&amp;gt; DB-&amp;gt;로드주기를 거치지 않고 인코딩-&amp;gt; DB-&amp;gt; 디코드-&amp;gt; 캐스트를 거치게됩니다. 즉, PG 또는 MySQL과 같은 데이터베이스에 포함 된 스키마를 사용할 때 모든 유형이 JSON으로 인코딩 / 디코딩 될 수 있는지 확인합니다. Ecto는 모든 내장 유형에 대해 이러한 보증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="62d7117a3b1a1721c1d5300823fd83a08ec0eb56" translate="yes" xml:space="preserve">
          <source>For example, a developer using MySQL may write:</source>
          <target state="translated">예를 들어 MySQL을 사용하는 개발자는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c337aa19ed63d216ce92de1e0fb06effb6d7cd3" translate="yes" xml:space="preserve">
          <source>For example, assuming the &lt;code&gt;conditions&lt;/code&gt; variable defined in the previous section, the following is forbidden because it is not at the root of a &lt;code&gt;where&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 이전 섹션에서 정의 된 &lt;code&gt;conditions&lt;/code&gt; 변수를 가정하면 다음은 &lt;code&gt;where&lt;/code&gt; 의 루트에 있지 않기 때문에 금지됩니다 .</target>
        </trans-unit>
        <trans-unit id="17b027db9ca188624206f2420c11e61eb142d7dd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;:on_conflict&lt;/code&gt; is set to &lt;code&gt;:nothing&lt;/code&gt;, Postgres will return 0 if no new entry was added while MySQL will still return the amount of entries attempted to be inserted, even if no entry was added. Even worse, if &lt;code&gt;:on_conflict&lt;/code&gt; is query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query.</source>
          <target state="translated">예를 들어, &lt;code&gt;:on_conflict&lt;/code&gt; 로 설정 &lt;code&gt;:nothing&lt;/code&gt; 항목을 삽입 할 시도의 MySQL은 여전히 항목이 추가되지 않은 경우에도, 금액을 반환하면서 새로운 항목이 추가되지 않은 경우, 포스트 그레스는 0을 반환합니다. 더 나쁜 것은 &lt;code&gt;:on_conflict&lt;/code&gt; 가 query 인 경우 MySQL은 시도 된 항목 수와 UPDATE 쿼리로 수정 된 항목 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ad70964b6903a03710c190caf3acb0e49049573" translate="yes" xml:space="preserve">
          <source>For example, if a plug called &lt;code&gt;my_plug&lt;/code&gt; needs to store a &lt;code&gt;:hello&lt;/code&gt; key, it would store it as &lt;code&gt;:my_plug_hello&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;my_plug&lt;/code&gt; 라는 플러그 가 &lt;code&gt;:hello&lt;/code&gt; 키 를 저장 해야하는 경우 &lt;code&gt;:my_plug_hello&lt;/code&gt; 로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="c680c9e8f22ccafd93e44ffae3a885cef74b7437" translate="yes" xml:space="preserve">
          <source>For example, if some plug needs to store a &lt;code&gt;:hello&lt;/code&gt; key, it should do so as &lt;code&gt;:plug_hello&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 일부 플러그가 &lt;code&gt;:hello&lt;/code&gt; 키 를 저장해야하는 경우 &lt;code&gt;:plug_hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b67a51b0929c3bd20516b18e930c9d65453e2f33" translate="yes" xml:space="preserve">
          <source>For example, if you are running your application behind a proxy, the browser will send a request to the proxy with &lt;code&gt;www.example.com&lt;/code&gt; but the proxy will request you using an internal IP. In such cases, it is common for proxies to attach information such as &lt;code&gt;&quot;x-forwarded-host&quot; that contains the original
host.

This may also happen on redirects. If you have a POST request to&lt;/code&gt;foo.example.com&lt;code&gt;that redirects with status&lt;/code&gt;bar.example.com&lt;code&gt;with status 407. The token and
the server will be running on different versions.

You can pass the&lt;/code&gt;:allow_hosts&lt;code&gt;option to control any host that you may want
to allow. The values in&lt;/code&gt;:allow_hosts&lt;code&gt;may either be a full host name or a
host suffix. For example:&lt;/code&gt;[&amp;ldquo;www.example.com&amp;rdquo;, &amp;ldquo;.subdomain.example.com&amp;rdquo;]&lt;code&gt;will allow the exact host of&lt;/code&gt;&amp;rdquo;www.example.com&amp;rdquo;&lt;code&gt;and any host that ends with&lt;/code&gt;&amp;rdquo;.subdomain.example.com&amp;rdquo;&lt;code&gt;.

## Options

  *&lt;/code&gt;:session_key&lt;code&gt;- the name of the key in session to store the token under
  *&lt;/code&gt;:allow_hosts&lt;code&gt;- a list with hosts to allow on cross-host tokens
  *&lt;/code&gt;:with&lt;code&gt;- should be one of&lt;/code&gt;:exception&lt;code&gt;or&lt;/code&gt;:clear_session&lt;code&gt;. Defaults to&lt;/code&gt;:exception&lt;code&gt;.
    *&lt;/code&gt;:exception&lt;code&gt;-  for invalid requests, this plug will raise
    [&lt;/code&gt;Plug.CSRFProtection.InvalidCSRFTokenError&lt;code&gt;](Plug.CSRFProtection.InvalidCSRFTokenError.html).
    *&lt;/code&gt;:clear_session&lt;code&gt;-  for invalid requests, this plug will set an empty
    session for only this request. Also any changes to the session during this
    request will be ignored.

## Disabling

You may disable this plug by doing&lt;/code&gt;Plug.Conn.put_private(conn, :plug_skip_csrf_protection, true)&lt;code&gt;. This was made
available for disabling [&lt;/code&gt;Plug.CSRFProtection&lt;code&gt;](Plug.CSRFProtection.html#content) in tests and not for dynamically
skipping [&lt;/code&gt;Plug.CSRFProtection&lt;code&gt;](Plug.CSRFProtection.html#content) in production code. If you want specific routes to
skip [&lt;/code&gt;Plug.CSRFProtection&lt;code&gt;](Plug.CSRFProtection.html#content), then use a different stack of plugs for that route that
does not include [&lt;/code&gt;Plug.CSRFProtection`](Plug.CSRFProtection.html#content). ## Examples plug Plug.Session, &amp;hellip; plug :fetch_session plug Plug.CSRFProtection</source>
          <target state="translated">예를 들어 프록시 뒤에서 응용 프로그램을 실행하는 경우 브라우저는 &lt;code&gt;www.example.com&lt;/code&gt; 을 사용하여 프록시에 요청을 보내지 만 프록시는 내부 IP를 사용하도록 요청합니다. 이러한 경우 프록시가 &lt;code&gt;&quot;x-forwarded-host&quot; that contains the original host. This may also happen on redirects. If you have a POST request to&lt;/code&gt; 와 같은 정보를 첨부하는 것이 일반적입니다 . 리디렉션에서도 발생할 수 있습니다. &lt;code&gt;with status 407. The token and the server will be running on different versions. You can pass the&lt;/code&gt; &lt;code&gt;that redirects with status&lt;/code&gt; bar.example.com 으로 경로 재 지정 되는 foo.example.com에 대한 POST 요청이있는 경우 , 토큰과 서버는 다른 버전에서 실행됩니다. : allow_hosts &lt;code&gt;option to control any host that you may want to allow. The values in&lt;/code&gt; 전달하여 허용하려는 모든 호스트를 제어 할 수 있습니다. : allow_hosts 의 값은 &lt;code&gt;may either be a full host name or a host suffix. For example:&lt;/code&gt; [&amp;ldquo;www.example.com&amp;rdquo;,&amp;ldquo;.subdomain.example.com&amp;rdquo;] &lt;code&gt;will allow the exact host of&lt;/code&gt; &amp;rdquo;www.example.com&amp;rdquo; 의 정확한 호스트 &lt;code&gt;and any host that ends with&lt;/code&gt; &amp;rdquo;.subdomain.example.com&amp;rdquo;으로 끝나는 모든 호스트를 허용합니다 &lt;code&gt;. ## Options *&lt;/code&gt; : SESSION_KEY &lt;code&gt;- the name of the key in session to store the token under *&lt;/code&gt; : allow_hosts &lt;code&gt;- a list with hosts to allow on cross-host tokens *&lt;/code&gt; :와 &lt;code&gt;- should be one of&lt;/code&gt; : 예외 &lt;code&gt;or&lt;/code&gt; : CLEAR_SESSOIN 값 &lt;code&gt;. Defaults to&lt;/code&gt; : exception &lt;code&gt;. *&lt;/code&gt; : exception- &lt;code&gt;- for invalid requests, this plug will raise [&lt;/code&gt; Plug.CSRFProtection.InvalidCSRFTokenError &lt;code&gt;](Plug.CSRFProtection.InvalidCSRFTokenError.html). *&lt;/code&gt; : clear_session &lt;code&gt;- for invalid requests, this plug will set an empty session for only this request. Also any changes to the session during this request will be ignored. ## Disabling You may disable this plug by doing&lt;/code&gt; Plug.Conn.put_private (conn, : plug_skip_csrf_protection, true) 를 수행 하여이 플러그를 비활성화 할 수 있습니다 &lt;code&gt;. This was made available for disabling [&lt;/code&gt; Plug.CSRFProtection &lt;code&gt;](Plug.CSRFProtection.html#content) in tests and not for dynamically skipping [&lt;/code&gt; Plug.CSRFProtection &lt;code&gt;](Plug.CSRFProtection.html#content) in production code. If you want specific routes to skip [&lt;/code&gt; Plug.CSRFProtection &lt;code&gt;](Plug.CSRFProtection.html#content), then use a different stack of plugs for that route that does not include [&lt;/code&gt; 을 건너 뛰려면 해당 경로에 다른 플러그 스택을 사용하십시오.Plug.CSRFProtection`] (Plug.CSRFProtection.html # content). ## 예제 plug Plug.Session,&amp;hellip; plug : fetch_session plug Plug.CSRFProtection</target>
        </trans-unit>
        <trans-unit id="0e91726d425116538b0449faff1e3e0fef303282" translate="yes" xml:space="preserve">
          <source>For example, if you are running your application behind a proxy, the browser will send a request to the proxy with &lt;code&gt;www.example.com&lt;/code&gt; but the proxy will request you using an internal IP. In such cases, it is common for proxies to attach information such as &lt;code&gt;&quot;x-forwarded-host&quot;&lt;/code&gt; that contains the original host.</source>
          <target state="translated">예를 들어 프록시 뒤에서 응용 프로그램을 실행하는 경우 브라우저는 &lt;code&gt;www.example.com&lt;/code&gt; 을 사용하여 프록시에 요청을 보내지 만 프록시는 내부 IP를 사용하도록 요청합니다. 이러한 경우 프록시가 원래 호스트를 포함하는 &lt;code&gt;&quot;x-forwarded-host&quot;&lt;/code&gt; 와 같은 정보를 첨부하는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="f1191fda5c146bc7cb8bf9725ef9a87de1ba7566" translate="yes" xml:space="preserve">
          <source>For example, if you are using Phoenix with Gettext and you want to localize the list of months, you can pass &lt;code&gt;:options&lt;/code&gt; to the &lt;code&gt;:month&lt;/code&gt; key:</source>
          <target state="translated">예를 들어, Gettext와 함께 Phoenix를 사용하고 있고 월 목록을 현지화하려는 경우 &lt;code&gt;:options&lt;/code&gt; 를 &lt;code&gt;:month&lt;/code&gt; 키에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5c675e9e5c373385484112272b4a043bbd839e6" translate="yes" xml:space="preserve">
          <source>For example, if you don&amp;rsquo;t need all fields to be returned as part of a struct, you can filter it to include only certain fields by using &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 구조체의 일부로 모든 필드를 반환 할 필요가없는 경우 &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 필드 만 포함하도록 필드를 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc5dc01c081354dfaf44b568f55f3ebe9329dee7" translate="yes" xml:space="preserve">
          <source>For example, if you don&amp;rsquo;t need all fields to be returned or neither need a struct, you can use &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; to achieve both:</source>
          <target state="translated">예를 들어, 모든 필드를 반환 할 필요가 없거나 구조체가 필요하지 않은 경우 &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 두 가지를 모두 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c811ae0696ce6f951b2bc3002197b8ae16be70c6" translate="yes" xml:space="preserve">
          <source>For example, if you don't need all fields to be returned as part of a struct, you can filter it to include only certain fields by using &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어 모든 필드를 구조체의 일부로 반환 할 필요가없는 경우 &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 필드 만 포함하도록 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1352717ed362aac86319e5ca0446d68b801172fa" translate="yes" xml:space="preserve">
          <source>For example, if you don't need all fields to be returned or neither need a struct, you can use &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; to achieve both:</source>
          <target state="translated">예를 들어 모든 필드를 반환 할 필요가 없거나 구조체가 필요하지 않은 경우 &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 두 가지를 모두 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="046786477a40d0ce576e85622a62582fe169703c" translate="yes" xml:space="preserve">
          <source>For example, if you want to provide your own date structures, the type function should return &lt;code&gt;:date&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 고유 한 날짜 구조를 제공하려는 경우 type 함수는 &lt;code&gt;:date&lt;/code&gt; 를 반환해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="4a490502a537fa70cbfe7862a7fdc9d9d25a4ab0" translate="yes" xml:space="preserve">
          <source>For example, if your database does not support autoincrementing primary keys and requires something like UUID or a RecordID, you can configure and use &lt;code&gt;:binary_id&lt;/code&gt; as your primary key type as follows:</source>
          <target state="translated">예를 들어, 데이터베이스에서 자동 증가 기본 키를 지원하지 않고 UUID 또는 RecordID와 같은 것이 필요한 경우 다음과 같이 &lt;code&gt;:binary_id&lt;/code&gt; 를 기본 키 유형으로 구성하고 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84cde3c3ecfdee20a150817b154d085461422ad2" translate="yes" xml:space="preserve">
          <source>For example, imagine a user has many addresses relationship where post data is sent as follows</source>
          <target state="translated">예를 들어, 사용자에게 다음과 같이 게시물 데이터가 전송되는 많은 주소 관계가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="df1b9f8c3f5e06f384cb183c3f248319b297f218" translate="yes" xml:space="preserve">
          <source>For example, imagine a user with id &lt;code&gt;123&lt;/code&gt; online from two different devices, as well as a user with id &lt;code&gt;456&lt;/code&gt; online from just one device. The following presence information might be returned:</source>
          <target state="translated">예를 들어, 두 개의 다른 장치에서 온라인 으로 ID가 &lt;code&gt;123&lt;/code&gt; 인 사용자와 하나의 장치에서 온라인 으로 ID가 &lt;code&gt;456&lt;/code&gt; 인 사용자를 상상해보십시오 . 다음과 같은 현재 상태 정보가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886c455d893cac0662c17c0b5a315859b743e334" translate="yes" xml:space="preserve">
          <source>For example, imagine creating a resource and replying with the created record:</source>
          <target state="translated">예를 들어, 자원을 작성하고 작성된 레코드로 응답한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="533f158f4a4f3c3fed2c4251950886b68baf1969" translate="yes" xml:space="preserve">
          <source>For example, imagine you are testing an authentication plug in isolation, but you need to invoke the Endpoint plugs and &lt;code&gt;:browser&lt;/code&gt; pipeline of your Router for session and flash related dependencies:</source>
          <target state="translated">예를 들어, 인증 플러그를 별도로 테스트하고 있지만 세션 및 플래시 관련 종속성에 대해 라우터 의 엔드 포인트 플러그 및 &lt;code&gt;:browser&lt;/code&gt; 파이프 라인 을 호출해야한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="24497d20f39de0bd9301b7b9d03a2a9115d64d94" translate="yes" xml:space="preserve">
          <source>For example, imagine you are testing an authentication plug in isolation, but you need to invoke the Endpoint plugs and router pipelines to set up session and flash related dependencies. One option is to invoke an existing route that uses the proper pipelines. You can do so by passing the connection and the router name to &lt;code&gt;bypass_through&lt;/code&gt;:</source>
          <target state="translated">예를 들어 인증 플러그를 격리 테스트하고 있지만 세션 및 플래시 관련 종속성을 설정하려면 엔드 포인트 플러그 및 라우터 파이프 라인을 호출해야한다고 가정 해보십시오. 한 가지 옵션은 적절한 파이프 라인을 사용하는 기존 경로를 호출하는 것입니다. 연결과 라우터 이름을 &lt;code&gt;bypass_through&lt;/code&gt; 에 전달하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d35abbc4af6b641142df2d7b6e8cb714b2e59096" translate="yes" xml:space="preserve">
          <source>For example, imagine you have a set of conditions you want to build your query on:</source>
          <target state="translated">예를 들어, 쿼리를 작성하려는 조건 세트가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="8eebd42f8b90a67c493e81c5b014f284666e7e5e" translate="yes" xml:space="preserve">
          <source>For example, one could set the accepts header for json requests as follows:</source>
          <target state="translated">예를 들어, 다음과 같이 json 요청에 대한 accepts 헤더를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0404b9a4be72b8fa2ca4aa38b64953ae3c079e9" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;:banner&lt;/code&gt; option:</source>
          <target state="translated">예를 들어 다음과 같은 &lt;code&gt;:banner&lt;/code&gt; 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e3418ad418cbae8b838f55a7f3c5eff7a23b6e" translate="yes" xml:space="preserve">
          <source>For example, the following is forbidden because it is not at the root of a &lt;code&gt;where&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음은 &lt;code&gt;where&lt;/code&gt; 의 루트에 있지 않기 때문에 금지되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6471f878df0f8a31f0a9c6ed9c1a0970d2b7f6cc" translate="yes" xml:space="preserve">
          <source>For example, the route above will match on the path &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; and the named route will be &lt;code&gt;api_v1_page_path&lt;/code&gt;, as expected from the values given to &lt;a href=&quot;#scope/2&quot;&gt;&lt;code&gt;scope/2&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">예를 들어, 위의 경로는 &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; 경로에서 일치 하며 &lt;a href=&quot;#scope/2&quot;&gt; &lt;code&gt;scope/2&lt;/code&gt; &lt;/a&gt; 옵션에 제공된 값에서 예상 &lt;code&gt;api_v1_page_path&lt;/code&gt; 명명 된 경로는 api_v1_page_path 입니다.</target>
        </trans-unit>
        <trans-unit id="d2fc813eb5dfb8f4978194599eab4ecab416b2e4" translate="yes" xml:space="preserve">
          <source>For example, the route:</source>
          <target state="translated">예를 들어 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10a90aa8783fdb171b94edeeedb9421523ade4a7" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &quot;lower(?)&quot; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">데이터베이스에서 &quot;낮은 (?)&quot;기능을 실행하는 동안 예를 들어, 모든 게시물을 얻을 수 &lt;code&gt;p.title&lt;/code&gt; 는 대신에 보간을 &lt;code&gt;?&lt;/code&gt; , 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c268739f07b40440ff73d328a7a5b1783a45e413" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &amp;ldquo;lower(?)&amp;rdquo; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">데이터베이스에서 &quot;낮은 (?)&quot;기능을 실행하는 동안 예를 들어, 모든 게시물을 얻을 수 &lt;code&gt;p.title&lt;/code&gt; 는 대신에 보간을 &lt;code&gt;?&lt;/code&gt; , 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="712a75ed27773b36d6dab2e762ed7d44810db42c" translate="yes" xml:space="preserve">
          <source>For example, to handle &quot;phx_leave&quot; messages, which is recommended to be handled by all channel implementations, one may do:</source>
          <target state="translated">예를 들어 모든 채널 구현에서 처리하도록 권장되는 &quot;phx_leave&quot;메시지를 처리하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa80c213499c1e4e2ebabd1a68490863d99b23c" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phoenix.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">예를 들어, 종속성을 확인하지 않고 &lt;code&gt;phoenix.server&lt;/code&gt; 를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="52d1730d810a3213b8ae35feb4a46172562acd1e" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">예를 들어, 종속성을 확인하지 않고 &lt;code&gt;phx.server&lt;/code&gt; 를 실행하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb24d75387baa2ce86c09393fcd13aa1468c60e5" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without recompiling:</source>
          <target state="translated">예를 들어, 다시 컴파일하지 않고 &lt;code&gt;phx.server&lt;/code&gt; 를 실행 하려면 :</target>
        </trans-unit>
        <trans-unit id="ee191307a2caef15a68ebec9dbfb940793de8194" translate="yes" xml:space="preserve">
          <source>For example, we can use the &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt; function in the test to push messages to the channel (it will invoke &lt;code&gt;handle_in/3&lt;/code&gt;):</source>
          <target state="translated">예를 들어 테스트에서 &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 메시지를 채널로 푸시 할 수 있습니다 ( &lt;code&gt;handle_in/3&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="a9c7054e90670cbc4ed17910aed6f38d7ea04bcd" translate="yes" xml:space="preserve">
          <source>For example, you may define it as:</source>
          <target state="translated">예를 들어 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f038621e4427f7e69c128ca2c67366fe95857d" translate="yes" xml:space="preserve">
          <source>For example, you may way to generate an https URL from an http request. You could define a function like the following:</source>
          <target state="translated">예를 들어 http 요청에서 https URL을 생성 할 수 있습니다. 다음과 같은 기능을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="011fbae011e4f284a1bc4a3f9f03b9f3860ee774" translate="yes" xml:space="preserve">
          <source>For further details refer to &lt;a href=&quot;plug.rewriteon&quot;&gt;&lt;code&gt;Plug.RewriteOn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;plug.rewriteon&quot;&gt; &lt;code&gt;Plug.RewriteOn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed904b738db7c4a3075c6e430608f75222bb23b" translate="yes" xml:space="preserve">
          <source>For graceful exits, the channel will notify the transort it is gracefully terminating via the following message:</source>
          <target state="translated">정상 종료의 경우 채널은 트랜스 포트에 다음 메시지를 통해 정상적으로 종료되고 있음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="92926b5f41b64990dae4306af8842a9e143deef7" translate="yes" xml:space="preserve">
          <source>For instance, here is how you would pass the SSL options to the Cowboy adapter:</source>
          <target state="translated">예를 들어 SSL 옵션을 Cowboy 어댑터에 전달하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29be4bc5c201dd9ca580d6ef9202fab40016be15" translate="yes" xml:space="preserve">
          <source>For instance, imagine you wrote:</source>
          <target state="translated">예를 들어, 다음과 같이 썼다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="c93a52e328a78cb6709c141ab080c4cb225cf8de" translate="yes" xml:space="preserve">
          <source>For instance, to receive all query events published by a repository called &lt;code&gt;MyApp.Repo&lt;/code&gt;, one would define a module:</source>
          <target state="translated">예를 들어 &lt;code&gt;MyApp.Repo&lt;/code&gt; 라는 저장소에서 게시 한 모든 쿼리 이벤트를 수신하려면 모듈을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d9022c5a0c8964d6ea0f8ae4b3dab94f265d3706" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">이러한 데이터베이스에서 맵이 작동하려면 Ecto에 JSON 라이브러리가 필요합니다. 기본적으로 Ecto는 &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; 을 사용 하며 &lt;code&gt;mix.exs&lt;/code&gt; 의 뎁에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad179f69fed4d39adf90ca8b668b0dcf60ff8610" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html.&lt;/a&gt;</source>
          <target state="translated">ETS 테이블에 대한 자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html&lt;/a&gt; 의 Erlang 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8aba17a165f8cb7c095fcd429f135914d9b29c38" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at http://www.erlang.org/doc/man/ets.html.</source>
          <target state="translated">ETS 테이블에 대한 자세한 내용은 Erlang 설명서 (http://www.erlang.org/doc/man/ets.html)를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="7497a10d07df46f2b4b817a1e9655c0d2b08b83d" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &quot;Named bindings&quot; in this module doc.</source>
          <target state="translated">명명 된 바인딩에 대한 자세한 내용은이 모듈 문서의 &quot;명명 된 바인딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86dc89db4b6ce2937afc00f7c25bd37c98b90786" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &amp;ldquo;Named bindings&amp;rdquo; in this module doc.</source>
          <target state="translated">명명 된 바인딩에 대한 자세한 내용은이 모듈 설명서의 &quot;명명 된 바인딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47623288c6f7e25e0286078a9bc973202790385a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션과 예제는 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa05355f3967ad546f604ed6817bb6dc2f2810a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_one/3&quot;&gt;&lt;code&gt;embeds_one/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션과 예제는 &lt;a href=&quot;#embeds_one/3&quot;&gt; &lt;code&gt;embeds_one/3&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f762b81db42047b1f8e5c705f799a2c497f5c89" translate="yes" xml:space="preserve">
          <source>For preloads, the selected fields may be specified from the parent:</source>
          <target state="translated">사전로드의 경우 선택한 필드를 상위에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a741dc08e6f8380624e48ef2c45211a0061c62e0" translate="yes" xml:space="preserve">
          <source>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</source>
          <target state="translated">관계형 데이터베이스의 경우 이는 해당 명령문의 RETURNING 옵션이 사용됨을 의미합니다. 이러한 이유로 MySQL은이 옵션을 지원하지 않으며 쓰기 후 읽기 필드로 스키마를 삽입 / 업데이트하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00597a349fb6a62ad730ce7a374a1fd3fdf60dfa" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#get_change/3&quot;&gt;&lt;code&gt;get_change/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계의 경우이 함수는 변경 사항이 적용된 변경 세트 데이터를 반환합니다. 원시 변경 세트를 검색하려면 &lt;a href=&quot;#get_change/3&quot;&gt; &lt;code&gt;get_change/3&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a48c0cb962716952cf875975eac6007455ad2f0" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#fetch_change/2&quot;&gt;&lt;code&gt;fetch_change/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계의 경우이 함수는 변경 사항이 적용된 변경 세트 원본 데이터를 반환합니다. 원시 변경 세트를 검색하려면 &lt;a href=&quot;#fetch_change/2&quot;&gt; &lt;code&gt;fetch_change/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e438c72243585ad24059c796c9627a8dd79cb75" translate="yes" xml:space="preserve">
          <source>For requests with a different request method, this plug will only fetch the query params.</source>
          <target state="translated">요청 방법이 다른 요청의 경우이 플러그는 쿼리 매개 변수 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9e5eaa2ebb08d285e2d07000eb79f966c0f46f7d" translate="yes" xml:space="preserve">
          <source>For responsive images, pass a map, list or string through &lt;code&gt;:srcset&lt;/code&gt;.</source>
          <target state="translated">반응 형 이미지의 경우 &lt;code&gt;:srcset&lt;/code&gt; 를 통해지도, 목록 또는 문자열을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="fd8f14bec39884e1bac29f6af6c015070597aa14" translate="yes" xml:space="preserve">
          <source>For security reasons, the form data and parameter values are never re-used in &lt;a href=&quot;#password_input/3&quot;&gt;&lt;code&gt;password_input/3&lt;/code&gt;&lt;/a&gt;. Pass the value explicitly if you would like to set one.</source>
          <target state="translated">보안상의 이유로 양식 데이터 및 매개 변수 값은 &lt;a href=&quot;#password_input/3&quot;&gt; &lt;code&gt;password_input/3&lt;/code&gt; &lt;/a&gt; 에서 재사용되지 않습니다 . 값을 설정하려면 명시 적으로 값을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0c9c55ef99a1b85442974d55919cef61666635f0" translate="yes" xml:space="preserve">
          <source>For security, &lt;code&gt;:to&lt;/code&gt; only accepts paths. Use the &lt;code&gt;:external&lt;/code&gt; option to redirect to any URL.</source>
          <target state="translated">보안을 위해 &lt;code&gt;:to&lt;/code&gt; 는 경로 만 허용합니다. &lt;code&gt;:external&lt;/code&gt; 옵션을 사용하여 URL로 리디렉션하십시오.</target>
        </trans-unit>
        <trans-unit id="fff536d187e3538d188ab49aed8a72744fd84f9c" translate="yes" xml:space="preserve">
          <source>For stylesheet files found under the given path, Phoenix will replace asset references with the digested paths, as long as the asset exists in the generated cache manifest.</source>
          <target state="translated">지정된 경로 아래에있는 스타일 시트 파일의 경우 자산이 생성 된 캐시 매니페스트에있는 한 Phoenix는 자산 참조를 다이제스트 된 경로로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8c36fe9b2a7c749e8571085eb2af112fd9083639" translate="yes" xml:space="preserve">
          <source>For such cases, just pass an atom representing the action to dispatch:</source>
          <target state="translated">그러한 경우, 파견 할 조치를 나타내는 원자를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3e369afedac592425ec8d8e891860e0bbe16c64c" translate="yes" xml:space="preserve">
          <source>For such cases, you need to set the &lt;code&gt;@endpoint&lt;/code&gt; attribute to your controller and pass an atom representing the action to dispatch:</source>
          <target state="translated">이러한 경우 &lt;code&gt;@endpoint&lt;/code&gt; 속성을 컨트롤러 에 설정하고 디스패치 할 작업을 나타내는 아톰을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="20a1f9c6c25c59a377c89a60f258c5d3b208854e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">의 경우 &lt;code&gt;:decimal&lt;/code&gt; 유형, &lt;code&gt;+Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 과 &lt;code&gt;NaN&lt;/code&gt; 값은 지원되지 않습니다에도 불구하고 &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 라이브러리 핸들 그들. 이를 지원하기 위해 사용자 정의 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d601251c886cf09d8df301039ddd66e5410dddf0" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">의 경우 &lt;code&gt;:decimal&lt;/code&gt; 유형, &lt;code&gt;+Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 과 &lt;code&gt;NaN&lt;/code&gt; 값은 지원되지 않습니다에도 불구하고 &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 라이브러리 핸들 그들. 이를 지원하기 위해 사용자 정의 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780c2570702e69db99f32922ce1d16997b165979" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;{:array, inner_type}&lt;/code&gt; and &lt;code&gt;{:map, inner_type}&lt;/code&gt; type, replace &lt;code&gt;inner_type&lt;/code&gt; with one of the valid types, such as &lt;code&gt;:string&lt;/code&gt;.</source>
          <target state="translated">를 들어 &lt;code&gt;{:array, inner_type}&lt;/code&gt; 과 &lt;code&gt;{:map, inner_type}&lt;/code&gt; 유형, 대체 &lt;code&gt;inner_type&lt;/code&gt; 을 같은 유효한 유형 중 하나 &lt;code&gt;:string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b121a5201e5fe9abd71ff02499c57b1592c223e" translate="yes" xml:space="preserve">
          <source>For the endpoint:</source>
          <target state="translated">엔드 포인트의 경우 :</target>
        </trans-unit>
        <trans-unit id="b6cc26f40ba25b58fe4ceb1492cc4ebe433ed3db" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the plug stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">이 플러그가 작동하려면 세션이 이전에 페치되었을 것으로 예상됩니다. 그런 다음 세션에 저장된 플러그를 요청이 보낸 플러그와 비교하여 요청의 유효성을 확인합니다. 유효하지 않은 요청의 경우 조치는 &lt;code&gt;:with&lt;/code&gt; 옵션을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c19aeef5835b8730002052f32c829b18a9a1b368" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the token stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">이 플러그가 작동하려면 세션이 이전에 페치되었을 것으로 예상됩니다. 그런 다음 세션에 저장된 토큰을 요청이 보낸 토큰과 비교하여 요청의 유효성을 확인합니다. 유효하지 않은 요청의 경우 조치는 &lt;code&gt;:with&lt;/code&gt; 옵션을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="acbd3da24abf12ae2ee4b4dbe388f7d784a60abf" translate="yes" xml:space="preserve">
          <source>For this reason, Phoenix automatically includes a &amp;ldquo;_utf8=✓&amp;rdquo; parameter in your forms, to force those browsers to send the data in the proper encoding. This technique has been seen in the Rails web framework and reproduced here.</source>
          <target state="translated">이러한 이유로 Phoenix는 양식에&amp;ldquo;_utf8 = ✓&amp;rdquo;매개 변수를 자동으로 포함하여 해당 브라우저가 데이터를 적절한 인코딩으로 보내도록합니다. 이 기술은 Rails 웹 프레임 워크에서 보았으며 여기서 재현되었습니다.</target>
        </trans-unit>
        <trans-unit id="93af13c5fc0bdc9bd0b9d349f954f83799c8aaa8" translate="yes" xml:space="preserve">
          <source>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</source>
          <target state="translated">이러한 이유로 나머지 예제에서는 스키마를 사용하지만 쿼리를 작성하기 위해 Ecto에서는 스키마를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7e5ab937cf7dceafaad92974cb027e2587d7a76" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously</source>
          <target state="translated">주어진 pid가 비동기 적으로 다운되었으므로 테이블 정리를 강제하십시오.</target>
        </trans-unit>
        <trans-unit id="8297c64e60d581b16d4f160782d093bba37f69c8" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously.</source>
          <target state="translated">지정된 pid가 비동기 적으로 다운되었으므로 테이블 정리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9376e40f7dd57bd0a80a45f4b597decef3430bb5" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection</source>
          <target state="translated">소켓 연결에서 SSL을 강제 실행</target>
        </trans-unit>
        <trans-unit id="f2f36ba3d6535af9ad03fa2741c09ec0c941cf53" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection.</source>
          <target state="translated">소켓 연결에서 SSL을 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a94803f581b82f9ba5bdaf6f21212ed730ebfce9" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 강제 변경</target>
        </trans-unit>
        <trans-unit id="ba1f8f66627e0e0f8fe7b916b77edc9622c220fc" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 강제 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="d59e0684db2c7234ae793772920708c7ec986309" translate="yes" xml:space="preserve">
          <source>Format encoders</source>
          <target state="translated">인코더 포맷</target>
        </trans-unit>
        <trans-unit id="c97fca207ecbaf116ba6ca44368cce3e0a305b92" translate="yes" xml:space="preserve">
          <source>Fortunately that&amp;rsquo;s easily solvable by simply rewriting it to:</source>
          <target state="translated">다행히도 간단히 다음과 같이 다시 작성하면 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0ce27512362c06a1b5491aeb75239f7f72fd68" translate="yes" xml:space="preserve">
          <source>Fortunately that's easily solvable by simply rewriting it to:</source>
          <target state="translated">다행히 다음과 같이 간단히 다시 작성하면 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243792f59615d8e2d372bd2223d968fccda687be" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug</source>
          <target state="translated">주어진 경로에서 요청을 플러그로 전달</target>
        </trans-unit>
        <trans-unit id="16e33ad48d9a60b2973610a401cef5c85f913f57" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug.</source>
          <target state="translated">주어진 경로에서 요청을 플러그로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b32cf12685ca5dc27b473a969f37f02beef213d2" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;</source>
          <target state="translated">요청을 다른 플러그로 전달합니다. &lt;code&gt;path_info&lt;/code&gt; 전달은 연결의 호출로 지정된 경로의 일부 제외한다 &lt;code&gt;forward&lt;/code&gt; . 경로에 매개 변수가 포함 된 경우 대상 플러그인에서 사용할 수 있습니다. &lt;code&gt;conn.params&lt;/code&gt; 및 &lt;code&gt;conn.path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2b6fd862c663433fb18b8d94573b799a0d0c715" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;.</source>
          <target state="translated">요청을 다른 플러그로 전달합니다. &lt;code&gt;path_info&lt;/code&gt; 전달은 연결의 호출로 지정된 경로의 일부 제외한다 &lt;code&gt;forward&lt;/code&gt; . 경로에 매개 변수가 포함되어 있으면 대상 플러그인 &lt;code&gt;conn.params&lt;/code&gt; 및 &lt;code&gt;conn.path_params&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676ca63eda9f110339bc4562d41c4087d1f58d05" translate="yes" xml:space="preserve">
          <source>Four different datetime primitive types are available:</source>
          <target state="translated">4 가지 다른 날짜 / 시간 기본 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="a3351c1a0bc423227fbc6658fde3c845ebb20e75" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 20, channels automatically hibernate to save memory after 15_000 milliseconds of inactivity. This can be customized by passing the &lt;code&gt;:hibernate_after&lt;/code&gt; option to &lt;code&gt;use Phoenix.Channel&lt;/code&gt;:</source>
          <target state="translated">Erlang / OTP 20에서 채널은 15_000 밀리 초 동안 활동이 없으면 메모리를 절약하기 위해 자동으로 최대 절전 모드로 전환됩니다. &lt;code&gt;use Phoenix.Channel&lt;/code&gt; 을 사용 하기 위해 &lt;code&gt;:hibernate_after&lt;/code&gt; 옵션을 전달하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d57ff449f79bf9c5a7e5e0c8035c5660c71a840" translate="yes" xml:space="preserve">
          <source>From this moment on, all future queries done by the current process will run on &lt;code&gt;:tenant_foo&lt;/code&gt;.</source>
          <target state="translated">이 순간부터 현재 프로세스가 수행하는 모든 향후 쿼리는 &lt;code&gt;:tenant_foo&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7091d22a2b4d23609cc93c591d186ab2886edba6" translate="yes" xml:space="preserve">
          <source>Front-end to Phoenix pubsub layer.</source>
          <target state="translated">Phoenix pubsub 레이어의 프런트 엔드</target>
        </trans-unit>
        <trans-unit id="9bf236d048ccab1956dd5420be9ebe7d7c44331e" translate="yes" xml:space="preserve">
          <source>Function plugs</source>
          <target state="translated">기능 플러그</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1442301406adda1b4f88b555bb39bb4cb9e30ff1" translate="yes" xml:space="preserve">
          <source>Furthermore an array type can also be given if it is supported by your database, although it requires the type of the underlying array element to be given too:</source>
          <target state="translated">또한 기본 배열 요소의 유형도 제공해야하지만 데이터베이스에서 지원하는 경우 배열 유형을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c1f2b55dcf3303d32f38fbac65ddded9bd404b" translate="yes" xml:space="preserve">
          <source>Furthermore, both &lt;code&gt;__struct__&lt;/code&gt; and &lt;code&gt;__changeset__&lt;/code&gt; functions are defined so structs and changeset functionalities are available.</source>
          <target state="translated">또한 &lt;code&gt;__struct__&lt;/code&gt; 및 &lt;code&gt;__changeset__&lt;/code&gt; 함수가 모두 정의되므로 구조체 및 변경 집합 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d2ace48935ec9ca13c146a4d739dd039753a23f" translate="yes" xml:space="preserve">
          <source>Furthermore, it sets the following defaults:</source>
          <target state="translated">또한 다음 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9c9cc3e69d5248baac17979dd85069ab7aa035bd" translate="yes" xml:space="preserve">
          <source>Furthermore, since the tag information is given as structs read directly from the database, Ecto will treat the data as correct and only do the minimum necessary to guarantee that posts and tags are associated, without trying to update or diff any of the fields in the tag struct.</source>
          <target state="translated">또한 태그 정보는 데이터베이스에서 직접 읽은 구조체로 제공되므로 Ecto는 데이터를 올바른 것으로 취급하고 필드의 필드를 업데이트하거나 비교하지 않고 게시물과 태그가 연결되도록 보장하는 데 필요한 최소한의 작업 만 수행합니다. 태그 구조체.</target>
        </trans-unit>
        <trans-unit id="c338ceb5b7adaaa50f38c347f2349c53389ff49c" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;before_send&lt;/code&gt; field stores callbacks that are invoked before the connection is sent. Callbacks are invoked in the reverse order they are registered (callbacks registered first are invoked last) in order to reproduce a pipeline ordering.</source>
          <target state="translated">또한 &lt;code&gt;before_send&lt;/code&gt; 필드는 연결이 전송되기 전에 호출되는 콜백을 저장합니다. 파이프 라인 순서를 재현하기 위해 콜백은 등록 된 역순으로 호출됩니다 (먼저 등록 된 콜백이 마지막으로 호출 됨).</target>
        </trans-unit>
        <trans-unit id="70e2803f5997f8434e1e14d79b67bf417331f761" translate="yes" xml:space="preserve">
          <source>Furthermore, this protocol relies on iodata, which provides better performance when sending or streaming data to the client.</source>
          <target state="translated">또한이 프로토콜은 iodata를 사용하여 클라이언트로 데이터를 보내거나 스트리밍 할 때 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98281856e51de8bb0669d3ab3f5d42120b606d43" translate="yes" xml:space="preserve">
          <source>GET requests are not protected, as they should not have any side-effect or change your application state. JavaScript requests are an exception: by using a script tag, external websites can embed server-side generated JavaScript, which can leak information. For this reason, this plug also forbids any GET JavaScript request that is not XHR (or AJAX).</source>
          <target state="translated">GET 요청은 부작용이 없거나 애플리케이션 상태를 변경하지 않아야하므로 보호되지 않습니다. JavaScript 요청은 예외입니다. 스크립트 태그를 사용하면 외부 웹 사이트가 서버 측에서 생성 된 JavaScript를 포함하여 정보가 유출 될 수 있습니다. 이러한 이유로이 플러그는 XHR (또는 AJAX)이 아닌 GET JavaScript 요청도 금지합니다.</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="a96be0a4f608d9678cf95140fc6762e7fff0a137" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="18fd8d6947881e76a9476c5cc3ade9f03cb51e63" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information.</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="81d73279e9d50f0e75f19715870b45b2edcc66d2" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">일반 : &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff7162efc456a290918a3e5ee7fb1cdec59b3096" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#as/1&quot;&gt;&lt;code&gt;as/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parent_as/1&quot;&gt;&lt;code&gt;parent_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">일반 : &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#as/1&quot;&gt; &lt;code&gt;as/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parent_as/1&quot;&gt; &lt;code&gt;parent_as/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbf039f3463a6192dcedbf378221d86ccce25ca4" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form</source>
          <target state="translated">지정된 매개 변수에 대해 새 양식 빌더를 양식으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="2809e45ea67772c9b7701d8d849d6d2e451fe427" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식의 지정된 매개 변수에 대한 새 양식 작성기를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="15e52a102d3768bc19eacc2abb7f4194a20be07e" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form.</source>
          <target state="translated">지정된 매개 변수에 대해 새 양식 빌더를 양식으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc292ee42a9b81099735fa47e66e355172cc4c20" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema&amp;rsquo;s primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">생성 된 마이그레이션은 스키마의 기본 키에 &lt;code&gt;binary_id&lt;/code&gt; 를 사용 하고 &lt;code&gt;--binary-id&lt;/code&gt; 옵션과 함께 해당 참조를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de509ead052a1d21c5bec58e9e137546f9fbc245" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema's primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">생성 된 마이그레이션은 &lt;code&gt;--binary-id&lt;/code&gt; 옵션을 사용 하여 스키마의 기본 키 및 참조에 &lt;code&gt;binary_id&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f64a5913edebccd654a6fcbe563ded9895c73182" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields</source>
          <target state="translated">&lt;code&gt;:inserted_at&lt;/code&gt; 및 &lt;code&gt;:updated_at&lt;/code&gt; 타임 스탬프 필드 생성</target>
        </trans-unit>
        <trans-unit id="6e6bf2fc4b7fa7784ba0393c92ca08b83b688b33" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields.</source>
          <target state="translated">&lt;code&gt;:inserted_at&lt;/code&gt; 및 &lt;code&gt;:updated_at&lt;/code&gt; 시간 소인 필드를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="46ec673256a5e76ef7c069fc676e2f5aef51009e" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply</source>
          <target state="translated">비동기 응답에 대한 &lt;code&gt;socket_ref&lt;/code&gt; 를 생성합니다</target>
        </trans-unit>
        <trans-unit id="89363898c56d89d0dc4865b93a5f0b41e2cb4d20" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply.</source>
          <target state="translated">비동기 응답에 대한 &lt;code&gt;socket_ref&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7254b9e30fd4dcd56334ce2310a46519a11db327" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix channel.</source>
          <target state="translated">피닉스 채널을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dbbfe88a5e9c28bee33e4a7709d25c7578b13712" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix resource.</source>
          <target state="translated">Phoenix 리소스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="396e5bd6ba3cdeb590c49ec0bbf4116674cec309" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker for your application.</source>
          <target state="translated">응용 프로그램에 대한 현재 상태 추적기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e050d4cb2d11258492bf32d26abe466db5793c12" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker.</source>
          <target state="translated">현재 상태 추적기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5b57a23b25adcd3dfb1b05de10692fcac4b0c0a7" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL</source>
          <target state="translated">주어진 URL에 제출하기 위해 일반 HTML 양식을 사용하는 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6dc6b7e0d06c3c7fac4214ca839f28cb452a6270" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL.</source>
          <target state="translated">주어진 URL에 제출하기 위해 일반 HTML 양식을 사용하는 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="64561f910e36802f2f2af6c0eeef79ae9959a53a" translate="yes" xml:space="preserve">
          <source>Generates a checkbox</source>
          <target state="translated">확인란을 생성합니다</target>
        </trans-unit>
        <trans-unit id="9c402930c245037de584689931bc5f98cb925246" translate="yes" xml:space="preserve">
          <source>Generates a checkbox.</source>
          <target state="translated">확인란을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e758b3646d387941fe43bb7c638a89c7ddd9d4c8" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree</source>
          <target state="translated">감독 트리에서 사용할 childspec을 생성합니다</target>
        </trans-unit>
        <trans-unit id="084a356e3603b2d7d3058ec01dbce1827e553b3a" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree.</source>
          <target state="translated">감독 트리에서 사용할 childspec을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c63422f792595ace635012713e2e3ec5fdcfe7c7" translate="yes" xml:space="preserve">
          <source>Generates a color input</source>
          <target state="translated">색상 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="45606cc48a2c148438a5b2a691378a779e9d8307" translate="yes" xml:space="preserve">
          <source>Generates a color input.</source>
          <target state="translated">색상 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f79dfad3ee4eee79404d483203748cd197bfb509" translate="yes" xml:space="preserve">
          <source>Generates a context with functions around an Ecto schema.</source>
          <target state="translated">Ecto 스키마를 중심으로 함수가 포함 된 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="171627640dc242b4213e2f665007e56c741ce2ff" translate="yes" xml:space="preserve">
          <source>Generates a date input</source>
          <target state="translated">날짜 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="1fcc6c8cae144832ffc98dcd40c8eac478e1a7da" translate="yes" xml:space="preserve">
          <source>Generates a date input.</source>
          <target state="translated">날짜 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67502aa3ceeeceb276d924590c8fa7dd9b0a9b11" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input</source>
          <target state="translated">날짜 / 시간 로컬 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="ef3ed161bccd6158e836dadcf99ca1633c739273" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input.</source>
          <target state="translated">날짜 / 시간 로컬 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9e84d239e416d559f3c0bccab74b22cff072a5a3" translate="yes" xml:space="preserve">
          <source>Generates a file input</source>
          <target state="translated">파일 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="39fb04074dabbb624cbc620ccf147d69b2a45061" translate="yes" xml:space="preserve">
          <source>Generates a file input.</source>
          <target state="translated">파일 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ab3c6b9191c757e18e68646ddc1874ca970de62b" translate="yes" xml:space="preserve">
          <source>Generates a form tag</source>
          <target state="translated">양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b412e1f99156deb9e91f69f6b5ac9155bb03b9cf" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder</source>
          <target state="translated">양식 작성기를 사용하여 양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="15171feee1ac42a2cb8b455685e4d0d0b906602c" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식 작성기로 양식 태그를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b83bd97bb3e9ba2d575b33b43cdc2a09ecc53c26" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; options or an anonymous function.</source>
          <target state="translated">옵션 또는 익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식 작성기로 양식 태그를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e62cb449bf1bc7de104a5c6a894843c62b8273" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder and an anonymous function.</source>
          <target state="translated">양식 작성기 및 익명 함수를 사용하여 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5867e479588e031d9af73f4e26e2f4bb755d993f" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder.</source>
          <target state="translated">양식 작성기를 사용하여 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1fcf6d502cbed8c6774cbd71cd67cb0475fb8d97" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents</source>
          <target state="translated">주어진 내용으로 양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="73a7ae0251a3209970edcca52c92641cb83828a7" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents.</source>
          <target state="translated">주어진 내용으로 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6fb768c7b9543e92cc3420ccd02e97e5655cfdc3" translate="yes" xml:space="preserve">
          <source>Generates a form tag.</source>
          <target state="translated">양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20996193071a0905fdf25cb5c613758dc8b93878" translate="yes" xml:space="preserve">
          <source>Generates a hidden input</source>
          <target state="translated">숨겨진 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="5b13e8707f3e8f0d576e0f2751dda4df911730a0" translate="yes" xml:space="preserve">
          <source>Generates a hidden input.</source>
          <target state="translated">숨겨진 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="abfeb23072c3a06d67ccfbf879bf2eeab96d5b0f" translate="yes" xml:space="preserve">
          <source>Generates a label tag</source>
          <target state="translated">라벨 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="ce9ab90073232b80839e14e4bbe7f7a803a34eae" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field</source>
          <target state="translated">주어진 필드에 대한 레이블 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="ab3ca2bbbbcd12eb651c2e27c2a279e192ff3c15" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field.</source>
          <target state="translated">주어진 필드에 대한 레이블 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28a6fc00166a8c669fa44ea65f62685493aa2310" translate="yes" xml:space="preserve">
          <source>Generates a label tag.</source>
          <target state="translated">라벨 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a50123897c2b44bec513e431ba7cb02309189fef" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL</source>
          <target state="translated">주어진 URL에 대한 링크를 생성합니다</target>
        </trans-unit>
        <trans-unit id="c1f404e8a3f775cd18f3aa5b04a6353a8bd3eb26" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL.</source>
          <target state="translated">주어진 URL에 대한 링크를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6ea02c48fa1a1a43ce66c3cf13791ad70aa1639c" translate="yes" xml:space="preserve">
          <source>Generates a loaded version of the data.</source>
          <target state="translated">로드 된 데이터 버전을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dbc6ea3e0e5e175a0282431e58e112038aaa09c9" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information</source>
          <target state="translated">CSRF 정보로 메타 태그 생성</target>
        </trans-unit>
        <trans-unit id="2219f0cedebbcfc4a9097edd34a767a497cb1274" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information.</source>
          <target state="translated">CSRF 정보로 메타 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3aee4fdfd218c8ef8af1764ebe197ddee57e21b5" translate="yes" xml:space="preserve">
          <source>Generates a new file, &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt;, where &lt;code&gt;my_presence&lt;/code&gt; is the snake-cased version of the provided module name.</source>
          <target state="translated">새 파일 &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt; 를 생성합니다 . 여기서 &lt;code&gt;my_presence&lt;/code&gt; 는 제공된 모듈 이름의 스네이크 케이스 버전입니다.</target>
        </trans-unit>
        <trans-unit id="02411617ad03187efe4d79ddc98c3934f98cab53" translate="yes" xml:space="preserve">
          <source>Generates a new repository.</source>
          <target state="translated">새로운 저장소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ec4e73c7a7527a111588dbb3ab99814034f1ef6f" translate="yes" xml:space="preserve">
          <source>Generates a number input</source>
          <target state="translated">숫자 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="11f48eeb86c1ee3d50fe2a5731642a36708b06b0" translate="yes" xml:space="preserve">
          <source>Generates a number input.</source>
          <target state="translated">숫자 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="47709e3ef4238d15f86dbf2ee76f58d705224d78" translate="yes" xml:space="preserve">
          <source>Generates a password input</source>
          <target state="translated">비밀번호 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6d0d9edbf1971f56f1a0efb9364b266914f7db45" translate="yes" xml:space="preserve">
          <source>Generates a password input.</source>
          <target state="translated">비밀번호 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3f4172380d2e87d78dec42dfbd35c80f932ab725" translate="yes" xml:space="preserve">
          <source>Generates a radio button</source>
          <target state="translated">라디오 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="54d925054bfa8df9816df148a94806ed340b7d20" translate="yes" xml:space="preserve">
          <source>Generates a radio button.</source>
          <target state="translated">라디오 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4211b9345387b675b9be0fc4617dcd0837432193" translate="yes" xml:space="preserve">
          <source>Generates a range input</source>
          <target state="translated">범위 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="f1d665b37d2ee2aaaf57abb73a773d37fb5632a4" translate="yes" xml:space="preserve">
          <source>Generates a range input.</source>
          <target state="translated">범위 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="42b02a853b6591ae8dcaaf9e2b0f271bae8897d8" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state</source>
          <target state="translated">모든 양식 필드를 원래 상태로 재설정하기위한 재설정 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5f9c5b5c3c6b4005d0ded69c44513c4c93741343" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state.</source>
          <target state="translated">모든 양식 필드를 원래 상태로 재설정하기 위해 재설정 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c9376cf87944d2c7638464200c033426a186aa76" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method</source>
          <target state="translated">임의의 HTTP 메소드를 기반으로 경로 일치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cc5394e9f36a89d2ae9bb46e099d38573bd6b481" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method.</source>
          <target state="translated">임의의 HTTP 메소드를 기반으로 경로 일치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="897983719926fe4ff3d98b2bae0351ca40ad6096" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 에서 정적 파일에 대한 경로를 생성합니다</target>
        </trans-unit>
        <trans-unit id="bf0351ad82e221297ee7764e10c9555e6b0f6dea" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 에있는 정적 파일에 대한 경로를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="894b7547e38d381fd5440a4e9164d424f886e4e7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path</source>
          <target state="translated">주어진 경로에 대한 연결 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="574b4ca741e3f439c47b28cd49adf25fd2f68c1b" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path.</source>
          <target state="translated">주어진 경로에 대한 연결 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="378f585ff9da2c90adf66dd182b6c07d40c0b410" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path</source>
          <target state="translated">지정된 경로에 대한 삭제 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e5a45bd26b667751489c9867bc4ac2e1ad5f415" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path.</source>
          <target state="translated">지정된 경로에 대한 삭제 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9b7eea3e2812a3a9f1485a0bf4b06ac9322cb592" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path</source>
          <target state="translated">주어진 경로에 대한 get 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="57d3a2a07eedb652e1be011b09d407612fa940d1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path.</source>
          <target state="translated">주어진 경로에 대한 get 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ad76b05490559045cdfdb8bde3bf7f1fbb5c58a4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path</source>
          <target state="translated">주어진 경로에 대한 헤드 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90093949144eba1a5fb435edb853256751817dc8" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path.</source>
          <target state="translated">주어진 경로에 대한 헤드 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e24375171478c89552863fcfeadc3ce58f2e5bca" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path</source>
          <target state="translated">주어진 경로에 대한 옵션 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77c88cce859e3f038ecdbff85d2d730cb2bf13d0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path.</source>
          <target state="translated">주어진 경로에 대한 옵션 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="80ed50be25df94aebc7db8a8ad0804d3342708c1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path</source>
          <target state="translated">주어진 경로에 대한 패치 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cca725a12cd24948f36b9ede692ae61a76c694e0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path.</source>
          <target state="translated">주어진 경로에 대한 패치 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1ac815ff5f9cdaae6a2df79818543d53e1f2f23f" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path</source>
          <target state="translated">지정된 경로에 대한 게시 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6fd5d431492f5f17891de85401d2c1290f388443" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path.</source>
          <target state="translated">지정된 경로에 대한 게시 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d46c0f90d8dd7ffb2914e6f3104c626432be2" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path</source>
          <target state="translated">주어진 경로에 대한 넣기 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f9ffc6392b8fbd3db7cb9e0d3dc9186949c8f8b7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path.</source>
          <target state="translated">주어진 경로에 대한 넣기 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e0b014c7fd0d0d1d83b5a70fa8d6fe074e0f3052" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path</source>
          <target state="translated">주어진 경로에 대한 추적 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="221bae031a3004d5c2045808e65d68d8c217bcd4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path.</source>
          <target state="translated">주어진 경로에 대한 추적 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a62a15cee984de5f9b1d155a86ae8b908ee45da6" translate="yes" xml:space="preserve">
          <source>Generates a search input</source>
          <target state="translated">검색 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="9a485964d5b7b8267fbecbe17ff5ca372d19bb8a" translate="yes" xml:space="preserve">
          <source>Generates a search input.</source>
          <target state="translated">검색 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e8a0342fc5c68fc8986011bb012bd0c39bcd4083" translate="yes" xml:space="preserve">
          <source>Generates a secret and prints it to the terminal.</source>
          <target state="translated">비밀을 생성하여 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="67e63e20fe6b5c241bb9891340bbc4e7f9f2e977" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;options&lt;/code&gt; 으로 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="8387b222b8a18961d9656292381976a0bb723ec4" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;options&lt;/code&gt; 으로 선택 태그를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="af0d06afeae9859b4f3fd6e9e412d3a718e92c81" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name</source>
          <target state="translated">템플릿 이름에서 상태 메시지를 생성합니다</target>
        </trans-unit>
        <trans-unit id="7454d06c3dd95214098294a1b0310dac0b7a4878" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name.</source>
          <target state="translated">템플릿 이름에서 상태 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="067fc3be22bab148f6c9165e5da91f0df3fa5da9" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form</source>
          <target state="translated">양식을 보내기 위해 제출 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="312f705dccca8c086547117e4724c8592db5695d" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form.</source>
          <target state="translated">양식을 보낼 제출 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f4ea648663e608eaa4d4758ecd78961c842e565e" translate="yes" xml:space="preserve">
          <source>Generates a telephone input</source>
          <target state="translated">전화 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="912392aacff0f7188b964ec552a88e06572c1c85" translate="yes" xml:space="preserve">
          <source>Generates a telephone input.</source>
          <target state="translated">전화 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="54aa2d4862224e6c0fb69837326cc7b97ce5c66a" translate="yes" xml:space="preserve">
          <source>Generates a text input</source>
          <target state="translated">텍스트 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="73f0bd438fee7c9707ed766a9afb23c407583846" translate="yes" xml:space="preserve">
          <source>Generates a text input.</source>
          <target state="translated">텍스트 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="45397941ecf32426955313a201964be41c43f1da" translate="yes" xml:space="preserve">
          <source>Generates a textarea input</source>
          <target state="translated">텍스트 영역 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="126b50f201a72f4c020abacab8f934f9f30a6581" translate="yes" xml:space="preserve">
          <source>Generates a textarea input.</source>
          <target state="translated">텍스트 영역 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="eceb224d2682e883c41b426e06844bbc0bb1dbfb" translate="yes" xml:space="preserve">
          <source>Generates a time input</source>
          <target state="translated">시간 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6248af3237dc2fb4fd35ad1108d254199730ac1e" translate="yes" xml:space="preserve">
          <source>Generates a time input.</source>
          <target state="translated">시간 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ae030fe064e790de454fd16af4f1f68f22484a3" translate="yes" xml:space="preserve">
          <source>Generates a token and stores it in the process dictionary if one does not exist.</source>
          <target state="translated">토큰을 생성하고 존재하지 않는 경우 프로세스 사전에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e9144aebe51b655f2f4bb9bb809ff17899371d44" translate="yes" xml:space="preserve">
          <source>Generates a two item tuple containing the &lt;code&gt;static_path&lt;/code&gt; and &lt;code&gt;static_integrity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_path&lt;/code&gt; 및 &lt;code&gt;static_integrity&lt;/code&gt; 를 포함하는 두 항목 튜플을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e07857e5bb53d01eb1dafeb1352fa46eae3a116c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID</source>
          <target state="translated">버전 4 (임의) UUID를 생성합니다</target>
        </trans-unit>
        <trans-unit id="21e2aa08f9efa85d22010347be63b109be8c5a02" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format</source>
          <target state="translated">이진 형식으로 버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0e42f792fb874b4044bce2c20dbf1af12c49012" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format.</source>
          <target state="translated">이진 형식으로 버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0f3d3d0bf68951efc2ef0156a57ac19451a2154c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID.</source>
          <target state="translated">버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f629d614bd57112e09d421f86237a37bc2fa9a5" translate="yes" xml:space="preserve">
          <source>Generates an Ecto model in your Phoenix application.</source>
          <target state="translated">Phoenix 애플리케이션에서 Ecto 모델을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="192881be6736fea74c466100ba43922580a0b06b" translate="yes" xml:space="preserve">
          <source>Generates an Ecto schema and migration.</source>
          <target state="translated">Ecto 스키마 및 마이그레이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3c003e1e5dc81ee91cde965669c00912afc2b27c" translate="yes" xml:space="preserve">
          <source>Generates an email input</source>
          <target state="translated">이메일 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="c7bd255992aaeef9602f0be4b666b7be9fe3a2ba" translate="yes" xml:space="preserve">
          <source>Generates an email input.</source>
          <target state="translated">이메일 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6504cdfcb718565b5576fc2158cd57efe4825bb4" translate="yes" xml:space="preserve">
          <source>Generates an embedded Ecto schema for casting/validating data outside the DB.</source>
          <target state="translated">DB 외부에서 데이터를 캐스트 / 검증하기위한 내장 Ecto 스키마를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2cad790430badca14ec8c02cc664082faed9f493" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src</source>
          <target state="translated">src로 img 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="9b6859233f63365d7a32da180d650f35004ce39e" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src.</source>
          <target state="translated">src를 사용하여 img 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31a11500f500d76442b5a7660ff34e1c46e8aaa8" translate="yes" xml:space="preserve">
          <source>Generates an integrity hash to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 의 정적 파일에 대한 무결성 해시를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="94584e370048710080737b7da1191363a53d9074" translate="yes" xml:space="preserve">
          <source>Generates an url input</source>
          <target state="translated">URL 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="41f536102076cb368a63c9729925c85b108feb67" translate="yes" xml:space="preserve">
          <source>Generates an url input.</source>
          <target state="translated">URL 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3eaee8e36f647786a53b9f964255fe72cc821f1a" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for a JSON resource.</source>
          <target state="translated">JSON 리소스에 대한 컨트롤러,보기 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="be50e5d315403c8a6e5ed901af8b36c1c04a5c95" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an JSON resource.</source>
          <target state="translated">JSON 리소스에 대한 컨트롤러, 뷰 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e78eb34839e1acd728f57541f822721b2b3ba7cc" translate="yes" xml:space="preserve">
          <source>Generates hidden inputs for the given form.</source>
          <target state="translated">주어진 양식에 대해 숨겨진 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8b426df53681f88f2110c30af8bf84dbae2dbb1" translate="yes" xml:space="preserve">
          <source>Generates select tags for date</source>
          <target state="translated">날짜에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="900feb5d8076251ce1c88b1c50c88ed36d4df204" translate="yes" xml:space="preserve">
          <source>Generates select tags for date.</source>
          <target state="translated">날짜에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="33944458ee24e52c6f57b54406929743c95d1e0f" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime</source>
          <target state="translated">날짜 시간에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b91c0777babdf510129bdd926e272571b56c507a" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime.</source>
          <target state="translated">날짜 / 시간에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2989d503428e011977ec7d2d26ea57f0cd501ff1" translate="yes" xml:space="preserve">
          <source>Generates select tags for time</source>
          <target state="translated">시간에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="44c3290708cfe98a895d3932d31b3028cf656029" translate="yes" xml:space="preserve">
          <source>Generates select tags for time.</source>
          <target state="translated">시간에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="06abc3fc049f6aeb29e4374ef7a511dc801188d0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information</source>
          <target state="translated">경로 정보없이 엔드 포인트 기본 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c54d53d2a725dae194fd5931fc6e94b42a7bafb" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information.</source>
          <target state="translated">경로 정보없이 엔드 포인트 기본 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="566783b0db0c0900209be301c7fb5794061562a0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct</source>
          <target state="translated">엔드 포인트 기본 URL을 생성하지만 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 구조체로 생성</target>
        </trans-unit>
        <trans-unit id="a457480f3b7970598a96e97a308a2c57be1d9d62" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">엔드 포인트 기본 URL을 생성하지만 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 구조체 로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="a56e0e8f6c89e5bcd6f332dfe4a7f18f1d712206" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint</source>
          <target state="translated">이 엔드 포인트로 라우팅 할 때 경로 정보를 생성합니다</target>
        </trans-unit>
        <trans-unit id="9de6c6bdf8366eaa60f44b75556d6710e9111768" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint.</source>
          <target state="translated">이 엔드 포인트로 라우팅 할 때 경로 정보를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92831dcf10942016c97191fd271c8140a6105d73" translate="yes" xml:space="preserve">
          <source>Generates the static URL without any path information.</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d336eb35990be39ada49eb89ccf7bc531bbf8d59" translate="yes" xml:space="preserve">
          <source>Generating typespecs for schemas is out of the scope of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스키마에 대한 typespec 생성은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 범위를 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="c7afc8fed6ae07096bcda43b2c180de120f70394" translate="yes" xml:space="preserve">
          <source>Generating without a schema</source>
          <target state="translated">스키마없이 생성</target>
        </trans-unit>
        <trans-unit id="3b22374ca8da32cfe346b6ca99bea860d67b2484" translate="yes" xml:space="preserve">
          <source>Generating without a schema or context file</source>
          <target state="translated">스키마 또는 컨텍스트 파일없이 생성</target>
        </trans-unit>
        <trans-unit id="24e7830f821b426f5a51f69a462e899b6faff3ad" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value</source>
          <target state="translated">변경을 가져 오거나 기본값을 반환</target>
        </trans-unit>
        <trans-unit id="20c69fc2d13ee5ae1e5c766de8168c5e86eac703" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value.</source>
          <target state="translated">변경을 가져 오거나 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae896285359a3676cf6a8e84fe64f02a1009d1d3" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data</source>
          <target state="translated">변경 또는 데이터에서 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bd5eebfdc41b8efa306222262683e1e2cb53f629" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data.</source>
          <target state="translated">변경 또는 데이터에서 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f0ad8554cfab9a4c20a7b61ea4176e67168e383d" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path</source>
          <target state="translated">응용 프로그램 경로와 관련된 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="54e09b22dc0bfd8c0d4977361cbe415e92fbad7a" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path.</source>
          <target state="translated">응용 프로그램 경로와 관련된 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="988d679daebf10d001e25c095b5b9e286e6bc11c" translate="yes" xml:space="preserve">
          <source>Gets how the type is treated inside embeds for the given format.</source>
          <target state="translated">주어진 형식에 대한 임베드 내부에서 유형이 처리되는 방법을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="df3ff2dbf500da7f3bca6907ee8045b12c112c08" translate="yes" xml:space="preserve">
          <source>Gets or generates a CSRF token.</source>
          <target state="translated">CSRF 토큰을 가져 오거나 생성합니다.</target>
        </trans-unit>
        <trans-unit id="997af9359b0274152d5976f8e8ca9230b5813c54" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair</source>
          <target state="translated">주어진 주제와 키 페어에서 현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="48f0745d124d4e83473eebb47a6d31ab2415d144" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair.</source>
          <target state="translated">주어진 주제와 키 페어에서 현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="97e4290574c5ed51caafb10b2de1e172c163410b" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token</source>
          <target state="translated">CSRF 토큰을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="08349fa609238bb75520280fb127235024b0eb68" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct)</source>
          <target state="translated">연결된 URL에 대한 CSRF 토큰을 가져옵니다 (문자열 또는 URI 구조체로).</target>
        </trans-unit>
        <trans-unit id="ff08f49db7e1265b7a0948738482fffe83f058a7" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct).</source>
          <target state="translated">연결된 URL의 CSRF 토큰 (문자열 또는 URI 구조체)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8d4fe3f1095bcbf480568f707f0f32660bfed495" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token.</source>
          <target state="translated">CSRF 토큰을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cacf574b487bbebb0a08dffbbbde22c3caa9dd7c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage</source>
          <target state="translated">플래시 스토리지에서 지정된 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="39a3c0f8225971cc340f65e20abcd3cfd296785c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage.</source>
          <target state="translated">플래시 스토리지에서 지정된 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="96a62524d2bf17765eab415eae3c27d04f1cdf6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field</source>
          <target state="translated">주어진 필드에 대한 입력 유형을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="66f52ba2db0eb578cab960fd32bdb155e164ce6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field.</source>
          <target state="translated">주어진 필드의 입력 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b27071d61374355defa4f7ba87856a1483070f41" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct</source>
          <target state="translated">주어진 구조체에서 메타 데이터를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="678baa7f889b181e04ecd1461201171108459f0b" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct.</source>
          <target state="translated">주어진 구조체에서 메타 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4aa65e24dc6d0d5c51eaeaf4bdd4b579ff2fe71c" translate="yes" xml:space="preserve">
          <source>Gets the store name from an atom or a module.</source>
          <target state="translated">원자 또는 모듈에서 저장소 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1baad63621d111aecd80381a2421d2b880bc0a22" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage</source>
          <target state="translated">전체 플래시 스토리지를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="64814fa71bd4c722ebaa70f584d80370c84fe56a" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage.</source>
          <target state="translated">전체 플래시 저장소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="f418c387ce0535243c1ffc04f850d20578d8ccef" translate="yes" xml:space="preserve">
          <source>Globs can match segments partially too. The difference is the whole segment is captured along with the trailing segments.</source>
          <target state="translated">Glob은 세그먼트도 부분적으로 일치시킬 수 있습니다. 차이점은 전체 세그먼트가 후행 세그먼트와 함께 캡처된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="eef0115acb31caa0fbd5afc01384c4545e7d44b5" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas</source>
          <target state="translated">모든 복제본에 permdown을 브로드 캐스트하여 정상적으로 종료</target>
        </trans-unit>
        <trans-unit id="37401107a71883efc56c3d07974d72873ad8f857" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas.</source>
          <target state="translated">모든 복제본에 permdown을 브로드 캐스트하여 정상적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="7b2bb758deee9a18063c4c798fcdec3e64196126" translate="yes" xml:space="preserve">
          <source>Groups are also supported:</source>
          <target state="translated">그룹도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d16fde456fa6a9274b8f28cf87784f0670263c64" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &quot;groups&quot; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">주어진 필드에 동일한 값을 가진 스키마의 행을 그룹화합니다. 사용 &lt;code&gt;group_by&lt;/code&gt; 쿼리가 그것에게 다른 의미를 부여 &quot;그룹&quot;을 &lt;code&gt;select&lt;/code&gt; 표현식입니다. 쿼리가 그룹화되면 &lt;code&gt;group_by&lt;/code&gt; 에서 참조 된 필드 만 &lt;code&gt;select&lt;/code&gt; 에서 또는 필드가 집계 함수에 대한 인수로 제공되는 경우 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="573359f98da0f46d93ce375944dfc230b3eb131f" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &amp;ldquo;groups&amp;rdquo; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">주어진 필드에서 동일한 값을 가진 스키마의 행을 그룹화합니다. &lt;code&gt;group_by&lt;/code&gt; 를 사용 하여 쿼리를&amp;ldquo;그룹화&amp;rdquo;하면 &lt;code&gt;select&lt;/code&gt; 표현식 에 다른 의미를 부여합니다 . 쿼리가 그룹화되어 있으면에서 참조 된 필드 만 &lt;code&gt;group_by&lt;/code&gt; 에서 사용할 수있는 &lt;code&gt;select&lt;/code&gt; 하거나 필드가 집계 함수에 인수로 주어진다면.</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="c41e81014d243f2d8875ff68c15a184a372a6901" translate="yes" xml:space="preserve">
          <source>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the &lt;code&gt;content-length&lt;/code&gt; header has been set before calling &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2는 청킹을 지원하지 않으며 대신 전송 인코딩없이 응답을 스트리밍합니다. HTTP / 1.1을 사용할 때 카우보이 어댑터는 &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;content-length&lt;/code&gt; 헤더가 설정된 경우 청크를 방출하는 대신 응답을 스트리밍합니다 .</target>
        </trans-unit>
        <trans-unit id="657152afda0bee08d931b261408d17d0b6e96e52" translate="yes" xml:space="preserve">
          <source>Halting a plug pipeline</source>
          <target state="translated">플러그 파이프 라인 정지</target>
        </trans-unit>
        <trans-unit id="1da643070952e956d86d49f8c58821c92fb71c6e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 관련&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9755cdf0347f99433eabcbc87b332485d5af95e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline.</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ccd69770e67bfc169e02509f802dfa9b974fafd" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 정지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 관련&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb6de5553592ef40a29a33d8a4f534ccdca762c0" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline.</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1179f95ead9bf0b9717da1e2ecfd57e128a47608" translate="yes" xml:space="preserve">
          <source>Handle channel joins by &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; 채널 조인을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="c751925f47985ead2c5d331b34495a279ea3f7ba" translate="yes" xml:space="preserve">
          <source>Handle incoming &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">들어오는 &lt;code&gt;event&lt;/code&gt; 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="82f1e20c501a3974e2888a65dd307415f027f8bd" translate="yes" xml:space="preserve">
          <source>Handle regular Elixir process messages.</source>
          <target state="translated">정기적 인 Elixir 프로세스 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="34e4b67d91a6a5a47ead00c473556ef12172e644" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer call messages.</source>
          <target state="translated">일반 GenServer 호출 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0bdffc90c861d354d82cfba6f42150171080724c" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer cast messages.</source>
          <target state="translated">일반 GenServer 캐스트 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f294e1b14ab763746b32a9cdc98d993760a810d1" translate="yes" xml:space="preserve">
          <source>Handles incoming control frames.</source>
          <target state="translated">들어오는 제어 프레임을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7d31dbed02487ad3b79dcccdca1c4517c3e304c7" translate="yes" xml:space="preserve">
          <source>Handles incoming socket messages.</source>
          <target state="translated">들어오는 소켓 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0ad1d4d7277dfbcb95f451d9d6d7bfc9124cb930" translate="yes" xml:space="preserve">
          <source>Handles info messages.</source>
          <target state="translated">정보 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5af19f504ed390f3616fe54d71be3c982a36fb0f" translate="yes" xml:space="preserve">
          <source>Handles the socket connection</source>
          <target state="translated">소켓 연결 처리</target>
        </trans-unit>
        <trans-unit id="5b3b8d6bf0e0ed4f6147a59b927ffe862e49bdc4" translate="yes" xml:space="preserve">
          <source>Handles the socket connection.</source>
          <target state="translated">소켓 연결을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="58514a1474cd3c04b6d7d45448e942f451571bf2" translate="yes" xml:space="preserve">
          <source>Handling of incoming messages</source>
          <target state="translated">수신 메시지 처리</target>
        </trans-unit>
        <trans-unit id="2b9f4508a5e4fc2c2b5ef7294940c248c8c75fd4" translate="yes" xml:space="preserve">
          <source>Handling of outgoing messages</source>
          <target state="translated">발신 메시지 처리</target>
        </trans-unit>
        <trans-unit id="791b3d718f251049300fc903f9b075211bce25f5" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;../plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">처리 요청 데이터는 &lt;a href=&quot;../plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 플러그를 통해 수행 할 수 있습니다 . URL로 인코딩 된, 양식 데이터 및 JSON 데이터를 구문 분석하고 다른 구문 분석기가 채택 할 수있는 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5824e50c0788d6515b063060ac394cb11876c16" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">처리 요청 데이터는 &lt;a href=&quot;plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 플러그를 통해 수행 할 수 있습니다 . URL로 인코딩 된, 양식 데이터 및 JSON 데이터를 구문 분석하고 다른 구문 분석기가 채택 할 수있는 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c698c3591147b68316110c515f5214cf7d5b3183" translate="yes" xml:space="preserve">
          <source>Having different precisions allows developers to choose a type that will be compatible with the database and your project's precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">다른 정밀도를 사용하면 개발자가 데이터베이스 및 프로젝트의 정밀도 요구 사항과 호환되는 유형을 선택할 수 있습니다. 예를 들어, 일부 이전 버전의 MySQL은 datetime 필드에서 마이크로 초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87609125a9917f1d1304583fa33c13ec60b69a2f" translate="yes" xml:space="preserve">
          <source>Having these different types allows developers to choose a type that will be compatible with the database and your project&amp;rsquo;s precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">이러한 다른 유형을 사용하면 개발자는 데이터베이스 및 프로젝트의 정밀 요구 사항과 호환되는 유형을 선택할 수 있습니다. 예를 들어, 일부 이전 버전의 MySQL은 날짜 시간 필드에서 마이크로 초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="2a35b8be1233091ad5332bbf56f5dc2f7b98ac70" translate="yes" xml:space="preserve">
          <source>Helpers are automatically generated based on the controller name. For example, the route:</source>
          <target state="translated">헬퍼는 컨트롤러 이름에 따라 자동으로 생성됩니다. 예를 들어 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42e29e501e0e0abe2c6edb0ec3f800ed7c669e6a" translate="yes" xml:space="preserve">
          <source>Helpers related to formatting text.</source>
          <target state="translated">텍스트 서식과 관련된 도우미.</target>
        </trans-unit>
        <trans-unit id="0d4c3aa7d2de3e04c2fa70e9a23a0cc750641d4a" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML forms.</source>
          <target state="translated">HTML 양식 생성과 관련된 도우미</target>
        </trans-unit>
        <trans-unit id="8d3f6ca83c967080b0bd89bc34ea0c0450fad6f1" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML tags within templates.</source>
          <target state="translated">템플릿 내에서 HTML 태그 생성과 관련된 도우미.</target>
        </trans-unit>
        <trans-unit id="1ae61dee0e45488052c0b40f12b8925406d54456" translate="yes" xml:space="preserve">
          <source>Here is a quick introduction into Phoenix templates terms:</source>
          <target state="translated">다음은 Phoenix 템플릿 용어에 대한 간략한 소개입니다.</target>
        </trans-unit>
        <trans-unit id="c1764c5d537b9f3a319ae1d976d0b1ca9635f544" translate="yes" xml:space="preserve">
          <source>Here is a simple echo socket implementation:</source>
          <target state="translated">다음은 간단한 에코 소켓 구현입니다.</target>
        </trans-unit>
        <trans-unit id="9a0608a11c75facb6614fa80af338062303f83e9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">다음은 POST 요청의 JSON 인코딩 본문을 구문 분석하기 위해 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; 라우터 에서 사용할 수있는 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="9cdd2430bc9221c06b037fdb8209b829394de4f3" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;plug.router#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">다음의 예 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; 는&lt;/a&gt; (A)에 사용될 수 &lt;a href=&quot;plug.router#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; 의&lt;/a&gt; POST 요청의 JSON 인코딩 체를 파싱 라우터 :</target>
        </trans-unit>
        <trans-unit id="cf8a0f224b439f3a7c58360fbb55ef423905c7d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how both modules could be used in an application:</source>
          <target state="translated">다음은 응용 프로그램에서 두 모듈을 모두 사용하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="514a051b8ea91a8358dacf4b2fa3b9efa3ab46e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a function plug:</source>
          <target state="translated">다음은 함수 플러그의 예입니다.</target>
        </trans-unit>
        <trans-unit id="afa6cca227f184cb839f4bb2a488e237e45cbd46" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a module plug:</source>
          <target state="translated">다음은 모듈 플러그의 예입니다.</target>
        </trans-unit>
        <trans-unit id="294bc9dc3de330e00af0c679783e2c3ab4b482ed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">다음 은 한 클라이언트에서 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 이벤트를 수신 하여이 소켓의 모든 주제 구독자에게 메시지를 브로드 캐스트하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2010f6be3cd1e0728d571d7959a93b42f107f411" translate="yes" xml:space="preserve">
          <source>Here's an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">다음 은 한 클라이언트로부터 수신 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 이벤트를 수신 하고이 소켓의 모든 토픽 구독자에게 메시지를 브로드 캐스팅 하는 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="172de218d867931358663fe72b49811c80d28ce7" translate="yes" xml:space="preserve">
          <source>Here, a request to &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; will be forwarded to the &lt;code&gt;FooPlug&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; will be set to &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; 에 대한 요청 은 &lt;code&gt;FooPlug&lt;/code&gt; 플러그 로 전달되며, FooPlug 플러그는 &lt;code&gt;/&lt;/code&gt; 에 대한 요청으로 표시되는 것을 수신 하고 &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; 는 &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e78f354796364ef7c67c1020994e22a118885793" translate="yes" xml:space="preserve">
          <source>Hibernation</source>
          <target state="translated">Hibernation</target>
        </trans-unit>
        <trans-unit id="5b3268c27e7d59601c440ed37c24688618bcf6ca" translate="yes" xml:space="preserve">
          <source>Hidden fields</source>
          <target state="translated">숨겨진 필드</target>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="c9bd403a4e9a302e8f2ed9f94925a54db8a68b9f" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won&amp;rsquo;t be set by Ecto:</source>
          <target state="translated">마이그레이션을 구성하는 방법은 &lt;code&gt;:join_through&lt;/code&gt; 에 전달하는 값에 따라 다릅니다 . 경우 &lt;code&gt;:join_through&lt;/code&gt; 테이블을 나타내는, 단순히 문자열, 당신은 기본 키가없는 테이블을 정의 할 수 있으며, 그 값이 체외로 설정되지 않습니다 당신은 더 열을 포함하지 않아야합니다 :</target>
        </trans-unit>
        <trans-unit id="e772dd16864f540c21adae4eff7d05aac5466700" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won't be set by Ecto:</source>
          <target state="translated">마이그레이션을 구성하는 방법은 전달하는 값에 따라 다릅니다 . &lt;code&gt;:join_through&lt;/code&gt; . 경우 &lt;code&gt;:join_through&lt;/code&gt; 테이블을 나타내는, 단순히 문자열, 당신은 기본 키가없는 테이블을 정의 할 수 있으며, 그 값이 체외로 설정되지 않습니다 당신은 더 열을 포함하지 않아야합니다 :</target>
        </trans-unit>
        <trans-unit id="fde9c228238451fde38808e6b71a5f4e8db27470" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &quot;?vsn=&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 버전이 지정된 쿼리 문자열을 사용하여 직접 캐시 제어도 지원합니다. 요청 쿼리 문자열이 &quot;? vsn =&quot;로 시작하는 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 애플리케이션이 버전 관리 자산이라고 가정하고 &lt;code&gt;ETag&lt;/code&gt; 헤더를 설정하지 않습니다 . 즉, 캐시 동작은 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 구성에 의해서만 지정 되며 기본값은 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca34d2ca00362f79bd18266ad0ec21713be1edf" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &amp;ldquo;?vsn=&amp;rdquo;, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 버전이 지정된 쿼리 문자열을 사용하여 직접 캐시 제어를 지원합니다. 요청 쿼리 문자열이 &quot;? vsn =&quot;으로 시작하는 경우 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 응용 프로그램이 버전 자산이며 &lt;code&gt;ETag&lt;/code&gt; 헤더를 설정하지 않는다고 가정합니다 . 즉, 캐시 동작은 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 구성에 의해서만 지정 되며 기본값은 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92b6ba6983e86cfb8b7f8a1c8aa387837993e78b" translate="yes" xml:space="preserve">
          <source>However, because constraints are only checked if all validations succeed, this function can be used as an early check to provide early feedback to users, since most conflicting data will have been inserted prior to the current validation phase.</source>
          <target state="translated">그러나 모든 유효성 검사가 성공한 경우에만 제약 조건을 검사하므로이 기능은 대부분의 충돌하는 데이터가 현재 유효성 검사 단계 이전에 삽입되었으므로 사용자에게 조기 피드백을 제공하기위한 조기 검사로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b56ea8eef111a454a3af358d1c8df493c3834e" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &quot;regular&quot; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">그러나 변경 집합은 데이터 및 해당 유형과 함께 튜플을 전달하여 &quot;일반&quot;구조체에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d4b9ddb4851e5cb9caec7c806e9ed043982b19" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &amp;ldquo;regular&amp;rdquo; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">그러나 변경 세트는 데이터 및 해당 유형과 함께 튜플을 전달하여 &quot;일반&quot;구조체와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c75a911a92357bb55a72a4f5cda6890aa2fa06e" translate="yes" xml:space="preserve">
          <source>However, developers can use the preload functionality in queries to automatically pre-populate the field:</source>
          <target state="translated">그러나 개발자는 쿼리에서 사전로드 기능을 사용하여 필드를 자동으로 미리 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e072c9f502e82c76107b9c680016ea26f2459bff" translate="yes" xml:space="preserve">
          <source>However, for convenience, this protocol can also be derivable. For example:</source>
          <target state="translated">그러나 편의상이 프로토콜을 파생 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2e281662c4868a83f42fe2d3a37e4b42a7ba94d" translate="yes" xml:space="preserve">
          <source>However, if the client had sent an expired or otherwise invalid token &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; would have returned an error instead:</source>
          <target state="translated">그러나 클라이언트가 만료되었거나 유효하지 않은 토큰을 보낸 경우 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 는 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06e4154438c600a0964d2ae325cad0bcb77711e5" translate="yes" xml:space="preserve">
          <source>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</source>
          <target state="translated">그러나 위의 구조체를 유지하려고 시도하면 Ecto가 유형을 어댑터 / 데이터베이스로 보낼 때 유형을 확인하므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6beb14dbb92a9c5566dff520724cf6035e375bf3" translate="yes" xml:space="preserve">
          <source>However, if you want all generated URLs to always have a certain schema, host, etc, you may use &lt;a href=&quot;#put_router_url/2&quot;&gt;&lt;code&gt;put_router_url/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 생성 된 모든 URL이 항상 특정 스키마, 호스트 등을 &lt;a href=&quot;#put_router_url/2&quot;&gt; &lt;code&gt;put_router_url/2&lt;/code&gt; &lt;/a&gt; 하려면 put_router_url / 2를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92a0deea3d522aed6c2af612ee37d11179610223" translate="yes" xml:space="preserve">
          <source>However, if your &lt;code&gt;:join_through&lt;/code&gt; is a schema, like &lt;code&gt;MyApp.PostTag&lt;/code&gt;, your join table may be structured as any other table in your codebase, including timestamps:</source>
          <target state="translated">귀하의 경우, &lt;code&gt;:join_through&lt;/code&gt; 이 같은 스키마입니다 &lt;code&gt;MyApp.PostTag&lt;/code&gt; 가 , 당신의 가입 테이블은 타임 스탬프를 포함하여 코드베이스의 다른 테이블로 구성 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="5054280086d854890f69bc24ac26fee32ed61037" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won&amp;rsquo;t be removed, leading to a query that won&amp;rsquo;t compile.</source>
          <target state="translated">그러나 조인이 제거되고 바인딩이 다른 곳에서 참조 된 경우 바인딩이 제거되지 않아 쿼리가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c145dbff75201402ee148458f35b3b4df8ec98" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won't be removed, leading to a query that won't compile.</source>
          <target state="translated">그러나 조인이 제거되고 해당 바인딩이 다른 곳에서 참조 된 경우 바인딩이 제거되지 않아 쿼리가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="418e05e8a16e7c15648cf7bdddb205991c4f4a14" translate="yes" xml:space="preserve">
          <source>However, most commonly, structs are cast, validated and manipulated with the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">그러나 가장 일반적으로 구조체는 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 캐스팅, 유효성 검사 및 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c15cb8377f6937f642e813f984385d51f7b4176e" translate="yes" xml:space="preserve">
          <source>However, note that defining a window is not necessary, as the window definition can be given as the second argument to &lt;code&gt;over&lt;/code&gt;:</source>
          <target state="translated">그러나 window 정의는 &lt;code&gt;over&lt;/code&gt; 에 대한 두 번째 인수로 제공 될 수 있으므로 window 정의는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="089510bf5810bca9d96388384533d0538018252e" translate="yes" xml:space="preserve">
          <source>However, once the repository is started, you can't directly interact with it, since all operations in &lt;code&gt;MyApp.Repo&lt;/code&gt; are sent by default to the repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;. You can change the default repo at compile time with:</source>
          <target state="translated">그러나 일단 저장소가 시작되면 &lt;code&gt;MyApp.Repo&lt;/code&gt; 의 모든 작업 이 기본적으로 &lt;code&gt;MyApp.Repo&lt;/code&gt; 라는 저장소로 전송되므로 저장소 와 직접 상호 작용할 수 없습니다 . 컴파일 시간에 다음을 사용하여 기본 저장소를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94de3aba560958a631f7ce9430b591344ccd7fee" translate="yes" xml:space="preserve">
          <source>However, we don't advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="translated">그러나 다른 엔드 포인트로 전달하는 것은 권장하지 않습니다. 그 이유는 앱과 전달 된 엔드 포인트에서 정의한 플러그가 두 번 호출되어 오류가 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="69818f21f7d2e8e3d4c95d045561623815bfdb97" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection</source>
          <target state="translated">소켓 연결을 식별합니다</target>
        </trans-unit>
        <trans-unit id="a1248f63e6d463c737ae4f281ae99a7acd6c280d" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection.</source>
          <target state="translated">소켓 연결을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c2b9e9831550c1277fc0f8c66e430ed4b934322f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:transaction/2&quot;&gt;&lt;code&gt;transaction/2&lt;/code&gt;&lt;/a&gt; is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:transaction/2&quot;&gt; &lt;code&gt;transaction/2&lt;/code&gt; &lt;/a&gt; 다른 트랜잭션 내에서 호출되는 함수는 단순히 어떤 방식으로 새로운 트랜잭션 호출을 포장하지 않고 실행됩니다. 내부 트랜잭션에 오류가 있고 오류가 복구되거나 내부 트랜잭션이 롤백되면 전체 외부 트랜잭션이 오염 된 것으로 표시되어 커밋 된 것이 없음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="48bb3facdf6a618d730a68a131d48750e21adc3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:init_opts&lt;/code&gt; is undefined, then all remaining options are passed to the target plug.</source>
          <target state="translated">&lt;code&gt;:init_opts&lt;/code&gt; 가 정의되지 않은 경우 나머지 모든 옵션이 대상 플러그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b518d769ddb0e8a385ef70577decbd4185956c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:select_merge&lt;/code&gt; is called and there is no value selected previously, it will default to the source, &lt;code&gt;p&lt;/code&gt; in the example above.</source>
          <target state="translated">경우 &lt;code&gt;:select_merge&lt;/code&gt; 가 전화해서 이전에 선택한 값이없는, 그것은 소스로 기본 설정됩니다 &lt;code&gt;p&lt;/code&gt; 위의 예이다.</target>
        </trans-unit>
        <trans-unit id="39bb4cb75be5b52a2198bb0576f54f0e0ede32c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won&amp;rsquo;t specify a charset.</source>
          <target state="translated">경우 &lt;code&gt;charset&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,의 값 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 응답 헤더는 문자 집합을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0675b7cae7347e027b29d7d61cb63f9f1413731c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won't specify a charset.</source>
          <target state="translated">경우 &lt;code&gt;charset&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,의 값 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 응답 헤더는 문자 집합을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a05c265ccb7acfd4d24ba0e20a24a92a6ce9889f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;limit&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">경우 &lt;code&gt;limit&lt;/code&gt; 두 번 주어, 그것은 이전의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e957bc885302ec7685e98cd24a82719aa373a888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is used more than once, the last one used takes precedence.</source>
          <target state="translated">경우 &lt;code&gt;lock&lt;/code&gt; 두 번 이상 사용되며, 마지막으로 사용한 사람은 우선합니다.</target>
        </trans-unit>
        <trans-unit id="90da74aa2f941149e52e2553f73747df1e9ff078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nil&lt;/code&gt; is given as id, a new session id should be generated and returned.</source>
          <target state="translated">경우 &lt;code&gt;nil&lt;/code&gt; ID로 주어진 새로운 세션 ID를 생성하여 반환한다.</target>
        </trans-unit>
        <trans-unit id="7d493634e419d6aa39da5fc4a5f636e40e36f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;offset&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">경우 &lt;code&gt;offset&lt;/code&gt; 두 번 주어, 그것은 이전의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="972e323b8fae502f4935411636b7be015afc29ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is map or keyword list where the first element is a string, atom or integer and the second element is a list or a map, it is assumed the key will be wrapped in an &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; and the value will be used to generate &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; nested under the group.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 첫 번째 요소는 문자열 원자 또는 정수 번째 요소 맵 또는 키워드 목록은 목록 또는 맵이다이를 키 래핑한다 상정되는 &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; 상기 값 생성하는데 사용될 &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; 은 그룹 아래에 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="a3421dda344b70b936418fb88ce89a791460b02d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_action&lt;/code&gt; is a string, it is considered to be the request path and stored as so in the connection. If an atom, it is assumed to be an action and the connection is dispatched to the given action.</source>
          <target state="translated">경우 &lt;code&gt;path_or_action&lt;/code&gt; 은 문자열입니다, 요청 경로로 간주하고 연결에 있도록 저장됩니다. 원자 인 경우, 조치 인 것으로 가정하고 연결이 지정된 조치로 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="b9c8f702bb6c0810a48712a7631f4ec240983313" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is &lt;code&gt;:closed&lt;/code&gt;, it means the client closed the socket. This is considered a &lt;code&gt;:normal&lt;/code&gt; exit signal, so linked process will not automatically exit. See &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt;&lt;code&gt;Process.exit/2&lt;/code&gt;&lt;/a&gt; for more details on exit signals.</source>
          <target state="translated">경우에는 &lt;code&gt;reason&lt;/code&gt; 있다 &lt;code&gt;:closed&lt;/code&gt; , 그것은 클라이언트가 소켓을 닫을 것을 의미한다. 이것은 &lt;code&gt;:normal&lt;/code&gt; 종료 신호 로 간주 되므로 연결된 프로세스가 자동으로 종료되지 않습니다. 종료 신호에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt; &lt;code&gt;Process.exit/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11e582e3374d4e382af5d6f29d1086454023de04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the header is checked against &lt;code&gt;:host&lt;/code&gt; in &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt;. If &lt;code&gt;false&lt;/code&gt;, your app is vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. Only use in development, when the host is truly unknown or when serving clients that do not send the &lt;code&gt;origin&lt;/code&gt; header, such as mobile apps. You can also specify a list of explicitly allowed origins. Wildcards are supported.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 헤더에 대해 확인 &lt;code&gt;:host&lt;/code&gt; 에 &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt; . 경우 &lt;code&gt;false&lt;/code&gt; 앱은 크로스 사이트 웹 소켓 하이재킹 (CSWSH) 공격에 취약합니다. 호스트가 실제로 알려지지 않은 경우 또는 모바일 앱과 같이 &lt;code&gt;origin&lt;/code&gt; 헤더를 전송하지 않는 클라이언트를 제공 할 때만 개발에 사용 합니다. 명시 적으로 허용 된 출처 목록을 지정할 수도 있습니다. 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="abf67ea57ee4ce23434afd8c43be52701544068b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; is given, it means the query can be cached and it must be cached by calling the &lt;code&gt;cache_function&lt;/code&gt; function with the cache entry of your choice. Once &lt;code&gt;cache_function&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cached&lt;/code&gt; tuple.</source>
          <target state="translated">만약 &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; 주어집니다, 그것은 쿼리가 캐시 될 수 있음을 의미하고이 호출에 의해 캐시해야 &lt;code&gt;cache_function&lt;/code&gt; 의 선택의 캐시 항목과 기능을. &lt;code&gt;cache_function&lt;/code&gt; 이 호출 되면 다음에 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; 에&lt;/a&gt; 동일한 쿼리가 제공 될 때 &lt;code&gt;:cached&lt;/code&gt; 튜플을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="1309c121da20f5187a51a6961ffb575f0b7cff39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; is given, it means the query has been cached. You may call &lt;code&gt;update_function/1&lt;/code&gt; if you want to update the cached result. Or you may call &lt;code&gt;reset_function/1&lt;/code&gt;, with a new prepared query, to force the query to be cached again. If &lt;code&gt;reset_function/1&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cache&lt;/code&gt; tuple.</source>
          <target state="translated">경우 &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; 주어집니다, 그것은 쿼리 캐시되었음을 의미합니다. 캐시 된 결과를 업데이트하려면 &lt;code&gt;update_function/1&lt;/code&gt; 을 호출 할 수 있습니다. 또는 새로 준비된 쿼리와 함께 &lt;code&gt;reset_function/1&lt;/code&gt; 을 호출 하여 쿼리를 다시 캐시하도록 할 수 있습니다. 경우 &lt;code&gt;reset_function/1&lt;/code&gt; 라고하며, 다음 번에이 같은 쿼리를 위해 주어진다 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt; , 그것은받을 &lt;code&gt;:cache&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="e417833516d635fb72f5c63c1ffab31f552e12db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:nocache, prepared}&lt;/code&gt; is given, it means the query was not and cannot be cached. The &lt;code&gt;prepared&lt;/code&gt; value is the value returned by &lt;a href=&quot;#c:prepare/2&quot;&gt;&lt;code&gt;prepare/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{:nocache, prepared}&lt;/code&gt; 주어, 그것은 쿼리가 아니었고 캐시 할 수 없음을 의미합니다. &lt;code&gt;prepared&lt;/code&gt; 값에 의해 리턴 된 값 &lt;a href=&quot;#c:prepare/2&quot;&gt; &lt;code&gt;prepare/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98796a5ac95043dc0bbdaf9869321de0caf5c9b9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">경우 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 의 환경 변수가 설정되어, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; 는&lt;/a&gt; 텍스트 편집기에 대한 링크를 생성하는 데 사용합니다. 변수는 올바르게 대체 될 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 자리 표시 자로 설정되어야합니다 . 예 ( &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; 편집기 사용) :</target>
        </trans-unit>
        <trans-unit id="3917143de35bdf1d2e86820a8a552e7dc5784eb2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">경우 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 의 환경 변수가 설정되어, &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; 는&lt;/a&gt; 텍스트 편집기에 대한 링크를 생성하는 데 사용합니다. 변수는 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 자리 표시 자로 설정해야 하며 올바르게 대체됩니다. 예를 들어 ( &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; 편집기 사용) :</target>
        </trans-unit>
        <trans-unit id="f871e965d2407597bc5715cea4f0ab94f714d6e5" translate="yes" xml:space="preserve">
          <source>If a control frame doesn't have a payload, then the payload value will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">제어 프레임에 페이로드가없는 경우 페이로드 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb554a564dd3cf44251ab909d1682e6cddc415a6" translate="yes" xml:space="preserve">
          <source>If a cookie is invalid, it is automatically discarded from the result.</source>
          <target state="translated">쿠키가 유효하지 않으면 결과에서 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3710000536ae0ecb682a86fbf651cc12761ba83e" translate="yes" xml:space="preserve">
          <source>If a field is given to &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; but it has not been passed as parameter during &lt;a href=&quot;#cast/3&quot;&gt;&lt;code&gt;cast/3&lt;/code&gt;&lt;/a&gt; (i.e. it has not been changed), then &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; will check for its current value in the data. If the data contains an non-empty value for the field, then no error is added. This allows developers to use &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; to perform partial updates. For example, on &lt;code&gt;insert&lt;/code&gt; all fields would be required, because their default values on the data are all &lt;code&gt;nil&lt;/code&gt;, but on &lt;code&gt;update&lt;/code&gt;, if you don't want to change a field that has been previously set, you are not required to pass it as a paramater, since &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; won't add an error for missing changes as long as the value in the data given to the &lt;code&gt;changeset&lt;/code&gt; is not empty.</source>
          <target state="translated">필드가 &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; 에 제공&lt;/a&gt; 되었지만 &lt;a href=&quot;#cast/3&quot;&gt; &lt;code&gt;cast/3&lt;/code&gt; &lt;/a&gt; 중에 매개 변수로 전달되지 않은 경우 (즉, 변경되지 않은 경우) &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 는 데이터에서 현재 값을 확인합니다. 데이터에 비어 있지 않은 필드 값이 포함되어 있으면 오류가 추가되지 않습니다. 이를 통해 개발자는 &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 부분 업데이트를 수행 할 수 있습니다. 예를 들어, 데이터의 기본값이 모두 &lt;code&gt;nil&lt;/code&gt; 이기 때문에 &lt;code&gt;insert&lt;/code&gt; 모든 필드가 필요 하지만 &lt;code&gt;update&lt;/code&gt; 이전에 설정된 필드를 변경하지 않으려면 다음과 같이 전달할 필요가 없습니다. &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 이후 매개 변수변경 세트에 제공된 데이터의 값 이 비어 있지 않은 한 &lt;code&gt;changeset&lt;/code&gt; 사항 누락에 대한 오류를 추가 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b5748e7fd13f50e04ab4f92ee369e7bef4e0182" translate="yes" xml:space="preserve">
          <source>If a file is uploaded via any of the parsers, Plug will stream the uploaded contents to a file in a temporary directory in order to avoid loading the whole file into memory. For such, the &lt;code&gt;:plug&lt;/code&gt; application needs to be started in order for file uploads to work. More details on how the uploaded file is handled can be found in the documentation for &lt;a href=&quot;plug.upload&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파서를 사용하여 파일을 업로드하는 경우 Plug는 전체 파일을 메모리로로드하지 않도록 업로드 된 내용을 임시 디렉토리의 파일로 스트리밍합니다. 파일 업로드가 작동 하려면 &lt;code&gt;:plug&lt;/code&gt; 응용 프로그램을 시작해야합니다. 업로드 된 파일을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;plug.upload&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9a66f3d4a76267cf3daa797fca21dffb2926bba" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &quot;x-request-id&quot; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">요청 ID가 &quot;x-request-id&quot;HTTP 요청 헤더로 이미 존재하는 경우 해당 값은 20 자에서 200 자 사이라고 가정하여 사용됩니다. 그렇지 않은 경우 새 요청 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4d7c53872729839a77bd5a96d38cb274491289" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &amp;ldquo;x-request-id&amp;rdquo; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">요청 ID가 이미 &quot;x-request-id&quot;HTTP 요청 헤더로 존재하는 경우 해당 값은 20 자에서 200 자 사이 인 것으로 가정하여 사용됩니다. 그렇지 않은 경우 새 요청 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0a43716c3aaf07a4683f32a558be906bc63cdf44" translate="yes" xml:space="preserve">
          <source>If a source is given, without a schema module, the given fields are passed as is to the adapter.</source>
          <target state="translated">스키마 모듈없이 소스가 제공되면 제공된 필드는 그대로 어댑터에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e0fcc0fd0de1b3c59c0bc9f15d6ba587aeb25386" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">정적 자산을 찾을 수없는 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 연결을 나머지 파이프 라인으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="43529dcc9122748af804be0c58edc57e0c307b24" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">정적 자산을 찾을 수없는 경우 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; 은&lt;/a&gt; 단순히 연결을 나머지 파이프 라인으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5ad05d6344b5d56c40d9d05868bbe0fc447a1ebc" translate="yes" xml:space="preserve">
          <source>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; and wrapped in the &lt;a href=&quot;ecto.subquery&quot;&gt;&lt;code&gt;Ecto.SubQuery&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">하위 쿼리가 제공되면 하위 쿼리 자체를 반환합니다. 다른 값이 제공되면 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; 을&lt;/a&gt; 통해 쿼리로 변환되어 &lt;a href=&quot;ecto.subquery&quot;&gt; &lt;code&gt;Ecto.SubQuery&lt;/code&gt; &lt;/a&gt; 구조체에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="d48ba6ea6ec7ffa263a8d1a43b7dcdf2efa2753d" translate="yes" xml:space="preserve">
          <source>If a token exists, it is returned, otherwise it is generated and stored in the process dictionary.</source>
          <target state="translated">토큰이 존재하면 반환되고, 그렇지 않으면 생성되어 프로세스 사전에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9b893693b1726f40ddda25b9dd0c70ab3cfa2216" translate="yes" xml:space="preserve">
          <source>If a value is given more than once, the last value takes precedence:</source>
          <target state="translated">값이 두 번 이상 제공되면 마지막 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="eaddcc5aa1077f7a26eab071fe7684352cdb0d24" translate="yes" xml:space="preserve">
          <source>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling &lt;a href=&quot;#c:rollback/1&quot;&gt;&lt;code&gt;rollback/1&lt;/code&gt;&lt;/a&gt;, this will immediately leave the function and return the value given to &lt;code&gt;rollback&lt;/code&gt; as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">처리되지 않은 오류가 발생하면 트랜잭션이 롤백되고 트랜잭션 기능에서 오류가 발생합니다. 오류가 발생하지 않으면 함수가 리턴 될 때 트랜잭션이 커미트됩니다. &lt;a href=&quot;#c:rollback/1&quot;&gt; &lt;code&gt;rollback/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 트랜잭션을 명시 적으로 롤백 할 수 있습니다 .이 함수는 즉시 함수를 그대로두고 &lt;code&gt;rollback&lt;/code&gt; 제공된 값 을 &lt;code&gt;{:error, value}&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="153b8768ac116a6059a08945ee6b26d18eec128a" translate="yes" xml:space="preserve">
          <source>If any of the callbacks return a &lt;code&gt;:stop&lt;/code&gt; tuple, it will also trigger terminate with the reason given in the tuple.</source>
          <target state="translated">콜백 중 하나가 &lt;code&gt;:stop&lt;/code&gt; 튜플을 반환하면 튜플에 주어진 이유로 종료를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a8b20d463cde7b903560b17334ed7d36242c5f45" translate="yes" xml:space="preserve">
          <source>If available, the file is sent directly over the socket using the operating system &lt;code&gt;sendfile&lt;/code&gt; operation.</source>
          <target state="translated">사용 가능한 경우 운영 체제 &lt;code&gt;sendfile&lt;/code&gt; 조작을 사용하여 파일이 소켓을 통해 직접 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="82f8819da3536b2ff1e621e91a5108e31f33c3f5" translate="yes" xml:space="preserve">
          <source>If casting of all fields is successful, the changeset is returned as valid.</source>
          <target state="translated">모든 필드를 성공적으로 캐스팅하면 변경 집합이 유효한 것으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8943a6555280626edd3a71e646c2c513ffe092f9" translate="yes" xml:space="preserve">
          <source>If changing the JSON library, remember to recompile the adapter afterwards by cleaning the current build:</source>
          <target state="translated">JSON 라이브러리를 변경하는 경우 현재 빌드를 정리하여 어댑터를 나중에 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9d661e3bc80c3727f4d8b3225ce99bc171f66095" translate="yes" xml:space="preserve">
          <source>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</source>
          <target state="translated">어떤 이유로 데이터베이스에서 대소 문자를 구분하지 않는 열을 지원하지 않는 경우 값을 삽입 / 업데이트하기 전에 명시 적으로 소문자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a9f7927001d081a57717076667b9d7a6f459c0" translate="yes" xml:space="preserve">
          <source>If interpolating keyword lists, the keyword list entries are combined using ANDs and joined to any existing expression with an OR:</source>
          <target state="translated">키워드 목록을 보간하는 경우 AND를 사용하여 키워드 목록 항목을 결합하고 OR을 사용하여 기존 표현식에 조인합니다.</target>
        </trans-unit>
        <trans-unit id="76cef5435664170ccd219b3f7c9c0adfb90f5be5" translate="yes" xml:space="preserve">
          <source>If it is a keyword query the first argument must be either an &lt;code&gt;in&lt;/code&gt; expression, or a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. If the query needs a reference to the data source in any other part of the expression, then an &lt;code&gt;in&lt;/code&gt; must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</source>
          <target state="translated">키워드 쿼리 인 경우 첫 번째 인수는 &lt;code&gt;in&lt;/code&gt; 식이거나 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 값 이어야 합니다. 쿼리에서 표현식의 다른 부분에서 데이터 소스에 대한 참조가 필요한 경우 &lt;code&gt;in&lt;/code&gt; 을 사용하여 참조 변수를 작성해야합니다. 두 번째 인수는 키가 표현식 유형이고 값이 표현식 인 키워드 쿼리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e167dc3c73586f0621a46fd98ad4b4b1f1bc7e6b" translate="yes" xml:space="preserve">
          <source>If it is a query expression the first argument must be a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol and the second argument the expression.</source>
          <target state="translated">쿼리 식인 경우 첫 번째 인수는 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 값이어야 하고 두 번째 인수는 식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f2004e501e574e9ee412f8a4a483f6b11c68baa6" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won&amp;rsquo;t even be started and the error will be immediately returned.</source>
          <target state="translated">multi에 변경 세트를 받아들이는 오퍼레이션 ( &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; 등&lt;/a&gt; )이 포함 된 경우 트랜잭션을 시작하기 전에 확인됩니다. 변경 세트에 오류가 있으면 트랜잭션이 시작되지 않고 오류가 즉시 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="63d39ee63729141787866693d23e5982b3dfbe19" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won't even be started and the error will be immediately returned.</source>
          <target state="translated">multi에 변경 집합을 허용하는 작업 (예 : &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt; )이 포함 된 경우 트랜잭션을 시작하기 전에 확인됩니다. 변경 세트에 오류가 있으면 트랜잭션이 시작되지 않고 오류가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="636fecfc6c19833110f980b78af43a7ddc1683cf" translate="yes" xml:space="preserve">
          <source>If no action has been applied to the changeset or action was set to &lt;code&gt;:ignore&lt;/code&gt;, no errors are shown on the form object even if the changeset has a non-empty &lt;code&gt;:errors&lt;/code&gt; value.</source>
          <target state="translated">변경 세트에 조치가 적용되지 않았거나 조치가 &lt;code&gt;:ignore&lt;/code&gt; 로 설정된 경우, 변경 세트에 비어 있지 않은 &lt;code&gt;:errors&lt;/code&gt; 값 이 있어도 양식 오브젝트에 오류가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cf26fadc638285a0643bc477b2beb4a0a2ba425c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket&amp;rsquo;s handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">채널 모듈이 제공되지 않으면 소켓의 핸들러는 주어진 주제에 맞는 채널을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a628119141d05e629bf0a8766bdd3134096279c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket's handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">채널 모듈이 제공되지 않으면 소켓의 핸들러를 사용하여 주어진 주제에 대해 일치하는 채널을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="b2947103d7b79f0495b72a656cc81700719a03f4" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang&amp;rsquo;s &lt;code&gt;ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit &amp;lsquo;group 14&amp;rsquo; from RFC 3526.</source>
          <target state="translated">사용자 지정 매개 변수를 지정하지 않으면 Erlang의 &lt;code&gt;ssl&lt;/code&gt; 은 기본 제공 기본값을 사용합니다. OTP 19 이후 이것은 RFC 3526의 2048 비트 '그룹 14'입니다.</target>
        </trans-unit>
        <trans-unit id="030bd22aca683fa25d2f90bbb7143785a15622d3" translate="yes" xml:space="preserve">
          <source>If no data type is given, it defaults to a string.</source>
          <target state="translated">데이터 유형이 제공되지 않으면 기본값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ad19118a3e502181cda3b94015f8e221a2d0b2b8" translate="yes" xml:space="preserve">
          <source>If no path is given, it will use &lt;code&gt;priv/static&lt;/code&gt; as the input and output path.</source>
          <target state="translated">경로를 지정하지 않으면 입력 / 출력 경로로 &lt;code&gt;priv/static&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="8d9d3c05f3dd12de1de5d07c7780f6542cae6c1f" translate="yes" xml:space="preserve">
          <source>If no repo option is given, it is retrieved from the application environment.</source>
          <target state="translated">저장소 옵션이 제공되지 않으면 응용 프로그램 환경에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="ac423aab6755d9973153fe985b209449ba726adf" translate="yes" xml:space="preserve">
          <source>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, &lt;code&gt;distinct&lt;/code&gt; accepts exactly the same expressions as &lt;code&gt;order_by&lt;/code&gt; and any &lt;code&gt;distinct&lt;/code&gt; expression will be automatically prepended to the &lt;code&gt;order_by&lt;/code&gt; expressions in case there is any &lt;code&gt;order_by&lt;/code&gt; expression.</source>
          <target state="translated">데이터베이스에서 지원하는 경우 쿼리 표현식을 고유하게 전달할 수 있으며 DISTINCT ON을 사용하여 쿼리를 생성합니다. 이러한 경우, &lt;code&gt;distinct&lt;/code&gt; 정확히 같은 표현을 허용 &lt;code&gt;order_by&lt;/code&gt; 하고 &lt;code&gt;distinct&lt;/code&gt; 표현이 자동으로 붙을 &lt;code&gt;order_by&lt;/code&gt; 의 모든이 경우에 표현 &lt;code&gt;order_by&lt;/code&gt; 의 식입니다.</target>
        </trans-unit>
        <trans-unit id="70216b8d4897b8cf4c5ab39916317d1da5fb0d73" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback is implemented in the repository, it will be invoked with the first argument set to &lt;code&gt;:runtime&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 콜백이 저장소에 구현되어, 그것은에 첫 번째 인수 세트로 호출됩니다 &lt;code&gt;:runtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbad62ac0f0e10ca6a55f7468a042cab7daca496" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:sign&lt;/code&gt; or &lt;code&gt;:encrypt&lt;/code&gt; flag are given, then the cookie value can be any term.</source>
          <target state="translated">경우 &lt;code&gt;:sign&lt;/code&gt; 나 &lt;code&gt;:encrypt&lt;/code&gt; 플래그가 지정되어, 다음 쿠키 값은 용어가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9712dc6b620700aa8412aa4754ed6dd3e600a162" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;required_key&lt;/code&gt; is not present, it will raise &lt;a href=&quot;phoenix.missingparamerror&quot;&gt;&lt;code&gt;Phoenix.MissingParamError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;required_key&lt;/code&gt; 이 존재하지 않는, 그것은 올릴 것이다 &lt;a href=&quot;phoenix.missingparamerror&quot;&gt; &lt;code&gt;Phoenix.MissingParamError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="774625820d7d0ec4e795fa8c9c6c08379f522851" translate="yes" xml:space="preserve">
          <source>If the URL has a host, a CSRF token that is tied to that host will be generated. If it is a relative path URL, a simple token emitted with &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">URL에 호스트가 있으면 해당 호스트에 연결된 CSRF 토큰이 생성됩니다. 상대 경로 URL 인 경우 &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; 으로 생성 된 간단한 토큰 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e46e2e7ec4df9676257eca653e07b09f347fb52" translate="yes" xml:space="preserve">
          <source>If the adapter does not provide a pool, just calling the passed function and returning its result are enough.</source>
          <target state="translated">어댑터가 풀을 제공하지 않는 경우 전달 된 함수를 호출하고 그 결과를 반환하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c467ebfb28c3769c0f60d1ed5192b127c4f129d1" translate="yes" xml:space="preserve">
          <source>If the adapter does not support inform, then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">어댑터가 정보를 지원하지 않으면 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b83fa861079f61f5349df999d4ab77d5e9dd2d46" translate="yes" xml:space="preserve">
          <source>If the adapter does not support informational responses then this is a noop.</source>
          <target state="translated">어댑터가 정보 응답을 지원하지 않는 경우 이는 noop입니다.</target>
        </trans-unit>
        <trans-unit id="abd9faa09d21bdad382cd8d73f3c1cd6edf98fe0" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">어댑터가 서버 푸시를 지원하지 않으면 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="03a7adb38fe4fd08405bbe2e59b1dc64945ce1ee" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then this is a noop.</source>
          <target state="translated">어댑터가 서버 푸시를 지원하지 않는 경우 이것은 noop입니다.</target>
        </trans-unit>
        <trans-unit id="e1ab595daecbe8219ab31d6ce1dc0b9d4bd3ff2d" translate="yes" xml:space="preserve">
          <source>If the adapter provides a pool, it is supposed to &quot;check out&quot; one of the pool connections for the duration of the function call. Which connection is checked out is not passed to the calling function, so it should be done using a stateful method like using the current process' dictionary, process tracking, or some kind of other lookup method. Make sure that this stored connection is then used in the other callbacks implementations, such as &lt;a href=&quot;ecto.adapter.queryable&quot;&gt;&lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.adapter.schema&quot;&gt;&lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어댑터가 풀을 제공하는 경우 함수 호출 기간 동안 풀 연결 중 하나를 &quot;체크 아웃&quot;해야합니다. 체크 아웃 된 연결은 호출 함수로 전달되지 않으므로 현재 프로세스의 사전, 프로세스 추적 또는 기타 검색 방법을 사용하는 것과 같은 상태 저장 방법을 사용하여 수행해야합니다. 이 저장된 연결이 &lt;a href=&quot;ecto.adapter.queryable&quot;&gt; &lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.adapter.schema&quot;&gt; &lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt; &lt;/a&gt; 와 같은 다른 콜백 구현에서 사용되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="67e30f305c8d388d84dacb2f22a8db0505392601" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;:select_merge&lt;/code&gt; is a constructed struct (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;) or map (&lt;code&gt;map/2&lt;/code&gt;) where the source to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;map/2&lt;/code&gt; may be a &lt;code&gt;nil&lt;/code&gt; value (as in an outer join), the source will be returned unmodified.</source>
          <target state="translated">의 인수 경우 &lt;code&gt;:select_merge&lt;/code&gt; 가 구축 된 구조체 (인 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; ) 또는지도 ( &lt;code&gt;map/2&lt;/code&gt; 원본) &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;map/2&lt;/code&gt; 수있다 &lt;code&gt;nil&lt;/code&gt; (외측 가입에서와 같이) 값을 상기 소스 것 수정되지 않은 상태로 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1c015b3bdb8e3e97eeb9a475ec46483a71e9b1c" translate="yes" xml:space="preserve">
          <source>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not any of values below, it will raise.</source>
          <target state="translated">연결에 변경 사항이 없으면 건너 뜁니다. 연결이 유효하지 않으면 변경 세트가 유효하지 않은 것으로 표시됩니다. 주어진 값이 아래 값 중 하나가 아니면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9f7bac3c27469f7d4914ccb40eab78a149fc9bfe" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value.</source>
          <target state="translated">변경 사항이 이미 존재하면 새 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a698e1cab1f6f678660aa4dfb67045d6928daa" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value. If the change has the same value as in the changeset data, it is not added to the list of changes.</source>
          <target state="translated">변경 사항이 이미 존재하면 새 값으로 대체됩니다. 변경 사항이 변경 세트 데이터와 동일한 값을 갖는 경우 변경 사항 목록에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d643dc985a9051bacd04e1a9f62548fd0e65c8a1" translate="yes" xml:space="preserve">
          <source>If the changes are valid, all changes are applied to the changeset data. If the changes are invalid, no changes are applied, and an error tuple is returned with the changeset containing the action that was attempted to be applied.</source>
          <target state="translated">변경 사항이 유효하면 모든 변경 사항이 변경 세트 데이터에 적용됩니다. 변경 사항이 유효하지 않은 경우, 변경 사항이 적용되지 않으며 적용하려고 시도한 조치가 포함 된 변경 세트와 함께 오류 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2757319b7d7f37a81751b87f0ba7d4b5be8070c7" translate="yes" xml:space="preserve">
          <source>If the changeset given to the repository is valid, the function given to &lt;a href=&quot;#prepare_changes/2&quot;&gt;&lt;code&gt;prepare_changes/2&lt;/code&gt;&lt;/a&gt; will be called with the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands. The repository itself can be accessed inside the function under the &lt;code&gt;repo&lt;/code&gt; field in the changeset. If the changeset given to the repository is invalid, the function will not be invoked.</source>
          <target state="translated">저장소에 제공된 변경 세트가 유효하면 &lt;a href=&quot;#prepare_changes/2&quot;&gt; &lt;code&gt;prepare_changes/2&lt;/code&gt; 에&lt;/a&gt; 제공된 함수 가 변경 세트와 함께 호출되고 변경 세트를 리턴해야 개발자가 변경 세트를 최종 조정하거나 데이터 일관성 명령을 실행할 수 있습니다. 저장소 자체는 변경 집합 의 &lt;code&gt;repo&lt;/code&gt; 필드 아래 함수 내에서 액세스 할 수 있습니다 . 저장소에 제공된 변경 집합이 유효하지 않은 경우 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="344cb03738b4c3ad68a22abc027e74afa335c15c" translate="yes" xml:space="preserve">
          <source>If the connection is accepted, the transport can move the connection to another process, if so desires, or keep using the same process. The process responsible for managing the socket should then call &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결이 수락되면 전송은 원하는 경우 연결을 다른 프로세스로 이동하거나 동일한 프로세스를 계속 사용할 수 있습니다. 소켓 관리를 담당하는 프로세스는 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d577ab6f6374c6d9db1620ec48bb72e49c4e5c2" translate="yes" xml:space="preserve">
          <source>If the connection was successful, generates &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic from the &lt;code&gt;id/1&lt;/code&gt; callback.</source>
          <target state="translated">연결에 성공 하면 &lt;code&gt;id/1&lt;/code&gt; 콜백 에서 &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; 주제를 생성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="14c0b3c8ee8241e593e8ad60d75f84e2457bdc6b" translate="yes" xml:space="preserve">
          <source>If the cookie is not signed nor encrypted, then the value must be a binary. Note the value is not automatically escaped. Therefore if you want to store values with non-alphanumeric characters, you must either sign or encrypt the cookie or consider explicitly escaping the cookie value by using a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. It is important for padding to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">쿠키가 서명되거나 암호화되지 않은 경우 값은 2 진이어야합니다. 값은 자동으로 이스케이프되지 않습니다. 따라서 영숫자가 아닌 문자로 값을 저장하려면 쿠키에 서명 또는 암호화하거나 작성시 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 및 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 와 같은 함수를 사용하여 쿠키 값을 명시 적으로 이스케이프하는 것을 고려해야합니다 . (인코딩 됨, 패딩 : false) 쿠키를 읽을 때. &lt;code&gt;=&lt;/code&gt; 는 쿠키 값에서 유효한 문자가 아니기 때문에 패딩을 비활성화하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="3a5834bc3acf73c8335beda9b2b7bbaf51ee3a6e" translate="yes" xml:space="preserve">
          <source>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid.</source>
          <target state="translated">퍼가기 변경 사항이 없으면 건너 뜁니다. 임베드가 유효하지 않은 경우 변경 세트가 유효하지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="100887b9de3b56af079f0a72491a4382d1396bb0" translate="yes" xml:space="preserve">
          <source>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</source>
          <target state="translated">왼쪽의 맵이 구조체 인 경우 Ecto는 병합하기 전에 오른쪽에있는 모든 필드가 왼쪽에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="67cfc2cb3e12875af3e1ba6a2973b3dbd4bbf5ad" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is an associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with the existing struct and become an update operation</source>
          <target state="translated">매개 변수에 ID가 포함되어 있고 해당 ID와 연관된 하위가있는 경우 매개 변수 데이터는 기존 구조와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달 되고 업데이트 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="5b235bb233a3f3d355503c030abb877188e1fb03" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is no associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">매개 변수에 ID가 있고 해당 ID와 연관된 하위가없는 경우 매개 변수 데이터는 새 구조체와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달 되고 삽입 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2858b55ac4015434edf3d00d6d984a1e7af01d" translate="yes" xml:space="preserve">
          <source>If the parameter does not contain an ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">매개 변수에 ID가 포함되어 있지 않으면 매개 변수 데이터가 새 구조체와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달되어 삽입 작업이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;:pop&lt;/code&gt; 을 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{value, new_data}&lt;/code&gt; 여야합니다. 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래 값 이거나 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; 이고 &lt;code&gt;new_data&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 없는 &lt;code&gt;data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 를 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{get_value, new_data}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2143e7239fbfa87b876c6cf2de6756de08ffc64" translate="yes" xml:space="preserve">
          <source>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</source>
          <target state="translated">쿼리에 제한, 오프셋 또는 고유 집합이 있으면 적절한 결과를 반환하기 위해 하위 쿼리에 자동으로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2bddb6cc8d18143b43f8bbafcae7867ac58bcf" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the key is set in the given struct, the key will automatically be set in the built association:</source>
          <target state="translated">관계가 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 이고 키가 주어진 구조체에서 설정되면 키는 자동으로 빌드 된 연관에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8c910d7e1f4a7ca500d332206b3b56b62dcdd3" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the primary key is set in the parent struct, the key will automatically be set in the built association:</source>
          <target state="translated">관계가 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 이고 기본 키가 부모 구조체에 설정된 경우 키는 빌드 된 연결에 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ab972c154c21dacb18a792e2b9de9b778294e4" translate="yes" xml:space="preserve">
          <source>If the request contains a &quot;_format&quot; parameter, it is considered to be the format desired by the client. If no &quot;_format&quot; parameter is available, this function will parse the &quot;accept&quot; header and find a matching format accordingly.</source>
          <target state="translated">요청에 &quot;_format&quot;매개 변수가 포함 된 경우 클라이언트가 원하는 형식으로 간주됩니다. &quot;_format&quot;매개 변수를 사용할 수없는 경우이 함수는 &quot;accept&quot;헤더를 구문 분석하고 그에 따라 일치하는 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="589c270364db1b0108ce43960e91be264009debe" translate="yes" xml:space="preserve">
          <source>If the request contains a &amp;ldquo;_format&amp;rdquo; parameter, it is considered to be the format desired by the client. If no &amp;ldquo;_format&amp;rdquo; parameter is available, this function will parse the &amp;ldquo;accept&amp;rdquo; header and find a matching format accordingly.</source>
          <target state="translated">요청에&amp;ldquo;_format&amp;rdquo;매개 변수가 포함되어 있으면 클라이언트가 원하는 형식으로 간주됩니다. &quot;_format&quot;매개 변수를 사용할 수 없으면이 함수는 &quot;accept&quot;헤더를 구문 분석하고 이에 따라 일치하는 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c173a238b103f05715b98fa0448f517f74ccec4e" translate="yes" xml:space="preserve">
          <source>If the request has method &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt;, the adapter should not send the response to the client.</source>
          <target state="translated">요청에 &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; 메소드가 있으면 어댑터는 클라이언트에 응답을 보내지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d45df81e2caa272cbf84dfebf38c8aa28609010e" translate="yes" xml:space="preserve">
          <source>If the route contains glob-like patterns, parameters for those have to be given as list:</source>
          <target state="translated">경로에 glob-like 패턴이 포함 된 경우 해당 매개 변수를 목록으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bf5da11b58dcf3690804466cd69ea5e5e4dca07" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;map&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">동일한 소스를 &lt;code&gt;map&lt;/code&gt; 으로 여러 번 선택한 경우 데이터베이스에서 여러 사본을 가져 오지 않도록 필드가 병합됩니다. 즉, 아래 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="652e9d42a43e2b8d5dcd0218df8782089064b141" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;struct&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 로 동일한 소스를 여러 번 선택한 경우 데이터베이스에서 여러 사본을 가져 오지 않도록 필드가 병합됩니다. 즉, 아래 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52eb3cdb7cd07fea24cf8899ccfeee45fa44e2fe" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 기본적으로 HTTP Strict Transport Security를 ​​활성화하기 위해 엄격한 전송 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="564b33d47ddc46edcbbb5f1d39d5ab6ae21f5998" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가하여 HTTP Strict Transport Security를 ​​활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8ce0178df9065e1071126bd4051a90d7aa5fa061" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it'll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가하여 기본적으로 HTTP Strict Transport Security를 ​​활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1e40997d2cab9139afd7b3e62e6c58a9b6923fe9" translate="yes" xml:space="preserve">
          <source>If the session has already been initialized, the new contents will be merged with the previous ones.</source>
          <target state="translated">세션이 이미 초기화 된 경우 새 내용이 이전 내용과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="187932693c763b03306b32e57e7c13cda06351fc" translate="yes" xml:space="preserve">
          <source>If the struct cannot be found, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체를 찾을 수 없으면 &lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62ac87da8864e486a5dadb087a7c2632f82b5234" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체에 기본 키가 없으면 &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8767938851ade63a15afc91119604f0839e7344" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised. If the struct has been removed from db prior to call, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체에 기본 키가 없으면 &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 호출하기 전에 구조체가 db에서 제거 된 경우 &lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e5578acf03166a21322dd600d9a66efef5d73e58" translate="yes" xml:space="preserve">
          <source>If the underlying input type is a &lt;code&gt;:text_field&lt;/code&gt;, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</source>
          <target state="translated">기본 입력 유형이 &lt;code&gt;:text_field&lt;/code&gt; 인 경우, 필드 이름만을 기반으로 입력 유형을 추가로 반영하기 위해 맵핑이 제공 될 수 있습니다. 기본 매핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a1e50f02aaf223bea1728ac3e4f595a0d0fbc9" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset&amp;rsquo;s changes, and an error is added. Note the error won&amp;rsquo;t be added though if the field already has an error.</source>
          <target state="translated">필드 값이 &lt;code&gt;nil&lt;/code&gt; 이거나 공백으로 만 구성된 문자열 인 경우 변경 세트가 유효하지 않은 것으로 표시되고 필드가 변경 세트의 변경 사항에서 제거되고 오류가 추가됩니다. 필드에 이미 오류가있는 경우 오류가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b51a8cfa4d0487afe8257855e71b56a122faf53b" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset's changes, and an error is added. An error won't be added if the field already has an error.</source>
          <target state="translated">필드의 값이 &lt;code&gt;nil&lt;/code&gt; 이거나 공백으로 만 이루어진 문자열이면 변경 집합이 유효하지 않은 것으로 표시되고 해당 필드가 변경 집합의 변경에서 제거되고 오류가 추가됩니다. 필드에 이미 오류가있는 경우 오류가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccfc8db638f1f1620ef7b8abebc9015b4310b64a" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &quot;On replace&quot; section on the module documentation)</source>
          <target state="translated">ID와 연관된 하위가 있고 ID가 매개 변수로 제공되지 않은 경우 해당 연관에 대한 &lt;code&gt;:on_replace&lt;/code&gt; 콜백이 호출됩니다 (모듈 문서의 &quot;대체시&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="5bc5b56a27b8e1d0d4212e390ddd5e71de7e4d2d" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &amp;ldquo;On replace&amp;rdquo; section on the module documentation)</source>
          <target state="translated">ID가있는 관련 자식이 있고 해당 ID가 매개 변수로 제공되지 않으면 해당 연결에 대한 &lt;code&gt;:on_replace&lt;/code&gt; 콜백이 호출됩니다 (모듈 설명서의 &quot;교체시&quot;섹션 참조)</target>
        </trans-unit>
        <trans-unit id="3027f8dce56af2e1b89a3dcdf3f1ecf46fe576f2" translate="yes" xml:space="preserve">
          <source>If there is no English translation for the post, the untranslated post &lt;code&gt;title&lt;/code&gt; will be returned and &lt;code&gt;summary&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt;. If there is, both &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; will be the value from &lt;code&gt;Post.Translation&lt;/code&gt;.</source>
          <target state="translated">게시물에 대한 영어 번역이없는 경우 번역되지 않은 게시물 &lt;code&gt;title&lt;/code&gt; 이 반환되고 &lt;code&gt;summary&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 됩니다. 있는 경우 &lt;code&gt;title&lt;/code&gt; 과 &lt;code&gt;summary&lt;/code&gt; 모두 &lt;code&gt;Post.Translation&lt;/code&gt; 의 값이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a1a377354e3a0de11df4acec5746a31c120d5d3" translate="yes" xml:space="preserve">
          <source>If there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">그러한 행이 없으면 대신 기본값을 반환합니다 (값과 동일한 유형이어야 함). 오프셋과 기본값은 모두 현재 행을 기준으로 평가됩니다. 생략하면 offset 기본값은 1이고 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcbca676064b2672228b8d404db61ea01e7b418d" translate="yes" xml:space="preserve">
          <source>If we are terminating because the client left, the reason will be &lt;code&gt;{:shutdown, :left}&lt;/code&gt;. Similarly, if we are terminating because the client connection was closed, the reason will be &lt;code&gt;{:shutdown, :closed}&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 떠나서 종료하는 경우 이유는 &lt;code&gt;{:shutdown, :left}&lt;/code&gt; 입니다. 마찬가지로 클라이언트 연결이 종료되어 종료하는 경우 이유는 &lt;code&gt;{:shutdown, :closed}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f56a37255e0b43c2392f533494036f18e8e066b4" translate="yes" xml:space="preserve">
          <source>If you access these fields before fetching them, they will be returned as &lt;a href=&quot;plug.conn.unfetched&quot;&gt;&lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt;&lt;/a&gt; structs.</source>
          <target state="translated">가져 오기 전에 이러한 필드에 액세스하면 &lt;a href=&quot;plug.conn.unfetched&quot;&gt; &lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt; &lt;/a&gt; 구조체 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b68cb6ad948ac353881b8951cfd579c0c0ee1df4" translate="yes" xml:space="preserve">
          <source>If you already have a model, the generated model can be skipped with &lt;code&gt;--no-model&lt;/code&gt;. Read the documentation for &lt;code&gt;phoenix.gen.model&lt;/code&gt; for more information on attributes and namespaced resources.</source>
          <target state="translated">이미 모델이있는 경우 &lt;code&gt;--no-model&lt;/code&gt; 을 사용하여 생성 된 모델을 건너 뛸 수 있습니다 . 속성 및 네임 스페이스 리소스에 대한 자세한 내용 은 &lt;code&gt;phoenix.gen.model&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff739bec2c4393b5a6029990ea9ff518a68f23c" translate="yes" xml:space="preserve">
          <source>If you also want to send the response, use &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt; after this or use &lt;a href=&quot;#send_resp/3&quot;&gt;&lt;code&gt;send_resp/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답을 보내려면 이 후에 &lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt; 을 사용하거나 &lt;a href=&quot;#send_resp/3&quot;&gt; &lt;code&gt;send_resp/3&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1445ed0a8505a52f1fc2ab343b225750d1c7d54" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should check if you are listing the desired formats in your &lt;code&gt;:accepts&lt;/code&gt; plug or if you are setting the proper accept header in the client. The exception contains the acceptable mime types in the &lt;code&gt;accepts&lt;/code&gt; field.</source>
          <target state="translated">이 오류가 표시되면 &lt;code&gt;:accepts&lt;/code&gt; 플러그 에 원하는 형식을 나열 하는지 또는 클라이언트에서 올바른 승인 헤더를 설정하고 있는지 확인해야합니다. 예외는 &lt;code&gt;accepts&lt;/code&gt; 필드 에 허용 가능한 MIME 유형을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="8befb119931680b815f371783bc72db7f010ea28" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should handle the error and surface it to the end user. It means that there is a parameter missing from the request.</source>
          <target state="translated">이 오류가 표시되면 오류를 처리하여 최종 사용자에게 표시해야합니다. 요청에서 누락 된 매개 변수가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8281d3b702b25fc319af701ce0fe42f100d16669" translate="yes" xml:space="preserve">
          <source>If you are sending data to a full URI, such as &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; or &lt;code&gt;//external.com/path&lt;/code&gt;, instead of a simple path such as &lt;code&gt;/path&lt;/code&gt;, you may want to consider using &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt;, as that will encode the host in the CSRF token. Once received, Plug will only consider the CSRF token to be valid if the &lt;code&gt;host&lt;/code&gt; encoded in the token is the same as the one in &lt;code&gt;conn.host&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/path&lt;/code&gt; 와 같은 간단한 경로 대신 &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; 또는 &lt;code&gt;//external.com/path&lt;/code&gt; 와 같은 전체 URI로 데이터를 전송하는 경우 &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 . CSRF 토큰으로 호스트를 인코딩합니다. 일단 수신되면 플러그는 토큰으로 인코딩 된 &lt;code&gt;host&lt;/code&gt; 가 &lt;code&gt;conn.host&lt;/code&gt; 의 호스트 와 동일한 경우에만 CSRF 토큰이 유효한 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="2860b8a98014af24457d97de2b8635d54397f121" translate="yes" xml:space="preserve">
          <source>If you are trying to debug transaction-related code while using &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt;, it may be more helpful to configure the database to log all statements and consult those logs.</source>
          <target state="translated">&lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; 를 사용하는 동안 트랜잭션 관련 코드를 디버깅하려는 경우 모든 명령문을 로그하고 해당 로그를 참조하도록 데이터베이스를 구성하는 것이 더 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d8aab708f551e6ce45eaa04e632f244694f2e5f" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; in tests, note that even though each test is inside a transaction, &lt;code&gt;in_transaction?/0&lt;/code&gt; will only return true inside transactions explicitly created with &lt;code&gt;transaction/2&lt;/code&gt;. This is done so the test environment mimics dev and prod.</source>
          <target state="translated">테스트 에서 &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; 를 사용하는 경우 각 테스트가 트랜잭션 내부에 &lt;code&gt;in_transaction?/0&lt;/code&gt; 은 &lt;code&gt;transaction/2&lt;/code&gt; 로 명시 적으로 작성된 트랜잭션 내에서만 true를 리턴합니다 . 이것은 테스트 환경이 dev와 prod를 모방하도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="942638ba1572b805045a6efb9c529e7e1a50d20b" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &quot;posts_tags&quot; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">당신이 관련된 제거하려고하면 &lt;code&gt;many_to_many&lt;/code&gt; 데이터를 &lt;strong&gt;(가) 스키마에 가입하고 목표 협회에서 결코에서 체외 항상 데이터를 제거합니다&lt;/strong&gt; 설정하여 수 없습니다 &lt;code&gt;:on_replace&lt;/code&gt; 을 에 &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:on_delete&lt;/code&gt; 에 &lt;code&gt;:delete_all&lt;/code&gt; 나 같은 변경 집합 기능을 사용하여 &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt; . 예를 들어, &lt;code&gt;Post&lt;/code&gt; 가 &lt;code&gt;Tag&lt;/code&gt; 와 다 대다 관계를 가지고있는 경우 &lt;code&gt;:on_delete&lt;/code&gt; 를 &lt;code&gt;:delete_all&lt;/code&gt; 로 설정 하면 &lt;code&gt;Post&lt;/code&gt; 가 삭제 된 경우 &quot;posts_tags&quot;테이블에서 항목 만 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3cbaa656dba938c685add2656722d0e125f277" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &amp;ldquo;posts_tags&amp;rdquo; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">당신이 관련된 제거하려고하면 &lt;code&gt;many_to_many&lt;/code&gt; 데이터를 &lt;strong&gt;(가) 스키마에 가입하고 목표 협회에서 결코에서 체외 항상 데이터를 제거합니다&lt;/strong&gt; 설정하여 수 없습니다 &lt;code&gt;:on_replace&lt;/code&gt; 을 에 &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:on_delete&lt;/code&gt; 에 &lt;code&gt;:delete_all&lt;/code&gt; 나 같은 변경 집합 기능을 사용하여 &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt; . 예를 들어 &lt;code&gt;Post&lt;/code&gt; 가 &lt;code&gt;Tag&lt;/code&gt; 와 다 대다 관계인 경우 &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; 을 설정 하면 &lt;code&gt;Post&lt;/code&gt; 가 삭제 된 경우&amp;ldquo;posts_tags&amp;rdquo;테이블에서 항목 만 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="33aeade4ec4114f6d64f05c0e4ded54c69c06049" translate="yes" xml:space="preserve">
          <source>If you attempt to write it as &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt;, Ecto won&amp;rsquo;t accept such query. However, the subquery above can be written as a JOIN, which is supported by Ecto. The final Ecto query will look like this:</source>
          <target state="translated">&lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt; 과 같이 쓰려고하면 Ecto는 그러한 쿼리를 허용하지 않습니다. 그러나 위의 하위 쿼리는 Ecto에서 지원하는 JOIN으로 작성할 수 있습니다. 최종 Ecto 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09cb3a84985c7f8fa4e8edcaba166f48f945bf96" translate="yes" xml:space="preserve">
          <source>If you don't have any Ecto schema pointing to the CTE table, you can pass a tuple with the CTE table name as first element and an Ecto schema as second element. This will cast the result rows to Ecto structs as long as the Ecto schema maps to the same fields in the CTE table:</source>
          <target state="translated">CTE 테이블을 가리키는 Ecto 스키마가없는 경우 첫 번째 요소로 CTE 테이블 이름을 사용하고 두 번째 요소로 Ecto 스키마를 사용하여 튜플을 전달할 수 있습니다. 이것은 Ecto 스키마가 CTE 테이블의 동일한 필드에 매핑되는 한 결과 행을 Ecto 구조체로 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="415aa01085c0f6d5805f0753fe7636a79914ccaf" translate="yes" xml:space="preserve">
          <source>If you have a session but the CSRF state was not loaded into the current process, you can dump the state from the session:</source>
          <target state="translated">세션이 있지만 CSRF 상태가 현재 프로세스에로드되지 않은 경우 세션에서 상태를 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0fdbca7cff696f9dab2f2e658e9f4fc49ebd8" translate="yes" xml:space="preserve">
          <source>If you need an escape hatch, Ecto provides fragments (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) to inject SQL (and non-SQL) fragments into queries.</source>
          <target state="translated">이스케이프 해치가 필요한 경우 Ecto는 조각 ( &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt; 참조 )을 제공하여 SQL (및 비 SQL) 조각을 쿼리에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="43ecb1e3f8dbc11e08115c78cf6e2d60dbd4aefe" translate="yes" xml:space="preserve">
          <source>If you need custom options on the underlying field, you can define the field explicitly and then pass &lt;code&gt;define_field: false&lt;/code&gt; to &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">기본 필드에 사용자 정의 옵션이 필요한 경우 필드를 명시 적으로 정의한 다음 &lt;code&gt;define_field: false&lt;/code&gt; 를 &lt;code&gt;belongs_to&lt;/code&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd51ff6183de690e100505fa4969b12d1551fa2a" translate="yes" xml:space="preserve">
          <source>If you need to dynamically configure how &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt;&lt;/a&gt; behave, for example, based on the connection or another system parameter, one option is to create your own parser that wraps it:</source>
          <target state="translated">예를 들어 연결 또는 다른 시스템 매개 변수를 기반으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt; 의&lt;/a&gt; 작동 방식을 동적으로 구성해야하는 경우 한 가지 옵션은이를 래핑하는 자체 파서를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="109f5082f2f1b912050b16bb98f4693eba354f1f" translate="yes" xml:space="preserve">
          <source>If you need to guarantee the data in the returned struct mirrors the database, you have three options:</source>
          <target state="translated">리턴 된 구조체의 데이터가 데이터베이스를 미러링하도록 보장해야하는 경우 세 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6194c95c25393c1533f24ca690885ddce3de29a4" translate="yes" xml:space="preserve">
          <source>If you want a map with only the selected fields to be returned. For more information, read the docs for &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt;&lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.query.api#map/2&quot;&gt;&lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택한 필드 만있는 맵을 반환하려는 경우. 자세한 정보는 &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt; &lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.query.api#map/2&quot;&gt; &lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt; 에&lt;/a&gt; 대한 문서를 읽으십시오. .</target>
        </trans-unit>
        <trans-unit id="b56c7f334ac00fd6eb86d51a4d425fe63a22845f" translate="yes" xml:space="preserve">
          <source>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</source>
          <target state="translated">부울 속성을 그대로 보내려면이를 명시 적으로 문자열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71958648bc2ee1d3c516f077771f912b56470ab5" translate="yes" xml:space="preserve">
          <source>If you want to configure the years range:</source>
          <target state="translated">연도 범위를 구성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="eaaf4a6e48637b0f1ace60064563e26ec60604dd" translate="yes" xml:space="preserve">
          <source>If you want to do so in a case-by-case basis, you can define a custom function that gets the endpoint URI configuration and changes it accordingly. For example, to get the current URL always in HTTPS format:</source>
          <target state="translated">사례별로 그렇게하려면 끝점 URI 구성을 가져와 그에 따라 변경하는 사용자 지정 함수를 정의 할 수 있습니다. 예를 들어 현재 URL을 항상 HTTPS 형식으로 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="3267ec97b69bd134a5f100a8b20b7af9c4d6bdb9" translate="yes" xml:space="preserve">
          <source>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of &lt;code&gt;use Phoenix.Controller&lt;/code&gt;.</source>
          <target state="translated">컨트롤러를 완전히 구현하지 않고 연결을 조작하는 기능을 &lt;code&gt;use Phoenix.Controller&lt;/code&gt; 대신 두 모듈을 직접 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e505240a0d781b16ebb52afdcfed3cf74a91017d" translate="yes" xml:space="preserve">
          <source>If you want to include the seconds field (hidden by default), pass &lt;code&gt;second: []&lt;/code&gt;:</source>
          <target state="translated">초 필드를 포함하려면 (기본적으로 숨겨 짐) 초를 전달하십시오 &lt;code&gt;second: []&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebd7ac9e06dec198b102f467e0d5a2146add7ac" translate="yes" xml:space="preserve">
          <source>If you want to instrument a piece of code, but the endpoint that should instrument it (the one that contains the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro you want to use) is not known at compile time, only at runtime, you can use the &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt;&lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt;&lt;/a&gt; macro. Refer to its documentation for more information.</source>
          <target state="translated">코드를 계측하려고하지만이를 계측해야하는 엔드 포인트 ( 사용하려는 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로 가 포함 된 엔드 포인트 )를 컴파일 타임에 알 수없는 경우 런타임에만 &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt; &lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다. . 악기 / 4 매크로. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec5f40c77fd66ea84bc6ba36f0c2a7c3fe56b0a" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application.</source>
          <target state="translated">Ecto를 사용하여 샘플 애플리케이션을 빠르게 확인하려면 &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;시작 안내서&lt;/a&gt; 및 함께 제공되는 샘플 애플리케이션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c4123984bcd758a7753f404a92fb713daeb010c8" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto's README&lt;/a&gt; also links to other resources.</source>
          <target state="translated">Ecto를 사용하여 샘플 애플리케이션을 빠르게 확인하려면 &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;시작 안내서&lt;/a&gt; 와 함께 제공되는 샘플 애플리케이션을 확인하십시오. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto의 README&lt;/a&gt; 는 다른 리소스에도 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="78c050fecd9ef681ce1f0f4d13cfe35bf4a562b4" translate="yes" xml:space="preserve">
          <source>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</source>
          <target state="translated">주어진 프로젝트의 관리자와 같이 데이터베이스에서 제공되는 옵션을 선택하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e2240497996f5c5fe18575f06718f0c34d8a4556" translate="yes" xml:space="preserve">
          <source>If you want to support a given engine only on a certain template, you can pass it as an option on &lt;code&gt;use Phoenix.Template&lt;/code&gt;:</source>
          <target state="translated">특정 템플릿에서만 주어진 엔진을 지원 &lt;code&gt;use Phoenix.Template&lt;/code&gt; 옵션으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6906d4bf644df48b3f0c419b3abf27f44bf197a2" translate="yes" xml:space="preserve">
          <source>If you would prefer to simply merge two multis together, see &lt;a href=&quot;#append/2&quot;&gt;&lt;code&gt;append/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#prepend/2&quot;&gt;&lt;code&gt;prepend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단순히 두 개의 멀티를 합치려면 &lt;a href=&quot;#append/2&quot;&gt; &lt;code&gt;append/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#prepend/2&quot;&gt; &lt;code&gt;prepend/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="906016b8afe13d5670e52576993026f7d29c208a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">Plug 애플리케이션이 HTTPS를 처리하는 프록시 뒤에있는 경우 Plug에 &lt;code&gt;x-forwarded-*&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 지시해야 할 수 있습니다 . &lt;code&gt;:rewrite_on&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffa6a80acbf97635e0ac507b93d5063cd5b0d16a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you will need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-proto&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">플러그 응용 프로그램이 HTTPS를 처리하는 프록시 뒤에있는 경우 플러그가 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 지시해야합니다 . &lt;code&gt;:rewrite_on&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 옵션을 .</target>
        </trans-unit>
        <trans-unit id="4ee22e439b0d72c012e013a54bdd332f454b15e8" translate="yes" xml:space="preserve">
          <source>If your adapter is only able to respond to one or a couple of the query functions, add custom implementations of those functions directly to the Repo by using &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt;&lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">어댑터가 쿼리 함수 중 하나 또는 두 개에만 응답 할 수있는 경우 대신 &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt; &lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 해당 함수의 사용자 지정 구현을 Repo에 직접 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ea11ef400e8f5b84f516d039032b014e672598" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application's supervisor:</source>
          <target state="translated">애플리케이션이 감독자와 함께 생성 된 경우 ( &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt; 를 전달 하여) 감독자를 정의하고 시작하는 애플리케이션 시작 콜백이 포함 된 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 파일이 생성됩니다. 애플리케이션의 감독자에서 감독자로 저장소를 시작 하려면 &lt;code&gt;start/2&lt;/code&gt; 함수 를 편집하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e64da7625aab0af6dfae19c9bbd8cef653814d79" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application&amp;rsquo;s supervisor:</source>
          <target state="translated">응용 프로그램이 수퍼바이저로 생성 된 경우 ( &lt;code&gt;--sup&lt;/code&gt; 을 &lt;code&gt;mix new&lt;/code&gt; 로 혼합 하여 전달 ) 수퍼바이저를 정의하고 시작하는 응용 프로그램 시작 콜백이 포함 된 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 파일이 있습니다. 응용 프로그램의 수퍼바이저에서 repo를 수퍼바이저로 시작 하려면 &lt;code&gt;start/2&lt;/code&gt; 기능 만 편집하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="9963b98e0a632c06b03f38938368cd7af1095618" translate="yes" xml:space="preserve">
          <source>If your data layer supports embedding or nested associations, you can use &lt;code&gt;inputs_for&lt;/code&gt; to attach nested data to the form.</source>
          <target state="translated">데이터 계층에서 임베드 또는 중첩 연관을 지원하는 경우 &lt;code&gt;inputs_for&lt;/code&gt; 를 사용 하여 중첩 된 데이터를 양식에 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3f651a489e53e22ef5bfd5ad5ccb20a85f41ce" translate="yes" xml:space="preserve">
          <source>If your primary key is not named &amp;ldquo;id&amp;rdquo; (e.g. if you are working with a legacy database), you can use the &lt;code&gt;@primary_key&lt;/code&gt; attribute to configure your key name using the &lt;code&gt;source&lt;/code&gt; option. For example, the following attribute defines an integer primary key named &lt;code&gt;legacy_id&lt;/code&gt; which is automatically incremented by the database:</source>
          <target state="translated">기본 키의 이름이 &quot;id&quot;가 아닌 경우 (예 : 레거시 데이터베이스로 작업하는 경우) &lt;code&gt;@primary_key&lt;/code&gt; 속성을 사용하여 &lt;code&gt;source&lt;/code&gt; 옵션을 사용하여 키 이름을 구성 할 수 있습니다 . 예를 들어 다음 속성은 &lt;code&gt;legacy_id&lt;/code&gt; 라는 정수 기본 키를 정의합니다. 데이터베이스에 의해 자동으로 증가하는 합니다.</target>
        </trans-unit>
        <trans-unit id="c262a06dde1c92c1b642e458f52da921424c961b" translate="yes" xml:space="preserve">
          <source>If your socket is implemented using &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, you can also pass to each transport above all options accepted on &lt;code&gt;use Phoenix.Socket&lt;/code&gt;. An option given here will override the value in &lt;code&gt;use Phoenix.Socket&lt;/code&gt;.</source>
          <target state="translated">소켓이 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현 된 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 허용되는 모든 옵션보다 각 전송에 전달할 수도 있습니다 . 여기에 제공된 옵션은 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a7f718c136252a6132fe7a1aa2ed7beedb600c13" translate="yes" xml:space="preserve">
          <source>If your table is partitioned, then your unique index might look different per partition, e.g. Postgres adds p&amp;lt;number&amp;gt; to the middle of your key, like:</source>
          <target state="translated">테이블이 분할 된 경우 고유 인덱스가 파티션마다 다르게 보일 수 있습니다. 예를 들어 Postgres는 다음과 같이 키 중간에 p &amp;lt;number&amp;gt;를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a69fedcf99422ab483c859e4efba05a441aa355" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unecessarily complex. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Post에 많은 주석이 있고 기존 게시물에 새 주석을 추가하려는 관계를 상상해보십시오. 이를 위해 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용할 수는 있지만 불필요하게 복잡합니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="b9e00b21da4725e0255aeee1974fcbd6702ec96c" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unnecessarily complex. Let's see an example.</source>
          <target state="translated">게시물에 많은 댓글이 있고 기존 게시물에 새 댓글을 추가하려는 관계를 상상해보십시오. 이를 위해 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있지만 불필요하게 복잡합니다. 예를 봅시다.</target>
        </trans-unit>
        <trans-unit id="a9a80fa7e20b6ec638558d87fd5e8f1b2c820f57" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;handle_in/3&lt;/code&gt; inside a channel:</source>
          <target state="translated">채널 내부에 다음 &lt;code&gt;handle_in/3&lt;/code&gt; 을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="d7eaef0786d3c2d56724df9325bdf3c6d03a3696" translate="yes" xml:space="preserve">
          <source>Imagine the following Ecto schemas:</source>
          <target state="translated">다음 Ecto 스키마를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="69ed1238c0e40ec582e839a9be87906ea6d1bb56" translate="yes" xml:space="preserve">
          <source>Imagine the following plug:</source>
          <target state="translated">다음 플러그를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="6ca34da07d3e254b51321106a99af217f3cef8f8" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let&amp;rsquo;s imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">게시물에 연결하려는 태그 세트를 수신한다고 가정하십시오. 이러한 태그가 선결제로 존재하며 모두 데이터베이스에 유지된다고 가정 해 봅시다. 이 형식으로 데이터를 얻는다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="07174bed3e1206960783f2a30e60773792599d44" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let's imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">게시물에 연결하려는 일련의 태그를 받고 있다고 상상해보십시오. 이러한 태그가 사전에 존재하고 모두 데이터베이스에 유지된다고 가정 해 보겠습니다. 다음 형식으로 데이터를 얻는다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="224f74e1875d15da71996dc37aae640fe78641d1" translate="yes" xml:space="preserve">
          <source>Imagine you have a schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">&lt;code&gt;has_many :comments&lt;/code&gt; 연관 이있는 스키마 &lt;code&gt;Post&lt;/code&gt; 가 있고 다음 쿼리를 실행 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="37ae5ef9b11c014505c58d928130e9d937a57895" translate="yes" xml:space="preserve">
          <source>Imagine you have an schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">&lt;code&gt;has_many :comments&lt;/code&gt; 연관 이있는 스키마 &lt;code&gt;Post&lt;/code&gt; 가 있고 다음 쿼리를 실행 한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="911d5cbc4bd74830db2cf2e8c805fa896d8b4ab3" translate="yes" xml:space="preserve">
          <source>Imagine you have the following action in your controller:</source>
          <target state="translated">컨트롤러에 다음과 같은 동작이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c3bcbecb37fb60e6f6b4d98aea0398cac118f78f" translate="yes" xml:space="preserve">
          <source>Imagine you want to encode the ID so they cannot enumerate the content in your application. An Ecto type could handle the conversion between the encoded version of the id and its representation in the database. For the sake of simplicity we'll use base64 encoding in this example:</source>
          <target state="translated">애플리케이션의 콘텐츠를 열거 할 수 없도록 ID를 인코딩한다고 가정 해보십시오. Ecto 유형은 ID의 인코딩 된 버전과 데이터베이스의 해당 표현 간의 변환을 처리 할 수 ​​있습니다. 간단하게하기 위해이 예제에서는 base64 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15e74fb2e9144b4fc1c6e2f7edb9692fba7939fe" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn&amp;rsquo;t an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">URL 단축 서비스에서 스키마의 일부로 URI 구조체를 저장한다고 가정합니다. 런타임시 해당 값을 지원하기위한 Ecto 필드 유형이 없으므로 사용자 정의 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="172eb5a1f40be1a000419ab4add75a6dc3be204b" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn't an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">URL 단축 서비스에서 스키마의 일부로 URI 구조체를 저장한다고 가정 해보십시오. 런타임에 해당 값을 지원하는 Ecto 필드 유형이 없으므로 사용자 지정 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1e1dad2bc8d9075bbf5f98838633808ebc9eb469" translate="yes" xml:space="preserve">
          <source>Imagine your application is configured to run on &quot;example.com&quot; but after the user signs in, you want all links to use &quot;some_user.example.com&quot;. You can do so by setting the proper router url configuration:</source>
          <target state="translated">애플리케이션이 &quot;example.com&quot;에서 실행되도록 구성되어 있지만 사용자가 로그인 한 후 모든 링크가 &quot;some_user.example.com&quot;을 사용하도록한다고 가정 해보십시오. 적절한 라우터 URL 구성을 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dd83f3829baa0b9a2d40da3d590f7c9d0db3a5ca" translate="yes" xml:space="preserve">
          <source>Implementing a Tracker</source>
          <target state="translated">트래커 구현</target>
        </trans-unit>
        <trans-unit id="3d6c2a38d322d3d763e854f7651b3495dd090632" translate="yes" xml:space="preserve">
          <source>Implementing the transport behaviour</source>
          <target state="translated">전송 동작 구현</target>
        </trans-unit>
        <trans-unit id="058fd7ed1c45697b86ef3cd0718d7bbfbe7580e9" translate="yes" xml:space="preserve">
          <source>Implementing your own adapter</source>
          <target state="translated">자신의 어댑터 구현</target>
        </trans-unit>
        <trans-unit id="b0c929d75f4d94fd8fe1c260cbfd2b081155e7fe" translate="yes" xml:space="preserve">
          <source>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</source>
          <target state="translated">Ecto에서는이 문제를 해결하는 세 가지 방법이 있습니다. 가장 간단한 방법은 주석 스키마에서 각 연관마다 하나씩 여러 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="382006685c4bc65202ab7101130f82fd90eb1bb5" translate="yes" xml:space="preserve">
          <source>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</source>
          <target state="translated">SQL에서 COALESCE는 여러 인수를 사용하지만 ecto에서는 두 개만 필요하므로 동일한 효과를 얻으려면 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae8d00a4f35aea9b1e600a76e95f40be1762a98" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;code&gt;builder_opts()&lt;/code&gt; allows us to pass the options given when initializing the router to a &lt;code&gt;dispatch&lt;/code&gt;.</source>
          <target state="translated">간단히 말해서 &lt;code&gt;builder_opts()&lt;/code&gt; 는 라우터를 초기화 할 때 주어진 옵션을 &lt;code&gt;dispatch&lt;/code&gt; 에 전달할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="9ac9085e5b012c8583c70779624f050d5eb103a2" translate="yes" xml:space="preserve">
          <source>In addition to pushing messages out when you receive a &lt;code&gt;handle_in&lt;/code&gt; event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</source>
          <target state="translated">&lt;code&gt;handle_in&lt;/code&gt; 이벤트 를 수신 할 때 메시지를 푸시하는 것 외에도 요청 / 응답 스타일 메시징을 위해 클라이언트 이벤트에 직접 응답 할 수도 있습니다. 클라이언트가 작업 결과를 알아야하거나 단순히 메시지를 ack해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a42c2c570e4795fcc36b32e73f177e0d5b29e6e2" translate="yes" xml:space="preserve">
          <source>In addition to selecting a group of ciphers, selecting a cipher suite will also disable client renegotiation and force the client to honor the server specified cipher order.</source>
          <target state="translated">암호 그룹을 선택하는 것 외에도 암호 그룹을 선택하면 클라이언트 재협상이 비활성화되고 클라이언트가 서버에서 지정한 암호 순서를 따르도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="e048396b52227039210be32cd7f7739a9bd6e4a9" translate="yes" xml:space="preserve">
          <source>In all examples so far we have used the &lt;strong&gt;keywords query syntax&lt;/strong&gt; to create a query:</source>
          <target state="translated">지금까지 모든 예제에서 &lt;strong&gt;키워드 query 구문&lt;/strong&gt; 을 사용하여 쿼리를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="39c6142f3ef45ee877e9c272f4bb4ce3244f2b98" translate="yes" xml:space="preserve">
          <source>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</source>
          <target state="translated">어쨌든 스키마의 제공 여부에 관계없이 Ecto 쿼리는 바인딩 시스템 덕분에 항상 컴포지션 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d5f38f557b90ac2d42e6a751598f4d8bbba9025c" translate="yes" xml:space="preserve">
          <source>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the &lt;code&gt;:id&lt;/code&gt; type with &lt;code&gt;:autogenerate&lt;/code&gt;, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</source>
          <target state="translated">두 경우 모두, 두 유형 모두 기본 어댑터 / 데이터베이스에 의해 지정된 의미를 갖습니다. 당신이 사용하는 경우 &lt;code&gt;:id&lt;/code&gt; 와 유형 &lt;code&gt;:autogenerate&lt;/code&gt; , 데이터베이스가 ID의 자동 생성에 대한 책임을 의미합니다. 자동 증분되는 관계형 데이터베이스의 기본 키의 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e64dc292736835c5a534ec38dce0f0304db068" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &quot;callback&quot;, but may be configured with the callback option.</source>
          <target state="translated">JSON 응답이 반환되는 경우 콜백 필드가 쿼리 문자열에있는 한 JSONP로 변환됩니다. 콜백 필드 자체의 기본값은 &quot;콜백&quot;이지만 콜백 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82af51d52f0d5e198a5e7d698f02d79e495b27b9" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &amp;ldquo;callback&amp;rdquo;, but may be configured with the callback option.</source>
          <target state="translated">JSON 응답이 반환되는 경우 콜백 필드가 쿼리 문자열에있는 한 JSONP로 변환됩니다. 콜백 필드 자체의 기본값은 &quot;콜백&quot;이지만 콜백 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce9be04157216a7cdb190a3b918523e8aca6731" translate="yes" xml:space="preserve">
          <source>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</source>
          <target state="translated">변경 세트가 제공되는 경우 변경 세트의 변경 사항이 구조체 필드와 병합되고 모든 변경 사항이 데이터베이스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="83a2e40171803838a9ad2e6d9d64ac8dc619d36d" translate="yes" xml:space="preserve">
          <source>In case a previous layout is set, &lt;code&gt;put_root_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">이전 레이아웃이 설정된 경우 &lt;code&gt;put_root_layout&lt;/code&gt; 은 문자열 또는 원자로 제공되는 레이아웃 이름도 허용합니다. 문자열 인 경우 형식을 포함해야합니다. atom을 전달하면 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 의 템플릿과 유사한 렌더링 시간에 레이아웃 형식이 발견됩니다 . &lt;code&gt;false&lt;/code&gt; 로 설정할 수도 있습니다 . 이 경우 레이아웃이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e804f9ad9af0ffc381cba4d6aa6307ec8f5528fa" translate="yes" xml:space="preserve">
          <source>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</source>
          <target state="translated">구조체가 제공되는 경우 구조체는 변경이 아닌 모든 필드를 변경 세트의 일부로 변경 세트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c3cb35e3a5542760b8bd73c40248a0ad353cdacc" translate="yes" xml:space="preserve">
          <source>In case an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; given as any of the field values by the user, it will be sent to the adapter as a tuple with in the shape of &lt;code&gt;{query, params}&lt;/code&gt;.</source>
          <target state="translated">사용자가 필드 값으로 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 를&lt;/a&gt; 제공 한 경우 &lt;code&gt;{query, params}&lt;/code&gt; 형태의 튜플 형태로 어댑터에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="24b15538982d59e2053fe7e9d8eaeadd4eb2e39f" translate="yes" xml:space="preserve">
          <source>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</source>
          <target state="translated">속성에 부울 값이 포함 된 경우 HTML에서 예상 한대로 키가 true 일 때 키가 반복되거나 false 인 경우 속성이 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8e575af2759774fa079f44025ceaa854182a1885" translate="yes" xml:space="preserve">
          <source>In case something goes wrong in a request, the router by default will crash, without returning any response to the client. This behaviour can be configured in two ways, by using two different modules:</source>
          <target state="translated">요청에서 문제가 발생하면 클라이언트에 대한 응답을 반환하지 않고 라우터가 기본적으로 중단됩니다. 이 동작은 두 가지 다른 모듈을 사용하여 두 가지 방법으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df0afcd7e029ed4180d102a2ae98dc593f2ffcd" translate="yes" xml:space="preserve">
          <source>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; repository callback:</source>
          <target state="translated">예를 들어 시스템 환경 변수를 읽어 URL을 동적으로 구성해야하는 경우 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 저장소 콜백을 통해 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c933f8035c349bb985fc09533544e811593ba38d" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection, which might improve performance by for instance allowing multiple related calls to the datastore to share cache information:</source>
          <target state="translated">어댑터가 풀을 제공하는 경우 지정된 &lt;code&gt;fun&lt;/code&gt; 내부의 모든 코드 가 동일한 연결에 대해 실행 되도록 보장합니다. 예를 들어 캐시 정보를 공유하기 위해 데이터 저장소에 대한 여러 관련 호출을 허용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bf9e264bce9cb321b7053883e7d31f611e7f05" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection.</source>
          <target state="translated">어댑터가 풀을 제공하는 경우, 주어진 &lt;code&gt;fun&lt;/code&gt; 내의 모든 코드 가 동일한 연결에 대해 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff857d8a1955260dd298b9e239a24e36bf3592fa" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won&amp;rsquo;t attempt to reload it.</source>
          <target state="translated">연결이 이미로드 된 경우 사전로드는 다시로드를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cafa8aa062d6ef4942117b66127dc03a39128b32" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won't attempt to reload it.</source>
          <target state="translated">연결이 이미로드 된 경우 사전로드는 연결을 다시로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606100f3e421118140c48c97a79e6b2bfcdaf803" translate="yes" xml:space="preserve">
          <source>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</source>
          <target state="translated">콜백이 없거나 응답이 JSON 형식으로 인코딩되지 않은 경우에는 응답이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a4c0d85054f4f0cfaba6ef317dc6eb61be6e95d" translate="yes" xml:space="preserve">
          <source>In case there&amp;rsquo;s at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">오류가 하나 이상있는 경우 변경 목록의 &lt;code&gt;:errors&lt;/code&gt; 필드와 &lt;code&gt;:valid?&lt;/code&gt; 에 오류 목록이 추가됩니다 . 플래그는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8802f9aee3cd3d44f383509389bf5a3ee709a5f4" translate="yes" xml:space="preserve">
          <source>In case there's at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 오류가있는 경우 오류 목록이 변경 집합 의 &lt;code&gt;:errors&lt;/code&gt; 필드와 &lt;code&gt;:valid?&lt;/code&gt; 플래그는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d961c79d7700abcfdd8ac118b7d6649979a32d5" translate="yes" xml:space="preserve">
          <source>In case you want to use only a subset of the functionality provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Presence&lt;/code&gt;&lt;/a&gt;, such as tracking processes but without broadcasting updates, we recommend that you look at the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; functionality from the &lt;code&gt;phoenix_pubsub&lt;/code&gt; project.</source>
          <target state="translated">추적 프로세스와 같이 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Presence&lt;/code&gt; &lt;/a&gt; 에서 제공하는 기능 중 일부만 사용하고 업데이트를 브로드 캐스팅하지 않으려 는 경우 &lt;code&gt;phoenix_pubsub&lt;/code&gt; 프로젝트 에서 &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 기능 을 살펴 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e55c4e4ce95987e0fe79dc9dcc20ddcd0ebdbe7f" translate="yes" xml:space="preserve">
          <source>In cases like above, when you want to work only on a single entry, it is much easier to simply work on the associated directly. For example, we could instead set the &lt;code&gt;post&lt;/code&gt; association in the comment:</source>
          <target state="translated">위와 같은 경우 단일 항목에 대해서만 작업하려는 경우 관련 작업을 직접 수행하는 것이 훨씬 쉽습니다. 예를 들어 주석에서 &lt;code&gt;post&lt;/code&gt; 연결을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a433a57ec454997093ca88ba782e60cd40611d5" translate="yes" xml:space="preserve">
          <source>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</source>
          <target state="translated">채널 테스트에서 프로세스 커뮤니케이션, 메시지 송수신을 통해 채널과 상호 작용합니다. 또한 채널이 구독하는 것과 동일한 주제를 구독하여 특정 메시지가 브로드 캐스트되었는지 여부를 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d0afdb19d32b80bba27b9edef3ebd1dd1cf2d1d" translate="yes" xml:space="preserve">
          <source>In complex cases, instead of relying on name inference, it may be best to set the constraint name explicitly:</source>
          <target state="translated">복잡한 경우에는 이름 추론에 의존하는 대신 제약 조건 이름을 명시 적으로 설정하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="77c8d6fd181489a2dd77e9ab68ac22f7bd4b22c2" translate="yes" xml:space="preserve">
          <source>In fact, given &lt;code&gt;:through&lt;/code&gt; associations are read-only, &lt;strong&gt;using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; format is the preferred mechanism for working with through associations&lt;/strong&gt;. Use the schema-based one only if you need to store the through data alongside of the parent struct, in specific cases such as preloading.</source>
          <target state="translated">실제로, 주어진 &lt;code&gt;:through&lt;/code&gt; 연관은 읽기 전용이며 &lt;strong&gt;, &lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt; 형식을 사용하는 것이 연관을 통한 작업에 선호되는 메커니즘입니다.&lt;/strong&gt; . 프리로드와 같은 특정 경우에 스루 데이터를 부모 구조체와 함께 저장해야하는 경우에만 스키마 기반 스키마를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e209e8446b46f8896bce3d2476eaddc91e35939f" translate="yes" xml:space="preserve">
          <source>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</source>
          <target state="translated">실제로이 매크로를 호출하면 외래 키 이름을 가진 필드가 스키마에 자동으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c7989d85bf0c7a46c11c45022e7b193d7c4745ef" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;camelize&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;underscore&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;camelize&lt;/code&gt; 는 &lt;code&gt;underscore&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;underscore&lt;/code&gt; 은 &lt;code&gt;camelize&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc684728adbd2c911a4a018ef11d85bc94e422b3" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</source>
          <target state="translated">대부분의 경우 요청에 따라 템플릿 형식을 동적으로 설정하고자 할 수 있습니다. 이렇게하려면 템플릿 이름을 아톰으로 확장명없이 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e42e4abc355dbe4c074a8c669e3ce458db628eaf" translate="yes" xml:space="preserve">
          <source>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</source>
          <target state="translated">위의 예제가 작동하려면 렌더링 전에 accepts 플러그를 사용하여 컨텐츠 협상을 수행해야합니다. 파이프 라인 (라우터)에 다음을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="12a19ac64c369cd3aa389e69a402bc23919589b6" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes&amp;rsquo; names and values as the first element in the tag&amp;rsquo;s attributes keyword list:</source>
          <target state="translated">사용자 정의 데이터 속성을 추가하려면 : data atom 및 태그의 속성 키워드 목록에서 첫 번째 요소로 데이터 속성의 이름과 값이 포함 된 키워드 목록이 포함 된 튜플을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac088c628be1832c3337855895315bec677904de" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes' names and values as the first element in the tag's attributes keyword list:</source>
          <target state="translated">사용자 정의 데이터 속성을 추가하려면 태그의 속성 키워드 목록의 첫 번째 요소로 데이터 속성의 이름과 값이있는 키워드 목록과 : data 원자를 포함하는 튜플을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="4945c44b05e04ace755224f66c5d74d324ac27b2" translate="yes" xml:space="preserve">
          <source>In order to be able to use types such as &lt;code&gt;User.t()&lt;/code&gt;, &lt;code&gt;t/0&lt;/code&gt; has to be defined manually:</source>
          <target state="translated">같은 종류 사용할 수 있도록하기 위해 &lt;code&gt;User.t()&lt;/code&gt; , &lt;code&gt;t/0&lt;/code&gt; 는 직접 정의한다 :</target>
        </trans-unit>
        <trans-unit id="f4270d5af79d57d387989112f1ca66b128244614" translate="yes" xml:space="preserve">
          <source>In order to customize the parameter for any struct, one can simply implement this protocol.</source>
          <target state="translated">모든 구조체의 매개 변수를 사용자 정의하기 위해이 프로토콜을 간단히 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb086d6d7d0263ec8c536ef5b195313198d32a9" translate="yes" xml:space="preserve">
          <source>In order to promote HTML safety, Phoenix templates do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt; to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</source>
          <target state="translated">HTML 안전성을 높이기 위해 Phoenix 템플릿은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; 을 사용 하여 데이터 형식을 템플릿의 문자열로 변환 하지 않습니다 . 대신 Phoenix는이 프로토콜을 사용하여 데이터 구조로 구현해야하며 HTML 안전 표현이 반환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9ca8acf13c91e783afefe3396f6e1d2849afbe0" translate="yes" xml:space="preserve">
          <source>In order to provide better security, this function also enables &lt;code&gt;:reuse_sessions&lt;/code&gt; and &lt;code&gt;:secure_renegotiate&lt;/code&gt; by default, to instruct clients to reuse sessions and enforce secure renegotiation according to RFC 5746 respectively</source>
          <target state="translated">더 나은 보안을 제공하기 위해이 기능은 또한 &lt;code&gt;:reuse_sessions&lt;/code&gt; 및 &lt;code&gt;:secure_renegotiate&lt;/code&gt; 를 활성화합니다 . 기본적으로 를 하여 RFC 5746에 따라 클라이언트가 세션을 재사용하고 보안 재협상을 시행하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2acba69363e13d3b2d19cde17064bc6e54ca91a5" translate="yes" xml:space="preserve">
          <source>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</source>
          <target state="translated">MongoDB와 같은 문자열 기반 쿼리가없는 데이터베이스를 지원하기 위해 조각을 사용하여 키워드를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62935c8ccc784ab4effb4cd884f492638a038713" translate="yes" xml:space="preserve">
          <source>In order to support links where &lt;code&gt;:method&lt;/code&gt; is not &lt;code&gt;:get&lt;/code&gt; or use the above data attributes, &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; relies on JavaScript. You can load &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; into your build tool.</source>
          <target state="translated">&lt;code&gt;:method&lt;/code&gt; 가 &lt;code&gt;:get&lt;/code&gt; 이 아닌 위의 데이터 속성을 사용하는 링크를 지원하기 위해 &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 은 JavaScript를 사용합니다. &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; 를 빌드 도구에 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac2a23cefe6dc405ba7cba0e86c91036507b2c2a" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MSSQL, on the other hand, does not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">지도를 지원하기 위해 서로 다른 데이터베이스에서 서로 다른 기술을 사용할 수 있습니다. 예를 들어 PostgreSQL은 이러한 값을 jsonb 필드에 저장하므로 일부만 쿼리 할 수 ​​있습니다. 반면 MSSQL은 아직 JSON 유형을 제공하지 않으므로 값은 텍스트 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0cfbb9e0b757e4a7c387f1a89548e61c769c0468" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">맵을 지원하기 위해, 다른 데이터베이스는 다른 기술을 사용할 수 있습니다. 예를 들어 PostgreSQL은 해당 값을 jsonb 필드에 저장하므로 그 일부만 쿼리 할 수 ​​있습니다. 반면에 MySQL 및 MSSQL은 아직 JSON 유형을 제공하지 않으므로 값이 텍스트 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="52e29e7cb4d222c076586aa6d2efe1e067b45ad8" translate="yes" xml:space="preserve">
          <source>In order to use the check constraint, the first step is to define the check constraint in a migration:</source>
          <target state="translated">검사 제약 조건을 사용하기위한 첫 번째 단계는 마이그레이션에서 검사 제약 조건을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="631c78b05b032bf7a4bc9563b17081acddc1f9da" translate="yes" xml:space="preserve">
          <source>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</source>
          <target state="translated">외래 키 제약 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 외래 키를 정의하는 것입니다. 이것은 종종 참조로 수행됩니다. 예를 들어 게시물에 속하는 주석 테이블을 작성한다고 가정하십시오. 하나는 :</target>
        </trans-unit>
        <trans-unit id="b25785fbeb7db9f5fe5792dc95bd9802bce1df6e" translate="yes" xml:space="preserve">
          <source>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</source>
          <target state="translated">고유성 제한 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 고유 색인을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d32962e066707989deb6579a1bef99dfb02fd652" translate="yes" xml:space="preserve">
          <source>In order to, for instance, support slower clients you can tune the &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options. These specify how much time should be allowed to pass for each read from the underlying socket.</source>
          <target state="translated">예를 들어 느린 클라이언트를 지원하기 위해 &lt;code&gt;:read_length&lt;/code&gt; 및 &lt;code&gt;:read_timeout&lt;/code&gt; 옵션을 조정할 수 있습니다. 이것들은 기본 소켓에서 읽을 때마다 통과해야하는 시간을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0ee12c14d9ca00e6cf48da215974e95f0c7e5650" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;...&lt;/code&gt; will include all the binding between the first and the last, which may be no binding at all, one or many.</source>
          <target state="translated">다시 말해, &lt;code&gt;...&lt;/code&gt; 는 첫 번째와 마지막 사이의 모든 바인딩을 포함하며, 하나 또는 여러 개의 바인딩이 전혀 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d505d82f389daac5da4c66b35201ad586113ff0" translate="yes" xml:space="preserve">
          <source>In other words, when you find yourself wanting to work only with a subset of the data, then using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is most likely unnecessary. Instead, you want to work on the other side of the association.</source>
          <target state="translated">다시 말해, 자신이 데이터의 서브셋으로 만 작업하기를 원할 경우 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 불필요 할 가능성이 높습니다. 대신, 당신은 협회의 다른 쪽에서 일하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6bbbdd02796e8c750180d95d224e10d5ba7f72ee" translate="yes" xml:space="preserve">
          <source>In our example, a &lt;code&gt;User&lt;/code&gt; has and belongs to many &lt;code&gt;Organization&lt;/code&gt;s:</source>
          <target state="translated">이 예에서 &lt;code&gt;User&lt;/code&gt; 는 다음과 같은 여러 &lt;code&gt;Organization&lt;/code&gt; 속합니다 .</target>
        </trans-unit>
        <trans-unit id="41ab6ab1980a050c36b66959ba9f3fe938f26932" translate="yes" xml:space="preserve">
          <source>In our example, a User has and belongs to many Organizations</source>
          <target state="translated">이 예에서 사용자는 많은 조직을 보유하고 있으며</target>
        </trans-unit>
        <trans-unit id="b939b666f3565b6620c702bbdd16fc9969fa1e4b" translate="yes" xml:space="preserve">
          <source>In practice, developers rarely use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; directly. Instead they use &lt;a href=&quot;phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; which wraps the template functionality and adds some extra conveniences.</source>
          <target state="translated">실제로 개발자는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; 을&lt;/a&gt; 직접 사용하는 경우는 거의 없습니다 . 대신 템플릿 기능을 래핑하고 추가 편의를 추가 하는 &lt;a href=&quot;phoenix.view&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="24a1a86627169c9301c553095fe386a37b9ae377" translate="yes" xml:space="preserve">
          <source>In practice, we recommend you to create your own helper with your default builder:</source>
          <target state="translated">실제로 기본 빌더를 사용하여 자체 헬퍼를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="993fe331f8eff395e53c329f899a97ba23a0a92b" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to boostrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">경우에 따라 컨텍스트 모듈 및 테스트를 강화하고 컨텍스트 및 스키마의 내부 구현을 자신에게 맡길 수 있습니다. 이를 수행 하려면 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ade3a11fcd46e0424822bf48a04573731b62fbef" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap JSON views, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">경우에 따라 JSON보기, 컨트롤러 및 컨트롤러 테스트를 부트 스트랩하고 컨텍스트 또는 스키마의 내부 구현을 자신에게 맡길 수 있습니다. 파일 생성 제어를 위해 &lt;code&gt;--no-context&lt;/code&gt; 및 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f55011b0377dd613950bd33fc87827f221a7e3b5" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">어떤 경우에는 컨텍스트 모듈과 테스트를 부트 스트랩하되 컨텍스트와 스키마의 내부 구현을 자신에게 맡기고 싶을 수 있습니다. 이를 수행 하려면 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24c4866aacf268fba081667d7687cebfe5f62ff4" translate="yes" xml:space="preserve">
          <source>In some cases, you might need to render based on the template. For these cases, &lt;code&gt;@view_template&lt;/code&gt; can pair with &lt;a href=&quot;#render_existing/3&quot;&gt;&lt;code&gt;render_existing/3&lt;/code&gt;&lt;/a&gt; for per-template based content, ie:</source>
          <target state="translated">경우에 따라 템플릿을 기반으로 렌더링해야 할 수도 있습니다. 이러한 경우 &lt;code&gt;@view_template&lt;/code&gt; 은 템플릿 기반 콘텐츠에 대해 &lt;a href=&quot;#render_existing/3&quot;&gt; &lt;code&gt;render_existing/3&lt;/code&gt; &lt;/a&gt; 과 쌍을 이룰 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b384998377753d90d4408512efaa31439cf25f8" translate="yes" xml:space="preserve">
          <source>In some cases, you will want to broadcast messages without the context of a &lt;code&gt;socket&lt;/code&gt;. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</source>
          <target state="translated">경우에 따라 &lt;code&gt;socket&lt;/code&gt; 컨텍스트없이 메시지를 브로드 캐스트하려는 경우가 있습니다 . 이는 채널 내에서 외부 주제로 브로드 캐스트하거나 애플리케이션의 다른 곳에서 컨트롤러 또는 다른 프로세스와 같은 브로드 캐스트를위한 것일 수 있습니다. 엔드 포인트를 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556542b6153a0a9877d7ad7e8e95684ac07433c4" translate="yes" xml:space="preserve">
          <source>In some cases, you&amp;rsquo;ll need to generate a request&amp;rsquo;s URL, but using a different scheme, different host, etc. This can be accomplished by concatentating the request path with a custom built URL from your Router helpers, another Endpoint, mix config, or a hand-built string.</source>
          <target state="translated">경우에 따라 요청의 URL을 생성해야하지만 다른 구성표, 다른 호스트 등을 사용해야합니다. 이는 라우터 도우미, 다른 엔드 포인트, 믹스 구성, 또는 손으로 만든 끈.</target>
        </trans-unit>
        <trans-unit id="5d135b52253ea1f76dc118e79a5ba5024dc31ed9" translate="yes" xml:space="preserve">
          <source>In some cases, you'll need to generate a request's URL, but using a different scheme, different host, etc. This can be accomplished in two ways.</source>
          <target state="translated">경우에 따라 요청의 URL을 생성해야하지만 다른 스키마, 다른 호스트 등을 사용합니다. 이는 두 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68280495d51817872c43fe92d60a5737a8f25c18" translate="yes" xml:space="preserve">
          <source>In that example we have a user&amp;rsquo;s id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">이 예에서는 사용자의 ID가 있으며 토큰을 생성하고 주어진 &lt;code&gt;endpoint&lt;/code&gt; 구성된 비밀 키베이스를 사용하여 토큰을 확인 합니다 . 최대 연령 (권장)을 설정하여 토큰이 하루 동안 만 유효 함을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1f41f3118259de0c9215a6b06e0067217d596aea" translate="yes" xml:space="preserve">
          <source>In that example we have a user's id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">이 예에서는 사용자 ID가 있고 토큰을 생성하고 지정된 &lt;code&gt;endpoint&lt;/code&gt; 구성된 비밀 키베이스를 사용하여이를 확인 합니다 . 최대 연령을 설정하여 토큰이 하루 동안 만 유효 함을 보장합니다 (권장).</target>
        </trans-unit>
        <trans-unit id="fd49de9316bf15faaf745aa97193e59f4c5ce77a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;changeset/2&lt;/code&gt; function above, we define three validations. They check that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</source>
          <target state="translated">위의 &lt;code&gt;changeset/2&lt;/code&gt; 함수에서는 세 가지 유효성 검사를 정의합니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;email&lt;/code&gt; 필드가 변경 세트에 있는지 , 전자 메일이 지정된 형식이며, 전자 메일 필드의 고유 한 제한 조건과 함께 전자 메일이 18에서 100 사이인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2beaddf1dc1af0a0afed02b2665a4c614e8c9fe1" translate="yes" xml:space="preserve">
          <source>In the CTE query itself use the same table name to leverage recursion that has been passed to the &lt;code&gt;name&lt;/code&gt; argument. Make sure to write a stop condition to avoid infinite recursion loop. Generally speaking, you should only use CTEs in Ecto for writing recursive queries.</source>
          <target state="translated">CTE 쿼리 자체에서 동일한 테이블 이름을 사용하여 &lt;code&gt;name&lt;/code&gt; 인수에 전달 된 재귀를 활용 합니다. 무한 재귀 루프를 피하기 위해 중지 조건을 작성해야합니다. 일반적으로 Ecto에서는 재귀 쿼리를 작성하기 위해 CTE 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ea091611015f8ec7cc9dd9fea5d96ed83e209c4" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these data structures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">위의 예에서 &lt;code&gt;with&lt;/code&gt; 는 성공적인 post fetch와 일치하는 데 사용되며 현재 사용자에 대한 유효한 권한이 뒤 따릅니다. 둘 중 하나가 일치 하지 않는 경우 &lt;code&gt;with&lt;/code&gt; 는 렌더 블록을 호출하지 않고 대신 일치 하지 않는 값을 반환합니다. 이 경우 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환 했거나 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 반환 했다고 상상해보세요 . 이러한 데이터 구조가 도메인의 여러 경계에서 반환 값으로 사용되는 경우 단일 대체 모듈을 사용하여 값을 유효한 응답으로 변환 할 수 있습니다. 예를 들어 위의 값을 처리하기 위해 다음 폴백 컨트롤러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5795255717d6356ac87649a6472e670f2673298a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these datastructures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">위의 예에서 &lt;code&gt;with&lt;/code&gt; 는 성공적인 포스트 페치에만 일치하고 현재 사용자에 대한 유효한 권한 부여와 일치하는 데 사용됩니다. 중 이들의 경우, 일치 실패 &lt;code&gt;with&lt;/code&gt; 블록을 렌더링 대신 타의 추종을 불허하는 값을 반환하지 않습니다 호출합니다. 이 경우 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 리턴 하거나 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 리턴 했다고 가정하십시오 . 이러한 데이터 구조가 도메인의 여러 경계에서 반환 값으로 사용되는 경우 단일 폴백 모듈을 사용하여 값을 유효한 응답으로 변환 할 수 있습니다. 예를 들어 위의 값을 처리하기 위해 다음 폴백 컨트롤러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1b0c0a37a5ad734fd8c9a63cf167f822b9d6d7" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 응답되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="687f064f0b397a245fd7efdac2c169e020ea3fe3" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 전송되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ed97cc0df14884c8ffa3bce15edcee614a81a95" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 응답되는 한 전송되는 데이터에 대해 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfd5bb81c813b68dd4c64063dd42225fe58dd0c8" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 전송되는 한 전송되는 데이터에 대해 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6084cacdb41ec7942b3031f9f8713fcd0287545b" translate="yes" xml:space="preserve">
          <source>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct defined by an Ecto schema, such as the &lt;code&gt;%User{}&lt;/code&gt; struct defined by the &lt;code&gt;User&lt;/code&gt; module.</source>
          <target state="translated">지금까지 변경 세트 예제에서, 변경 세트를 사용 하여 &lt;code&gt;User&lt;/code&gt; 모듈에 의해 정의 된 &lt;code&gt;%User{}&lt;/code&gt; 구조체 와 같이 Ecto 스키마에 의해 정의 된 구조체에 포함 된 데이터의 유효성을 검증하고 캐스트했습니다 .</target>
        </trans-unit>
        <trans-unit id="6967baeb41fe4aaf65135be1a86f7b7f51cb74b8" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; implementation, the metadata expects the following keys:</source>
          <target state="translated">기본 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt; 구현에서 메타 데이터에는 다음 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c05024d1d5f114eed84c10173ddb5b0423ed6df3" translate="yes" xml:space="preserve">
          <source>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</source>
          <target state="translated">위의 예에서는 스키마를 사용했지만 테이블 이름을 문자열로 지정하여 테이블에 대해 직접 쿼리를 수행 할 수도 있습니다. 이러한 경우 가져올 데이터는 명시 적으로 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="77e215827ec3fbaaba50e0c67d6aa3a380c28048" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6980dcf932f4756073eec7951985832bf4ffdbc2" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;ecto#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;ecto#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0efaf4e38ac06de9330c96ca3071c0aa49d7d17" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; will be available to all plugs invoked after &lt;code&gt;:match&lt;/code&gt;. Such plugs can read from &lt;code&gt;conn.assigns&lt;/code&gt; (or &lt;code&gt;conn.private&lt;/code&gt;) to configure their behaviour based on the matched route.</source>
          <target state="translated">위의 예에서 &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; 은 &lt;code&gt;:match&lt;/code&gt; 이후에 호출 된 모든 플러그에서 사용할 수 있습니다 . 이러한 플러그는 &lt;code&gt;conn.assigns&lt;/code&gt; (또는 &lt;code&gt;conn.private&lt;/code&gt; ) 에서 읽어 일치 경로를 기반으로 동작을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b582e24c785d7e528d91beeaeb2094948f8201" translate="yes" xml:space="preserve">
          <source>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, &lt;a href=&quot;ecto.query.casterror&quot;&gt;&lt;code&gt;Ecto.Query.CastError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">위의 예에서 Ecto는 나이를 정수 유형으로 캐스팅합니다. 값을 캐스트 할 수 없으면 &lt;a href=&quot;ecto.query.casterror&quot;&gt; &lt;code&gt;Ecto.Query.CastError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38da296833b2b1ef41965ac27af71cead65925f5" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &quot;/hello&quot;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 요청은 &lt;code&gt;GET&lt;/code&gt; 요청이고 경로가 &quot;/ hello&quot;인 경우에만 일치 합니다. 지원되는 HTTP 메소드는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a6032006ee3190bfba008183ef22c7724958741" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &amp;ldquo;/hello&amp;rdquo;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 요청은 &lt;code&gt;GET&lt;/code&gt; 요청이고 경로가 &quot;/ hello&quot;인 경우에만 일치 합니다. 지원되는 HTTP 메소드는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb4d85bfa68b487dba755bf14be4d94f034f1c7" translate="yes" xml:space="preserve">
          <source>In the example above, both &lt;code&gt;at_least_four(:doors)&lt;/code&gt; and &lt;code&gt;at_least_four(:tires)&lt;/code&gt; would be valid calls as the field is dynamically generated.</source>
          <target state="translated">위의 예에서 &lt;code&gt;at_least_four(:doors)&lt;/code&gt; 및 &lt;code&gt;at_least_four(:tires)&lt;/code&gt; 는 필드가 동적으로 생성되므로 유효한 호출이됩니다.</target>
        </trans-unit>
        <trans-unit id="f151d0619adc353362eafc28e0ed90d66415139d" translate="yes" xml:space="preserve">
          <source>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; results, like a &lt;code&gt;join&lt;/code&gt; would, it returns only posts with the &lt;code&gt;comments&lt;/code&gt; fields properly filled in.</source>
          <target state="translated">위의 예에서 주석을 가져 오기 위해 별도의 쿼리를 발행하는 대신 Ecto는 단일 쿼리에서 게시물과 주석을 가져오고 각 주석을 상위 게시물에 연결하는 별도의 패스를 수행합니다. 따라서 &lt;code&gt;join&lt;/code&gt; 처럼 &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; 결과 를 반환하는 대신 &lt;code&gt;comments&lt;/code&gt; 필드가 올바르게 채워진 게시물 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4efbfdb8b81848fa5c5be65d29714905c426ad1" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket&amp;rsquo;s topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel&amp;rsquo;s process as a presence for the socket&amp;rsquo;s user ID, with a map of metadata.</source>
          <target state="translated">위의 예에서 소켓 주제에 대한 현재 상태 정보는 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 이벤트 로 클라이언트에 푸시됩니다 . 다음으로 &lt;code&gt;Presence.track&lt;/code&gt; 은이 채널의 프로세스를 메타 데이터 맵과 함께 소켓 사용자 ID의 존재로 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b04f9b48d20bfebf57013a4e3bc857f160f52" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket's topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel's process as a presence for the socket's user ID, with a map of metadata.</source>
          <target state="translated">위의 예에서 소켓 주제에 대한 현재 상태 정보는 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 이벤트 로 클라이언트에 푸시됩니다 . 다음으로 &lt;code&gt;Presence.track&lt;/code&gt; 은이 채널의 프로세스를 메타 데이터 맵과 함께 소켓의 사용자 ID에 대한 존재로 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c5fb7697f09cc5ff0d4a520eb43540e86b99510" translate="yes" xml:space="preserve">
          <source>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</source>
          <target state="translated">위의 예에서 쿼리는 최종 맵에 병합하여 조금씩 작성됩니다. 위의 두 조건이 모두 해당되는 경우 최종 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d58aedac2b16ebd09d651ee588fbf1ba5cf17edd" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &quot;users&quot; table from the database.</source>
          <target state="translated">위의 예에서는 데이터베이스에서 &quot;users&quot;테이블을 직접 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="925feb16ac76c5d3be11e92f48d4338c9def7879" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &amp;ldquo;users&amp;rdquo; table from the database.</source>
          <target state="translated">위의 예에서는 데이터베이스에서 &quot;users&quot;테이블을 직접 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="0bdcc56455db35f7ec8e6aad2349adff0d37f04a" translate="yes" xml:space="preserve">
          <source>In the example above, we are using the lower procedure in the database to downcase the title column.</source>
          <target state="translated">위의 예에서 데이터베이스의 하위 프로 시저를 사용하여 제목 열을 다운 케이스합니다.</target>
        </trans-unit>
        <trans-unit id="6d69428195f2828f8a6f3b10d5d7bcaad49a7a54" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt; is the window function.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt; 은 창 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e6d3d727bce6283546ba164b37335f9c8037c441" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;code&gt;avg/1&lt;/code&gt; is the window function. For more information on windows functions, see &lt;a href=&quot;ecto.query.windowapi&quot;&gt;&lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;code&gt;avg/1&lt;/code&gt; 은 창 함수입니다. windows 함수에 대한 자세한 정보는 &lt;a href=&quot;ecto.query.windowapi&quot;&gt; &lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b237c8ca61ef3e508aa687be188e40ca4adf22f" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a &lt;code&gt;has_many :through&lt;/code&gt; association named &lt;code&gt;:comments_authors&lt;/code&gt;. A &lt;code&gt;:through&lt;/code&gt; association always expects a list and the first element of the list must be a previously defined association in the current module. For example, &lt;code&gt;:comments_authors&lt;/code&gt; first points to &lt;code&gt;:comments&lt;/code&gt; in the same module (Post), which then points to &lt;code&gt;:author&lt;/code&gt; in the next schema, &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;:comments_authors&lt;/code&gt; 라는 &lt;code&gt;has_many :through&lt;/code&gt; 연관을 정의했습니다 . A는 &lt;code&gt;:through&lt;/code&gt; 연관 항상리스트와리스트의 첫 번째 요소는 현재 모듈에서 사전에 정의 된 연관 있어야 기대한다. 예를 들어 &lt;code&gt;:comments_authors&lt;/code&gt; 는 먼저 동일한 모듈 (Post)에서 &lt;code&gt;:comments&lt;/code&gt; 를 가리키고 다음 스키마 인 &lt;code&gt;Comment&lt;/code&gt; 에서 &lt;code&gt;:author&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="85ec2ea6c6ded12b6166febab5316f612414d722" translate="yes" xml:space="preserve">
          <source>In the example above, we used &lt;a href=&quot;#datetime_add/3&quot;&gt;&lt;code&gt;datetime_add/3&lt;/code&gt;&lt;/a&gt; to subtract one month from the current datetime and compared it with the &lt;code&gt;p.published_at&lt;/code&gt;. If you want to perform operations on date, &lt;a href=&quot;#date_add/3&quot;&gt;&lt;code&gt;date_add/3&lt;/code&gt;&lt;/a&gt; could be used.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#datetime_add/3&quot;&gt; &lt;code&gt;datetime_add/3&lt;/code&gt; &lt;/a&gt; 을 사용 하여 현재 날짜 시간에서 한 달을 빼고 &lt;code&gt;p.published_at&lt;/code&gt; 과 비교했습니다 . 날짜에 작업을 수행하려는 경우 &lt;a href=&quot;#date_add/3&quot;&gt; &lt;code&gt;date_add/3&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a77b1f6b12d8b7d6c0db0b804a8d03a2387d7fc2" translate="yes" xml:space="preserve">
          <source>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once inside the query.</source>
          <target state="translated">위의 예에서 우리는 서로 다른 바인딩을 사용하여 쿼리 식을 비트 단위로 빌드 한 다음 쿼리 내부에서 한 번에 보간 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="b3cc98d911ffe36e25f191353a2c3e1efd5e9454" translate="yes" xml:space="preserve">
          <source>In the example below, we get all comments associated to the given post:</source>
          <target state="translated">아래 예에서는 지정된 게시물과 관련된 모든 의견을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="113fef9616300cb9b03a9842f0b9a69b0c3665e7" translate="yes" xml:space="preserve">
          <source>In the examples above, even though it returned &lt;code&gt;:ok&lt;/code&gt;, we do not know if we inserted new data or if we updated only the &lt;code&gt;:on_conflict&lt;/code&gt; fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as &lt;code&gt;inserted_at&lt;/code&gt; will point to now rather than the time the struct was actually inserted.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;:ok&lt;/code&gt; 반환했지만 새 데이터를 삽입했는지 또는 &lt;code&gt;:on_conflict&lt;/code&gt; 필드 만 업데이트했는지는 알 수 없습니다 . 업데이트가 발생한 경우, 구조체의 데이터가 데이터베이스의 데이터와 일치하지 않을 가능성이 높습니다. 예를 들어, 같은 자동 생성 필드 &lt;code&gt;inserted_at&lt;/code&gt; 은 오히려 구조체가 실제로 삽입 된 시간보다 지금 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2f37c0e9a5a67e4ea92ceac140f3ed765f58b555" translate="yes" xml:space="preserve">
          <source>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</source>
          <target state="translated">In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</target>
        </trans-unit>
        <trans-unit id="05a430899144f4642991576f8481a69501d20d42" translate="yes" xml:space="preserve">
          <source>In the form, you now can:</source>
          <target state="translated">양식에서 이제 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94cd064e93fa734125c2fd704a901c1c0fcb707" translate="yes" xml:space="preserve">
          <source>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</source>
          <target state="translated">키워드 쿼리 구문에서 이러한 옵션은 조인 직후에 제공되어야합니다. 표현식 구문에서 옵션은 다섯 번째 인수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="925384cf40775541bef0fdb371ddd4f6902ee2ec" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here&amp;rsquo;s a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">이전 섹션에서는 엔드 포인트에서 자동으로 생성 된 &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; 기능을 사용했습니다 . 다음은 엔드 포인트에서 자동으로 정의 된 모든 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f3c7ddaf3d4a8950203ba5460188209b699de98" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here's a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">이전 섹션에서는 엔드 포인트에서 자동으로 생성되는 &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; 함수를 사용했습니다 . 다음은 엔드 포인트에서 자동으로 정의되는 모든 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e4a55cc79b6410f0afe6d205affc7d1b1d385b5c" translate="yes" xml:space="preserve">
          <source>In the second case, the &lt;code&gt;form_for&lt;/code&gt; emits only the opening of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag, which then needs to be closed explicitly in HTML. Since the anonymous function has been removed, &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is able to optimize forms too. Although outside of live views, we recommend using the first construct.</source>
          <target state="translated">두 번째 경우, &lt;code&gt;form_for&lt;/code&gt; 는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 의 열기 만 내 보냅니다. 그런 다음 HTML에서 명시 적으로 닫아야합니다. 익명 기능이 제거되었으므로 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 도 양식을 최적화 할 수 있습니다. 라이브 뷰 외부에 있지만 첫 번째 구성을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7e2c6811152e546fda2c29bf344f22b16249e04d" translate="yes" xml:space="preserve">
          <source>In this case you can use the name and suffix options together to match on these dynamic indexes, like:</source>
          <target state="translated">이 경우 이름과 접미사 옵션을 함께 사용하여 다음과 같은 동적 색인에서 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c678eccca5ec57c1ed60e620ac17c9a5a18d705b" translate="yes" xml:space="preserve">
          <source>In this case, we haven&amp;rsquo;t checked the unique constraint in the e-mail field because the data did not validate. Let&amp;rsquo;s fix the age and assume, however, that the e-mail already exists in the database:</source>
          <target state="translated">이 경우 데이터의 유효성이 검사되지 않았기 때문에 전자 메일 필드에서 고유 제약 조건을 확인하지 않았습니다. 그러나 연령을 수정하고 전자 메일이 데이터베이스에 이미 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="50bf56697ce917a335edfd2bed8c62011c485096" translate="yes" xml:space="preserve">
          <source>In this case, we haven't checked the unique constraint in the e-mail field because the data did not validate. Let's fix the age and the name, and assume that the e-mail already exists in the database:</source>
          <target state="translated">이 경우 데이터의 유효성을 검사하지 않았기 때문에 전자 메일 필드의 고유 제약 조건을 확인하지 않았습니다. 나이와 이름을 수정하고 전자 메일이 이미 데이터베이스에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f94f214e683bc0e00a7e39c7767a3430885c51b2" translate="yes" xml:space="preserve">
          <source>In this example, the phoenix.js client will send the token in the &lt;code&gt;connect&lt;/code&gt; command which is then validated by the server.</source>
          <target state="translated">이 예제에서 phoenix.js 클라이언트는 &lt;code&gt;connect&lt;/code&gt; 명령으로 토큰을 전송 한 다음 서버에서 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b1c87280301ac2f9d889847d9370825348892494" translate="yes" xml:space="preserve">
          <source>In this example, we know the client sent a valid token because &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; returned a tuple of type &lt;code&gt;{:ok, user_id}&lt;/code&gt;. The server can now proceed with the request.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, user_id}&lt;/code&gt; 유형의 튜플을 반환 했기 때문에 클라이언트가 유효한 토큰을 보냈습니다 . 서버는 이제 요청을 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71e6a35d1eff7b2aab276040bac56ef6b66ab6ad" translate="yes" xml:space="preserve">
          <source>In this example, we prepend the new comment to the list of existing comments. Ecto will diff the list of comments currently in &lt;code&gt;post&lt;/code&gt; with the list of comments given, and correctly insert the new comment to the database. Note, however, Ecto is doing a lot of work just to figure out something we knew since the beginning, which is that there is only one new comment.</source>
          <target state="translated">이 예에서는 기존 주석 목록에 새 주석을 추가합니다. Ecto는 현재 &lt;code&gt;post&lt;/code&gt; 주석 목록을 제공된 주석 목록과 비교하여 새 주석을 데이터베이스에 올바르게 삽입합니다. 그러나 Ecto는 처음부터 우리가 알고있는 것을 알아 내기 위해 많은 노력을 기울이고 있습니다. 즉, 새로운 의견은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="094b03b8c08ae8f0aca1e1b64e1f6fdead91e39c" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. (See &lt;a href=&quot;phoenix.token#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.)</source>
          <target state="translated">이 시나리오에서는 토큰을 생성하고 서명 한 다음 클라이언트 응용 프로그램에 제공합니다. 그러면 클라이언트는이 토큰을 사용하여 서버의 리소스 요청을 인증합니다. 토큰 생성에 대한 자세한 내용은 &lt;a href=&quot;phoenix.token#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; 요약을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d2ca7cf6666758e66d70fb72bd2c17d8cc12775" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. See &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.</source>
          <target state="translated">이 시나리오에서는 토큰을 만들고 서명 한 다음 클라이언트 응용 프로그램에 제공합니다. 그런 다음 클라이언트는이 토큰을 사용하여 서버의 리소스 요청을 인증합니다. 토큰 생성에 대한 자세한 내용은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; 요약을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="534f0da6f14534e0120bbc0f42df3e9cafe2ef69" translate="yes" xml:space="preserve">
          <source>In your posts and tasks:</source>
          <target state="translated">게시물과 작업에서 :</target>
        </trans-unit>
        <trans-unit id="c3b933e481b11d1bde53fbfb5da0612030cd36c5" translate="yes" xml:space="preserve">
          <source>In your test, you can assert that the close happened by:</source>
          <target state="translated">테스트에서 다음과 같이 종료가 발생했다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2145377aa10484f7a6a7e6838ef07513b94b08f3" translate="yes" xml:space="preserve">
          <source>Inclusion operator: &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">포함 연산자 : &lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fb63493844a1ddd4abed4ae031ad06a61ed43a" translate="yes" xml:space="preserve">
          <source>Incoming Events</source>
          <target state="translated">들어오는 이벤트</target>
        </trans-unit>
        <trans-unit id="f330c4ccc52c7952a156d5b90f9e2cb96c8ebbb4" translate="yes" xml:space="preserve">
          <source>Incoming messages</source>
          <target state="translated">수신 메시지</target>
        </trans-unit>
        <trans-unit id="615a09426a8930c611cc2c8dba4ed06391710162" translate="yes" xml:space="preserve">
          <source>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; before being forwarded to a channel.</source>
          <target state="translated">들어오는 메시지는 전송자가 선택하는 방식에 따라 인코딩됩니다. 이러한 메시지는 채널로 전달되기 전에 전송에서 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 로 디코딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2668d897f3e5655c92b0200386d6b654d95aaf3e" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema</source>
          <target state="translated">다른 스키마와 다 대다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6aedb251e3f9159172c6827ec8ede269c15554c5" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema.</source>
          <target state="translated">다른 스키마와의 다 대다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="135ecd7103630379591db4bff96d8d8045c40ee5" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema</source>
          <target state="translated">다른 스키마와 일대 다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13d6cb61c10dc318568f2defc7bea984f223dba4" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema.</source>
          <target state="translated">다른 스키마와 일대 다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1708cc604ed2771df21bc2d718401a60ab2cc1f0" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ae09be75f38bd6a2f7c1a338f1fea359b869e83" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c438499b0af025a1043798095c70140d1dfd657" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3745614dbe3129d4f977d563860dba9c8231878f" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aba2438ae1e81b9920197c224065413b7671c158" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema</source>
          <target state="translated">스키마 임베딩을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b12568554ff04c1842f8599807aa79f64173a10b" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema.</source>
          <target state="translated">스키마의 포함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0754ccd3beda4c7eb864f57ffbfc33fd61e455d7" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99fc922b999b45aabf4ebb20cd1ef3dfc6c0a01f" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas.</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d6143e57414f523ba3e39d5fe528429bec73741" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration</source>
          <target state="translated">엔드 포인트 구성 초기화</target>
        </trans-unit>
        <trans-unit id="5feacf6897a98bceba39f5f4a774ab74aa83f3be" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration.</source>
          <target state="translated">엔드 포인트 구성을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3397476eb797456dd549685d4d13875789ff5bea" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c798c674e519bc2029ac452c4e9259668434c74d" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata.</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2a5ae207d4c7ad36e0e12a08bb38366c31c50683" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="3e313d7032fb8b49aa12e688ee30e31dff8431ca" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents.</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="869617ee9409bb26ae162b9333128e6d4f2497b3" translate="yes" xml:space="preserve">
          <source>Initializes the socket state.</source>
          <target state="translated">소켓 상태를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="fc723255ce4cbc0ec464d52fcc972a1cff32563d" translate="yes" xml:space="preserve">
          <source>Initializes the store</source>
          <target state="translated">상점을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="1948daa5ef81efb1f6ec1462ab9c9c66bafc872e" translate="yes" xml:space="preserve">
          <source>Initializes the store.</source>
          <target state="translated">상점을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0a32892f65c6f195d4bdaf7f60b3ed037aaaf563" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다</target>
        </trans-unit>
        <trans-unit id="aa4d0a4055c28858395d1bfeafcca50d2acb136f" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler.</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6966f2c2b0c652d66d13404f26dd54080032e919" translate="yes" xml:space="preserve">
          <source>Inits a session used exclusively for testing.</source>
          <target state="translated">테스트 전용으로 사용되는 세션을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="da5d892e49eb5ac8b64c4d52c39e57d5d2b08b77" translate="yes" xml:space="preserve">
          <source>Inline embedded schema</source>
          <target state="translated">인라인 임베디드 스키마</target>
        </trans-unit>
        <trans-unit id="569dafe164ae502c9b87c69bc2eeb16d3ac20cb7" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store</source>
          <target state="translated">데이터 저장소에 하나의 새로운 구조체를 삽입합니다</target>
        </trans-unit>
        <trans-unit id="3a1317498687c5894a20801ea9661a9689ed2d87" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store.</source>
          <target state="translated">데이터 저장소에 단일 새 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="86c1d2240ae2916c99327d1f3c4590ec880385b2" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a079a1b2f8984d465d9779ce849f02a429912d56" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset.</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="2181d458ad9deb4e6f83faf70ff675628bae0f26" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository</source>
          <target state="translated">모든 항목을 저장소에 삽입</target>
        </trans-unit>
        <trans-unit id="bc00e3feeb02479984623c1097211a4ee34ffd3d" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository.</source>
          <target state="translated">모든 항목을 저장소에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="9a37ef1a0e51e4ac96d292248e7c141eccd65b5f" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="45c0d55451df6034857c16938433e2842f295184" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store.</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a7003a167a94b7bd8fae5279ac09697a6145d12e" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="dcd7179acaea39cd9930239b8c9b516c75b3f0b6" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not.</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9eeac09af2f2cedab574e42a13a327495bc47759" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not</source>
          <target state="translated">구조체가 유지되는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="518a7ab088e5ce8ed019df775d78816d42febbe1" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not.</source>
          <target state="translated">구조체의 유지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c6d1a59fa5a20ec26ebff17adad30561c03cb5fa" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;select&lt;/code&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; can also be used to cast fragments:</source>
          <target state="translated">내부 &lt;code&gt;select&lt;/code&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 또한 주조 조각에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bd5d902a671eb6810031f5357cbe6027ed13c2f5" translate="yes" xml:space="preserve">
          <source>Inside select: &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; and literals (map, tuples, lists, etc)</source>
          <target state="translated">내부 선택 : &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; 및 리터럴 (지도, 튜플, 목록 등)</target>
        </trans-unit>
        <trans-unit id="5017ef1ca24c2a0d39b26c970ff7ebac50e027e8" translate="yes" xml:space="preserve">
          <source>Instead do this:</source>
          <target state="translated">대신 이것을하십시오 :</target>
        </trans-unit>
        <trans-unit id="53f49b4a03d02b3492955bbf412c1bec4c46145a" translate="yes" xml:space="preserve">
          <source>Instead of setting the action manually, you may use &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; that emulates operations such as &lt;code&gt;Repo.insert&lt;/code&gt;. &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;{:ok, changes}&lt;/code&gt; if the changeset is valid or &lt;code&gt;{:error, changeset}&lt;/code&gt;, with the given &lt;code&gt;action&lt;/code&gt; set in the changeset in case of errors.</source>
          <target state="translated">대신 수동으로 작업을 설정, 당신은 사용할 수 있습니다 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 그와 같은 에뮬레이션 작업 &lt;code&gt;Repo.insert&lt;/code&gt; 가 . 변경 세트가 유효한 경우 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, changes}&lt;/code&gt; 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 를 리턴 하며, 오류가 발생하면 변경 세트에 지정된 &lt;code&gt;action&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ab4eded4494d51c420236d3c9dde1cb217c024c" translate="yes" xml:space="preserve">
          <source>Instead, you can see the valid options for ciphers in the Erlang SSL documentation: http://erlang.org/doc/man/ssl.html</source>
          <target state="translated">대신 Erlang SSL 문서에서 유효한 암호 옵션을 확인할 수 있습니다. http://erlang.org/doc/man/ssl.html</target>
        </trans-unit>
        <trans-unit id="cb49b30bf89c4f1a8a29b63caa0a66ed1c9abce4" translate="yes" xml:space="preserve">
          <source>Instrumentation</source>
          <target state="translated">Instrumentation</target>
        </trans-unit>
        <trans-unit id="e963ac54f9b90e504ad8b5131dedaa40800f87bf" translate="yes" xml:space="preserve">
          <source>Instrumenter to handle logging of various instrumentation events.</source>
          <target state="translated">다양한 계측 이벤트의 로깅을 처리하는 계측기</target>
        </trans-unit>
        <trans-unit id="0a977fa7c155d5db26b9805f1ed5ecb306366925" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint</source>
          <target state="translated">주어진 엔드 포인트가 제공하는 계측을 사용하여 주어진 기능을 계측</target>
        </trans-unit>
        <trans-unit id="040ea1fc514e828951fb8bd3d4e6583bf2dab63c" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint.</source>
          <target state="translated">주어진 엔드 포인트에서 제공하는 계측을 사용하여 지정된 기능을 계측합니다.</target>
        </trans-unit>
        <trans-unit id="a4c71d7db6768276e995bf083955f4cf532a2661" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">정수 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cf4a624177d7b6a2189975011d8cf1553a6ea" translate="yes" xml:space="preserve">
          <source>Intercepting Outgoing Events</source>
          <target state="translated">발신 이벤트 차단</target>
        </trans-unit>
        <trans-unit id="e70cfbd4ab25034bd13454c2505b73098457ac1c" translate="yes" xml:space="preserve">
          <source>Intercepts outgoing &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">나가는 &lt;code&gt;event&lt;/code&gt; 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="352256d32ca814a08dd6fb42ea6e24113694d807" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="eb704a4d49662206b6263bee9e3a6a682a47856e" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas.</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="60fcb5d998d297a0c11dd2b6af2c754859e11297" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 동작을 구현하는데 , 이는 &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 함수가 모두 정의 되어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd342be42586a26dea11e10d4f2f734d1e7b515" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 동작을 구현합니다. 즉, &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 함수가 모두 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="9e19e8e52d010a3380d2cbbab62c90af63b8d211" translate="yes" xml:space="preserve">
          <source>Interpolation and casting</source>
          <target state="translated">보간 및 주조</target>
        </trans-unit>
        <trans-unit id="28f682fd32feb69dea4dd4ff7adfaeaa1d1cf34e" translate="yes" xml:space="preserve">
          <source>Intersect expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the intersection of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#intersect_all/2&quot;&gt;&lt;code&gt;intersect_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">교차 표현식은 각 쿼리가 고유 한 결과를 반환 한 것처럼 고유 한 행만 반환합니다. 성능이 저하 될 수 있습니다. 중복 행을 제거하지 않고 여러 결과 세트의 교차점을 가져와야하는 경우 &lt;a href=&quot;#intersect_all/2&quot;&gt; &lt;code&gt;intersect_all/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="99267cc8937fb84d59bd60cc8326f8d752393db1" translate="yes" xml:space="preserve">
          <source>Intervals</source>
          <target state="translated">Intervals</target>
        </trans-unit>
        <trans-unit id="f5ee41c074ac477895b057c2f41a57f16a778949" translate="yes" xml:space="preserve">
          <source>Invoke this function for each possible value you want to be sent to the server.</source>
          <target state="translated">서버로 보내려는 각 가능한 값에 대해이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="619c9c50996959b8e8f2beefe6dce08a85ac4c47" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;</source>
          <target state="translated">주어진 기간 &lt;code&gt;term&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">주어진 용어 &lt;code&gt;term&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3cf9b446c97f792217c895b34619fd73d2391b8" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="36dca7d832107fe8c35259472cc9700cfe1e2dbf" translate="yes" xml:space="preserve">
          <source>Invoked on termination.</source>
          <target state="translated">종료시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="733a4970520b6a464600ddd46a5ea64dba2a7375" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래에있는 값을 &quot;팝&quot;하기 위해 호출</target>
        </trans-unit>
        <trans-unit id="742607736cb1addcde99f49aeedd51a191858b29" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값을 &quot;팝핑&quot;하도록 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f35bf2a44d8213b1a251a0c82fa8bd2d26bc1736" translate="yes" xml:space="preserve">
          <source>Invoked when the channel process is about to exit.</source>
          <target state="translated">채널 프로세스가 종료 되려고 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="61f50a5fe51f51ed7bfe665e624200109386cacc" translate="yes" xml:space="preserve">
          <source>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</source>
          <target state="translated">엔드 포인트 감독자가 시작될 때 호출되며 시스템 환경 또는 기타 런타임 소스에서 엔드 포인트를 동적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dadda151ad04d6534ebf813dc99705a1a1d25aa9" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="fe65c1df5bce54718f5a6ea6e98b5d9c1a779a60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0516c7f6572d24052272cc4f229ec6f77d29e2" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="092a9376001bb69648a2c2cf84aeeda23d64be60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="0c22586bb54f63849624411c842f2723bc94a4ec" translate="yes" xml:space="preserve">
          <source>It accepts an expression representing the path and many options allowing the match to be configured.</source>
          <target state="translated">경로를 나타내는 표현식과 일치를 구성 할 수있는 많은 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e9e7a6e5fc7e8d490f61f816d70fa682574386e8" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#read_body/2&quot;&gt;&lt;code&gt;read_body/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#read_body/2&quot;&gt; &lt;code&gt;read_body/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="09ea74617913e32e5cdeb3c90a896c1320876968" translate="yes" xml:space="preserve">
          <source>It also supports custom adapter configuration:</source>
          <target state="translated">또한 사용자 정의 어댑터 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="726bf51434f75d8acf5e951711360513b2a0f6e9" translate="yes" xml:space="preserve">
          <source>It builds a new &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, invokes the handler &lt;code&gt;connect/2&lt;/code&gt; callback and returns the result.</source>
          <target state="translated">새 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; 을&lt;/a&gt; 빌드 하고 핸들러 &lt;code&gt;connect/2&lt;/code&gt; 콜백을 호출하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a2cee1f656545c050d15a435216908ba321f2198" translate="yes" xml:space="preserve">
          <source>It can be mounted in your endpoint like any other socket:</source>
          <target state="translated">다른 소켓처럼 엔드 포인트에 마운트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b86f00ae4f81180f207fb516f99df0d0c9b931" translate="yes" xml:space="preserve">
          <source>It can be used to derive a number of keys for various purposes from a given secret. This lets applications have a single secure secret, but avoid reusing that key in multiple incompatible contexts.</source>
          <target state="translated">주어진 비밀에서 다양한 목적으로 여러 키를 파생시키는 데 사용될 수 있습니다. 이를 통해 응용 프로그램은 단일 보안 암호를 가질 수 있지만 호환되지 않는 여러 컨텍스트에서 해당 키를 재사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="23758d8b77b97b076e10f03ba6b30fb6fdbbbd09" translate="yes" xml:space="preserve">
          <source>It can either be a keyword query or a query expression.</source>
          <target state="translated">키워드 쿼리 또는 쿼리 식일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186c38e14a6722baf34f425fa70665e109fc23a0" translate="yes" xml:space="preserve">
          <source>It can reset many fields except the query source (&lt;code&gt;from&lt;/code&gt;). When excluding a &lt;code&gt;:join&lt;/code&gt;, it will remove &lt;em&gt;all&lt;/em&gt; types of joins. If you prefer to remove a single type of join, please see paragraph below.</source>
          <target state="translated">쿼리 소스 ( &lt;code&gt;from&lt;/code&gt; )를 제외한 많은 필드를 재설정 할 수 있습니다 . &lt;code&gt;:join&lt;/code&gt; 을 제외하면 &lt;em&gt;모든&lt;/em&gt; 유형의 조인 이 제거 &lt;em&gt;됩니다&lt;/em&gt; . 단일 유형의 조인을 제거하려면 아래 단락을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19ab39633586fe70e0d92fb43a531d87dd58c9ee" translate="yes" xml:space="preserve">
          <source>It defaults to 5_000.</source>
          <target state="translated">기본값은 5_000입니다.</target>
        </trans-unit>
        <trans-unit id="452abe794374c8a4220fd3958f7c982cbc75a77b" translate="yes" xml:space="preserve">
          <source>It expects &lt;code&gt;{:safe, body}&lt;/code&gt; as a safe response or body as a string which will be HTML escaped.</source>
          <target state="translated">그것은 예상 &lt;code&gt;{:safe, body}&lt;/code&gt; HTML 이스케이프됩니다 문자열로 안전 응답이나 신체 등을.</target>
        </trans-unit>
        <trans-unit id="8540fa79ebeeb04321b6937468baa86cf4bdc0a6" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="acabec8dab50a30917f688b209245a29971cc577" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise, raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;. After &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt; is called, chunks can be sent to the client via the &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; 함수 를 통해 청크를 클라이언트로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c8ac9c1aa8ddc9982ee763c945c57e9b9465d7" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:file&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 그 후 상태를 &lt;code&gt;:file&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1fe68caa8735b3dcb8f4a5c0b34b1b868f77311e" translate="yes" xml:space="preserve">
          <source>It expects a connection with state &lt;code&gt;:chunked&lt;/code&gt; as set by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;. It returns &lt;code&gt;{:ok, conn}&lt;/code&gt; in case of success, otherwise &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 상태 &lt;code&gt;:chunked&lt;/code&gt; 와의 연결이 필요 합니다. 그것은 반환 &lt;code&gt;{:ok, conn}&lt;/code&gt; 그렇지 않으면 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a89874718d53663a7182056d1005a29e9ce37ec6" translate="yes" xml:space="preserve">
          <source>It expects a name or a PID representing a repo.</source>
          <target state="translated">리포를 나타내는 이름 또는 PID가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="acb7e336ed29d294c4566b6d952ca3d23d9cfb62" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</source>
          <target state="translated">첫 번째 인수로 스키마 모듈 ( &lt;code&gt;MyApp.User&lt;/code&gt; ) 또는 소스 ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) 또는 둘 다 ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; )가 필요합니다. 두 번째 인수는 키워드 목록 또는 맵으로 삽입 할 항목 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e373615ede0cb68b0ddc4b7d19e01255f7ceb5ec" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; that returns a single entry with a single value.</source>
          <target state="translated">스키마 모듈 ( &lt;code&gt;MyApp.User&lt;/code&gt; )이나 소스 ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) 또는 둘 다 ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; )가 첫 번째 인수로 예상 됩니다. 두 번째 인수는 키워드 목록 또는 맵으로 삽입 할 항목 목록입니다. 항목의 키는 원자로서의 필드 이름이고 값은 필드 유형에 대한 각각의 값이거나 선택적 으로 단일 값이있는 단일 항목을 리턴 하는 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 여야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="833cf1288bb8a29f6137f917618b60a72a57a732" translate="yes" xml:space="preserve">
          <source>It expects the connection state to be &lt;code&gt;:set&lt;/code&gt;, otherwise raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; for &lt;code&gt;:unset&lt;/code&gt; connections or a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; for already &lt;code&gt;:sent&lt;/code&gt; connections.</source>
          <target state="translated">연결 상태는 &lt;code&gt;:set&lt;/code&gt; 이어야하고 , 그렇지 않으면 &lt;code&gt;:unset&lt;/code&gt; 연결에 대해 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 를 발생 시키거나 이미 &lt;code&gt;:sent&lt;/code&gt; 연결에 대해 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="08038ecbe054a873bb08a6b11a9614856a8f9ff2" translate="yes" xml:space="preserve">
          <source>It expects the value of &lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if there is no state in the session.</source>
          <target state="translated">&lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt; 의 값을 예상합니다 . 세션에 상태가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66c2fa1bb2a3b72c645dc3842e1b860a47918db6" translate="yes" xml:space="preserve">
          <source>It expects the view module, the template as a string, and a set of assigns.</source>
          <target state="translated">뷰 모듈, 문자열로 된 템플릿 및 할당 집합이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7f16d994b67422cffaafcda9f7a4a44b5dac9b6a" translate="yes" xml:space="preserve">
          <source>It has to return a supervisor child specification.</source>
          <target state="translated">감독자 자식 사양을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b418dc1717675b2c364bf1025422ff35a375736" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;a href=&quot;#child_spec/3&quot;&gt;&lt;code&gt;child_spec/3&lt;/code&gt;&lt;/a&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">필요한 &lt;a href=&quot;#child_spec/3&quot;&gt; &lt;code&gt;child_spec/3&lt;/code&gt; &lt;/a&gt; 함수와 WebSocket 전송 핸들러를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="078983c5e35a9c8a686a6ae53ccec194f56ab546" translate="yes" xml:space="preserve">
          <source>It invokes the &lt;code&gt;validator&lt;/code&gt; function to perform the validation only if a change for the given &lt;code&gt;field&lt;/code&gt; exists and the change value is not &lt;code&gt;nil&lt;/code&gt;. The function must return a list of errors (with an empty list meaning no errors).</source>
          <target state="translated">주어진 &lt;code&gt;field&lt;/code&gt; 대한 변경이 존재하고 변경 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 유효성 검증을 수행하기 위해 &lt;code&gt;validator&lt;/code&gt; 함수를 호출합니다 . 이 함수는 오류 목록을 리턴해야합니다 (빈 목록은 오류가 없음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="b32bb8330646b67711708edabee82d77ea1330ee" translate="yes" xml:space="preserve">
          <source>It is advised to do as little work as possible when handling errors and avoid accessing data like parameters and session, as the parsing of those is what could have led the error to trigger in the first place.</source>
          <target state="translated">오류를 처리 할 때 가능한 한 적은 작업을 수행하고 매개 변수 및 세션과 같은 데이터에 액세스하는 것을 피하는 것이 좋습니다.이를 분석하면 오류가 처음에 트리거 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a9bfb318603777a6353f70162343fdb59351cda5" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; 를 혼동하지 않는 것도 중요 합니다. 전자는 연결을 예상하고 콘텐츠 협상에 의존하는 반면 후자는 연결에 구애받지 않고 일반적으로 뷰에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c2327b2734d4abd79bc9e71baaac2419dacff235" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;phoenix.controller#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; 를 혼동하지 않는 것도 중요 합니다. 전자는 연결을 기대하고 콘텐츠 협상에 의존하지만 후자는 연결에 무관하며 일반적으로 사용자의 관점에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a635280fb829c46f3ffad5a5d1753b1e733763d" translate="yes" xml:space="preserve">
          <source>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</source>
          <target state="translated">처리기를 먼저 지정하는 것도 중요합니다. 그렇지 않으면 Phoenix는 처리기가 처리기에 도달하기 전에 요청을 가로 챌 것입니다.</target>
        </trans-unit>
        <trans-unit id="30055e2131468401399af6d6f093161c25f60030" translate="yes" xml:space="preserve">
          <source>It is also not possible to use &lt;code&gt;insert_all&lt;/code&gt; to insert across multiple tables, therefore associations are not supported.</source>
          <target state="translated">&lt;code&gt;insert_all&lt;/code&gt; 을 사용 하여 여러 테이블에 삽입 할 수도 없으므로 연관이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5881689e685ad3746b2176daf7ae680c41d23de2" translate="yes" xml:space="preserve">
          <source>It is also possible to assign data to the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; that will be available to any plug invoked after the &lt;code&gt;:match&lt;/code&gt; plug. This is very useful if you want a matched route to customize how later plugs will behave.</source>
          <target state="translated">또한 &lt;code&gt;:match&lt;/code&gt; 플러그 이후에 호출 된 모든 플러그에서 사용할 수 있는 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 에&lt;/a&gt; 데이터를 할당 할 수도 있습니다 . 이는 나중에 플러그가 작동하는 방식을 사용자 정의하기 위해 일치하는 경로를 원하는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a8b8d8d53d8d8d7bd2e2cb61ea0c656280b0dd19" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate an Ecto query on the right side of &lt;code&gt;in&lt;/code&gt;. For example, the query above can also be written as:</source>
          <target state="translated">그것의 오른쪽 측의 체외 쿼리를 보간하는 것도 가능하다 &lt;code&gt;in&lt;/code&gt; . 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21ad6a95ad909158ac71de812586e3b7701491a" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</source>
          <target state="translated">전체 키워드 목록을 보간하여 소스를 동적으로 필터링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5529f115beed361dd6ff5307741dbc9a975d8d" translate="yes" xml:space="preserve">
          <source>It is also possible to say the type must match the same of a column:</source>
          <target state="translated">유형이 동일한 열과 일치해야한다고 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="731c24ca319f444e53ad6c345b4820aa7c05979b" translate="yes" xml:space="preserve">
          <source>It is also possible to select a struct and limit the returned fields at the same time:</source>
          <target state="translated">구조체를 선택하고 반환 된 필드를 동시에 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a7d66c051591aae4846e19708e277358bb5702" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; directly or even run your own pubsub backends outside of an Endpoint.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 를&lt;/a&gt; 직접 사용 하거나 엔드 포인트 외부에서 고유 한 pubsub 백엔드를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a719d875929b73a5f638e46b11bc306d0aaee72" translate="yes" xml:space="preserve">
          <source>It is compiled to:</source>
          <target state="translated">다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="5f416c91fdafe72dbbea13ab378ff98cfdfba3e1" translate="yes" xml:space="preserve">
          <source>It is composed of the following fields:</source>
          <target state="translated">다음과 같은 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92a07cde7a7c28b24072256a01215dba443d5ba7" translate="yes" xml:space="preserve">
          <source>It is important that &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; is placed before the &lt;code&gt;:dispatch&lt;/code&gt; plug in the pipeline, otherwise the matched clause route will not receive the parsed body in its &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; argument when dispatched.</source>
          <target state="translated">&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 는 파이프 라인에서 &lt;code&gt;:dispatch&lt;/code&gt; 플러그 앞에 배치 하는 것이 중요 합니다 . 그렇지 않으면 일치하는 절 경로가 디스패치 될 때 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 인수 에서 구문 분석 된 본문을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a2e2246bf2f06464052843a1b73d10ceadd7820b" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &quot;html&quot; format whenever:</source>
          <target state="translated">브라우저가 역사적으로 잘못된 수락 헤더를 보냈다는 사실을 알아 두는 것이 중요합니다. 이러한 이유로이 함수는 다음과 같은 경우 &quot;html&quot;형식으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d959bc56d3f9eacdf442d02254dff9bed2d3a24c" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &amp;ldquo;html&amp;rdquo; format whenever:</source>
          <target state="translated">브라우저는 역사적으로 잘못된 수락 헤더를 보냈습니다. 이러한 이유로이 기능은 다음과 같은 경우 항상 &quot;html&quot;형식으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="afc85cab7e33f056d309bd20e21206dd571d1b09" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and want to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">HSTS는 SSL 용 포트가 443 일 것으로 예상하기 때문에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 에서 포트를 직접 구성 할 수 없습니다 . HSTS를 사용하지 않고 다른 포트에서 HTTPS로 리디렉션하려는 경우 호스트와 함께 숨길 수 있습니다 (예 : &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8df7a21de3fad9373d1e80d0a68fb9c2af463623" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;plug.ssl#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and wants to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">HSTS는 포트가 SSL에 대해 443이 될 것으로 예상하므로 &lt;a href=&quot;plug.ssl#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 에서 포트를 직접 구성 할 수 없습니다 . HSTS를 사용하지 않고 다른 포트에서 HTTPS로 경로 재 지정하려는 경우 호스트와 함께 몰래 이동할 수 있습니다 (예 : &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb866ba422c5f8373a8e029337285f653ad8d5ad" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto&amp;rsquo;s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Ecto의 쿼리 구문을 사용하여 가능한 모든 데이터베이스 쿼리를 나타내는 것은 불가능합니다. 필요한 경우 조각을 사용하여 데이터베이스에 표현식을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ce5ae4e3f70bf7bcfc04fd5cadb18e0b1c097f" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto's query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Ecto의 쿼리 구문을 사용하여 가능한 모든 데이터베이스 쿼리를 표현하는 것은 불가능합니다. 필요한 경우 조각을 사용하여 모든 표현식을 데이터베이스에 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f6c0d9ff724f7de2dd203438fa29365111d1aa" translate="yes" xml:space="preserve">
          <source>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">Phoenix 애플리케이션에 사용자 정의 미디어 유형을 추가 할 수 있습니다. 첫 번째 단계는 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 새로운 미디어 유형에 대해 플러그를 가르치는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c6fa08a29b74dfb5f5b32afcba99b61a22649c51" translate="yes" xml:space="preserve">
          <source>It is possible to include variables in the path, these will be available in the &lt;code&gt;params&lt;/code&gt; that are passed to the socket.</source>
          <target state="translated">경로에 변수를 포함 할 수 있으며 소켓으로 전달 되는 &lt;code&gt;params&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2d8626fbe4ef6e2589dce4fc2dd6762fe2a1b8" translate="yes" xml:space="preserve">
          <source>It is possible to make use of PostgreSQL&amp;rsquo;s JSON/JSONB data type with fragments, as well:</source>
          <target state="translated">PostgreSQL의 JSON / JSONB 데이터 유형을 조각과 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef6e9ed5dbdf5b36ce6e79f0b64c7e18c4f11c1" translate="yes" xml:space="preserve">
          <source>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</source>
          <target state="translated">쿼리의 접두사를 설정할 수 있습니다. Postgres 사용자의 경우 테이블이있는 스키마를 지정하고 MySQL 사용자의 경우 테이블이있는 데이터베이스를 지정합니다. 접두사가 설정되지 않으면 Postgres 쿼리는 퍼블릭 스키마에있는 것으로 가정하고 MySQL 쿼리는 리포지토리의 구성에 설정된 데이터베이스에있는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="700c0f421fd3cd0dfcac1f7b125e6e262daac824" translate="yes" xml:space="preserve">
          <source>It is possible to set:</source>
          <target state="translated">다음을 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="90c2522cafce21dec34e2ada4a5ef033ed999c16" translate="yes" xml:space="preserve">
          <source>It is possible to specify a &lt;code&gt;:where&lt;/code&gt; option that will filter the records returned by the association. Querying, joining or preloading the association will use the given conditions as shown next:</source>
          <target state="translated">연결에 의해 반환 된 레코드를 필터링 하는 &lt;code&gt;:where&lt;/code&gt; 옵션 을 지정할 수 있습니다 . 연결 쿼리, 조인 또는 사전로드는 다음과 같이 주어진 조건을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="29ec728a65755ba3d79cf56f0945ca98b6fece30" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lower-case, to avoid sending duplicate keys in a request. As a convenience, this is validated during testing which raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header key is not lowercase.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상, 이것은 헤더 키가 소문자가 아닌 경우 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를&lt;/a&gt; 발생시키는 테스트 중에 검증 됩니다.</target>
        </trans-unit>
        <trans-unit id="b406934b6940f484ccb4f4e12d7de52338c19b17" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 지정하는 것이 좋습니다. 또한 HTTP / 2를 통해 제공되는 대소 문자 혼합 헤더가있는 응답은 일반 클라이언트에서 유효하지 않은 것으로 간주되어 응답이 삭제됩니다. 편의상 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 어댑터를 사용할 때 소문자가 아닌 헤더는 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40511b3383ca8f06336921afea27344c64c63c88" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren&amp;rsquo;t lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 어댑터를 사용할 때 소문자가 아닌 헤더는 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e835d630e658a66295e09f0cfb72bb2ca5635f8b" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; and a default of &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (although Ecto will also automatically translate &lt;code&gt;nil&lt;/code&gt; values from the database into empty lists).</source>
          <target state="translated">형식 &lt;code&gt;:map&lt;/code&gt; 및 기본값 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 필드 를 선언하는 것이 좋습니다 (Ecto는 데이터베이스의 &lt;code&gt;nil&lt;/code&gt; 값 도 자동 으로 빈 목록 으로 변환하지만 ).</target>
        </trans-unit>
        <trans-unit id="06eb543ba97430c42676fb74fc38e6d03236b950" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; in your migrations, instead of using &lt;code&gt;{:array, :map}&lt;/code&gt;. Ecto can work with both maps and arrays as the container for embeds (and in most databases map are represented as JSON which allows Ecto to choose what works best).</source>
          <target state="translated">&lt;code&gt;{:array, :map}&lt;/code&gt; 을 사용하는 대신 마이그레이션에서 &lt;code&gt;:map&lt;/code&gt; 유형으로 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 필드 를 선언하는 것이 좋습니다 . Ecto는 임베딩을위한 컨테이너로 맵과 배열 모두에서 작동 할 수 있습니다 (대부분의 데이터베이스 맵은 JSON으로 표시되어 Ecto가 가장 잘 작동하는 것을 선택할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9795c1abaf982033b2c0ed19994a9b57e226ca48" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &amp;lsquo;dhparam.pem&amp;rsquo; file:</source>
          <target state="translated">DHE 키 교환에 사용될 Diffie Hellman 매개 변수의 사용자 정의 세트를 생성하는 것이 좋습니다. 다음 OpenSSL CLI 명령을 사용하여 'dhparam.pem'파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed21c543268df4242ce9c821e6a091cd15a3cd4" translate="yes" xml:space="preserve">
          <source>It is recommended to include this metadata configuration in your production configuration file.</source>
          <target state="translated">프로덕션 구성 파일에이 메타 데이터 구성을 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3ce90e2d8912f1f2f7b4ea1417a8fb3575961cda" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#media_type/1&quot;&gt;&lt;code&gt;media_type/1&lt;/code&gt;&lt;/a&gt; except wildcards are not accepted in the type nor in the subtype.</source>
          <target state="translated">와일드 카드는 유형이나 하위 유형으로 허용되지 않는다는 점을 제외하면 &lt;a href=&quot;#media_type/1&quot;&gt; &lt;code&gt;media_type/1&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ed4b71fb3d52453bbf4aa28da6905ada01f52ccb" translate="yes" xml:space="preserve">
          <source>It is used on &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt;&lt;code&gt;Ecto.Repo.all/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt;. If returns a tuple, saying if this query can be cached or not, and the &lt;code&gt;prepared&lt;/code&gt; query. The &lt;code&gt;prepared&lt;/code&gt; query is any term that will be passed to the adapter's &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 사용되는 &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt; &lt;code&gt;Ecto.Repo.all/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt; &lt;/a&gt; . If이 쿼리를 캐시 할 수 있는지 여부와 &lt;code&gt;prepared&lt;/code&gt; 쿼리를 나타내는 튜플을 반환 합니다. &lt;code&gt;prepared&lt;/code&gt; 쿼리는 어댑터로 전달의됩니다 어떤 용어 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d8b235293c3fd441987efade8483fcf5a50bbd4" translate="yes" xml:space="preserve">
          <source>It is very common in Phoenix applications to namespace all of your routes under the application scope:</source>
          <target state="translated">응용 프로그램 범위에서 모든 경로를 네임 스페이스로 만드는 것은 Phoenix 응용 프로그램에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="511755381ec8f835711d51bfe3c71d347d8afc8e" translate="yes" xml:space="preserve">
          <source>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; function to give Ecto some hints:</source>
          <target state="translated">Ecto는 프래그먼트를 사용할 때 위에서 설명한 유형 캐스팅을 수행 할 수 없다는 점을 명심해야합니다. 그러나 &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Ecto에 힌트를 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f8bd155fb3b264871458601bfe98b34947ef8af" translate="yes" xml:space="preserve">
          <source>It must be a map and Ecto itself will always inject two keys into the meta:</source>
          <target state="translated">맵이어야하며 Ecto 자체는 항상 메타에 두 개의 키를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="d812a176eca481ceed3aeedcb084d96bdf1cfa9d" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The entries in the actual list will depend on what has been selected by the query. The result set may also be &lt;code&gt;nil&lt;/code&gt;, if no value is being selected.</source>
          <target state="translated">항목 수와 결과 집합을 목록 목록으로 포함하는 튜플을 반환해야합니다. 실제 목록의 항목은 쿼리에서 선택한 항목에 따라 다릅니다. 값이 선택되지 않은 경우 결과 집합은 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c7bf550d2dd91e3eb7f4d8ba8c5d8e72098cb71" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be &lt;code&gt;nil&lt;/code&gt; if a particular operation does not support them.</source>
          <target state="translated">항목 수와 결과 집합이 포함 된 튜플을 목록 목록으로 반환해야합니다. 특정 작업에서 지원하지 않는 경우 결과 집합이 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c372464cefb3e13bb0538ac72ed0e91a45083451" translate="yes" xml:space="preserve">
          <source>It parses the key and stores the value into the current accumulator. The keys and values are not assumed to be encoded in &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">키를 구문 분석하고 값을 현재 누산기에 저장합니다. 키와 값은 &quot;x-www-form-urlencoded&quot;로 인코딩 된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f49388dc41541c5a93c112295bb0bf75921390c9" translate="yes" xml:space="preserve">
          <source>It provides a set of macros to generate routes. For example:</source>
          <target state="translated">라우트를 생성하는 매크로 세트를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aeb6380d88e1271819dcb40ba83ee9babe0b5d5c" translate="yes" xml:space="preserve">
          <source>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</source>
          <target state="translated">서버가 렌더링 할 수있는 형식 목록 인 연결을 수신 한 다음 요청 정보를 기반으로 컨텐츠 협상을 진행합니다. 클라이언트가 주어진 형식 중 하나를 승인하면 요청이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="a632a124b740ee3ecfe4c66cfbe50a9b8a5330c6" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 처음에 주어진 유형의 덤퍼 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5336dd4112321d4cfb426214c2399ecd75a7e8c" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 끝에 주어진 유형의 로더 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8d567de13218d83676c9bf848a612d0dcb63a942" translate="yes" xml:space="preserve">
          <source>It receives the socket options from the endpoint, for example:</source>
          <target state="translated">끝점에서 소켓 옵션을받습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eead6f123b731bd151755a8d6351651f60a5cb89" translate="yes" xml:space="preserve">
          <source>It requires the given form to be configured with &lt;code&gt;multipart: true&lt;/code&gt; when invoking &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt;, otherwise it fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 주어진 양식을 &lt;code&gt;multipart: true&lt;/code&gt; 로 구성 해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="b444a758782f3e5a243723f32117b04bcd1193d7" translate="yes" xml:space="preserve">
          <source>It requires two options:</source>
          <target state="translated">두 가지 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c368117d80fc577cffd447c6b5a5ef62cbb74d54" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, headers, conn}&lt;/code&gt; with the headers or &lt;code&gt;{:done, conn}&lt;/code&gt; if there are no more parts.</source>
          <target state="translated">&lt;code&gt;{:ok, headers, conn}&lt;/code&gt; 와 함께 {: ok, headers, conn} 을 반환 하거나 더 이상 부품이 없으면 &lt;code&gt;{:done, conn}&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625a8c24b534dfa374e922372c9b8979bedc267b" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 또는 &lt;code&gt;{:error, reply}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="056c105e63679c152071fae62b19b0a4e30832f1" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully deleted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삭제 된 경우 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="662e3be55825a0906e817964327528ec203f0e24" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully inserted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삽입되거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="ebff193a925e1e6c88a5aaae59a0f61ddce1cce8" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully updated or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 업데이트하거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="0de4905b00b9de98c7609ccd5172409bb3e98d86" translate="yes" xml:space="preserve">
          <source>It returns a stream of values.</source>
          <target state="translated">값의 스트림을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d945823e21b496648aba33471fce7ac539af8894" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. 데이터베이스가 INSERT 문에서 RETURNING을 지원하지 않거나 리턴 결과가 선택되지 않은 경우 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0aff2437c77d235b55c3776008e824ca479913f4" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the delete query. Note, however, not all databases support returning data from DELETEs.</source>
          <target state="translated">항목 수와 반환 된 결과를 두 번째 요소로 포함하는 튜플을 반환합니다. 두 번째 요소는 삭제 쿼리에 &lt;code&gt;select&lt;/code&gt; 이 제공 되지 않는 한 기본적으로 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 DELETE에서 데이터 반환을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2de945d39c2f6ebed7d1277d00db21d0a2293afd" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from DELETEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 DELETE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd503f783ffe50789a63b679ddc9eae334819de3" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from UPDATEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 UPDATE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5cb46c1b2cfe83bb261f99a63434e88b8c939760" translate="yes" xml:space="preserve">
          <source>It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times.</source>
          <target state="translated">함수의 결과를 반환합니다. 저장소에 대해 여러 작업을 연속으로 수행해야하고 연결을 여러 번 체크 아웃하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c1f14a15c0de711fbde38e075f198dfac5e7435" translate="yes" xml:space="preserve">
          <source>It runs on Distributed Erlang and is the default adapter.</source>
          <target state="translated">Distributed Erlang에서 실행되며 기본 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="617f00d23c5d3066a19c5e3ce78c044821a23f5a" translate="yes" xml:space="preserve">
          <source>It sets the connection state to &lt;code&gt;:set&lt;/code&gt; (if not already &lt;code&gt;:set&lt;/code&gt;) and raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; if it was already &lt;code&gt;:sent&lt;/code&gt;.</source>
          <target state="translated">그것은 연결에 대한 상태를 설정 &lt;code&gt;:set&lt;/code&gt; (그렇지 않으면 이미 &lt;code&gt;:set&lt;/code&gt; )과 인상을 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 그것은 이미 한 경우 &lt;code&gt;:sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c36c6b7e91751f2ec48df7d4ea27f4e7e31732" translate="yes" xml:space="preserve">
          <source>It sets the following headers:</source>
          <target state="translated">다음과 같은 헤더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c088e2a507a2a5e02f9225879e207b1cc9d659c3" translate="yes" xml:space="preserve">
          <source>It uses the configured &lt;code&gt;:format_encoders&lt;/code&gt; under the &lt;code&gt;:phoenix&lt;/code&gt; application for &lt;code&gt;:json&lt;/code&gt; to pick up the encoder module.</source>
          <target state="translated">그것은 구성된 사용 &lt;code&gt;:format_encoders&lt;/code&gt; 언더 &lt;code&gt;:phoenix&lt;/code&gt; 신청 &lt;code&gt;:json&lt;/code&gt; 인코더 모듈을 데리러.</target>
        </trans-unit>
        <trans-unit id="7d6f510fe95fd22f99e4cf0157757d8ec2f9ec70" translate="yes" xml:space="preserve">
          <source>It uses the configured &lt;code&gt;:json_library&lt;/code&gt; under the &lt;code&gt;:phoenix&lt;/code&gt; application for &lt;code&gt;:json&lt;/code&gt; to pick up the encoder module.</source>
          <target state="translated">인코더 모듈을 선택하기 위해 &lt;code&gt;:json&lt;/code&gt; &lt;code&gt;:phoenix&lt;/code&gt; 애플리케이션 아래에 구성된 &lt;code&gt;:json_library&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b9116882d9307a47508d698f93ad21084841fb25" translate="yes" xml:space="preserve">
          <source>It will be rendered in the &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; generated error page as buttons showing the &lt;code&gt;label&lt;/code&gt; that upon pressing executes the MFArgs defined in the &lt;code&gt;handler&lt;/code&gt;.</source>
          <target state="translated">이것은 렌더링한다 &lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 나타내는 버튼으로 생성 된 페이지 오류 &lt;code&gt;label&lt;/code&gt; 가압이 실행시에는 MFArgs에 정의 &lt;code&gt;handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02cb0c375004c2445f7a4b48bb5c6b5a1e02d0ca" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;[custom: :options]&lt;/code&gt; as the builder options were passed to the inner plug.</source>
          <target state="translated">빌더 옵션이 내부 플러그로 전달되면 &lt;code&gt;[custom: :options]&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e932cc853633259a073e9bc817ae714d9a39c458" translate="yes" xml:space="preserve">
          <source>It works exactly as the keyword query version of &lt;a href=&quot;#order_by/3&quot;&gt;&lt;code&gt;order_by/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#order_by/3&quot;&gt; &lt;code&gt;order_by/3&lt;/code&gt; &lt;/a&gt; 의 키워드 쿼리 버전과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e45e5922ce914746230466b94c7fd740acd1fec9" translate="yes" xml:space="preserve">
          <source>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</source>
          <target state="translated">Ecto와는 아무런 차이가 없습니다. 개발자가 초기 쿼리에 사용 된 바인딩에 신경 쓰지 않고 쿼리를 작성할 수 있기 때문에 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f998c41fbf62a9340e17dee0bf437b58bc29010a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to force garbage collection in the transport process after processing large messages.</source>
          <target state="translated">대용량 메시지를 처리 ​​한 후 전송 프로세스에서 가비지 콜렉션을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0bad13f86ad2c5d039679b6eaec2c3d69ca326" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a raw SQL fragment:</source>
          <target state="translated">원시 SQL 조각을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c67d6995f6034c94530f83d33682b8d74b681c" translate="yes" xml:space="preserve">
          <source>It's also possible to select a struct from one source but only a subset of fields from one of its associations:</source>
          <target state="translated">하나의 소스에서 구조체를 선택할 수도 있지만 연결 중 하나에서 필드의 하위 집합 만 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="601895d5e1b09e4e3213f94d4a659f2b62dbafaf" translate="yes" xml:space="preserve">
          <source>It's possible to force garbage collection in the transport process after processing large messages. For example, to trigger such from your channels, run:</source>
          <target state="translated">대용량 메시지를 처리 ​​한 후 전송 프로세스에서 가비지 수집을 강제 할 수 있습니다. 예를 들어 채널에서이를 트리거하려면 다음을 실행하세요.</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">해당 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8591bde56739aa5275d5d85d6a798e00bc371f2c" translate="yes" xml:space="preserve">
          <source>JSON arrays are parsed into a &lt;code&gt;&quot;_json&quot;&lt;/code&gt; key to allow proper param merging.</source>
          <target state="translated">JSON 배열은 &lt;code&gt;&quot;_json&quot;&lt;/code&gt; 키로 구문 분석되어 적절한 매개 변수 병합이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5f94e635b587cbd2a8acf3d3bd9aa404cbc55472" translate="yes" xml:space="preserve">
          <source>JSON documents that aren't maps (arrays, strings, numbers, etc) are parsed into a &lt;code&gt;&quot;_json&quot;&lt;/code&gt; key to allow proper param merging.</source>
          <target state="translated">매핑이 아닌 JSON 문서 (배열, 문자열, 숫자 등)는 적절한 매개 변수 병합을 허용하기 위해 &lt;code&gt;&quot;_json&quot;&lt;/code&gt; 키로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="10d5f74dbf369576734a6ac682a4a030a54c7295" translate="yes" xml:space="preserve">
          <source>JavaScript dependency</source>
          <target state="translated">자바 스크립트 의존성</target>
        </trans-unit>
        <trans-unit id="2487b95e85c7fe6d18646545ea40fb331697431c" translate="yes" xml:space="preserve">
          <source>Join Schema Example</source>
          <target state="translated">조인 스키마 예</target>
        </trans-unit>
        <trans-unit id="669d3f3b74c1d931ea3e5af907f9c949381661d4" translate="yes" xml:space="preserve">
          <source>Joining with fragments</source>
          <target state="translated">조각으로 결합</target>
        </trans-unit>
        <trans-unit id="5207cd0b1b61b86c4ade218e352d2c11be05f56f" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여</target>
        </trans-unit>
        <trans-unit id="27105bb472e95e58a185d9b6f056c464b00b8238" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload.</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="47359e7039cce9b20721fbf73895d042b4baa139" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;:reloadable_compilers&lt;/code&gt; must be a subset of the &lt;code&gt;:compilers&lt;/code&gt; specified in &lt;code&gt;project/0&lt;/code&gt; in your &lt;code&gt;mix.exs&lt;/code&gt;.</source>
          <target state="translated">명심하십시오 &lt;code&gt;:reloadable_compilers&lt;/code&gt; 이 의 하위 집합이어야합니다 &lt;code&gt;:compilers&lt;/code&gt; 에 지정된 &lt;code&gt;project/0&lt;/code&gt; 당신에 &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621e4edd3a1dcb97c56ea183a37744b57bb45b43" translate="yes" xml:space="preserve">
          <source>Keep in mind Phoenix will automatically recycle the connection between dispatches. This usually works out well most times, but it may discard information if you are modifying the connection before the next dispatch:</source>
          <target state="translated">Phoenix는 발송 사이의 연결을 자동으로 재활용합니다. 일반적으로 대부분 잘 작동하지만 다음 디스패치 전에 연결을 수정하면 정보가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1d18ab5d51cf02602c0cbc6206bcd60ecb5e7a" translate="yes" xml:space="preserve">
          <source>Keep in mind that this function does not generate hidden inputs automatically like &lt;code&gt;inputs/4&lt;/code&gt;. To generate them you need to explicit do it by yourself.</source>
          <target state="translated">이 함수는 &lt;code&gt;inputs/4&lt;/code&gt; 처럼 숨겨진 입력을 자동으로 생성하지 않습니다 . 그것들을 생성하려면 명시 적으로 직접해야합니다.</target>
        </trans-unit>
        <trans-unit id="331125190d2a2354adf50058bea5b635af515279" translate="yes" xml:space="preserve">
          <source>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always convert atom keys to strings due to security reasons.</source>
          <target state="translated">지도 키는 원자 대신 문자열 또는 정수로 사용하는 것이 좋습니다. 맵이 직렬화되는 방식에 따라 원자가 승인 될 수 있지만 데이터베이스는 보안상의 이유로 항상 원자 키를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2cfc2cb8633912216c377009001c7ec706c71ef5" translate="yes" xml:space="preserve">
          <source>Keep in mind that, once the &lt;code&gt;@endpoint&lt;/code&gt; variable is set, all tests after setting it will be affected.</source>
          <target state="translated">한 번 것을 명심 &lt;code&gt;@endpoint&lt;/code&gt; 변수가 설정되어, 그것을 설정 한 후 모든 테스트가 영향을받습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
