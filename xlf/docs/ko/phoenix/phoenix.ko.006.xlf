<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="d945823e21b496648aba33471fce7ac539af8894" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. 데이터베이스가 INSERT 문에서 RETURNING을 지원하지 않거나 리턴 결과가 선택되지 않은 경우 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0aff2437c77d235b55c3776008e824ca479913f4" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the delete query. Note, however, not all databases support returning data from DELETEs.</source>
          <target state="translated">항목 수와 반환 된 결과를 두 번째 요소로 포함하는 튜플을 반환합니다. 두 번째 요소는 삭제 쿼리에 &lt;code&gt;select&lt;/code&gt; 이 제공 되지 않는 한 기본적으로 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 DELETE에서 데이터 반환을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2de945d39c2f6ebed7d1277d00db21d0a2293afd" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from DELETEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 DELETE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd503f783ffe50789a63b679ddc9eae334819de3" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from UPDATEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 UPDATE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="924df8aebecdfde6525414ea66a7d85277ac7359" translate="yes" xml:space="preserve">
          <source>It returns either &lt;code&gt;{user, pass}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. Note the username and password may be empty strings. When comparing the username and password with the expected values, be sure to use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt;&lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{user, pass}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 를 반환합니다 . 사용자 이름과 암호는 빈 문자열 일 수 있습니다. 사용자 이름 및 비밀번호를 예상 값과 비교할 때 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt; &lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7bfcb5fbfeb4e8a87b20c4f8b37d3c7e75b025f5" translate="yes" xml:space="preserve">
          <source>It returns the connection</source>
          <target state="translated">연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd89579ebcddbd76baee2e79998a29b054ef952c" translate="yes" xml:space="preserve">
          <source>It returns the contents of the whole LiveView or an &lt;code&gt;{:error, redirect}&lt;/code&gt; tuple.</source>
          <target state="translated">전체 LiveView의 내용 또는 &lt;code&gt;{:error, redirect}&lt;/code&gt; 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aa7c31c85502cb370898f99548a9d000dca49e14" translate="yes" xml:space="preserve">
          <source>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</source>
          <target state="translated">해당 리디렉션에서 플래시 메시지를 반환합니다. 플래시에는 문자열 키가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cb46c1b2cfe83bb261f99a63434e88b8c939760" translate="yes" xml:space="preserve">
          <source>It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times.</source>
          <target state="translated">함수의 결과를 반환합니다. 저장소에 대해 여러 작업을 연속으로 수행해야하고 연결을 여러 번 체크 아웃하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c1f14a15c0de711fbde38e075f198dfac5e7435" translate="yes" xml:space="preserve">
          <source>It runs on Distributed Erlang and is the default adapter.</source>
          <target state="translated">Distributed Erlang에서 실행되며 기본 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="617f00d23c5d3066a19c5e3ce78c044821a23f5a" translate="yes" xml:space="preserve">
          <source>It sets the connection state to &lt;code&gt;:set&lt;/code&gt; (if not already &lt;code&gt;:set&lt;/code&gt;) and raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; if it was already &lt;code&gt;:sent&lt;/code&gt;.</source>
          <target state="translated">그것은 연결에 대한 상태를 설정 &lt;code&gt;:set&lt;/code&gt; (그렇지 않으면 이미 &lt;code&gt;:set&lt;/code&gt; )과 인상을 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 그것은 이미 한 경우 &lt;code&gt;:sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c36c6b7e91751f2ec48df7d4ea27f4e7e31732" translate="yes" xml:space="preserve">
          <source>It sets the following headers:</source>
          <target state="translated">다음과 같은 헤더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f7f6d7a763b6a57c836df0d7b9f4427462c6003d" translate="yes" xml:space="preserve">
          <source>It sets the response to status 401 with &quot;Unauthorized&quot; as body. The response is not sent though (nor the connection is halted), allowing developers to further customize it.</source>
          <target state="translated">&quot;Unauthorized&quot;를 본문으로하여 상태 401에 대한 응답을 설정합니다. 그러나 응답은 전송되지 않으며 (연결이 중단되지도 않음) 개발자가 추가로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef137c6da1cbca6cee324075b5264af1feba64e" translate="yes" xml:space="preserve">
          <source>It silently ignores our &lt;code&gt;DoesNotExist&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;DoesNotExist&lt;/code&gt; 인수를 조용히 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="c088e2a507a2a5e02f9225879e207b1cc9d659c3" translate="yes" xml:space="preserve">
          <source>It uses the configured &lt;code&gt;:format_encoders&lt;/code&gt; under the &lt;code&gt;:phoenix&lt;/code&gt; application for &lt;code&gt;:json&lt;/code&gt; to pick up the encoder module.</source>
          <target state="translated">그것은 구성된 사용 &lt;code&gt;:format_encoders&lt;/code&gt; 언더 &lt;code&gt;:phoenix&lt;/code&gt; 신청 &lt;code&gt;:json&lt;/code&gt; 인코더 모듈을 데리러.</target>
        </trans-unit>
        <trans-unit id="7d6f510fe95fd22f99e4cf0157757d8ec2f9ec70" translate="yes" xml:space="preserve">
          <source>It uses the configured &lt;code&gt;:json_library&lt;/code&gt; under the &lt;code&gt;:phoenix&lt;/code&gt; application for &lt;code&gt;:json&lt;/code&gt; to pick up the encoder module.</source>
          <target state="translated">인코더 모듈을 선택하기 위해 &lt;code&gt;:json&lt;/code&gt; &lt;code&gt;:phoenix&lt;/code&gt; 애플리케이션 아래에 구성된 &lt;code&gt;:json_library&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b9116882d9307a47508d698f93ad21084841fb25" translate="yes" xml:space="preserve">
          <source>It will be rendered in the &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; generated error page as buttons showing the &lt;code&gt;label&lt;/code&gt; that upon pressing executes the MFArgs defined in the &lt;code&gt;handler&lt;/code&gt;.</source>
          <target state="translated">이것은 렌더링한다 &lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 나타내는 버튼으로 생성 된 페이지 오류 &lt;code&gt;label&lt;/code&gt; 가압이 실행시에는 MFArgs에 정의 &lt;code&gt;handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02cb0c375004c2445f7a4b48bb5c6b5a1e02d0ca" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;[custom: :options]&lt;/code&gt; as the builder options were passed to the inner plug.</source>
          <target state="translated">빌더 옵션이 내부 플러그로 전달되면 &lt;code&gt;[custom: :options]&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ddba2f855f34fd40029b7e959661d2f36de8221" translate="yes" xml:space="preserve">
          <source>It will tell us we need to add a line to our router file, but since we skipped the context, it won't mention anything about &lt;code&gt;ecto.migrate&lt;/code&gt;.</source>
          <target state="translated">라우터 파일에 한 줄을 추가해야한다고 알려 주지만 컨텍스트를 건너 뛰었 &lt;code&gt;ecto.migrate&lt;/code&gt; 대해서는 언급하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="149a7f29f63bd4a86b4a736fa7a02ca642c29873" translate="yes" xml:space="preserve">
          <source>It will tell us we need to add a line to our router file, but since we skipped the schema, it won't mention anything about &lt;code&gt;ecto.migrate&lt;/code&gt;.</source>
          <target state="translated">라우터 파일에 한 줄을 추가해야한다고 알려 주지만 스키마를 건너 뛰었 &lt;code&gt;ecto.migrate&lt;/code&gt; 대해서는 언급하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e932cc853633259a073e9bc817ae714d9a39c458" translate="yes" xml:space="preserve">
          <source>It works exactly as the keyword query version of &lt;a href=&quot;#order_by/3&quot;&gt;&lt;code&gt;order_by/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#order_by/3&quot;&gt; &lt;code&gt;order_by/3&lt;/code&gt; &lt;/a&gt; 의 키워드 쿼리 버전과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e45e5922ce914746230466b94c7fd740acd1fec9" translate="yes" xml:space="preserve">
          <source>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</source>
          <target state="translated">Ecto와는 아무런 차이가 없습니다. 개발자가 초기 쿼리에 사용 된 바인딩에 신경 쓰지 않고 쿼리를 작성할 수 있기 때문에 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f998c41fbf62a9340e17dee0bf437b58bc29010a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to force garbage collection in the transport process after processing large messages.</source>
          <target state="translated">대용량 메시지를 처리 ​​한 후 전송 프로세스에서 가비지 콜렉션을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0bad13f86ad2c5d039679b6eaec2c3d69ca326" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a raw SQL fragment:</source>
          <target state="translated">원시 SQL 조각을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c67d6995f6034c94530f83d33682b8d74b681c" translate="yes" xml:space="preserve">
          <source>It's also possible to select a struct from one source but only a subset of fields from one of its associations:</source>
          <target state="translated">하나의 소스에서 구조체를 선택할 수도 있지만 연결 중 하나에서 필드의 하위 집합 만 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d86978176e191d21853fe7dafbc4ac471d0efc4c" translate="yes" xml:space="preserve">
          <source>It's good to remember that the keys to the &lt;code&gt;params&lt;/code&gt; map will always be strings, and that the equals sign does not represent assignment, but is instead a &lt;a href=&quot;https://elixir-lang.org/getting-started/pattern-matching.html&quot;&gt;pattern match&lt;/a&gt; assertion.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 맵 의 키 는 항상 문자열이며 등호는 할당을 나타내지 않고 대신 &lt;a href=&quot;https://elixir-lang.org/getting-started/pattern-matching.html&quot;&gt;패턴 일치&lt;/a&gt; 어설 션 임을 기억하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bd9215e845c900f34bbb70bff0a45dec90efc481" translate="yes" xml:space="preserve">
          <source>It's not much to look at yet, but it works! We added relationships within our context complete with data integrity enforced by the database. Not bad. Let's keep building!</source>
          <target state="translated">아직 볼 것이 많지는 않지만 작동합니다! 우리는 데이터베이스에 의해 시행되는 데이터 무결성을 갖춘 컨텍스트 내에서 관계를 추가했습니다. 나쁘지 않다. 계속 건축합시다!</target>
        </trans-unit>
        <trans-unit id="601895d5e1b09e4e3213f94d4a659f2b62dbafaf" translate="yes" xml:space="preserve">
          <source>It's possible to force garbage collection in the transport process after processing large messages. For example, to trigger such from your channels, run:</source>
          <target state="translated">대용량 메시지를 처리 ​​한 후 전송 프로세스에서 가비지 수집을 강제 할 수 있습니다. 예를 들어 채널에서이를 트리거하려면 다음을 실행하세요.</target>
        </trans-unit>
        <trans-unit id="5e159505e2931874c15d67643b9d12ab0948f554" translate="yes" xml:space="preserve">
          <source>It's useful to build our views like this so they can be composable. Imagine a situation where our &lt;code&gt;Page&lt;/code&gt; has a &lt;code&gt;has_many&lt;/code&gt; relationship with &lt;code&gt;Author&lt;/code&gt;, and depending on the request, we may want to send back &lt;code&gt;author&lt;/code&gt; data with the &lt;code&gt;page&lt;/code&gt;. We can easily accomplish this with a new &lt;code&gt;render/2&lt;/code&gt;:</source>
          <target state="translated">이러한 뷰를 구성 할 수 있도록 빌드하는 것이 유용합니다. &lt;code&gt;Page&lt;/code&gt; 가 &lt;code&gt;Author&lt;/code&gt; 와 &lt;code&gt;has_many&lt;/code&gt; 관계를 가지고 있고 요청에 따라 &lt;code&gt;page&lt;/code&gt; 와 함께 &lt;code&gt;author&lt;/code&gt; 데이터를 다시 보낼 수 있는 상황을 상상해보십시오 . 새로운 &lt;code&gt;render/2&lt;/code&gt; 를 사용하면 쉽게이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">해당 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae26f3399aaf66d16451149f87b3d5a3a4a383d" translate="yes" xml:space="preserve">
          <source>JS Interop</source>
          <target state="translated">JS Interop</target>
        </trans-unit>
        <trans-unit id="8591bde56739aa5275d5d85d6a798e00bc371f2c" translate="yes" xml:space="preserve">
          <source>JSON arrays are parsed into a &lt;code&gt;&quot;_json&quot;&lt;/code&gt; key to allow proper param merging.</source>
          <target state="translated">JSON 배열은 &lt;code&gt;&quot;_json&quot;&lt;/code&gt; 키로 구문 분석되어 적절한 매개 변수 병합이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5f94e635b587cbd2a8acf3d3bd9aa404cbc55472" translate="yes" xml:space="preserve">
          <source>JSON documents that aren't maps (arrays, strings, numbers, etc) are parsed into a &lt;code&gt;&quot;_json&quot;&lt;/code&gt; key to allow proper param merging.</source>
          <target state="translated">매핑이 아닌 JSON 문서 (배열, 문자열, 숫자 등)는 적절한 매개 변수 병합을 허용하기 위해 &lt;code&gt;&quot;_json&quot;&lt;/code&gt; 키로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3046d7f74c5d145e9f80f7e75de3fb0bf2bc308" translate="yes" xml:space="preserve">
          <source>JavaScript client specifics</source>
          <target state="translated">자바 스크립트 클라이언트 사양</target>
        </trans-unit>
        <trans-unit id="10d5f74dbf369576734a6ac682a4a030a54c7295" translate="yes" xml:space="preserve">
          <source>JavaScript dependency</source>
          <target state="translated">자바 스크립트 의존성</target>
        </trans-unit>
        <trans-unit id="139ff8a996ffe156ad8f421af90aa4672024be1b" translate="yes" xml:space="preserve">
          <source>JavaScript interoperability</source>
          <target state="translated">JavaScript 상호 운용성</target>
        </trans-unit>
        <trans-unit id="2487b95e85c7fe6d18646545ea40fb331697431c" translate="yes" xml:space="preserve">
          <source>Join Schema Example</source>
          <target state="translated">조인 스키마 예</target>
        </trans-unit>
        <trans-unit id="669d3f3b74c1d931ea3e5af907f9c949381661d4" translate="yes" xml:space="preserve">
          <source>Joining with fragments</source>
          <target state="translated">조각으로 결합</target>
        </trans-unit>
        <trans-unit id="5207cd0b1b61b86c4ade218e352d2c11be05f56f" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여</target>
        </trans-unit>
        <trans-unit id="27105bb472e95e58a185d9b6f056c464b00b8238" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload.</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="36905bd1fff9222632605ecfdef619f26143aad5" translate="yes" xml:space="preserve">
          <source>Just like we extended our &lt;code&gt;Accounts&lt;/code&gt; context with new application-specific functions like &lt;code&gt;Accounts.authenticate_by_email_password/2&lt;/code&gt;, let's extend our generated &lt;code&gt;CMS&lt;/code&gt; context with new functionality. For any CMS system, the ability to track how many times a page has been viewed is essential for popularity ranks. While we could try to use the existing &lt;code&gt;CMS.update_page&lt;/code&gt; function, along the lines of &lt;code&gt;CMS.update_page(user, page, %{views: page.views + 1})&lt;/code&gt;, this would not only be prone to race conditions, but it would also require the caller to know too much about our CMS system. To see why the race condition exists, let's walk through the possible execution of events:</source>
          <target state="translated">&lt;code&gt;Accounts.authenticate_by_email_password/2&lt;/code&gt; 와 같은 새로운 애플리케이션 별 기능으로 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 확장 한 것처럼 생성 된 &lt;code&gt;CMS&lt;/code&gt; 컨텍스트를 새로운 기능으로 확장 해 보겠습니다 . 모든 CMS 시스템에서 페이지를 본 횟수를 추적하는 기능은 인기 순위에 필수적입니다. &lt;code&gt;CMS.update_page(user, page, %{views: page.views + 1})&lt;/code&gt; 라인을 따라 기존 &lt;code&gt;CMS.update_page&lt;/code&gt; 함수 를 사용하려고 할 수 있지만 이는 경쟁 조건에 취약 할뿐만 아니라 또한 발신자가 CMS 시스템에 대해 너무 많이 알도록 요구합니다. 경쟁 조건이 존재하는 이유를 확인하기 위해 가능한 이벤트 실행을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="47359e7039cce9b20721fbf73895d042b4baa139" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;:reloadable_compilers&lt;/code&gt; must be a subset of the &lt;code&gt;:compilers&lt;/code&gt; specified in &lt;code&gt;project/0&lt;/code&gt; in your &lt;code&gt;mix.exs&lt;/code&gt;.</source>
          <target state="translated">명심하십시오 &lt;code&gt;:reloadable_compilers&lt;/code&gt; 이 의 하위 집합이어야합니다 &lt;code&gt;:compilers&lt;/code&gt; 에 지정된 &lt;code&gt;project/0&lt;/code&gt; 당신에 &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621e4edd3a1dcb97c56ea183a37744b57bb45b43" translate="yes" xml:space="preserve">
          <source>Keep in mind Phoenix will automatically recycle the connection between dispatches. This usually works out well most times, but it may discard information if you are modifying the connection before the next dispatch:</source>
          <target state="translated">Phoenix는 발송 사이의 연결을 자동으로 재활용합니다. 일반적으로 대부분 잘 작동하지만 다음 디스패치 전에 연결을 수정하면 정보가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd156cffe7c952d3001480181dfb7fffbd5f002" translate="yes" xml:space="preserve">
          <source>Keep in mind most helpers will automatically escape your data and return safe content:</source>
          <target state="translated">대부분의 도우미는 자동으로 데이터를 이스케이프하고 안전한 콘텐츠를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b1d18ab5d51cf02602c0cbc6206bcd60ecb5e7a" translate="yes" xml:space="preserve">
          <source>Keep in mind that this function does not generate hidden inputs automatically like &lt;code&gt;inputs/4&lt;/code&gt;. To generate them you need to explicit do it by yourself.</source>
          <target state="translated">이 함수는 &lt;code&gt;inputs/4&lt;/code&gt; 처럼 숨겨진 입력을 자동으로 생성하지 않습니다 . 그것들을 생성하려면 명시 적으로 직접해야합니다.</target>
        </trans-unit>
        <trans-unit id="331125190d2a2354adf50058bea5b635af515279" translate="yes" xml:space="preserve">
          <source>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always convert atom keys to strings due to security reasons.</source>
          <target state="translated">지도 키는 원자 대신 문자열 또는 정수로 사용하는 것이 좋습니다. 맵이 직렬화되는 방식에 따라 원자가 승인 될 수 있지만 데이터베이스는 보안상의 이유로 항상 원자 키를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2cfc2cb8633912216c377009001c7ec706c71ef5" translate="yes" xml:space="preserve">
          <source>Keep in mind that, once the &lt;code&gt;@endpoint&lt;/code&gt; variable is set, all tests after setting it will be affected.</source>
          <target state="translated">한 번 것을 명심 &lt;code&gt;@endpoint&lt;/code&gt; 변수가 설정되어, 그것을 설정 한 후 모든 테스트가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="7156ebc4567873a3817311da3893b5b592122d73" translate="yes" xml:space="preserve">
          <source>Keep in mind that:</source>
          <target state="translated">다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="2b5e3cabe364eb4be494f179754ad9a13637213c" translate="yes" xml:space="preserve">
          <source>Keep in mind this &lt;code&gt;update_all&lt;/code&gt; will not update autogenerated fields like the &lt;code&gt;updated_at&lt;/code&gt; columns.</source>
          <target state="translated">이 &lt;code&gt;update_all&lt;/code&gt; 은 &lt;code&gt;updated_at&lt;/code&gt; 열과 같은 자동 생성 필드를 업데이트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="299a4b98174cae36a3bded071df303aca8d08070" translate="yes" xml:space="preserve">
          <source>Keep in mind you want to use hints rarely, so don&amp;rsquo;t forget to read the database disclaimers about such functionality.</source>
          <target state="translated">힌트를 거의 사용하지 않으려면 이러한 기능에 대한 데이터베이스 고지 사항을 반드시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="99df1f280e467893f63a398d472343b6527bd03b" translate="yes" xml:space="preserve">
          <source>Keep in mind you want to use hints rarely, so don't forget to read the database disclaimers about such functionality.</source>
          <target state="translated">힌트를 거의 사용하지 않기를 원하므로 이러한 기능에 대한 데이터베이스 고지 사항을 읽는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9a94cfc7b2fedabc45202f752518e42387b1479f" translate="yes" xml:space="preserve">
          <source>Keeps track of presences in a single shard</source>
          <target state="translated">단일 샤드에서 현재 상태를 추적합니다</target>
        </trans-unit>
        <trans-unit id="9afa61b2e05cde4863011a25acd0c7ddf79ee17b" translate="yes" xml:space="preserve">
          <source>Key Events</source>
          <target state="translated">중요 행사들</target>
        </trans-unit>
        <trans-unit id="07a8182406eb3604641127149a583b03956a7aec" translate="yes" xml:space="preserve">
          <source>Keys are case insensitive and downcased, invalid key-value pairs are discarded.</source>
          <target state="translated">키는 대소 문자를 구분하지 않으며 소문자이며 유효하지 않은 키-값 쌍은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9a6f4f87d376adf6445b438a9285b6badbe80b" translate="yes" xml:space="preserve">
          <source>Keys are retrieved from the optional transport option &lt;code&gt;:connect_info&lt;/code&gt;. This functionality is transport specific. Please refer to your transports' documentation for more information.</source>
          <target state="translated">키는 선택적 전송 옵션 &lt;code&gt;:connect_info&lt;/code&gt; 에서 검색됩니다 . 이 기능은 전송에 따라 다릅니다. 자세한 내용은 운송의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f646918bb09aa52636f453f3bef43322294ab327" translate="yes" xml:space="preserve">
          <source>Keyword fragments</source>
          <target state="translated">키워드 조각</target>
        </trans-unit>
        <trans-unit id="0b249c97792474709b8dbb21e02d67cf22c8da85" translate="yes" xml:space="preserve">
          <source>Keyword syntax is not supported for this feature.</source>
          <target state="translated">이 기능에는 키워드 구문이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6f5b95bb6336d1b9972cc37a8893e22ef3605ff" translate="yes" xml:space="preserve">
          <source>Keywords can also be given or interpolated as part of &lt;code&gt;on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 의 일부로 키워드를 제공하거나 보간 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2723e28604ac818370f58695dbeb251d15a692e0" translate="yes" xml:space="preserve">
          <source>Keywords example</source>
          <target state="translated">키워드 예</target>
        </trans-unit>
        <trans-unit id="8527969b5917b99377eaa45d7f9a2ada9dc3bfd2" translate="yes" xml:space="preserve">
          <source>Keywords examples</source>
          <target state="translated">키워드 예</target>
        </trans-unit>
        <trans-unit id="4bbd4701bb11bdf8cb772e866b8507d8365cf806" translate="yes" xml:space="preserve">
          <source>Known status codes</source>
          <target state="translated">알려진 상태 코드</target>
        </trans-unit>
        <trans-unit id="0b12a998982672c9c6ed53b2d324f6daa513af06" translate="yes" xml:space="preserve">
          <source>Last but not least, Ecto allows you to write queries in Elixir and send them to the repository, which translates them to the underlying database. Let&amp;rsquo;s see an example:</source>
          <target state="translated">마지막으로, Ecto를 사용하면 Elixir에서 쿼리를 작성하고 리포지토리로 보내서 기본 데이터베이스로 변환 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="702241aa302739e0becf3fc3c06fbcb3099a27e3" translate="yes" xml:space="preserve">
          <source>Last but not least, Ecto allows you to write queries in Elixir and send them to the repository, which translates them to the underlying database. Let's see an example:</source>
          <target state="translated">마지막으로 Ecto를 사용하면 Elixir에서 쿼리를 작성하고 저장소로 보낼 수 있습니다. 그러면 기본 데이터베이스로 변환됩니다. 예를 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="42200979a26f89842487674a8dffdd14c8ac5823" translate="yes" xml:space="preserve">
          <source>Lastly, we need &lt;code&gt;SessionView&lt;/code&gt; to render a template for our login form. Create a new file in &lt;code&gt;lib/hello_web/views/session_view.ex&lt;/code&gt;:</source>
          <target state="translated">마지막으로 로그인 양식에 대한 템플릿을 렌더링 하려면 &lt;code&gt;SessionView&lt;/code&gt; 가 필요 합니다. &lt;code&gt;lib/hello_web/views/session_view.ex&lt;/code&gt; 에 새 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="28e6f54e33a1151bfd4c7cc4affd14df3525f2db" translate="yes" xml:space="preserve">
          <source>Layouts</source>
          <target state="translated">Layouts</target>
        </trans-unit>
        <trans-unit id="383ff585f68829ad8a7e8dffc2a85a7b7dbecf93" translate="yes" xml:space="preserve">
          <source>Layouts are just a special subset of templates. They live in &lt;code&gt;lib/hello_web/templates/layout&lt;/code&gt;. Phoenix created one for us when we generated our app. The default layout is called &lt;code&gt;app.html.eex&lt;/code&gt;, and it is the layout into which all templates will be rendered by default.</source>
          <target state="translated">레이아웃은 템플릿의 특별한 하위 집합입니다. 그들은 살고 &lt;code&gt;lib/hello_web/templates/layout&lt;/code&gt; . Phoenix는 우리가 앱을 만들 때 우리를 위해 하나를 만들었습니다. 기본 레이아웃은 &lt;code&gt;app.html.eex&lt;/code&gt; 이며 기본적으로 모든 템플릿이 렌더링되는 레이아웃입니다.</target>
        </trans-unit>
        <trans-unit id="c30c1483050589dfecc9331a9c53fba39e9d5b44" translate="yes" xml:space="preserve">
          <source>Layouts are just templates. They have a view, just like other templates. In a newly generated app, this is &lt;code&gt;lib/hello_web/views/layout_view.ex&lt;/code&gt;. You may be wondering how the string resulting from a rendered view ends up inside a layout. That's a great question! If we look at &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;, just about in the middle of the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;, we will see this.</source>
          <target state="translated">레이아웃은 템플릿 일뿐입니다. 다른 템플릿과 마찬가지로보기가 있습니다. 새로 생성 된 앱에서는 &lt;code&gt;lib/hello_web/views/layout_view.ex&lt;/code&gt; 입니다. 렌더링 된 뷰의 결과 문자열이 레이아웃 내부에서 어떻게 끝나는 지 궁금 할 것입니다. 좋은 질문입니다! 우리가 보면 &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; ,의 중간에 단지에 대해 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; , 우리는이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="695cc1441048cfdc25d37f049780d12a2816af95" translate="yes" xml:space="preserve">
          <source>Learn about all the available metrics options in the &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt; &lt;code&gt;Telemetry.Metrics&lt;/code&gt; &lt;/a&gt; 모듈 설명서 에서 사용 가능한 모든 메트릭 옵션에 대해 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="c19b6017ad8d264fefc0742e7c1278ed7629ad06" translate="yes" xml:space="preserve">
          <source>LearnPhoenix.io: Build Scalable, Real-Time Apps with Phoenix, React, and React Native (2016)</source>
          <target state="translated">LearnPhoenix.io : Phoenix, React 및 React Native로 확장 가능한 실시간 앱 빌드 (2016)</target>
        </trans-unit>
        <trans-unit id="49c96bf78a49027ad34651adbdb49b0b0dea4fe2" translate="yes" xml:space="preserve">
          <source>LearnPhoenix.tv: Learn how to Build Fast, Dependable Web Apps with Phoenix (2017)</source>
          <target state="translated">LearnPhoenix.tv : Phoenix로 빠르고 신뢰할 수있는 웹 앱을 구축하는 방법 배우기 (2017)</target>
        </trans-unit>
        <trans-unit id="3d156c82e277315dd675804808caa48f6121a42e" translate="yes" xml:space="preserve">
          <source>Leave and close</source>
          <target state="translated">떠나고 닫으십시오</target>
        </trans-unit>
        <trans-unit id="f256310459076f21fdf5ec208db0f6548c6b7994" translate="yes" xml:space="preserve">
          <source>Leaving aside solutions that rely on external network elements, such as load balancers, there are several solutions on typical Linux servers:</source>
          <target state="translated">로드 밸런서와 같은 외부 네트워크 요소에 의존하는 솔루션을 제외하고 일반적인 Linux 서버에는 여러 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48cbd714362b332f46af7c0449a1162f10ad14a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example definition and usage. The use case we&amp;rsquo;ll be looking into is resetting a password. We need to update the account with proper information, log the request and remove all current sessions:</source>
          <target state="translated">정의와 사용법의 예를 봅시다. 우리가 살펴볼 유스 케이스는 비밀번호를 재설정하는 것입니다. 적절한 정보로 계정을 업데이트하고 요청을 기록한 다음 모든 현재 세션을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="631c60aa60bc16b1bf740a990139dd79086a4394" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see a sample query:</source>
          <target state="translated">샘플 쿼리를 보자.</target>
        </trans-unit>
        <trans-unit id="eee9f4926b9b562d7d7d24617f54066feabfd955" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example where using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is a good fit.</source>
          <target state="translated">&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋은 예를 보자 .</target>
        </trans-unit>
        <trans-unit id="496ebc27fbab27f3e6746ffd987c96f94e9a702c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="bc3d553ca52816cf4129cd63c38245f87b3da82f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see some examples. To see the query prefix globally, the simplest mechanism is to pass an option to the repository operation:</source>
          <target state="translated">몇 가지 예를 봅시다. 쿼리 접두사를 전체적으로 보려면 가장 간단한 메커니즘은 옵션을 리포지토리 작업에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7e2fcaa4bcf585ecc64057fde915c3a9de78479" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</source>
          <target state="translated">이메일이 제공되었지만 나이가 유효하지 않다고 가정 해 봅시다. 변경 세트에는 다음 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b1ba2e3a744981dda1fffda820555111f39270" translate="yes" xml:space="preserve">
          <source>Let's add a new route to the router that maps a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/hello&lt;/code&gt; to the &lt;code&gt;index&lt;/code&gt; action of a soon-to-be-created &lt;code&gt;HelloWeb.HelloController&lt;/code&gt; inside the &lt;code&gt;scope &quot;/&quot; do&lt;/code&gt; block of the router:</source>
          <target state="translated">&lt;code&gt;/hello&lt;/code&gt; 에 대한 &lt;code&gt;GET&lt;/code&gt; 요청을 라우터의 &lt;code&gt;scope &quot;/&quot; do&lt;/code&gt; 블록 범위 내에서 곧 생성 될 &lt;code&gt;HelloWeb.HelloController&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 작업에 매핑하는 새 경로를 라우터에 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4eca96380e5ed3ea0d07b414a47453adc5ae5a18" translate="yes" xml:space="preserve">
          <source>Let's add another metric for the route event, this time to group by route and method:</source>
          <target state="translated">이번에는 경로 및 방법별로 그룹화하기 위해 경로 이벤트에 대한 또 다른 메트릭을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1cf1ecf40bf83863279b5676851eb8d80b25d904" translate="yes" xml:space="preserve">
          <source>Let's add just a little complexity to our application. We're going to add a new page that will recognize a piece of the URL, label it as a &quot;messenger&quot; and pass it through the controller into the template so our messenger can say hello.</source>
          <target state="translated">응용 프로그램에 약간의 복잡성을 추가해 보겠습니다. URL의 일부를 인식하고 &quot;메신저&quot;라는 레이블을 지정하고 컨트롤러를 통해 템플릿으로 전달하여 메신저가 인사 할 수있는 새 페이지를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e02906d89b8a362edf94079724f930dce099e08" translate="yes" xml:space="preserve">
          <source>Let's change the status in our &lt;code&gt;PageController&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; action.</source>
          <target state="translated">&lt;code&gt;PageController&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 작업 에서 상태를 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c0ec000cc2fd5d3578e99a4fb7c571be8e1e79f1" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;CMS&lt;/code&gt; context to handle basic CMS duties. Before we write code, let's imagine we have the following CMS feature requirements:</source>
          <target state="translated">기본적인 CMS 업무를 처리하기 위한 &lt;code&gt;CMS&lt;/code&gt; 컨텍스트를 만들어 보겠습니다 . 코드를 작성하기 전에 다음과 같은 CMS 기능 요구 사항이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="45a2873bc6d85613430486ac7dcf5ff204fba1e3" translate="yes" xml:space="preserve">
          <source>Let's create a new template to play around with, &lt;code&gt;lib/hello_web/templates/page/test.html.eex&lt;/code&gt;:</source>
          <target state="translated">함께 놀 수있는 새 템플릿 &lt;code&gt;lib/hello_web/templates/page/test.html.eex&lt;/code&gt; 를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2bd5f076a836197521fae2d47cd707b4ccc3cdf6" translate="yes" xml:space="preserve">
          <source>Let's create a new view. Create &lt;code&gt;lib/hello_web/views/hello_view.ex&lt;/code&gt; and make it look like this:</source>
          <target state="translated">새보기를 만들어 보겠습니다. 만들기 &lt;code&gt;lib/hello_web/views/hello_view.ex&lt;/code&gt; 이 같이보고합니다</target>
        </trans-unit>
        <trans-unit id="51644e3e6134f101351bd43ca450a78bd5c8711b" translate="yes" xml:space="preserve">
          <source>Let's digest what this route is telling us. Visiting &lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt; issues an HTTP &lt;code&gt;GET&lt;/code&gt; request to the root path. All requests like this will be handled by the &lt;code&gt;index&lt;/code&gt; function in the &lt;code&gt;HelloWeb.PageController&lt;/code&gt; module defined in &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt;.</source>
          <target state="translated">이 경로가 우리에게 말하는 것을 요약 해 봅시다. &lt;a href=&quot;http://localhost:4000/&quot;&gt;http : // localhost : 4000 /을&lt;/a&gt; 방문 하면 루트 경로에 대한 HTTP &lt;code&gt;GET&lt;/code&gt; 요청이 발행 됩니다. 이와 같은 모든 요청 은 &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; 에 정의 된 &lt;code&gt;HelloWeb.PageController&lt;/code&gt; 모듈 의 &lt;code&gt;index&lt;/code&gt; 함수에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="be4bf6d8990004b571401cf1b7b3cd7bdd457be6" translate="yes" xml:space="preserve">
          <source>Let's do a quick recap and how the last three components work together by adding another page.</source>
          <target state="translated">다른 페이지를 추가하여 마지막 세 가지 구성 요소가 함께 작동하는 방식을 간략히 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="65f81ffe80bca94d27f1a7efbcfddfe3558bba56" translate="yes" xml:space="preserve">
          <source>Let's find out how to extract more tags from events that include a &lt;code&gt;conn&lt;/code&gt; in their metadata.</source>
          <target state="translated">메타 데이터에 &lt;code&gt;conn&lt;/code&gt; 이 포함 된 이벤트에서 더 많은 태그를 추출하는 방법을 알아 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c78527e1e2aa8e92da2c57f64d3d9575995a9793" translate="yes" xml:space="preserve">
          <source>Let's first check out the &lt;code&gt;UserController&lt;/code&gt; that was generated in &lt;code&gt;lib/hello_web/controllers/user_controller.ex&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;lib/hello_web/controllers/user_controller.ex&lt;/code&gt; 에서 생성 된 &lt;code&gt;UserController&lt;/code&gt; 를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4a4bfe6e2b62f1e33f0e51ffd99f771dc8ab3ac4" translate="yes" xml:space="preserve">
          <source>Let's get a Phoenix application up and running as quickly as possible.</source>
          <target state="translated">Phoenix 애플리케이션을 최대한 빨리 시작하고 실행 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3cb9a5e6cb7e58d41e079b91fe51842e6ebd93ec" translate="yes" xml:space="preserve">
          <source>Let's get on with our first new Phoenix page!</source>
          <target state="translated">우리의 첫 번째 새로운 Phoenix 페이지로 넘어 갑시다!</target>
        </trans-unit>
        <trans-unit id="2fee7b24c2b0fd4d46634d971ff05c70198eff85" translate="yes" xml:space="preserve">
          <source>Let's head back over to IEx with &lt;code&gt;iex -S mix&lt;/code&gt;, and insert a couple of users into the database.</source>
          <target state="translated">&lt;code&gt;iex -S mix&lt;/code&gt; 를 사용하여 IEx로 돌아가서 몇 명의 사용자를 데이터베이스에 삽입 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="bc6f755f8a0a3e4804f49451c8d16a4af54a713f" translate="yes" xml:space="preserve">
          <source>Let's look at an example definition and usage. The use case we'll be looking into is resetting a password. We need to update the account with proper information, log the request and remove all current sessions:</source>
          <target state="translated">예제 정의 및 사용법을 살펴 보겠습니다. 우리가 살펴볼 사용 사례는 암호 재설정입니다. 적절한 정보로 계정을 업데이트하고 요청을 기록하고 현재 세션을 모두 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3669d476d4a505daeb275deab7ed1e4cb6b00ad" translate="yes" xml:space="preserve">
          <source>Let's open up our &lt;code&gt;mix.exs&lt;/code&gt; file and do that now.</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; 파일을 열고 지금 실행 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1616d2164649ffa0942cc459513f1a94c73f11b8" translate="yes" xml:space="preserve">
          <source>Let's rollback our &lt;code&gt;show&lt;/code&gt; action to what we originally wrote &lt;a href=&quot;request_lifecycle&quot;&gt;in the Request life-cycle guide&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;request_lifecycle&quot;&gt;요청 수명주기 가이드에서&lt;/a&gt; 원래 작성한 내용으로 &lt;code&gt;show&lt;/code&gt; 작업을 롤백 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1648a51e97016facf6343896e766731a0a1d6ea1" translate="yes" xml:space="preserve">
          <source>Let's say that the request matches our first route: a GET to &lt;code&gt;/&lt;/code&gt;. The router will first pipe that request through the &lt;code&gt;:browser&lt;/code&gt; pipeline - which will fetch the session data, fetch the flash, and execute forgery protection - before it dispatches the request to the &lt;code&gt;PageController&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; action.</source>
          <target state="translated">요청이 첫 번째 경로 인 GET to &lt;code&gt;/&lt;/code&gt; 와 일치한다고 가정 해 보겠습니다 . 라우터는 요청을 &lt;code&gt;PageController&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 작업에 전달하기 전에 먼저 세션 데이터를 가져오고 플래시를 가져오고 위조 방지를 실행 하는 &lt;code&gt;:browser&lt;/code&gt; 파이프 라인을 통해 해당 요청을 파이프합니다 .</target>
        </trans-unit>
        <trans-unit id="af32870381ff5acbc0cc9c7716a41a2055389a91" translate="yes" xml:space="preserve">
          <source>Let's say we have a &lt;code&gt;show&lt;/code&gt; action which uses &lt;code&gt;with&lt;/code&gt; to fetch a blog post and then authorize the current user to view that blog post. In this example we might expect &lt;code&gt;fetch_post/1&lt;/code&gt; to return &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the post is not found and &lt;code&gt;authorize_user/3&lt;/code&gt; might return &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; if the user is unauthorized. We could use the &lt;code&gt;ErrorView&lt;/code&gt; Phoenix generates for every new application to handle these error paths accordingly:</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 를 사용 하여 블로그 게시물을 가져온 다음 현재 사용자에게 해당 블로그 게시물을 볼 수있는 권한을 부여 하는 &lt;code&gt;show&lt;/code&gt; 작업이 있다고 가정 해 보겠습니다 . 이 예 에서 게시물을 찾을 수없는 경우 &lt;code&gt;fetch_post/1&lt;/code&gt; 이 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환 하고 사용자가 권한이없는 경우 &lt;code&gt;authorize_user/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 를 반환 할 것으로 예상 할 수 있습니다 . 모든 새로운 애플리케이션에 대해 생성 된 &lt;code&gt;ErrorView&lt;/code&gt; Phoenix를 사용하여 이러한 오류 경로를 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f30137247dfadf8e6f06a41ae89552268d52299a" translate="yes" xml:space="preserve">
          <source>Let's say we have a read-only posts resource. We could define it like this:</source>
          <target state="translated">읽기 전용 게시물 리소스가 있다고 가정 해 보겠습니다. 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bfbaf644c1384fdaff980ae0420c5e29d72af7" translate="yes" xml:space="preserve">
          <source>Let's say we want to perform at least some rudimentary format validation on the &lt;code&gt;email&lt;/code&gt; field. All we want to check for is the presence of the &quot;@&quot;. The &lt;code&gt;validate_format/3&lt;/code&gt; function is just what we need.</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; 필드 에 대해 최소한 몇 가지 기본적인 형식 유효성 검사를 수행하고 싶다고 가정 해 보겠습니다 . 우리가 확인하고 싶은 것은 &quot;@&quot;의 존재뿐입니다. &lt;code&gt;validate_format/3&lt;/code&gt; 기능은 우리가 필요로하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6098ec037e505d9cdebf8be8d53bba3b2b76ad3a" translate="yes" xml:space="preserve">
          <source>Let's say you want to filter out records that were &quot;soft-deleted&quot; (have &lt;code&gt;deleted_at&lt;/code&gt; column set) from all operations unless an admin is running the query; you can define the callback like this:</source>
          <target state="translated">관리자가 쿼리를 실행하지 않는 한 모든 작업에서 &quot;소프트 삭제 된&quot;( &lt;code&gt;deleted_at&lt;/code&gt; 열 집합이있는) 레코드를 필터링한다고 가정 해 보겠습니다 . 다음과 같이 콜백을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f509c301e19802f2570647e6413d72b9c0adbb" translate="yes" xml:space="preserve">
          <source>Let's see a sample query:</source>
          <target state="translated">샘플 쿼리를 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a1d89be0a7b8c26a9c361c7e90a1503ab931c035" translate="yes" xml:space="preserve">
          <source>Let's see an example where using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is a good fit.</source>
          <target state="translated">&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 적합한 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7be4a4f8fe8c136ea1812aa5ff5433b439cc6d5a" translate="yes" xml:space="preserve">
          <source>Let's see an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="0935018ed9fd47f669b3fb22d1382a9e280d4ad8" translate="yes" xml:space="preserve">
          <source>Let's see how this works. Go to the root of a newly-generated Phoenix application and run &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt;. You should see something like the following, generated with all routes you currently have:</source>
          <target state="translated">이것이 어떻게 작동하는지 봅시다. 새로 생성 된 Phoenix 애플리케이션의 루트로 이동하여 &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt; &lt;code&gt;mix phx.routes&lt;/code&gt; 를&lt;/a&gt; 실행 합니다 . 현재 가지고있는 모든 경로로 생성 된 다음과 같은 내용이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="828a4cf61b0cd300c1f37421aa08635a30cff70e" translate="yes" xml:space="preserve">
          <source>Let's see some examples. To see the query prefix globally, the simplest mechanism is to pass an option to the repository operation:</source>
          <target state="translated">몇 가지 예를 살펴 보겠습니다. 쿼리 접두사를 전역으로 보려면 가장 간단한 메커니즘은 저장소 작업에 옵션을 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8b6667ddd4013ec0ea2f17e12f63c6acaa38274e" translate="yes" xml:space="preserve">
          <source>Let's start by grouping these events by route. Add the following (if it does not already exist) to the &lt;code&gt;metrics/0&lt;/code&gt; function of your Telemetry supervisor (usually in &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt;):</source>
          <target state="translated">이러한 이벤트를 경로별로 그룹화하여 시작하겠습니다. Telemetry 감독자 의 &lt;code&gt;metrics/0&lt;/code&gt; 함수 (일반적으로 &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt; 에 있음 )에 다음 (아직없는 경우)을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9d72481484e89f73282a7a5d88bf46adc0c7f7" translate="yes" xml:space="preserve">
          <source>Let's stretch these ideas out a little bit more. What if we need to pipe requests through both &lt;code&gt;:browser&lt;/code&gt; and one or more custom pipelines? We simply &lt;code&gt;pipe_through&lt;/code&gt; a list of pipelines, and Phoenix will invoke them in order.</source>
          <target state="translated">이 아이디어를 조금 더 확장 해 보겠습니다. &lt;code&gt;:browser&lt;/code&gt; 와 하나 이상의 사용자 지정 파이프 라인을 통해 요청을 파이프해야하는 경우 어떻게해야 합니까? 우리는 단순히 &lt;code&gt;pipe_through&lt;/code&gt; 파이프 라인의 목록을, 피닉스는 순서대로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5b92da37df456785a13baf1231380413930da330" translate="yes" xml:space="preserve">
          <source>Let's suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</source>
          <target state="translated">이메일이 제공되었지만 연령이 유효하지 않다고 가정 해 보겠습니다. 변경 세트에는 다음과 같은 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a404afbf269feeb167ff1427ee868e9bf9a6fb6e" translate="yes" xml:space="preserve">
          <source>Let's take a closer look at our default changeset function.</source>
          <target state="translated">기본 변경 집합 기능을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0761ac284346638d02f13bc7978d0f3c400be26d" translate="yes" xml:space="preserve">
          <source>Let's take a look at another event emitted during the HTTP request lifecycle, this time from &lt;a href=&quot;phoenix.router&quot;&gt;&lt;code&gt;Phoenix.Router&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이번에는 &lt;a href=&quot;phoenix.router&quot;&gt; &lt;code&gt;Phoenix.Router&lt;/code&gt; &lt;/a&gt; 에서 HTTP 요청 수명주기 동안 발생하는 다른 이벤트를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1344515a1b9eee8128a33d31c72548c5e4fd00" translate="yes" xml:space="preserve">
          <source>Let's take a look at some examples.</source>
          <target state="translated">몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6881b045340f3823b721a791b6795f28e2db7f2c" translate="yes" xml:space="preserve">
          <source>Let's take a look at the file &lt;code&gt;ecto.gen.migration&lt;/code&gt; has generated for us at &lt;code&gt;priv/repo/migrations/20150318001628_add_comments_table.exs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;priv/repo/migrations/20150318001628_add_comments_table.exs&lt;/code&gt; 에서 &lt;code&gt;ecto.gen.migration&lt;/code&gt; 이 생성 한 파일을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d87f1c7cf229c6b9100f3c36100df75e94f8457b" translate="yes" xml:space="preserve">
          <source>Let's take a quick look at the &lt;code&gt;LayoutView&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LayoutView&lt;/code&gt; 를 간단히 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d23646badf887468ef066ae2387e119c33bb4c9c" translate="yes" xml:space="preserve">
          <source>Let's take a quick look at the moving parts involved in a working mix task.</source>
          <target state="translated">작업 혼합 작업과 관련된 움직이는 부분을 간단히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="25f4a0c9b17ac2090c9128142e129ff9a827f9e0" translate="yes" xml:space="preserve">
          <source>Let's test out the HTML escaping, just for fun:</source>
          <target state="translated">재미를 위해 HTML 이스케이프를 테스트 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="33b594f91bb3addd986ce08a27d04bdd1c7745ad" translate="yes" xml:space="preserve">
          <source>Let's use these ideas to build out our web application. Our goal is to build a user system as well as a basic content management system for adding and editing page content. Let's get started!</source>
          <target state="translated">이 아이디어를 사용하여 웹 애플리케이션을 구축해 보겠습니다. 우리의 목표는 페이지 콘텐츠를 추가하고 편집하기위한 기본 콘텐츠 관리 시스템뿐만 아니라 사용자 시스템을 구축하는 것입니다. 시작하자!</target>
        </trans-unit>
        <trans-unit id="ae06854c350cf6cabf4fa7ba7e9220ecbd0eb702" translate="yes" xml:space="preserve">
          <source>Libraries using Telemetry</source>
          <target state="translated">원격 분석을 사용하는 라이브러리</target>
        </trans-unit>
        <trans-unit id="bb98723c23e6ee3003ead75f660dba9a92cd9fdb" translate="yes" xml:space="preserve">
          <source>Library authors are actively encouraged to send a PR adding their own (in alphabetical order, please):</source>
          <target state="translated">도서관 저자는 자신의 PR을 추가하여 (알파벳 순서로) PR을 보내도록 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="795ca83ae31bf6f37a94692c80d7f9869ee96467" translate="yes" xml:space="preserve">
          <source>Life-cycle</source>
          <target state="translated">Life-cycle</target>
        </trans-unit>
        <trans-unit id="d83746203e0b55f7322adc3a1a7549fceca1ff37" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#put_layout/2&quot;&gt;&lt;code&gt;put_layout/2&lt;/code&gt;&lt;/a&gt;, the layout must be a tuple, specifying the layout view and the layout name, or false.</source>
          <target state="translated">&lt;a href=&quot;#put_layout/2&quot;&gt; &lt;code&gt;put_layout/2&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 레이아웃은 레이아웃보기와 레이아웃 이름을 지정하는 튜플이거나 false 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dcdf1f3f20d25750eec18cb3946ae2be25cb8eaa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_broadcast&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_broadcast&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d486907f4d390d5bb6c5c2f6b978b91b0d62fc4e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_push&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_push&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="c1e5c3ab8c6ae38a073f8acc6293e0c0a2698284" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_reply&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_reply&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="c4ff50b501c7a5383e059d167f3ea5fd4ec8a941" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;c:list/2&lt;/code&gt;, the presence metadata is passed to the &lt;code&gt;fetch&lt;/code&gt; callback of your presence module to fetch any additional information.</source>
          <target state="translated">&lt;code&gt;c:list/2&lt;/code&gt; 와 마찬가지로 프레즌스 메타 데이터는 추가 정보를 가져 오기 위해 프레즌스 모듈 의 &lt;code&gt;fetch&lt;/code&gt; 콜백으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="28a791b4db77913904c38cfe58adaaf487678aff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;having&lt;/code&gt; but combines with the previous expression by using &lt;code&gt;OR&lt;/code&gt;. &lt;code&gt;or_having&lt;/code&gt; behaves for &lt;code&gt;having&lt;/code&gt; the same way &lt;code&gt;or_where&lt;/code&gt; behaves for &lt;code&gt;where&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;having&lt;/code&gt; 있지만 사용하여 이전의 표현과 결합 &lt;code&gt;OR&lt;/code&gt; . &lt;code&gt;or_having&lt;/code&gt; 에 대한 동작합니다을 &lt;code&gt;having&lt;/code&gt; 같은 방식으로 &lt;code&gt;or_where&lt;/code&gt; 에 대한 동작합니다 . &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c49abb0983070a22d29b7273189d0776225eabc5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; filters rows from the schema, but after the grouping is performed giving it the same semantics as &lt;code&gt;select&lt;/code&gt; for a grouped query (see &lt;a href=&quot;#group_by/3&quot;&gt;&lt;code&gt;group_by/3&lt;/code&gt;&lt;/a&gt;). &lt;code&gt;having&lt;/code&gt; groups the query even if the query has no &lt;code&gt;group_by&lt;/code&gt; expression.</source>
          <target state="translated">마찬가지로 &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;having&lt;/code&gt; 스키마에서 필터 행했지만 그룹핑 후의으로 동일한 의미를주는 수행되는 &lt;code&gt;select&lt;/code&gt; 그룹화 쿼리 (참조 &lt;a href=&quot;#group_by/3&quot;&gt; &lt;code&gt;group_by/3&lt;/code&gt; &lt;/a&gt; ). 쿼리에 &lt;code&gt;group_by&lt;/code&gt; 표현식 이없는 경우에도 쿼리 &lt;code&gt;having&lt;/code&gt; 그룹화합니다 .</target>
        </trans-unit>
        <trans-unit id="991c41b9025ffcd1d70a6479d74f5a2a0dd1e334" translate="yes" xml:space="preserve">
          <source>Like Phoenix, Ecto ships with built-in Telemetry events. This means that you can gain introspection into your web and database layers using the same tools.</source>
          <target state="translated">Phoenix와 마찬가지로 Ecto는 내장 된 원격 측정 이벤트와 함께 제공됩니다. 이는 동일한 도구를 사용하여 웹 및 데이터베이스 계층에 대한 내성을 얻을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03eaa0d73103e80b4696a385480906421628b2d0" translate="yes" xml:space="preserve">
          <source>Like all functions in this module, the &lt;code&gt;conn&lt;/code&gt; returned by &lt;code&gt;read_body&lt;/code&gt; must be passed to the next stage of your pipeline and should not be ignored.</source>
          <target state="translated">이 모듈의 모든 함수와 마찬가지로 &lt;code&gt;read_body&lt;/code&gt; 에 의해 반환 된 &lt;code&gt;conn&lt;/code&gt; 은 파이프 라인의 다음 단계로 전달되어야하며 무시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5397e1c8fe3990864e664661bb79fede1d642082" translate="yes" xml:space="preserve">
          <source>Like routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.</source>
          <target state="translated">라우터와 마찬가지로 컨트롤러는 플러그이지만 동작이라고하는 특정 기능으로 디스패치되도록 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="82344a99522b2ca7752091871deed656cf2265f9" translate="yes" xml:space="preserve">
          <source>Likewise for &lt;code&gt;phx-submit&lt;/code&gt; bindings, the same callback is invoked and persistence is attempted. On success, a &lt;code&gt;:noreply&lt;/code&gt; tuple is returned and the socket is annotated for redirect with &lt;a href=&quot;phoenix.liveview#redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.redirect/2&lt;/code&gt;&lt;/a&gt; to the new user page, otherwise the socket assigns are updated with the errored changeset to be re-rendered for the client.</source>
          <target state="translated">&lt;code&gt;phx-submit&lt;/code&gt; 바인딩의 경우와 마찬가지로 동일한 콜백이 호출되고 지속성이 시도됩니다. 성공하면 &lt;code&gt;:noreply&lt;/code&gt; 튜플이 반환되고 &lt;a href=&quot;phoenix.liveview#redirect/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.redirect/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 새 사용자 페이지 로 리디렉션하도록 소켓에 주석이 추가됩니다 . 그렇지 않으면 소켓 할당이 클라이언트에 대해 다시 렌더링되도록 오류가 발생한 변경 집합으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="14fd51ca97a077da3ae700c76889cf7006e2865d" translate="yes" xml:space="preserve">
          <source>Likewise, you may throttle held-down keydown:</source>
          <target state="translated">마찬가지로, 누르고있는 키 다운을 조절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db10e543b75e859cf172efee27b738c6517452ba" translate="yes" xml:space="preserve">
          <source>Limitation: CTEs on schemas with source fields</source>
          <target state="translated">제한 사항 : 소스 필드가있는 스키마의 CTE</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="4808633a2ab2296b7932aebce8b1e52933d4ac4e" translate="yes" xml:space="preserve">
          <source>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can&amp;rsquo;t include any field.</source>
          <target state="translated">결과에서 반환되는 행 수를 제한합니다. 표현식 일 수 있지만 정수 값으로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d3addd800692a15c76606ee71c2809ad7a52353" translate="yes" xml:space="preserve">
          <source>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can't include any field.</source>
          <target state="translated">결과에서 반환되는 행 수를 제한합니다. 모든 표현식이 될 수 있지만 정수 값으로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef1386ae50a4573cddb5393b59e23b0d14285c49" translate="yes" xml:space="preserve">
          <source>Links to the text editor</source>
          <target state="translated">텍스트 편집기로 연결</target>
        </trans-unit>
        <trans-unit id="01d247fa5e6a284a0c5a9c7bc67f22471c23bee4" translate="yes" xml:space="preserve">
          <source>Listening on Port 443</source>
          <target state="translated">포트 443에서 듣기</target>
        </trans-unit>
        <trans-unit id="3daed10a79c7363f6ca411964fab08bbb45dd2d8" translate="yes" xml:space="preserve">
          <source>Lists all functions allowed in the query API.</source>
          <target state="translated">쿼리 API에서 허용되는 모든 함수를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="815704335e99997946fd7e2eb4b7a04f3a3b2307" translate="yes" xml:space="preserve">
          <source>Lists all presences tracked under a given topic</source>
          <target state="translated">특정 주제에서 추적 된 모든 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="bae3a2425aba950d370a4070fef8ada60ba48039" translate="yes" xml:space="preserve">
          <source>Lists all presences tracked under a given topic.</source>
          <target state="translated">특정 주제에서 추적 된 모든 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4bdaba18f84a5a60e20f166eb2402f70f6f23d34" translate="yes" xml:space="preserve">
          <source>Lists all windows functions.</source>
          <target state="translated">모든 창 기능을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="86f0d2ee14ec0f4ca6ecca72abf2e2fcc658b115" translate="yes" xml:space="preserve">
          <source>Lists are created with &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">리스트는 &lt;code&gt;[]&lt;/code&gt; 로 생성됩니다 :</target>
        </trans-unit>
        <trans-unit id="5157f161ff9924001000e57a45ac9c5313681de2" translate="yes" xml:space="preserve">
          <source>Literal syntax in query</source>
          <target state="translated">쿼리의 리터럴 구문</target>
        </trans-unit>
        <trans-unit id="c8f3648249292725d12854ae1862369828fec9af" translate="yes" xml:space="preserve">
          <source>Live Layouts</source>
          <target state="translated">라이브 레이아웃</target>
        </trans-unit>
        <trans-unit id="e93ab6715c35c387e979fb1054379dc15a7081a7" translate="yes" xml:space="preserve">
          <source>Live Navigation</source>
          <target state="translated">라이브 내비게이션</target>
        </trans-unit>
        <trans-unit id="8ca431c9acf59b732cf88a92fb2e5b805ef90bd3" translate="yes" xml:space="preserve">
          <source>Live component blocks</source>
          <target state="translated">라이브 구성 요소 블록</target>
        </trans-unit>
        <trans-unit id="600ea47a9b1de0660c730ef2c18da8aaa66782b4" translate="yes" xml:space="preserve">
          <source>Live layouts</source>
          <target state="translated">라이브 레이아웃</target>
        </trans-unit>
        <trans-unit id="cef2823ceb02a543cb64bbdf5eb6dfbcc95a2fa8" translate="yes" xml:space="preserve">
          <source>Live navigation</source>
          <target state="translated">라이브 내비게이션</target>
        </trans-unit>
        <trans-unit id="4ea7773f4f1b2698ceaccb335c60057810a06b74" translate="yes" xml:space="preserve">
          <source>Live patches and live redirects</source>
          <target state="translated">라이브 패치 및 라이브 리디렉션</target>
        </trans-unit>
        <trans-unit id="11d0325968dbe1a6e1075c1f4ad5ea8691a80637" translate="yes" xml:space="preserve">
          <source>LiveComponent as the source of truth</source>
          <target state="translated">진실의 근원으로서의 LiveComponent</target>
        </trans-unit>
        <trans-unit id="6450c3e304f468e265b5af0bb48323df7de4bc0b" translate="yes" xml:space="preserve">
          <source>LiveComponent comes in two shapes, stateful and stateless. See &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">LiveComponent는 상태 저장 및 상태 비 저장의 두 가지 형태로 제공됩니다. 자세한 내용은 &lt;a href=&quot;phoenix.livecomponent&quot;&gt; &lt;code&gt;Phoenix.LiveComponent&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="323b2813584f216a213f93c659a5e84b04bb9ee5" translate="yes" xml:space="preserve">
          <source>LiveEEx pitfalls</source>
          <target state="translated">LiveEEx 함정</target>
        </trans-unit>
        <trans-unit id="372c8b032b1fafb0fb2c7265ccfec98b704fc4cc" translate="yes" xml:space="preserve">
          <source>LiveView Specific Events</source>
          <target state="translated">LiveView 특정 이벤트</target>
        </trans-unit>
        <trans-unit id="3aa757570818e16e7d1fc2596621d9a5c9751eaa" translate="yes" xml:space="preserve">
          <source>LiveView Testing</source>
          <target state="translated">LiveView 테스트</target>
        </trans-unit>
        <trans-unit id="52d2ec38a948e93b536e120dcdaa9950447dc3b8" translate="yes" xml:space="preserve">
          <source>LiveView accepts the following configuration in your endpoint under the &lt;code&gt;:live_view&lt;/code&gt; key:</source>
          <target state="translated">LiveView는 &lt;code&gt;:live_view&lt;/code&gt; 키 아래의 엔드 포인트에서 다음 구성을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="39564957073d429c2a33ca8e7a59a0c0be79967f" translate="yes" xml:space="preserve">
          <source>LiveView allows you to have multiple LiveViews in the same page by calling &lt;a href=&quot;phoenix.liveview.helpers#live_render/3&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_render/3&lt;/code&gt;&lt;/a&gt; in your templates. However, only the LiveViews defined directly in your router can use the &quot;Live Navigation&quot; functionality described here. This is important because LiveViews work closely with your router, guaranteeing you can only navigate to known routes.</source>
          <target state="translated">LiveView를 사용하면 템플릿에서 &lt;a href=&quot;phoenix.liveview.helpers#live_render/3&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_render/3&lt;/code&gt; &lt;/a&gt; 를 호출하여 동일한 페이지에 여러 LiveView를 가질 수 있습니다 . 그러나 라우터에 직접 정의 된 LiveView 만 여기에 설명 된 &quot;라이브 내비게이션&quot;기능을 사용할 수 있습니다. 이는 LiveView가 라우터와 긴밀하게 작동하여 알려진 경로 만 탐색 할 수 있도록 보장하기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b7eea60b0d8e657c74d4160a51c8fd28351ea724" translate="yes" xml:space="preserve">
          <source>LiveView also allows the current browser URL to be replaced. This is useful when you want certain events to change the URL but without polluting the browser's history. This can be done by passing the &lt;code&gt;replace: true&lt;/code&gt; option to any of the navigation helpers.</source>
          <target state="translated">LiveView를 사용하면 현재 브라우저 URL을 바꿀 수도 있습니다. 이것은 특정 이벤트가 URL을 변경하지만 브라우저 기록을 오염시키지 않고 싶을 때 유용합니다. 이것은 탐색 도우미에 &lt;code&gt;replace: true&lt;/code&gt; 옵션을 전달하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92ca455bcc251344065850ecfe0b918435bc08ae" translate="yes" xml:space="preserve">
          <source>LiveView as the source of truth</source>
          <target state="translated">진실의 근원으로서의 LiveView</target>
        </trans-unit>
        <trans-unit id="a1f6474398d11aaa10bcb14f78741bb746af5191" translate="yes" xml:space="preserve">
          <source>LiveView currently exposes the following &lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;&lt;code&gt;telemetry&lt;/code&gt;&lt;/a&gt; events:</source>
          <target state="translated">LiveView는 현재 다음과 같은 &lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt; &lt;code&gt;telemetry&lt;/code&gt; &lt;/a&gt; 이벤트를 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="30cfdd744801dcd928aaa6c89c1e104f425032d9" translate="yes" xml:space="preserve">
          <source>LiveView does not use the default app layout. Instead, you typically call &lt;code&gt;put_root_layout&lt;/code&gt; in your router to specify a layout that is used by both &quot;regular&quot; views and live views. In your router, do:</source>
          <target state="translated">LiveView는 기본 앱 레이아웃을 사용하지 않습니다. 대신 일반적으로 라우터에서 &lt;code&gt;put_root_layout&lt;/code&gt; 을 호출 하여 &quot;일반&quot;보기와 라이브보기 모두에서 사용되는 레이아웃을 지정합니다. 라우터에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="138b2b868721e7cc682a44fe4b4c634b85e41e8c" translate="yes" xml:space="preserve">
          <source>LiveView has many guides to help you on your journey.</source>
          <target state="translated">LiveView에는 여정에 도움이되는 많은 가이드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e829b47d26845f5ab0d32750954f7930c69a8206" translate="yes" xml:space="preserve">
          <source>LiveView is first rendered statically as part of regular HTTP requests, which provides quick times for &quot;First Meaningful Paint&quot;, in addition to helping search and indexing engines. Then a persistent connection is established between client and server. This allows LiveView applications to react faster to user events as there is less work to be done and less data to be sent compared to stateless requests that have to authenticate, decode, load, and encode data on every request. The flipside is that LiveView uses more memory on the server compared to stateless requests.</source>
          <target state="translated">LiveView는 먼저 정규 HTTP 요청의 일부로 정적으로 렌더링되며, 검색 및 인덱싱 엔진을 지원하는 것 외에도 &quot;First Meanful Paint&quot;에 대한 빠른 시간을 제공합니다. 그런 다음 클라이언트와 서버간에 지속적인 연결이 설정됩니다. 이를 통해 LiveView 응용 프로그램은 모든 요청에서 데이터를 인증, 디코딩,로드 및 인코딩해야하는 상태 비 저장 요청에 비해 수행 할 작업이 적고 전송할 데이터가 적기 때문에 사용자 이벤트에 더 빠르게 반응 할 수 있습니다. 반면 LiveView는 상태 비 저장 요청에 비해 서버에서 더 많은 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cab97f1923c31e031b1aac2d82f8961e72b30c13" translate="yes" xml:space="preserve">
          <source>LiveView knows nothing about &lt;code&gt;content_tag&lt;/code&gt;, which means the whole &lt;code&gt;div&lt;/code&gt; will be sent whenever any of the assigns change. This can be easily fixed by writing the HTML directly:</source>
          <target state="translated">LiveView는 &lt;code&gt;content_tag&lt;/code&gt; 에 대해 아무것도 모르기 때문에 할당이 변경 될 때마다 전체 &lt;code&gt;div&lt;/code&gt; 가 전송됩니다. HTML을 직접 작성하여 쉽게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="928bd15e6c3d1662c54dd80df0fe89e6625de462" translate="yes" xml:space="preserve">
          <source>LiveView provides functionality to allow page navigation using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;browser's pushState API&lt;/a&gt;. With live navigation, the page is updated without a full page reload.</source>
          <target state="translated">LiveView는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;브라우저의 pushState API를&lt;/a&gt; 사용하여 페이지 탐색을 허용하는 기능을 제공합니다 . 라이브 내비게이션을 사용하면 전체 페이지를 다시로드하지 않고도 페이지가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f09257710223a329020fef8ceb1944241748b7" translate="yes" xml:space="preserve">
          <source>LiveView provides rich, real-time user experiences with server-rendered HTML.</source>
          <target state="translated">LiveView는 서버 렌더링 HTML로 풍부한 실시간 사용자 경험을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17588cede601fb6808a1cdb5b004d43bda79eb72" translate="yes" xml:space="preserve">
          <source>LiveViews are &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s under the hood, and can send and receive messages just like any other server. To test the side effects of sending or receiving messages, simply message the view and use the &lt;code&gt;render&lt;/code&gt; function to test the result:</source>
          <target state="translated">LiveView는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 내부에 있으며 다른 서버와 마찬가지로 메시지를 보내고받을 수 있습니다. 메시지를 보내거나받는 부작용을 테스트하려면보기에 메시지를 보내고 &lt;code&gt;render&lt;/code&gt; 함수를 사용하여 결과를 테스트하면됩니다.</target>
        </trans-unit>
        <trans-unit id="57358719361c3c517ab823ba823774442d6dfe63" translate="yes" xml:space="preserve">
          <source>Load CSRF state into the process dictionary.</source>
          <target state="translated">CSRF 상태를 프로세스 사전에로드합니다.</target>
        </trans-unit>
        <trans-unit id="e748021b3e41528d2c175fd8605c569d384ae8ae" translate="yes" xml:space="preserve">
          <source>Loading state and errors</source>
          <target state="translated">로드 상태 및 오류</target>
        </trans-unit>
        <trans-unit id="e9a9640e18b7869d8f7e2ceddccf74aef091b653" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;data&lt;/code&gt; into a struct or a map</source>
          <target state="translated">구조체 나 맵에 &lt;code&gt;data&lt;/code&gt; 를 로드</target>
        </trans-unit>
        <trans-unit id="fb2e98e74e82eb7e2474cb754cd6b9096a3f6741" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;data&lt;/code&gt; into a struct or a map.</source>
          <target state="translated">구조체 또는 맵에 &lt;code&gt;data&lt;/code&gt; 를 로드 합니다 .</target>
        </trans-unit>
        <trans-unit id="82aff2203375dcddd99030298fa0fd4111ff9e20" translate="yes" xml:space="preserve">
          <source>Loads a value with the given type</source>
          <target state="translated">주어진 타입으로 값을로드</target>
        </trans-unit>
        <trans-unit id="a18c618fa4df41a3d4e0a01c037f434dac2896d7" translate="yes" xml:space="preserve">
          <source>Loads a value with the given type.</source>
          <target state="translated">주어진 유형으로 값을로드합니다.</target>
        </trans-unit>
        <trans-unit id="e24061bda9694e6493e3550f591dd68ed369d90d" translate="yes" xml:space="preserve">
          <source>Loads previously dumped &lt;code&gt;data&lt;/code&gt; in the given &lt;code&gt;format&lt;/code&gt; into a schema.</source>
          <target state="translated">주어진 &lt;code&gt;format&lt;/code&gt; 으로 이전에 덤프 된 &lt;code&gt;data&lt;/code&gt; 를 스키마에로드합니다.</target>
        </trans-unit>
        <trans-unit id="85b0ecb3082b55c4d811c190730ecaed7c688555" translate="yes" xml:space="preserve">
          <source>Loads the &lt;code&gt;value&lt;/code&gt; for &lt;code&gt;type&lt;/code&gt; considering it was embedded in &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 에 포함 된 것으로 간주 하여 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 을 로드 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f2f5093ca6b0ca51b824d8c4d43b48e88ebb634" translate="yes" xml:space="preserve">
          <source>Loads the given term into a ParameterizedType.</source>
          <target state="translated">주어진 용어를 ParameterizedType에로드합니다.</target>
        </trans-unit>
        <trans-unit id="b269f8fe0c26ed86332fe55318e12ba6ca8edd78" translate="yes" xml:space="preserve">
          <source>Loads the given term into a custom type</source>
          <target state="translated">주어진 용어를 사용자 정의 유형으로로드</target>
        </trans-unit>
        <trans-unit id="3fe85d96329792635d8589e2b28d8c7d163b68a5" translate="yes" xml:space="preserve">
          <source>Loads the given term into a custom type.</source>
          <target state="translated">주어진 용어를 사용자 정의 유형으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="4ec296012bb3dc5612ab1f74bd74837d8c5bd816" translate="yes" xml:space="preserve">
          <source>Local PubSub server supervisor.</source>
          <target state="translated">로컬 PubSub 서버 관리자.</target>
        </trans-unit>
        <trans-unit id="bdbcefa64386a101956cb9889050c4f6b3759508" translate="yes" xml:space="preserve">
          <source>Location for LiveView modules</source>
          <target state="translated">LiveView 모듈의 위치</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="aea106bc34b23b21819e5f4e10f742e1cd442e25" translate="yes" xml:space="preserve">
          <source>Logs the given entry in the given level</source>
          <target state="translated">주어진 레벨에 주어진 항목을 기록</target>
        </trans-unit>
        <trans-unit id="008ad5939b30b44a5a3f7467494f7bfda37f2c86" translate="yes" xml:space="preserve">
          <source>Logs the given entry in the given level.</source>
          <target state="translated">주어진 레벨에서 주어진 항목을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f943d416e2ada7a0922291d06f813a919e5f4338" translate="yes" xml:space="preserve">
          <source>Logs the transport request</source>
          <target state="translated">전송 요청을 기록합니다</target>
        </trans-unit>
        <trans-unit id="a4d314c6f2abcc14a73e4df67793b447704d1088" translate="yes" xml:space="preserve">
          <source>Logs the transport request.</source>
          <target state="translated">전송 요청을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6334a82e6b64f833c08ca77fc96cdf687354a15a" translate="yes" xml:space="preserve">
          <source>Longpoll configuration</source>
          <target state="translated">Longpoll 구성</target>
        </trans-unit>
        <trans-unit id="9193ce08dd0d1e4ee5c430a7e975fbc0d025be68" translate="yes" xml:space="preserve">
          <source>Looking more closely at the Router &quot;stop&quot; event, you can see that the &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct representing the request is present in the metadata, but how do you access the properties in &lt;code&gt;conn&lt;/code&gt;?</source>
          <target state="translated">Router &quot;stop&quot;이벤트를 자세히 살펴보면 요청을 나타내는 &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체가 메타 데이터에 있지만 &lt;code&gt;conn&lt;/code&gt; 의 속성에 어떻게 액세스 합니까?</target>
        </trans-unit>
        <trans-unit id="720fbca516bd7a21a834ac39b96b1f996e84c60d" translate="yes" xml:space="preserve">
          <source>Low-level usage</source>
          <target state="translated">낮은 수준의 사용</target>
        </trans-unit>
        <trans-unit id="e26dcf517d077c30e44f5f69523cc6862fc7df01" translate="yes" xml:space="preserve">
          <source>Luckily, because LiveViews and LiveComponents are in the same process, they share the same data structures. For example, in the code above, the view and the component will share the same copies of the &lt;code&gt;@user&lt;/code&gt; and &lt;code&gt;@org&lt;/code&gt; assigns.</source>
          <target state="translated">운 좋게도 LiveView와 LiveComponent는 동일한 프로세스에 있기 때문에 동일한 데이터 구조를 공유합니다. 예를 들어 위 코드에서보기와 구성 요소는 &lt;code&gt;@user&lt;/code&gt; 및 &lt;code&gt;@org&lt;/code&gt; 할당 의 동일한 복사본을 공유 합니다.</target>
        </trans-unit>
        <trans-unit id="c6898fced5a7fae04f4272d7cff745cf91bf897d" translate="yes" xml:space="preserve">
          <source>Luckily, because the component and the view run in the same process, sending a message from the component to the parent LiveView is as simple as sending a message to &lt;code&gt;self()&lt;/code&gt;:</source>
          <target state="translated">다행히도 컴포넌트와 뷰가 동일한 프로세스에서 실행되기 때문에 컴포넌트에서 부모 LiveView로 메시지를 보내는 것은 &lt;code&gt;self()&lt;/code&gt; 메시지를 보내는 것만 큼 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="600619c55e8df99ff46f5b3bb34cc4a2741f102f" translate="yes" xml:space="preserve">
          <source>Luckily, it is possible to identify all LiveView sockets by setting a &lt;code&gt;live_socket_id&lt;/code&gt; in the session. For example, when signing in a user, you could do:</source>
          <target state="translated">다행히 세션에서 &lt;code&gt;live_socket_id&lt;/code&gt; 를 설정하여 모든 LiveView 소켓을 식별 할 수 있습니다 . 예를 들어 사용자로 로그인 할 때 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994e68b51c415a0e1f6cb282ff78888effe223ae" translate="yes" xml:space="preserve">
          <source>Luckily, there is a solution to this problem. Since SVG allows &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; tags to be nested, you can wrap the component content into an &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; tag. This will ensure that it is correctly interpreted by the browser.</source>
          <target state="translated">다행히도이 문제에 대한 해결책이 있습니다. SVG는 &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; 태그의 중첩을 허용하므로 구성 요소 콘텐츠를 &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; 태그 로 래핑 할 수 있습니다 . 이렇게하면 브라우저에서 올바르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba8f2d0f2163782c80c9cd52f4a928ca1aef007" translate="yes" xml:space="preserve">
          <source>MSSQL (via &lt;a href=&quot;https://github.com/livehelpnow/tds&quot;&gt;&lt;code&gt;tds&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">MSSQL ( &lt;a href=&quot;https://github.com/livehelpnow/tds&quot;&gt; &lt;code&gt;tds&lt;/code&gt; &lt;/a&gt; 를 통해 )</target>
        </trans-unit>
        <trans-unit id="9e7ecacb6d25d8488efc01d0e32f2eaa48be34c5" translate="yes" xml:space="preserve">
          <source>Mac OS X and Windows users already have a filesystem watcher but Linux users must install inotify-tools. Please consult the &lt;a href=&quot;https://github.com/rvoicilas/inotify-tools/wiki&quot;&gt;inotify-tools wiki&lt;/a&gt; for distribution-specific installation instructions.</source>
          <target state="translated">Mac OS X 및 Windows 사용자는 이미 파일 시스템 감시자가 있지만 Linux 사용자는 inotify-tools를 설치해야합니다. 배포 별 설치 지침 은 &lt;a href=&quot;https://github.com/rvoicilas/inotify-tools/wiki&quot;&gt;inotify-tools 위키&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3d708c4d13a71cfeceee79423883db47334722d" translate="yes" xml:space="preserve">
          <source>Mac OS X users can also install node.js via &lt;a href=&quot;https://brew.sh/&quot;&gt;homebrew&lt;/a&gt;.</source>
          <target state="translated">Mac OS X 사용자는 &lt;a href=&quot;https://brew.sh/&quot;&gt;homebrew&lt;/a&gt; 를 통해 node.js를 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c44d1a0d8628a1cd966123bf0558926c82708fe" translate="yes" xml:space="preserve">
          <source>Macro API</source>
          <target state="translated">매크로 API</target>
        </trans-unit>
        <trans-unit id="1abed56a50038fd3d93f973f0467ce40a2147338" translate="yes" xml:space="preserve">
          <source>Main API to define routes</source>
          <target state="translated">경로를 정의하는 기본 API</target>
        </trans-unit>
        <trans-unit id="39960b7f5715ba45e19e351b393e17e2cfdadb17" translate="yes" xml:space="preserve">
          <source>Main API to define routes.</source>
          <target state="translated">경로를 정의하는 기본 API</target>
        </trans-unit>
        <trans-unit id="9da9b78bd1f6beee19ddbe0b4579b553f3127bb1" translate="yes" xml:space="preserve">
          <source>Make sure to replace MyApp by your actual application name.</source>
          <target state="translated">MyApp을 실제 애플리케이션 이름으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="99a0f320b2fb537dd42a7812df48f82897713b9d" translate="yes" xml:space="preserve">
          <source>Managing channel exits</source>
          <target state="translated">채널 이탈 관리</target>
        </trans-unit>
        <trans-unit id="3ad3d529b12f4fc16303c879aff5c55cedcb3d8b" translate="yes" xml:space="preserve">
          <source>Managing channels</source>
          <target state="translated">채널 관리</target>
        </trans-unit>
        <trans-unit id="f6093a240beb2a14bae8b8ae6b53d5883d5193d0" translate="yes" xml:space="preserve">
          <source>Managing state</source>
          <target state="translated">상태 관리</target>
        </trans-unit>
        <trans-unit id="f79b5db13b12d3811bad65573044bfefb5c0c943" translate="yes" xml:space="preserve">
          <source>Manual Cipher Configuration</source>
          <target state="translated">수동 암호 구성</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">수동 구성</target>
        </trans-unit>
        <trans-unit id="e6dbd2fb71df536491f55c613d4aec182595f301" translate="yes" xml:space="preserve">
          <source>Manually rendering templates</source>
          <target state="translated">수동으로 템플릿 렌더링</target>
        </trans-unit>
        <trans-unit id="0afd156b03c021a77cfbe1eeaa204c13beb281d7" translate="yes" xml:space="preserve">
          <source>Many Elixir libraries (including Phoenix) are already using the &lt;a href=&quot;http://hexdocs.pm/telemetry&quot;&gt;&lt;code&gt;:telemetry&lt;/code&gt;&lt;/a&gt; package as a way to give users more insight into the behavior of their applications, by emitting events at key moments in the application lifecycle.</source>
          <target state="translated">많은 Elixir 라이브러리 (Phoenix 포함)는 이미 응용 프로그램 수명주기의 주요 순간에 이벤트를 생성하여 사용자에게 응용 프로그램의 동작에 대한 더 많은 통찰력을 제공하는 방법으로 &lt;a href=&quot;http://hexdocs.pm/telemetry&quot;&gt; &lt;code&gt;:telemetry&lt;/code&gt; &lt;/a&gt; 패키지를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5500f345b31088b686a0015b123d5f3013ac5695" translate="yes" xml:space="preserve">
          <source>Many applications require more than one data store. For each data store, we'll need a new repo, and we can generate them automatically with &lt;code&gt;ecto.gen.repo&lt;/code&gt;.</source>
          <target state="translated">많은 응용 프로그램에는 둘 이상의 데이터 저장소가 필요합니다. 각 데이터 저장소에 대해 새 저장소가 필요하며 &lt;code&gt;ecto.gen.repo&lt;/code&gt; 를 사용하여 자동으로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05bfe4c2872329a4aea7503289ab18b4416bd983" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok,
value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 많은 기능은 내부적으로이 기능을 호출합니다. 이 함수는 대괄호 액세스 구문 ( &lt;code&gt;structure[key]&lt;/code&gt; )을 사용할 때도 사용됩니다. &lt;code&gt;structure&lt;/code&gt; 구조체 를 정의하는 모듈에 의해 구현 된 &lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt; 콜백 이 호출되고 &lt;code&gt;{:ok, value}&lt;/code&gt; 를 반환하면 &lt;code&gt;value&lt;/code&gt; 는 반환되거나, &lt;code&gt;:error&lt;/code&gt; 를 반환하면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0622625664d77a22b6a2176664f5f9d1fb2bb591" translate="yes" xml:space="preserve">
          <source>Many times, the data given on cast needs to be further pruned, specially regarding empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text-based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to the field&amp;rsquo;s default value on &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Those values are stored in the changeset &lt;code&gt;empty_values&lt;/code&gt; field and default to &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="translated">캐스트에 제공된 데이터는 특히 빈 값과 관련하여 추가로 정리해야합니다. 예를 들어, 명령 행에서 또는 HTML 양식 또는 기타 텍스트 기반 형식으로 캐스트 할 데이터를 수집하는 경우 이러한 방법으로 nil 값을 표현할 수 없습니다. 이러한 이유로 변경 세트에는 빈 값의 개념이 포함되며, 이는 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 의 필드 기본값으로 자동 변환되는 값입니다 . 이러한 값은 changeset &lt;code&gt;empty_values&lt;/code&gt; 필드에 저장되며 기본값은 &lt;code&gt;[&quot;&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61246b88ed7a5f7986b9da903039be89c9445168" translate="yes" xml:space="preserve">
          <source>Many times, the data given on cast needs to be further pruned, specially regarding empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text-based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to the field's default value on &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Those values are stored in the changeset &lt;code&gt;empty_values&lt;/code&gt; field and default to &lt;code&gt;[&quot;&quot;]&lt;/code&gt;. You can also pass the &lt;code&gt;:empty_values&lt;/code&gt; option to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; in case you want to change how a particular &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; work.</source>
          <target state="translated">여러 번, 캐스트에 제공된 데이터는 특히 빈 값과 관련하여 추가로 정리해야합니다. 예를 들어, 명령 줄에서 또는 HTML 양식 또는 기타 텍스트 기반 형식을 통해 캐스트 할 데이터를 수집하는 경우 해당 수단은 nil 값을 표현할 수 없습니다. 이러한 이유로 변경 집합에는 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 에서 필드의 기본값으로 자동 변환되는 값인 빈 값 개념이 포함됩니다 . 이러한 값은 변경 집합 &lt;code&gt;empty_values&lt;/code&gt; 필드에 저장되며 기본값은 &lt;code&gt;[&quot;&quot;]&lt;/code&gt; 입니다. 특정 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; 의&lt;/a&gt; 작동 방식을 변경하려는 경우 &lt;code&gt;:empty_values&lt;/code&gt; 옵션을 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 에 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e03bc8f9ea572e8bb58396508ed7400daec8e4f" translate="yes" xml:space="preserve">
          <source>Maps can be encoded:</source>
          <target state="translated">지도를 인코딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c0b2e757f9c2b7f54b059bdc66921ad7db9abcda" translate="yes" xml:space="preserve">
          <source>Marks a replica as down in the set and returns left users</source>
          <target state="translated">세트에서 복제본을 다운으로 표시하고 왼쪽 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f6ecb4b64f782c1574eeade5e3a5e6c7d5499e1" translate="yes" xml:space="preserve">
          <source>Marks a replica as down in the set and returns left users.</source>
          <target state="translated">세트에서 복제본을 다운으로 표시하고 왼쪽 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cac75985ecff81fbaa9d6395fc501bef58477065" translate="yes" xml:space="preserve">
          <source>Marks a replica as up in the set and returns rejoined users</source>
          <target state="translated">세트에서 복제본을 마크 업으로 표시하고 재결합 된 사용자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4a0f7b96b57238ae8a59d72d6764bfd2f16087e3" translate="yes" xml:space="preserve">
          <source>Marks a replica as up in the set and returns rejoined users.</source>
          <target state="translated">세트에서 복제본을 위로 표시하고 재결합 된 사용자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ae4938ecdc1c61c8fe5e37c2f8c552d86495eb9e" translate="yes" xml:space="preserve">
          <source>Marks the given content as raw.</source>
          <target state="translated">주어진 콘텐츠를 원시로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="668cde7b95aa944eff49d756854f316be67cc5d7" translate="yes" xml:space="preserve">
          <source>May be safe or unsafe (i.e. it needs to be converted)</source>
          <target state="translated">안전하거나 안전하지 않을 수 있습니다 (즉, 변환해야 함).</target>
        </trans-unit>
        <trans-unit id="e05b3b197d8b8e77c17df65ec7660a891ba833fe" translate="yes" xml:space="preserve">
          <source>May raise &lt;a href=&quot;ecto.queryerror&quot;&gt;&lt;code&gt;Ecto.QueryError&lt;/code&gt;&lt;/a&gt; if query validation fails.</source>
          <target state="translated">제기 할 수 &lt;a href=&quot;ecto.queryerror&quot;&gt; &lt;code&gt;Ecto.QueryError&lt;/code&gt; 를&lt;/a&gt; 쿼리 유효성 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c7d18d3f1514b0f2444c968078cf85a9c4435e6e" translate="yes" xml:space="preserve">
          <source>Measurement:</source>
          <target state="translated">Measurement:</target>
        </trans-unit>
        <trans-unit id="bb7ae1736937a08d3957bdaef0ed678a496eaede" translate="yes" xml:space="preserve">
          <source>Measurement: &lt;code&gt;%{duration: native_time}&lt;/code&gt;</source>
          <target state="translated">측정 : &lt;code&gt;%{duration: native_time}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a744e49022f94a90a9449c2c9a086d678fca16fe" translate="yes" xml:space="preserve">
          <source>Measurement: &lt;code&gt;%{system_time: System.system_time}&lt;/code&gt;</source>
          <target state="translated">측정 : &lt;code&gt;%{system_time: System.system_time}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3384ca17d10c01596373b5cd518f783f1c7fdf2c" translate="yes" xml:space="preserve">
          <source>Measurement: &lt;code&gt;%{system_time: native_time}&lt;/code&gt;</source>
          <target state="translated">측정 : &lt;code&gt;%{system_time: native_time}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e035f97dae3301683992e75819c7b7264495a5bb" translate="yes" xml:space="preserve">
          <source>Measurement: &lt;code&gt;%{system_time: system_time}&lt;/code&gt;</source>
          <target state="translated">측정 : &lt;code&gt;%{system_time: system_time}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b74c072bb7013187872af44544af0e8b5d38f913" translate="yes" xml:space="preserve">
          <source>Mergeable select query expression</source>
          <target state="translated">병합 가능한 선택 쿼리 식</target>
        </trans-unit>
        <trans-unit id="e0602da34e956cfe4ccf39291af6bbf743972760" translate="yes" xml:space="preserve">
          <source>Mergeable select query expression.</source>
          <target state="translated">병합 가능한 선택 쿼리 식</target>
        </trans-unit>
        <trans-unit id="ec8f620f7f2db18541f3f3c9f19a06244a10bf79" translate="yes" xml:space="preserve">
          <source>Merges a map into the flash.</source>
          <target state="translated">지도를 플래시에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="a9a97d779516c6c12de75d8a51f3e4535af915a5" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by an anonymous function</source>
          <target state="translated">익명 함수에 의해 동적으로 반환 된 멀티를 병합</target>
        </trans-unit>
        <trans-unit id="7539ec95f69d1d6b4a4634b33a0a8590c79d83ad" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by an anonymous function.</source>
          <target state="translated">익명 함수에 의해 동적으로 반환 된 멀티를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="502de2d879d943b97d0456728f32d2c986101961" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by calling &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 를 사용 하여 &lt;code&gt;module&lt;/code&gt; 과 &lt;code&gt;function&lt;/code&gt; 를 호출하여 동적으로 반환 된 멀티를 병합</target>
        </trans-unit>
        <trans-unit id="29a2e7237d9dee4cc5a360feac545f1d1971bad4" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by calling &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 를 사용 하여 &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;function&lt;/code&gt; 을 호출하여 동적으로 반환 된 멀티를 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="57958d33f03b60f05d8a34f941485854b9bf467d" translate="yes" xml:space="preserve">
          <source>Merges a series of response headers into the connection</source>
          <target state="translated">일련의 응답 헤더를 연결에 병합</target>
        </trans-unit>
        <trans-unit id="ce5152c17c059a57bc8e11b5c5b0541b8e4778a9" translate="yes" xml:space="preserve">
          <source>Merges a series of response headers into the connection.</source>
          <target state="translated">일련의 응답 헤더를 연결에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="941f60e1885ad38ab5cd520fe6ac6723852ffc96" translate="yes" xml:space="preserve">
          <source>Merges the map on the right over the map on the left</source>
          <target state="translated">오른쪽의지도를 왼쪽의지도 위에 병합</target>
        </trans-unit>
        <trans-unit id="2e8960db43dcc2c7152168ec7ddbeaa64641007c" translate="yes" xml:space="preserve">
          <source>Merges the map on the right over the map on the left.</source>
          <target state="translated">오른쪽의 맵을 왼쪽의 맵 위에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="02b5244c8d4b9e3c41b4940e22fc1dfb9c417c42" translate="yes" xml:space="preserve">
          <source>Merges two changesets</source>
          <target state="translated">두 개의 변경 세트를 병합</target>
        </trans-unit>
        <trans-unit id="531ed93b3b84f718e731466faa80ec118f9e0df8" translate="yes" xml:space="preserve">
          <source>Merges two changesets.</source>
          <target state="translated">두 개의 변경 세트를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="a3915b79f92d6a448ae5c8fabd6eee46571b15e0" translate="yes" xml:space="preserve">
          <source>Merges two sets, or a delta into a set</source>
          <target state="translated">두 세트 또는 델타를 세트로 병합</target>
        </trans-unit>
        <trans-unit id="122840ff6ee2d32e7c4455601ee79ffe39542536" translate="yes" xml:space="preserve">
          <source>Merges two sets, or a delta into a set.</source>
          <target state="translated">두 세트 또는 델타를 세트로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="0ab6539c6aa5bb1b163448c2103e14655ba3dbd3" translate="yes" xml:space="preserve">
          <source>Metadata:</source>
          <target state="translated">Metadata:</target>
        </trans-unit>
        <trans-unit id="6b76db96dfa23f9dfa1ebe701738a0acfd702e9c" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, kind: :throw | :error | :exit, reason: term(), stacktrace: Exception.stacktrace()}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, kind: :throw | :error | :exit, reason: term(), stacktrace: Exception.stacktrace()}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65d0bba4edc1c500b0f0228875d5781f131efd69" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, options: Keyword.t}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, options: Keyword.t}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd108d354bf42a2bead0a858ce622812c15a964f" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, route: binary, plug: module, plug_opts: term, path_params: map, pipe_through: [atom], log: Logger.level | false}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, route: binary, plug: module, plug_opts: term, path_params: map, pipe_through: [atom], log: Logger.level | false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3149557d13a87076ab4bdce7ae7aea60a65f3f91" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, route: binary, plug: module, plug_opts: term, path_params: map, pipe_through: [atom]}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, route: binary, plug: module, plug_opts: term, path_params: map, pipe_through: [atom]}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="662c7b824ff90d9c0f5e030f077b3f4065266466" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, route: binary, router: module}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, route: binary, router: module}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7072d2fe240e8421f95cece67fd6ad93d39da09" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t, status: Plug.Conn.status, kind: Exception.kind, reason: term, stacktrace: Exception.stacktrace}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t, status: Plug.Conn.status, kind: Exception.kind, reason: term, stacktrace: Exception.stacktrace}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33bdc300d9f49419997f73ccd950c1482c4615d2" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{conn: Plug.Conn.t}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{conn: Plug.Conn.t}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f239b85b85c4c215e5db31ab82ee4e434fb22a2" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{endpoint: atom, transport: atom, params: term, connect_info: map, vsn: binary, user_socket: atom, result: :ok | :error, serializer: atom, log: Logger.level | false}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{endpoint: atom, transport: atom, params: term, connect_info: map, vsn: binary, user_socket: atom, result: :ok | :error, serializer: atom, log: Logger.level | false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d95e757b0b2cce533c511316616cdf4474eb9ba6" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{event: binary, params: term, socket: Phoenix.Socket.t}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{event: binary, params: term, socket: Phoenix.Socket.t}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc1b28002c3a86ee3949a40d3a92c115d1dc7a8" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{repo: Ecto.Repo, opts: Keyword.t()}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{repo: Ecto.Repo, opts: Keyword.t()}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="761df135c2ec4fafeea32ffa3ec49cbbaa73db43" translate="yes" xml:space="preserve">
          <source>Metadata: &lt;code&gt;%{result: :ok | :error, params: term, socket: Phoenix.Socket.t}&lt;/code&gt;</source>
          <target state="translated">메타 데이터 : &lt;code&gt;%{result: :ok | :error, params: term, socket: Phoenix.Socket.t}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddf6a1f0ce8cfffc5cd8f14230ab1fecd0f34953" translate="yes" xml:space="preserve">
          <source>Metrics</source>
          <target state="translated">Metrics</target>
        </trans-unit>
        <trans-unit id="981c56ca0d17bc960ffbd953a1a6c1b03316559f" translate="yes" xml:space="preserve">
          <source>Metrics are aggregations of Telemetry events with a specific name, providing a view of the system's behaviour over time.</source>
          <target state="translated">메트릭은 특정 이름을 가진 Telemetry 이벤트의 집계로, 시간 경과에 따른 시스템 동작에 대한보기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e458173eef4a800366eeb68965cf8f147c4756b" translate="yes" xml:space="preserve">
          <source>Migration</source>
          <target state="translated">Migration</target>
        </trans-unit>
        <trans-unit id="0daf241c4dd13554073f07ada5a5c873672e9612" translate="yes" xml:space="preserve">
          <source>Migrations are a programmatic, repeatable way to affect changes to a database schema. Migrations are also just modules, and we can create them with the &lt;code&gt;ecto.gen.migration&lt;/code&gt; task. Let's walk through the steps to create a migration for a new comments table.</source>
          <target state="translated">마이그레이션은 데이터베이스 스키마의 변경 사항에 영향을주는 프로그래밍 방식의 반복 가능한 방법입니다. 마이그레이션은 모듈 일 &lt;code&gt;ecto.gen.migration&lt;/code&gt; 작업을 사용하여 만들 수 있습니다 . 새 주석 테이블에 대한 마이그레이션을 만드는 단계를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">혼합 작업</target>
        </trans-unit>
        <trans-unit id="5350d908077a396ae56f7f8796818e8da6ab3923" translate="yes" xml:space="preserve">
          <source>Mix assumes that we are in the development environment unless we tell it otherwise with &lt;code&gt;MIX_ENV=prod mix ecto.migrate&lt;/code&gt;.</source>
          <target state="translated">Mix는 &lt;code&gt;MIX_ENV=prod mix ecto.migrate&lt;/code&gt; 를 사용 하여 달리 말하지 않는 한 우리가 개발 환경에 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3c9bf7c6de3ecb74ac52b84e399f4368727e2a2b" translate="yes" xml:space="preserve">
          <source>Mix tasks and generators</source>
          <target state="translated">혼합 작업 및 생성기</target>
        </trans-unit>
        <trans-unit id="82ea088f9a1123debf0e7aa3ef3f18ae150571d5" translate="yes" xml:space="preserve">
          <source>Mix.Ecto</source>
          <target state="translated">Mix.Ecto</target>
        </trans-unit>
        <trans-unit id="8696aa2d675ccb542c46d74b216b58f46f22bae1" translate="yes" xml:space="preserve">
          <source>Module Plugs</source>
          <target state="translated">모듈 플러그</target>
        </trans-unit>
        <trans-unit id="a5bacc2154fe35adde562356475fbcb75af8d43b" translate="yes" xml:space="preserve">
          <source>Module plugs</source>
          <target state="translated">모듈 플러그</target>
        </trans-unit>
        <trans-unit id="dbc6de6279622177a917cc1811e685e3c0e26145" translate="yes" xml:space="preserve">
          <source>Module plugs are another type of Plug that let us define a connection transformation in a module. The module only needs to implement two functions:</source>
          <target state="translated">모듈 플러그는 모듈에서 연결 변환을 정의 할 수있는 또 다른 유형의 플러그입니다. 모듈은 두 가지 기능 만 구현하면됩니다.</target>
        </trans-unit>
        <trans-unit id="023d267e1867d5eff92406f80cc111867c1210f6" translate="yes" xml:space="preserve">
          <source>More information on the migration for creating such a schema is shown below.</source>
          <target state="translated">이러한 스키마 작성을위한 마이그레이션에 대한 자세한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="790bce08848434bc69e698160212f5c800b0d960" translate="yes" xml:space="preserve">
          <source>More on Path Helpers</source>
          <target state="translated">경로 도우미에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="5a4254e79e985b1798114b8612784970b94d85d5" translate="yes" xml:space="preserve">
          <source>Most HTTP/1.1 clients do not properly support informational responses but some proxies require it to support server push for HTTP/2. You can call &lt;a href=&quot;#get_http_protocol/1&quot;&gt;&lt;code&gt;get_http_protocol/1&lt;/code&gt;&lt;/a&gt; to retrieve the protocol and version.</source>
          <target state="translated">대부분의 HTTP / 1.1 클라이언트는 정보 응답을 제대로 지원하지 않지만 일부 프록시는 HTTP / 2에 대한 서버 푸시를 지원해야합니다. &lt;a href=&quot;#get_http_protocol/1&quot;&gt; &lt;code&gt;get_http_protocol/1&lt;/code&gt; &lt;/a&gt; 을 호출 하여 프로토콜 및 버전을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb09ee4b294fbfea38eb275e1237d7d1466082d6" translate="yes" xml:space="preserve">
          <source>Most of the configuration that goes into the &lt;code&gt;config&lt;/code&gt; is specific to the adapter, so check &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; documentation for more information. However, some configuration is shared across all adapters, they are:</source>
          <target state="translated">에 들어가는 대부분의 구성 &lt;code&gt;config&lt;/code&gt; 그래서 확인, 어댑터에 고유 &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; 에 대한 자세한 내용은 문서를. 그러나 일부 구성은 모든 어댑터에서 공유되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d9a833447c8049a3ad19fe194f66ce9b0a20090" translate="yes" xml:space="preserve">
          <source>Most of the configuration that goes into the &lt;code&gt;config&lt;/code&gt; is specific to the adapter. For this particular example, you can check &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Adapters.Postgres.html&quot;&gt;&lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt;&lt;/a&gt; for more information. In spite of this, the following configuration values are shared across all adapters:</source>
          <target state="translated">에 들어가는 대부분의 구성 &lt;code&gt;config&lt;/code&gt; 어댑터에 고유합니다. 이 특정 예의 경우 &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Adapters.Postgres.html&quot;&gt; &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; &lt;/a&gt; 에서 자세한 내용을 확인할 수 있습니다 . 그럼에도 불구하고 다음 구성 값은 모든 어댑터에서 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="2c145af550dde5f46b9e4696ddd1212973954998" translate="yes" xml:space="preserve">
          <source>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, you may want to tell Ecto that a parameter has some particular type:</source>
          <target state="translated">대부분의 경우 Ecto는 유형 검사 메커니즘으로 인해 적절한 보간 값을 캐스팅 할 수 있습니다. 그러나 어떤 상황에서는 Ecto에 매개 변수에 특정 유형이 있다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f134ad078fea264b6de84ed9f31c5503c7679c" translate="yes" xml:space="preserve">
          <source>Most of those messages are user messages except:</source>
          <target state="translated">이러한 메시지는 대부분 다음을 제외하고 사용자 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="78d8255a90dd6976659e3b3bbb772d285938d373" translate="yes" xml:space="preserve">
          <source>Most web applications today need some form of data validation and persistence. In the Elixir ecosystem, we have Ecto to enable this. Before we jump into building database-backed web features, we're going to focus on the finer details of Ecto to give a solid base to build our web features on top of. Let's get started!</source>
          <target state="translated">오늘날 대부분의 웹 애플리케이션에는 일정한 형태의 데이터 유효성 검사 및 지속성이 필요합니다. Elixir 생태계에는이를 가능하게하는 Ecto가 있습니다. 데이터베이스 기반 웹 기능을 구축하기 전에 웹 기능을 구축 할 수있는 견고한 기반을 제공하기 위해 Ecto의 세부 사항에 초점을 맞출 것입니다. 시작하자!</target>
        </trans-unit>
        <trans-unit id="a188458e71cfa2d3b910d466e722198838573525" translate="yes" xml:space="preserve">
          <source>Mounting considerations</source>
          <target state="translated">장착 고려 사항</target>
        </trans-unit>
        <trans-unit id="2db17d187e6b646d780b3d0beb7bb6dcde206fda" translate="yes" xml:space="preserve">
          <source>Mounts, updates and renders a component.</source>
          <target state="translated">구성 요소를 마운트, 업데이트 및 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b46227126fb387bbbda3613451d38be5999d30bb" translate="yes" xml:space="preserve">
          <source>Move the options to a module attribute at the top of your file:</source>
          <target state="translated">옵션을 파일 맨 위에있는 모듈 속성으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="e4817e037eb35285aec42c91897d990919177151" translate="yes" xml:space="preserve">
          <source>Moves cookies from a connection into a new connection for subsequent requests</source>
          <target state="translated">후속 요청을 위해 쿠키를 연결에서 새 연결로 이동</target>
        </trans-unit>
        <trans-unit id="01c37f68ea24f1c8881a0bb14ffdf08a1ed447b9" translate="yes" xml:space="preserve">
          <source>Moves cookies from a connection into a new connection for subsequent requests.</source>
          <target state="translated">후속 요청을 위해 쿠키를 연결에서 새 연결로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="833bffc08d3a9c875fbb22617882f0e1a5923f92" translate="yes" xml:space="preserve">
          <source>Multi allows you to run arbitrary functions as part of your transaction via &lt;a href=&quot;#run/3&quot;&gt;&lt;code&gt;run/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#run/5&quot;&gt;&lt;code&gt;run/5&lt;/code&gt;&lt;/a&gt;. This is especially useful when an operation depends on the value of a previous operation. For this reason, the function given as a callback to &lt;a href=&quot;#run/3&quot;&gt;&lt;code&gt;run/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#run/5&quot;&gt;&lt;code&gt;run/5&lt;/code&gt;&lt;/a&gt; will receive the repo as the first argument, and all changes performed by the multi so far as a map for the second argument.</source>
          <target state="translated">Multi를 사용하면 &lt;a href=&quot;#run/3&quot;&gt; &lt;code&gt;run/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#run/5&quot;&gt; &lt;code&gt;run/5&lt;/code&gt; &lt;/a&gt; 통해 트랜잭션의 일부로 임의의 기능을 실행할 수 있습니다 . 이것은 조작이 이전 조작의 값에 의존 할 때 특히 유용합니다. 이러한 이유로 &lt;a href=&quot;#run/3&quot;&gt; &lt;code&gt;run/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#run/5&quot;&gt; &lt;code&gt;run/5&lt;/code&gt; 에&lt;/a&gt; 대한 콜백으로 제공된 함수 는 첫 번째 인수로 repo를 수신하고 두 번째 인수에 대한 맵까지 멀티에 의해 수행 된 모든 변경 사항을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="75854cc2e0b50f35c5496f91c9272ba5bab0916a" translate="yes" xml:space="preserve">
          <source>Multiple LiveViews in the same page</source>
          <target state="translated">동일한 페이지에있는 여러 LiveView</target>
        </trans-unit>
        <trans-unit id="762b531feb7f88155017a3d9112eac22dd92c8cc" translate="yes" xml:space="preserve">
          <source>Multiple plugs can be defined with the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro, forming a pipeline. The plugs in the pipeline will be executed in the order they&amp;rsquo;ve been added through the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro. In the example above, &lt;a href=&quot;plug.logger&quot;&gt;&lt;code&gt;Plug.Logger&lt;/code&gt;&lt;/a&gt; will be called first and then the &lt;code&gt;:hello&lt;/code&gt; function plug will be called on the resulting connection.</source>
          <target state="translated">&lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 매크로로 여러 개의 플러그를 정의 하여 파이프 라인을 형성 할 수 있습니다 . 파이프 라인의 &lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 는 플러그 / 2 매크로를 통해 추가 된 순서대로 실행됩니다 . 위의 예제에서 &lt;a href=&quot;plug.logger&quot;&gt; &lt;code&gt;Plug.Logger&lt;/code&gt; &lt;/a&gt; 가 먼저 호출 된 다음 결과 연결 에서 &lt;code&gt;:hello&lt;/code&gt; 함수 플러그가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9ee2f55e3d0a2d3ca3cd60a7ea6de79d8d66b4e7" translate="yes" xml:space="preserve">
          <source>Multiple plugs can be defined with the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro, forming a pipeline. The plugs in the pipeline will be executed in the order they've been added through the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro. In the example above, &lt;a href=&quot;plug.logger&quot;&gt;&lt;code&gt;Plug.Logger&lt;/code&gt;&lt;/a&gt; will be called first and then the &lt;code&gt;:hello&lt;/code&gt; function plug will be called on the resulting connection.</source>
          <target state="translated">&lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 파이프 라인을 형성하는 여러 플러그를 정의 할 수 있습니다 . 파이프 라인의 &lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 는 plug / 2 매크로를 통해 추가 된 순서대로 실행됩니다 . 위의 예에서 &lt;a href=&quot;plug.logger&quot;&gt; &lt;code&gt;Plug.Logger&lt;/code&gt; &lt;/a&gt; 가 먼저 호출 된 다음 결과 연결 에서 &lt;code&gt;:hello&lt;/code&gt; 함수 플러그가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4c38c9515c472b9837dedb7d97127653c55b99de" translate="yes" xml:space="preserve">
          <source>MyRepo.reload!([post1, post2]) [%Post{}, %Post{}]</source>
          <target state="translated">MyRepo.reload! ([post1, post2]) [% Post {}, % Post {}]</target>
        </trans-unit>
        <trans-unit id="7e54f90673eaa2d3e5724deebf9906ead3d8645a" translate="yes" xml:space="preserve">
          <source>MyRepo.reload!(post) %Post{}</source>
          <target state="translated">MyRepo.reload! (게시물) % Post {}</target>
        </trans-unit>
        <trans-unit id="6b22f4ae317b89567d6917b231af6d84dffaa1e2" translate="yes" xml:space="preserve">
          <source>MyRepo.reload([deleted_post, post1]) [nil, %Post{}]</source>
          <target state="translated">MyRepo.reload ([deleted_post, post1]) [nil, % Post {}]</target>
        </trans-unit>
        <trans-unit id="4aaef92042a1be60582f96d5526078f93a9fea78" translate="yes" xml:space="preserve">
          <source>MyRepo.reload([post1, post2]) [%Post{}, %Post{}]</source>
          <target state="translated">MyRepo.reload ([post1, post2]) [% Post {}, % Post {}]</target>
        </trans-unit>
        <trans-unit id="51894d51efb3b83bc1c630edd8719d560c39c971" translate="yes" xml:space="preserve">
          <source>MyRepo.reload(post) %Post{}</source>
          <target state="translated">MyRepo.reload (post) % Post {}</target>
        </trans-unit>
        <trans-unit id="cbe1e9dbf7b84b6e5c55c79af8a3951ee496e662" translate="yes" xml:space="preserve">
          <source>MySQL (via &lt;a href=&quot;https://github.com/elixir-ecto/myxql&quot;&gt;&lt;code&gt;myxql&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">MySQL ( &lt;a href=&quot;https://github.com/elixir-ecto/myxql&quot;&gt; &lt;code&gt;myxql&lt;/code&gt; 사용&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f9de1517a4b476a9c48b39ed877798606c11b1ff" translate="yes" xml:space="preserve">
          <source>MySQL will return, at a minimum, the number of entries attempted. For example, if &lt;code&gt;:on_conflict&lt;/code&gt; is set to &lt;code&gt;:nothing&lt;/code&gt;, MySQL will return the number of entries attempted to be inserted, even when no entry was added.</source>
          <target state="translated">MySQL은 최소한 시도한 항목 수를 반환합니다. 예를 들어, &lt;code&gt;:on_conflict&lt;/code&gt; 로 설정 &lt;code&gt;:nothing&lt;/code&gt; , MySQL은 어떤 항목이 추가되지 않은 경우에도 항목의 수를 삽입 할 시도 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="13989bd1dc00ffbc980d6c94b69810e4ef0e3b83" translate="yes" xml:space="preserve">
          <source>NOTE: Ecto does not lazy load associations. While lazily loading associations may sound convenient at first, in the long run it becomes a source of confusion and performance issues.</source>
          <target state="translated">참고 : Ecto는로드 연관을 지연시키지 않습니다. 처음에는 느리게로드되는 연결이 편리하게 들리지만 장기적으로 혼란과 성능 문제의 원인이됩니다.</target>
        </trans-unit>
        <trans-unit id="e14cb300ba8325c2102c73a68cebde93c1baf4c8" translate="yes" xml:space="preserve">
          <source>NOTE: by using &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;, an &lt;code&gt;:id&lt;/code&gt; field with type &lt;code&gt;:id&lt;/code&gt; (:id means :integer) is generated by default, which is the primary key of the Schema. If you want to use a different primary key, you can declare custom &lt;code&gt;@primary_key&lt;/code&gt; before the &lt;code&gt;schema/2&lt;/code&gt; call. Consult the &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">참고 : &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 를 사용 하면 기본적으로 스키마의 기본 키인 유형 &lt;code&gt;:id&lt;/code&gt; (: id는 : integer) 인 &lt;code&gt;:id&lt;/code&gt; 필드 가 생성됩니다. 다른 기본 키를 사용 하려면 &lt;code&gt;schema/2&lt;/code&gt; 호출 전에 사용자 정의 &lt;code&gt;@primary_key&lt;/code&gt; 를 선언 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb1361c635e3503d7f2e4a6295cdf3de9ad43167" translate="yes" xml:space="preserve">
          <source>NOTE: when using Google Chrome, open chrome://flags/#allow-insecure-localhost to enable the use of self-signed certificates on &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">참고 : 구글 크롬, 개방 크롬을 사용하는 경우 : // 플래그 / # 허용 - 불안 - 로컬 호스트가 자체 서명 된 인증서를 사용할 수 있도록하는 &lt;code&gt;localhost&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75759c54c05dc9ac9a57424fb90dc1564b6105c9" translate="yes" xml:space="preserve">
          <source>NaN and infinite decimals are not supported, use custom types instead.</source>
          <target state="translated">NaN 및 무한 소수는 지원되지 않습니다. 대신 사용자 정의 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd8adfc3b9778f59e1149aee2d219e827012b80" translate="yes" xml:space="preserve">
          <source>Named bindings</source>
          <target state="translated">명명 된 바인딩</target>
        </trans-unit>
        <trans-unit id="1baad6f562ae39bcf7c08ce18bba96e44e7e3f7c" translate="yes" xml:space="preserve">
          <source>Named bindings can also be use for late binding when use with the &lt;code&gt;as/1&lt;/code&gt; construct, allowing you to refer to a binding that has not been defined yet:</source>
          <target state="translated">명명 된 바인딩은 &lt;code&gt;as/1&lt;/code&gt; 구문 과 함께 사용할 때 후기 바인딩에도 사용할 수 있으므로 아직 정의되지 않은 바인딩을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7e5d8bec4aa7b812c5c3499a3c6e87a4eec62c" translate="yes" xml:space="preserve">
          <source>Namespaced resources</source>
          <target state="translated">네임 스페이스 자원</target>
        </trans-unit>
        <trans-unit id="1bb3fe97255abf9e2f91ad6dcdd5a3b1fdf9acbf" translate="yes" xml:space="preserve">
          <source>Naming things is hard. If you're stuck when trying to come up with a context name when the grouped functionality in your system isn't yet clear, you can simply use the plural form of the resource you're creating. For example, a &lt;code&gt;Users&lt;/code&gt; context for managing users. As you grow your application and the parts of your system become clear, you can simply rename the context to a more refined name at a later time.</source>
          <target state="translated">이름을 지정하는 것은 어렵습니다. 시스템의 그룹화 된 기능이 아직 명확하지 않은 상황에서 컨텍스트 이름을 만들려고 할 때 막히면 생성중인 리소스의 복수형을 사용할 수 있습니다. 예를 들어, &lt;code&gt;Users&lt;/code&gt; 관리를위한 사용자 컨텍스트. 응용 프로그램을 확장하고 시스템의 일부가 명확 해지면 나중에 컨텍스트 이름을 좀 더 정제 된 이름으로 간단히 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="248022a870eb27897fa53e16452caafdbdabcf57" translate="yes" xml:space="preserve">
          <source>Nested Resources</source>
          <target state="translated">중첩 된 리소스</target>
        </trans-unit>
        <trans-unit id="8d4b12f8d7f11ef23bb408604336a8dfe441bbe1" translate="yes" xml:space="preserve">
          <source>Nested associations can also be preloaded in both formats:</source>
          <target state="translated">중첩 된 연결은 두 가지 형식으로 미리로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7afad4dc0eae2b12d5e245c5b82007fd11a1998" translate="yes" xml:space="preserve">
          <source>Nested inputs</source>
          <target state="translated">중첩 된 입력</target>
        </trans-unit>
        <trans-unit id="f1d65dcc9d3d6ca80db0b892b3aa00c0e363499b" translate="yes" xml:space="preserve">
          <source>Nested structures can be created via &lt;code&gt;[key]&lt;/code&gt;:</source>
          <target state="translated">중첩 된 구조는 &lt;code&gt;[key]&lt;/code&gt; 를 통해 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6fe6658ccfdf3c44f06021e29648540b15bf4fc" translate="yes" xml:space="preserve">
          <source>Nesting and fingerprinting</source>
          <target state="translated">중첩 및 지문</target>
        </trans-unit>
        <trans-unit id="6e05035aa3e747edcb0aed3616a4c996a1f32d87" translate="yes" xml:space="preserve">
          <source>Never do anything on &lt;code&gt;def render(assigns)&lt;/code&gt; besides rendering a template or invoking the &lt;code&gt;~L&lt;/code&gt; sigil</source>
          <target state="translated">&lt;code&gt;def render(assigns)&lt;/code&gt; 에서 템플릿을 렌더링하거나 &lt;code&gt;~L&lt;/code&gt; 시길을 호출하는 것 외에는 아무것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b24c57190cd211af4290f8ccf482da51559f88f2" translate="yes" xml:space="preserve">
          <source>New encoders can be added via the format encoder option:</source>
          <target state="translated">포맷 인코더 옵션을 통해 새 인코더를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbbac91ec652a8972f156f3f69a1e666fdd052c6" translate="yes" xml:space="preserve">
          <source>New lines</source>
          <target state="translated">새로운 줄</target>
        </trans-unit>
        <trans-unit id="8995fa032bc8e05456581871b1826c10275f897e" translate="yes" xml:space="preserve">
          <source>Newly generated Phoenix applications now include ecto and postgrex as dependencies by default (which is to say, unless we use &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;--no-ecto&lt;/code&gt; flag). With those dependencies come mix tasks to take care of common ecto operations. Let's see which tasks we get out of the box.</source>
          <target state="translated">새로 생성 된 Phoenix 애플리케이션은 이제 기본적으로 종속성으로 ecto 및 postgrex를 포함합니다 (즉, &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;--no-ecto&lt;/code&gt; 플래그를 함께 사용하지 않는 경우 ). 이러한 종속성으로 인해 일반적인 ecto 작업을 처리하기 위해 혼합 작업이 제공됩니다. 어떤 작업이 상자에서 나오는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="23fb93c0ee5dd80140d0d827891f7b05c51649ff" translate="yes" xml:space="preserve">
          <source>Newly generated Phoenix projects include Ecto with the PostgreSQL adapter by default. You can pass the &lt;code&gt;--database&lt;/code&gt; option to change or &lt;code&gt;--no-ecto&lt;/code&gt; flag to exclude this.</source>
          <target state="translated">새로 생성 된 Phoenix 프로젝트에는 기본적으로 PostgreSQL 어댑터가있는 Ecto가 포함됩니다. &lt;code&gt;--database&lt;/code&gt; 옵션을 전달하여 변경하거나 &lt;code&gt;--no-ecto&lt;/code&gt; 플래그를 전달하여 이를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26518d7a05a2252dcdacdd9dea68e68ad5a273e8" translate="yes" xml:space="preserve">
          <source>Next, &lt;a href=&quot;../ecto/ecto.changeset#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; checks that this list of fields is present in the changeset that &lt;code&gt;cast/3&lt;/code&gt; returns. By default with the generator, all fields are required.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../ecto/ecto.changeset#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;cast/3&lt;/code&gt; 가 반환 하는 변경 집합에이 필드 목록이 있는지 확인 합니다. 생성기에서는 기본적으로 모든 필드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de21f779999e4b43019aab4321e738d83d000131" translate="yes" xml:space="preserve">
          <source>Next, add a new template in &lt;code&gt;lib/hello_web/templates/session/new.html.eex&lt;/code&gt;:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/hello_web/templates/session/new.html.eex&lt;/code&gt; 에 새 템플릿을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1f014cb367bb71f5fc1e94e3a1bf7ba14972e8f1" translate="yes" xml:space="preserve">
          <source>Next, add the following imports to your web file in &lt;code&gt;lib/my_app_web.ex&lt;/code&gt;:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; 의 웹 파일에 다음 가져 오기를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6708d8752a556a739a123bb27ff07615eadfaa47" translate="yes" xml:space="preserve">
          <source>Next, add the new supervisor to your supervision tree in &lt;code&gt;lib/my_app.ex&lt;/code&gt;:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/my_app.ex&lt;/code&gt; 의 감독 트리에 새 감독자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bac4543af499e6dba143ca6e24376eee1fe96810" translate="yes" xml:space="preserve">
          <source>Next, add the new supervisor to your supervision tree in &lt;code&gt;lib/my_app/application.ex&lt;/code&gt;. It must be after the PubSub child and before the endpoint:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 의 감독 트리에 새 감독자를 추가하십시오 . PubSub 하위와 엔드 포인트 앞에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f430544de17f8619e24d931424727bd8cd8bd0a5" translate="yes" xml:space="preserve">
          <source>Next, decide where you want to use your LiveView.</source>
          <target state="translated">다음으로 LiveView를 사용할 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="14070b75a5413bc7e2b24cde6e3f5ef097bf59fe" translate="yes" xml:space="preserve">
          <source>Next, expose a new socket for LiveView updates in your app's endpoint module.</source>
          <target state="translated">다음으로 앱의 엔드 포인트 모듈에서 LiveView 업데이트를위한 새 소켓을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="e94c4d95f82e907331e0d5c160c3735f98da3d77" translate="yes" xml:space="preserve">
          <source>Next, implement &lt;code&gt;MyTracker&lt;/code&gt; with support for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour callbacks. An example of a minimal tracker could include:</source>
          <target state="translated">다음으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 동작 콜백 을 지원 하는 &lt;code&gt;MyTracker&lt;/code&gt; 를 구현 합니다. 최소 추적기의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab7dcbb2ba96d66fd695eab8bf3ec5b603dd1b78" translate="yes" xml:space="preserve">
          <source>Next, implement &lt;code&gt;MyTracker&lt;/code&gt; with support for the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour callbacks. An example of a minimal tracker could include:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 동작 콜백 을 지원하여 &lt;code&gt;MyTracker&lt;/code&gt; 를 구현 하십시오 . 최소 추적기의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21dbbdc3d6b14b91a279a05500a0b232ef70161b" translate="yes" xml:space="preserve">
          <source>Next, let's build a changeset from our schema with an empty &lt;code&gt;User&lt;/code&gt; struct, and an empty map of parameters.</source>
          <target state="translated">다음으로, 빈 &lt;code&gt;User&lt;/code&gt; 구조체와 빈 매개 변수 맵을 사용하여 스키마에서 변경 집합을 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a6daec8002385796e51d2353665cce5b66f2b80b" translate="yes" xml:space="preserve">
          <source>Next, let's dig deeper and check out our &lt;code&gt;Accounts&lt;/code&gt; context in &lt;code&gt;lib/hello/accounts.ex&lt;/code&gt;:</source>
          <target state="translated">다음 으로 &lt;code&gt;lib/hello/accounts.ex&lt;/code&gt; 에서 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 자세히 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2a3e9955694e977733c4b3f870ddb16186a4d397" translate="yes" xml:space="preserve">
          <source>Next, let's expose our new feature to the web by adding the credentials input to our user form. Open up &lt;code&gt;lib/hello_web/templates/user/form.html.eex&lt;/code&gt; and key in the new credential form group above the submit button:</source>
          <target state="translated">다음으로 사용자 양식에 자격 증명 입력을 추가하여 새로운 기능을 웹에 노출 해 보겠습니다. &lt;code&gt;lib/hello_web/templates/user/form.html.eex&lt;/code&gt; 를 열고 제출 버튼 위에 새 자격 증명 양식 그룹을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="df54bc39158d7ea13ae841496809f61fd63e8872" translate="yes" xml:space="preserve">
          <source>Next, let's migrate up our database as Phoenix instructed:</source>
          <target state="translated">다음으로 Phoenix의 지시에 따라 데이터베이스를 마이그레이션 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6314deae8c82e688a6c6cfecd7e480a07c5ab3ae" translate="yes" xml:space="preserve">
          <source>Next, let's open up &lt;code&gt;lib/hello_web/templates/cms/page/show.html.eex&lt;/code&gt; and make use of our new function:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/hello_web/templates/cms/page/show.html.eex&lt;/code&gt; 를 열고 새 함수를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="24348c3e6908a953ab31cd79285c3323aec2b572" translate="yes" xml:space="preserve">
          <source>Next, let's reset our database so we also discard the table we have just removed:</source>
          <target state="translated">다음으로, 방금 제거한 테이블도 삭제하도록 데이터베이스를 재설정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d72548a96c5825ee3bdcbdb7a4d013cbb7148316" translate="yes" xml:space="preserve">
          <source>Next, let's show the user's email address in the user show template. Add the following code to &lt;code&gt;lib/hello_web/templates/user/show.html.eex&lt;/code&gt;:</source>
          <target state="translated">다음으로 사용자 표시 템플릿에 사용자의 이메일 주소를 표시해 보겠습니다. &lt;code&gt;lib/hello_web/templates/user/show.html.eex&lt;/code&gt; 에 다음 코드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="735bc22f9206d93d88be56eada0b0ed286ff9f84" translate="yes" xml:space="preserve">
          <source>Next, let's use our new &lt;code&gt;params&lt;/code&gt; map to create another changeset.</source>
          <target state="translated">다음으로, 새로운 &lt;code&gt;params&lt;/code&gt; 맵을 사용하여 다른 변경 세트를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1191e0e61b513083ac9f784ba039c8d038f3e570" translate="yes" xml:space="preserve">
          <source>Next, let's wire up our session routes in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;:</source>
          <target state="translated">다음으로 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 에 세션 경로를 연결해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5861c3eb8ccdf0c67aa3fca930c16a1df35a0d2c" translate="yes" xml:space="preserve">
          <source>Next, we added an &lt;code&gt;:authorize_page&lt;/code&gt; plug that makes use of plug's guard clause feature where we can limit the plug to only certain actions. The definition for our &lt;code&gt;authorize_page/2&lt;/code&gt; plug first fetches the page from the connection params, then does an authorization check against the &lt;code&gt;current_author&lt;/code&gt;. If our current author's ID matches the fetched page ID, we have verified the page's owner is accessing the page and we simply assign the &lt;code&gt;page&lt;/code&gt; into the connection assigns to be used in the controller action. If our authorization fails, we add a flash error message, redirect to the page index screen, and then call &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; to prevent the plug pipeline from continuing and invoking the controller action.</source>
          <target state="translated">다음으로 플러그를 특정 동작으로 만 제한 할 수있는 플러그의 보호 절 기능을 사용 하는 &lt;code&gt;:authorize_page&lt;/code&gt; 플러그를 추가했습니다 . &lt;code&gt;authorize_page/2&lt;/code&gt; 플러그에 대한 정의는 먼저 연결 매개 변수에서 페이지를 가져온 다음 &lt;code&gt;current_author&lt;/code&gt; 에 대한 권한 검사를 수행합니다 . 현재 작성자의 ID가 가져온 페이지 ID와 일치하면 페이지 소유자가 페이지에 액세스하고 있는지 확인 하고 컨트롤러 작업에서 사용할 연결 할당에 &lt;code&gt;page&lt;/code&gt; 를 할당하기 만하면 됩니다. 인증에 실패하면 플래시 오류 메시지를 추가하고 페이지 인덱스 화면으로 리디렉션 한 다음 &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt; 을 호출 하여 플러그 파이프 라인이 계속해서 컨트롤러 작업을 호출하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a4cd0f08fb8eac320fa09d6e720313b4862c2a4a" translate="yes" xml:space="preserve">
          <source>Next, we need to configure our adapter to use the default MySQL credentials. Let's open up our &lt;code&gt;config/dev.exs&lt;/code&gt; file and do that.</source>
          <target state="translated">다음으로 기본 MySQL 자격 증명을 사용하도록 어댑터를 구성해야합니다. &lt;code&gt;config/dev.exs&lt;/code&gt; 파일을 열고 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="65030acee64dee332a18e0f3b18d92ed51549f12" translate="yes" xml:space="preserve">
          <source>Next, your LiveView picks up the events in &lt;code&gt;handle_event&lt;/code&gt; callbacks:</source>
          <target state="translated">다음으로 LiveView는 &lt;code&gt;handle_event&lt;/code&gt; 콜백 에서 이벤트를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="a896dc9ba46abff759ffb400c77bfa27b77903fa" translate="yes" xml:space="preserve">
          <source>Nil values cannot be converted to param.</source>
          <target state="translated">잘못된 값은 param으로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f34a9fdbd9c40572bc7066a9cfff7f9698e8f59" translate="yes" xml:space="preserve">
          <source>Node is an optional dependency. Phoenix will use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to compile static assets (JavaScript, CSS, etc), by default. Webpack uses the node package manager (npm) to install its dependencies, and npm requires node.js.</source>
          <target state="translated">노드는 선택적 종속성입니다. Phoenix는 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;기본적&lt;/a&gt; 으로 웹팩 을 사용 하여 정적 자산 (JavaScript, CSS 등)을 컴파일합니다. Webpack은 노드 패키지 관리자 (npm)를 사용하여 종속성을 설치하고 npm에는 node.js가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b9a49db0c673622cda20328cad7cb421cf567345" translate="yes" xml:space="preserve">
          <source>Node.JS for assets - which can be opt-out, especially if you are building APIs</source>
          <target state="translated">자산 용 Node.JS-특히 API를 빌드하는 경우 옵트 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa4730d226177989e4496055890c0f818ebc7f74" translate="yes" xml:space="preserve">
          <source>Note &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; is automatically invoked when dispatching to the endpoint, unless the connection has already been recycled.</source>
          <target state="translated">참고 연결이 이미 재활용되지 않은 경우 엔드 포인트로 디스패치 할 때 &lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt; 이 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d253471339920aa185df89b0a0e899c7ef41e1e6" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;:through&lt;/code&gt; associations are read-only. For example, you cannot use &lt;a href=&quot;ecto.changeset#cast_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.cast_assoc/3&lt;/code&gt;&lt;/a&gt; to modify through associations.</source>
          <target state="translated">참고 &lt;code&gt;:through&lt;/code&gt; 연결은 읽기 전용입니다. 예를 들어 &lt;a href=&quot;ecto.changeset#cast_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.cast_assoc/3&lt;/code&gt; &lt;/a&gt; 를 사용 하여 연결을 통해 수정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="664f45de417c50491eb1e076628f45820a670c71" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;@myself&lt;/code&gt; is not set for stateless components, as they cannot receive events.</source>
          <target state="translated">참고 &lt;code&gt;@myself&lt;/code&gt; 는 이벤트를받을 수 없기 때문에 상태 비 저장 구성 요소에 대해 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b112956c6e65a83bd10629287ef0dbca5ebebde7" translate="yes" xml:space="preserve">
          <source>Note developers are allowed to explicitly set the &lt;code&gt;:action&lt;/code&gt; field of a changeset to instruct Ecto how to act in certain situations. Let&amp;rsquo;s suppose that, if one of the associations has only empty fields, you want to ignore the entry altogether instead of showing an error. The changeset function could be written like this:</source>
          <target state="translated">참고 개발자는 특정 상황에서 행동하는 방법을 Ecto에 지시하기 위해 변경 세트의 &lt;code&gt;:action&lt;/code&gt; 필드 를 명시 적으로 설정할 수 있습니다. 연관 중 하나에 빈 필드 만있는 경우 오류를 표시하는 대신 항목을 모두 무시하려고한다고 가정하십시오. 변경 세트 기능은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64dd8974916f779632d015f550b5e558a6238beb" translate="yes" xml:space="preserve">
          <source>Note developers are allowed to explicitly set the &lt;code&gt;:action&lt;/code&gt; field of a changeset to instruct Ecto how to act in certain situations. Let's suppose that, if one of the associations has only empty fields, you want to ignore the entry altogether instead of showing an error. The changeset function could be written like this:</source>
          <target state="translated">개발자는 변경 집합의 &lt;code&gt;:action&lt;/code&gt; 필드 를 명시 적으로 설정하여 Ecto에게 특정 상황에서 작동하는 방법을 지시 할 수 있습니다. 연결 중 하나에 빈 필드 만있는 경우 오류를 표시하는 대신 항목을 모두 무시하려고한다고 가정합니다. 변경 집합 함수는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ef185830422b27144c6a55b55256bcde6d8d7a" translate="yes" xml:space="preserve">
          <source>Note only &lt;a href=&quot;#broadcast_from/3&quot;&gt;&lt;code&gt;broadcast_from/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#broadcast_from!/3&quot;&gt;&lt;code&gt;broadcast_from!/3&lt;/code&gt;&lt;/a&gt; are available in tests to avoid broadcast messages to be resent to the test process.</source>
          <target state="translated">참고 만 &lt;a href=&quot;#broadcast_from/3&quot;&gt; &lt;code&gt;broadcast_from/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#broadcast_from!/3&quot;&gt; &lt;code&gt;broadcast_from!/3&lt;/code&gt; 는&lt;/a&gt; 테스트 프로세스에 재전송 될 않도록 브로드 캐스트 메시지에 테스트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97965ab861bc886a42f97e1bc2e7904773682063" translate="yes" xml:space="preserve">
          <source>Note request headers are normalized to lowercase and response headers are expected to have lower-case keys.</source>
          <target state="translated">요청 헤더는 소문자로 정규화되며 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4111c64111b17828ae49d5ad8fca97b7202cf233" translate="yes" xml:space="preserve">
          <source>Note request headers are normalized to lowercase and response headers are expected to have lowercase keys.</source>
          <target state="translated">요청 헤더는 소문자로 정규화되며 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e09af1e7d2d9b5542e8d0620bc99a22794415214" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; validates the types in the &lt;code&gt;params&lt;/code&gt;, but not in the given &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 의 유효성을 검사에게의 유형 &lt;code&gt;params&lt;/code&gt; 주어진에 있지만 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5e2794cae483e352f9fee8b206c0fff6e92b09c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@live_action&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt; if no action is given on the route definition.</source>
          <target state="translated">참고 &lt;code&gt;@live_action&lt;/code&gt; 이 될 것입니다 &lt;code&gt;nil&lt;/code&gt; 아무런 조치 경로 정의에 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="ebcff7cb91be58ffbdfdaba340057dc3e4b4bd8d" translate="yes" xml:space="preserve">
          <source>Note that LiveViews are automatically configured to use a &quot;live.html.leex&quot; layout in this line:</source>
          <target state="translated">LiveView는 다음 줄에서 &quot;live.html.leex&quot;레이아웃을 사용하도록 자동으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="68692d25fe3a2f82a06be636549912678b27c223" translate="yes" xml:space="preserve">
          <source>Note that certain browsers (such as Google Chrome) will not accept a pushed resource if your certificate is not trusted. In the case of Chrome this means a valid cert with a SAN. See &lt;a href=&quot;https://www.chromestatus.com/feature/4981025180483584&quot;&gt;https://www.chromestatus.com/feature/4981025180483584&lt;/a&gt;</source>
          <target state="translated">특정 브라우저 (예 : Google Chrome)는 인증서를 신뢰할 수없는 경우 푸시 된 리소스를 허용하지 않습니다. Chrome의 경우 이는 SAN이있는 유효한 인증서를 의미합니다. 참조 &lt;a href=&quot;https://www.chromestatus.com/feature/4981025180483584&quot;&gt;https://www.chromestatus.com/feature/4981025180483584를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb865cd2bc7ad462289cb66fa61be39f36364e79" translate="yes" xml:space="preserve">
          <source>Note that certain browsers (such as Google Chrome) will not accept a pushed resource if your certificate is not trusted. In the case of Chrome this means a valid cert with a SAN. See https://www.chromestatus.com/feature/4981025180483584</source>
          <target state="translated">인증서를 신뢰할 수없는 경우 특정 브라우저 (예 : Chrome)는 푸시 된 리소스를 허용하지 않습니다. Chrome의 경우 이는 SAN이있는 유효한 인증서를 의미합니다. https://www.chromestatus.com/feature/4981025180483584 참조</target>
        </trans-unit>
        <trans-unit id="e3ad91ed34e7d6fb813fd7e54efb1b493704c193" translate="yes" xml:space="preserve">
          <source>Note that if the confirmation field is nil or missing, by default this does not add a validation error. You can specify that the confirmation field is required in the options (see below). Note &amp;ldquo;email_confirmation&amp;rdquo; does not need to be added as a virtual field in your schema.</source>
          <target state="translated">확인 필드가 nil이거나 누락 된 경우 기본적으로 유효성 검사 오류가 추가되지 않습니다. 옵션에 확인 필드가 필요하도록 지정할 수 있습니다 (아래 참조). 참고&amp;ldquo;email_confirmation&amp;rdquo;은 스키마에서 가상 필드로 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5efbfd3b086cca4455ed1b9cad10d37cb0fa3d8" translate="yes" xml:space="preserve">
          <source>Note that if the confirmation field is nil or missing, this does not add a validation error. You can specify that the confirmation parameter is required in the options (see below).</source>
          <target state="translated">확인 필드가 nil이거나 누락 된 경우 유효성 검사 오류가 추가되지 않습니다. 옵션에서 확인 매개 변수가 필수임을 지정할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a334815f24332fb80d8f770a7f663492be25e936" translate="yes" xml:space="preserve">
          <source>Note that if you want to load data into a non-embedded schema that was directly persisted into a given repository, then use &lt;a href=&quot;ecto.repo#c:load/2&quot;&gt;&lt;code&gt;Ecto.Repo.load/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 저장소에 직접 지속 된 비 포함 스키마로 데이터를로드하려면 &lt;a href=&quot;ecto.repo#c:load/2&quot;&gt; &lt;code&gt;Ecto.Repo.load/2&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="927a818a7b44dfa9ad2fb86b918794b0ea4d7393" translate="yes" xml:space="preserve">
          <source>Note that it is recommended to enable CSRFProtection whenever a session is used, even for JSON requests. For example, Chrome had a bug that allowed POST requests to be triggered with arbitrary content-type, making JSON exploitable. More info: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=490015&quot;&gt;https://bugs.chromium.org/p/chromium/issues/detail?id=490015&lt;/a&gt;</source>
          <target state="translated">JSON 요청의 경우에도 세션이 사용될 때마다 CSRFProtection을 활성화하는 것이 좋습니다. 예를 들어 Chrome에는 임의의 콘텐츠 유형으로 POST 요청이 트리거되도록 허용하는 버그가있어 JSON을 악용 할 수 있습니다. 추가 정보 : &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=490015&quot;&gt;https://bugs.chromium.org/p/chromium/issues/detail?id=490015&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f9ca5a11268558f4efa29c8efef8203870c05fd" translate="yes" xml:space="preserve">
          <source>Note that it is recommended to enable CSRFProtection whenever a session is used, even for JSON requests. For example, Chrome had a bug that allowed POST requests to be triggered with arbitrary content-type, making JSON exploitable. More info: https://bugs.chromium.org/p/chromium/issues/detail?id=490015</source>
          <target state="translated">JSON 요청의 경우에도 세션이 사용될 때마다 CSRFProtection을 사용하는 것이 좋습니다. 예를 들어 Chrome에는 POST 요청을 임의의 콘텐츠 유형으로 트리거하여 JSON을 활용할 수있는 버그가있었습니다. 자세한 정보 : https://bugs.chromium.org/p/chromium/issues/detail?id=490015</target>
        </trans-unit>
        <trans-unit id="865a623fddda8eeed1c887e0dc9637971ab24a2f" translate="yes" xml:space="preserve">
          <source>Note that nil can be cast to all primitive types as data stores allow nil to be set on any column.</source>
          <target state="translated">데이터 저장소에서 모든 열에 nil을 설정할 수 있으므로 nil은 모든 기본 유형으로 캐스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5aa08cebb53f27d657e8126e23b17cb250974fe" translate="yes" xml:space="preserve">
          <source>Note that options are specified as a keyword, but it is idiomatic to convert them to maps inside &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; for easier pattern matching in other callbacks.</source>
          <target state="translated">옵션은 키워드로 지정되지만 다른 콜백에서보다 쉬운 패턴 일치를 위해 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 내부의 맵으로 변환하는 것이 관용적 입니다.</target>
        </trans-unit>
        <trans-unit id="2e027bd4f398e45376ee727928f6c2291e8322c5" translate="yes" xml:space="preserve">
          <source>Note that pipelines themselves are plugs, so we can plug a pipeline inside another pipeline. For example, we could rewrite the &lt;code&gt;review_checks&lt;/code&gt; pipeline above to automatically invoke &lt;code&gt;browser&lt;/code&gt;, simplifying the downstream pipeline call:</source>
          <target state="translated">파이프 라인 자체는 플러그이므로 다른 파이프 라인 내부에 파이프 라인을 연결할 수 있습니다. 예를 들어, 우리는 다시 쓸 수 &lt;code&gt;review_checks&lt;/code&gt; 에 자동으로 호출에 위의 파이프 라인을 &lt;code&gt;browser&lt;/code&gt; 다운 스트림 파이프 라인 호출을 단순화 :</target>
        </trans-unit>
        <trans-unit id="2e8b8c6972e11192f70f9cf574047f3c6a1d2337" translate="yes" xml:space="preserve">
          <source>Note that reading environment variables in Mix config files only works when starting the application using Mix, e.g. in a development environment. In production, a different approach is needed for runtime configuration, but this is out of scope for the current document.</source>
          <target state="translated">Mix 구성 파일의 환경 변수 읽기는 Mix를 사용하여 애플리케이션을 시작할 때만 작동합니다 (예 : 개발 환경). 프로덕션에서는 런타임 구성을 위해 다른 접근 방식이 필요하지만 이는 현재 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="c8c6eb8d869ea49ffa84ebf25ae6c14dd441958f" translate="yes" xml:space="preserve">
          <source>Note that router pipelines are only invoked after a route is found. No plug is invoked in case no matches were found.</source>
          <target state="translated">라우터 파이프 라인은 경로를 찾은 후에 만 ​​호출됩니다. 일치하는 항목이없는 경우 플러그가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8963a0f3b0f13ffd27614bfb29db69e2fd1590e9" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;--no-deps-check&lt;/code&gt; flag cannot be used this way, because Mix needs to check dependencies to find &lt;code&gt;phx.server&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;--no-deps-check&lt;/code&gt; 믹스 찾을 종속성을 확인해야하기 때문에 플래그,이 방법을 사용할 수 없습니다 &lt;code&gt;phx.server&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="89c55fa6e3ecad499021fb85db24111d255d93a1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;join&lt;/code&gt; does not automatically wrap the fragment in parentheses, since some expressions require parens and others require no parens. Therefore, in cases such as common table expressions, you will have to explicitly wrap the fragment content in parens.</source>
          <target state="translated">일부 표현식에는 괄호가 필요하고 다른 표현식에는 괄호가 필요하지 않기 때문에 &lt;code&gt;join&lt;/code&gt; 은 조각을 괄호로 자동 랩핑하지 않습니다. 따라서 공통 테이블 표현식과 같은 경우 조각 컨텐츠를 명시 적으로 랩 단위로 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="4470bfdf005f63cfba3bb0b7fe138397db0876f9" translate="yes" xml:space="preserve">
          <source>Note that the choice between conditionally checking on the result of the &lt;code&gt;leave&lt;/code&gt; function with an &lt;code&gt;if&lt;/code&gt;, or simply asserting it returns &lt;code&gt;true&lt;/code&gt;, is completely up to you. If the likelihood of everyone leaving the organization at the same time is low, then you may as well treat it as an unexpected scenario. Although other developers will be more comfortable by explicitly handling those cases. In both scenarios, LiveView has you covered.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 를 사용하여 &lt;code&gt;leave&lt;/code&gt; 함수 의 결과를 조건부로 확인 하거나 단순히 &lt;code&gt;true&lt;/code&gt; 를 반환한다고 주장하는 선택 은 전적으로 귀하에게 달려 있습니다. 모든 사람이 동시에 조직을 떠날 가능성이 낮다면 예상치 못한 시나리오로 처리하는 것이 좋습니다. 다른 개발자는 이러한 경우를 명시 적으로 처리하는 것이 더 편안 할 것입니다. 두 시나리오 모두에서 LiveView가 다룹니다.</target>
        </trans-unit>
        <trans-unit id="31338e6d6e34d7fa0fe7f8546cf809c23e91cac0" translate="yes" xml:space="preserve">
          <source>Note that the length of a string is counted in graphemes by default. If using this validation to match a character limit of a database backend, it's likely that the limit ignores graphemes and limits the number of unicode characters. Then consider using the &lt;code&gt;:count&lt;/code&gt; option to limit the number of codepoints (&lt;code&gt;:codepoints&lt;/code&gt;), or limit the number of bytes (&lt;code&gt;:bytes&lt;/code&gt;).</source>
          <target state="translated">문자열의 길이는 기본적으로 자소로 계산됩니다. 이 유효성 검사를 사용하여 데이터베이스 백엔드의 문자 제한과 일치하는 경우 제한이 자소를 무시하고 유니 코드 문자 수를 제한 할 수 있습니다. 그런 다음 &lt;code&gt;:count&lt;/code&gt; 옵션을 사용하여 코드 포인트 수를 제한 하거나 ( &lt;code&gt;:codepoints&lt;/code&gt; ) 바이트 수를 제한합니다 ( &lt;code&gt;:bytes&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="102fb3069ea42c376728f7d160b27d82ce7dccc5" translate="yes" xml:space="preserve">
          <source>Note that the length of a string is counted in graphemes. If using this validation to match a character limit of a database backend, it&amp;rsquo;s likely that the limit ignores graphemes and limits the number of unicode characters. Then consider using the &lt;code&gt;:count&lt;/code&gt; option to limit the number of codepoints.</source>
          <target state="translated">문자열의 길이는 그래프로 계산됩니다. 이 유효성 검사를 사용하여 데이터베이스 백엔드의 문자 제한과 일치하는 경우 제한이 grapheme을 무시하고 유니 코드 문자 수를 제한 할 수 있습니다. 그런 다음 &lt;code&gt;:count&lt;/code&gt; 옵션을 사용하여 코드 포인트 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="5281d498d35200887f768cde6b913e0a30c4898a" translate="yes" xml:space="preserve">
          <source>Note that the name of the database table does not need to correlate to your module name. For example, if you are working with a legacy database, you can reference the table name when you define your schema:</source>
          <target state="translated">데이터베이스 테이블의 이름은 모듈 이름과 상관 될 필요가 없습니다. 예를 들어 레거시 데이터베이스를 사용하는 경우 스키마를 정의 할 때 테이블 이름을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e62db11ff5777fc8aaf6203f89bf84679fe8df" translate="yes" xml:space="preserve">
          <source>Note that the operations &lt;code&gt;order_by&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; of the current &lt;code&gt;query&lt;/code&gt; apply to the result of the set difference.</source>
          <target state="translated">현재 &lt;code&gt;query&lt;/code&gt; 의 &lt;code&gt;order_by&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 작업 이 설정된 차이의 결과에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e4be7313e1b3bfa4d99f77ae0697f5c5f0a3cbe" translate="yes" xml:space="preserve">
          <source>Note that the operations &lt;code&gt;order_by&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; of the current &lt;code&gt;query&lt;/code&gt; apply to the result of the union.</source>
          <target state="translated">현재 &lt;code&gt;query&lt;/code&gt; 의 &lt;code&gt;order_by&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 작업 은 공용체의 결과에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="265ecafe0db9cd4bf84fb9c15a5e4f8e89f3d0b4" translate="yes" xml:space="preserve">
          <source>Note that there is a potential race condition when both the certificate and the key need to be replaced at the same time: if the &lt;code&gt;:ssl&lt;/code&gt; application reloads one file before the other file is updated, the partial update can leave the HTTPS server with a mismatched private key. This can be avoiding by placing the private key in the same PEM file as the certificate, and omitting the &lt;code&gt;:keyfile&lt;/code&gt; option. This configuration allows atomic updates, and it works because &lt;code&gt;:ssl&lt;/code&gt; looks for a private key entry in the &lt;code&gt;:certfile&lt;/code&gt; PEM file if no &lt;code&gt;:key&lt;/code&gt; or &lt;code&gt;:keyfile&lt;/code&gt; option is specified.</source>
          <target state="translated">인증서와 키를 동시에 교체해야하는 경우 잠재적 경쟁 조건이 있습니다 . 다른 파일이 업데이트되기 전에 &lt;code&gt;:ssl&lt;/code&gt; 애플리케이션이 한 파일을 다시로드하면 부분 업데이트로 인해 HTTPS 서버가 일치하지 않을 수 있습니다. 개인 키. 인증서와 동일한 PEM 파일에 개인 키를 배치하고 &lt;code&gt;:keyfile&lt;/code&gt; 옵션을 생략하면이를 방지 할 수 있습니다 . 이 구성은 원자 적 업데이트를 허용하며 &lt;code&gt;:key&lt;/code&gt; 또는 &lt;code&gt;:keyfile&lt;/code&gt; 옵션이 지정 되지 않은 경우 &lt;code&gt;:ssl&lt;/code&gt; 이 &lt;code&gt;:certfile&lt;/code&gt; PEM 파일 에서 개인 키 항목을 찾기 때문에 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a1db4174eadd17542b35c50d0fb4d9e6203b4bb9" translate="yes" xml:space="preserve">
          <source>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt; after this function if you want to halt the plug pipeline.</source>
          <target state="translated">이 기능은 연결을 중단하지 않으므로 후속 플러그가 다른 응답을 보내려고하면 오류가 발생합니다. 플러그 파이프 라인을 정지 시키려면이 기능 뒤에 &lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1aa34ade3db4517e37b549bb5b9fe2c30cba6eb" translate="yes" xml:space="preserve">
          <source>Note that this function expects a reversed pipeline (with the last plug that has to be called coming first in the pipeline).</source>
          <target state="translated">이 함수는 파이프 라인에서 역으로 연결되는 파이프 라인 (마지막으로 플러그를 호출해야 함)을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="22d6138cf86c2b7e8e7ca90beb6e039c9b8c93fa" translate="yes" xml:space="preserve">
          <source>Note that this function must be invoked using window function syntax.</source>
          <target state="translated">이 함수는 창 함수 구문을 사용하여 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2aa7afcfb46e1de53ed7d8c39faeed9fcd5793f" translate="yes" xml:space="preserve">
          <source>Note that, even if &lt;a href=&quot;#clear_session/1&quot;&gt;&lt;code&gt;clear_session/1&lt;/code&gt;&lt;/a&gt; is used, the session is still sent to the client. If the session should be effectively &lt;em&gt;dropped&lt;/em&gt;, &lt;a href=&quot;#configure_session/2&quot;&gt;&lt;code&gt;configure_session/2&lt;/code&gt;&lt;/a&gt; should be used with the &lt;code&gt;:drop&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우에도, 그 주 &lt;a href=&quot;#clear_session/1&quot;&gt; &lt;code&gt;clear_session/1&lt;/code&gt; &lt;/a&gt; 사용되며, 세션이 여전히 클라이언트로 전송됩니다. 세션이 효율적으로 할 필요가있는 경우 &lt;em&gt;하락&lt;/em&gt; , &lt;a href=&quot;#configure_session/2&quot;&gt; &lt;code&gt;configure_session/2&lt;/code&gt; 는&lt;/a&gt; 함께 사용되어야 &lt;code&gt;:drop&lt;/code&gt; 에 대한 옵션을 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b30fab2fcc2c2f84b880c883b28132676826b5d" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:id&lt;/code&gt; won't necessarily be used as the DOM ID. That's up to the component. However, note that the &lt;code&gt;:id&lt;/code&gt; has a special meaning: whenever an &lt;code&gt;:id&lt;/code&gt; is given, the component becomes stateful. Otherwise, &lt;code&gt;:id&lt;/code&gt; is always set to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">메모 &lt;code&gt;:id&lt;/code&gt; 반드시 DOM ID로 사용되지 않습니다. 그것은 구성 요소에 달려 있습니다. 그러나 &lt;code&gt;:id&lt;/code&gt; 에는 특별한 의미가 있습니다. &lt;code&gt;:id&lt;/code&gt; 가 주어질 때마다 구성 요소는 상태 저장이됩니다. 그렇지 않으면 &lt;code&gt;:id&lt;/code&gt; 는 항상 &lt;code&gt;nil&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff72dbc4d36b18c5a792f9db652f37f620c451b5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:tags&lt;/code&gt; and &lt;code&gt;:tag_values&lt;/code&gt; options can be applied to all &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">메모 &lt;code&gt;:tags&lt;/code&gt; 과 &lt;code&gt;:tag_values&lt;/code&gt; 의 옵션은 모두에 적용 할 수 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt; &lt;code&gt;Telemetry.Metrics&lt;/code&gt; 의&lt;/a&gt; 유형.</target>
        </trans-unit>
        <trans-unit id="ac7ecdc2090cf427dae97a258496c93dd4a69e03" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;@inner_content&lt;/code&gt; assign is also passed to &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; along all other assigns. So if you have a custom &lt;code&gt;update/2&lt;/code&gt; implementation, make sure to assign it to the socket like so:</source>
          <target state="translated">참고 &lt;code&gt;@inner_content&lt;/code&gt; 의 할당도에 전달 &lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt; 다른 모든 양수인 함께. 따라서 사용자 정의 &lt;code&gt;update/2&lt;/code&gt; 구현 이있는 경우 다음 과 같이 소켓에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="0938fe997a4530ce1e67083c7d403be7f29aca70" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;type: EncodedId&lt;/code&gt; option given to &lt;code&gt;belongs_to&lt;/code&gt; in the &lt;code&gt;BlogPost&lt;/code&gt; schema. By default, Ecto will treat associations as if their keys were &lt;code&gt;:integer&lt;/code&gt;s. Our primary keys are a custom type, so when Ecto tries to cast those ids, it will fail.</source>
          <target state="translated">&lt;code&gt;BlogPost&lt;/code&gt; 스키마의 &lt;code&gt;belongs_to&lt;/code&gt; 에 지정된 &lt;code&gt;type: EncodedId&lt;/code&gt; 옵션에 유의하십시오 . 기본적으로 Ecto는 연결을 키가 &lt;code&gt;:integer&lt;/code&gt; 인 것처럼 취급 합니다. 우리의 기본 키는 사용자 지정 유형이므로 Ecto가 해당 ID를 캐스팅하려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1f569f104132819e886ef5eb4d4340fa57f9b610" translate="yes" xml:space="preserve">
          <source>Note the examples in this module use &lt;code&gt;safe_to_string/1&lt;/code&gt; imported from &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; for readability.</source>
          <target state="translated">이 모듈 사용의 예를 참고 &lt;code&gt;safe_to_string/1&lt;/code&gt; 에서 수입 &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc58a84961ba4cd50b3fb3ae2c631ed8261f2490" translate="yes" xml:space="preserve">
          <source>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈의 기능은 문서화 목적으로 존재하며 직접 호출 할 필요는 없습니다. 또한 자체 매크로를 정의하고 Ecto 쿼리에서 사용할 수 있습니다 ( &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; 에&lt;/a&gt; 대한 문서 참조 ).</target>
        </trans-unit>
        <trans-unit id="e648921374e8289cdb288e5911e06388b2d9efae" translate="yes" xml:space="preserve">
          <source>Note the parameters given to &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; are the same as the ones given to &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;. So how do you decide which callback to use to load data? Generally speaking, data should always be loaded on &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;, since &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is invoked once per LiveView life-cycle. Only the params you expect to be changed via &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; must be loaded on &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 매개 변수 참고 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt; 에 주어진 것과 동일 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; . 그렇다면 데이터를로드하는 데 사용할 콜백을 어떻게 결정합니까? 일반적으로 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 는 LiveView 수명주기마다 한 번씩 호출 되므로 데이터는 항상 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 에로드되어야 합니다. &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; &lt;/a&gt; 를 통해 변경 될 것으로 예상되는 매개 변수 만 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt; 에로드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d247c03df0b09b5db12eb983aa276db8485ec040" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;get(&quot;/&quot;)&lt;/code&gt; following &lt;code&gt;bypass_through&lt;/code&gt; in the examples below. To execute the plug pipelines, you must issue a request against the router. Most often, you can simply send a GET request against the root path, but you may also specify a different method or path which your pipelines may operate against.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;bypass_through&lt;/code&gt; 다음 에 &lt;code&gt;get(&quot;/&quot;)&lt;/code&gt; 을 사용 합니다. 플러그 파이프 라인을 실행하려면 라우터에 대해 요청을 발행해야합니다. 대부분의 경우 루트 경로에 대해 간단히 GET 요청을 보낼 수 있지만 파이프 라인이 작동 할 수있는 다른 방법이나 경로를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="632246044261dd2ecd26ea1bba426739ad1abad9" translate="yes" xml:space="preserve">
          <source>Note the values above are distinctly different from the values you would pass to &lt;code&gt;where&lt;/code&gt; when building a query. For example, if you attempt to build a query such as</source>
          <target state="translated">위의 값은 당신이 통과 할 값에서 분명히 다른주의 &lt;code&gt;where&lt;/code&gt; 쿼리를 작성하는 경우. 예를 들어, 다음과 같은 쿼리를 작성하려는 경우</target>
        </trans-unit>
        <trans-unit id="b228dbd46b006a98f7e46a9644e89c371685f474" translate="yes" xml:space="preserve">
          <source>Note the variables &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; can be named whatever you like as they have no importance in the query sent to the database.</source>
          <target state="translated">변수 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;o&lt;/code&gt; 는 데이터베이스로 전송 된 쿼리에서 중요하지 않으므로 원하는대로 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25884c18abd998c05bd3862237637e7160ff32f8" translate="yes" xml:space="preserve">
          <source>Note these guides are not a step-by-step introduction to Phoenix. If you want a more structured approach to learning the framework, we have a large community and many books, courses, and screencasts available. See &lt;a href=&quot;community&quot;&gt;our community page&lt;/a&gt; for a complete list.</source>
          <target state="translated">이 가이드는 Phoenix에 대한 단계별 소개가 아닙니다. 프레임 워크 학습에보다 체계적인 접근 방식을 원한다면 대규모 커뮤니티와 많은 책, 코스 및 스크린 캐스트를 사용할 수 있습니다. 전체 목록은 &lt;a href=&quot;community&quot;&gt;커뮤니티 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40e3f4e9761b3a3423b7214331185e6ab2fd1d53" translate="yes" xml:space="preserve">
          <source>Note this function is not required to return Ecto primitive types, the type is only required to be known by the adapter.</source>
          <target state="translated">이 함수는 Ecto 기본 유형을 리턴하는 데 필요하지 않으며 유형은 어댑터 만 알면됩니다.</target>
        </trans-unit>
        <trans-unit id="a5e2a4c0349fb080a5b762698584cd6cce120033" translate="yes" xml:space="preserve">
          <source>Note this plug measures the time between its invocation until a response is sent. The &lt;code&gt;:stop&lt;/code&gt; event is not guaranteed to be emitted in all error cases, so this Plug cannot be used as a Telemetry span.</source>
          <target state="translated">이 플러그는 응답이 전송 될 때까지 호출 사이의 시간을 측정합니다. &lt;code&gt;:stop&lt;/code&gt; 이 플러그는 원격 측정 범위로 사용할 수 없도록 이벤트는, 모든 오류의 경우에 방출 할 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="768fea9dafafd1db30554f9ed42bcd9781a114f2" translate="yes" xml:space="preserve">
          <source>Note this validation only checks the parameter itself is true, never the field in the schema. That's because acceptance parameters do not need to be persisted, as by definition they would always be stored as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 유효성 검사는 스키마의 필드가 아닌 매개 변수 자체 만 확인합니다. 그 이유는 허용 매개 변수가 지속될 필요가 없기 때문입니다. 정의에 따라 항상 &lt;code&gt;true&lt;/code&gt; 로 저장되기 때문 입니다 .</target>
        </trans-unit>
        <trans-unit id="44d0d702486d95344749a5a28edcb2d5287109a7" translate="yes" xml:space="preserve">
          <source>Note though it doesn&amp;rsquo;t happen with &lt;code&gt;belongs_to&lt;/code&gt; cases, as the key is often the primary key and such is usually generated dynamically:</source>
          <target state="translated">키가 기본 키이고 일반적으로 동적으로 생성되기 때문에 &lt;code&gt;belongs_to&lt;/code&gt; 경우에는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e4efeadfa678193748db0eeb5a1435c0980f95e1" translate="yes" xml:space="preserve">
          <source>Note though it doesn't happen with &lt;code&gt;belongs_to&lt;/code&gt; cases, as the key is often the primary key and such is usually generated dynamically:</source>
          <target state="translated">이 키는 종종 기본 키이고 일반적으로 동적으로 생성되므로 &lt;code&gt;belongs_to&lt;/code&gt; 케이스에서는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba415bb15311bf3708d138233fdceb01a40ceeb0" translate="yes" xml:space="preserve">
          <source>Note to learn more about &lt;code&gt;mix&lt;/code&gt;, you can read Elixir's official &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Introduction to Mix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mix&lt;/code&gt; 에 대해 자세히 알아 보려면 Elixir의 공식 &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix 소개를&lt;/a&gt; 읽어보세요 .</target>
        </trans-unit>
        <trans-unit id="a0c8012cf69a9aa8fd08e9cac331449c4edc0e4d" translate="yes" xml:space="preserve">
          <source>Note you only pass &lt;code&gt;builder_opts()&lt;/code&gt; to &lt;strong&gt;function plugs&lt;/strong&gt;. You cannot use &lt;code&gt;builder_opts()&lt;/code&gt; with module plugs because their options are evaluated at compile time. If you need to pass &lt;code&gt;builder_opts()&lt;/code&gt; to a module plug, you can wrap the module plug in function. To be precise, do not do this:</source>
          <target state="translated">&lt;strong&gt;함수 plugs&lt;/strong&gt; 에만 &lt;code&gt;builder_opts()&lt;/code&gt; 를 전달하십시오 . 옵션은 컴파일시 평가되므로 모듈 플러그와 함께 &lt;code&gt;builder_opts()&lt;/code&gt; 를 사용할 수 없습니다 . &lt;code&gt;builder_opts()&lt;/code&gt; 를 모듈 플러그 에 전달해야하는 경우 모듈 플러그인 함수를 랩핑 할 수 있습니다. 정확하게하기 위해, 이렇게하지 마십시오 :&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d156d5fce0cbfece1b0207b4a0759bbeeede9c04" translate="yes" xml:space="preserve">
          <source>Note, however, that &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always expects all data currently associated to be given. In both examples above, if the changeset has any other comment besides the comment with &lt;code&gt;id&lt;/code&gt; equal to 1, all of them will be considered as replaced, invoking the relevant &lt;code&gt;:on_replace&lt;/code&gt; callback which may potentially remove the data. In other words, if only a comment with a id equal to 1 is given, it will be the only one kept. Therefore, &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always works with the whole data, which may be undesired in some cases. Let&amp;rsquo;s see an example.</source>
          <target state="translated">그러나 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 는&lt;/a&gt; 항상 현재 연결된 모든 데이터가 제공 될 것으로 예상합니다. 위의 두 예에서 변경 세트에 &lt;code&gt;id&lt;/code&gt; 가 1 인 주석 외에 다른 주석이있는 경우 , 모든 데이터는 대체 된 것으로 간주되어 잠재적으로 데이터를 제거 할 수있는 관련 &lt;code&gt;:on_replace&lt;/code&gt; 콜백을 호출합니다 . 다시 말해, id가 1 인 주석 만 주면 유일하게 유지됩니다. 따라서 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 는&lt;/a&gt; 항상 전체 데이터와 함께 작동하며 경우에 따라 바람직하지 않을 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="03326181e9e6469d6fde59fa5ae844a24dd2b08d" translate="yes" xml:space="preserve">
          <source>Note, however, that we don&amp;rsquo;t advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="translated">그러나 다른 엔드 포인트로 전달하는 것은 권장하지 않습니다. 앱과 전달 된 엔드 포인트에서 정의한 플러그가 두 번 호출되어 오류가 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="84edd7926f36fd307fbe5444a18859614c0a29c3" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#insert_or_update/4&quot;&gt;&lt;code&gt;insert_or_update/4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt; variants that accept a function are not performing such checks since the functions are executed after the transaction has started.</source>
          <target state="translated">참고 : 함수를 승인하는 &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#insert_or_update/4&quot;&gt; &lt;code&gt;insert_or_update/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt; 변형은 트랜잭션이 시작된 후에 함수가 실행되므로 이러한 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8fb0f81785b06a4c4492cb88879c8170b3b1cfb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nil&lt;/code&gt; values are always bypassed and cannot be handled by custom types.</source>
          <target state="translated">참고 : &lt;code&gt;nil&lt;/code&gt; 값은 항상 무시되며 사용자 정의 유형으로 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="8672a8dd0935041d8e4fc39bcadf10def2eb2cf8" translate="yes" xml:space="preserve">
          <source>Note: A resource may also be split over distinct contexts (such as &lt;code&gt;Accounts.User&lt;/code&gt; and &lt;code&gt;Payments.User&lt;/code&gt;).</source>
          <target state="translated">Note: A resource may also be split over distinct contexts (such as &lt;code&gt;Accounts.User&lt;/code&gt; and &lt;code&gt;Payments.User&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2321eec0b96a1b0a8d48f5c647ec9c024006ef8" translate="yes" xml:space="preserve">
          <source>Note: A resource may also be split over distinct contexts (such as Accounts.User and Payments.User).</source>
          <target state="translated">Note: A resource may also be split over distinct contexts (such as Accounts.User and Payments.User).</target>
        </trans-unit>
        <trans-unit id="f875f83241d739a46a249ecd55560587b8950f86" translate="yes" xml:space="preserve">
          <source>Note: If we need to namespace our resource we can simply namespace the first argument of the generator.</source>
          <target state="translated">참고 : 리소스에 네임 스페이스를 지정해야하는 경우 생성기의 첫 번째 인수에 네임 스페이스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6992d7daa453bdc96355aacd0f9b20e0dcd025" translate="yes" xml:space="preserve">
          <source>Note: This feature is not supported with the Cowboy 1 adapter.</source>
          <target state="translated">Note: This feature is not supported with the Cowboy 1 adapter.</target>
        </trans-unit>
        <trans-unit id="92f584b5b3b5e0f483d9372fb5980926abc58fe1" translate="yes" xml:space="preserve">
          <source>Note: To connect from a native app be sure to either have the native app set an origin or allow any origin via &lt;code&gt;check_origin: false&lt;/code&gt;</source>
          <target state="translated">참고 : 기본 앱에서 연결하려면 기본 앱이 오리진을 설정하거나 &lt;code&gt;check_origin: false&lt;/code&gt; 통해 오리진을 허용해야합니다 . false</target>
        </trans-unit>
        <trans-unit id="5d2faaeafc8d7583ddaeea652374be673818a29e" translate="yes" xml:space="preserve">
          <source>Note: Using &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; imports &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;, so shortening the call to &lt;code&gt;assign/3&lt;/code&gt; works just fine.</source>
          <target state="translated">참고 : 사용 &lt;a href=&quot;phoenix.controller&quot;&gt; &lt;code&gt;Phoenix.Controller&lt;/code&gt; 의&lt;/a&gt; 수입 &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 을&lt;/a&gt; 이렇게 호출 단축, &lt;code&gt;assign/3&lt;/code&gt; 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c0602c670a5058d842da446252321e021ec760a5" translate="yes" xml:space="preserve">
          <source>Note: Using an atom as the template name also works &lt;code&gt;render(conn, :index)&lt;/code&gt;. In these cases, the template will be chosen based off the Accept headers, e.g. &lt;code&gt;&quot;index.html&quot;&lt;/code&gt; or &lt;code&gt;&quot;index.json&quot;&lt;/code&gt;.</source>
          <target state="translated">참고 : 템플릿 이름으로 atom을 사용하면 &lt;code&gt;render(conn, :index)&lt;/code&gt; 도 작동합니다 . 이 경우 템플릿은 Accept 헤더 (예 : &lt;code&gt;&quot;index.html&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; )를 기반으로 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e0cedd6dc20afb2d16bf09ab3ad81b667676b33" translate="yes" xml:space="preserve">
          <source>Note: We can run any of the tasks above with the &lt;code&gt;--no-start&lt;/code&gt; flag to execute the task without starting the application.</source>
          <target state="translated">참고 : &lt;code&gt;--no-start&lt;/code&gt; 플래그를 사용하여 위의 모든 작업을 실행하여 응용 프로그램을 시작하지 않고 작업을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed5fa898ef97e997d80bc3d7716844d2f829c9d" translate="yes" xml:space="preserve">
          <source>Note: We can specify a different output folder where &lt;a href=&quot;mix.tasks.phx.digest&quot;&gt;&lt;code&gt;mix phx.digest&lt;/code&gt;&lt;/a&gt; will put processed files. The first argument is the path where the static files are located.</source>
          <target state="translated">참고 : &lt;a href=&quot;mix.tasks.phx.digest&quot;&gt; &lt;code&gt;mix phx.digest&lt;/code&gt; &lt;/a&gt; 가 처리 된 파일을 저장할 다른 출력 폴더를 지정할 수 있습니다. 첫 번째 인수는 정적 파일이있는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="a101d6600fc3c6ea9aba53e128dc0a3eae089756" translate="yes" xml:space="preserve">
          <source>Note: at the time of writing, Erlang/OTP does not support keys encrypted with AES-256. The OpenSSL command in the previous paragraph can also be used to convert an AES-256 encrypted key to AES-128.</source>
          <target state="translated">참고 : 작성 당시 Erlang / OTP는 AES-256으로 암호화 된 키를 지원하지 않습니다. 이전 단락의 OpenSSL 명령을 사용하여 AES-256 암호화 키를 AES-128로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6a39504b62b134ed4740ba710ed8c01492d9839" translate="yes" xml:space="preserve">
          <source>Note: building the association does not consider the query filters. For example, if the given query requires the active field of the associated records to be true, building such association won&amp;rsquo;t automatically set the active field to true.</source>
          <target state="translated">참고 : 연결을 구축 할 때는 쿼리 필터가 고려되지 않습니다. 예를 들어, 주어진 쿼리에서 연관된 레코드의 활성 필드가 true 여야하는 경우 이러한 연관을 빌드하면 활성 필드가 자동으로 true로 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6b5dd905f7d96e2f31d933ea099fd9d2d363705" translate="yes" xml:space="preserve">
          <source>Note: if this is the first time you are running this command, Phoenix may also ask to install Rebar. Go ahead with the installation as Rebar is used to build Erlang packages.</source>
          <target state="translated">참고 :이 명령을 처음 실행하는 경우 Phoenix는 Rebar를 설치하도록 요청할 수도 있습니다. Rebar는 Erlang 패키지를 빌드하는 데 사용되므로 설치를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="1531c2b951684d7dd194abe46d0ec49804de1e15" translate="yes" xml:space="preserve">
          <source>Note: if you reconfigure HTTP options in &lt;code&gt;MyAppWeb.Endpoint.init/1&lt;/code&gt;, your dispatch options set in mix config will be overwritten.</source>
          <target state="translated">참고 : &lt;code&gt;MyAppWeb.Endpoint.init/1&lt;/code&gt; 에서 HTTP 옵션을 재구성하면 혼합 구성에 설정된 디스패치 옵션을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="96479eb762012bbd4afde3ac81bb6af80f36572a" translate="yes" xml:space="preserve">
          <source>Note: keep in mind operations like limit and offset in the preload query will affect the whole result set and not each association. For example, the query below:</source>
          <target state="translated">참고 : 사전로드 조회의 한계 및 오프셋과 같은 조작은 각 연관이 아니라 전체 결과 세트에 영향을 미칩니다. 예를 들어 아래 쿼리는</target>
        </trans-unit>
        <trans-unit id="76294b367946455fb32e1d4f7027b048f95d6b60" translate="yes" xml:space="preserve">
          <source>Note: the caller must be responsible for preventing duplicate subscriptions. After calling &lt;code&gt;subscribe/1&lt;/code&gt; from your endpoint, the same flow applies to handling regular Elixir messages within your channel. Most often, you&amp;rsquo;ll simply relay the &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; event and payload:</source>
          <target state="translated">참고 : 호출자는 중복 구독을 방지해야합니다. 엔드 포인트에서 &lt;code&gt;subscribe/1&lt;/code&gt; 을 호출 한 후 동일한 플로우가 채널 내 일반 Elixir 메시지 처리에 적용됩니다. 대부분의 경우 &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; 이벤트 및 페이로드를 간단히 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="9b2ea0624d5a64b95793834377d49f315a3af4b1" translate="yes" xml:space="preserve">
          <source>Note: the caller must be responsible for preventing duplicate subscriptions. After calling &lt;code&gt;subscribe/1&lt;/code&gt; from your endpoint, the same flow applies to handling regular Elixir messages within your channel. Most often, you'll simply relay the &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; event and payload:</source>
          <target state="translated">Note: the caller must be responsible for preventing duplicate subscriptions. After calling &lt;code&gt;subscribe/1&lt;/code&gt; from your endpoint, the same flow applies to handling regular Elixir messages within your channel. Most often, you'll simply relay the &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; event and payload:</target>
        </trans-unit>
        <trans-unit id="5623011dc15dc83409628fd086df7323d6d776b6" translate="yes" xml:space="preserve">
          <source>Note: to start the endpoint without using this mix task you must set &lt;code&gt;server: true&lt;/code&gt; in your &lt;a href=&quot;phoenix.endpoint&quot;&gt;&lt;code&gt;Phoenix.Endpoint&lt;/code&gt;&lt;/a&gt; configuration.</source>
          <target state="translated">Note: to start the endpoint without using this mix task you must set &lt;code&gt;server: true&lt;/code&gt; in your &lt;a href=&quot;phoenix.endpoint&quot;&gt; &lt;code&gt;Phoenix.Endpoint&lt;/code&gt; &lt;/a&gt; configuration.</target>
        </trans-unit>
        <trans-unit id="685be153b912c76b172990dcf41bb1e03e10e4d6" translate="yes" xml:space="preserve">
          <source>Notice &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;&lt;em&gt;does not&lt;/em&gt; catch errors, as errors should still propagate so that the Elixir process finishes with the proper reason. This module does not perform any logging either, as all logging is done by the web server handler.</source>
          <target state="translated">Notice &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;&lt;em&gt;does not&lt;/em&gt; catch errors, as errors should still propagate so that the Elixir process finishes with the proper reason. This module does not perform any logging either, as all logging is done by the web server handler.</target>
        </trans-unit>
        <trans-unit id="c4b9538483539a5364e06b2c7a530ca3c54f9268" translate="yes" xml:space="preserve">
          <source>Notice &lt;a href=&quot;#leave/1&quot;&gt;&lt;code&gt;leave/1&lt;/code&gt;&lt;/a&gt; is async, so it will also return a reference which you can use to check for a reply:</source>
          <target state="translated">&lt;a href=&quot;#leave/1&quot;&gt; &lt;code&gt;leave/1&lt;/code&gt; &lt;/a&gt; 은 비동기이므로 통지 를 확인하는 데 사용할 수있는 참조도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98084f9098a6d8c6cb716517ef19fc373e412f0f" translate="yes" xml:space="preserve">
          <source>Notice &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;&lt;em&gt;does not&lt;/em&gt; catch errors, as errors should still propagate so that the Elixir process finishes with the proper reason. This module does not perform any logging either, as all logging is done by the web server handler.</source>
          <target state="translated">주의 사항 Elixir 프로세스가 적절한 이유로 완료되도록 오류가 계속 전파되므로 &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 는&lt;/em&gt; 오류를 포착 &lt;em&gt;하지 않습니다&lt;/em&gt; . 웹 서버 핸들러가 모든 로깅을 수행하므로이 모듈은 로깅을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eb5ae0d39953702ed3cb571e939efbbe0729ac9" translate="yes" xml:space="preserve">
          <source>Notice all times are stored in native unit. You must convert them to the proper unit by using &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; before logging.</source>
          <target state="translated">모든 시간은 기본 단위로 저장됩니다. 로깅하기 전에 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 을 사용하여 적절한 단위로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fe0e069c522cae7859b146daed2272539487a97" translate="yes" xml:space="preserve">
          <source>Notice event and payload are patterns. This means one can write:</source>
          <target state="translated">공지 이벤트 및 페이로드는 패턴입니다. 이것은 다음과 같이 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="72220b90f4888ee786b86cf44708d137f090618e" translate="yes" xml:space="preserve">
          <source>Notice how just a few steps of authentication and authorization require complicated nesting and duplication? Let's improve this with a couple of plugs.</source>
          <target state="translated">몇 단계의 인증 및 권한 부여만으로 복잡한 중첩 및 복제가 필요하다는 것을 알 수 있습니까? 몇 개의 플러그로 이것을 개선해 봅시다.</target>
        </trans-unit>
        <trans-unit id="bb3714a1aa3f5a3dbd4b393e762b28464d76ce1a" translate="yes" xml:space="preserve">
          <source>Notice how the storage (repository) and the data are decoupled. This provides two main benefits:</source>
          <target state="translated">스토리지 (리포지토리)와 데이터가 어떻게 분리되어 있는지 확인합니다. 이것은 두 가지 주요 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f3467fef009ee169e97de38cc7f6d36db63b68c" translate="yes" xml:space="preserve">
          <source>Notice status and payload are patterns. This means one can write:</source>
          <target state="translated">통지 상태 및 페이로드는 패턴입니다. 이것은 다음과 같이 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="88c1995b04b32687a874e0104e22bb1f3f7cc8a7" translate="yes" xml:space="preserve">
          <source>Notice that &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; displays the text we put into the &lt;code&gt;@shortdoc&lt;/code&gt; along with the name of our task.</source>
          <target state="translated">공지 사항이 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 표시 우리가 넣어 텍스트 &lt;code&gt;@shortdoc&lt;/code&gt; 우리 작업의 이름과 함께.</target>
        </trans-unit>
        <trans-unit id="30ca448ada7803d59a47b42236252fa82c814916" translate="yes" xml:space="preserve">
          <source>Notice that in order to render JSON data, we don&amp;rsquo;t need to explicitly return a JSON string! Instead, we just return data that is encodable to JSON.</source>
          <target state="translated">JSON 데이터를 렌더링하기 위해 명시 적으로 JSON 문자열을 반환 할 필요는 없습니다. 대신 JSON으로 인코딩 가능한 데이터 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="140699776984319f7ba5d59cf6702075bae951cc" translate="yes" xml:space="preserve">
          <source>Notice that in order to render JSON data, we don't need to explicitly return a JSON string! Instead, we just return data that is encodable to JSON.</source>
          <target state="translated">Notice that in order to render JSON data, we don't need to explicitly return a JSON string! Instead, we just return data that is encodable to JSON.</target>
        </trans-unit>
        <trans-unit id="96a6890472ab6f7e194e48a22a74e5b41e69b7e3" translate="yes" xml:space="preserve">
          <source>Notice that our &lt;code&gt;random_key&lt;/code&gt; and &lt;code&gt;random_value&lt;/code&gt; have been removed from the final changeset. Changesets allow us to cast external data, such as user input on a web form or data from a CSV file into valid data into our system. Invalid parameters will be stripped and bad data that is unable to be cast according to our schema will be highlighted in the changeset errors.</source>
          <target state="translated">우리 것을 알 수 &lt;code&gt;random_key&lt;/code&gt; 및 &lt;code&gt;random_value&lt;/code&gt; 가 최종 변경 집합에서 제거되었습니다. 변경 세트를 사용하면 웹 양식의 사용자 입력 또는 CSV 파일의 데이터와 같은 외부 데이터를 유효한 데이터로 시스템에 캐스팅 할 수 있습니다. 잘못된 매개 변수는 제거되고 스키마에 따라 캐스트 할 수없는 잘못된 데이터는 변경 집합 오류에서 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0db40361209b6bb85131412727c6434f6320058c" translate="yes" xml:space="preserve">
          <source>Notice that the first param is just one of the unique index fields, this will be used as the error key to the changeset errors keyword list. For example, the above &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; would generate something like:</source>
          <target state="translated">첫 번째 매개 변수는 고유 색인 필드 중 하나이며 변경 세트 오류 키워드 목록의 오류 키로 사용됩니다. 예를 들어 위의 &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="69e1758b65f3318d8330166efc152f9b61cfbffd" translate="yes" xml:space="preserve">
          <source>Notice that the migration's filename begins with a string representation of the date and time the file was created.</source>
          <target state="translated">마이그레이션의 파일 이름은 파일이 생성 된 날짜 및 시간의 문자열 표현으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="774c31591bfa885ea023024d2e74e24ae0bb915b" translate="yes" xml:space="preserve">
          <source>Notice that the redirect function takes &lt;code&gt;conn&lt;/code&gt; as well as a string representing a relative path within our application. For security reasons, the &lt;code&gt;:to&lt;/code&gt; helper can only redirect for paths within your application. If you want to redirect to a fully-qualified path or an external URL, you should use &lt;code&gt;:external&lt;/code&gt; instead:</source>
          <target state="translated">리디렉션 함수는 응용 프로그램 내에서 상대 경로를 나타내는 문자열과 &lt;code&gt;conn&lt;/code&gt; 을 사용합니다. 보안상의 이유로 &lt;code&gt;:to&lt;/code&gt; 도우미는 애플리케이션 내의 경로에 대해서만 리디렉션 할 수 있습니다. 정규화 된 경로 또는 외부 URL로 리디렉션하려면 대신 : &lt;code&gt;:external&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba780763f477f0a8a7300d41764c71cab13e57f" translate="yes" xml:space="preserve">
          <source>Notice that there is a single function &lt;code&gt;change/0&lt;/code&gt; which will handle both forward migrations and rollbacks. We'll define the schema changes that we want using ecto's handy dsl, and ecto will figure out what to do depending on whether we are rolling forward or rolling back. Very nice indeed.</source>
          <target state="translated">포워드 마이그레이션과 롤백을 모두 처리 하는 단일 함수 &lt;code&gt;change/0&lt;/code&gt; 이 있습니다. ecto의 편리한 dsl을 사용하여 원하는 스키마 변경을 정의하고 ecto는 롤 포워드 또는 롤백 여부에 따라 수행 할 작업을 파악합니다. 참으로 아주 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0f46615ba0f0240d4d135f932cd85f058940008" translate="yes" xml:space="preserve">
          <source>Notice that this function returns the inner representation of a template. If you want the encoded template as a result, use &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Notice that this function returns the inner representation of a template. If you want the encoded template as a result, use &lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="5bef53f93af6f3a3e82f329166c0f809a1265a4b" translate="yes" xml:space="preserve">
          <source>Notice that this task has updated &lt;code&gt;config/config.exs&lt;/code&gt;. If we take a look, we'll see this extra configuration block for our new repo.</source>
          <target state="translated">이 작업이 &lt;code&gt;config/config.exs&lt;/code&gt; 를 업데이트했습니다 . 살펴보면 새 저장소에 대한이 추가 구성 블록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4496ee7e81b6d8ee590f451a0b8506d1a62fc45" translate="yes" xml:space="preserve">
          <source>Notice that we do get an &lt;code&gt;id&lt;/code&gt; column as our primary key by default, even though it isn't listed as a field in our migration.</source>
          <target state="translated">마이그레이션에서 필드로 나열되지 않더라도 기본적으로 &lt;code&gt;id&lt;/code&gt; 열을 기본 키로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b284b5bcd3ebbe3485601e9eb87264dd81883c43" translate="yes" xml:space="preserve">
          <source>Notice that we use the &lt;code&gt;:messenger&lt;/code&gt; syntax in the path. Phoenix will take whatever value that appears in that position in the URL and convert it into a parameter. For example, if we point the browser at: &lt;a href=&quot;http://localhost:4000/hello/Frank&quot;&gt;http://localhost:4000/hello/Frank&lt;/a&gt;, the value of &quot;messenger&quot; will be &quot;Frank&quot;.</source>
          <target state="translated">경로에 &lt;code&gt;:messenger&lt;/code&gt; 구문을 사용합니다 . Phoenix는 URL의 해당 위치에 나타나는 모든 값을 가져와 매개 변수로 변환합니다. 예를 들어 브라우저를 &lt;a href=&quot;http://localhost:4000/hello/Frank&quot;&gt;http : // localhost : 4000 / hello / Frank&lt;/a&gt; 로 지정하면 &quot;messenger&quot;값은 &quot;Frank&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="64af1c72d9186050db6fd48644f9310d3b64546e" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;:session&lt;/code&gt; uses string keys as a reminder that session data is serialized and sent to the client. So you should always keep the data in the session to a minimum. For example, instead of storing a User struct, you should store the &quot;user_id&quot; and load the User when the LiveView mounts.</source>
          <target state="translated">통지 &lt;code&gt;:session&lt;/code&gt; 세션 데이터가 직렬화 및 클라이언트로 전송되는 알림 등의 용도 문자열 키를. 따라서 항상 세션의 데이터를 최소한으로 유지해야합니다. 예를 들어 User 구조체를 저장하는 대신 &quot;user_id&quot;를 저장하고 LiveView가 마운트 될 때 사용자를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="705a210e2f967e9b27fbc85f4436d1298ca94d8c" translate="yes" xml:space="preserve">
          <source>Notice the generated textarea includes a new line after the opening tag. This is because the HTML spec says new lines after tags must be ignored and all major browser implementations do that.</source>
          <target state="translated">생성 된 텍스트 영역에는 여는 태그 다음에 줄 바꿈이 포함되어 있습니다. HTML 사양에 따르면 태그 뒤의 줄 바꿈을 무시해야하며 모든 주요 브라우저 구현에서 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bd1eb7bdbf1493fe7fff0dfec020edf248af81f" translate="yes" xml:space="preserve">
          <source>Notice the router contains a plug pipeline and by default it requires two plugs: &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt;. &lt;code&gt;match&lt;/code&gt; is responsible for finding a matching route which is then forwarded to &lt;code&gt;dispatch&lt;/code&gt;. This means users can easily hook into the router mechanism and add behaviour before match, before dispatch or after both.</source>
          <target state="translated">라우터에는 플러그 파이프 라인이 있으며 기본적으로 &lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;dispatch&lt;/code&gt; 두 개의 플러그가 필요합니다 . &lt;code&gt;match&lt;/code&gt; 는 일치하는 경로를 찾은 다음 &lt;code&gt;dispatch&lt;/code&gt; 로 전달됩니다 . 즉, 사용자는 라우터 메커니즘에 쉽게 연결하여 일치 전, 발송 전 또는 후에 동작을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338f1f90a543cc885f674d5b51bb680bb881e354" translate="yes" xml:space="preserve">
          <source>Notice this function returns the inner representation of a template. If you want the encoded template as a result, use &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 템플릿의 내부 표현을 반환합니다. 인코딩 된 템플릿을 원하는 경우 &lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e90ff23dc6ebf7543c5efbc0c470d81ef5bfdd63" translate="yes" xml:space="preserve">
          <source>Notice we have changed the table name to &quot;abstract table: comments&quot;. You can choose whatever name you want, the point here is that this particular table will never exist.</source>
          <target state="translated">Notice we have changed the table name to &quot;abstract table: comments&quot;. You can choose whatever name you want, the point here is that this particular table will never exist.</target>
        </trans-unit>
        <trans-unit id="c8e74265a82393d957428ce63aae8cdb0f63ce60" translate="yes" xml:space="preserve">
          <source>Notice we have changed the table name to &amp;ldquo;abstract table: comments&amp;rdquo;. You can choose whatever name you want, the point here is that this particular table will never exist.</source>
          <target state="translated">테이블 이름을 &quot;abstract table : comments&quot;로 변경했습니다. 원하는 이름을 선택할 수 있습니다. 여기서 요점은이 특정 테이블이 존재하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c1b3f3f8d9ec0b4f783bd20005a72f78660278b" translate="yes" xml:space="preserve">
          <source>Notice we have created a &lt;code&gt;p&lt;/code&gt; variable to reference the query&amp;rsquo;s original data source. This assumes that the original query only had one source. When the given query has more than one source, a variable must be given for each in the order they were bound:</source>
          <target state="translated">쿼리의 원래 데이터 소스를 참조하기 위해 &lt;code&gt;p&lt;/code&gt; 변수를 만들었습니다 . 이는 원래 쿼리에 소스가 하나만 있다고 가정합니다. 주어진 쿼리에 둘 이상의 소스가있는 경우 각각에 대해 바인딩 된 순서대로 변수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="34ba1e83ec991b59587d3be2e3bac9908c6c5660" translate="yes" xml:space="preserve">
          <source>Notice we have created a &lt;code&gt;p&lt;/code&gt; variable to reference the query's original data source. This assumes that the original query only had one source. When the given query has more than one source, positional or named bindings may be used to access the additional sources.</source>
          <target state="translated">Notice we have created a &lt;code&gt;p&lt;/code&gt; variable to reference the query's original data source. This assumes that the original query only had one source. When the given query has more than one source, positional or named bindings may be used to access the additional sources.</target>
        </trans-unit>
        <trans-unit id="388ad7b43a3f7389ea1cffa9eb54312ad06e6bda" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;/hello/Frank&lt;/code&gt; in your browser should display &lt;code&gt;From messenger Frank&lt;/code&gt; as plain text without any HTML.</source>
          <target state="translated">이제 브라우저의 &lt;code&gt;/hello/Frank&lt;/code&gt; 가 &lt;code&gt;From messenger Frank&lt;/code&gt; 를 HTML없이 일반 텍스트로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb002e44e6ece76c8ea66f1e6240f01d34b08fb" translate="yes" xml:space="preserve">
          <source>Now a &lt;code&gt;@changeset&lt;/code&gt; assign is available in views which we can pass to the form:</source>
          <target state="translated">이제 &lt;code&gt;@changeset&lt;/code&gt; assign을 뷰에서 사용할 수 있으며 양식에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e2284863d0ac87a3339fb9372d10ab42d965b2" translate="yes" xml:space="preserve">
          <source>Now all LiveView sockets will be identified and listening to the given &lt;code&gt;live_socket_id&lt;/code&gt;. You can disconnect all live users identified by said ID by broadcasting on the topic:</source>
          <target state="translated">이제 모든 LiveView 소켓이 식별되고 주어진 &lt;code&gt;live_socket_id&lt;/code&gt; 를 수신합니다 . 주제에 대한 방송을 통해 해당 ID로 식별 된 모든 라이브 사용자의 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1437e6513a6bf32b3b3c512efa591077f4c0f62" translate="yes" xml:space="preserve">
          <source>Now all we need to do is fetch our new dependency, and we'll be ready to go.</source>
          <target state="translated">이제 우리가해야 할 일은 새로운 의존성을 가져 오는 것뿐입니다.</target>
        </trans-unit>
        <trans-unit id="156eab0fe0155cf5ef12fb84db1b915119e1a800" translate="yes" xml:space="preserve">
          <source>Now casting the changeset should tell us that only &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;bio&lt;/code&gt; can't be blank. We can test that by running &lt;code&gt;recompile()&lt;/code&gt; inside &lt;code&gt;iex&lt;/code&gt; and then rebuilding our changeset.</source>
          <target state="translated">이제 변경 세트를 캐스팅하면 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;bio&lt;/code&gt; 만 비워 둘 수 없다고 알려야합니다 . &lt;code&gt;iex&lt;/code&gt; 내 에서 &lt;code&gt;recompile()&lt;/code&gt; 을 실행 한 다음 변경 집합을 다시 빌드 하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75509e758e0d1631ae8ffd5a0584843795e654a2" translate="yes" xml:space="preserve">
          <source>Now each association uses its own specific table, &quot;posts_comments&quot; and &quot;tasks_comments&quot;, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</source>
          <target state="translated">Now each association uses its own specific table, &quot;posts_comments&quot; and &quot;tasks_comments&quot;, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</target>
        </trans-unit>
        <trans-unit id="df59147f1da82103dabce460393f6c1465729899" translate="yes" xml:space="preserve">
          <source>Now each association uses its own specific table, &amp;ldquo;posts_comments&amp;rdquo; and &amp;ldquo;tasks_comments&amp;rdquo;, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</source>
          <target state="translated">이제 각 연관은 고유 한 특정 테이블 인 &quot;posts_comments&quot;및 &quot;tasks_comments&quot;를 사용하며 마이그레이션시 작성해야합니다. 이 방법의 장점은 관련없는 데이터를 함께 저장하지 않고 데이터베이스 참조를 빠르고 정확하게 유지할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d533e178b5d0a298f5a45857958d625cc801c11" translate="yes" xml:space="preserve">
          <source>Now if we visit &lt;a href=&quot;http://localhost:4000/users/new&quot;&gt;http://localhost:4000/users/new&lt;/a&gt;, we'll see the new email input, but if you try to save a user, you'll find that the email field is ignored. No validations are run telling you it was blank and the data was not saved, and at the end you'll get an exception &lt;code&gt;(UndefinedFunctionError) function nil.email/0 is undefined or private&lt;/code&gt;. What gives?</source>
          <target state="translated">이제 &lt;a href=&quot;http://localhost:4000/users/new&quot;&gt;http : // localhost : 4000 / users / new&lt;/a&gt; 를 방문하면 새 이메일 입력이 표시되지만 사용자를 저장하려고하면 이메일 필드가 무시된다는 것을 알 수 있습니다. 비어 있고 데이터가 저장되지 않았 음을 알리는 유효성 검사가 실행되지 않으며 결국 예외 &lt;code&gt;(UndefinedFunctionError) function nil.email/0 is undefined or private&lt;/code&gt; 합니다. 무엇을 제공합니까?</target>
        </trans-unit>
        <trans-unit id="ddbd2955eb6c6aea90a158ce55ea3030e47776d5" translate="yes" xml:space="preserve">
          <source>Now if you fire up the server with &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt; and visit &lt;code&gt;http://localhost:4000&lt;/code&gt;, you should see the following text below your layout header instead of the main template page:</source>
          <target state="translated">이제 &lt;a href=&quot;mix.tasks.phx.server&quot;&gt; &lt;code&gt;mix phx.server&lt;/code&gt; 로&lt;/a&gt; 서버를 시작 하고 &lt;code&gt;http://localhost:4000&lt;/code&gt; 을 방문 하면 기본 템플릿 페이지 대신 레이아웃 헤더 아래에 다음 텍스트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8c607c6e8c44404ce5068ab9b1b3ce98bb9336" translate="yes" xml:space="preserve">
          <source>Now if you reload the Welcome page, you will be redirect and the flash messages will be shown once more.</source>
          <target state="translated">이제 시작 페이지를 다시로드하면 리디렉션되고 플래시 메시지가 다시 한 번 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="600696e62dbcdba61c2028951da1ff82fa17e816" translate="yes" xml:space="preserve">
          <source>Now if you visit the Welcome page, you see the template results also shown.</source>
          <target state="translated">이제 시작 페이지를 방문하면 템플릿 결과도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3fef062b25c451b71f17fb1b79afe0cec7ef7430" translate="yes" xml:space="preserve">
          <source>Now imagine you may need to implement similar logic for every controller and action handled by your API. This would result in a lot of repetition.</source>
          <target state="translated">이제 API에서 처리하는 모든 컨트롤러 및 작업에 대해 유사한 로직을 구현해야 할 수도 있습니다. 이것은 많은 반복을 초래할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d540d337c5d369ff7698d73be7f952b00691abb" translate="yes" xml:space="preserve">
          <source>Now in order to add templates to this view, we simply need to add files to the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory. Note the controller name (&lt;code&gt;HelloController&lt;/code&gt;), the view name (&lt;code&gt;HelloView&lt;/code&gt;), and the template directory (&lt;code&gt;hello&lt;/code&gt;) all follow the same naming convention and are named after each other.</source>
          <target state="translated">이제이 뷰에 템플릿을 추가하려면 &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; 디렉토리 에 파일을 추가하기 만하면 됩니다. 컨트롤러 이름 ( &lt;code&gt;HelloController&lt;/code&gt; ),보기 이름 ( &lt;code&gt;HelloView&lt;/code&gt; ) 및 템플릿 디렉토리 ( &lt;code&gt;hello&lt;/code&gt; )는 모두 동일한 명명 규칙을 따르며 서로 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7892eaebe9d69b3ed993b29b5209261c6832b7a2" translate="yes" xml:space="preserve">
          <source>Now in your Post and Task schemas:</source>
          <target state="translated">이제 Post 및 Task 스키마에서 :</target>
        </trans-unit>
        <trans-unit id="5f22e70ebe5aae1ac6efa98983a3696a51e1fba6" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s take optimistic locking for a spin:</source>
          <target state="translated">이제 스핀에 대해 낙관적 잠금을 수행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="fdfb14fbdcd7f2125b261c60da86a874ceda8245" translate="yes" xml:space="preserve">
          <source>Now let's actually create another layout and render the index template into it. As an example, let's say we had a different layout for the admin section of our application which didn't have the logo image. To do this, let's copy the existing &lt;code&gt;app.html.eex&lt;/code&gt; to a new file &lt;code&gt;admin.html.eex&lt;/code&gt; in the same directory &lt;code&gt;lib/hello_web/templates/layout&lt;/code&gt;. Then let's remove the line in &lt;code&gt;admin.html.eex&lt;/code&gt; that displays the logo.</source>
          <target state="translated">이제 실제로 다른 레이아웃을 만들고 인덱스 템플릿을 렌더링 해 보겠습니다. 예를 들어 로고 이미지가없는 애플리케이션의 관리 섹션에 대해 다른 레이아웃이 있다고 가정 해 보겠습니다. 이를 위해 기존 &lt;code&gt;app.html.eex&lt;/code&gt; 를 동일한 디렉토리 &lt;code&gt;lib/hello_web/templates/layout&lt;/code&gt; 의 새 파일 &lt;code&gt;admin.html.eex&lt;/code&gt; 에 복사 해 보겠습니다 . 그런 다음 로고를 표시하는 &lt;code&gt;admin.html.eex&lt;/code&gt; 에서 줄을 제거해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="fd134ac704626086c0a2688bcf8f69146360ae5f" translate="yes" xml:space="preserve">
          <source>Now let's add a &lt;code&gt;title/0&lt;/code&gt; function to our &lt;code&gt;LayoutView&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;LayoutView&lt;/code&gt; 에 &lt;code&gt;title/0&lt;/code&gt; 함수를 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="384386a9b047357266afdf9d97f79518e3766f61" translate="yes" xml:space="preserve">
          <source>Now let's look at the other flavor plugs come in, module plugs.</source>
          <target state="translated">이제 다른 플레이버 플러그인 모듈 플러그를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="da25f59c7a40f55e7277b533b2edbc31ff66970d" translate="yes" xml:space="preserve">
          <source>Now let's migrate up:</source>
          <target state="translated">이제 마이그레이션 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="961a40b88623bc2ee7b5dcbbe336e0516a508274" translate="yes" xml:space="preserve">
          <source>Now let's take optimistic locking for a spin:</source>
          <target state="translated">Now let's take optimistic locking for a spin:</target>
        </trans-unit>
        <trans-unit id="ab58625211afc49146829abed99901764c327c9b" translate="yes" xml:space="preserve">
          <source>Now only a single query to the database will be made. In fact, the preloading algorithm is a breadth-first tree traversal, which means that even for nested components, the amount of queries are kept to a minimum.</source>
          <target state="translated">이제 데이터베이스에 대한 단일 쿼리 만 만들어집니다. 실제로 사전로드 알고리즘은 폭 우선 트리 순회이므로 중첩 된 구성 요소의 경우에도 쿼리의 양이 최소로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="109cfd20dceeaff1d5d846ed923d3e46a565048e" translate="yes" xml:space="preserve">
          <source>Now open up the new &lt;code&gt;*_add_author_id_to_pages.exs&lt;/code&gt; file in &lt;code&gt;priv/repo/migrations&lt;/code&gt; and key this in:</source>
          <target state="translated">이제 &lt;code&gt;priv/repo/migrations&lt;/code&gt; 에서 새 &lt;code&gt;*_add_author_id_to_pages.exs&lt;/code&gt; 파일을 열고 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="cb2ec75e9d3a281f67cb609f11618373867a0b51" translate="yes" xml:space="preserve">
          <source>Now our new task should be visible to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이제 새로운 작업이 표시되어 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 을 혼합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbc89b18dc14910ce424e7f955e1f39cd23a0890" translate="yes" xml:space="preserve">
          <source>Now start an IEx session and call the server:</source>
          <target state="translated">이제 IEx 세션을 시작하고 서버를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="13c250e39b476294ce3dfa10f4ae7b19afb05096" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when creating comments, we could annotate the changeset with foreign key constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">주석을 작성할 때 제약 조건이 있으므로 외래 키 제약 조건으로 변경 세트에 주석을 달 수 있으므로 Ecto는이를 오류 메시지로 변환하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a955cfcd1ef672463de82344c9b857d32a3c6e9" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when modifying users, we could annotate the changeset with a check constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">Now that a constraint exists, when modifying users, we could annotate the changeset with a check constraint so Ecto knows how to convert it into an error message:</target>
        </trans-unit>
        <trans-unit id="9df5910e0fe0b228330cec2f08ce81553db1a5d6" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when modifying users, we could annotate the changeset with a unique constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">Now that a constraint exists, when modifying users, we could annotate the changeset with a unique constraint so Ecto knows how to convert it into an error message:</target>
        </trans-unit>
        <trans-unit id="0798fc5c299098a56234fedea57c40bd7fcfcd36" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when modifying users, we could annotate the changeset with unique constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">이제 제약 조건이 존재하므로 사용자를 수정할 때 고유 한 제약 조건으로 변경 세트에 주석을 달 수 있으므로 Ecto는이를 오류 메시지로 변환하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc2fc3d7e696c45305baf47a8c9c85699509700" translate="yes" xml:space="preserve">
          <source>Now that we can authenticate a user from our context, let's add a login page to our web layer. First create a new controller in &lt;code&gt;lib/hello_web/controllers/session_controller.ex&lt;/code&gt;:</source>
          <target state="translated">이제 컨텍스트에서 사용자를 인증 할 수 있으므로 웹 레이어에 로그인 페이지를 추가해 보겠습니다. 먼저 &lt;code&gt;lib/hello_web/controllers/session_controller.ex&lt;/code&gt; 에 새 컨트롤러를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="687b8ff07009b0e8ec7cbe90f92d71a6e85984bb" translate="yes" xml:space="preserve">
          <source>Now that we have Ecto and Postgres installed and configured, the easiest way to use Ecto is to generate an Ecto &lt;em&gt;schema&lt;/em&gt; through the &lt;code&gt;phx.gen.schema&lt;/code&gt; task. Ecto schemas are a way for us to specify how Elixir data types map to and from external sources, such as database tables. Let's generate a &lt;code&gt;User&lt;/code&gt; schema with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;bio&lt;/code&gt;, and &lt;code&gt;number_of_pets&lt;/code&gt; fields.</source>
          <target state="translated">이제 Ecto 및 Postgres가 설치 및 구성 &lt;code&gt;phx.gen.schema&lt;/code&gt; Ecto를 사용하는 가장 쉬운 방법 은 phx.gen.schema 작업을 통해 Ecto &lt;em&gt;스키마&lt;/em&gt; 를 생성하는 것입니다. Ecto 스키마는 Elixir 데이터 유형이 데이터베이스 테이블과 같은 외부 소스와 어떻게 매핑되는지를 지정하는 방법입니다. &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; , &lt;code&gt;bio&lt;/code&gt; 및 &lt;code&gt;number_of_pets&lt;/code&gt; 필드를 사용하여 &lt;code&gt;User&lt;/code&gt; 스키마를 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4718c841e16ccc9b39671676d23c17f47d4fb3bb" translate="yes" xml:space="preserve">
          <source>Now that we have acquainted ourselves with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;, we are ready to share views and templates from inside other views and templates.</source>
          <target state="translated">이제 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; 에&lt;/a&gt; 익숙해 졌으므로 다른 뷰와 템플릿 내부에서 뷰와 템플릿을 공유 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed53b5e153ccb4f1e5f4dc29467f4c264b8f3b33" translate="yes" xml:space="preserve">
          <source>Now that we have learned how to define and use components, as well as how to use &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; as a data loading optimization, it is important to talk about how to manage state in components.</source>
          <target state="translated">이제 구성 요소를 정의하고 사용하는 방법과 데이터로드 최적화로 &lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt; 을 사용하는 방법을 배웠 으므로 구성 요소에서 상태를 관리하는 방법에 대해 이야기하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="284e717ac291e10e2ab5fb1d71ea0889a46bfbc8" translate="yes" xml:space="preserve">
          <source>Now that we have our task module defined, our next step is to compile the application.</source>
          <target state="translated">작업 모듈이 정의되었으므로 다음 단계는 응용 프로그램을 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ff9f43eddd62ad585ceaaca6e5c096e3fccfd598" translate="yes" xml:space="preserve">
          <source>Now that we have the beginnings of user account and credential features, let's begin to work on the other main features of our application &amp;ndash; managing page content. We want to support a content management system (CMS) where authors can create and edit pages of the site. While we could extend our &lt;code&gt;Accounts&lt;/code&gt; context with CMS features, if we step back and think about the isolation of our application, we can see it doesn't fit. An accounts system shouldn't care at all about a CMS system. The responsibilities of our &lt;code&gt;Accounts&lt;/code&gt; context is to manage users and their credentials, not handle page content changes. There's a clear need here for a separate context to handle these responsibilities. Let's call it &lt;code&gt;CMS&lt;/code&gt;.</source>
          <target state="translated">이제 사용자 계정 및 자격 증명 기능을 시작 했으므로 응용 프로그램의 다른 주요 기능인 페이지 콘텐츠 관리 작업을 시작하겠습니다. 저자가 사이트의 페이지를 만들고 편집 할 수있는 콘텐츠 관리 시스템 (CMS)을 지원하고자합니다. CMS 기능으로 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 확장 할 수 있지만 한 걸음 물러서서 애플리케이션의 격리에 대해 생각하면 적합하지 않음을 알 수 있습니다. 계정 시스템은 CMS 시스템에 대해 전혀 신경 쓰지 않아야합니다. &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트 의 책임은 페이지 콘텐츠 변경을 처리하는 것이 아니라 사용자와 해당 자격 증명을 관리하는 것입니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이러한 책임을 처리하기위한 별도의 컨텍스트가 여기에 분명하게 필요합니다. &lt;code&gt;CMS&lt;/code&gt; 라고합시다 .</target>
        </trans-unit>
        <trans-unit id="280233dd235fe9104eea288a29f74373bba5c1f8" translate="yes" xml:space="preserve">
          <source>Now that we know where our data dependencies exist, let's add our schema associations so we can tie pages to authors and authors to users. Make the following changes to &lt;code&gt;lib/hello/cms/page.ex&lt;/code&gt;:</source>
          <target state="translated">이제 데이터 종속성이 어디에 있는지 알았으므로 페이지를 작성자에 연결하고 작성자를 사용자에 연결할 수 있도록 스키마 연결을 추가해 보겠습니다. &lt;code&gt;lib/hello/cms/page.ex&lt;/code&gt; 를 다음과 같이 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="a03010b8d00b03e92f316d8729fdf78437d8234c" translate="yes" xml:space="preserve">
          <source>Now that we've got the route, controller, view, and template, we should be able to point our browsers at &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http://localhost:4000/hello&lt;/a&gt; and see our greeting from Phoenix! (In case you stopped the server along the way, the task to restart it is &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">이제 경로, 컨트롤러,보기 및 템플릿을 얻었으므로 &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http : // localhost : 4000 / hello&lt;/a&gt; 에서 브라우저를 가리키고 Phoenix의 인사말을 볼 수 있습니다! (도중에 서버를 중지 한 경우 다시 시작하는 작업은 &lt;a href=&quot;mix.tasks.phx.server&quot;&gt; &lt;code&gt;mix phx.server&lt;/code&gt; &lt;/a&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="96e8ec286497eee03da03a7da6b9a6a2803ce1f4" translate="yes" xml:space="preserve">
          <source>Now the value label will be rendered like &lt;code&gt;&quot;Phoenix.LiveDashboard.MetricsLive Connected&quot;&lt;/code&gt;.</source>
          <target state="translated">이제 값 레이블이 &lt;code&gt;&quot;Phoenix.LiveDashboard.MetricsLive Connected&quot;&lt;/code&gt; 와 같이 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="3118c6df6c7648828e1c75aa2e5f0dc54ff66b25" translate="yes" xml:space="preserve">
          <source>Now to add live sorting, you could do:</source>
          <target state="translated">이제 실시간 정렬을 추가하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8146d2b685b41a346d939acfce081d0b50f0ea" translate="yes" xml:space="preserve">
          <source>Now we can insert with the same title but do nothing on conflicts:</source>
          <target state="translated">이제 같은 제목으로 삽입 할 수 있지만 충돌에 대해서는 아무 것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba86d9c862b711f84037498dddfa0769d16c6930" translate="yes" xml:space="preserve">
          <source>Now we can match on event and payload as patterns:</source>
          <target state="translated">이제 이벤트와 페이로드를 패턴으로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f293a74f0c6acbd493f7be5d1b1da8ff98570181" translate="yes" xml:space="preserve">
          <source>Now we can use our new field type above in our schemas:</source>
          <target state="translated">이제 스키마에서 위의 새 필드 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54af1554b118c9ad35d27f9dec4b6b5a38cb64b2" translate="yes" xml:space="preserve">
          <source>Now we know how data is fetched, but how are users persisted? Let's take a look at the &lt;code&gt;Accounts.create_user/1&lt;/code&gt; function:</source>
          <target state="translated">이제 데이터를 가져 오는 방법을 알고 있지만 사용자는 어떻게 유지됩니까? &lt;code&gt;Accounts.create_user/1&lt;/code&gt; 함수를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b9015fd7695dcf3a3869ec9890d61ecf327b4ee3" translate="yes" xml:space="preserve">
          <source>Now we'll create our database:</source>
          <target state="translated">이제 데이터베이스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a15534db69c5982cb36f6eb83be9e89a05748026" translate="yes" xml:space="preserve">
          <source>Now we're ready to create our accounts context. We'll use &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt; which creates a context module that wraps up Ecto access for creating, updating, and deleting users, along with web files like controllers and templates for the web interface into our context. Run the following command at your project root:</source>
          <target state="translated">이제 계정 컨텍스트를 만들 준비가되었습니다. 우리는 사용합니다 &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt; &lt;code&gt;mix phx.gen.html&lt;/code&gt; &lt;/a&gt; 상황에 맞는 모듈을 만듭니다 생성, 업데이트, 그리고 우리의 상황에 웹 인터페이스 컨트롤러 및 템플릿 같은 웹 파일과 함께 사용자를 삭제하기위한 체외 액세스 최대 래핑합니다. 프로젝트 루트에서 다음 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0bed409b21499bace4fa14cc1d1a8a7b6830c03a" translate="yes" xml:space="preserve">
          <source>Now we're starting to get a taste of Ecto's rich querying capabilities. We used &lt;code&gt;Repo.one/1&lt;/code&gt; to fetch the count of all users with an email address containing &quot;1&quot;, and received the expected count in return. This just scratches the surface of Ecto's query interface, and much more is supported such as sub-querying, interval queries, and advanced select statements. For example, let's build a query to fetch a map of all user id's to their email addresses.</source>
          <target state="translated">이제 우리는 Ecto의 풍부한 쿼리 기능을 맛보기 시작했습니다. &lt;code&gt;Repo.one/1&lt;/code&gt; 을 사용 하여 &quot;1&quot;이 포함 된 이메일 주소를 가진 모든 사용자의 수를 가져오고 그에 대한 예상 수를 받았습니다. 이것은 Ecto의 쿼리 인터페이스의 표면에 불과하며 하위 쿼리, 간격 쿼리 및 고급 선택 문과 같은 훨씬 더 많은 것이 지원됩니다. 예를 들어 모든 사용자 ID의지도를 이메일 주소로 가져 오는 쿼리를 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="66eb09ebffa8e0cfdd32a399ee36544bed9f39f4" translate="yes" xml:space="preserve">
          <source>Now when we go back to &lt;a href=&quot;http://localhost:4000/such/a/wrong/path&quot;&gt;http://localhost:4000/such/a/wrong/path&lt;/a&gt;, we should see a much nicer error page. It is worth noting that we did not render our &lt;code&gt;404.html.eex&lt;/code&gt; template through our application layout, even though we want our error page to have the look and feel of the rest of our site. This is to avoid circular errors. For example, what happens if our application failed due to an error in the layout? Attempting to render the layout again will just trigger another error. So ideally we want to minimize the amount of dependencies and logic in our error templates, sharing only what is necessary.</source>
          <target state="translated">이제 &lt;a href=&quot;http://localhost:4000/such/a/wrong/path&quot;&gt;http : // localhost : 4000 / such / a / wrong / path&lt;/a&gt; 로 돌아 가면 훨씬 더 멋진 오류 페이지가 표시됩니다. 오류 페이지가 나머지 사이트의 모양과 느낌을 갖기를 원하지만 애플리케이션 레이아웃을 통해 &lt;code&gt;404.html.eex&lt;/code&gt; 템플릿을 렌더링하지 않았다는 점은 주목할 가치가 있습니다. 이것은 순환 오류를 방지하기위한 것입니다. 예를 들어, 레이아웃 오류로 인해 애플리케이션이 실패하면 어떻게됩니까? 레이아웃을 다시 렌더링하려고하면 또 다른 오류가 발생합니다. 따라서 이상적으로는 오류 템플릿에서 종속성과 논리의 양을 최소화하고 필요한 것만 공유하려고합니다.</target>
        </trans-unit>
        <trans-unit id="671d80ccffc149ad8246088d3f267d0488bdf446" translate="yes" xml:space="preserve">
          <source>Now when you call &lt;code&gt;Routes.some_route_url(conn, ...)&lt;/code&gt;, it will use the router url set above. Keep in mind that, if you want to generate routes to the &lt;em&gt;current&lt;/em&gt; domain, it is preferred to use &lt;code&gt;Routes.some_route_path&lt;/code&gt; helpers, as those are always relative.</source>
          <target state="translated">Now when you call &lt;code&gt;Routes.some_route_url(conn, ...)&lt;/code&gt; , it will use the router url set above. Keep in mind that, if you want to generate routes to the &lt;em&gt;current&lt;/em&gt; domain, it is preferred to use &lt;code&gt;Routes.some_route_path&lt;/code&gt; helpers, as those are always relative.</target>
        </trans-unit>
        <trans-unit id="13d454d44ac4299e10880f99c22305f1ff47e0f8" translate="yes" xml:space="preserve">
          <source>Now with measurements in place, you can define the metrics for the events above:</source>
          <target state="translated">이제 측정이 완료되면 위의 이벤트에 대한 메트릭을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd422e1cc828b1edc3ea104d8180dbeb02ea406" translate="yes" xml:space="preserve">
          <source>Now you are ready to explore the world provided by Phoenix! See &lt;a href=&quot;community&quot;&gt;our community page&lt;/a&gt; for books, screencasts, courses, and more.</source>
          <target state="translated">이제 Phoenix가 제공하는 세계를 탐험 할 준비가되었습니다! 도서, 스크린 캐스트, 코스 등을 보려면 &lt;a href=&quot;community&quot;&gt;커뮤니티 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21d5031f091d1df5545887b06dbf8bf713ba83d4" translate="yes" xml:space="preserve">
          <source>Now, any DOM container with the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute will receive a &lt;code&gt;phx-no-feedback&lt;/code&gt; class in cases where the form fields has yet to receive user input/focus. The following css rules are generated in new projects to hide the errors:</source>
          <target state="translated">이제 &lt;code&gt;phx-feedback-for&lt;/code&gt; 속성이 있는 DOM 컨테이너 는 양식 필드가 아직 사용자 입력 / 포커스를 수신하지 않은 경우 &lt;code&gt;phx-no-feedback&lt;/code&gt; 클래스를받습니다. 오류를 숨기기 위해 새 프로젝트에서 다음 CSS 규칙이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="28539fab18f089e7edede27282980155dcb516c5" translate="yes" xml:space="preserve">
          <source>Now, each CardComponent loads their own card. Of course, doing so per card would be expensive and lead to N queries, where N is the number of components, so we must use the &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; callback to make it efficient.</source>
          <target state="translated">이제 각 CardComponent는 자체 카드를로드합니다. 물론 카드 당 그렇게하는 것은 비용이 많이 들고 N 쿼리로 이어질 것입니다. 여기서 N은 구성 요소의 수이므로 효율적으로 만들기 위해 &lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt; 콜백을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8457cbe58c93ebdf37da248e0177a07ae7d1be1c" translate="yes" xml:space="preserve">
          <source>Now, fire up your server with &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt; and try it out. Visit &lt;a href=&quot;http://localhost:4000/cms/pages/new&quot;&gt;http://localhost:4000/cms/pages/new&lt;/a&gt; and save a new page.</source>
          <target state="translated">이제 &lt;a href=&quot;mix.tasks.phx.server&quot;&gt; &lt;code&gt;mix phx.server&lt;/code&gt; 로&lt;/a&gt; 서버를 시작 하고 사용해보십시오. &lt;a href=&quot;http://localhost:4000/cms/pages/new&quot;&gt;http : // localhost : 4000 / cms / pages / new를&lt;/a&gt; 방문 하여 새 페이지를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="f922556241095611055be1ec378ed358e841233e" translate="yes" xml:space="preserve">
          <source>Now, if we try to cast data containing a value of &quot;A&quot; for our user's bio, we should see the failed validation in the changeset's errors.</source>
          <target state="translated">이제 사용자 약력에 대해 &quot;A&quot;값이 포함 된 데이터를 캐스팅하려고하면 변경 집합의 오류에서 실패한 유효성 검사가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8173424368e14547f313929000b0087bed3ce719" translate="yes" xml:space="preserve">
          <source>Now, in the same way the channel has a socket representing communication it will push to the client. Our test has a socket representing communication to be pushed to the server.</source>
          <target state="translated">동일한 방식으로 채널에는 통신을 나타내는 소켓이 있으며 클라이언트로 푸시됩니다. 테스트에는 서버에 푸시 할 통신을 나타내는 소켓이 있습니다.</target>
        </trans-unit>
        <trans-unit id="651a0fa90825b87efc8e53dec822eab4036cafec" translate="yes" xml:space="preserve">
          <source>Now, let's fire up the server with &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt; and visit &lt;a href=&quot;http://localhost:4000/cms/pages&quot;&gt;http://localhost:4000/cms/pages&lt;/a&gt;. If we haven't logged in yet, we'll be redirected to the home page with a flash error message telling us to sign in. Let's sign in at &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http://localhost:4000/sessions/new&lt;/a&gt;, then re-visit &lt;a href=&quot;http://localhost:4000/cms/pages&quot;&gt;http://localhost:4000/cms/pages&lt;/a&gt;. Now that we're authenticated, we should see a familiar resource listing for pages, with a &lt;code&gt;New Page&lt;/code&gt; link.</source>
          <target state="translated">이제 &lt;a href=&quot;mix.tasks.phx.server&quot;&gt; &lt;code&gt;mix phx.server&lt;/code&gt; 로&lt;/a&gt; 서버를 시작 하고 &lt;a href=&quot;http://localhost:4000/cms/pages&quot;&gt;http : // localhost : 4000 / cms / pages를&lt;/a&gt; 방문해 보겠습니다 . 아직 로그인하지 않은 경우 로그인하라는 플래시 오류 메시지와 함께 홈 페이지로 리디렉션됩니다. &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http : // localhost : 4000 / sessions / new&lt;/a&gt; 에서 로그인 한 다음 &lt;a href=&quot;http://localhost:4000/cms/pages&quot;&gt;http&lt;/a&gt; 를 다시 방문합니다. : // localhost를 : 4000 / CMS / 페이지 . 이제 인증되었으므로 &lt;code&gt;New Page&lt;/code&gt; 링크 와 함께 페이지에 대한 친숙한 리소스 목록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6995b04f2014469bc431d1ebf80a860774d5897a" translate="yes" xml:space="preserve">
          <source>Now, let's make &lt;code&gt;number_of_pets&lt;/code&gt; optional. In order to do this, we simply remove it from the list.</source>
          <target state="translated">이제 &lt;code&gt;number_of_pets&lt;/code&gt; 를 선택적으로 만들어 보겠습니다 . 이렇게하려면 목록에서 제거하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="22e0a1e0cfc6b366660737615984d2e99a0dd933" translate="yes" xml:space="preserve">
          <source>Now, since the tags already exist, we will bring all of them from the database and put them directly in the post:</source>
          <target state="translated">이제 태그가 이미 존재하므로 데이터베이스에서 모든 태그를 가져 와서 포스트에 직접 넣습니다.</target>
        </trans-unit>
        <trans-unit id="2c2f8561ea64f704daa54d16a3cce1aabe4b4fc2" translate="yes" xml:space="preserve">
          <source>Now, when deleting the post, it is possible to forbid any post to be deleted if they still have comments attached to it:</source>
          <target state="translated">이제 게시물을 삭제할 때 게시물에 여전히 주석이 첨부되어 있으면 게시물이 삭제되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6353f6cdd020e0676b8bc3ecb0210f83694d66" translate="yes" xml:space="preserve">
          <source>Now, when inserting a comment, it is possible to forbid any comment to be added if the associated post does not exist:</source>
          <target state="translated">이제 주석을 삽입 할 때 연관된 게시물이 존재하지 않는 경우 주석이 추가되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb3c08053ad9023afdd5bd4d957472bc6369f4e" translate="yes" xml:space="preserve">
          <source>Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt;, if the associated post does not exist, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository.</source>
          <target state="translated">이제 &lt;code&gt;Repo.insert/2&lt;/code&gt; 또는 &lt;code&gt;Repo.update/2&lt;/code&gt; 를 호출 할 때 연관된 게시물이 존재하지 않으면 저장소에 의해 오류 및 &lt;code&gt;{:error, changeset}&lt;/code&gt; 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="68a2adda5c42710e68a1cc01422f0e86a8968174" translate="yes" xml:space="preserve">
          <source>Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt;, if the email already exists, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</source>
          <target state="translated">이제 &lt;code&gt;Repo.insert/2&lt;/code&gt; 또는 &lt;code&gt;Repo.update/2&lt;/code&gt; 를 호출 할 때 전자 우편이 이미 존재하는 경우, 전자 우편이 오류로 변환되고 &lt;code&gt;{:error, changeset}&lt;/code&gt; 가 저장소에 의해 리턴됩니다. 데이터베이스에 도달 한 후에 만 ​​오류가 발생하므로 다른 모든 유효성 검사가 통과 될 때까지 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fdda6a6b82e0d07f744f3b9a46a40360cfdce5f" translate="yes" xml:space="preserve">
          <source>Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt;, if the price is not positive, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</source>
          <target state="translated">Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt; , if the price is not positive, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</target>
        </trans-unit>
        <trans-unit id="7152c788739bd39d4dfe9f7865d02f930a5ac9ee" translate="yes" xml:space="preserve">
          <source>Now, when the user submits a form inside the CardComponent to update the card, &lt;code&gt;CardComponent.handle_event/3&lt;/code&gt; will be triggered. However, if the update succeeds, you must not change the card struct inside the component. If you do so, the card struct in the component will get out of sync with the LiveView. Since the LiveView is the source of truth, you should instead tell the LiveView that the card was updated.</source>
          <target state="translated">이제 사용자가 CardComponent 내에서 양식을 제출하여 카드를 업데이트하면 &lt;code&gt;CardComponent.handle_event/3&lt;/code&gt; 가 트리거됩니다. 그러나 업데이트가 성공하면 구성 요소 내부의 카드 구조를 변경하면 안됩니다. 그렇게하면 구성 요소의 카드 구조가 LiveView와 동기화되지 않습니다. LiveView는 진실의 소스이므로 대신 LiveView에 카드가 업데이트되었음을 ​​알려야합니다.</target>
        </trans-unit>
        <trans-unit id="208681361b31870cfb3c51d2c0869d053d96cc95" translate="yes" xml:space="preserve">
          <source>Now, whenever LiveView connects to the server, it will send a copy &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;href&lt;/code&gt; attributes of all tracked statics and compare those values with the latest entries computed by &lt;a href=&quot;../phoenix/mix.tasks.phx.digest&quot;&gt;&lt;code&gt;mix phx.digest&lt;/code&gt;&lt;/a&gt; in the server.</source>
          <target state="translated">이제 LiveView가 서버에 연결할 때마다 추적 된 모든 정적의 &lt;code&gt;src&lt;/code&gt; 또는 &lt;code&gt;href&lt;/code&gt; 속성을 복사 하고 해당 값을 서버의 &lt;a href=&quot;../phoenix/mix.tasks.phx.digest&quot;&gt; &lt;code&gt;mix phx.digest&lt;/code&gt; &lt;/a&gt; 에 의해 계산 된 최신 항목과 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="f327615cc51c1828cda7fcb9fd954538d2a0fb33" translate="yes" xml:space="preserve">
          <source>Now, whenever there are one or more new messages, we will assign only the new messages to &lt;code&gt;@messages&lt;/code&gt;:</source>
          <target state="translated">이제 하나 이상의 새 메시지가있을 때마다 새 메시지 만 &lt;code&gt;@messages&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="6d5fdb98909059197f8adf8277903d735dc527ef" translate="yes" xml:space="preserve">
          <source>Null check functions: &lt;a href=&quot;#is_nil/1&quot;&gt;&lt;code&gt;is_nil/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">널 점검 기능 : &lt;a href=&quot;#is_nil/1&quot;&gt; &lt;code&gt;is_nil/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2c355e93abf7eccce6a133b7b0dd4181ba5bf2" translate="yes" xml:space="preserve">
          <source>Number inputs</source>
          <target state="translated">숫자 입력</target>
        </trans-unit>
        <trans-unit id="aadc131fe18a8b9e64fb8607ca02faec66b47b25" translate="yes" xml:space="preserve">
          <source>Number inputs are a special case in LiveView forms. On programmatic updates, some browsers will clear invalid inputs. So LiveView will not send change events from the client when an input is invalid, instead allowing the browser's native validation UI to drive user interaction. Once the input becomes valid, change and submit events will be sent normally.</source>
          <target state="translated">숫자 입력은 LiveView 양식에서 특별한 경우입니다. 프로그래밍 방식 업데이트에서 일부 브라우저는 잘못된 입력을 지 웁니다. 따라서 LiveView는 입력이 유효하지 않은 경우 클라이언트에서 변경 이벤트를 보내지 않고 대신 브라우저의 기본 유효성 검사 UI가 사용자 상호 작용을 유도하도록 허용합니다. 입력이 유효 해지면 변경 및 제출 이벤트가 정상적으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="af60c4a86495ef9a6ff8569ed2a0e3670fd7e1bf" translate="yes" xml:space="preserve">
          <source>Of course, our task is just a module, so we can define other private functions as needed to support our &lt;code&gt;run/1&lt;/code&gt; function.</source>
          <target state="translated">물론 우리의 작업은 모듈 일 뿐이므로 &lt;code&gt;run/1&lt;/code&gt; 함수 를 지원하기 위해 필요에 따라 다른 개인 함수를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27f90e8f61d8bf4c3bcf4b84ae0d014ea7ce324c" translate="yes" xml:space="preserve">
          <source>Of course, the benefit of &lt;code&gt;.leex&lt;/code&gt; templates is exactly that you do not need to send both static and dynamic segments every time. So let's talk about tracking changes.</source>
          <target state="translated">물론 &lt;code&gt;.leex&lt;/code&gt; 템플릿 의 이점은 매번 정적 및 동적 세그먼트를 모두 보낼 필요가 없다는 것입니다. 이제 변경 사항 추적에 대해 이야기 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c9c4cf4ccb71723572be6c90bf766dc3e132735f" translate="yes" xml:space="preserve">
          <source>Of course, we'll need to change the login credentials to match what our database expects. We'll also need to change the config for other environments.</source>
          <target state="translated">물론 데이터베이스가 예상하는 것과 일치하도록 로그인 자격 증명을 변경해야합니다. 다른 환경에 대한 구성도 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="7655c74497a5c7b8685ca84508279dfa205338fd" translate="yes" xml:space="preserve">
          <source>Offloading TLS</source>
          <target state="translated">TLS 오프 로딩</target>
        </trans-unit>
        <trans-unit id="d03194ddedfd6a15cc669b23f161a08fa6b4ce3d" translate="yes" xml:space="preserve">
          <source>Offloading might be done to achieve higher throughput, or to stick to the more widely used OpenSSL implementation of the TLS protocol. The Erlang/OTP implementation depends on OpenSSL for the underlying cryptography, but it implements its own message framing and protocol state machine. While it is not clear that one implementation is inherently more secure than the other, just patching OpenSSL along with everybody else in case of vulnerabilities might give peace of mind, compared to than having to research the implications on the Erlang/OTP implementation.</source>
          <target state="translated">더 높은 처리량을 달성하거나 더 널리 사용되는 TLS 프로토콜의 OpenSSL 구현을 고수하기 위해 오프 로딩을 수행 할 수 있습니다. Erlang / OTP 구현은 기본 암호화를 위해 OpenSSL에 의존하지만 자체 메시지 프레이밍 및 프로토콜 상태 시스템을 구현합니다. 하나의 구현이 본질적으로 다른 구현보다 더 안전하다는 것은 분명하지 않지만, 취약점이있는 경우 다른 모든 사람과 함께 OpenSSL을 패치하는 것만으로도 Erlang / OTP 구현에 대한 영향을 조사하는 것보다 안심할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1169045ff4783e5d8401da833eccb418f745b0e" translate="yes" xml:space="preserve">
          <source>Offloading work to clients via MFA response</source>
          <target state="translated">MFA 응답을 통해 클라이언트로 작업을 오프로드</target>
        </trans-unit>
        <trans-unit id="e8c2f62e74e6e2e3c2e935bb6f427f5a5a8b6ff0" translate="yes" xml:space="preserve">
          <source>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can&amp;rsquo;t include any field.</source>
          <target state="translated">결과에서 선택한 행 수를 오프셋합니다. 모든 표현식이 될 수 있지만 정수 값으로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="877a81700bf01ab2876d0af2848aeacdd865e1e7" translate="yes" xml:space="preserve">
          <source>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can't include any field.</source>
          <target state="translated">Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can't include any field.</target>
        </trans-unit>
        <trans-unit id="3268d5059217b0540f5f6fe6f9e84eff2fec3291" translate="yes" xml:space="preserve">
          <source>Often one may want to do side-effects inside channels, like writing to the database, and verify those side-effects during their tests.</source>
          <target state="translated">종종 데이터베이스에 쓰는 것과 같이 채널 내부에서 부작용을 수행하고 테스트 중에 이러한 부작용을 확인하고자 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57042716b8ebfeb22e5ac3fd9d2e4b69afeeae1c" translate="yes" xml:space="preserve">
          <source>Often times, you may want posts and comments to be selected and filtered in the same query. For such cases, you can explicitly tell an existing join to be preloaded into the result set:</source>
          <target state="translated">종종 같은 쿼리에서 게시물과 댓글을 선택하고 필터링 할 수 있습니다. 이러한 경우 기존 조인을 결과 집합에 미리로드하도록 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3397f740e17da01fd4e1161fbf74b7b31c2a19e" translate="yes" xml:space="preserve">
          <source>Often, we need to redirect to a new url in the middle of a request. A successful &lt;code&gt;create&lt;/code&gt; action, for instance, will usually redirect to the &lt;code&gt;show&lt;/code&gt; action for the resource we just created. Alternately, it could redirect to the &lt;code&gt;index&lt;/code&gt; action to show all the things of that same type. There are plenty of other cases where redirection is useful as well.</source>
          <target state="translated">종종 요청 중에 새 URL로 리디렉션해야합니다. 예를 들어 성공적인 &lt;code&gt;create&lt;/code&gt; 작업은 일반적으로 방금 만든 리소스에 대한 &lt;code&gt;show&lt;/code&gt; 작업 으로 리디렉션됩니다 . 또는 동일한 유형의 모든 항목을 표시 하기 위해 &lt;code&gt;index&lt;/code&gt; 작업으로 리디렉션 할 수 있습니다. 리디렉션이 유용한 다른 경우도 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe587642c6822c244524cab44ad920470036c18" translate="yes" xml:space="preserve">
          <source>Ok, let's give it a try. First, we'll &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;hello/&lt;/code&gt; directory we've just created:</source>
          <target state="translated">좋아, 한번 해보자. 첫째, 우리는거야 &lt;code&gt;cd&lt;/code&gt; 에 &lt;code&gt;hello/&lt;/code&gt; 우리는 단지 디렉토리 만들었습니다 :</target>
        </trans-unit>
        <trans-unit id="c26a917733e13b7f48bd1165efef98ef86a82d1c" translate="yes" xml:space="preserve">
          <source>Ok, that's not very exciting. We get the bare string &quot;Not Found&quot;, displayed without any markup or styling.</source>
          <target state="translated">좋아,별로 흥미롭지 않아. 마크 업이나 스타일없이 표시되는 맨 문자열 &quot;Not Found&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f141b9556ffaa940bdd55ed667d6fe7df0636fe1" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;init/1&lt;/code&gt;, you will define the supervision tree and use the given &lt;code&gt;name&lt;/code&gt; to register the main pubsub process locally. This process must be able to handle the following GenServer calls:</source>
          <target state="translated">에 &lt;code&gt;init/1&lt;/code&gt; , 당신은 감독 트리를 정의하고 주어진 사용할 &lt;code&gt;name&lt;/code&gt; 로컬 주요 pubsub 과정을 등록 할 수 있습니다. 이 프로세스는 다음 GenServer 호출을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a3d486060ac23bbb932985c424a7618cb9333223" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;use Phoenix.Socket&lt;/code&gt;, the following options are accepted:</source>
          <target state="translated">On &lt;code&gt;use Phoenix.Socket&lt;/code&gt; , the following options are accepted:</target>
        </trans-unit>
        <trans-unit id="7f1a4f5f25b2df4283fcf9a15c23f2f29afb3c94" translate="yes" xml:space="preserve">
          <source>On a slow machine (e.g. a cheap VPS) this may take several hours. You may want to run the command on a strong machine and copy the file over to the target server: the file does not need to be kept secret. It is best practice to rotate the file periodically.</source>
          <target state="translated">느린 시스템 (예 : 저렴한 VPS)에서는 몇 시간이 걸릴 수 있습니다. 강력한 시스템에서 명령을 실행하고 파일을 대상 서버로 복사 할 수 있습니다. 파일을 비밀로 유지할 필요는 없습니다. 주기적으로 파일을 회전하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e84a0f737366ca3cfdac4eb66f40bb0d94b8528" translate="yes" xml:space="preserve">
          <source>On a slow machine (e.g. a cheap VPS) this may take several hours. You may want to run the command on a strong machine and copy the file over: the file does not need to be kept secret.</source>
          <target state="translated">느린 컴퓨터 (예 : 저렴한 VPS)에서는 몇 시간이 걸릴 수 있습니다. 강력한 시스템에서 명령을 실행하고 파일을 복사 할 수 있습니다. 파일을 비밀로 유지할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c976d3a359546676c77da904026694b0f3d7d4f" translate="yes" xml:space="preserve">
          <source>On click, would receive the &lt;code&gt;phx-click-loading&lt;/code&gt; class, and on keydown would receive the &lt;code&gt;phx-keydown-loading&lt;/code&gt; class. The css loading classes are maintained until an acknowledgement is received on the client for the pushed event.</source>
          <target state="translated">클릭시 &lt;code&gt;phx-click-loading&lt;/code&gt; 클래스를 수신하고 &lt;code&gt;phx-keydown-loading&lt;/code&gt; 클래스를 수신합니다 . CSS 로딩 클래스는 푸시 된 이벤트에 대한 승인이 클라이언트에서 수신 될 때까지 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd15d31b2b705788de178b21b7c3d0964d6d449" translate="yes" xml:space="preserve">
          <source>On completion of server processing of the &lt;code&gt;phx-submit&lt;/code&gt; event:</source>
          <target state="translated">&lt;code&gt;phx-submit&lt;/code&gt; 이벤트 의 서버 처리 완료시 :</target>
        </trans-unit>
        <trans-unit id="cd2ab14af2363fa537385832ba4cbdf91081372e" translate="yes" xml:space="preserve">
          <source>On mount we also load the initial number of messages we want to send. After the initial render, the initial batch of messages will be reset back to an empty list.</source>
          <target state="translated">마운트시 우리는 보낼 초기 메시지 수도로드합니다. 초기 렌더링 후 메시지의 초기 배치는 빈 목록으로 다시 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7714e69084164c3ffa02d9b3047303179f312af" translate="yes" xml:space="preserve">
          <source>On submission of a form bound with a &lt;code&gt;phx-submit&lt;/code&gt; event:</source>
          <target state="translated">&lt;code&gt;phx-submit&lt;/code&gt; 이벤트 로 바인딩 된 양식 제출시 :</target>
        </trans-unit>
        <trans-unit id="51ce62f0730c8671ea8c5e482854874c47611ba5" translate="yes" xml:space="preserve">
          <source>On subsequent renders, these callbacks will be invoked:</source>
          <target state="translated">후속 렌더링에서 다음 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9350f68c16dc3975736e2ffb932a9eec44b9b561" translate="yes" xml:space="preserve">
          <source>On termination, &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; must be called. A special atom with reason &lt;code&gt;:closed&lt;/code&gt; can be used to specify that the client terminated the connection.</source>
          <target state="translated">On termination, &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; must be called. A special atom with reason &lt;code&gt;:closed&lt;/code&gt; can be used to specify that the client terminated the connection.</target>
        </trans-unit>
        <trans-unit id="967d69f7b0e95ad35ee7b7bf3862fba54aff0f83" translate="yes" xml:space="preserve">
          <source>On termination, the channel callback &lt;code&gt;terminate/2&lt;/code&gt; will be invoked with the error reason and the socket.</source>
          <target state="translated">종료시, 채널 콜백 &lt;code&gt;terminate/2&lt;/code&gt; 는 오류 이유 및 소켓과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62ac2bb5b94cbb1a583addb2cd6e29190cd32943" translate="yes" xml:space="preserve">
          <source>On the left side of &lt;code&gt;in&lt;/code&gt; we specify the query bindings. This is done inside from and join clauses. In the query below &lt;code&gt;u&lt;/code&gt; is a binding and &lt;code&gt;u.age&lt;/code&gt; is a field access using this binding.</source>
          <target state="translated">왼쪽에서 &lt;code&gt;in&lt;/code&gt; 우리는 쿼리 바인딩을 지정합니다. 이것은 from 및 join 절 내에서 수행됩니다. 아래 쿼리에서 &lt;code&gt;u&lt;/code&gt; 는 바인딩이고 &lt;code&gt;u.age&lt;/code&gt; 는이 바인딩을 사용하는 필드 액세스입니다.</target>
        </trans-unit>
        <trans-unit id="cbdd917a58dadedc012b8760e8dfaa3abf4a7649" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; is used for defining schemas that are embedded in other schemas or only exist in-memory. For example, you can use such schemas to receive data from a command line interface and validate it, without ever persisting it elsewhere. Such structs do not contain a &lt;code&gt;__meta__&lt;/code&gt; field, as they are never persisted.</source>
          <target state="translated">반면에 &lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt; 은 다른 스키마에 포함되거나 메모리에만 존재하는 스키마를 정의하는 데 사용됩니다. 예를 들어, 이러한 스키마를 사용하여 다른 곳에서 데이터를 유지하지 않고도 명령 행 인터페이스에서 데이터를 수신하고 유효성을 검증 할 수 있습니다. 이러한 구조체 는 결코 유지 되지 않으므로 &lt;code&gt;__meta__&lt;/code&gt; 필드를 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d2b84b8ce38d79f388a7e3e997a08736c117d64b" translate="yes" xml:space="preserve">
          <source>On the other hand, close is always sync and it will return only after the channel process is guaranteed to have been terminated:</source>
          <target state="translated">반면에 close는 항상 동기화되며 채널 프로세스가 종료 된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65d55c3da40fba47f1217fe10066ca2995c32a7c" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints rely on the database and are always safe. As a consequence, validations are always checked before constraints. Constraints won&amp;rsquo;t even be checked in case validations failed.</source>
          <target state="translated">반면 제약 조건은 데이터베이스에 의존하며 항상 안전합니다. 결과적으로 유효성 검사는 항상 제약 조건보다 먼저 확인됩니다. 유효성 검사에 실패한 경우에도 제약 조건을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b488acef92fcf6178ab9bdc9c04dde91411dbec7" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints rely on the database and are always safe. As a consequence, validations are always checked before constraints. Constraints won't even be checked in case validations failed.</source>
          <target state="translated">On the other hand, constraints rely on the database and are always safe. As a consequence, validations are always checked before constraints. Constraints won't even be checked in case validations failed.</target>
        </trans-unit>
        <trans-unit id="8d9e63cf8b016d8e719e880e64557a6623ede44d" translate="yes" xml:space="preserve">
          <source>On the other hand, the proxy solution might not support end-to-end HTTP 2, limiting the benefits of the new protocol. It can also introduce operational complexities and new resource constraints, especially for long-lived connections such as WebSockets.</source>
          <target state="translated">반면에 프록시 솔루션은 종단 간 HTTP 2를 지원하지 않아 새 프로토콜의 이점을 제한 할 수 있습니다. 또한 특히 WebSocket과 같이 수명이 긴 연결의 경우 운영 복잡성과 새로운 리소스 제약을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5b64c297525a964e37acd9f2c8efa298a7088b" translate="yes" xml:space="preserve">
          <source>On the server, the &lt;code&gt;&quot;validate_wizard_step&quot;&lt;/code&gt; event is only concerned with the current client form data, but the server maintains the entire state of the wizard. To recover in this scenario, you can specify a recovery event, such as &lt;code&gt;&quot;recover_wizard&quot;&lt;/code&gt; above, which would wire up to the following server callbacks in your LiveView:</source>
          <target state="translated">서버에서 &lt;code&gt;&quot;validate_wizard_step&quot;&lt;/code&gt; 이벤트는 현재 클라이언트 양식 데이터에만 관련되지만 서버는 마법사의 전체 상태를 유지합니다. 이 시나리오에서 복구하려면 위의 &lt;code&gt;&quot;recover_wizard&quot;&lt;/code&gt; 와 같은 복구 이벤트를 지정하면됩니다.이 이벤트 는 LiveView에서 다음 서버 콜백에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="12b1ec2a89194fbb026941ac12fa16630e06149b" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; is called, Ecto will compare each parameter with the user&amp;rsquo;s already preloaded addresses and act as follows:</source>
          <target state="translated">일단 &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; 이라고 다음과 같이 체외은 사용자가 이미 주소를 미리로드있어 각 매개 변수를 비교하고 역할을합니다 :</target>
        </trans-unit>
        <trans-unit id="9a2a88d7c2caea5519ee5740b6b3fc8cb0514c3b" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; is called, Ecto will compare each parameter with the user's already preloaded addresses and act as follows:</source>
          <target state="translated">Once &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; is called, Ecto will compare each parameter with the user's already preloaded addresses and act as follows:</target>
        </trans-unit>
        <trans-unit id="e51b66d6cc36fe276b7702ba45c881391d7a1233" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is invoked, a developer may call &lt;a href=&quot;#read_part_body/2&quot;&gt;&lt;code&gt;read_part_body/2&lt;/code&gt;&lt;/a&gt; to read the body associated to the headers. If &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is called instead, the body is automatically skipped until the next part headers.</source>
          <target state="translated">일단 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; &lt;/a&gt; 호출, 개발자는 호출 할 수 있습니다 &lt;a href=&quot;#read_part_body/2&quot;&gt; &lt;code&gt;read_part_body/2&lt;/code&gt; &lt;/a&gt; 헤더에 관련된 몸을 읽을 수 있습니다. 경우 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; 가&lt;/a&gt; 대신 호출, 몸은 자동으로 다음 부분 헤더까지 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="4bffed96518285486f70feaaf4548f09e696472f" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is invoked, you may call &lt;a href=&quot;#read_part_body/2&quot;&gt;&lt;code&gt;read_part_body/2&lt;/code&gt;&lt;/a&gt; to read the body associated to the headers. If &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is called instead, the body is automatically skipped until the next part headers.</source>
          <target state="translated">일단 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; &lt;/a&gt; 호출하면 호출 할 수 &lt;a href=&quot;#read_part_body/2&quot;&gt; &lt;code&gt;read_part_body/2&lt;/code&gt; &lt;/a&gt; 헤더에 관련된 몸을 읽을 수 있습니다. 경우 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; 가&lt;/a&gt; 대신 호출, 몸은 자동으로 다음 부분 헤더까지 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9cde6048f28ae09b604393296e4461c47386d7a3" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;phx-trigger-action&lt;/code&gt; is true, LiveView disconnects and then submits the form.</source>
          <target state="translated">일단 &lt;code&gt;phx-trigger-action&lt;/code&gt; 사실이다, 다음 라이브 뷰 연결 해제하고 양식을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="0a9cc033fe6f34858df0697800cee18cd8bdf62b" translate="yes" xml:space="preserve">
          <source>Once a LiveView is disconnected, the client will attempt to reestablish the connection, re-executing the &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; callback. In this case, if the user is no longer logged in or it no longer has access to its current resource, &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; will fail and the user will be redirected to the proper page.</source>
          <target state="translated">LiveView가 연결 해제되면 클라이언트는 연결을 다시 설정하여 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 콜백을 다시 실행합니다 . 이 경우 사용자가 더 이상 로그인되어 있지 않거나 현재 리소스에 더 이상 액세스 할 수없는 경우 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 가 실패하고 사용자가 적절한 페이지로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="fdd21797e7e0035bfde10bfb17f93be00ebf4192" translate="yes" xml:space="preserve">
          <source>Once a changeset is built, it can be given to functions like &lt;code&gt;insert&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in the repository that will return an &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; tuple:</source>
          <target state="translated">변경 세트가 빌드되면 &lt;code&gt;:ok&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 튜플을 리턴하는 리포지토리의 &lt;code&gt;insert&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 와 같은 함수에 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3857ceb3c71bdbca7ddefc73f5a6c10ad83890f0" translate="yes" xml:space="preserve">
          <source>Once a connection goes through this plug, it will have &lt;code&gt;:body_params&lt;/code&gt; set to the map of params parsed by one of the parsers listed in &lt;code&gt;:parsers&lt;/code&gt; and &lt;code&gt;:params&lt;/code&gt; set to the result of merging the &lt;code&gt;:body_params&lt;/code&gt; and &lt;code&gt;:query_params&lt;/code&gt;.</source>
          <target state="translated">연결이이 플러그를 통과하면 &lt;code&gt;:body_params&lt;/code&gt; 가 &lt;code&gt;:parsers&lt;/code&gt; 및 &lt;code&gt;:params&lt;/code&gt; 에 나열된 구문 분석기 중 하나에 의해 구문 분석 된 매개 변수 맵으로 설정됩니다 &lt;code&gt;:body_params&lt;/code&gt; 및 &lt;code&gt;:query_params&lt;/code&gt; 를 병합 한 결과로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="380a226dd346505a271148d3d4c1216ac127f8f6" translate="yes" xml:space="preserve">
          <source>Once a connection is established, the transport is responsible for invoking the &lt;code&gt;Phoenix.Socket.connect/2&lt;/code&gt; callback and acting accordingly. Once connected, the transport should request the &lt;code&gt;Phoenix.Socket.id/1&lt;/code&gt; and subscribe to the topic if one exists. On subscribed, the transport must be able to handle &amp;ldquo;disconnect&amp;rdquo; broadcasts on the given id topic.</source>
          <target state="translated">연결이 설정되면 전송은 &lt;code&gt;Phoenix.Socket.connect/2&lt;/code&gt; 콜백을 호출하고 그에 따라 작동합니다. 연결되면 전송에서 &lt;code&gt;Phoenix.Socket.id/1&lt;/code&gt; 을 요청 하고 주제가 있으면 주제를 구독해야합니다. 가입하면 전송에서 지정된 ID 주제에 대한 &quot;연결 해제&quot;브로드 캐스트를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5552d73347a712fe9add3a0267c3bc2c17cb0911" translate="yes" xml:space="preserve">
          <source>Once a request arrives at the Phoenix router, it performs a series of transformations through pipelines until the request is dispatched to a desired end-point.</source>
          <target state="translated">요청이 Phoenix 라우터에 도착하면 요청이 원하는 엔드 포인트로 디스패치 될 때까지 파이프 라인을 통해 일련의 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ddc4c29e5572a7c685066f089e6f4095cbcb0223" translate="yes" xml:space="preserve">
          <source>Once a server is configured to support HTTPS it is often a good idea to redirect HTTP requests to HTTPS. To do this, include &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; in the Plug pipeline.</source>
          <target state="translated">HTTPS를 지원하도록 서버를 구성한 후에는 HTTP 요청을 HTTPS로 리디렉션하는 것이 좋습니다. 이렇게하려면 Plug 파이프 라인에 &lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 을 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="f3cc6468e75fbddaa368bc2ba46507eba00b7064" translate="yes" xml:space="preserve">
          <source>Once a template engine is defined, you can tell Phoenix about it via the template engines option:</source>
          <target state="translated">Once a template engine is defined, you can tell Phoenix about it via the template engines option:</target>
        </trans-unit>
        <trans-unit id="386c702d0645d812c90c3528534c818926a832a3" translate="yes" xml:space="preserve">
          <source>Once a token is generated, it is cached in the process dictionary. The CSRF token is usually generated inside forms which may be isolated from &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. Storing them in the process dictionary allows them to be generated as a side-effect only when necessary, becoming one of those rare situations where using the process dictionary is useful.</source>
          <target state="translated">토큰이 생성되면 프로세스 사전에 캐시됩니다. CSRF 토큰은 일반적으로 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 에서 분리 될 수있는 양식 내부에서 생성됩니다 . 프로세스 사전에 저장하면 필요할 때만 부작용으로 생성 될 수있어 프로세스 사전을 사용하는 것이 유용한 드문 상황 중 하나가됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3d9c7003e516c340b1917822b5e1bf0526bd08" translate="yes" xml:space="preserve">
          <source>Once a token is signed, we can send it to the client in multiple ways.</source>
          <target state="translated">토큰에 서명하면 여러 가지 방법으로 고객에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2216e933bee085262590e69dd46199fab1ffd90" translate="yes" xml:space="preserve">
          <source>Once added, presences can be tracked in your channel after joining:</source>
          <target state="translated">추가 한 후에는 참여 후 채널에서 현재 상태를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee9ee5ec7d246783c4767ee94f29ffc21b00bea" translate="yes" xml:space="preserve">
          <source>Once all card components are started, they can fully manage each card as a whole, without concerning themselves with the parent LiveView.</source>
          <target state="translated">모든 카드 구성 요소가 시작되면 부모 LiveView와 관계없이 각 카드를 전체적으로 완전히 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf1e5c61aafb0e177fd0ff6c7c81e5861b146f1" translate="yes" xml:space="preserve">
          <source>Once called, &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; will subscribe the current test process to the &quot;room:lobby&quot; topic and start a channel in another process. It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">Once called, &lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt; will subscribe the current test process to the &quot;room:lobby&quot; topic and start a channel in another process. It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d073a02aa6e87328220e8b4cba068be36062c496" translate="yes" xml:space="preserve">
          <source>Once called, &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; will subscribe the current test process to the &amp;ldquo;room:lobby&amp;rdquo; topic and start a channel in another process. It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt; 가 호출되면 현재 테스트 프로세스를 &quot;room : lobby&quot;주제에 구독하고 다른 프로세스에서 채널을 시작합니다. &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 또는 &lt;code&gt;{:error, reply}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="54126b811e54eb300f9e22e496c59c2167f298f5" translate="yes" xml:space="preserve">
          <source>Once connected to a socket, incoming and outgoing events are routed to channels. The incoming client data is routed to channels via transports. It is the responsibility of the socket to tie transports and channels together.</source>
          <target state="translated">소켓에 연결되면 들어오고 나가는 이벤트가 채널로 라우팅됩니다. 수신 클라이언트 데이터는 전송을 통해 채널로 라우팅됩니다. 운송과 채널을 함께 묶는 것은 소켓의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="524e784f4ac45abe4378b5f8d1367e81e826c34e" translate="yes" xml:space="preserve">
          <source>Once installed, update your endpoint's configuration to include a signing salt. You can generate a signing salt by running &lt;code&gt;mix phx.gen.secret 32&lt;/code&gt;:</source>
          <target state="translated">설치가 완료되면 서명 솔트를 포함하도록 엔드 포인트의 구성을 업데이트하십시오. &lt;code&gt;mix phx.gen.secret 32&lt;/code&gt; 를 실행하여 서명 솔트를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad6bb5d4b1e05f2b881a9eda3dafe34d1eea3b8" translate="yes" xml:space="preserve">
          <source>Once our dependencies are installed, the task will prompt us to change into our project directory and start our application.</source>
          <target state="translated">종속성이 설치되면 작업은 프로젝트 디렉토리로 변경하고 응용 프로그램을 시작하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4c58ae7399a8318ca8ef9801babe40519e13ea64" translate="yes" xml:space="preserve">
          <source>Once the LiveView is rendered, a regular HTML response is sent. In your app.js file, you should find the following:</source>
          <target state="translated">LiveView가 렌더링되면 일반 HTML 응답이 전송됩니다. app.js 파일에서 다음을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc54e2b572a7209574bfb7f869fb30ea5c136f8d" translate="yes" xml:space="preserve">
          <source>Once the client has noticed the crash during &lt;code&gt;mount&lt;/code&gt;, it will fully reload the page</source>
          <target state="translated">클라이언트가 &lt;code&gt;mount&lt;/code&gt; 하는 동안 충돌을 감지 하면 페이지를 완전히 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="fa849836704013b02bf0688391a4792e440cbe60" translate="yes" xml:space="preserve">
          <source>Once the parent changeset is given to an &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt; function, all entries will be inserted/updated/deleted within the same transaction.</source>
          <target state="translated">Once the parent changeset is given to an &lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt; function, all entries will be inserted/updated/deleted within the same transaction.</target>
        </trans-unit>
        <trans-unit id="a518c49ea343181730fb1037315f6dd6bf77a3ce" translate="yes" xml:space="preserve">
          <source>Once the process is initialized, it will receive the following message:</source>
          <target state="translated">Once the process is initialized, it will receive the following message:</target>
        </trans-unit>
        <trans-unit id="e101392ff74d32e68327b0d41cac29994c56dd53" translate="yes" xml:space="preserve">
          <source>Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set &quot;text/html&quot; as response content type) and the data is sent to the client with default status of 200.</source>
          <target state="translated">Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set &quot;text/html&quot; as response content type) and the data is sent to the client with default status of 200.</target>
        </trans-unit>
        <trans-unit id="133d0debedf679c0dc98a9cb8c0152a081388bbe" translate="yes" xml:space="preserve">
          <source>Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set &amp;ldquo;text/html&amp;rdquo; as response content type) and the data is sent to the client with default status of 200.</source>
          <target state="translated">템플리트가 렌더링되면 템플리트 형식이 응답 컨텐츠 유형으로 설정되고 (예 : HTML 템플리트가 &quot;text / html&quot;을 응답 컨텐츠 유형으로 설정 함) 데이터는 기본 상태 인 200으로 클라이언트에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5b49bac9f5d4f9ebe24ac16c036df55f5e8ddeff" translate="yes" xml:space="preserve">
          <source>Once the token is sent, the client may now send it back to the server as an authentication mechanism. For example, we can use it to authenticate a user on a Phoenix channel:</source>
          <target state="translated">토큰이 전송되면 클라이언트는 이제 인증 메커니즘으로 서버에 다시 전송할 수 있습니다. 예를 들어, 피닉스 채널에서 사용자를 인증하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1180093e732314cb8943dabd113ce0e6e4cfe5a0" translate="yes" xml:space="preserve">
          <source>Once the user first accesses the page, the request will be denied with reason 401 and the request is halted. The browser will then prompt the user for username and password. If they match, then the request succeeds.</source>
          <target state="translated">사용자가 페이지에 처음 액세스하면 요청은 이유 401로 거부되고 요청이 중지됩니다. 그러면 브라우저가 사용자에게 사용자 이름과 암호를 입력하라는 메시지를 표시합니다. 일치하면 요청이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="1f64aff5d8ac3595981631d929f8c1ff6b09fb49" translate="yes" xml:space="preserve">
          <source>Once this module is used, a callback named &lt;code&gt;handle_errors/2&lt;/code&gt; should be defined in your plug. This callback should accept a connection and a map containing:</source>
          <target state="translated">이 모듈을 사용한 후에는 &lt;code&gt;handle_errors/2&lt;/code&gt; 라는 콜백을 플러그에 정의해야합니다. 이 콜백은 연결 및 다음을 포함하는 맵을 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c79f62aff58626ef11fcf6ddfc004baaf622476" translate="yes" xml:space="preserve">
          <source>Once this module is used, a callback named &lt;code&gt;handle_errors/2&lt;/code&gt; should be defined in your plug. This callback will receive the connection already updated with a proper status code for the given exception. The second argument is a map containing:</source>
          <target state="translated">Once this module is used, a callback named &lt;code&gt;handle_errors/2&lt;/code&gt; should be defined in your plug. This callback will receive the connection already updated with a proper status code for the given exception. The second argument is a map containing:</target>
        </trans-unit>
        <trans-unit id="e30c17ab00552e113929f882924d23efa4359522" translate="yes" xml:space="preserve">
          <source>Once we have Elixir and Erlang, we are ready to install the Phoenix application generator:</source>
          <target state="translated">Elixir와 Erlang이 있으면 Phoenix 애플리케이션 생성기를 설치할 준비가 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa9632399f8c7f3abbba0f16bcf4cff569d30c39" translate="yes" xml:space="preserve">
          <source>Once we have a changeset, we can check it if it is valid.</source>
          <target state="translated">변경 세트가 있으면 유효한지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fe8595e2b22d7b996b40c74e59c9dc0449f616" translate="yes" xml:space="preserve">
          <source>Once we have our migration module ready, we can simply run &lt;code&gt;mix ecto.migrate&lt;/code&gt; to have our changes applied to the database.</source>
          <target state="translated">마이그레이션 모듈이 준비되면 &lt;code&gt;mix ecto.migrate&lt;/code&gt; 를 실행 하여 변경 사항을 데이터베이스에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d61503b2191db46e07fe1554b11ad0f53a2fd1" translate="yes" xml:space="preserve">
          <source>Once you have specified a root layout, &quot;app.html.eex&quot; will be rendered within your root layout for all non-LiveViews. You may also optionally define a &quot;live.html.leex&quot; layout to be used across all LiveViews, as we will describe in the next section.</source>
          <target state="translated">루트 레이아웃을 지정하면 LiveView가 아닌 ​​모든 루트 레이아웃 내에서 &quot;app.html.eex&quot;가 렌더링됩니다. 다음 섹션에서 설명 하겠지만 모든 LiveView에서 사용할 &quot;live.html.leex&quot;레이아웃을 선택적으로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="333c7cb99825e7a02250628ce47b4b7143a91019" translate="yes" xml:space="preserve">
          <source>One advantage of bindingless queries is that they are data-driven and therefore useful for dynamically building queries. For example, the query above could also be written as:</source>
          <target state="translated">바인딩없는 쿼리의 장점 중 하나는 데이터 기반 쿼리이므로 쿼리를 동적으로 작성하는 데 유용하다는 것입니다. 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9279410a27789475cbdf33cb95f3977eb9b02dec" translate="yes" xml:space="preserve">
          <source>One can also pass a router explicitly as an argument to the task:</source>
          <target state="translated">작업에 대한 인수로 라우터를 명시 적으로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="209832054f55ad7e3cbd8d483474917b7a556e03" translate="yes" xml:space="preserve">
          <source>One common use case for belongs to associations is to handle polymorphism. For example, imagine you have defined a Comment schema and you wish to use it for commenting on both tasks and posts.</source>
          <target state="translated">연관에 속하는 일반적인 사용 사례는 다형성을 처리하는 것입니다. 예를 들어, 주석 스키마를 정의했으며이를 태스크 및 게시물에 주석을 달 때 사용한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="dc415f8c0b228e077fb6b05a0d5169debe03fd55" translate="yes" xml:space="preserve">
          <source>One is via the meta tag:</source>
          <target state="translated">하나는 메타 태그를 통하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7136382653ef50edfc5079509c9b673392c096e2" translate="yes" xml:space="preserve">
          <source>One of the main features provided by controllers is the ability to perform content negotiation and render templates based on information sent by the client. Read &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt; to learn more.</source>
          <target state="translated">컨트롤러가 제공하는 주요 기능 중 하나는 클라이언트가 전송 한 정보를 기반으로 컨텐츠 협상을 수행하고 템플릿을 렌더링하는 기능입니다. 자세한 내용은 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="230db56c81b04dda96c9de64ff428f8a1d0537e2" translate="yes" xml:space="preserve">
          <source>One of the main responsibilities of this module is to provide convenience functions for escaping and marking HTML code as safe.</source>
          <target state="translated">이 모듈의 주요 책임 중 하나는 HTML 코드를 이스케이프하고 안전한 것으로 표시하는 편리한 기능을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d78b7cfb9e0146d7a197e88da4f8c83b813bf17" translate="yes" xml:space="preserve">
          <source>One of the most common ways to use Ecto is to interact with databases, such as Postgres and MySQL via &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt;&lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; provides many conveniences for working with SQL databases, including support for database migrations.</source>
          <target state="translated">Ecto를 사용하는 가장 일반적인 방법 중 하나는 &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt; &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; 을&lt;/a&gt; 통해 Postgres 및 MySQL과 같은 데이터베이스와 상호 작용하는 것 입니다. &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; 은 데이터베이스 마이그레이션 지원을 포함하여 SQL 데이터베이스 작업에 많은 편의를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="26b65d7e38cd0725337d9b89d756deca1cb6faca" translate="yes" xml:space="preserve">
          <source>One possible concern in this approach is that in regular HTTP requests the current user will be fetched twice: once in the HTTP request and again on &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;. You can address this by using the &lt;a href=&quot;phoenix.liveview#assign_new/3&quot;&gt;&lt;code&gt;assign_new/3&lt;/code&gt;&lt;/a&gt; function, that will reuse any of the connection assigns from the HTTP request:</source>
          <target state="translated">이 접근 방식의 한 가지 가능한 문제는 일반 HTTP 요청에서 현재 사용자가 HTTP 요청에서 한 번, &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 에서 다시 두 번 페치된다는 것 입니다. HTTP 요청에서 할당 된 연결을 재사용 하는 &lt;a href=&quot;phoenix.liveview#assign_new/3&quot;&gt; &lt;code&gt;assign_new/3&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eefd197930e8a07f4b30e58ca6a8711994d07fc" translate="yes" xml:space="preserve">
          <source>One such adapter-specific event is the &lt;code&gt;[:my_app, :repo, :query]&lt;/code&gt; event. For instance, if you want to graph query execution time, you can use the &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#summary/2&quot;&gt;&lt;code&gt;Telemetry.Metrics.summary/2&lt;/code&gt;&lt;/a&gt; function to instruct your reporter to calculate statistics of the &lt;code&gt;[:my_app, :repo, :query]&lt;/code&gt; event, like maximum, mean, percentiles etc.:</source>
          <target state="translated">이러한 어댑터 별 이벤트 중 하나는 &lt;code&gt;[:my_app, :repo, :query]&lt;/code&gt; 이벤트입니다. 예를 들어 쿼리 실행 시간을 그래프로 표시하려는 경우 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#summary/2&quot;&gt; &lt;code&gt;Telemetry.Metrics.summary/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 리포터에게 최대, 평균과 같은 &lt;code&gt;[:my_app, :repo, :query]&lt;/code&gt; 이벤트의 통계를 계산하도록 지시 할 수 있습니다. 백분위 수 등 :</target>
        </trans-unit>
        <trans-unit id="b35e8fc21fa33cd847c62b0b0e85a41a068aa1ce" translate="yes" xml:space="preserve">
          <source>Only alphanumeric characters and underscore are allowed in the callback name. Otherwise an exception is raised.</source>
          <target state="translated">콜백 이름에는 영숫자와 밑줄 만 사용할 수 있습니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="278bf6027e6334f85a23d913599b54e56b4fdc3d" translate="yes" xml:space="preserve">
          <source>Only atoms are accepted for binding names. Named binding references are expected to be placed in the tail position of the bindings list.</source>
          <target state="translated">바인딩 이름에는 원자 만 허용됩니다. 명명 된 바인딩 참조는 바인딩 목록의 꼬리 위치에 배치 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="fbfbca5c3277af03dfa1f15af228fe47e6cd94af" translate="yes" xml:space="preserve">
          <source>Only simple queries with &lt;code&gt;where&lt;/code&gt; expressions can be interpolated in join.</source>
          <target state="translated">조인 &lt;code&gt;where&lt;/code&gt; 식을 보간 할 수있는 간단한 쿼리 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f0f4128705a1e23fa1b3f0949f80eee715909ee" translate="yes" xml:space="preserve">
          <source>Only the first value of the header &lt;code&gt;key&lt;/code&gt; is updated if present.</source>
          <target state="translated">존재하는 경우 헤더 &lt;code&gt;key&lt;/code&gt; 의 첫 번째 값만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7b2b48e3e1b4ee438a5bfeb9bb433ef1ab24eb32" translate="yes" xml:space="preserve">
          <source>Open up our application layout template, &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;, and change this line,</source>
          <target state="translated">애플리케이션 레이아웃 템플릿 &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; 를 열고이 줄을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d03091eb11fe023fd9ae9571575d876bc30dd1b5" translate="yes" xml:space="preserve">
          <source>Open up your CMS context (&lt;code&gt;lib/hello/cms.ex&lt;/code&gt;), and add this new function:</source>
          <target state="translated">CMS 컨텍스트 ( &lt;code&gt;lib/hello/cms.ex&lt;/code&gt; )를 열고 다음 새 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ee3b93329a7272e4fbb9c2a60560a1241a169de2" translate="yes" xml:space="preserve">
          <source>Open up your generated &lt;code&gt;lib/hello_web/controllers/cms/page_controller.ex&lt;/code&gt; and make the following additions:</source>
          <target state="translated">생성 된 &lt;code&gt;lib/hello_web/controllers/cms/page_controller.ex&lt;/code&gt; 를 열고 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3b3a15e06a10238ca5cfcfe88dd53d2cd35f1089" translate="yes" xml:space="preserve">
          <source>Operating sockets</source>
          <target state="translated">Operating sockets</target>
        </trans-unit>
        <trans-unit id="7fa3faab6d6720fe110ace73960265700520cff2" translate="yes" xml:space="preserve">
          <source>Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server&amp;rsquo;s context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; spawned process.</source>
          <target state="translated">&lt;code&gt;handle_diff/2&lt;/code&gt; 내의 작업 &lt;em&gt;은 트래커 서버의 컨텍스트에서&lt;/em&gt; 발생 &lt;em&gt;합니다&lt;/em&gt; . 따라서 가능하면 차단 작업을 피하고 필요할 경우 감독 작업에 오프로드해야합니다. 또한 &lt;code&gt;handle_diff/2&lt;/code&gt; 의 충돌로 인해 추적 서버가 충돌하므로 서버를 충돌시킬 수있는 작업은 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 생성 프로세스 로 오프로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f69ad7b4644db4047001e046a926515928efb72f" translate="yes" xml:space="preserve">
          <source>Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server&amp;rsquo;s context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;code&gt;Task.Supervisor&lt;/code&gt; spawned process.</source>
          <target state="translated">&lt;code&gt;handle_diff/2&lt;/code&gt; 내의 작업 &lt;em&gt;은 트래커 서버의 컨텍스트에서&lt;/em&gt; 발생 &lt;em&gt;합니다&lt;/em&gt; . 따라서 가능하면 차단 작업을 피하고 필요할 경우 감독 작업에 오프로드해야합니다. 또한 &lt;code&gt;handle_diff/2&lt;/code&gt; 의 충돌로 인해 추적 서버가 충돌하므로 서버를 충돌시킬 수있는 작업은 &lt;code&gt;Task.Supervisor&lt;/code&gt; 생성 프로세스 로 오프로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b12143ad7d69d60775a293c5afc612e87140f96" translate="yes" xml:space="preserve">
          <source>Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server's context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; spawned process.</source>
          <target state="translated">Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server's context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; spawned process.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="832d17728f477b6af233a37ce757a299695d6661" translate="yes" xml:space="preserve">
          <source>Opposite to casting, dumping requires the returned value to be a valid Ecto type, as it will be sent to the underlying data store.</source>
          <target state="translated">캐스팅과 반대로 덤프는 반환 된 값이 기본 데이터 저장소로 전송되므로 유효한 Ecto 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="edae6c4c00b3af9b0faeebfa1ddc67a4bcd1563d" translate="yes" xml:space="preserve">
          <source>Opposite to other validations, calling this function does not store the validation under the &lt;code&gt;changeset.validations&lt;/code&gt; key. Instead, it stores all required fields under &lt;code&gt;changeset.required&lt;/code&gt;.</source>
          <target state="translated">Opposite to other validations, calling this function does not store the validation under the &lt;code&gt;changeset.validations&lt;/code&gt; key. Instead, it stores all required fields under &lt;code&gt;changeset.required&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465829d5307e0ace671c108d4b60686a9e377efc" translate="yes" xml:space="preserve">
          <source>Optgroups</source>
          <target state="translated">Optgroups</target>
        </trans-unit>
        <trans-unit id="7703fdb524069df80a1e25bcd374d8ad6110df6d" translate="yes" xml:space="preserve">
          <source>Optimistic locking also works with delete operations. Just call the &lt;a href=&quot;#optimistic_lock/3&quot;&gt;&lt;code&gt;optimistic_lock/3&lt;/code&gt;&lt;/a&gt; function with the data before delete:</source>
          <target state="translated">낙관적 잠금은 삭제 작업에서도 작동합니다. 삭제하기 전에 데이터로 &lt;a href=&quot;#optimistic_lock/3&quot;&gt; &lt;code&gt;optimistic_lock/3&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c33b27870c2dbee62bb5ca496fad21de8d31ef5" translate="yes" xml:space="preserve">
          <source>Optimistic locking works by keeping a &quot;version&quot; counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</source>
          <target state="translated">Optimistic locking works by keeping a &quot;version&quot; counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</target>
        </trans-unit>
        <trans-unit id="5a9d530cb8c562cac44d93379e9a5d57513ac6e9" translate="yes" xml:space="preserve">
          <source>Optimistic locking works by keeping a &amp;ldquo;version&amp;rdquo; counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</source>
          <target state="translated">낙관적 잠금은 각 레코드에 대해 &quot;버전&quot;카운터를 유지함으로써 작동합니다. 이 카운터는 레코드를 수정할 때마다 증가합니다. 따라서 낙관적 잠금을 사용하려면 버전 관리를 위해 스키마에 필드가 있어야합니다. 이러한 필드는 일반적으로 정수이지만 다른 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6080dd3f6316b79c1e99b9219c5e9c4e943bd5fb" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;pool_opts&lt;/code&gt;:</source>
          <target state="translated">선택적 &lt;code&gt;pool_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e352cc634bcbd875f9a3d76f49b8b7b037fb1d9" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;server_opts&lt;/code&gt;:</source>
          <target state="translated">선택적 &lt;code&gt;server_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="252b17be73d7596d917bab75758c48cd96bad3fa" translate="yes" xml:space="preserve">
          <source>Optionally function can accept three arguments: &lt;code&gt;changeset&lt;/code&gt;, &lt;code&gt;field&lt;/code&gt; and error tuple &lt;code&gt;{msg, opts}&lt;/code&gt;. It is useful whenever you want to extract validations rules from &lt;code&gt;changeset.validations&lt;/code&gt; to build detailed error description.</source>
          <target state="translated">선택적으로 함수는 &lt;code&gt;changeset&lt;/code&gt; , &lt;code&gt;field&lt;/code&gt; 및 error tuple &lt;code&gt;{msg, opts}&lt;/code&gt; 세 가지 인수를 사용할 수 있습니다 . &lt;code&gt;changeset.validations&lt;/code&gt; 에서 유효성 검사 규칙을 추출 하여 자세한 오류 설명을 작성할 때마다 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="6011f39be2f926fbdab3c480bd16a247893c32f1" translate="yes" xml:space="preserve">
          <source>Options should be passed before the &lt;code&gt;do&lt;/code&gt; block like this:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;do&lt;/code&gt; 블록 앞에 옵션을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8599218f8739559f74b77f86fffce79e4072789e" translate="yes" xml:space="preserve">
          <source>Options: &lt;code&gt;%{log: Logger.level | false}&lt;/code&gt;</source>
          <target state="translated">Options: &lt;code&gt;%{log: Logger.level | false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ec863e019b6e94ecc3cfbe5e6b680390f64a1e8" translate="yes" xml:space="preserve">
          <source>Or a custom MFA function:</source>
          <target state="translated">Or a custom MFA function:</target>
        </trans-unit>
        <trans-unit id="16064f1b4545ef550fcb61614eaca19e1afda642" translate="yes" xml:space="preserve">
          <source>Or all comments in a given table:</source>
          <target state="translated">또는 주어진 표의 모든 의견 :</target>
        </trans-unit>
        <trans-unit id="d1a50ae16efbaca88cc2228114460371a17c9c17" translate="yes" xml:space="preserve">
          <source>Or an endpoint that returns it:</source>
          <target state="translated">또는 그것을 반환하는 끝점 :</target>
        </trans-unit>
        <trans-unit id="8cb668e6fd819227fd1383bd796114922f4a2e87" translate="yes" xml:space="preserve">
          <source>Or as a where condition:</source>
          <target state="translated">Or as a where condition:</target>
        </trans-unit>
        <trans-unit id="82dff2c911db7417fc0789a07848db764d6e5c6a" translate="yes" xml:space="preserve">
          <source>Or as part of a pipeline like this:</source>
          <target state="translated">Or as part of a pipeline like this:</target>
        </trans-unit>
        <trans-unit id="958651d2d7053b9596a4e08cea4d89b818dabca7" translate="yes" xml:space="preserve">
          <source>Or can be used to show or hide parts of the template:</source>
          <target state="translated">또는 템플릿의 일부를 표시하거나 숨기는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c60aaacf0e71b59a7197b091439347ab628cef" translate="yes" xml:space="preserve">
          <source>Or creating a changeset from a simple map with types:</source>
          <target state="translated">또는 유형이있는 간단한 맵에서 변경 세트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab68c6440b65a81745c8da96a580e0571274dd1d" translate="yes" xml:space="preserve">
          <source>Or even assert something was broadcast into pubsub:</source>
          <target state="translated">또는 무언가가 pubsub에 방송되었다고 주장하기도합니다.</target>
        </trans-unit>
        <trans-unit id="1d003458b7bc5539864c0a23e25a6fa8ac04297d" translate="yes" xml:space="preserve">
          <source>Or even dynamically:</source>
          <target state="translated">또는 동적으로 :</target>
        </trans-unit>
        <trans-unit id="712f44bbae8ee984dfa9d49047b6bc225ad6e612" translate="yes" xml:space="preserve">
          <source>Or even say the right side is of the same type as &lt;code&gt;p.title&lt;/code&gt;:</source>
          <target state="translated">또는 오른쪽이 &lt;code&gt;p.title&lt;/code&gt; 과 동일한 유형이라고 말하십시오 .</target>
        </trans-unit>
        <trans-unit id="d33c077786749f9e9de6fab195958ab7831aea1d" translate="yes" xml:space="preserve">
          <source>Or if using MySQL:</source>
          <target state="translated">또는 MySQL을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="8489447b12c50bb6facab6fdc14fd190e3be42e7" translate="yes" xml:space="preserve">
          <source>Or if you would rather put those in a config file:</source>
          <target state="translated">또는 구성 파일에 넣으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ff0dcc57ed98ff60cf6f15da1aa9afd43a8a3840" translate="yes" xml:space="preserve">
          <source>Or maybe you have a subdomain based URL for different organizations:</source>
          <target state="translated">또는 여러 조직에 대한 하위 도메인 기반 URL이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d2db8c0dea9cfa12e2dc31cd92ed981b86c925" translate="yes" xml:space="preserve">
          <source>Or only invoke the Endpoint&amp;rsquo;s plugs:</source>
          <target state="translated">또는 엔드 포인트의 플러그 만 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="0a0eff2f301b498afea7c7d959e2160fd790226d" translate="yes" xml:space="preserve">
          <source>Or to type aggregation results:</source>
          <target state="translated">또는 집계 결과를 입력하려면</target>
        </trans-unit>
        <trans-unit id="ac0551f45123b16a0b4e730672b87a1036336a05" translate="yes" xml:space="preserve">
          <source>Or to type fields from schemaless queries:</source>
          <target state="translated">또는 스키마없는 쿼리에서 필드를 입력하려면</target>
        </trans-unit>
        <trans-unit id="db83fd402c11cf8159d1e10f0e61b02924ea765b" translate="yes" xml:space="preserve">
          <source>Or we can simply set the post_id in the comment itself:</source>
          <target state="translated">또는 단순히 주석 자체에서 post_id를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb25deca5f5b67aa36a9aca437ad824b5dab3b0c" translate="yes" xml:space="preserve">
          <source>Or when preloading:</source>
          <target state="translated">또는 사전로드시 :</target>
        </trans-unit>
        <trans-unit id="c0bf61bd202cb1f5bb98ec5bf92435c88154d70a" translate="yes" xml:space="preserve">
          <source>Or without the HTML and JS bits (useful for APIs):</source>
          <target state="translated">또는 HTML 및 JS 비트없이 (API에 유용) :</target>
        </trans-unit>
        <trans-unit id="cdbfe7b3f351402b648ee804a0064e3fbe469475" translate="yes" xml:space="preserve">
          <source>Or you can &lt;code&gt;live_render&lt;/code&gt; your view from any controller:</source>
          <target state="translated">또는 모든 컨트롤러에서 뷰를 &lt;code&gt;live_render&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f96bbe5888ef217ac0d38c0b51ac749535eac349" translate="yes" xml:space="preserve">
          <source>Or you can change it anytime at runtime by calling &lt;code&gt;put_dynamic_repo/1&lt;/code&gt;:</source>
          <target state="translated">Or you can change it anytime at runtime by calling &lt;code&gt;put_dynamic_repo/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4768bd40f3882dca8a91264190d40d76952f751b" translate="yes" xml:space="preserve">
          <source>Or you could attach your own custom behavior.</source>
          <target state="translated">또는 자신 만의 사용자 지정 동작을 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8a0533f62dac6b40c92e109599a2e940602b55b" translate="yes" xml:space="preserve">
          <source>Or you could use the &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#distribution/2&quot;&gt;&lt;code&gt;Telemetry.Metrics.distribution/2&lt;/code&gt;&lt;/a&gt; function to define a histogram for another adapter-specific event: &lt;code&gt;[:my_app, :repo, :query, :queue_time]&lt;/code&gt;, thus visualizing how long queries spend queued:</source>
          <target state="translated">또는 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#distribution/2&quot;&gt; &lt;code&gt;Telemetry.Metrics.distribution/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 다른 어댑터 별 이벤트에 대한 히스토그램을 정의 할 수 있습니다 . &lt;code&gt;[:my_app, :repo, :query, :queue_time]&lt;/code&gt; , 따라서 쿼리가 대기하는 데 걸리는 시간을 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b89dc25eda26d94696c5e348b38324b069651aba" translate="yes" xml:space="preserve">
          <source>Or, using Visual Studio Code:</source>
          <target state="translated">Or, using Visual Studio Code:</target>
        </trans-unit>
        <trans-unit id="79aa5e012d340daabf02aa4645be1ac4c8831a14" translate="yes" xml:space="preserve">
          <source>Orders the fields based on one or more fields. It accepts a single field or a list of fields. The default direction is ascending (&lt;code&gt;:asc&lt;/code&gt;) and can be customized in a keyword list as one of the following:</source>
          <target state="translated">하나 이상의 필드를 기준으로 필드를 정렬합니다. 단일 필드 또는 필드 목록을 허용합니다. 기본 방향은 오름차순 ( &lt;code&gt;:asc&lt;/code&gt; )이며 키워드 목록에서 다음 중 하나로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f401fbecb15cdf2fd5c7b0bddd80710df34a5c9b" translate="yes" xml:space="preserve">
          <source>Other (optional) arguments:</source>
          <target state="translated">기타 (선택 사항) 인수 :</target>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="cecef7b4b9031469617c3480b016645bf039da43" translate="yes" xml:space="preserve">
          <source>Other options will be passed as html attributes. ie, &lt;code&gt;class: &quot;foo&quot;, id: &quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">다른 옵션은 html 속성으로 전달됩니다. 즉, &lt;code&gt;class: &quot;foo&quot;, id: &quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7c4b57295a40e5f3e757610ef1f4a955b58ae43" translate="yes" xml:space="preserve">
          <source>Other topics</source>
          <target state="translated">다른 주제</target>
        </trans-unit>
        <trans-unit id="5a210eca2b390795c62e881581895a0e75cf0b6a" translate="yes" xml:space="preserve">
          <source>Otherwise a 403 Forbidden response will be sent and the connection halted. It is a noop if the connection has been halted.</source>
          <target state="translated">그렇지 않으면 403 Forbidden 응답이 전송되고 연결이 중지됩니다. 연결이 중단 된 경우 이는 noop입니다.</target>
        </trans-unit>
        <trans-unit id="2b4a0bc39a6815eb69b677161d53d542e530f9f8" translate="yes" xml:space="preserve">
          <source>Otherwise, the request will be redirected to a corresponding location with the &lt;code&gt;https&lt;/code&gt; scheme by setting the &lt;code&gt;location&lt;/code&gt; header of the response. The status code will be 301 if the method of &lt;code&gt;conn&lt;/code&gt; is &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;, or 307 in other situations.</source>
          <target state="translated">그렇지 않으면 응답 의 &lt;code&gt;location&lt;/code&gt; 헤더를 설정 하여 요청이 &lt;code&gt;https&lt;/code&gt; 체계 를 사용하여 해당 위치로 리디렉션됩니다 . &lt;code&gt;conn&lt;/code&gt; 방법 이 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 이면 상태 코드는 301이고 다른 상황에서는 307입니다.</target>
        </trans-unit>
        <trans-unit id="addeb7742f87f3b1575bcea550d015ebadb259c8" translate="yes" xml:space="preserve">
          <source>Otherwise, use &lt;a href=&quot;#socket/2&quot;&gt;&lt;code&gt;socket/2&lt;/code&gt;&lt;/a&gt; if you want to build a socket with id and assigns.</source>
          <target state="translated">그렇지 않으면 id와 assign을 사용하여 소켓을 빌드 하려면 &lt;a href=&quot;#socket/2&quot;&gt; &lt;code&gt;socket/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="98de8ee859797bd8c92402d4e6f5b73f619a19fb" translate="yes" xml:space="preserve">
          <source>Otherwise, use &lt;a href=&quot;#socket/3&quot;&gt;&lt;code&gt;socket/3&lt;/code&gt;&lt;/a&gt; if you want to build a socket with existing id and assigns.</source>
          <target state="translated">Otherwise, use &lt;a href=&quot;#socket/3&quot;&gt; &lt;code&gt;socket/3&lt;/code&gt; &lt;/a&gt; if you want to build a socket with existing id and assigns.</target>
        </trans-unit>
        <trans-unit id="db3e93650111f461dea9719b2bd8fe8b9eede958" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Author&lt;/code&gt; resource serves to keep the responsibilities of representing an author inside the CMS, but ultimately for an author to exist at all, an end-user represented by an &lt;code&gt;Accounts.User&lt;/code&gt; must be present. Given this, our &lt;code&gt;CMS&lt;/code&gt; context will have a data dependency on the &lt;code&gt;Accounts&lt;/code&gt; context. With that in mind, we have two options. One is to expose APIs on the &lt;code&gt;Accounts&lt;/code&gt; contexts that allows us to efficiently fetch user data for use in the CMS system, or we can use database joins to fetch the dependent data. Both are valid options given your tradeoffs and application size, but joining data from the database when you have a hard data dependency is just fine for a large class of applications. If you decide to break out coupled contexts into entirely separate applications and databases at a later time, you still gain the benefits of isolation. This is because your public context APIs will likely remain unchanged.</source>
          <target state="translated">우리의 &lt;code&gt;Author&lt;/code&gt; 리소스는 CMS 내에서 작성자를 대표하는 책임을 유지하는 역할을하지만 궁극적으로 작성자가 존재하려면 &lt;code&gt;Accounts.User&lt;/code&gt; 가 대표하는 최종 사용자가 있어야합니다. 이를 감안할 때 &lt;code&gt;CMS&lt;/code&gt; 컨텍스트는 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트 에 대한 데이터 종속성을 갖습니다 . 이를 염두에두고 두 가지 옵션이 있습니다. 하나는 &lt;code&gt;Accounts&lt;/code&gt; API를 노출하는 것입니다.CMS 시스템에서 사용할 사용자 데이터를 효율적으로 가져올 수있는 컨텍스트를 제공하거나 데이터베이스 조인을 사용하여 종속 데이터를 가져올 수 있습니다. 둘 다 장단점과 응용 프로그램 크기를 고려할 때 유효한 옵션이지만 데이터 종속성이 높을 때 데이터베이스에서 데이터를 결합하는 것은 대규모 응용 프로그램 클래스에 적합합니다. 나중에 결합 된 컨텍스트를 완전히 별개의 응용 프로그램과 데이터베이스로 분리하기로 결정한 경우에도 여전히 격리의 이점을 얻을 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이는 공용 컨텍스트 API가 변경되지 않을 가능성이 높기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="68809848c21f8d08d6a61c41c646c42bb2d530ea" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Hello.Repo&lt;/code&gt; module is the foundation we need to work with databases in a Phoenix application. Phoenix generated it for us in &lt;code&gt;lib/hello/repo.ex&lt;/code&gt;, and this is what it looks like.</source>
          <target state="translated">우리 &lt;code&gt;Hello.Repo&lt;/code&gt; 의 모듈은 우리가 피닉스 응용 프로그램에서 데이터베이스 작업에 필요한 기초입니다. Phoenix는 우리를 위해 &lt;code&gt;lib/hello/repo.ex&lt;/code&gt; 에서 생성했으며 이것이 어떻게 생겼는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1d7a7a5788c673d7a0b479765bf324ffeec73915" translate="yes" xml:space="preserve">
          <source>Our CMS context supports lazily creating authors in the system when a user decides to publish page content. This makes sense for our use case because not all users of our system will be CMS authors. But what if our use case were for when all users of our app are indeed authors?</source>
          <target state="translated">우리의 CMS 컨텍스트는 사용자가 페이지 콘텐츠를 게시하기로 결정할 때 시스템에서 저자를 느리게 생성하는 것을 지원합니다. 이것은 우리 시스템의 모든 사용자가 CMS 작성자가 아니기 때문에 우리의 사용 사례에 적합합니다. 하지만 우리 앱의 모든 사용자가 실제로 작성자 일 때 사용 사례가 있다면 어떨까요?</target>
        </trans-unit>
        <trans-unit id="e3c279505904e1dcbe28e9a3c7179d05739940b2" translate="yes" xml:space="preserve">
          <source>Our CMS system requires an author to exist for any end-user before they publish posts, so we added an &lt;code&gt;ensure_author_exists&lt;/code&gt; function to programmatically allow authors to be created. Our new function accepts an &lt;code&gt;Accounts.User&lt;/code&gt; struct and either finds the existing author in the application with that &lt;code&gt;user.id&lt;/code&gt;, or creates a new author for the user. Our authors table has a unique constraint on the &lt;code&gt;user_id&lt;/code&gt; foreign key, so we are protected from a race condition allowing duplicate authors. That said, we still need to protect ourselves from racing the insert of another user. To accomplish this, we use a purpose-built changeset with &lt;code&gt;Ecto.Changeset.change/1&lt;/code&gt; which accepts a new &lt;code&gt;Author&lt;/code&gt; struct with our &lt;code&gt;user_id&lt;/code&gt;. The changeset's only purpose is to convert a unique constraint violation into an error we can handle. After attempting to insert the new author with &lt;code&gt;Repo.insert/1&lt;/code&gt;, we pipe to &lt;code&gt;handle_existing_author/1&lt;/code&gt; which matches on the success and error cases. For the success case, we are done and simply return the created author, otherwise we use &lt;code&gt;Repo.get_by!&lt;/code&gt; to fetch the author for the &lt;code&gt;user_id&lt;/code&gt; that already exists.</source>
          <target state="translated">CMS 시스템은 최종 사용자가 게시물을 게시하기 전에 작성자가 있어야하므로, 작성자 가 프로그래밍 방식으로 생성 될 수 있도록 &lt;code&gt;ensure_author_exists&lt;/code&gt; 함수를 추가했습니다 . 우리의 새 함수는 &lt;code&gt;Accounts.User&lt;/code&gt; 구조체를 받아들이고 해당 &lt;code&gt;user.id&lt;/code&gt; 를 사용하여 애플리케이션에서 기존 작성자를 찾 거나 사용자에 대한 새 작성자를 만듭니다. authors 테이블에는 &lt;code&gt;user_id&lt;/code&gt; 외래 키 에 대한 고유 한 제약 조건이 있으므로 중복 작성자를 허용하는 경쟁 조건으로부터 보호됩니다. 즉, 우리는 여전히 다른 사용자의 삽입물을 경주하는 것으로부터 우리 자신을 보호해야합니다. 이를 달성하기 위해 우리 는 새로운 &lt;code&gt;Author&lt;/code&gt; 를 받아들이는 &lt;code&gt;Ecto.Changeset.change/1&lt;/code&gt; 과 함께 목적에 맞게 만들어진 변경 세트를 사용합니다. &lt;code&gt;user_id&lt;/code&gt; 를 가진 구조체 . 변경 세트의 유일한 목적은 고유 한 제약 조건 위반을 처리 할 수있는 오류로 변환하는 것입니다. &lt;code&gt;Repo.insert/1&lt;/code&gt; 을 사용하여 새 작성자를 삽입하려고 시도한 후 성공 및 오류 케이스와 일치 하는 &lt;code&gt;handle_existing_author/1&lt;/code&gt; 로 파이프합니다 . 성공 사례의 경우 완료되고 생성 된 작성자를 반환합니다. 그렇지 않으면 &lt;code&gt;Repo.get_by!&lt;/code&gt; 를 사용 합니다! 이미 존재 하는 &lt;code&gt;user_id&lt;/code&gt; 의 작성자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f551741a4b37224559b58ec369b3afe56b5a6db0" translate="yes" xml:space="preserve">
          <source>Our Plug simply prints information from the connection. Although our initial Plug is very simple, you can virtually do anything you want inside of it. To learn about all fields available in the connection and all of the functionality associated to it, &lt;a href=&quot;../plug/plug.conn&quot;&gt;see the documentation for Plug.Conn&lt;/a&gt;.</source>
          <target state="translated">플러그는 단순히 연결에서 정보를 인쇄합니다. 초기 Plug는 매우 간단하지만 내부에서 원하는 모든 작업을 가상으로 수행 할 수 있습니다. 연결에서 사용할 수있는 모든 필드 및 이와 관련된 모든 기능에 &lt;a href=&quot;../plug/plug.conn&quot;&gt;대한 자세한 내용은 Plug.Conn 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b1e5820194d31d170679714ddf4d30123dd14fc" translate="yes" xml:space="preserve">
          <source>Our basic user account features are nice, but let's take it up a notch by supporting user login credentials. We won't implement a complete authentication system, but we'll give ourselves a good start to grow such a system from. Many authentication solutions couple the user credentials to an account in a one-to-one fashion, but this often causes issues. For example, supporting different login methods, such as social login or recovery email addresses, will cause major code changes. Let's set up a credentials association that will allow us to start off tracking a single credential per account, but easily support more features later.</source>
          <target state="translated">우리의 기본 사용자 계정 기능은 훌륭하지만 사용자 로그인 자격 증명을 지원하여 한 단계 더 나아가 보겠습니다. 우리는 완전한 인증 시스템을 구현하지는 않을 것이지만 그러한 시스템을 성장시킬 수있는 좋은 출발을 할 것입니다. 많은 인증 솔루션이 사용자 자격 증명을 일대일 방식으로 계정에 연결하지만 이로 인해 종종 문제가 발생합니다. 예를 들어 소셜 로그인 또는 복구 이메일 주소와 같은 다른 로그인 방법을 지원하면 주요 코드가 변경됩니다. 계정 당 단일 자격 증명 추적을 시작할 수 있지만 나중에 더 많은 기능을 쉽게 지원할 수있는 자격 증명 연결을 설정해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1d7313084c8b21ce4f0507cf9bc4af3941bf7220" translate="yes" xml:space="preserve">
          <source>Our messenger appears as &lt;code&gt;@messenger&lt;/code&gt;. We call &quot;assigns&quot; the values passed from the controller to views. It is a special bit of metaprogrammed syntax which stands in for &lt;code&gt;assigns.messenger&lt;/code&gt;. The result is much nicer on the eyes and much easier to work with in a template.</source>
          <target state="translated">메신저는 &lt;code&gt;@messenger&lt;/code&gt; 로 나타납니다 . 컨트롤러에서 뷰로 전달 된 값을 &quot;할당&quot;이라고합니다. 이는 &lt;code&gt;assigns.messenger&lt;/code&gt; 를 의미하는 특별한 메타 프로그래밍 구문입니다 . 결과는 눈에 훨씬 좋고 템플릿에서 작업하기가 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3e1a826396e2650c0700a8a180a28a7e80d4ff12" translate="yes" xml:space="preserve">
          <source>Our new changeset is valid.</source>
          <target state="translated">새로운 변경 세트가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="0ebdf80b83f5cf65aea1da4db1b10ea5b8df21b5" translate="yes" xml:space="preserve">
          <source>Our repo has three main tasks - to bring in all the common query functions from &lt;code&gt;Ecto.Repo&lt;/code&gt;, to set the &lt;code&gt;otp_app&lt;/code&gt; name equal to our application name, and to configure our database adapter. We'll talk more about how to use the Repo in a bit.</source>
          <target state="translated">&lt;code&gt;Ecto.Repo&lt;/code&gt; 에는 Ecto.Repo 에서 모든 공통 쿼리 함수를 가져 오고 , &lt;code&gt;otp_app&lt;/code&gt; 이름을 애플리케이션 이름과 동일하게 설정하고, 데이터베이스 어댑터를 구성하는 세 가지 주요 작업 이 있습니다. Repo를 사용하는 방법에 대해 조금 더 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6d8972b6dba015c1daf133c9edf1cee72a9b5d92" translate="yes" xml:space="preserve">
          <source>Outgoing messages</source>
          <target state="translated">발신 메시지</target>
        </trans-unit>
        <trans-unit id="60fc0ce740f5da61976d79aad4218eb0450789ff" translate="yes" xml:space="preserve">
          <source>Outlines the Socket &amp;lt;-&amp;gt; Transport communication.</source>
          <target state="translated">Outlines the Socket &amp;lt;-&amp;gt; Transport communication.</target>
        </trans-unit>
        <trans-unit id="84cb499e9d8f2b1a971bcb1ebcff17a6e1eb8b67" translate="yes" xml:space="preserve">
          <source>Overall, an endpoint has three responsibilities:</source>
          <target state="translated">전반적으로 엔드 포인트에는 세 가지 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f8b79088a96e524e81ddc616fb358f5f139825" translate="yes" xml:space="preserve">
          <source>Overall, here is the prefix lookup precedence:</source>
          <target state="translated">전반적으로 접두사 조회 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fcd60e01af70e78edbf181b1214f759e3a283fb" translate="yes" xml:space="preserve">
          <source>Overall, this generator will add the following files to &lt;code&gt;lib/&lt;/code&gt;:</source>
          <target state="translated">전체적으로이 생성기는 다음 파일을 &lt;code&gt;lib/&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2acf5b862691be6f62e2449d6e2615f813f2f508" translate="yes" xml:space="preserve">
          <source>Overall, this generator will add the following files to &lt;code&gt;lib/your_app&lt;/code&gt;:</source>
          <target state="translated">Overall, this generator will add the following files to &lt;code&gt;lib/your_app&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec88af88a4c0ef32ab8fb8dc8407ea440260105d" translate="yes" xml:space="preserve">
          <source>Overall, this generator will add the following files to lib/your_app:</source>
          <target state="translated">전체적으로이 생성기는 다음 파일을 lib / your_app에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bf7bf06f552fe77c7ba87a6f84518b320f5d186a" translate="yes" xml:space="preserve">
          <source>Overall, those layouts are found in &lt;code&gt;templates/layout&lt;/code&gt; with the following names:</source>
          <target state="translated">전반적으로 이러한 레이아웃은 다음 이름의 &lt;code&gt;templates/layout&lt;/code&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="956e1158a7f55f29402094f48543f47fda3b3cf0" translate="yes" xml:space="preserve">
          <source>Overriding &lt;code&gt;action/2&lt;/code&gt; for custom arguments</source>
          <target state="translated">맞춤 인수에 대한 &lt;code&gt;action/2&lt;/code&gt; 재정의</target>
        </trans-unit>
        <trans-unit id="25927715135873aac41c2a150bbab494316a6f61" translate="yes" xml:space="preserve">
          <source>Overriding Rendering Formats</source>
          <target state="translated">렌더링 형식 재정의</target>
        </trans-unit>
        <trans-unit id="0fe592ea3722f7a45e73af399dbc7308e1cb79b2" translate="yes" xml:space="preserve">
          <source>Overriding the default Plug API functions</source>
          <target state="translated">기본 Plug API 함수 재정의</target>
        </trans-unit>
        <trans-unit id="9475f5f883622c29630c91241f765fa4e8a2d1e6" translate="yes" xml:space="preserve">
          <source>Overriding the default confirm behaviour</source>
          <target state="translated">기본 확인 동작 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d9fc53f6f5c5e30d53c01944f4976707146eee68" translate="yes" xml:space="preserve">
          <source>Page and data navigation - such as navigating between pages, pagination, etc can be built with LiveView using the excellent live navigation feature set. This reduces the amount of data sent over the wire, gives developers full control over the LiveView life-cycle, while controlling how the browser tracks those changes in state;</source>
          <target state="translated">페이지 간 탐색, 페이지 매김 등과 같은 페이지 및 데이터 탐색은 뛰어난 라이브 탐색 기능 세트를 사용하여 LiveView로 구축 할 수 있습니다. 이렇게하면 유선을 통해 전송되는 데이터의 양이 줄어들고 개발자가 LiveView 수명주기를 완벽하게 제어하는 ​​동시에 브라우저가 상태 변경을 추적하는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb2471f8e6552b517fb9675c568592a1bca1d4a" translate="yes" xml:space="preserve">
          <source>Page creation and updates</source>
          <target state="translated">페이지 생성 및 업데이트</target>
        </trans-unit>
        <trans-unit id="df2f5a899b8025b4f81f380e99b9ad1cade18348" translate="yes" xml:space="preserve">
          <source>Pages belong to Authors who are responsible for publishing changes</source>
          <target state="translated">페이지는 변경 사항 게시를 담당하는 작성자에게 속합니다.</target>
        </trans-unit>
        <trans-unit id="021d2cddbf4abaf710484feba4bf51af8bac6435" translate="yes" xml:space="preserve">
          <source>Parameter Parsing</source>
          <target state="translated">파라미터 파싱</target>
        </trans-unit>
        <trans-unit id="540251aeff537e785f0090e4cc24f62d368a649b" translate="yes" xml:space="preserve">
          <source>Parameter filtering</source>
          <target state="translated">파라미터 필터링</target>
        </trans-unit>
        <trans-unit id="5eb03398aca0d53fd13adbb88570ba9bce20d46f" translate="yes" xml:space="preserve">
          <source>Parameter filtering on join</source>
          <target state="translated">결합시 매개 변수 필터링</target>
        </trans-unit>
        <trans-unit id="b62573538900d52f69421fef6d67c0a5eaca90d4" translate="yes" xml:space="preserve">
          <source>Parameter lists are added to the accumulator in reverse order, so be sure to pass the parameters in reverse order.</source>
          <target state="translated">매개 변수 목록은 누적기에 역순으로 추가되므로 매개 변수를 역순으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e17741d9465fdb853c64a093ceff9ae3d17ec8f3" translate="yes" xml:space="preserve">
          <source>Parameterized types allow a set of options to be specified in the schema which are initialized on compilation and passed to the callback functions as the last argument.</source>
          <target state="translated">매개 변수화 된 유형을 사용하면 컴파일시 초기화되고 마지막 인수로 콜백 함수에 전달되는 스키마에 옵션 세트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0cf9692f101d065db4a03747ddabad0753ad60" translate="yes" xml:space="preserve">
          <source>Parameterized types are Ecto types that can be customized per field.</source>
          <target state="translated">매개 변수화 된 유형은 필드별로 사용자 정의 할 수있는 Ecto 유형입니다.</target>
        </trans-unit>
        <trans-unit id="927a5198c9360734a1aa5544624f1270c44f24fa" translate="yes" xml:space="preserve">
          <source>Parameterized types are a superset of regular types. In other words, with parameterized types you can do everything a regular type does, and more. For example, parameterized types can handle &lt;code&gt;nil&lt;/code&gt; values in both &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;dump&lt;/code&gt; callbacks, they can customize &lt;code&gt;cast&lt;/code&gt; behavior per query and per changeset, and also control how values are embedded.</source>
          <target state="translated">매개 변수화 된 유형은 일반 유형의 상위 세트입니다. 즉, 매개 변수화 된 유형을 사용하면 일반 유형이 수행하는 모든 작업 등을 수행 할 수 있습니다. 예를 들어, 매개 변수화 된 유형은 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;dump&lt;/code&gt; 콜백 모두에서 &lt;code&gt;nil&lt;/code&gt; 값을 처리 할 수 있으며, 쿼리 및 변경 세트별로 &lt;code&gt;cast&lt;/code&gt; 동작을 사용자 정의 할 수 있으며 값이 포함되는 방법을 제어 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd05340d4075cf1f86308b962f75f4753adec47" translate="yes" xml:space="preserve">
          <source>Parameters and body</source>
          <target state="translated">매개 변수 및 본문</target>
        </trans-unit>
        <trans-unit id="dc124689c7040d627a2c6490eec999443990ba30" translate="yes" xml:space="preserve">
          <source>Params</source>
          <target state="translated">Params</target>
        </trans-unit>
        <trans-unit id="0cae913f273763644fc1ea065cefbe7c81c8a50c" translate="yes" xml:space="preserve">
          <source>Params are decoded as &amp;ldquo;x-www-form-urlencoded&amp;rdquo; in which key/value pairs are separated by &lt;code&gt;&amp;amp;&lt;/code&gt; and keys are separated from values by &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &quot;x-www-form-urlencoded&quot;로 디코딩되며 여기서 키 / 값 쌍은 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 구분되고 키는 &lt;code&gt;=&lt;/code&gt; 로 값과 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="84ce6a25f9333e1074169cfa4096ad3c1ac96944" translate="yes" xml:space="preserve">
          <source>Params are decoded as &lt;code&gt;&quot;x-www-form-urlencoded&quot;&lt;/code&gt; in which key/value pairs are separated by &lt;code&gt;&amp;amp;&lt;/code&gt; and keys are separated from values by &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;&quot;x-www-form-urlencoded&quot;&lt;/code&gt; 로 디코딩되며 여기서 키 / 값 쌍은 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 구분되고 키는 &lt;code&gt;=&lt;/code&gt; 로 값과 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bc818adf9596d6f8e72d5ebb319e14d2d8ad77" translate="yes" xml:space="preserve">
          <source>Parsers may raise a &lt;a href=&quot;plug.parsers.parseerror&quot;&gt;&lt;code&gt;Plug.Parsers.ParseError&lt;/code&gt;&lt;/a&gt; if the request has a malformed body.</source>
          <target state="translated">요청에 잘못된 본문이있는 경우 파서에서 &lt;a href=&quot;plug.parsers.parseerror&quot;&gt; &lt;code&gt;Plug.Parsers.ParseError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cccc957fe078af75253bf9b2e6e8e9e63f87426f" translate="yes" xml:space="preserve">
          <source>Parses JSON request body.</source>
          <target state="translated">JSON 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="febd101e37af95c11999e9624c83f04d4097ab35" translate="yes" xml:space="preserve">
          <source>Parses a comma-separated list of header values</source>
          <target state="translated">쉼표로 구분 된 헤더 값 목록을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="7abfebddba3c610641e8f882717e35b43ed7edb4" translate="yes" xml:space="preserve">
          <source>Parses a comma-separated list of header values.</source>
          <target state="translated">쉼표로 구분 된 헤더 값 목록을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="eeffd6812fd1c41bf966facf09d2730c17eef5d8" translate="yes" xml:space="preserve">
          <source>Parses a value as defined in &lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341에&lt;/a&gt; 정의 된 대로 값을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="b5f5bc9fbe8ea215a0c5e0cc30ca46bd75d8ab73" translate="yes" xml:space="preserve">
          <source>Parses a value as defined in &lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341에&lt;/a&gt; 정의 된 대로 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="2185e747720b7d0fb465dbcfa35c76689b67ddf1" translate="yes" xml:space="preserve">
          <source>Parses content type (without wildcards)</source>
          <target state="translated">컨텐츠 유형 구문 분석 (와일드 카드 없음)</target>
        </trans-unit>
        <trans-unit id="2ad2310b834d234619722ce81d4e14f7d4ae3f92" translate="yes" xml:space="preserve">
          <source>Parses content type (without wildcards).</source>
          <target state="translated">컨텐츠 유형을 구문 분석합니다 (와일드 카드 없음).</target>
        </trans-unit>
        <trans-unit id="edcb288b34b94e9a7b0b19595aeaef526084fa11" translate="yes" xml:space="preserve">
          <source>Parses headers parameters</source>
          <target state="translated">헤더 매개 변수 구문 분석</target>
        </trans-unit>
        <trans-unit id="c7285730fc5c73222e859f0e3e7c3e02b2c17514" translate="yes" xml:space="preserve">
          <source>Parses headers parameters.</source>
          <target state="translated">헤더 매개 변수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="5a1d617a7f9d1c524d3e04146f32d517b9afce1c" translate="yes" xml:space="preserve">
          <source>Parses media types (with wildcards)</source>
          <target state="translated">미디어 유형 구문 분석 (와일드 카드 사용)</target>
        </trans-unit>
        <trans-unit id="b2b6e960a35b0125c6525a5e4b92a2ee49c9f2bd" translate="yes" xml:space="preserve">
          <source>Parses media types (with wildcards).</source>
          <target state="translated">미디어 유형을 구문 분석합니다 (와일드 카드 사용).</target>
        </trans-unit>
        <trans-unit id="75d8c6d477b6e3f69af2ae67553366717edbc36a" translate="yes" xml:space="preserve">
          <source>Parses multipart request body.</source>
          <target state="translated">멀티 파트 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e21c68fcb0d3e3b32206991f6e19f3811948aaee" translate="yes" xml:space="preserve">
          <source>Parses the given cookie</source>
          <target state="translated">주어진 쿠키를 파싱</target>
        </trans-unit>
        <trans-unit id="944dfd390be7ae48712dfb31bfdccb0d6eb083fe" translate="yes" xml:space="preserve">
          <source>Parses the given cookie.</source>
          <target state="translated">주어진 쿠키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="2b2aef79cbfc6edb73d8c0a8df4a18152f4ef7c8" translate="yes" xml:space="preserve">
          <source>Parses the repository option from the given command line args list</source>
          <target state="translated">제공된 명령 행 인수 목록에서 저장소 옵션을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="4d056c3c1990172ff2a799b5561c4cf7758262df" translate="yes" xml:space="preserve">
          <source>Parses the repository option from the given command line args list.</source>
          <target state="translated">제공된 명령 행 인수 목록에서 저장소 옵션을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a8ccbdf0ea4fb9786bba06d775ebbe92ab8cd421" translate="yes" xml:space="preserve">
          <source>Parses the request username and password from Basic HTTP auth.</source>
          <target state="translated">기본 HTTP 인증에서 요청 사용자 이름과 비밀번호를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e6b5a511e222d1fd33ba56da0250000bdd6269d4" translate="yes" xml:space="preserve">
          <source>Parses urlencoded request body.</source>
          <target state="translated">urlencoded 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="dff091d52f0ab0fb3edf7f3667472f820343f30a" translate="yes" xml:space="preserve">
          <source>Partial and multiple segments can be matched. For example:</source>
          <target state="translated">Partial and multiple segments can be matched. For example:</target>
        </trans-unit>
        <trans-unit id="93e976db30d2d1e659c6681d80cc8c7ab0dbd542" translate="yes" xml:space="preserve">
          <source>Partial changes for many-style associations</source>
          <target state="translated">여러 스타일 연관에 대한 부분 변경</target>
        </trans-unit>
        <trans-unit id="4d8d29c37cfa9d2ee47bae5429be39d9f989f27b" translate="yes" xml:space="preserve">
          <source>Partitioning</source>
          <target state="translated">Partitioning</target>
        </trans-unit>
        <trans-unit id="718245df741ec43142c0b6c264179186673e8371" translate="yes" xml:space="preserve">
          <source>Pass the (relative or absolute) path using the &lt;code&gt;:dhfile&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:dhfile&lt;/code&gt; 옵션을 사용하여 (상대 또는 절대) 경로를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fecdb6c2a3ad36cf4a2181161441ba3664c5740" translate="yes" xml:space="preserve">
          <source>Passing DER Binaries</source>
          <target state="translated">DER 바이너리 전달</target>
        </trans-unit>
        <trans-unit id="bcf58232ce830f75c9e16a9c414175781444e8ed" translate="yes" xml:space="preserve">
          <source>Passing a changeset as the first argument:</source>
          <target state="translated">변경 세트를 첫 번째 인수로 전달 :</target>
        </trans-unit>
        <trans-unit id="79594c27a0996c84feb78ccf2403bfabfafed6a5" translate="yes" xml:space="preserve">
          <source>Passing data between routes and plugs</source>
          <target state="translated">Passing data between routes and plugs</target>
        </trans-unit>
        <trans-unit id="2d638a5d061d20e534d6e216da51b8475dee8c87" translate="yes" xml:space="preserve">
          <source>Passing more than one value in to our template is as simple as connecting &lt;code&gt;assign/3&lt;/code&gt; functions together:</source>
          <target state="translated">템플릿에 둘 이상의 값을 전달하는 것은 &lt;code&gt;assign/3&lt;/code&gt; 함수를 함께 연결 하는 것만 큼 ​​간단 합니다.</target>
        </trans-unit>
        <trans-unit id="2ba5d7c85f44f63374475833d6fed9a01b4fff14" translate="yes" xml:space="preserve">
          <source>Password inputs</source>
          <target state="translated">비밀번호 입력</target>
        </trans-unit>
        <trans-unit id="7fc0bad45caa68b9815f9386fb2c432a9046a5f5" translate="yes" xml:space="preserve">
          <source>Password inputs are also special cased in &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt;. For security reasons, password field values are not reused when rendering a password input tag. This requires explicitly setting the &lt;code&gt;:value&lt;/code&gt; in your markup, for example:</source>
          <target state="translated">비밀번호 입력은 &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 에서도 특수한 경우가 있습니다 . 보안상의 이유로 암호 입력 태그를 렌더링 할 때 암호 필드 값은 재사용되지 않습니다. 이를 위해서는 마크 업에서 &lt;code&gt;:value&lt;/code&gt; 를 명시 적으로 설정해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c6707e04bf1f663b738171a4e15820d300bc415b" translate="yes" xml:space="preserve">
          <source>Path Helpers</source>
          <target state="translated">경로 도우미</target>
        </trans-unit>
        <trans-unit id="764b74e2382549dd2640abeb89867d31d480a68b" translate="yes" xml:space="preserve">
          <source>Path elements can be integers to access values in JSON arrays:</source>
          <target state="translated">Path elements can be integers to access values in JSON arrays:</target>
        </trans-unit>
        <trans-unit id="4bf07859424115f0a7391b2a1e76d2d3586b03ae" translate="yes" xml:space="preserve">
          <source>Path helpers are functions which are dynamically defined on the &lt;code&gt;Router.Helpers&lt;/code&gt; module for an individual application. For us, that is &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt;. Their name of each path helper is derived from the name of the controller used in the route definition. Our controller is &lt;code&gt;HelloWeb.PageController&lt;/code&gt;, and &lt;code&gt;page_path&lt;/code&gt; is the function which will return the path to the root of our application.</source>
          <target state="translated">경로 도우미는 개별 응용 프로그램 에 대해 &lt;code&gt;Router.Helpers&lt;/code&gt; 모듈 에 동적으로 정의되는 함수입니다 . 우리에게는 &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; 입니다. 각 경로 도우미의 이름은 경로 정의에 사용 된 컨트롤러의 이름에서 파생됩니다. 컨트롤러는 &lt;code&gt;HelloWeb.PageController&lt;/code&gt; 이고 &lt;code&gt;page_path&lt;/code&gt; 는 애플리케이션의 루트 경로를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="99be152ebccb0e4754a4e653efa063a16c828043" translate="yes" xml:space="preserve">
          <source>Path params</source>
          <target state="translated">Path params</target>
        </trans-unit>
        <trans-unit id="2004f66fdb8c8bf73b24a2cbf645ba2ba722074e" translate="yes" xml:space="preserve">
          <source>Per longpoll transport:</source>
          <target state="translated">롱폴 운송 당 :</target>
        </trans-unit>
        <trans-unit id="0e44a1edfc6cd4e153baf2b65bf53238ca82e2c7" translate="yes" xml:space="preserve">
          <source>Per websocket transport:</source>
          <target state="translated">웹 소켓 전송 당 :</target>
        </trans-unit>
        <trans-unit id="a85e0697988afaaff9ffbaf7e05d3bd427288bd5" translate="yes" xml:space="preserve">
          <source>Performs content negotiation based on the available formats</source>
          <target state="translated">사용 가능한 형식을 기반으로 컨텐츠 협상을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="581159b1cc630249addc79676d97814121177054" translate="yes" xml:space="preserve">
          <source>Performs content negotiation based on the available formats.</source>
          <target state="translated">사용 가능한 형식을 기반으로 컨텐츠 협상을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66350424b6ec15141e12bc5e1d0630433dc753e2" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked elements in the topic</source>
          <target state="translated">주제에서 추적 된 요소에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d75048af6986e27dc9129029c719e8a150810076" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked elements in the topic.</source>
          <target state="translated">주제에서 추적 된 요소에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9fd3b5cac74a6c816e64725647fb0e077b321ead" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked key in the topic</source>
          <target state="translated">주제에서 추적 된 키에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="65edcafb6a8455f62879eb04988b9447a89e87d0" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked key in the topic.</source>
          <target state="translated">주제에서 추적 된 키에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e1db222cfb5f428ee6ea20828b82ac315cf7a189" translate="yes" xml:space="preserve">
          <source>Performs the repository change on the association</source>
          <target state="translated">연관에 대한 저장소 변경을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a30cfc42d0635d83408f75d1c0aa49bd2fa09bee" translate="yes" xml:space="preserve">
          <source>Performs the repository change on the association.</source>
          <target state="translated">연관에서 저장소 변경을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8a32565cc9d5564dc754e7a741ae6202d09e4b06" translate="yes" xml:space="preserve">
          <source>Periodic measurements</source>
          <target state="translated">주기적 측정</target>
        </trans-unit>
        <trans-unit id="d7f4ad0c4187ab879c3f2d5cbdf9d2c789a5d959" translate="yes" xml:space="preserve">
          <source>Persists a value in flash</source>
          <target state="translated">플래시 값 유지</target>
        </trans-unit>
        <trans-unit id="2ae9ec55da158cde328d17e822f68f763d0e88f6" translate="yes" xml:space="preserve">
          <source>Persists a value in flash.</source>
          <target state="translated">플래시 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3e978fbf8aad93b7520fcec25f666a8823b47615" translate="yes" xml:space="preserve">
          <source>Phoenix</source>
          <target state="translated">Phoenix</target>
        </trans-unit>
        <trans-unit id="3ece665b36c719f365fb360f2b928657e6944fa7" translate="yes" xml:space="preserve">
          <source>Phoenix &lt;small&gt;(Phoenix v1.5.6)&lt;/small&gt;</source>
          <target state="translated">Phoenix &lt;small&gt;(Phoenix v1.5.6)&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8c440de623ec33f4f6366896e6906fe47112aa77" translate="yes" xml:space="preserve">
          <source>Phoenix Framework Tutorial (by Tensor Programming - 2017)</source>
          <target state="translated">Phoenix 프레임 워크 튜토리얼 (By Tensor Programming-2017)</target>
        </trans-unit>
        <trans-unit id="f7ec67cf354802c21a5ad8ec743f5289ce6a3840" translate="yes" xml:space="preserve">
          <source>Phoenix Inside Out - Book Series (by Shankar Dhanasekaran - 2017)</source>
          <target state="translated">Phoenix Inside Out - Book Series (by Shankar Dhanasekaran - 2017)</target>
        </trans-unit>
        <trans-unit id="95074257ecd7b5e553ae1799b1c4eb06f6c7fbf9" translate="yes" xml:space="preserve">
          <source>Phoenix LiveView Free Course (by The Pragmatic Studio - 2020)</source>
          <target state="translated">Phoenix LiveView 무료 과정 (The Pragmatic Studio-2020)</target>
        </trans-unit>
        <trans-unit id="2b3fb71bfcd88cbe1d12d9c402e864ce2941a3b9" translate="yes" xml:space="preserve">
          <source>Phoenix Metrics</source>
          <target state="translated">피닉스 메트릭스</target>
        </trans-unit>
        <trans-unit id="8e407dce91f4a35a357a057dc8cd197d689f75ed" translate="yes" xml:space="preserve">
          <source>Phoenix PubSub adapter based on &lt;a href=&quot;http://erlang.org/doc/man/pg2.html&quot;&gt;PG2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/man/pg2.html&quot;&gt;PG2&lt;/a&gt; 기반의 Phoenix PubSub 어댑터 .</target>
        </trans-unit>
        <trans-unit id="f9631dc599922d5a4c975f5d316922d72aa0b4a7" translate="yes" xml:space="preserve">
          <source>Phoenix PubSub adapter based on &lt;code&gt;:pg&lt;/code&gt;/&lt;code&gt;:pg2&lt;/code&gt;.</source>
          <target state="translated">Phoenix PubSub adapter based on &lt;code&gt;:pg&lt;/code&gt; / &lt;code&gt;:pg2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="246981200bb56d76ee02c0dfe4981a040360e5a5" translate="yes" xml:space="preserve">
          <source>Phoenix PubSub was designed to be flexible and support multiple backends. There are two officially supported backends:</source>
          <target state="translated">Phoenix PubSub was designed to be flexible and support multiple backends. There are two officially supported backends:</target>
        </trans-unit>
        <trans-unit id="8e7a9a072682ed29991a64c5ebfd07a902b9f405" translate="yes" xml:space="preserve">
          <source>Phoenix Telemetry Events</source>
          <target state="translated">Phoenix Telemetry 이벤트</target>
        </trans-unit>
        <trans-unit id="3b8361f60937d7f93c78ee48bfce5c4dd4fdcbc0" translate="yes" xml:space="preserve">
          <source>Phoenix allows us to change formats on the fly with the &lt;code&gt;_format&lt;/code&gt; query string parameter. To make this happen, Phoenix requires an appropriately named view and an appropriately named template in the correct directory.</source>
          <target state="translated">Phoenix에서는 &lt;code&gt;_format&lt;/code&gt; 쿼리 문자열 매개 변수 를 사용하여 즉시 형식을 변경할 수 있습니다 . 이를 위해 Phoenix는 적절한 이름의 뷰와 올바른 디렉토리에 적절한 이름의 템플릿이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="600f63bc95cf613607c031a5aefe19492763aa4c" translate="yes" xml:space="preserve">
          <source>Phoenix allows us to create our own custom pipelines anywhere in the router. To do so, we call the &lt;code&gt;pipeline/2&lt;/code&gt; macro with these arguments: an atom for the name of our new pipeline and a block with all the plugs we want in it.</source>
          <target state="translated">Phoenix를 사용하면 라우터 어디에서나 자체 사용자 지정 파이프 라인을 만들 수 있습니다. 이를 위해 다음 인수를 사용 하여 &lt;code&gt;pipeline/2&lt;/code&gt; 매크로를 호출합니다 . 새 파이프 라인의 이름에 대한 원자와 원하는 모든 플러그가있는 블록입니다.</target>
        </trans-unit>
        <trans-unit id="e40de680c92e9c88f77145a4a9e1b3b02c8d2011" translate="yes" xml:space="preserve">
          <source>Phoenix allows you to choose which webserver adapter to use. The default is &lt;a href=&quot;phoenix.endpoint.cowboy2adapter&quot;&gt;&lt;code&gt;Phoenix.Endpoint.Cowboy2Adapter&lt;/code&gt;&lt;/a&gt; which can be configured via the following options.</source>
          <target state="translated">Phoenix allows you to choose which webserver adapter to use. The default is &lt;a href=&quot;phoenix.endpoint.cowboy2adapter&quot;&gt; &lt;code&gt;Phoenix.Endpoint.Cowboy2Adapter&lt;/code&gt; &lt;/a&gt; which can be configured via the following options.</target>
        </trans-unit>
        <trans-unit id="d431adf08f5c06e6f59704625a0fe3cbc4a8838a" translate="yes" xml:space="preserve">
          <source>Phoenix also offers the ability to generate all the code to stand up a complete JSON resource - ecto migration, ecto schema, controller with all the necessary actions and view. This command will not create any template for the app.</source>
          <target state="translated">Phoenix는 또한 완전한 JSON 리소스 (ecto 마이그레이션, ecto 스키마, 필요한 모든 작업 및보기가 포함 된 컨트롤러)를 지원하기 위해 모든 코드를 생성하는 기능을 제공합니다. 이 명령은 앱에 대한 템플릿을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="977b047af5e8d58f5897d44aaa109fe536c9b7ed" translate="yes" xml:space="preserve">
          <source>Phoenix also provides a &lt;a href=&quot;#resources/4&quot;&gt;&lt;code&gt;resources/4&lt;/code&gt;&lt;/a&gt; macro that allows developers to generate &quot;RESTful&quot; routes to a given resource:</source>
          <target state="translated">Phoenix also provides a &lt;a href=&quot;#resources/4&quot;&gt; &lt;code&gt;resources/4&lt;/code&gt; &lt;/a&gt; macro that allows developers to generate &quot;RESTful&quot; routes to a given resource:</target>
        </trans-unit>
        <trans-unit id="563cf9047af9d0a38a9f21a81eb58f780532cb3a" translate="yes" xml:space="preserve">
          <source>Phoenix also provides a &lt;a href=&quot;#resources/4&quot;&gt;&lt;code&gt;resources/4&lt;/code&gt;&lt;/a&gt; macro that allows developers to generate &amp;ldquo;RESTful&amp;rdquo; routes to a given resource:</source>
          <target state="translated">또한 Phoenix 는 개발자가 주어진 리소스에 대한 &quot;RESTful&quot;경로를 생성 할 수 있도록 &lt;a href=&quot;#resources/4&quot;&gt; &lt;code&gt;resources/4&lt;/code&gt; &lt;/a&gt; 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c93b742601722ee5d5b1c7210566706cafc7e5ea" translate="yes" xml:space="preserve">
          <source>Phoenix applications are configured to use PostgreSQL by default, but what if we want to use MySQL instead? In this guide, we'll walk through changing that default whether we are about to create a new application, or whether we have an existing one configured for PostgreSQL.</source>
          <target state="translated">Phoenix 애플리케이션은 기본적으로 PostgreSQL을 사용하도록 구성되어 있지만 MySQL을 대신 사용하려면 어떻게해야합니까? 이 가이드에서는 새 애플리케이션을 만들 것인지 아니면 PostgreSQL 용으로 구성된 기존 애플리케이션이 있는지 여부에 관계없이 해당 기본값을 변경하는 방법을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7fb2dd422ce36f075cbed33d3855683bb2d91a00" translate="yes" xml:space="preserve">
          <source>Phoenix assumes a strong naming convention from controllers to views to the templates they render. The &lt;code&gt;PageController&lt;/code&gt; requires a &lt;code&gt;PageView&lt;/code&gt; to render templates in the &lt;code&gt;lib/hello_web/templates/page&lt;/code&gt; directory. While all of these can be customizable (see &lt;a href=&quot;phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.template&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; for more information), we recommend users stick with Phoenix' convention.</source>
          <target state="translated">Phoenix는 컨트롤러에서 뷰, 렌더링하는 템플릿에 이르기까지 강력한 명명 규칙을 사용합니다. &lt;code&gt;PageController&lt;/code&gt; 는 필요 &lt;code&gt;PageView&lt;/code&gt; 에서 템플릿을 렌더링하기 위해 &lt;code&gt;lib/hello_web/templates/page&lt;/code&gt; 디렉토리. 이들 모두를 사용자 정의 할 수 있지만 (자세한 내용은 &lt;a href=&quot;phoenix.view&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phoenix.template&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; &lt;/a&gt; 참조 ) 사용자는 Phoenix의 규칙을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="20f91145c37fb132f53a9b6f4d7951e80a45311b" translate="yes" xml:space="preserve">
          <source>Phoenix assumes that our PostgreSQL database will have a &lt;code&gt;postgres&lt;/code&gt; user account with the correct permissions and a password of &quot;postgres&quot;. If that isn't the case, please see the &lt;a href=&quot;mix_tasks#ecto-specific-mix-tasks&quot;&gt;Mix Tasks Guide&lt;/a&gt; to learn more about the &lt;code&gt;mix ecto.create&lt;/code&gt; task.</source>
          <target state="translated">Phoenix는 PostgreSQL 데이터베이스 에 올바른 권한과 &quot;postgres&quot;암호 가있는 &lt;code&gt;postgres&lt;/code&gt; 사용자 계정 이 있다고 가정합니다 . 그렇지 않은 경우 &lt;code&gt;mix ecto.create&lt;/code&gt; 작업에 대한 자세한 내용은 &lt;a href=&quot;mix_tasks#ecto-specific-mix-tasks&quot;&gt;Mix 작업 가이드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72235a2da760fdd627bf34a66005e7ad134e9e16" translate="yes" xml:space="preserve">
          <source>Phoenix automatically generates a module &lt;code&gt;Helpers&lt;/code&gt; inside your router which contains named helpers to help developers generate and keep their routes up to date.</source>
          <target state="translated">Phoenix는 라우터 내부에 모듈 &lt;code&gt;Helpers&lt;/code&gt; 자동으로 생성하는데, 여기에는 개발자가 경로를 생성하고 최신 상태로 유지할 수 있도록 명명 된 헬퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55671bef02efae40eff055a656f5c94f8ff1d22d" translate="yes" xml:space="preserve">
          <source>Phoenix can filter all parameters by default and selectively keep parameters. This can be configured like so:</source>
          <target state="translated">Phoenix는 기본적으로 모든 매개 변수를 필터링하고 선택적으로 매개 변수를 유지할 수 있습니다. 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d0b29938060ad2544acc880235dd39f4c2479d" translate="yes" xml:space="preserve">
          <source>Phoenix controllers act as intermediary modules. Their functions - called actions - are invoked from the router in response to HTTP requests. The actions, in turn, gather all the necessary data and perform all the necessary steps before invoking the view layer to render a template or returning a JSON response.</source>
          <target state="translated">Phoenix 컨트롤러는 중간 모듈 역할을합니다. 이들의 기능 (액션이라고 함)은 HTTP 요청에 대한 응답으로 라우터에서 호출됩니다. 그런 다음 작업은 필요한 모든 데이터를 수집하고 뷰 레이어를 호출하여 템플릿을 렌더링하거나 JSON 응답을 반환하기 전에 필요한 모든 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1e27497026a493416a612d01951d09fcf5ab0ee1" translate="yes" xml:space="preserve">
          <source>Phoenix controllers also build on the Plug package, and are themselves plugs. Controllers provide the functions to do almost anything we need to in an action. If we do find ourselves looking for something that Phoenix controllers don't provide, we might find what we're looking for in Plug itself. Please see the &lt;a href=&quot;plug&quot;&gt;Plug Guide&lt;/a&gt; or &lt;a href=&quot;../plug/index&quot;&gt;Plug Documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Phoenix 컨트롤러는 또한 Plug 패키지를 기반으로하며 그 자체가 플러그입니다. 컨트롤러는 행동에 필요한 거의 모든 작업을 수행 할 수있는 기능을 제공합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ Phoenix 컨트롤러가 제공하지 않는 무언가를 찾고 있다면 Plug 자체에서 우리가 원하는 것을 찾을 수 있습니다. 자세한 내용은 &lt;a href=&quot;plug&quot;&gt;플러그 가이드&lt;/a&gt; 또는 &lt;a href=&quot;../plug/index&quot;&gt;플러그 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4260fca2a7c1a2e8caec4614e49c75e9733a32f" translate="yes" xml:space="preserve">
          <source>Phoenix controllers can also render HTML without a view. As you may have already guessed, the &lt;code&gt;html/2&lt;/code&gt; function does just that. This time, we implement the &lt;code&gt;show&lt;/code&gt; action like this.</source>
          <target state="translated">Phoenix 컨트롤러는보기없이 HTML을 렌더링 할 수도 있습니다. 이미 짐작 하셨겠지만 &lt;code&gt;html/2&lt;/code&gt; 함수가 바로 그 일을합니다. 이번에 &lt;code&gt;show&lt;/code&gt; 이와 같은 쇼 액션 을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="681383e103822b1a0593bf4b68cda68085e72301" translate="yes" xml:space="preserve">
          <source>Phoenix default events</source>
          <target state="translated">피닉스 기본 이벤트</target>
        </trans-unit>
        <trans-unit id="b7a0c1b121ac14fd3a53cd23959e43b33c97063f" translate="yes" xml:space="preserve">
          <source>Phoenix defines the view template at &lt;code&gt;lib/web/web.ex&lt;/code&gt;:</source>
          <target state="translated">Phoenix는 &lt;code&gt;lib/web/web.ex&lt;/code&gt; 에서 뷰 템플릿을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a4b6a80c82014709407f5fdb675ee752387046a6" translate="yes" xml:space="preserve">
          <source>Phoenix defines the view template at &lt;code&gt;lib/your_app_web.ex&lt;/code&gt;:</source>
          <target state="translated">Phoenix defines the view template at &lt;code&gt;lib/your_app_web.ex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ed8c65c06e667866d349f7c9f8c234296d28bccb" translate="yes" xml:space="preserve">
          <source>Phoenix defines two pipelines by default, &lt;code&gt;:browser&lt;/code&gt; and &lt;code&gt;:api&lt;/code&gt;, which can be used for a number of common tasks. In turn we can customize them as well as create new pipelines to meet our needs.</source>
          <target state="translated">Phoenix는 기본적으로 두 개의 파이프 라인, &lt;code&gt;:browser&lt;/code&gt; 및 &lt;code&gt;:api&lt;/code&gt; 를 정의 하며, 여러 일반적인 작업에 사용할 수 있습니다. 차례로 우리는 요구 사항을 충족하는 새로운 파이프 라인을 생성 할뿐만 아니라이를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76037093b62c95aa19a9c7c787d135873a61c5a" translate="yes" xml:space="preserve">
          <source>Phoenix does not enforce which keys are stored in the flash. As long as we are internally consistent, all will be well. &lt;code&gt;:info&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt;, however, are common and are handled by default in our templates.</source>
          <target state="translated">Phoenix는 플래시에 저장되는 키를 강제하지 않습니다. 내부적으로 일관성이있는 한 모든 것이 잘 될 것입니다. 그러나 &lt;code&gt;:info&lt;/code&gt; 및 &lt;code&gt;:error&lt;/code&gt; 는 일반적이며 기본적으로 템플릿에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bcee790bf66c5e0a6e64bc18bc8cb98e50a4aab9" translate="yes" xml:space="preserve">
          <source>Phoenix generated the web files as expected in &lt;code&gt;lib/hello_web/&lt;/code&gt;. We can also see our context files were generated inside a &lt;code&gt;lib/hello/accounts.ex&lt;/code&gt; file and our user schema in the directory of the same name. Note the difference between &lt;code&gt;lib/hello&lt;/code&gt; and &lt;code&gt;lib/hello_web&lt;/code&gt;. We have an &lt;code&gt;Accounts&lt;/code&gt; module to serve as the public API for account functionality, as well as an &lt;code&gt;Accounts.User&lt;/code&gt; struct, which is an Ecto schema for casting and validating user account data. Phoenix also provided web and context tests for us, which we'll look at later. For now, let's follow the instructions and add the route according to the console instructions, in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;:</source>
          <target state="translated">Phoenix는 &lt;code&gt;lib/hello_web/&lt;/code&gt; 에서 예상대로 웹 파일을 생성했습니다 . 또한 컨텍스트 파일이 &lt;code&gt;lib/hello/accounts.ex&lt;/code&gt; 파일과 동일한 이름의 디렉토리에있는 사용자 스키마 내에 생성 된 것을 볼 수 있습니다 . &lt;code&gt;lib/hello&lt;/code&gt; 와 &lt;code&gt;lib/hello_web&lt;/code&gt; 의 차이점에 유의하십시오 . 계정 기능을위한 공용 API 역할을 하는 &lt;code&gt;Accounts&lt;/code&gt; 모듈 과 사용자 계정 데이터를 캐스팅하고 검증하기위한 Ecto 스키마 인 &lt;code&gt;Accounts.User&lt;/code&gt; 구조체가 있습니다. Phoenix는 또한 웹 및 컨텍스트 테스트를 제공했으며 나중에 살펴 보겠습니다. 지금은 지침에 따라 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 의 콘솔 지침에 따라 경로를 추가 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3c6a4c42f6da67fb0155d376aee461679733f67a" translate="yes" xml:space="preserve">
          <source>Phoenix generates a router file for us in new applications at &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;. This is where we will be working for this section.</source>
          <target state="translated">Phoenix는 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 의 새로운 애플리케이션에서 우리를 위해 라우터 파일을 생성합니다 . 이 섹션에서 작업 할 곳입니다.</target>
        </trans-unit>
        <trans-unit id="1cf982436b2f1dec7188e97ef3f8e08ffdb049f4" translate="yes" xml:space="preserve">
          <source>Phoenix generates an &lt;code&gt;ErrorView&lt;/code&gt; for us, but it doesn't give us a &lt;code&gt;lib/hello_web/templates/error&lt;/code&gt; directory. Let's create one now. Inside our new directory, let's add a template, &lt;code&gt;404.html.eex&lt;/code&gt; and give it some markup - a mixture of our application layout and a new &lt;code&gt;div&lt;/code&gt; with our message to the user.</source>
          <target state="translated">Phoenix는 우리를 위해 &lt;code&gt;ErrorView&lt;/code&gt; 를 생성 하지만 &lt;code&gt;lib/hello_web/templates/error&lt;/code&gt; 디렉토리 는 제공하지 않습니다 . 지금 만들어 봅시다. 새 디렉토리 안에 &lt;code&gt;404.html.eex&lt;/code&gt; 템플릿을 추가하고 마크 업 (애플리케이션 레이아웃과 사용자에게 보내는 메시지와 함께 새 &lt;code&gt;div&lt;/code&gt; 가 혼합 된)을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="943f9caaf78c7e44791e5c4d08df323d8254573d" translate="yes" xml:space="preserve">
          <source>Phoenix generates the directory structure and all the files we will need for our application.</source>
          <target state="translated">Phoenix는 애플리케이션에 필요한 디렉터리 구조와 모든 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90022361fc09e0bf0d778a2457d7f6ddc39d7f3f" translate="yes" xml:space="preserve">
          <source>Phoenix has a view called the &lt;code&gt;ErrorView&lt;/code&gt; which lives in &lt;code&gt;lib/hello_web/views/error_view.ex&lt;/code&gt;. The purpose of the &lt;code&gt;ErrorView&lt;/code&gt; is to handle errors in a general way, from one centralized location.</source>
          <target state="translated">피닉스라는보기가 &lt;code&gt;ErrorView&lt;/code&gt; 에 살고 &lt;code&gt;lib/hello_web/views/error_view.ex&lt;/code&gt; . &lt;code&gt;ErrorView&lt;/code&gt; 의 목적은 하나의 중앙 위치에서 일반적인 방식으로 오류를 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca21d7b4ebd9ed2849b91aecb3a2cc46b8dfd221" translate="yes" xml:space="preserve">
          <source>Phoenix has a view called the &lt;code&gt;ErrorView&lt;/code&gt; which lives in &lt;code&gt;lib/hello_web/views/error_view.ex&lt;/code&gt;. The purpose of the &lt;code&gt;ErrorView&lt;/code&gt; is to handle errors in a general way, from one centralized location. Similar to the views we built in this guide, error views can return both HTML and JSON responses. See &lt;a href=&quot;custom_error_pages&quot;&gt;the Custom Error Pages How-To&lt;/a&gt; for more information.</source>
          <target state="translated">피닉스라는보기가 &lt;code&gt;ErrorView&lt;/code&gt; 에 살고 &lt;code&gt;lib/hello_web/views/error_view.ex&lt;/code&gt; . &lt;code&gt;ErrorView&lt;/code&gt; 의 목적은 하나의 중앙 위치에서 일반적인 방식으로 오류를 처리하는 것입니다. 이 가이드에서 빌드 한보기와 ​​유사하게 오류보기는 HTML 및 JSON 응답을 모두 반환 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 자세한 내용 &lt;a href=&quot;custom_error_pages&quot;&gt;은 사용자 지정 오류 페이지 방법&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="42e2cfe402e791a38de54744345cecda7da570dc" translate="yes" xml:space="preserve">
          <source>Phoenix in Action (by Geoffrey Lessel - 2019)</source>
          <target state="translated">Phoenix in Action (저자 : Geoffrey Lessel-2019)</target>
        </trans-unit>
        <trans-unit id="f7d1e2992f72ece22d106950f407c7d2f47005cb" translate="yes" xml:space="preserve">
          <source>Phoenix includes a JavaScript client for WebSocket and Longpolling support using JSON encodings.</source>
          <target state="translated">Phoenix에는 JSON 인코딩을 사용하는 WebSocket 및 Longpolling 지원을위한 JavaScript 클라이언트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42a833d6eae527d447d8e167e01286e8b768777" translate="yes" xml:space="preserve">
          <source>Phoenix includes the &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.phx.gen.json&quot;&gt;&lt;code&gt;mix phx.gen.json&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.phx.gen.live&quot;&gt;&lt;code&gt;mix phx.gen.live&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; generators that apply the ideas of isolating functionality in our applications into contexts. These generators are a great way to hit the ground running while Phoenix nudges you in the right direction to grow your application. Let's put these tools to use for our new user accounts context.</source>
          <target state="translated">Phoenix에는 애플리케이션의 기능을 컨텍스트에 분리하는 아이디어를 적용 하는 &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt; &lt;code&gt;mix phx.gen.html&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.phx.gen.json&quot;&gt; &lt;code&gt;mix phx.gen.json&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.phx.gen.live&quot;&gt; &lt;code&gt;mix phx.gen.live&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt; 생성기가 포함되어 있습니다. 이 생성기는 Phoenix가 애플리케이션을 성장시키기 위해 올바른 방향으로 안내하는 동안 지상에 뛰어들 수있는 좋은 방법입니다. 이러한 도구를 새 사용자 계정 컨텍스트에 사용할 수 있도록하겠습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="dd1a122e2d3db7e6977ee15d5854014e7c483daf" translate="yes" xml:space="preserve">
          <source>Phoenix injects an &lt;code&gt;action/2&lt;/code&gt; plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the &lt;code&gt;action/2&lt;/code&gt; plug in your controller is a useful way to inject arguments into your actions that you would otherwise need to fetch of the connection repeatedly. For example, imagine if you stored a &lt;code&gt;conn.assigns.current_user&lt;/code&gt; in the connection and wanted quick access to the user for every action in your controller:</source>
          <target state="translated">Phoenix 는 라우터에 일치하는 기능을 호출 하는 &lt;code&gt;action/2&lt;/code&gt; 플러그를 컨트롤러에 삽입 합니다. 기본적으로 conn 및 params를 전달합니다. 경우 에 따라 컨트롤러에서 &lt;code&gt;action/2&lt;/code&gt; 플러그를 재정의하는 것이 연결에 반복적으로 가져와야하는 인수를 조치에 삽입하는 유용한 방법입니다. 예를 들어, 연결에 &lt;code&gt;conn.assigns.current_user&lt;/code&gt; 를 저장하고 컨트롤러의 모든 작업에 대해 사용자에게 빠르게 액세스하려는 경우를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="bb04d769c54701f9f35839469c966cff1eb67c69" translate="yes" xml:space="preserve">
          <source>Phoenix injects an &lt;code&gt;action/2&lt;/code&gt; plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the &lt;code&gt;action/2&lt;/code&gt; plug in your controller is a useful way to inject arguments into your actions that you would otherwise need to repeatedly fetch off the connection. For example, imagine if you stored a &lt;code&gt;conn.assigns.current_user&lt;/code&gt; in the connection and wanted quick access to the user for every action in your controller:</source>
          <target state="translated">Phoenix injects an &lt;code&gt;action/2&lt;/code&gt; plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the &lt;code&gt;action/2&lt;/code&gt; plug in your controller is a useful way to inject arguments into your actions that you would otherwise need to repeatedly fetch off the connection. For example, imagine if you stored a &lt;code&gt;conn.assigns.current_user&lt;/code&gt; in the connection and wanted quick access to the user for every action in your controller:</target>
        </trans-unit>
        <trans-unit id="c9c3b484281045c70f03ebd69154717d189bbc79" translate="yes" xml:space="preserve">
          <source>Phoenix is a web development framework written in Elixir which implements the server-side Model View Controller (MVC) pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python's Django.</source>
          <target state="translated">Phoenix는 서버 측 모델 뷰 컨트롤러 (MVC) 패턴을 구현하는 Elixir로 작성된 웹 개발 프레임 워크입니다. Ruby on Rails 또는 Python의 Django와 같은 다른 웹 프레임 워크에 대한 경험이있는 우리에게는 많은 구성 요소와 개념이 익숙해 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="3109d8b84a9dfd200d9bed5a60aa940e36a6f800" translate="yes" xml:space="preserve">
          <source>Phoenix is written in Elixir, and our application code will also be written in Elixir. We won't get far in a Phoenix app without it! The Elixir site maintains a great &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;Installation Page&lt;/a&gt; to help.</source>
          <target state="translated">Phoenix는 Elixir로 작성되었으며, 애플리케이션 코드도 Elixir로 작성됩니다. 우리는 그것 없이는 Phoenix 앱에서 멀리 가지 않을 것입니다! Elixir 사이트는 도움이 되는 훌륭한 &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;설치 페이지&lt;/a&gt; 를 유지하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c678b44209f0fadf67e60a99e2b49b722fd392a" translate="yes" xml:space="preserve">
          <source>Phoenix knows how to extract the &lt;code&gt;:id&lt;/code&gt; from &lt;code&gt;@user&lt;/code&gt; thanks to this protocol.</source>
          <target state="translated">피닉스는 추출하는 방법을 알고 &lt;code&gt;:id&lt;/code&gt; 에서 &lt;code&gt;@user&lt;/code&gt; 의 이 프로토콜에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="444ca1bf3c48419e5f680948f2de893dafdcc18f" translate="yes" xml:space="preserve">
          <source>Phoenix offers the ability to generate all the code to stand up a complete HTML resource - ecto migration, ecto context, controller with all the necessary actions, view, and templates. This can be a tremendous timesaver. Let's take a look at how to make this happen.</source>
          <target state="translated">Phoenix는 완전한 HTML 리소스 (ecto 마이그레이션, ecto 컨텍스트, 필요한 모든 작업이 포함 된 컨트롤러,보기 및 템플릿)를 구성하는 모든 코드를 생성하는 기능을 제공합니다. 이것은 엄청난 시간 절약이 될 수 있습니다. 어떻게 이런 일이 발생하는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="203598486d219dbc5a8e85d13bf938e6769fd28f" translate="yes" xml:space="preserve">
          <source>Phoenix projects are structured like Elixir and any other Elixir project &amp;ndash; we split our code into contexts. A context will group related functionality, such as posts and comments, often encapsulating patterns such as data access and data validation. By using contexts, we decouple and isolate our systems into manageable, independent parts.</source>
          <target state="translated">Phoenix 프로젝트는 Elixir 및 다른 Elixir 프로젝트와 같이 구성되어 있습니다. 코드를 컨텍스트로 분할했습니다. 컨텍스트는 게시물 및 댓글과 같은 관련 기능을 그룹화하여 데이터 액세스 및 데이터 유효성 검사와 같은 패턴을 캡슐화하는 경우가 많습니다. 컨텍스트를 사용하여 시스템을 관리 가능하고 독립적 인 부분으로 분리하고 분리합니다.</target>
        </trans-unit>
        <trans-unit id="6186760453ba6feab34e7d1a30198525222aa870" translate="yes" xml:space="preserve">
          <source>Phoenix promotes the usage of git as version control software: among the generated files we find a &lt;code&gt;.gitignore&lt;/code&gt;. We can &lt;code&gt;git init&lt;/code&gt; our repository, and immediately add and commit all that hasn't been marked ignored.</source>
          <target state="translated">Phoenix는 버전 제어 소프트웨어로 git 사용을 장려합니다. 생성 된 파일 중에서 &lt;code&gt;.gitignore&lt;/code&gt; 를 찾습니다 . 우리는 할 수 &lt;code&gt;git init&lt;/code&gt; 우리의 저장소를 즉시 추가하고 무시 표시된되지 않은 모든 커밋.</target>
        </trans-unit>
        <trans-unit id="55feceabd166218a997839f87c1c4f65fd8ca59f" translate="yes" xml:space="preserve">
          <source>Phoenix provides a great tool for investigating routes in an application: &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Phoenix는 애플리케이션에서 경로를 조사하기위한 훌륭한 도구를 제공합니다 : &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt; &lt;code&gt;mix phx.routes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d8470d46d6e0aef52d11c34073a21ad87a7a80" translate="yes" xml:space="preserve">
          <source>Phoenix provides a very handy feature called Live Reloading. As you change your views or your assets, it automatically reloads the page in the browser. In order for this functionality to work, you need a filesystem watcher.</source>
          <target state="translated">Phoenix는 Live Reloading이라는 매우 편리한 기능을 제공합니다. 보기 또는 자산을 변경하면 브라우저에서 페이지가 자동으로 다시로드됩니다. 이 기능이 작동하려면 파일 시스템 감시자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f4b45e163bf2d53e9ddf11815239e6fe0d7d631" translate="yes" xml:space="preserve">
          <source>Phoenix provides the best of both worlds - high developer productivity &lt;em&gt;and&lt;/em&gt; high application performance. It also has some interesting new twists like channels for implementing realtime features and pre-compiled templates for blazing speed.</source>
          <target state="translated">Phoenix는 높은 개발자 생산성 &lt;em&gt;과&lt;/em&gt; 높은 애플리케이션 성능 이라는 두 가지 장점을 모두 제공합니다 . 또한 실시간 기능을 구현하기위한 채널과 놀라운 속도를 위해 미리 컴파일 된 템플릿과 같은 흥미로운 새로운 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2cd29ce0f61c525ebbf5b9fbe66435aa87ab5b" translate="yes" xml:space="preserve">
          <source>Phoenix pubsub was designed to be flexible and support multiple backends. We currently ship with two backends:</source>
          <target state="translated">Phoenix pubsub는 유연하게 설계되었으며 여러 백엔드를 지원합니다. 현재 두 개의 백엔드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8bf0b7038a58953be09b1c27b47f3b6cd1166ac" translate="yes" xml:space="preserve">
          <source>Phoenix ships with a JavaScript implementation of both websocket and long polling that interacts with Phoenix.Socket and can be used as reference for those interested in implementing custom clients.</source>
          <target state="translated">Phoenix ships with a JavaScript implementation of both websocket and long polling that interacts with Phoenix.Socket and can be used as reference for those interested in implementing custom clients.</target>
        </trans-unit>
        <trans-unit id="50c2a8172e777a948fbb454fccb02b365c2af72b" translate="yes" xml:space="preserve">
          <source>Phoenix ships with some template engines and format encoders, which can be further configured in the Phoenix application. You can read more about format encoders in &lt;a href=&quot;phoenix.template&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">Phoenix는 일부 템플릿 엔진 및 형식 인코더와 함께 제공되며 Phoenix 애플리케이션에서 추가로 구성 할 수 있습니다. 포맷 인코더에 대한 자세한 내용은 &lt;a href=&quot;phoenix.template&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b728e8e5229b505e9fdd7e98b216dfd4d423440" translate="yes" xml:space="preserve">
          <source>Phoenix supports DOM element bindings for client-server interaction. For example, to react to a click on a button, you would render the element:</source>
          <target state="translated">Phoenix는 클라이언트-서버 상호 작용을위한 DOM 요소 바인딩을 지원합니다. 예를 들어 버튼 클릭에 반응하려면 요소를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="d82318fe8219a5008d1698de3a34d944e48624ec" translate="yes" xml:space="preserve">
          <source>Phoenix supports custom template engines. Engines tell Phoenix how to convert a template path into quoted expressions. See &lt;a href=&quot;phoenix.template.engine&quot;&gt;&lt;code&gt;Phoenix.Template.Engine&lt;/code&gt;&lt;/a&gt; for more information on the API required to be implemented by custom engines.</source>
          <target state="translated">Phoenix supports custom template engines. Engines tell Phoenix how to convert a template path into quoted expressions. See &lt;a href=&quot;phoenix.template.engine&quot;&gt; &lt;code&gt;Phoenix.Template.Engine&lt;/code&gt; &lt;/a&gt; for more information on the API required to be implemented by custom engines.</target>
        </trans-unit>
        <trans-unit id="fc3a831c178dd184156bc4d1affde9ff805af580" translate="yes" xml:space="preserve">
          <source>Phoenix supports instrumentation through an extensible API. Each endpoint defines an &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro that both users and Phoenix internals can call to instrument generic events. This macro is responsible for measuring the time it takes for the event to be processed and for notifying a list of interested instrumenter modules of this measurement.</source>
          <target state="translated">Phoenix는 확장 가능한 API를 통한 계측을 지원합니다. 각 엔드 포인트는 사용자와 Phoenix 내부 모두가 일반 이벤트를 계측하기 위해 호출 할 수 있는 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로를 정의 합니다. 이 매크로는 이벤트를 처리하는 데 걸리는 시간을 측정하고이 측정에 관심있는 계측기 모듈 목록을 알리는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="ccae26a3c55891669b22932d33f95b96afd4a534" translate="yes" xml:space="preserve">
          <source>Phoenix tasks</source>
          <target state="translated">Phoenix 작업</target>
        </trans-unit>
        <trans-unit id="baa319a678459985c92aa57b00956d8069935662" translate="yes" xml:space="preserve">
          <source>Phoenix uses &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; to encode JSON, so all we need to do in our views is format the data we'd like to respond with as a list or a map, and Phoenix will do the rest.</source>
          <target state="translated">Phoenix는 &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; 을 사용 하여 JSON을 인코딩하므로 뷰에서해야 할 일은 목록이나지도로 응답 할 데이터의 형식을 지정하는 것뿐입니다. 나머지는 Phoenix가 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7b8fc1fa1821f949ea5c8d9845c586714161e303" translate="yes" xml:space="preserve">
          <source>Phoenix uses Ecto to provide builtin support to the following databases:</source>
          <target state="translated">Phoenix는 Ecto를 사용하여 다음 데이터베이스에 대한 기본 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd66d4249cae4d4901b53e2f1132e1753d4a8d5f" translate="yes" xml:space="preserve">
          <source>Phoenix uses the &lt;code&gt;:telemetry&lt;/code&gt; library for instrumentation. The following events are published by Phoenix with the following measurements and metadata:</source>
          <target state="translated">Phoenix uses the &lt;code&gt;:telemetry&lt;/code&gt; library for instrumentation. The following events are published by Phoenix with the following measurements and metadata:</target>
        </trans-unit>
        <trans-unit id="2eb325f0cf1418192e6354abb60b2d6f559c3c71" translate="yes" xml:space="preserve">
          <source>Phoenix views act as the presentation layer. For example, we expect the output of rendering &quot;index.html&quot; to be a complete HTML page. To make our lives easier, we often use templates for creating those HTML pages.</source>
          <target state="translated">Phoenix 뷰는 프레젠테이션 레이어 역할을합니다. 예를 들어, &quot;index.html&quot;렌더링의 출력은 완전한 HTML 페이지가 될 것으로 예상합니다. 우리의 삶을 더 쉽게 만들기 위해 우리는 종종 그러한 HTML 페이지를 만들기 위해 템플릿을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="63984165b20efcc4077f547448622ba148f9ea2f" translate="yes" xml:space="preserve">
          <source>Phoenix views main job is to render the body of the responses to be sent back to browsers and API clients. Most of the time, we use templates to build said responses, but we can also craft them by hand. We will learn how.</source>
          <target state="translated">Phoenix의 주요 작업은 브라우저 및 API 클라이언트로 다시 보낼 응답 본문을 렌더링하는 것입니다. 대부분의 경우 템플릿을 사용하여 응답을 작성하지만 수동으로 작성할 수도 있습니다. 우리는 방법을 배울 것입니다.</target>
        </trans-unit>
        <trans-unit id="b00e5d8a6fed5b342079a86721f428670f5e8a61" translate="yes" xml:space="preserve">
          <source>Phoenix will be able to track what is static and dynamic across templates, as well as what changed. A rendered nested &lt;code&gt;.leex&lt;/code&gt; template will appear in the &lt;code&gt;dynamic&lt;/code&gt; list as another &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structure, which must be handled recursively.</source>
          <target state="translated">Phoenix는 템플릿 전체에서 정적 및 동적 요소와 변경된 사항을 추적 할 수 있습니다. 렌더링 된 중첩 &lt;code&gt;.leex&lt;/code&gt; 템플릿은 재귀 적으로 처리되어야하는 또 다른 &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt; &lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt; &lt;/a&gt; 구조 로 &lt;code&gt;dynamic&lt;/code&gt; 목록에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="ce5aad93c959c8da3f30d2164ea56e1348ca5c84" translate="yes" xml:space="preserve">
          <source>Phoenix&amp;rsquo;s default is &lt;code&gt;[&quot;password&quot;]&lt;/code&gt;.</source>
          <target state="translated">Phoenix의 기본값은 &lt;code&gt;[&quot;password&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0cd67f6f884429e9186f9da35ac87f7fba18cba" translate="yes" xml:space="preserve">
          <source>Phoenix&amp;rsquo;s router is extremely efficient, as it relies on Elixir pattern matching for matching routes and serving requests.</source>
          <target state="translated">Phoenix의 라우터는 경로 일치 및 요청 처리에 Elixir 패턴 일치를 사용하므로 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c211792ecd1df40cd68108b33555b05f222ca3a9" translate="yes" xml:space="preserve">
          <source>Phoenix's Telemetry tooling provides you with a supervisor that uses &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; to define the list of Telemetry events to handle and how to handle those events, i.e. how to structure them as a certain type of metric. This supervisor works together with Telemetry reporters to respond to the specified Telemetry events by aggregating them as the appropriate metric and sending them to the correct reporting destination.</source>
          <target state="translated">Phoenix의 Telemetry 도구는 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt; &lt;code&gt;Telemetry.Metrics&lt;/code&gt; &lt;/a&gt; 를 사용하여 처리 할 Telemetry 이벤트 목록과 이러한 이벤트를 처리하는 방법 (예 : 특정 유형의 메트릭으로 구조화하는 방법)을 정의 하는 감독자를 제공합니다 . 이 감독자는 Telemetry 리포터와 협력하여 지정된 Telemetry 이벤트를 적절한 메트릭으로 집계하고 올바른보고 대상으로 전송하여 지정된 Telemetry 이벤트에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="04c31db1d5ce8f6fa97b9f0120237b4323f21a73" translate="yes" xml:space="preserve">
          <source>Phoenix's default is &lt;code&gt;[&quot;password&quot;]&lt;/code&gt;.</source>
          <target state="translated">Phoenix's default is &lt;code&gt;[&quot;password&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0c6e396b6f23a3c117fdb66135815161548ab4" translate="yes" xml:space="preserve">
          <source>Phoenix's router is extremely efficient, as it relies on Elixir pattern matching for matching routes and serving requests.</source>
          <target state="translated">Phoenix's router is extremely efficient, as it relies on Elixir pattern matching for matching routes and serving requests.</target>
        </trans-unit>
        <trans-unit id="f3f724bed5c1dd367d7a6792b9791c2b2e7f4b61" translate="yes" xml:space="preserve">
          <source>Phoenix.ActionClauseError</source>
          <target state="translated">Phoenix.ActionClauseError</target>
        </trans-unit>
        <trans-unit id="a3c9625a75baea112564459d484e0749d11f46dd" translate="yes" xml:space="preserve">
          <source>Phoenix.ActionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.ActionClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dc55ed0afe31dd55493b9cffeda4e4fc9d18de96" translate="yes" xml:space="preserve">
          <source>Phoenix.Channel</source>
          <target state="translated">Phoenix.Channel</target>
        </trans-unit>
        <trans-unit id="7f0eb0fd8d0504f17307a6fe51df4933f98dd78b" translate="yes" xml:space="preserve">
          <source>Phoenix.Channel &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Channel &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="194067696901b5ee61c86e4a34c8412e29d8a729" translate="yes" xml:space="preserve">
          <source>Phoenix.ChannelTest</source>
          <target state="translated">Phoenix.ChannelTest</target>
        </trans-unit>
        <trans-unit id="7f47822f13327710ff7c52a6086ea2369d9864f1" translate="yes" xml:space="preserve">
          <source>Phoenix.CodeReloader</source>
          <target state="translated">Phoenix.CodeReloader</target>
        </trans-unit>
        <trans-unit id="71ff35769fb1ba5e7fe215dacfb07c1a016a409a" translate="yes" xml:space="preserve">
          <source>Phoenix.ConnTest</source>
          <target state="translated">Phoenix.ConnTest</target>
        </trans-unit>
        <trans-unit id="f1bb9bd32ed6a31867d5e3f4baaeb4cd54e0d456" translate="yes" xml:space="preserve">
          <source>Phoenix.Controller</source>
          <target state="translated">Phoenix.Controller</target>
        </trans-unit>
        <trans-unit id="b083ff21b48dc5fc860fe03533f81abf7ff48a0b" translate="yes" xml:space="preserve">
          <source>Phoenix.Digester</source>
          <target state="translated">Phoenix.Digester</target>
        </trans-unit>
        <trans-unit id="4596b9f544e92d211c61bfff6ce5c45323d19998" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint</source>
          <target state="translated">Phoenix.Endpoint</target>
        </trans-unit>
        <trans-unit id="e92cb5f483d3e8b468601886c85c01459044b604" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Endpoint &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="78f08bf4616d89086573429b97dfa4ec6304dd41" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.Cowboy2Adapter</source>
          <target state="translated">Phoenix.Endpoint.Cowboy2Adapter</target>
        </trans-unit>
        <trans-unit id="6eb8ce1073ba86cd353917977ca879ae43d10cd3" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.CowboyAdapter</source>
          <target state="translated">Phoenix.Endpoint.CowboyAdapter</target>
        </trans-unit>
        <trans-unit id="9e2a4123df59e55691aadc23751b530eea4294d1" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.CowboyHandler</source>
          <target state="translated">Phoenix.Endpoint.CowboyHandler</target>
        </trans-unit>
        <trans-unit id="89b27ed63f4f756c1f00eabc7cc517d3aa354251" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.Handler</source>
          <target state="translated">Phoenix.Endpoint.Handler</target>
        </trans-unit>
        <trans-unit id="250b8ddbb84121b634ab3349e0f36898b6f54154" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.Handler &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Endpoint.Handler &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d92a07414c224d6e1c67257e93659b50d506cdc7" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML</source>
          <target state="translated">Phoenix.HTML</target>
        </trans-unit>
        <trans-unit id="6987f796feee2221ad338ab71afc5d2c71509a7b" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Engine</source>
          <target state="translated">Phoenix.HTML.Engine</target>
        </trans-unit>
        <trans-unit id="3b67791df012124d0e4b2454857515f310c79756" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Form</source>
          <target state="translated">Phoenix.HTML.Form</target>
        </trans-unit>
        <trans-unit id="999475b0cb80ba68d5a56924e78e15906ac978b9" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData</source>
          <target state="translated">Phoenix.HTML.FormData</target>
        </trans-unit>
        <trans-unit id="04a8bfdcef89a105f09fe88aa2835a8c1ce4c4be" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.HTML.FormData &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="da04dc0f2d6b8acebef1fb005064e5a04b2ff3a0" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_type (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_type (3)</target>
        </trans-unit>
        <trans-unit id="3c5a41144956d8684f02352faac91bb53520389c" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_validations (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_validations (3)</target>
        </trans-unit>
        <trans-unit id="87c641775daf60819a26236f4e55fb074a6a99cc" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_value (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_value (3)</target>
        </trans-unit>
        <trans-unit id="8f602b3c4b4fd5b433a895b76de2afacbc126fdc" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.t (0)</source>
          <target state="translated">Phoenix.HTML.FormData.t (0)</target>
        </trans-unit>
        <trans-unit id="f7da9b9ca7ed512a02f17037b9fdbd9c9f60ebc7" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.to_form (2)</source>
          <target state="translated">Phoenix.HTML.FormData.to_form (2)</target>
        </trans-unit>
        <trans-unit id="5ccae6cd22b0a64bb0f4555803e5210d7d16c1d2" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.to_form (4)</source>
          <target state="translated">Phoenix.HTML.FormData.to_form (4)</target>
        </trans-unit>
        <trans-unit id="daf81ce2175003e5551acec3f22e912d6f354abb" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Format</source>
          <target state="translated">Phoenix.HTML.Format</target>
        </trans-unit>
        <trans-unit id="040e2511b94e8cd75bd6ecf44cc8a5d637238b81" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Link</source>
          <target state="translated">Phoenix.HTML.Link</target>
        </trans-unit>
        <trans-unit id="6932ff744b89afc815c5b8542af4342ea56a3340" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe</source>
          <target state="translated">Phoenix.HTML.Safe</target>
        </trans-unit>
        <trans-unit id="266d7c161ec8bc2e9c0e2d9960f206f4e4e9f771" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.HTML.Safe &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8224dbe21b25ec1c7a480134db55859fcaf6d339" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe.t (0)</source>
          <target state="translated">Phoenix.HTML.Safe.t (0)</target>
        </trans-unit>
        <trans-unit id="662e3232a3f3aa1d971e6a4dbf827fc2ef052645" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe.to_iodata (1)</source>
          <target state="translated">Phoenix.HTML.Safe.to_iodata (1)</target>
        </trans-unit>
        <trans-unit id="a88a5675b06fa29c744c634664506ce144b08e0c" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Tag</source>
          <target state="translated">Phoenix.HTML.Tag</target>
        </trans-unit>
        <trans-unit id="15bc0dd3064bf1544cd3525d8f90e79f8d804795" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveComponent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.LiveComponent &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4ec7eb0ddbc1d84c2fcd42aa72d279af0841bb6d" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveComponent.CID</source>
          <target state="translated">Phoenix.LiveComponent.CID</target>
        </trans-unit>
        <trans-unit id="ce050039bc61e74cab0f3b36832167a776ee32e5" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveDashboard</source>
          <target state="translated">Phoenix.LiveDashboard</target>
        </trans-unit>
        <trans-unit id="d5c9e2d0b4be8cf4dbe5577949d7e071899e8d84" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.LiveView &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cb34a295d4275d6652e8fa3e0a5be289acb5a6ad" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView integration</source>
          <target state="translated">Phoenix.LiveView integration</target>
        </trans-unit>
        <trans-unit id="d06e2fc999d230dc67b500f64b21855be96eb1d1" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Component</source>
          <target state="translated">Phoenix.LiveView.Component</target>
        </trans-unit>
        <trans-unit id="21a1450bfeac025097dd33f6fad5a5298c13f391" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Comprehension</source>
          <target state="translated">Phoenix.LiveView.Comprehension</target>
        </trans-unit>
        <trans-unit id="dbf3c6933625f2e5a39771b31bfb742dcffa1306" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Controller</source>
          <target state="translated">Phoenix.LiveView.Controller</target>
        </trans-unit>
        <trans-unit id="038d7ea3f40d5df873f2dc70ed76a5c46af11f6a" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Engine</source>
          <target state="translated">Phoenix.LiveView.Engine</target>
        </trans-unit>
        <trans-unit id="de95bab2a707b31105f16c03a897f8bff069263a" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Helpers</source>
          <target state="translated">Phoenix.LiveView.Helpers</target>
        </trans-unit>
        <trans-unit id="e71c55ccf44149bea5a566f4c782b56425f8d54c" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Rendered</source>
          <target state="translated">Phoenix.LiveView.Rendered</target>
        </trans-unit>
        <trans-unit id="c2c4561a50d0326965d11fce31649e3590629670" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Router</source>
          <target state="translated">Phoenix.LiveView.Router</target>
        </trans-unit>
        <trans-unit id="191541399aa2ae7946fe3ff5db4e5a8d4f7a5735" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Socket</source>
          <target state="translated">Phoenix.LiveView.Socket</target>
        </trans-unit>
        <trans-unit id="af64ed313e90463feb39736315f3d286d0b3fdb4" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveView.Socket.AssignsNotInSocket</source>
          <target state="translated">Phoenix.LiveView.Socket.AssignsNotInSocket</target>
        </trans-unit>
        <trans-unit id="062ec6e66d82135c22e8d091be64a98d2f844aaf" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveViewTest</source>
          <target state="translated">Phoenix.LiveViewTest</target>
        </trans-unit>
        <trans-unit id="fa60e33179840a769670ab655a92a39d4b2048eb" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveViewTest.Element</source>
          <target state="translated">Phoenix.LiveViewTest.Element</target>
        </trans-unit>
        <trans-unit id="34f98aa84f393f07a1e4c295a61ab28c224ca095" translate="yes" xml:space="preserve">
          <source>Phoenix.LiveViewTest.View</source>
          <target state="translated">Phoenix.LiveViewTest.View</target>
        </trans-unit>
        <trans-unit id="18ed4339cd679ede709262e5c7ca6dbb72bf11f9" translate="yes" xml:space="preserve">
          <source>Phoenix.Logger</source>
          <target state="translated">Phoenix.Logger</target>
        </trans-unit>
        <trans-unit id="18f54395c35b9ed069f39004e2697c661fbad386" translate="yes" xml:space="preserve">
          <source>Phoenix.MissingParamError</source>
          <target state="translated">Phoenix.MissingParamError</target>
        </trans-unit>
        <trans-unit id="7e80cad23896baef4ff1811bc9766d2b89732862" translate="yes" xml:space="preserve">
          <source>Phoenix.MissingParamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.MissingParamError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="af6e7971d9c75329ee2d5a112ce07dd63719b84c" translate="yes" xml:space="preserve">
          <source>Phoenix.Naming</source>
          <target state="translated">Phoenix.Naming</target>
        </trans-unit>
        <trans-unit id="77242a4c29eb130cfa68c2e99e1810423e07dcfb" translate="yes" xml:space="preserve">
          <source>Phoenix.NotAcceptableError</source>
          <target state="translated">Phoenix.NotAcceptableError</target>
        </trans-unit>
        <trans-unit id="8fc4c919fa9143f47d0d26d1af22cd3a40258486" translate="yes" xml:space="preserve">
          <source>Phoenix.NotAcceptableError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.NotAcceptableError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="78bc07bb7a9125c02ecf85d4c004e9bb157c2826" translate="yes" xml:space="preserve">
          <source>Phoenix.Param</source>
          <target state="translated">Phoenix.Param</target>
        </trans-unit>
        <trans-unit id="bb1d6188b5400f302d27eef68360a665984a8f62" translate="yes" xml:space="preserve">
          <source>Phoenix.Param &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.Param &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dd8ca2142234d167b5390c3462f591825869a497" translate="yes" xml:space="preserve">
          <source>Phoenix.Param.t (0)</source>
          <target state="translated">피닉스 파라 메 (0)</target>
        </trans-unit>
        <trans-unit id="c4b9da22cc6b8bc9499b0aa80a5680cf66ee196a" translate="yes" xml:space="preserve">
          <source>Phoenix.Param.to_param (1)</source>
          <target state="translated">Phoenix.Param.to_param (1)</target>
        </trans-unit>
        <trans-unit id="eeda5210386aed3128867da645c85a2274d2c0ff" translate="yes" xml:space="preserve">
          <source>Phoenix.Presence</source>
          <target state="translated">Phoenix.Presence</target>
        </trans-unit>
        <trans-unit id="1c6cee5a13060e94bd272116ce04a11edb0fb3ed" translate="yes" xml:space="preserve">
          <source>Phoenix.Presence &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">피닉스. 존재 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1771d26988e43bc483b78a4a7956bc399d115727" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub</source>
          <target state="translated">Phoenix.PubSub</target>
        </trans-unit>
        <trans-unit id="55fdbf7bc46ead98dfb476680697fd68af529b76" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub allows developers to perform custom dispatching by passing a &lt;code&gt;dispatcher&lt;/code&gt; module which is responsible for local message deliveries.</source>
          <target state="translated">Phoenix.PubSub allows developers to perform custom dispatching by passing a &lt;code&gt;dispatcher&lt;/code&gt; module which is responsible for local message deliveries.</target>
        </trans-unit>
        <trans-unit id="dab7bc24afbfad28a5c35e7c4ab160f9a6db2fd5" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Adapter &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.PubSub.Adapter &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6e7dc46902672959902aa22d4b06aba562d63612" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Application</source>
          <target state="translated">Phoenix.PubSub.Application</target>
        </trans-unit>
        <trans-unit id="e088adf91de21851153d82558f1b5b94e4fee9be" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.BroadcastError</source>
          <target state="translated">Phoenix.PubSub.BroadcastError</target>
        </trans-unit>
        <trans-unit id="c21b0fafbb5e8d03a8c3c6ae17dca1136b1dc3b5" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.BroadcastError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.PubSub.BroadcastError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="16d6a73345201c65a7626dd501d627ab27dfc9de" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.GC</source>
          <target state="translated">Phoenix.PubSub.GC</target>
        </trans-unit>
        <trans-unit id="7694b062d6fc42fc848d17abfab7ee653935a9ce" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Local</source>
          <target state="translated">Phoenix.PubSub.Local</target>
        </trans-unit>
        <trans-unit id="941fb28aafbbb815dd5c95a534c319ae3d36c36c" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.LocalSupervisor</source>
          <target state="translated">Phoenix.PubSub.LocalSupervisor</target>
        </trans-unit>
        <trans-unit id="7d910cadf0a19ada4a43c712efd81d787b209afe" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.PG2</source>
          <target state="translated">Phoenix.PubSub.PG2</target>
        </trans-unit>
        <trans-unit id="a68a8acd108d213f9a93e6df2b052eb4a81b5c20" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Supervisor</source>
          <target state="translated">Phoenix.PubSub.Supervisor</target>
        </trans-unit>
        <trans-unit id="30e9a959dc51235994d199ae35f8ecf6e3aafb98" translate="yes" xml:space="preserve">
          <source>Phoenix.Router</source>
          <target state="translated">Phoenix.Router</target>
        </trans-unit>
        <trans-unit id="3378c621c089530fde6dd6b7a8266f8a81e32044" translate="yes" xml:space="preserve">
          <source>Phoenix.Router.MalformedURIError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Router.MalformedURIError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a0fa225c88930ec3a4a05c9b434cd9ccfae83464" translate="yes" xml:space="preserve">
          <source>Phoenix.Router.NoRouteError</source>
          <target state="translated">Phoenix.Router.NoRouteError</target>
        </trans-unit>
        <trans-unit id="21a0480959213f5dafde91b500efd2b48392f822" translate="yes" xml:space="preserve">
          <source>Phoenix.Router.NoRouteError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Router.NoRouteError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="15c8b8a4eab6b63ce74836a0047c01c5d613caea" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket</source>
          <target state="translated">Phoenix.Socket</target>
        </trans-unit>
        <trans-unit id="5f4eb1aa819a708cc071efa9545599afd328835b" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">피닉스 소켓 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dec13932c8027eda323afb9aa03ee6266c07c5f1" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Broadcast</source>
          <target state="translated">Phoenix.Socket.Broadcast</target>
        </trans-unit>
        <trans-unit id="e6b39e263c2f93b46a5e61347b46e247bb3ea74a" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.InvalidMessageError</source>
          <target state="translated">Phoenix.Socket.InvalidMessageError</target>
        </trans-unit>
        <trans-unit id="6eabb3d1eca5d0468cd5c297c1d0d6e9b273dfc2" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.InvalidMessageError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Socket.InvalidMessageError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cc1215c6ff861301db6a6265e25b4296d73eb2bb" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Message</source>
          <target state="translated">Phoenix.Socket.Message</target>
        </trans-unit>
        <trans-unit id="536df0a73a189404cc538ce4401d0b55e578ae8e" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Reply</source>
          <target state="translated">Phoenix.Socket.Reply</target>
        </trans-unit>
        <trans-unit id="de15c3dd1c21eebe4f02b6a3a2b217df0bec553e" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Serializer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Socket.Serializer &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="975a6a8cb29b023db1536efe366a0246b8f8f73f" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Transport</source>
          <target state="translated">Phoenix.Socket.Transport</target>
        </trans-unit>
        <trans-unit id="7100002fc16c82bbe7ff3fb56a65c5478a47d59c" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Transport &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Socket.Transport &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8ae4b158e8dce3b5d2defd5c648cfa621670fcff" translate="yes" xml:space="preserve">
          <source>Phoenix.Template</source>
          <target state="translated">Phoenix.Template</target>
        </trans-unit>
        <trans-unit id="3116ab3ec2d51d6a59cc0b58a78dcf0c1705d6a4" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.EExEngine</source>
          <target state="translated">Phoenix.Template.EExEngine</target>
        </trans-unit>
        <trans-unit id="0a01340729120640cbc0f60d173d14a93cd917a3" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.Engine</source>
          <target state="translated">Phoenix.Template.Engine</target>
        </trans-unit>
        <trans-unit id="1ad27c23cf4f858125bea91c2e7c75356d89a714" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.Engine &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Template.Engine &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="234d6d4a6b93dd62f2590b3842d1a7d46378d167" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.ExsEngine</source>
          <target state="translated">Phoenix.Template.ExsEngine</target>
        </trans-unit>
        <trans-unit id="2a322c29f1da50c5ce310b3c32a380db55975eb6" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.HTML</source>
          <target state="translated">Phoenix.Template.HTML</target>
        </trans-unit>
        <trans-unit id="45ce2441c1e0bca5729eef8b018bba81e9a40cf8" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.UndefinedError</source>
          <target state="translated">Phoenix.Template.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b717ca75c096168f81cb863370a119961f1e124a" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Template.UndefinedError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4100edf3175789316497437c6450655389771ed7" translate="yes" xml:space="preserve">
          <source>Phoenix.Token</source>
          <target state="translated">Phoenix.Token</target>
        </trans-unit>
        <trans-unit id="617049e3dee7e40fb8b99dfc1f2e1b4b83118d7a" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker</source>
          <target state="translated">Phoenix.Tracker</target>
        </trans-unit>
        <trans-unit id="04f9c2ab9d80b402057013e3c8dbe36d1656374a" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Tracker &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c21af06db2da4ef620e3dc022eb3c8ecfc7364d4" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.Shard</source>
          <target state="translated">Phoenix.Tracker.Shard</target>
        </trans-unit>
        <trans-unit id="542ae29baa6557b6ae9b127e5619f2f2d2353b4c" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.Shard &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Tracker.Shard &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="789ba99bf73efbcedc95f1b2f2b5ff382b8db713" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.State</source>
          <target state="translated">Phoenix.Tracker.State</target>
        </trans-unit>
        <trans-unit id="d92e8bf63e6d221807acdde4e7dab43bdab64274" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.LongPoll</source>
          <target state="translated">Phoenix.Transports.LongPoll</target>
        </trans-unit>
        <trans-unit id="c0495d5fc1db092780a2235609f5cf672dc23581" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.Serializer</source>
          <target state="translated">Phoenix.Transports.Serializer</target>
        </trans-unit>
        <trans-unit id="50339ae5aa447a89cb481302464a30dc2d96b2b7" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.Serializer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Transports.Serializer &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="74d4a8b3f14220f0f7e61bf4984dc37d4c5be450" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.WebSocket</source>
          <target state="translated">Phoenix.Transports.WebSocket</target>
        </trans-unit>
        <trans-unit id="9a429996206e9b73a474596f699b2eda6333bd55" translate="yes" xml:space="preserve">
          <source>Phoenix.View</source>
          <target state="translated">Phoenix.View</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="f48c581069059c13328af0b2e2818126b82fd34a" translate="yes" xml:space="preserve">
          <source>Pipelines and plugs</source>
          <target state="translated">파이프 라인 및 플러그</target>
        </trans-unit>
        <trans-unit id="21fd94c1d3aece31c037e4ad2d773532d2314416" translate="yes" xml:space="preserve">
          <source>Pipelines are a series of plugs that can be attached to specific scopes. If you are not familiar with plugs, we have an &lt;a href=&quot;plug&quot;&gt;in-depth guide about them&lt;/a&gt;.</source>
          <target state="translated">파이프 라인은 특정 범위에 연결할 수있는 일련의 플러그입니다. 플러그에 익숙하지 않은 경우 해당 플러그에 &lt;a href=&quot;plug&quot;&gt;대한 심층 가이드가 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4481e68159859f03e70cf9a77f061d044faa36" translate="yes" xml:space="preserve">
          <source>Pipelines are defined at the router root and can be used from any scope.</source>
          <target state="translated">파이프 라인은 라우터 루트에서 정의되며 모든 범위에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6919c5e978569b7c38dd5e903c954441364fed" translate="yes" xml:space="preserve">
          <source>Plans a query using the given adapter</source>
          <target state="translated">주어진 어댑터를 사용하여 쿼리 계획</target>
        </trans-unit>
        <trans-unit id="1060e726672f4517cb496b202d24b08618a977cc" translate="yes" xml:space="preserve">
          <source>Plans a query using the given adapter.</source>
          <target state="translated">주어진 어댑터를 사용하여 쿼리를 계획합니다.</target>
        </trans-unit>
        <trans-unit id="23441c76f8f0fea9cebdad7024ae9d43267ca0fd" translate="yes" xml:space="preserve">
          <source>Plans and prepares a query for the given repo, leveraging its query cache</source>
          <target state="translated">쿼리 리포지토리를 활용하여 지정된 리포지토리에 대한 쿼리 계획 및 준비</target>
        </trans-unit>
        <trans-unit id="1e55e74adc560a8ce58ea242927a6a7d15ecd946" translate="yes" xml:space="preserve">
          <source>Plans and prepares a query for the given repo, leveraging its query cache.</source>
          <target state="translated">쿼리 캐시를 활용하여 지정된 리포지토리에 대한 쿼리를 계획하고 준비합니다.</target>
        </trans-unit>
        <trans-unit id="5546110269fb9b179862651acd41e4db4d75730a" translate="yes" xml:space="preserve">
          <source>Play around a bit. Whatever you put after &lt;code&gt;/hello/&lt;/code&gt; will appear on the page as your messenger.</source>
          <target state="translated">약간 놀아보세요. &lt;code&gt;/hello/&lt;/code&gt; 뒤에 넣은 것은 무엇이든 메신저로 페이지에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4e9efbf61297042078f0e61a851e7de6288b9450" translate="yes" xml:space="preserve">
          <source>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won&amp;rsquo;t work:</source>
          <target state="translated">이것이 작동하려면 데이터베이스에서 기존 구조체를로드해야합니다. 따라서 구조체가 존재하더라도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46cf066203bde34cc7cdf7fe5ed30c7f4a26f4de" translate="yes" xml:space="preserve">
          <source>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won't work:</source>
          <target state="translated">Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won't work:</target>
        </trans-unit>
        <trans-unit id="b7fbb8a6dd50cf08d9f76c5cf9b730d1437190c9" translate="yes" xml:space="preserve">
          <source>Please note that specifying a cipher as a binary string is not valid and would silently fail in the past. This was problematic because the result would be for Erlang to use the default list of ciphers. To prevent this Plug will now throw an error to ensure you&amp;rsquo;re aware of this.</source>
          <target state="translated">암호를 이진 문자열로 지정하는 것은 유효하지 않으며 과거에는 자동으로 실패합니다. 결과는 Erlang이 기본 암호 목록을 사용하기 때문에 문제가되었습니다. 이 플러그를 방지하려면 이제이를 인식 할 수 있도록 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91e1335792877d04ea770f392aee951ccaf83e70" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; module for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71d46d4ede9a703932de8cc19e99a761cead78fc" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; documentation&lt;/a&gt; for details on the supported configuration options.</source>
          <target state="translated">지원되는 구성 옵션에 대한 자세한 내용 은 &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;Erlang / OTP &lt;code&gt;:ssl&lt;/code&gt; 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38b76b0964244ce878b571fe54c2753a4fcf3896" translate="yes" xml:space="preserve">
          <source>Please take a look at this list and make sure to install anything necessary for your system. Having dependencies installed in advance can prevent frustrating problems later on.</source>
          <target state="translated">이 목록을 살펴보고 시스템에 필요한 모든 것을 설치했는지 확인하십시오. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 종속성을 미리 설치하면 나중에 문제가되는 문제를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce109d49823084600b80720242d87140dd6592f" translate="yes" xml:space="preserve">
          <source>Plug</source>
          <target state="translated">Plug</target>
        </trans-unit>
        <trans-unit id="7c7e4fdd3cdc2dff539b9f180562230cfc46d2c5" translate="yes" xml:space="preserve">
          <source>Plug &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="842f5e559c3807099e83fb23d693645950119cff" translate="yes" xml:space="preserve">
          <source>Plug Configuration Impact</source>
          <target state="translated">플러그 구성 영향</target>
        </trans-unit>
        <trans-unit id="12732fc8131e6b226a95926ba5de3ef015ce7c61" translate="yes" xml:space="preserve">
          <source>Plug Options</source>
          <target state="translated">플러그 옵션</target>
        </trans-unit>
        <trans-unit id="15c8311c78620445d44f639385af88e3c6c0f460" translate="yes" xml:space="preserve">
          <source>Plug allows a developer to build query strings that map to Elixir structures in order to make manipulation of such structures easier on the server side. Here are some examples:</source>
          <target state="translated">플러그를 사용하면 개발자가 서버 측에서 이러한 구조를보다 쉽게 ​​조작 할 수 있도록 Elixir 구조에 매핑되는 쿼리 문자열을 작성할 수 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="0d7695d45b2ae4da14ca5714a056f98cf87a2384" translate="yes" xml:space="preserve">
          <source>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&quot;Not Found&quot; by default) and add a new 998 status code, the following config can be specified:</source>
          <target state="translated">Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&quot;Not Found&quot; by default) and add a new 998 status code, the following config can be specified:</target>
        </trans-unit>
        <trans-unit id="c0116ba430886361e4c51fe8937ae9b7eec35f8e" translate="yes" xml:space="preserve">
          <source>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&amp;ldquo;Not Found&amp;rdquo; by default) and add a new 451 status code, the following config can be specified:</source>
          <target state="translated">플러그를 사용하면 플러그 나 해당 어댑터에서 직접 지정하지 않은 새 코드를 허용하기 위해 상태 코드를 재정의하거나 추가 할 수 있습니다. 상태 코드 추가 또는 재정의는 &lt;code&gt;:plug&lt;/code&gt; 애플리케이션 의 혼합 구성을 통해 수행됩니다 . 예를 들어, 404 상태 코드의 기존 404 이유 구문을 무시하고 (기본적으로 &quot;찾을 수 없음&quot;) 새로운 451 상태 코드를 추가하려면 다음 구성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc79b11ec870c9eae9ae7413b1d48d08eaf38429" translate="yes" xml:space="preserve">
          <source>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&amp;ldquo;Not Found&amp;rdquo; by default) and add a new 998 status code, the following config can be specified:</source>
          <target state="translated">플러그를 사용하면 플러그 나 어댑터에서 직접 지정하지 않은 새 코드를 허용하기 위해 상태 코드를 재정의하거나 추가 할 수 있습니다. 상태 코드 추가 또는 재정의는 &lt;code&gt;:plug&lt;/code&gt; 애플리케이션 의 혼합 구성을 통해 수행됩니다 . 예를 들어, 404 상태 코드의 기존 404 이유 문구를 무시하고 (기본적으로 &quot;찾을 수 없음&quot;) 새로운 998 상태 코드를 추가하려면 다음 구성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18c657519b38c3613274954c2cdf6a713c33b59" translate="yes" xml:space="preserve">
          <source>Plug behaviour</source>
          <target state="translated">플러그 동작</target>
        </trans-unit>
        <trans-unit id="56c386f50ae467be1b5113eddd7aa6480ba26564" translate="yes" xml:space="preserve">
          <source>Plug can serve HTTP over TLS ('HTTPS') through an appropriately configured Adapter. While the exact syntax for defining an HTTPS listener is adapter-specific, Plug does define a common set of TLS configuration options that most adapters support, formally documented as &lt;a href=&quot;plug.ssl#configure/1&quot;&gt;&lt;code&gt;Plug.SSL.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Plug는 적절하게 구성된 어댑터를 통해 HTTP over TLS ( 'HTTPS')를 제공 할 수 있습니다. HTTPS 리스너를 정의하는 정확한 구문은 어댑터별로 다르지만 Plug는 대부분의 어댑터가 지원하는 공통 TLS 구성 옵션 세트를 정의하며 공식적으로는 &lt;a href=&quot;plug.ssl#configure/1&quot;&gt; &lt;code&gt;Plug.SSL.configure/1&lt;/code&gt; &lt;/a&gt; 로 문서화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a40628d1ac1f915c79a5953f6c04a1c8de88e590" translate="yes" xml:space="preserve">
          <source>Plug initialization callback</source>
          <target state="translated">플러그 초기화 콜백</target>
        </trans-unit>
        <trans-unit id="5106d525f5ec5116b03e8d92705c063c0ee06ab9" translate="yes" xml:space="preserve">
          <source>Plug initialization callback.</source>
          <target state="translated">초기화 콜백을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="abd871fb020904ad154a8b9db83a32e57e18844d" translate="yes" xml:space="preserve">
          <source>Plug lives at the heart of Phoenix's HTTP layer, and Phoenix puts Plug front and center. We interact with plugs at every step of the request life-cycle, and the core Phoenix components like Endpoints, Routers, and Controllers are all just Plugs internally. Let's jump in and find out just what makes Plug so special.</source>
          <target state="translated">Plug는 Phoenix의 HTTP 계층의 중심에 있으며 Phoenix는 Plug를 최우선으로 생각합니다. 요청 수명주기의 모든 단계에서 플러그와 상호 작용하며 엔드 포인트, 라우터 및 컨트롤러와 같은 핵심 Phoenix 구성 요소는 모두 내부적으로 플러그 일뿐입니다. 뛰어 들어서 Plug가 특별한 이유를 알아 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e910974c1e028c594bce3d68cef33fd5394e7df8" translate="yes" xml:space="preserve">
          <source>Plug pipeline</source>
          <target state="translated">플러그 파이프 라인</target>
        </trans-unit>
        <trans-unit id="fc8dd83ae44bb059cc7802314fed9a543d1c702f" translate="yes" xml:space="preserve">
          <source>Plug pipeline callback</source>
          <target state="translated">플러그 파이프 라인 콜백</target>
        </trans-unit>
        <trans-unit id="38b80698245f8c4f0b9bb325123b02f8db8735b7" translate="yes" xml:space="preserve">
          <source>Plug pipeline callback.</source>
          <target state="translated">파이프 라인 콜백을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5b8d7df3246be1fd76c07e99f8e23e2c642d34a3" translate="yes" xml:space="preserve">
          <source>Plug ships with the following parsers:</source>
          <target state="translated">다음과 같은 파서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="64750cb1a06f5010538b48f3144265324fda1dac" translate="yes" xml:space="preserve">
          <source>Plug ships with the following session stores:</source>
          <target state="translated">플러그는 다음 세션 저장소와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88e430fe4000c7309065c41f50017a5014756368" translate="yes" xml:space="preserve">
          <source>Plug to protect from cross-site request forgery.</source>
          <target state="translated">사이트 간 요청 위조로부터 보호하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="5090d5e35ab4a0e3c9892e222f65ca37cc39f4d8" translate="yes" xml:space="preserve">
          <source>Plug.Adapters.Cowboy</source>
          <target state="translated">Plug.Adapters.Cowboy</target>
        </trans-unit>
        <trans-unit id="03e978ece5c71b0b11092b3e53a7b5c35b21b895" translate="yes" xml:space="preserve">
          <source>Plug.Adapters.Cowboy2</source>
          <target state="translated">Plug.Adapters.Cowboy2</target>
        </trans-unit>
        <trans-unit id="1f02f113800b0cf10c9ab32938948463ae8051be" translate="yes" xml:space="preserve">
          <source>Plug.BadRequestError</source>
          <target state="translated">Plug.BadRequestError</target>
        </trans-unit>
        <trans-unit id="62f108c33076c27169358f8ecd89e35a38697289" translate="yes" xml:space="preserve">
          <source>Plug.BadRequestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.BadRequestError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1ed4e9a56d20d3b03a2e2615f588ea204793d2e6" translate="yes" xml:space="preserve">
          <source>Plug.BasicAuth</source>
          <target state="translated">Plug.BasicAuth</target>
        </trans-unit>
        <trans-unit id="f8aa731ebba0d5376c075f74c1c69f7628d45c49" translate="yes" xml:space="preserve">
          <source>Plug.Builder</source>
          <target state="translated">Plug.Builder</target>
        </trans-unit>
        <trans-unit id="3724cc2f092149d8ded98361fbf5df7e0282b2b8" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection</source>
          <target state="translated">Plug.CSRFProtection</target>
        </trans-unit>
        <trans-unit id="b1c348e6fedac292667c5449e7e31b6111c64863" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCSRFTokenError</source>
          <target state="translated">Plug.CSRFProtection.InvalidCSRFTokenError</target>
        </trans-unit>
        <trans-unit id="097dd5324eeaac24afcb1a5c24a608dc76f3dca4" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d2a2e7efa35695745f63a5dc0d1d7fb5475eb72a" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCrossOriginRequestError</source>
          <target state="translated">Plug.CSRFProtection.InvalidCrossOriginRequestError</target>
        </trans-unit>
        <trans-unit id="a33fafd111d45648b8b5e9f6dc1392feabbea6d8" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCrossOriginRequestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.CSRFProtection.InvalidCrossOriginRequestError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40cce800a5c3149b46d4f3c35a5189042a167861" translate="yes" xml:space="preserve">
          <source>Plug.Conn</source>
          <target state="translated">Plug.Conn</target>
        </trans-unit>
        <trans-unit id="b574632d3cdd4e84e014f0a2f6cfb904422686f2" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Adapter &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 연결 어댑터 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="21747133d0bfbba57a64eaa43478a6f881fb3f3d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.AlreadySentError</source>
          <target state="translated">Plug.Conn.AlreadySentError</target>
        </trans-unit>
        <trans-unit id="8b34f269cef9b38f4bc80cd1ea87510fa961e0f3" translate="yes" xml:space="preserve">
          <source>Plug.Conn.AlreadySentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.AlreadySentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3a21400c358e3bbe2ec0b0db6c914de64499de5b" translate="yes" xml:space="preserve">
          <source>Plug.Conn.CookieOverflowError</source>
          <target state="translated">Plug.Conn.CookieOverflowError</target>
        </trans-unit>
        <trans-unit id="bc996d1c97e7362b9076b9e286d3612430f2c073" translate="yes" xml:space="preserve">
          <source>Plug.Conn.CookieOverflowError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.CookieOverflowError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bb86f659414f21859b56e588dfc82241895d0095" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Cookies</source>
          <target state="translated">Plug.Conn.Cookies</target>
        </trans-unit>
        <trans-unit id="da591d1d7cccd223cfb43581f16c408d4a2cacce" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidHeaderError</source>
          <target state="translated">Plug.Conn.InvalidHeaderError</target>
        </trans-unit>
        <trans-unit id="4b8c631413aee6b7519be91a5b52f0885e00f535" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidHeaderError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.InvalidHeaderError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6084b6ee3204533a4e0ee26ce3e9fced7e012fc6" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidQueryError</source>
          <target state="translated">Plug.Conn.InvalidQueryError</target>
        </trans-unit>
        <trans-unit id="4b06f1704e9fd1f811248b8b1fd13f98567d4081" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidQueryError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.InvalidQueryError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3fd422bf6d8a706b9088311ea1d7b3b6fcc2e41d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.NotSentError</source>
          <target state="translated">Plug.Conn.NotSentError</target>
        </trans-unit>
        <trans-unit id="5e701691f17997fa509597535b633f539e6f6c4c" translate="yes" xml:space="preserve">
          <source>Plug.Conn.NotSentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.NotSentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e24ef7997c87cf0d8ce006d67ec035cbd96bc7df" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Query</source>
          <target state="translated">Plug.Conn.Query</target>
        </trans-unit>
        <trans-unit id="6dd8c22a9766d4d4e60af03e7e9bbabc455f0d8b" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Status</source>
          <target state="translated">Plug.Conn.Status</target>
        </trans-unit>
        <trans-unit id="5f2737d23cbee85ece48e300b66a00d869c9c59d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Unfetched</source>
          <target state="translated">Plug.Conn.Unfetched</target>
        </trans-unit>
        <trans-unit id="f227231e634d98406467ac2e60b3a784848a0bf9" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Utils</source>
          <target state="translated">Plug.Conn.Utils</target>
        </trans-unit>
        <trans-unit id="75d6bfa4228ea10ed3fae55b45519d715f536789" translate="yes" xml:space="preserve">
          <source>Plug.Conn.WrapperError</source>
          <target state="translated">Plug.Conn.WrapperError</target>
        </trans-unit>
        <trans-unit id="916f1c91b3d6db7431dd35c4802b03978cc32827" translate="yes" xml:space="preserve">
          <source>Plug.Conn.WrapperError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.WrapperError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="90e881fa81ef7e1a364897f8bfee5f69522eb5fe" translate="yes" xml:space="preserve">
          <source>Plug.Crypto.KeyGenerator</source>
          <target state="translated">Plug.Crypto.KeyGenerator</target>
        </trans-unit>
        <trans-unit id="9ebe5fdf96d10885c53378f87f6d73689c67c247" translate="yes" xml:space="preserve">
          <source>Plug.Debugger</source>
          <target state="translated">Plug.Debugger</target>
        </trans-unit>
        <trans-unit id="809456b3866bd5506e874b687e4cdf3fd432d440" translate="yes" xml:space="preserve">
          <source>Plug.ErrorHandler</source>
          <target state="translated">Plug.ErrorHandler</target>
        </trans-unit>
        <trans-unit id="ff4257149d3299183c285078a2489a915774bbea" translate="yes" xml:space="preserve">
          <source>Plug.Exception</source>
          <target state="translated">Plug.Exception</target>
        </trans-unit>
        <trans-unit id="0504b1ef3bee2522df1fdfeecf35f72aecebc259" translate="yes" xml:space="preserve">
          <source>Plug.Exception &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">플러그 예외 &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2998037144bd1f54ad2f8e422b89e12a3d119d7a" translate="yes" xml:space="preserve">
          <source>Plug.Exception.status (1)</source>
          <target state="translated">플러그 예외 상태 (1)</target>
        </trans-unit>
        <trans-unit id="8af4ca46e5e70e0e9795051b8460287f7eaa2f8d" translate="yes" xml:space="preserve">
          <source>Plug.Exception.t (0)</source>
          <target state="translated">Plug.Exception.t (0)</target>
        </trans-unit>
        <trans-unit id="4a7d66791479787bc515114a800979b54a9b7757" translate="yes" xml:space="preserve">
          <source>Plug.HTML</source>
          <target state="translated">Plug.HTML</target>
        </trans-unit>
        <trans-unit id="3a840b7b9c77d348c2b126f57c2069444d3d1fdc" translate="yes" xml:space="preserve">
          <source>Plug.Head</source>
          <target state="translated">Plug.Head</target>
        </trans-unit>
        <trans-unit id="86a6b3d2f49a74c2002106a79162c6c46bf3a7c2" translate="yes" xml:space="preserve">
          <source>Plug.Logger</source>
          <target state="translated">Plug.Logger</target>
        </trans-unit>
        <trans-unit id="3da20dbeffc9bfc2bb63ffc107d51974f1874ddd" translate="yes" xml:space="preserve">
          <source>Plug.MethodOverride</source>
          <target state="translated">Plug.MethodOverride</target>
        </trans-unit>
        <trans-unit id="52bbcba025427fab650fee21f34d2921068f4144" translate="yes" xml:space="preserve">
          <source>Plug.Parsers &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 파서 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7360a1de6131ce36267daffb90d2574809710fb6" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.BadEncodingError</source>
          <target state="translated">Plug.Parsers.BadEncodingError</target>
        </trans-unit>
        <trans-unit id="f6d5837a2fbd93e1b540a45b655fa943932d1c08" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.BadEncodingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.BadEncodingError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="855ca5aa37685f9246e0a3d8228826b72b78092e" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.JSON</source>
          <target state="translated">Plug.Parsers.JSON</target>
        </trans-unit>
        <trans-unit id="024a759252607a0ac59a432047a2bc74c33af7e9" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.MULTIPART</source>
          <target state="translated">Plug.Parsers.MULTIPART</target>
        </trans-unit>
        <trans-unit id="76a4d5762584a4b7f59159357c1bd7895dd5e8ce" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.ParseError</source>
          <target state="translated">Plug.Parsers.ParseError</target>
        </trans-unit>
        <trans-unit id="88cae26afd90e4bc5abf7fe34771f3ba5368c901" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.ParseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="65505ee433f3dbdb794c60edfd34a579c212a0d0" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.RequestTooLargeError</source>
          <target state="translated">Plug.Parsers.RequestTooLargeError</target>
        </trans-unit>
        <trans-unit id="361328f684541740489e610c866019abc75dded5" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.RequestTooLargeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.RequestTooLargeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="957831edf9da6029c93cb308770bb29228a089d6" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.URLENCODED</source>
          <target state="translated">Plug.Parsers.URLENCODED</target>
        </trans-unit>
        <trans-unit id="143b275d9257366e6d82561d78bd2421da66cb30" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.UnsupportedMediaTypeError</source>
          <target state="translated">Plug.Parsers.UnsupportedMediaTypeError</target>
        </trans-unit>
        <trans-unit id="79420b94d6b1a53eb948ca3af6e128d4cc7f44ca" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="06bf7d7b55e12b27fb50cc99fe83ea30b9346e15" translate="yes" xml:space="preserve">
          <source>Plug.RequestId</source>
          <target state="translated">Plug.RequestId</target>
        </trans-unit>
        <trans-unit id="9eb4dfd85965b99b43a51d867910ae4d74bd8e90" translate="yes" xml:space="preserve">
          <source>Plug.RewriteOn</source>
          <target state="translated">Plug.RewriteOn</target>
        </trans-unit>
        <trans-unit id="49161d756392f8ec1392dde7491564dc0215c712" translate="yes" xml:space="preserve">
          <source>Plug.Router</source>
          <target state="translated">Plug.Router</target>
        </trans-unit>
        <trans-unit id="ebd8ca539d2898fa6f492bc221cd9e791fca1e81" translate="yes" xml:space="preserve">
          <source>Plug.Router.InvalidSpecError</source>
          <target state="translated">Plug.Router.InvalidSpecError</target>
        </trans-unit>
        <trans-unit id="7cdb4b390957aa3b87fe6177cef5151bc4977d77" translate="yes" xml:space="preserve">
          <source>Plug.Router.InvalidSpecError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Router.InvalidSpecError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b428b60e2fdcc5916735c89013b8177a545d6cd7" translate="yes" xml:space="preserve">
          <source>Plug.Router.MalformedURIError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Router.MalformedURIError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e7ce22e4d4207804b1374c8cb497427d07f3c012" translate="yes" xml:space="preserve">
          <source>Plug.SSL</source>
          <target state="translated">Plug.SSL</target>
        </trans-unit>
        <trans-unit id="f9642818ecfbe9b8db3eab15f59172c99b7aece4" translate="yes" xml:space="preserve">
          <source>Plug.Session</source>
          <target state="translated">Plug.Session</target>
        </trans-unit>
        <trans-unit id="1bfe72ba72028781f0595aaf9082533f79601722" translate="yes" xml:space="preserve">
          <source>Plug.Session.COOKIE</source>
          <target state="translated">Plug.Session.COOKIE</target>
        </trans-unit>
        <trans-unit id="24e9adee8c5223a3e2b35470c0f1dee004a2be00" translate="yes" xml:space="preserve">
          <source>Plug.Session.ETS</source>
          <target state="translated">Plug.Session.ETS</target>
        </trans-unit>
        <trans-unit id="8c191a111bd1ca8943c3102027f68110273163d4" translate="yes" xml:space="preserve">
          <source>Plug.Session.Store &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 세션 세션 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e63cee1c407f2c1f3c562da1c78a36b81b4bcfbf" translate="yes" xml:space="preserve">
          <source>Plug.Static</source>
          <target state="translated">Plug.Static</target>
        </trans-unit>
        <trans-unit id="fe95991608b633b478b7f474acc041afec3bea64" translate="yes" xml:space="preserve">
          <source>Plug.Static will be unable to serve assets if you build releases or if you change the current directory. Instead do:</source>
          <target state="translated">릴리스를 빌드하거나 현재 디렉토리를 변경하면 Plug.Static이 자산을 제공 할 수 없습니다. 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d72df0cbd6329f7e5d3edfcbfc7744bbaaa0351c" translate="yes" xml:space="preserve">
          <source>Plug.Static.InvalidPathError</source>
          <target state="translated">Plug.Static.InvalidPathError</target>
        </trans-unit>
        <trans-unit id="33732960284e22902e1286c6ddbb3f27a366dee0" translate="yes" xml:space="preserve">
          <source>Plug.Static.InvalidPathError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Static.InvalidPathError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f473e3ca6d5281991466c9fed4c1226dd8a663a0" translate="yes" xml:space="preserve">
          <source>Plug.Telemetry</source>
          <target state="translated">Plug.Telemetry</target>
        </trans-unit>
        <trans-unit id="8a95623d184b4a606beb18e0ffe9ceab5b1dfc41" translate="yes" xml:space="preserve">
          <source>Plug.Test</source>
          <target state="translated">Plug.Test</target>
        </trans-unit>
        <trans-unit id="f0f104d7c8ff4f8bf0d638ab38f4177ce4dba122" translate="yes" xml:space="preserve">
          <source>Plug.TimeoutError</source>
          <target state="translated">Plug.TimeoutError</target>
        </trans-unit>
        <trans-unit id="d001ebce35384c272e36b2fcd0073ce401d87d19" translate="yes" xml:space="preserve">
          <source>Plug.TimeoutError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.TimeoutError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bebfb71e1da02cb5ce594139b71e5dd8e2145faf" translate="yes" xml:space="preserve">
          <source>Plug.Upload</source>
          <target state="translated">Plug.Upload</target>
        </trans-unit>
        <trans-unit id="35a35df1cacf3bebd2793aae156668ed4d1d84e6" translate="yes" xml:space="preserve">
          <source>Plug.UploadError</source>
          <target state="translated">Plug.UploadError</target>
        </trans-unit>
        <trans-unit id="43131ab6badbba7b97b5b90ab7649a8ea2a80322" translate="yes" xml:space="preserve">
          <source>Plug.UploadError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.UploadError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="aa5635f37c09419c148590affa75c4ab4128f8a5" translate="yes" xml:space="preserve">
          <source>Plugs as composition</source>
          <target state="translated">구성으로 플러그</target>
        </trans-unit>
        <trans-unit id="3043ffa369068e896903e8a4971fde40dabfdd42" translate="yes" xml:space="preserve">
          <source>Polymorphic associations</source>
          <target state="translated">다형성 연관</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
