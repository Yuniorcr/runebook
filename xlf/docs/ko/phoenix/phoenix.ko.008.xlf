<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="3f1d6571352636299c2a638ffac8ee18e017790a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module provides the &lt;code&gt;put_layout/2&lt;/code&gt; function for us to switch layouts. This takes &lt;code&gt;conn&lt;/code&gt; as its first argument and a string for the basename of the layout we want to render. It also accepts &lt;code&gt;false&lt;/code&gt; to disable the layout altogether.</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller&quot;&gt; &lt;code&gt;Phoenix.Controller&lt;/code&gt; 의&lt;/a&gt; 모듈은 제공 &lt;code&gt;put_layout/2&lt;/code&gt; 스위치 레이아웃에 우리를 위해 기능. 이것은 걸립니다 &lt;code&gt;conn&lt;/code&gt; 첫 번째 인자 우리가 렌더링 할 레이아웃의 기본 이름에 대한 문자열로. 또한 레이아웃을 모두 비활성화하려면 &lt;code&gt;false&lt;/code&gt; 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="207e43d957b25557eabcceb34d7699aa7a77e89f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; callback is invoked after &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and before the initial render. It is also invoked every time &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; are used. It receives the request parameters as first argument, the url as second, and the socket as third.</source>
          <target state="translated">&lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt; 콜백 후 호출 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 하고 초기 전에 렌더링합니다. 또한 &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; &lt;/a&gt; 가 사용될 때마다 호출 됩니다. 요청 매개 변수를 첫 번째 인수로, url을 두 번째로, 소켓을 세 번째로받습니다.</target>
        </trans-unit>
        <trans-unit id="a3ab5765089e37fe00cdc982a6c6127904496f5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; implementation for examples.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 의&lt;/a&gt; API의 모든 기능이 매칭 어댑터로부터의 응답을 처리 할 수 &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; . PubSub 클라이언트는 결과가 리턴 될 때까지 모든 MFA 응답을 재귀 적으로 호출합니다. PubSub 어댑터를 차단하지 않고 클라이언트로 작업을 오프로드하는 데 유용합니다. 예제는 &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt; 구현을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b0c9e11a76593a12fc7ec6f78afc56ab4d36aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; implementation for examples.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 의&lt;/a&gt; API의 모든 기능이 매칭 어댑터로부터의 응답을 처리 할 수 &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; . PubSub 클라이언트는 결과가 리턴 될 때까지 모든 MFA 응답을 재귀 적으로 호출합니다. PubSub 어댑터를 차단하지 않고 클라이언트로 작업을 오프로드하는 데 유용합니다. 예제는 &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; 구현을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f059f03c50e25491e9ade11affa506a5c85827c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#forward/4&quot;&gt;&lt;code&gt;Phoenix.Router.forward/4&lt;/code&gt;&lt;/a&gt; macro can be used to send all requests that start with a particular path to a particular plug. Let's say we have a part of our system that is responsible (it could even be a separate application or library) for running jobs in the background, it could have its own web interface for checking the status of the jobs. We can forward to this admin interface using:</source>
          <target state="translated">&lt;a href=&quot;phoenix.router#forward/4&quot;&gt; &lt;code&gt;Phoenix.Router.forward/4&lt;/code&gt; &lt;/a&gt; 매크로는 특정 플러그인에 특정 경로로 시작하는 모든 요청을 보내는 데 사용할 수 있습니다. 백그라운드에서 작업을 실행하는 시스템의 일부 (별도의 애플리케이션 또는 라이브러리 일 수도 있음)가 있다고 가정 해 보겠습니다. 작업 상태를 확인하기위한 자체 웹 인터페이스가있을 수 있습니다. 다음을 사용하여이 관리 인터페이스로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf89a86a0eb3ec72901bbad36238d748fb754a69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#resources/4&quot;&gt;&lt;code&gt;Phoenix.Router.resources/4&lt;/code&gt;&lt;/a&gt; macro describes additional options for customizing resource routes.</source>
          <target state="translated">&lt;a href=&quot;phoenix.router#resources/4&quot;&gt; &lt;code&gt;Phoenix.Router.resources/4&lt;/code&gt; &lt;/a&gt; 매크로는 자원 경로를 사용자 지정하기위한 추가 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f32ca35c51fcd8b2c79b98aed4633cc99e6aea64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; module provides conveniences for building plug pipelines.</source>
          <target state="translated">&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 의&lt;/a&gt; 모듈은 플러그 파이프 라인을 구축하기위한 편의를 제공한다.</target>
        </trans-unit>
        <trans-unit id="d6e79dbadb31903b9f92905b4723d4810b1bea76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; event is sent by the transport when a channel exits, and represents the channel terminating against its will. The &lt;a href=&quot;#on_exit_message/3&quot;&gt;&lt;code&gt;on_exit_message/3&lt;/code&gt;&lt;/a&gt; function aids in constructing the &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; 이벤트는 경우 채널 이탈 전송에 의해 송신 및 의지에 대해 채널 종료를 나타내고있다. &lt;a href=&quot;#on_exit_message/3&quot;&gt; &lt;code&gt;on_exit_message/3&lt;/code&gt; &lt;/a&gt; 건설의 기능을 보조 &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; 메시지를.</target>
        </trans-unit>
        <trans-unit id="6e450e02e99e9729245c2971a0f234ed37f3b636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; is the leave message for the transport to relay to the client.</source>
          <target state="translated">&lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; 전송이 클라이언트에 중계하기위한 휴가 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="bd539ef4a22e6b8ce30fc264d95352ee8a15cefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &quot;nulls first&quot; or &quot;nulls last&quot; is specific to each database implementation.</source>
          <target state="translated">&lt;code&gt;*_nulls_first&lt;/code&gt; 와 &lt;code&gt;*_nulls_last&lt;/code&gt; 의 변형은 모든 데이터베이스에서 지원되지 않습니다. 모든 데이터베이스는 기본적으로 오름차순으로 설정되지만 &quot;널 먼저&quot;또는 &quot;마지막 널&quot;의 선택은 각 데이터베이스 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6d85a8224c78cbfc81cbb854cdafc632fe561a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &amp;ldquo;nulls first&amp;rdquo; or &amp;ldquo;nulls last&amp;rdquo; is specific to each database implementation.</source>
          <target state="translated">&lt;code&gt;*_nulls_first&lt;/code&gt; 와 &lt;code&gt;*_nulls_last&lt;/code&gt; 의 변형은 모든 데이터베이스에서 지원되지 않습니다. 모든 데이터베이스의 기본값은 오름차순이지만 &quot;nulls first&quot;또는 &quot;nulls last&quot;는 각 데이터베이스 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5adb9f7effcd9a92a5c3394cf706464a50f8e854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--no-halt&lt;/code&gt; flag is automatically added.</source>
          <target state="translated">&lt;code&gt;--no-halt&lt;/code&gt; 플래그가 자동적으로 부가된다.</target>
        </trans-unit>
        <trans-unit id="23ed4ea9af36661b5bef1c1c6ac364a14dd0fd25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--step&lt;/code&gt; option will behave the same way.</source>
          <target state="translated">&lt;code&gt;--step&lt;/code&gt; 옵션은 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4d285d5d2d694c280d2af59d2b72a39d127833e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--to&lt;/code&gt; option will run all migrations up to and including given version.</source>
          <target state="translated">&lt;code&gt;--to&lt;/code&gt; 의 옵션은 모든 마이그레이션을 실행하고 버전을 제공 포함.</target>
        </trans-unit>
        <trans-unit id="6ea39d3cb35a084383c1603b0beb3c4727483b5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.eex&lt;/code&gt; extension maps to a template engine which tells Phoenix how to compile the code in the file into Elixir source code. After it is compiled, the template can be rendered as:</source>
          <target state="translated">&lt;code&gt;.eex&lt;/code&gt; 확장 비약 소스 코드에 파일의 코드를 컴파일하는 방법 피닉스 알려주는 템플릿 엔진에 매핑됩니다. 컴파일 된 후 템플릿은 다음과 같이 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2663c4b667ff4ea7906e8eff89a8ab26b4176847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.leex&lt;/code&gt; (Live EEx) template engine that tracks changes.</source>
          <target state="translated">변경 사항을 추적 하는 &lt;code&gt;.leex&lt;/code&gt; (Live EEx) 템플릿 엔진.</target>
        </trans-unit>
        <trans-unit id="8d2cbe3b530a3545de3248339706a75f4da234de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:aspect&lt;/code&gt; key of the struct specifies what field is still unfetched.</source>
          <target state="translated">구조체 의 &lt;code&gt;:aspect&lt;/code&gt; 키는 아직 언 페치 된 필드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ef67b3c2738d0f830da956da57f8a9d7ab9878ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won&amp;rsquo;t inoke the action.</source>
          <target state="translated">&lt;code&gt;:authenticate&lt;/code&gt; 플러그는 행동하기 전에 호출됩니다. 플러그가 &lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt; (기본적으로 컨트롤러로 가져옴)을 호출 하면 파이프 라인이 중지되고 작업이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a2077bbe0dc1df2c551ae2d5305040e0b043053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won't invoke the action.</source>
          <target state="translated">&lt;code&gt;:authenticate&lt;/code&gt; 플러그는 행동하기 전에 호출됩니다. 플러그가 &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt; (기본적으로 컨트롤러로 가져옴)을 호출하면 파이프 라인을 중지하고 작업을 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18fe4cf95d7fab8a497960c08951af855a55d8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; and &lt;code&gt;:api&lt;/code&gt; Pipelines</source>
          <target state="translated">&lt;code&gt;:browser&lt;/code&gt; 와 &lt;code&gt;:api&lt;/code&gt; 파이프 라인</target>
        </trans-unit>
        <trans-unit id="c70cf91a624862bdabdacfdc0d7521b33d8e86b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; pipeline has five plugs: &lt;code&gt;plug :accepts, [&quot;html&quot;]&lt;/code&gt; which defines the request format or formats which will be accepted, &lt;code&gt;:fetch_session&lt;/code&gt;, which, naturally, fetches the session data and makes it available in the connection, &lt;code&gt;:fetch_flash&lt;/code&gt; which retrieves any flash messages which may have been set, as well as &lt;code&gt;:protect_from_forgery&lt;/code&gt; and &lt;code&gt;:put_secure_browser_headers&lt;/code&gt;, which protects form posts from cross site forgery.</source>
          <target state="translated">&lt;code&gt;:browser&lt;/code&gt; : 파이프 라인은 다섯 플러그가 &lt;code&gt;plug :accepts, [&quot;html&quot;]&lt;/code&gt; 요청 형식이나 형식 허용됩니다, 정의하는 &lt;code&gt;:fetch_session&lt;/code&gt; , 자연, 세션 데이터를 가져 와서 연결에 사용할 수 있도록, &lt;code&gt;:fetch_flash&lt;/code&gt; 를 설정되었을 수있는 모든 플래시 메시지는 물론 , 사이트 간 위조로부터 양식 게시물을 보호하는 &lt;code&gt;:protect_from_forgery&lt;/code&gt; 및 &lt;code&gt;:put_secure_browser_headers&lt;/code&gt; 를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="731f4c8f6efafb89aa6c584007065c777c291143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project&amp;rsquo;s root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:cd&lt;/code&gt; 옵션은 감시자가 실행되는 폴더를 대체 감시자 사용할 수 있습니다. 기본적으로 이것은 프로젝트의 루트입니다 : &lt;code&gt;File.cwd!()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ae21bdba03584c806666010e52a2cb28db8be56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project's root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:cd&lt;/code&gt; 옵션은 감시자가 실행되는 폴더를 대체 감시자 사용할 수 있습니다. 기본적으로 이것은 프로젝트의 루트입니다. &lt;code&gt;File.cwd!()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7bc6b309b1a0d5dcb1c973131cf2999c439c9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cipher_suite&lt;/code&gt; option provides &lt;code&gt;:strong&lt;/code&gt; and &lt;code&gt;:compatible&lt;/code&gt; options for setting up better cipher and version defaults according to the OWASP recommendations. See the &amp;ldquo;Cipher Suites&amp;rdquo; section below</source>
          <target state="translated">&lt;code&gt;:cipher_suite&lt;/code&gt; 옵션을 제공합니다 &lt;code&gt;:strong&lt;/code&gt; 과 &lt;code&gt;:compatible&lt;/code&gt; OWASP의 권장 사항에 따라 더 나은 암호화 및 버전 기본값을 설정하는 옵션. 아래의 &quot;Cipher Suites&quot;섹션을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="1e4e2c269f3978f76ff199356c975a07324ab155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:compatible&lt;/code&gt; profile additionally enables AES-CBC ciphers, as well as TLS versions 1.1 and 1.0. Use this configuration to allow connections from older clients, such as older PC or mobile operating systems. Note that RSA key exchange is not enabled by this configuration, due to known weaknesses, so to support clients that do not support ECDHE or DHE it is necessary specify the ciphers explicitly (see &lt;a href=&quot;#manual-configuration&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;:compatible&lt;/code&gt; 프로필 별도로 AES-CBC 암호뿐만 아니라 TLS 버전 1.1 및 1.0을 가능하게한다. 이 구성을 사용하여 이전 PC 또는 모바일 운영 체제와 같은 이전 클라이언트의 연결을 허용합니다. 알려진 약점으로 인해 RSA 키 교환은이 구성에서 활성화되지 않습니다. 따라서 ECDHE 또는 DHE를 지원하지 않는 클라이언트를 지원하려면 암호화를 명시 적으로 지정해야합니다 ( &lt;a href=&quot;#manual-configuration&quot;&gt;아래 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="918f4e83de0e618dc7aa4875d78f6492629319c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:filename&lt;/code&gt; fields in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; struct are client-controlled. These values should be validated, via file content inspection or similar, before being trusted.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt; 구조체 의 &lt;code&gt;:content_type&lt;/code&gt; 및 &lt;code&gt;:filename&lt;/code&gt; 필드 는 클라이언트가 제어합니다. 이러한 값은 신뢰되기 전에 파일 내용 검사 등을 통해 유효성을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fb2b2f7e9b4811efb97cc3c2e5e5c07ea928f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:context&lt;/code&gt; 필드는 일부 데이터베이스는 데이터의 적절한 업데이트에 필요한 추가 상태를 나타냅니다. &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; 및 &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt; 의 기본 제공 어댑터에서는 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ea6213d9c5c2d60d6a2f351db0efbb41962d6d16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:context&lt;/code&gt; 필드는 일부 데이터베이스는 데이터의 적절한 업데이트에 필요한 추가 상태를 나타냅니다. &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; 및 &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt; 의 내장 어댑터에서는 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="16a1d1418e35d766234890bac5372c3fa8aab917" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data by simply not sending any data for a given field. If you need deletion, it is often preferred to manually mark the changeset for deletion if a &lt;code&gt;delete&lt;/code&gt; field is set in the params, as in the example below:</source>
          <target state="translated">특히 &lt;code&gt;:delete&lt;/code&gt; 옵션은 사용자가 주어진 필드에 대한 데이터를 전송하지 않음으로써 관련 데이터를 삭제할 수 있도록주의 깊게 사용해야합니다. 삭제가 필요한 경우 아래 예와 같이 매개 변수에 &lt;code&gt;delete&lt;/code&gt; 필드가 설정되어 있으면 수동으로 변경 세트를 삭제하도록 표시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5acd2290f1eeb3bc214ec527b315e41481bcb38d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data. If you need deletion, it is often preferred to add a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</source>
          <target state="translated">&lt;code&gt;:delete&lt;/code&gt; 는 사용자가 모든 관련 데이터를 삭제할 수 있도록하는 것처럼 특히 옵션은 신중하게 사용해야합니다. 삭제가 필요한 경우 아래 예와 같이 별도의 부울 가상 필드를 변경 세트 기능에 추가하여 삭제 표시를 수동으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c252a1b7d9e6defcdc7e6e2741931b5df0cd03a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:duration&lt;/code&gt; measurements are presented in the &lt;code&gt;:native&lt;/code&gt; time unit. You can read more about it in the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:duration&lt;/code&gt; 측정은에 제시되어 &lt;code&gt;:native&lt;/code&gt; 시간 단위. &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 문서에서 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0cb6c08b188d0d4ef6ec2d55ff0640a7a5a562f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:dynamic&lt;/code&gt; field contains a function that takes a boolean argument (see &quot;Tracking changes&quot; below), and returns a list of dynamic content. Each element in the list is either one of:</source>
          <target state="translated">&lt;code&gt;:dynamic&lt;/code&gt; 필드 (아래의 &quot;추적 변경&quot;참조) 부울 인수를 취하는 함수를 포함하고 동적 콘텐츠의 목록을 반환합니다. 목록의 각 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d742e4a33ea1296a531ccca07c5ea7b18db14083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:host&lt;/code&gt; option requires a string or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. Similar to &lt;code&gt;:port&lt;/code&gt;, when given a tuple like &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt;, the host will be referenced from &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; at runtime.</source>
          <target state="translated">&lt;code&gt;:host&lt;/code&gt; 옵션은 문자열이나 필요 &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; . &lt;code&gt;:port&lt;/code&gt; 와 유사하게 &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt; 과 같은 튜플이 제공되면 런타임에 &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; 는 System.get_env ( &quot;HOST&quot;) 에서 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="dd99d05cad94c87bb280dd5d83fd4ec31d3e120f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:id&lt;/code&gt; type is used when the primary key is an integer while the &lt;code&gt;:binary_id&lt;/code&gt; is used for primary keys in particular binary formats, which may be &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt; for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</source>
          <target state="translated">&lt;code&gt;:id&lt;/code&gt; 기본 키는 동안 정수 때 유형이 사용됩니다 &lt;code&gt;:binary_id&lt;/code&gt; 있을 수 있습니다 특정 바이너리 형식의 기본 키에 사용되는, &lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; 을&lt;/a&gt; PostgreSQL의와 MySQL, 또는 종종 NoSQL에 의해 부과 된 일부 특정 OBJECTID 또는 recordID와 같은 데이터베이스에이 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="03335948c65fcf829d6e89720eb38d3cb4ea9a0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:layout&lt;/code&gt; option on &lt;code&gt;use&lt;/code&gt; does not apply to LiveViews rendered within other LiveViews. If you want to render child live views or opt-in to a layout, use &lt;code&gt;:layout&lt;/code&gt; as an option in mount:</source>
          <target state="translated">&lt;code&gt;:layout&lt;/code&gt; 에서 옵션을 &lt;code&gt;use&lt;/code&gt; 다른 LiveViews 내에서 렌더링 LiveViews 적용되지 않습니다. 자식 라이브 뷰를 렌더링하거나 &lt;code&gt;:layout&lt;/code&gt; 을 선택하려면 mount의 옵션으로 : layout 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d0a17946500299e7ee12b6af3689a1c4c43f8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:logo&lt;/code&gt; is preferred to be a base64-encoded data URI so not to make any external requests, though external URLs (eg, &lt;code&gt;https://...&lt;/code&gt;) are supported.</source>
          <target state="translated">&lt;code&gt;:logo&lt;/code&gt; , URI가 너무 외부 요청을하지 base64로 인코딩 된 데이터로하는 것이 바람직하다 외부 URL하지만 (예 : &lt;code&gt;https://...&lt;/code&gt; )이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c3992bb8a6efd8a4bd3e7e1767377cc30d96b760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:measurements&lt;/code&gt; map will include the following, all given in the &lt;code&gt;:native&lt;/code&gt; time unit:</source>
          <target state="translated">&lt;code&gt;:measurements&lt;/code&gt; 맵은 다음, 모든 주어진 포함됩니다 &lt;code&gt;:native&lt;/code&gt; 시간 단위 :</target>
        </trans-unit>
        <trans-unit id="25110dc298c23b6bcca6b66d8becb6c3ab0252e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; is required as part of &lt;code&gt;options&lt;/code&gt;. The remaining options are described below.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 의 일부로서 요구되는 &lt;code&gt;options&lt;/code&gt; . 나머지 옵션은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a144d9bf2ce178155262a9bed21600765bd913d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; parameter will also be available in the function body as &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; and &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 파라미터는 또한 함수 본문에 사용할 수 &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; 과 &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6a9f8fae8b3f03bb8da33b0dd63ade9e7c2388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can be provided instead. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="translated">&lt;code&gt;:namespace&lt;/code&gt; 와 &lt;code&gt;:path&lt;/code&gt; 옵션을 계산 템플릿 검색 경로에 사용됩니다. 예를 들어 &lt;code&gt;MyApp.UserView&lt;/code&gt; 에 있고 네임 스페이스가 &lt;code&gt;MyApp&lt;/code&gt; 인 경우 템플릿은 &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt; 에 있어야 합니다. 반면에보기가 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; 인 경우 경로는 &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; 등이됩니다. 명시적인 루트 경로 위치의 경우 &lt;code&gt;:path&lt;/code&gt; 옵션을 대신 제공 할 수 있습니다. &lt;code&gt;:root&lt;/code&gt; 및 &lt;code&gt;:path&lt;/code&gt; 최종 조회 경로를 형성하기 위해 결합됩니다. &lt;code&gt;:root&lt;/code&gt; 경로를 템플릿 조회 경로로 직접 사용하기 위해 빈 문자열을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a1f032809b2a80ee05ed26deb3f2fce84671c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can instead be provided. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="translated">&lt;code&gt;:namespace&lt;/code&gt; 와 &lt;code&gt;:path&lt;/code&gt; 옵션을 계산 템플릿 검색 경로에 사용됩니다. 예를 들어, &lt;code&gt;MyApp.UserView&lt;/code&gt; 에 있고 네임 스페이스가 &lt;code&gt;MyApp&lt;/code&gt; 이면 템플릿은 &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt; 에 있어야 합니다. 반면,보기가 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; 인 경우 경로는 &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; 등입니다. 명시적인 루트 경로 위치의 경우 &lt;code&gt;:path&lt;/code&gt; 옵션을 대신 제공 할 수 있습니다. &lt;code&gt;:root&lt;/code&gt; 및 &lt;code&gt;:path&lt;/code&gt; 최종 조회 경로를 형성하기 위해 결합됩니다. &lt;code&gt;:root&lt;/code&gt; 경로를 템플릿 조회 경로로 직접 사용하기 위해 빈 문자열이 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="895c2ddd40cf8e3567de42e9bf12420974e19653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:on_replace&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:on_replace&lt;/code&gt; 의 옵션</target>
        </trans-unit>
        <trans-unit id="36d82b1b3e9c0c28b3952588185c19ae211245b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer or string. The &lt;code&gt;:host&lt;/code&gt; option requires a string. The &lt;code&gt;:scheme&lt;/code&gt; option accepts &lt;code&gt;&quot;http&quot;&lt;/code&gt; and &lt;code&gt;&quot;https&quot;&lt;/code&gt; values. Default value is inferred from top level &lt;code&gt;:http&lt;/code&gt; or &lt;code&gt;:https&lt;/code&gt; option. It is useful when hosting Phoenix behind a load balancer or reverse proxy and terminating SSL there. The &lt;code&gt;:path&lt;/code&gt; option can be used to override root path. Useful when hosting Phoenix behind a reverse proxy with URL rewrite rules</source>
          <target state="translated">&lt;code&gt;:port&lt;/code&gt; 옵션은 정수 나 문자열 중 하나가 필요합니다. &lt;code&gt;:host&lt;/code&gt; 옵션은 문자열이 필요합니다. &lt;code&gt;:scheme&lt;/code&gt; 옵션을 받아 &lt;code&gt;&quot;http&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;https&quot;&lt;/code&gt; 값을. 기본값은 최상위 수준 &lt;code&gt;:http&lt;/code&gt; 또는 &lt;code&gt;:https&lt;/code&gt; 옵션 에서 유추됩니다 . 로드 밸런서 또는 역방향 프록시 뒤에서 Phoenix를 호스팅하고 거기서 SSL을 종료 할 때 유용합니다. &lt;code&gt;:path&lt;/code&gt; 옵션은 루트 경로를 대체 할 수 있습니다. URL 재 작성 규칙을 사용하여 역방향 프록시 뒤에서 Phoenix를 호스팅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6168b39090f584c85cff0cc128125156fba6b515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer, string, or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. When given a tuple like &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt;, the port will be referenced from &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; at runtime as a workaround for releases where environment specific information is loaded only at compile-time.</source>
          <target state="translated">&lt;code&gt;:port&lt;/code&gt; 옵션은 정수, 문자열, 또는 중 하나가 필요합니다 &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; . &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt; 와 같은 튜플이 제공되면 환경 특정 정보가 컴파일 타임에만로드되는 릴리스에 대한 임시 해결책으로 런타임에 &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; 에서 포트가 참조 됩니다.</target>
        </trans-unit>
        <trans-unit id="92d07421660bd7c638d8258897864e4a9cf3e6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:prefix&lt;/code&gt; option given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt; has the highest precedence</source>
          <target state="translated">&lt;code&gt;:prefix&lt;/code&gt; 에 주어진 옵션 &lt;code&gt;from&lt;/code&gt; / &lt;code&gt;join&lt;/code&gt; 가장 높은 우선 순위를 가지고</target>
        </trans-unit>
        <trans-unit id="54e1957e79c6b007c7f23224e0a1670cbbc75677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:pubsub_server&lt;/code&gt; must point to an existing pubsub server running in your application, which is included by default as &lt;code&gt;MyApp.PubSub&lt;/code&gt; for new applications.</source>
          <target state="translated">&lt;code&gt;:pubsub_server&lt;/code&gt; 은 기본적으로 포함되어있는 응용 프로그램에서 실행 기존 pubsub 서버를 가리켜 야합니다 &lt;code&gt;MyApp.PubSub&lt;/code&gt; 새로운 애플리케이션.</target>
        </trans-unit>
        <trans-unit id="5cda43ef4ff3376cfc2c7af75979f3ba0d7ed620" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reloadable_apps&lt;/code&gt; defaults to &lt;code&gt;nil&lt;/code&gt;. In such case default behaviour is to reload current project if it consists of single app, or all applications within umbrella project. You can set &lt;code&gt;:reloadable_apps&lt;/code&gt; to subset of default applications to reload only some of them, empty list - to effectively disable code reloader, or include external applications from library dependencies.</source>
          <target state="translated">는 &lt;code&gt;:reloadable_apps&lt;/code&gt; 에 기본값을 &lt;code&gt;nil&lt;/code&gt; . 이 경우 기본 동작은 단일 앱으로 구성된 경우 현재 프로젝트를 다시로드하거나 우산 프로젝트 내의 모든 애플리케이션을 다시로드하는 것입니다. 당신은 설정할 수 있습니다 &lt;code&gt;:reloadable_apps&lt;/code&gt; 단지 그들 중 일부 빈 목록을 다시로드 기본 응용 프로그램의 서브 세트 - 효과적으로 해제 코드 장전에, 또는 라이브러리 의존성에서 외부 응용 프로그램을 포함한다.</target>
        </trans-unit>
        <trans-unit id="baa4db1aa422d9779d3b8729775b268f6c7f02de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:remote_ip&lt;/code&gt; field in the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct by default contains the network peer IP address. Terminating TLS in a separate process or network element typically masks the actual client IP address from the Elixir application. If proxying is done at the HTTP layer, the original client IP address is often inserted into an HTTP header, e.g. 'X-Forwarded-For'. There are Plug packages available to extract the client IP from such a header and update the &lt;code&gt;:remote_ip&lt;/code&gt; field.</source>
          <target state="translated">&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체 의 &lt;code&gt;:remote_ip&lt;/code&gt; 필드는 기본적으로 네트워크 피어 IP 주소를 포함합니다. 별도의 프로세스 또는 네트워크 요소에서 TLS를 종료하면 일반적으로 Elixir 애플리케이션의 실제 클라이언트 IP 주소가 마스킹됩니다. 프록시가 HTTP 계층에서 수행되는 경우 원래 클라이언트 IP 주소가 종종 HTTP 헤더에 삽입됩니다 (예 : 'X-Forwarded-For'). 이러한 헤더에서 클라이언트 IP를 추출하고 &lt;code&gt;:remote_ip&lt;/code&gt; 필드를 업데이트하는 데 사용할 수있는 플러그 패키지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed05e3737398b3c2beccb1cfaf10e740d96858b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:root&lt;/code&gt; option is required while the &lt;code&gt;:namespace&lt;/code&gt; defaults to the first nesting in the module name. For instance, both &lt;code&gt;MyApp.UserView&lt;/code&gt; and &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; have namespace &lt;code&gt;MyApp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:root&lt;/code&gt; 옵션은 동안 필요한 &lt;code&gt;:namespace&lt;/code&gt; 모듈 이름의 첫 번째 중첩에 기본값을. 예를 들어 &lt;code&gt;MyApp.UserView&lt;/code&gt; 및 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; 모두 네임 스페이스 &lt;code&gt;MyApp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a3296e1c3da0ddff618bfd191c05b175ff0cb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:schema&lt;/code&gt; field refers the module name for the schema this metadata belongs to.</source>
          <target state="translated">&lt;code&gt;:schema&lt;/code&gt; 필드는이 메타 데이터에 속하는 스키마 모듈 이름을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e2763632c3bc8d8b6f69e916c553e100096271d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:selected&lt;/code&gt; option will mark the given IDs as selected unless the form is being resubmitted. When resubmitted, it uses the form params as values.</source>
          <target state="translated">&lt;code&gt;:selected&lt;/code&gt; 양식이 제출되지 않는 한 옵션이 선택은 주어진 ID를 표시합니다. 다시 제출하면 양식 params를 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0cea6902bf81cf806e2e2ff5a1334ab75f6b0054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:source&lt;/code&gt; tracks the (table or collection) where the struct is or should be persisted to.</source>
          <target state="translated">&lt;code&gt;:source&lt;/code&gt; 구조체가 이상으로 유지되어야한다 (표 또는 수집)을 추적한다.</target>
        </trans-unit>
        <trans-unit id="c67eef75ef4d15947c1d4d035bc00669b3f024ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static&lt;/code&gt; field is a list of literal strings. This allows the Elixir compiler to optimize this list and avoid allocating its strings on every render.</source>
          <target state="translated">&lt;code&gt;:static&lt;/code&gt; 필드는 리터럴 문자열의 목록입니다. 이를 통해 Elixir 컴파일러는이 목록을 최적화하고 렌더링 할 때마다 문자열을 할당하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ec232b6cfcdbc23d88179e41f0fb0e88f686fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strong&lt;/code&gt; profile enables AES-GCM ciphers with ECDHE or DHE key exchange, and TLS version 1.2 only. It is intended for typical installations with support for browsers and other modern clients.</source>
          <target state="translated">&lt;code&gt;:strong&lt;/code&gt; 프로필 ECDHE 또는 DHE 키 교환, 및 TLS 버전 1.2 만와 AES-GCM 암호 할 수있다. 브라우저 및 기타 최신 클라이언트를 지원하는 일반 설치를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="81e4f3969fca2a0c0bce3d4dfbb896188d5e6e36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option expects a keyword list where the key is an atom representing the field and the value is either:</source>
          <target state="translated">&lt;code&gt;:where&lt;/code&gt; 옵션은 키 필드와 값을 나타내는 원자 키워드 목록을 기대 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="3d6613c6ae5cafc810769cb60c6e62f072ba58bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option may receive a dynamic query, a keyword list or a MFA (a tuple with a module, function and args to invoke). The MFA is especially useful to avoid duplication in those definitions:</source>
          <target state="translated">&lt;code&gt;:where&lt;/code&gt; 옵션은 동적 쿼리, 키워드 목록 또는 MFA (호출 모듈, 기능 및 인수와 튜플)를받을 수 있습니다. MFA는 이러한 정의에서 중복을 피하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cdf5ea7cc064d3fd02c24e10f92c4d06b0296467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@endpoint&lt;/code&gt; module attribute contains the endpoint under testing, most commonly your application endpoint itself. If you are using the MyApp.ConnCase generated by Phoenix, it is automatically set for you.</source>
          <target state="translated">&lt;code&gt;@endpoint&lt;/code&gt; 모듈 속성 테스트에서 엔드 포인트를 포함, 가장 일반적으로 응용 프로그램 자체 엔드 포인트. Phoenix에서 생성 한 MyApp.ConnCase를 사용하는 경우 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb7111fae5bbf19a11fce2dbdf8ba880cacae4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@primary_key&lt;/code&gt; attribute will tell ecto which type to use for the id.</source>
          <target state="translated">&lt;code&gt;@primary_key&lt;/code&gt; 의 ID를 사용하는 유형 속성은 체외을 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="010ab761c017e85e79712afcc13c2e028e60df3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@shortdoc&lt;/code&gt; module attribute holds a string which will describe our task when users invoke &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@shortdoc&lt;/code&gt; 의 모듈 속성은 사용자가 호출 할 때 우리의 작업을 설명하는 문자열을 보유하고 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e515ce695757264b1c2dae6b68e6bbfbc7f198c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method can be overridden only by these HTTP methods:</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 의 메소드는이 HTTP 방법으로 대체 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ef584d71c526b4b7d03dc94f80f6e8f1d6008b5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PageController&lt;/code&gt; gives us the &lt;code&gt;index&lt;/code&gt; action to display the Phoenix welcome page associated with the default route Phoenix defines in the router.</source>
          <target state="translated">&lt;code&gt;PageController&lt;/code&gt; 이 우리에게주는 &lt;code&gt;index&lt;/code&gt; 피닉스 라우터에서 정의하는 기본 경로와 관련된 피닉스 환영 페이지를 표시하기위한 조치를.</target>
        </trans-unit>
        <trans-unit id="65f0d0f4bd596df0232f105e5e46a46047747cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SignUp&lt;/code&gt; schema can be cast and validated with the help of the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module, and afterwards, you can copy its data to the &lt;code&gt;Profile&lt;/code&gt; and &lt;code&gt;Account&lt;/code&gt; structs that will be persisted to the database with the help of &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SignUp&lt;/code&gt; 스키마의 도움으로 출연진과 유효성을 검사 할 수 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; 의&lt;/a&gt; 모듈 및 그 후, 당신은 그것의 데이터를 복사 할 수 있습니다 &lt;code&gt;Profile&lt;/code&gt; 및 &lt;code&gt;Account&lt;/code&gt; 의 도움으로 데이터베이스에 지속됩니다 구조체 &lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0027e32d65973e3996206f15f8d2bc1ec48ab7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tracker&lt;/code&gt; API is used as a facade for a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s. The responsibility of which calls go to which &lt;code&gt;Shard&lt;/code&gt; is determined based on the topic, on which a given function is called.</source>
          <target state="translated">&lt;code&gt;Tracker&lt;/code&gt; API는 풀의 외관으로 사용됩니다 &lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; &lt;/a&gt; 의. 어떤 호출이 어떤 &lt;code&gt;Shard&lt;/code&gt; 로 전달되는지에 대한 책임은 주어진 기능이 호출되는 주제에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5479c3d20fe1168228ba562f220f909f384e32e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UserRegistration&lt;/code&gt; setup is likely simpler to implement than the dynamic author system we built &amp;ndash; we decided to take the harder path exactly because those are decisions developers take on their applications every day.</source>
          <target state="translated">&lt;code&gt;UserRegistration&lt;/code&gt; 의 설정은 우리가 내장 된 동적 저자의 시스템보다 구현 가능성이 간단하다 - 우리가 그 개발자가 매일 자신의 애플리케이션에 걸릴 결정 정확히 때문에 더 열심히 경로를 취하기로 결정.</target>
        </trans-unit>
        <trans-unit id="65dac19423140ef75ddacc313c1b338418cdd245" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[:telemetry]&lt;/code&gt; library allows you to emit events at various stages of an application's lifecycle. You can then respond to these events by, among other things, aggregating them as metrics and sending the metrics data to a reporting destination.</source>
          <target state="translated">&lt;code&gt;[:telemetry]&lt;/code&gt; 라이브러리는 응용 프로그램의 수명주기의 여러 단계에서 이벤트를 방출 할 수 있습니다. 그런 다음 이러한 이벤트를 메트릭으로 집계하고보고 대상으로 메트릭 데이터를 전송하여 이러한 이벤트에 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0004743ff2da907b7bfb6253848e44f110fc051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_url&lt;/code&gt; functions will get the host, port, proxy port, and SSL information needed to construct the full URL from the configuration parameters set for each environment. We'll talk about configuration in more detail in its own guide. For now, you can take a look at &lt;code&gt;config/dev.exs&lt;/code&gt; file in your own project to see those values.</source>
          <target state="translated">&lt;code&gt;_url&lt;/code&gt; 의 기능은 각 환경 설정 구성 매개 변수의 전체 URL을 구성하는 데 필요한 호스트, 포트, 프록시 포트 및 SSL 정보를 얻을 것이다. 자체 가이드에서 구성에 대해 자세히 설명합니다. 지금 은 자신의 프로젝트 에서 &lt;code&gt;config/dev.exs&lt;/code&gt; 파일을 살펴보고 해당 값을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9380732d83d99aa3ef7e1ee94986487b7d7501fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;adapter_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">&lt;code&gt;adapter_meta&lt;/code&gt; 의 필드에있는 일부 필드가 포함 된지도입니다 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 의&lt;/a&gt; 구조체.</target>
        </trans-unit>
        <trans-unit id="1f72cda2deb8565937044253265942493bf6aa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;belongs_to&lt;/code&gt; association on &lt;code&gt;MyApp.Comment&lt;/code&gt; will also define a &lt;code&gt;:post_id&lt;/code&gt; field with &lt;code&gt;:binary_id&lt;/code&gt; type that references the &lt;code&gt;:id&lt;/code&gt; field of the &lt;code&gt;MyApp.Post&lt;/code&gt; schema.</source>
          <target state="translated">&lt;code&gt;MyApp.Comment&lt;/code&gt; 의 &lt;code&gt;belongs_to&lt;/code&gt; 연관 은 &lt;code&gt;MyApp.Post&lt;/code&gt; 스키마 의 &lt;code&gt;:id&lt;/code&gt; 필드 를 참조하는 : &lt;code&gt;:binary_id&lt;/code&gt; 유형 의 &lt;code&gt;:post_id&lt;/code&gt; 필드 도 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="87e3861a73f975bf0651f08b600e6e3ad95f45d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacertfile&lt;/code&gt; option is not needed when using a self-signed certificate, or when the file pointed to by &lt;code&gt;certfile&lt;/code&gt; contains both the server certificate and all necessary CA chain certificates:</source>
          <target state="translated">&lt;code&gt;cacertfile&lt;/code&gt; 의 자체 서명 된 인증서를 사용하거나 파일을 가리키는 경우 때 옵션이 필요하지 않습니다 &lt;code&gt;certfile&lt;/code&gt; 서버 인증서 및 필요한 모든 CA 체인 인증서가 모두 포함 :</target>
        </trans-unit>
        <trans-unit id="778cb135fc988ae8195d411110c29d421206d37f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="translated">&lt;code&gt;call/2&lt;/code&gt; 이 함수 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 은&lt;/a&gt; 은 USING 나열된 모든 플러그 실행 내부적으로 사용 제공 &lt;code&gt;plug&lt;/code&gt; 때문에 무시 매크로 &lt;code&gt;call/2&lt;/code&gt; 사용 함축 일반적 기능 &lt;code&gt;super&lt;/code&gt; 여전히 플러그 체인을 호출하기 위해 :</target>
        </trans-unit>
        <trans-unit id="6752d9d305fe4dabd6e9f7e8abc5275de174456b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="translated">&lt;code&gt;call/2&lt;/code&gt; 이 함수 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 은&lt;/a&gt; 은 USING 나열된 모든 플러그 실행 내부적으로 사용 제공 &lt;code&gt;plug&lt;/code&gt; 때문에 무시 매크로 &lt;code&gt;call/2&lt;/code&gt; 사용 함축 일반적 기능 &lt;code&gt;super&lt;/code&gt; 여전히 플러그 체인을 호출하기 위해 :</target>
        </trans-unit>
        <trans-unit id="59369e81ae4c82531a9066b2b16f4703c7464cfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changeset/2&lt;/code&gt; function first invokes &lt;a href=&quot;ecto.changeset#cast/4&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt;&lt;/a&gt; with the struct, the parameters and a list of allowed fields; this returns a changeset. The parameters is a map with binary keys and values that will be cast based on the type defined on the schema.</source>
          <target state="translated">&lt;code&gt;changeset/2&lt;/code&gt; 기능 제 원용 &lt;a href=&quot;ecto.changeset#cast/4&quot;&gt; &lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt; &lt;/a&gt; 구조체의 파라미터 수 필드의 목록; 변경 세트를 돌려줍니다. 매개 변수는 스키마에 정의 된 유형을 기반으로 캐스트 될 2 진 키 및 값이있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="fcd29f0f3ca38c03e6a05f563bf7684e923be86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat (the &lt;code&gt;*&lt;/code&gt; character) argument can be provided as the last character to indicate a &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &lt;code&gt;&quot;topic:*&quot;&lt;/code&gt; pattern to allow more versatile topic scoping.</source>
          <target state="translated">&lt;code&gt;channel&lt;/code&gt; 매크로는 두 가지 종류의 주제 패턴을 받아들입니다. splat ( &lt;code&gt;*&lt;/code&gt; 문자) 인수는 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 일치 를 나타내는 마지막 문자로 제공 될 수 있습니다 . 일반 문자열이 제공되면 해당 주제 만 채널 핸들러와 일치합니다. 대부분의 사용 사례는 &lt;code&gt;&quot;topic:*&quot;&lt;/code&gt; 패턴을 사용하여보다 다양한 주제 범위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2294206fb3a150cd9c224614317f9aee05e6f3e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat argument can be provided as the last character to indicate a &amp;ldquo;topic:subtopic&amp;rdquo; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &amp;ldquo;topic:*&amp;rdquo; pattern to allow more versatile topic scoping.</source>
          <target state="translated">&lt;code&gt;channel&lt;/code&gt; 매크로는 두 가지 종류의 주제 패턴을 받아들입니다. &quot;topic : subtopic&quot;일치를 나타내는 마지막 문자로 splat 인수를 제공 할 수 있습니다. 일반 문자열이 제공되면 해당 주제 만 채널 핸들러와 일치합니다. 대부분의 유스 케이스는 &quot;topic : *&quot;패턴을 사용하여보다 다양한 주제 범위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd75bfb56e80fb59c39a66cbca5dfc544043958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do/end&lt;/code&gt; will be available as an anonymous function in an assign named &lt;code&gt;@inner_content&lt;/code&gt;. The anonymous function must be invoked passing a new set of assigns that will be merged into the user assigns. For example, the grid component above could be implemented as:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 할당라는 이름의 익명 함수로 사용할 수 있습니다 &lt;code&gt;@inner_content&lt;/code&gt; . 익명 함수는 사용자 할당에 병합 될 새로운 할당 집합을 전달하여 호출되어야합니다. 예를 들어 위의 그리드 구성 요소는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0566567c74373795b6261b3892abb0503ed0e625" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic&lt;/code&gt; macro can be interpolated at the root of a &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;'s &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 매크로는 루트에 보간 될 수있는 , &lt;code&gt;having&lt;/code&gt; 하거나는 &lt;code&gt;join&lt;/code&gt; 의 &lt;code&gt;on&lt;/code&gt; . &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="077b06b43fe5cab3947b5c73d7e014aabfed4b80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecto.rollback&lt;/code&gt; task will reverse the last migration we have run, undoing the schema changes. &lt;code&gt;ecto.migrate&lt;/code&gt; and &lt;code&gt;ecto.rollback&lt;/code&gt; are mirror images of each other.</source>
          <target state="translated">&lt;code&gt;ecto.rollback&lt;/code&gt; 의 작업은 스키마 변경을 취소, 우리가 실행 한 마지막 마이그레이션을 반대합니다. &lt;code&gt;ecto.migrate&lt;/code&gt; 및 &lt;code&gt;ecto.rollback&lt;/code&gt; 은 서로의 미러 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="b47faccb75d970d09e733fcef42fb4e981d00af8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-blur&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-blur&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 로 만든 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A의 페이지에서 단일 요소로해야 포인트 &lt;code&gt;phx-blur&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-blur&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. &lt;code&gt;value&lt;/code&gt; 인수를 사용하여 추가 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5019576176da0a0182ad14b8fd3ae5734cc494eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-change&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-change&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 로 만든 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A의 페이지에서 단일 요소로해야 포인트 &lt;code&gt;phx-change&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-change&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d153088b0ac1c3ab072462dcfc030a49a5bb2603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-click&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-click&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 만들어집니다 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A를 페이지에 하나의 요소로해야 포인트 &lt;code&gt;phx-click&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-click&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. &lt;code&gt;value&lt;/code&gt; 인수를 사용하여 추가 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cc050be15922cc83544181133c115aeaf56c9ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-focus&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-focus&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 만들어집니다 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A를 페이지에 하나의 요소로해야 포인트 &lt;code&gt;phx-focus&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-focus&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. &lt;code&gt;value&lt;/code&gt; 인수를 사용하여 추가 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a8552f5bca94ee3cd7fe7fd6d2f0771c726944d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keydown&lt;/code&gt; or &lt;code&gt;phx-window-keydown&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keydown&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 로 만든 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A의 페이지에서 단일 요소로해야 포인트 &lt;code&gt;phx-keydown&lt;/code&gt; 또는 &lt;code&gt;phx-window-keydown&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-keydown&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. &lt;code&gt;value&lt;/code&gt; 인수를 사용하여 추가 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="346fe7c5d882669468106690d1f552e7e73c91d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keyup&lt;/code&gt; or &lt;code&gt;phx-window-keyup&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keyup&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 로 만든 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A의 페이지에서 단일 요소로해야 포인트 &lt;code&gt;phx-keyup&lt;/code&gt; 또는 &lt;code&gt;phx-window-keyup&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-keyup&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. &lt;code&gt;value&lt;/code&gt; 인수를 사용하여 추가 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a298b368b8d58666332ac5fd98b74d5ced7a849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-submit&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-submit&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values, including hidden input fields, can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 만들어집니다 &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; A를 페이지에 하나의 요소로해야 포인트 &lt;code&gt;phx-submit&lt;/code&gt; 그것의 속성. &lt;code&gt;phx-submit&lt;/code&gt; 에 설정된 이벤트 이름 은 적절한 LiveView (또는 &lt;code&gt;phx-target&lt;/code&gt; 이 적절하게 설정된 경우 구성 요소)로 전송됩니다 . 요소의 모든 &lt;code&gt;phx-value-*&lt;/code&gt; 항목은 값으로 전송됩니다. 숨겨진 입력 필드를 포함한 추가 값은 &lt;code&gt;value&lt;/code&gt; 인수 와 함께 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfbf0996b2b7c1661988ea246da6fcdfd58f43b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode!/1&lt;/code&gt; function must return a tuple in the format &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;encode!/1&lt;/code&gt; 기능은 형식으로 튜플을 반환해야 &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="055209e601ab76424461a3d24cfbe4383896ba1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch/2&lt;/code&gt; function above fetches all users from the database who have registered presences for the given topic. The presences information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user's information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="translated">위의 &lt;code&gt;fetch/2&lt;/code&gt; 기능은 주어진 주제에 대한 존재를 등록한 데이터베이스에서 모든 사용자를 가져옵니다. 그런 다음 프레즌스 정보는 원래 프레즌스 데이터에서 필수 &lt;code&gt;:metas&lt;/code&gt; 필드 를 유지하면서 사용자 정보의 &lt;code&gt;:user&lt;/code&gt; 키로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a64f3256798e6a70350cf3a635b234e379dcbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">&lt;code&gt;form&lt;/code&gt; 중 하나이어야 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; 방출 &lt;code&gt;form_for&lt;/code&gt; 또는 원자이다.</target>
        </trans-unit>
        <trans-unit id="503560113ad63b1bbf6a1ce7a1a79895b311563a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">&lt;code&gt;form&lt;/code&gt; 중 하나이어야 &lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; 방출 &lt;code&gt;form_for&lt;/code&gt; 또는 원자이다.</target>
        </trans-unit>
        <trans-unit id="bd226e25354c107d2906f0cbea19295e4d882cd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json/2&lt;/code&gt; function is obviously useful for writing APIs, and the other two may come in handy, but most of the times we use Phoenix views to build our responses. For this, Phoenix provides the &lt;code&gt;render/3&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;json/2&lt;/code&gt; 기능은 API를 쓰는 분명히 유용하며, 다른 두 유용하게 사용할 수 있지만, 대부분의 시간은 우리는 우리의 응답을 구축 피닉스 뷰를 사용합니다. 이를 위해 Phoenix는 &lt;code&gt;render/3&lt;/code&gt; 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a3d0728771ec4d2ea3c901f60ad19db7fa2a8d0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello/application.ex&lt;/code&gt; file defines an Elixir application named &lt;code&gt;Hello.Application&lt;/code&gt;. That's because at the end of the day Phoenix applications are simply Elixir applications. The &lt;code&gt;Hello.Application&lt;/code&gt; module defines which services are part of our application:</source>
          <target state="translated">&lt;code&gt;lib/hello/application.ex&lt;/code&gt; 파일라는 이름의 비약 응용 프로그램 정의 &lt;code&gt;Hello.Application&lt;/code&gt; 을 . 결국 Phoenix 애플리케이션은 단순히 Elixir 애플리케이션이기 때문입니다. &lt;code&gt;Hello.Application&lt;/code&gt; 의 서비스는 우리의 응용 프로그램의 일부 모듈을 정의 :</target>
        </trans-unit>
        <trans-unit id="4b44c23c2835aabf2b8a0d71d119e8487fdff8fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello&lt;/code&gt; directory hosts all of your business domain. Since our project does not have any business logic yet, the directory is mostly empty. You will only find two files:</source>
          <target state="translated">&lt;code&gt;lib/hello&lt;/code&gt; 디렉토리 호스트 비즈니스 도메인의 모든. 우리 프로젝트에는 아직 비즈니스 로직이 없기 때문에 디렉토리는 대부분 비어 있습니다. 두 개의 파일 만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c968f45c63fd13191f1cd53260d0ffe8f31d44b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello_web&lt;/code&gt; directory holds the web-related parts of our application. It looks like this when expanded:</source>
          <target state="translated">&lt;code&gt;lib/hello_web&lt;/code&gt; 디렉토리는 우리의 응용 프로그램의 웹 관련 부품을 보유하고 있습니다. 확장하면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2252012c87ac27460a9e7188fe0a3ff365ab835" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lv:&lt;/code&gt; event prefix supports LiveView specific features that are handled by LiveView without calling the user's &lt;code&gt;handle_event/3&lt;/code&gt; callbacks. Today, the following events are supported:</source>
          <target state="translated">&lt;code&gt;lv:&lt;/code&gt; 사용자의 호출하지 않고 라이브 뷰에 의해 처리되는 이벤트 접두사가 지원하는 라이브 뷰 특정 기능 &lt;code&gt;handle_event/3&lt;/code&gt; 콜백을. 현재 다음 이벤트가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3dd5c68b341c68e39c0234d83212f3aebd4c77c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onkeydown&lt;/code&gt;, and &lt;code&gt;onkeyup&lt;/code&gt; events are supported via the &lt;code&gt;phx-keydown&lt;/code&gt;, and &lt;code&gt;phx-keyup&lt;/code&gt; bindings. Each binding supports a &lt;code&gt;phx-key&lt;/code&gt; attribute, which triggers the event for the specific key press. If no &lt;code&gt;phx-key&lt;/code&gt; is provided, the event is triggered for any key press. When pushed, the value sent to the server will contain the &lt;code&gt;&quot;key&quot;&lt;/code&gt; that was pressed, plus any user-defined metadata. For example, pressing the Escape key looks like this:</source>
          <target state="translated">&lt;code&gt;onkeydown&lt;/code&gt; , 및 &lt;code&gt;onkeyup&lt;/code&gt; 이벤트는 통해 지원됩니다 &lt;code&gt;phx-keydown&lt;/code&gt; 및 &lt;code&gt;phx-keyup&lt;/code&gt; 바인딩. 각 바인딩은 특정 키 누름에 대한 이벤트를 트리거 하는 &lt;code&gt;phx-key&lt;/code&gt; 속성을 지원합니다 . &lt;code&gt;phx-key&lt;/code&gt; 가 제공 되지 않으면 모든 키 누름에 대해 이벤트가 트리거됩니다. 푸시되면 서버로 전송 된 값에는 누른 &lt;code&gt;&quot;key&quot;&lt;/code&gt; 와 사용자 정의 메타 데이터가 포함됩니다. 예를 들어 Esc 키를 누르면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4280e53fd7de2d333eac4e3efda660422aeb8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; contains an &lt;code&gt;opcode&lt;/code&gt; key, this will be either &lt;code&gt;:ping&lt;/code&gt; or &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 포함 &lt;code&gt;opcode&lt;/code&gt; 키를,이 중 하나가 될 것입니다 &lt;code&gt;:ping&lt;/code&gt; 나 &lt;code&gt;:pong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b7c6ea8c001315dd26a0ae19bec5c510733707" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opts&lt;/code&gt; that are received in the &lt;code&gt;init/1&lt;/code&gt; callback of the Module Plug can be passed as a 3rd argument. For example, maybe the background job lets you set the name of your application to be displayed on the page. This could be passed with:</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 에서 수신 &lt;code&gt;init/1&lt;/code&gt; 모듈 플러그의 콜백은 제 3 인수로 전달 될 수있다. 예를 들어 백그라운드 작업을 통해 페이지에 표시 할 애플리케이션 이름을 설정할 수 있습니다. 이것은 다음과 같이 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30635ea371ab0a08e396d17ab555117f5134b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; is the list of query parameters. For example, for a query such as &lt;code&gt;from Post, where: [id: ^123]&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt; will be &lt;code&gt;[123]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 쿼리 매개 변수의 목록입니다. 예를 들어 &lt;code&gt;from Post, where: [id: ^123]&lt;/code&gt; 와 같은 쿼리의 경우 [id : ^ 123] , &lt;code&gt;params&lt;/code&gt; 는 &lt;code&gt;[123]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc799acb99c7c5e0571705aabef686e2a9bc106f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params_or_body&lt;/code&gt; field must be one of:</source>
          <target state="translated">&lt;code&gt;params_or_body&lt;/code&gt; 의 필드 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="ba32a6b84a77473cde79076160c7d25a5500e027" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; can be either a string or the &lt;code&gt;path_info&lt;/code&gt; segments.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 문자열이나 될 수 있습니다 &lt;code&gt;path_info&lt;/code&gt; 세그먼트를.</target>
        </trans-unit>
        <trans-unit id="6557be94c3b172806d0d806c90f7d5a409872519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; is commonly the request path with optional query string but it may also be a complete URI. When a URI is given, the host and schema will be used as part of the request too.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 일반적으로 선택 쿼리 문자열을 요청 경로뿐만 아니라 완전한 URI 될 수있다. URI가 주어지면 호스트와 스키마도 요청의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d55c3d00bf1f0ceaa729d7da79f6e3d8341ed27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-capture-click&lt;/code&gt; event is just like &lt;code&gt;phx-click&lt;/code&gt;, but instead of the click event being dispatched to the closest &lt;code&gt;phx-click&lt;/code&gt; element as it bubbles up through the DOM, the event is dispatched as it propagates from the top of the DOM tree down to the target element. This is useful when wanting to bind click events without receiving bubbled events from child UI elements. Since capturing happens before bubbling, this can also be important for preparing or preventing behaviour that will be applied during the bubbling phase.</source>
          <target state="translated">&lt;code&gt;phx-capture-click&lt;/code&gt; 이벤트는 같다 &lt;code&gt;phx-click&lt;/code&gt; , 대신 존재가 가장 가까운에 파견 클릭 이벤트의 &lt;code&gt;phx-click&lt;/code&gt; 는 DOM을 통해 거품 같은 요소는 DOM의 상단에서 전파로 이벤트가 전달됩니다 대상 요소까지 아래로 트리. 이는 자식 UI 요소에서 버블 링 된 이벤트를받지 않고 클릭 이벤트를 바인딩하려는 경우에 유용합니다. 캡처는 버블 링 전에 발생하므로 버블 링 단계 중에 적용될 동작을 준비하거나 방지하는데도 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701ba5efe9283602358bbbeacee6d8120c0fe72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-click&lt;/code&gt; binding is used to send click events to the server. When any client event, such as a &lt;code&gt;phx-click&lt;/code&gt; click is pushed, the value sent to the server will be chosen with the following priority:</source>
          <target state="translated">&lt;code&gt;phx-click&lt;/code&gt; 서버에 클릭 이벤트를 보내는 데 사용되는 바인딩. &lt;code&gt;phx-click&lt;/code&gt; 클릭 과 같은 클라이언트 이벤트 가 푸시되면 서버로 전송되는 값이 다음 우선 순위로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="aecbede8f9d2cd80586f2666e7832e30ea05d175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-submit&lt;/code&gt; event is used for form submissions where major side effects typically happen, such as rendering new containers, calling an external service, or redirecting to a new page.</source>
          <target state="translated">&lt;code&gt;phx-submit&lt;/code&gt; 이벤트는, 새로운 용기를 렌더링하는 외부 서비스를 호출하거나 새 페이지로 리디렉션 등 주요 부작용은 일반적으로 일어날 양식 제출에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3fdb35b1ba87d8758c4c7f6b8c9c83d6077ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-trigger-action&lt;/code&gt; attribute can be added to a form to trigger a standard form submit on DOM patch to the URL specified in the form's standard &lt;code&gt;action&lt;/code&gt; attribute. This is useful to perform pre-final validation of a LiveView form submit before posting to a controller route for operations that require Plug session mutation. For example, in your LiveView template you can annotate the &lt;code&gt;phx-trigger-action&lt;/code&gt; with a boolean assign:</source>
          <target state="translated">&lt;code&gt;phx-trigger-action&lt;/code&gt; 속성은 표준 양식 양식의 표준에 지정된 URL에 DOM 패치에 제출 트리거하는 양식에 추가 할 수있는 &lt;code&gt;action&lt;/code&gt; 속성. 이는 플러그 세션 변형이 필요한 작업을 위해 컨트롤러 경로에 게시하기 전에 LiveView 양식 제출에 대한 사전 최종 유효성 검사를 수행하는 데 유용합니다. 예를 들어 LiveView 템플릿 에서 부울 할당을 사용 하여 &lt;code&gt;phx-trigger-action&lt;/code&gt; 에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7722c1018aa1c3f5818dfe70fb8f2d0e854f196c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_cache&lt;/code&gt; and its state is documented in &lt;a href=&quot;#t:query_cache/0&quot;&gt;&lt;code&gt;query_cache/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query_cache&lt;/code&gt; 그 상태에서 설명 &lt;a href=&quot;#t:query_cache/0&quot;&gt; &lt;code&gt;query_cache/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd929735613a63a87936d342dcfc378113b7e06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct, after they have been normalized. For example, the values &lt;code&gt;selected&lt;/code&gt; by the query, which then have to be returned, can be found in &lt;code&gt;query_meta&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;query_meta&lt;/code&gt; 의 필드에있는 일부 필드가 포함 된지도입니다 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 의&lt;/a&gt; 가 정상화 된 후, 구조체. 예를 들어 쿼리에서 &lt;code&gt;selected&lt;/code&gt; 값 은 반환되어야하며 &lt;code&gt;query_meta&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c3070b126b1c8e20df8236ea7fbdbd8a762f348" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render_many/3&lt;/code&gt; function takes the data we want to respond with (&lt;code&gt;pages&lt;/code&gt;), a view, and a string to pattern match on the &lt;code&gt;render/2&lt;/code&gt; function defined on view. It will map over each item in &lt;code&gt;pages&lt;/code&gt;, and call &lt;code&gt;PageView.render(&quot;page.json&quot;, %{page: page})&lt;/code&gt;. &lt;code&gt;render_one/3&lt;/code&gt; follows, the same signature, ultimately using the &lt;code&gt;render/2&lt;/code&gt; matching &lt;code&gt;page.json&lt;/code&gt; to specify what each &lt;code&gt;page&lt;/code&gt; looks like.</source>
          <target state="translated">&lt;code&gt;render_many/3&lt;/code&gt; 기능은 우리가 (로 응답 할 데이터 소요 &lt;code&gt;pages&lt;/code&gt; ), 뷰, 그리고에 패턴 일치에 문자열 &lt;code&gt;render/2&lt;/code&gt; 뷰에 정의 된 기능을. &lt;code&gt;pages&lt;/code&gt; 각 항목에 매핑되고 &lt;code&gt;PageView.render(&quot;page.json&quot;, %{page: page})&lt;/code&gt; 호출 합니다. &lt;code&gt;render_one/3&lt;/code&gt; 은 동일한 서명을 따르며 궁극적으로 &lt;code&gt;render/2&lt;/code&gt; 일치 &lt;code&gt;page.json&lt;/code&gt; 을 사용하여 각 &lt;code&gt;page&lt;/code&gt; 모양 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e4f45984330c354b062f13b6711532673248bd5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply&lt;/code&gt; is a tuple contain an &lt;code&gt;opcode&lt;/code&gt; atom and a message that can be any term. The built-in websocket transport supports both &lt;code&gt;:text&lt;/code&gt; and &lt;code&gt;:binary&lt;/code&gt; opcode and the message must be always iodata. Long polling only supports text opcode.</source>
          <target state="translated">&lt;code&gt;reply&lt;/code&gt; 투플이 포함 인 &lt;code&gt;opcode&lt;/code&gt; 원자 및 임의의 기간 일 수있는 메시지. 내장 웹 소켓 전송은 &lt;code&gt;:text&lt;/code&gt; 및 &lt;code&gt;:binary&lt;/code&gt; opcode를 모두 지원 하며 메시지는 항상 iodata 여야합니다. 긴 폴링은 텍스트 opcode 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e9961db9b5232c882c065bf97a578f4c214483a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run/1&lt;/code&gt; function is the critical heart of any Mix task. It's the function that does all the work when users invoke our task. In ours, all we do is send a greeting from our app, but we can implement our &lt;code&gt;run/1&lt;/code&gt; function to do whatever we need it to. Note that &lt;code&gt;Mix.shell().info/1&lt;/code&gt; is the preferred way to print text back out to the user.</source>
          <target state="translated">&lt;code&gt;run/1&lt;/code&gt; 기능은 믹스 작업의 중요한 핵심입니다. 사용자가 작업을 호출 할 때 모든 작업을 수행하는 기능입니다. 우리가하는 일은 앱에서 인사말을 보내는 것 뿐이지 만 &lt;code&gt;run/1&lt;/code&gt; 함수를 구현 하여 필요한 모든 작업을 수행 할 수 있습니다. 참고 &lt;code&gt;Mix.shell().info/1&lt;/code&gt; 사용자에게 텍스트 등을 출력 할 수있는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2b70572d736ea97cd893ae8c7a89f40d35ac5c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use Mix.Task&lt;/code&gt; line brings in functionality from Mix that makes this module behave as a mix task.</source>
          <target state="translated">&lt;code&gt;use Mix.Task&lt;/code&gt; 라인은 혼합 작업으로이 모듈없이 행동하게 믹스에서 기능에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a21cb29773a5a21a0cd8e43940897e0aec855c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;views&lt;/code&gt; attribute on the pages will not be updated directly by the user, so let's remove it from the generated form. Open &lt;code&gt;lib/hello_web/templates/cms/page/form.html.eex&lt;/code&gt; and remove this part:</source>
          <target state="translated">페이지 의 &lt;code&gt;views&lt;/code&gt; 속성은 사용자가 직접 업데이트하지 않으므로 생성 된 양식에서 제거하겠습니다. &lt;code&gt;lib/hello_web/templates/cms/page/form.html.eex&lt;/code&gt; 를 열고 다음 부분을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7162959016edba78d69180b52bd5f5a794f9abb9" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Compatible&lt;/strong&gt; cipher suite supports tlsv1, tlsv1.1 and tlsv1.2. Ciphers were based on the OWASP Group B and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults that still maintain support for older browsers and Android versions 4.3 and earlier</source>
          <target state="translated">&lt;strong&gt;지원되는&lt;/strong&gt; 암호 스위트 지원은 tlsv1.1 및 tlsv1.2을 TLSV1. 암호는 OWASP 그룹 B를 기반으로하며 RSA 또는 ECDSA 인증서에 대한 지원을 포함합니다. 이 구성의 목적은 이전 브라우저와 Android 버전 4.3 이하를 계속 지원하는 가능한 기본값을 최대한 안전하게 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99eef0b8032d9eb66bdd6211a81ce1aa7ab072a6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strong&lt;/strong&gt; cipher suite only supports tlsv1.2. Ciphers were based on the OWASP Group A+ and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults knowing that it will not be fully compatible with older browsers and operating systems.</source>
          <target state="translated">&lt;strong&gt;강력한&lt;/strong&gt; 암호화 제품군에만 tlsv1.2을 지원합니다. 암호는 OWASP Group A +를 기반으로하며 RSA 또는 ECDSA 인증서를 지원합니다. 이 구성의 목적은 이전 브라우저 및 운영 체제와 완전히 호환되지 않을 것임을 알고 가능한 한 안전한 기본값을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1229266af5aeb7323a3edd251846a9e31826c75c" translate="yes" xml:space="preserve">
          <source>The API expected by a module plug is defined as a behaviour by the &lt;a href=&quot;plug#content&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; module (this module).</source>
          <target state="translated">모듈 플러그가 예상하는 API는 &lt;a href=&quot;plug#content&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 모듈 (이 모듈) 의 동작으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="397359192255c3cbb30eaefb0a5026e948b7ee90" translate="yes" xml:space="preserve">
          <source>The Complete Elixir and Phoenix Bootcamp Master Functional Programming Techniques with Elixir and Phoenix while Learning to Build Compelling Web Applications (by Stephen Grider - 2017)</source>
          <target state="translated">강력한 웹 응용 프로그램을 구축하는 방법을 배우면서 Elixir 및 Phoenix와 함께 완전한 Elixir 및 Phoenix Bootcamp 마스터 기능 프로그래밍 기술 (by Stephen Grider-2017)</target>
        </trans-unit>
        <trans-unit id="6ca090ddc59b8746edad3d668cd414cb0c01b50e" translate="yes" xml:space="preserve">
          <source>The Controller for LiveView rendering.</source>
          <target state="translated">LiveView 렌더링을위한 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="42a37edfcc20d368aed11372ea5e77be1563e669" translate="yes" xml:space="preserve">
          <source>The Cowboy adapter for Phoenix.</source>
          <target state="translated">Phoenix 용 카우보이 어댑터.</target>
        </trans-unit>
        <trans-unit id="5a9ef2f700440dbe5deb29ded8f4c846809f867a" translate="yes" xml:space="preserve">
          <source>The Cowboy2 adapter for Phoenix.</source>
          <target state="translated">Phoenix 용 Cowboy2 어댑터.</target>
        </trans-unit>
        <trans-unit id="b46e58ab01f0b48b2315edfcf8b2bd6c7e2b3937" translate="yes" xml:space="preserve">
          <source>The Ecto implementation of these operators provide only a thin layer above the adapters. So if your adapter allows you to use them in a certain way (like adding a date and an interval in PostgreSQL), it should work just fine in Ecto queries.</source>
          <target state="translated">이러한 연산자의 Ecto 구현은 어댑터 위에 얇은 계층 만 제공합니다. 따라서 어댑터에서 PostgreSQL에 날짜와 간격을 추가하는 것과 같이 특정 방식으로 어댑터를 사용할 수 있으면 Ecto 쿼리에서 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5fc206f389e6b83e4a0d3d847f1852857f161e08" translate="yes" xml:space="preserve">
          <source>The Ecto type</source>
          <target state="translated">엑토 타입</target>
        </trans-unit>
        <trans-unit id="dfd71c1d2df0567450285bf90b77cd7746d88f5d" translate="yes" xml:space="preserve">
          <source>The Ecto type.</source>
          <target state="translated">엑토 타입.</target>
        </trans-unit>
        <trans-unit id="8af11c43a109763d817fe84ffba10efa53664805" translate="yes" xml:space="preserve">
          <source>The Ecto.Changeset struct</source>
          <target state="translated">Ecto.Changeset 구조체</target>
        </trans-unit>
        <trans-unit id="22799cdc97ac8d9ad98ed9959054ca073ced3180" translate="yes" xml:space="preserve">
          <source>The Elixir and Phoenix communities are friendly and welcoming. All questions and comments are valuable, so please come join the discussion!</source>
          <target state="translated">Elixir와 Phoenix 커뮤니티는 친절하고 환영합니다. 모든 질문과 의견은 소중하므로 토론에 참여하십시오!</target>
        </trans-unit>
        <trans-unit id="2df24cb6684bccd3bc7f1741ada3cd48d84d2739" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyApp.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="translated">Elixir 컴파일러는 라우터가 &lt;code&gt;MyApp.PageController&lt;/code&gt; 에 직접 의존한다고 추론하지만 이는 사실이 아닙니다. 범위를 사용하여 Phoenix는 Elixir 컴파일러에게 컨트롤러가 라우터의 실제 종속성이 아니라고 암시 할 수 있습니다. 보다 효율적인 컴파일 시간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91a790f106411de498ef0d34631c0e826c9311e7" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="translated">Elixir 컴파일러는 라우터가 &lt;code&gt;MyAppWeb.PageController&lt;/code&gt; 에 직접 의존한다고 추론 하는데 , 이는 사실이 아닙니다. 범위를 사용함으로써 Phoenix는 Elixir 컴파일러에 컨트롤러가 라우터의 실제 종속성이 아니라는 것을 적절하게 힌트 할 수 있습니다. 이것은보다 효율적인 컴파일 시간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91f2df3ac4e5339357f53ff3d7998fcb1bc9dcf6" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP runtime, with OpenSSL bindings; run &lt;code&gt;:crypto.info_lib()&lt;/code&gt; in an IEx session to verify</source>
          <target state="translated">OpenSSL 바인딩을 사용하는 Erlang / OTP 런타임; IEx 세션에서 &lt;code&gt;:crypto.info_lib()&lt;/code&gt; 를 실행 하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a64bf2211a83bfb2580975f065ce021d849dded2" translate="yes" xml:space="preserve">
          <source>The ErrorView</source>
          <target state="translated">ErrorView</target>
        </trans-unit>
        <trans-unit id="7dcdec73ad8cfefe7c01cd059a8be75e6642807e" translate="yes" xml:space="preserve">
          <source>The JavaScript client is always the source of truth for current input values. For any given input with focus, LiveView will never overwrite the input's current value, even if it deviates from the server's rendered updates. This works well for updates where major side effects are not expected, such as form validation errors, or additive UX around the user's input values as they fill out a form.</source>
          <target state="translated">JavaScript 클라이언트는 항상 현재 입력 값에 대한 진실의 소스입니다. 포커스가있는 입력에 대해 LiveView는 서버의 렌더링 된 업데이트에서 벗어나더라도 입력의 현재 값을 덮어 쓰지 않습니다. 이는 양식 유효성 검사 오류 또는 양식을 작성할 때 사용자 입력 값 주변의 추가 UX와 같이 주요 부작용이 예상되지 않는 업데이트에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="831c44469432e217932a773e59cba3396570b870" translate="yes" xml:space="preserve">
          <source>The LiveView entry-point.</source>
          <target state="translated">LiveView 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="84226f67c848aa70d2bc109fe1a02c277fbf9624" translate="yes" xml:space="preserve">
          <source>The LiveView programming model is declarative: instead of saying &quot;once event X happens, change Y on the page&quot;, events in LiveView are regular messages which may cause changes to its state. Once the state changes, LiveView will re-render the relevant parts of its HTML template and push it to the browser, which updates itself in the most efficient manner. This means developers write LiveView templates as any other server-rendered HTML and LiveView does the hard work of tracking changes and sending the relevant diffs to the browser.</source>
          <target state="translated">LiveView 프로그래밍 모델은 선언적입니다. &quot;이벤트 X가 발생하면 페이지에서 Y를 변경하십시오&quot;라고 말하는 대신 LiveView의 이벤트는 상태를 변경할 수있는 일반 메시지입니다. 상태가 변경되면 LiveView는 HTML 템플릿의 관련 부분을 다시 렌더링하고 브라우저로 푸시하여 가장 효율적인 방식으로 자체 업데이트합니다. 즉, 개발자는 다른 서버 렌더링 HTML과 마찬가지로 LiveView 템플릿을 작성하고 LiveView는 변경 사항을 추적하고 관련 차이점을 브라우저로 보내는 어려운 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1cabc4988a5643640cd777c24c4e10db6bb7accd" translate="yes" xml:space="preserve">
          <source>The LiveView socket for Phoenix Endpoints.</source>
          <target state="translated">Phoenix Endpoints 용 LiveView 소켓.</target>
        </trans-unit>
        <trans-unit id="e596187a19062dc70866323907923d83b3869a8b" translate="yes" xml:space="preserve">
          <source>The LiveView then receives this event using &lt;code&gt;handle_info&lt;/code&gt;:</source>
          <target state="translated">그런 다음 LiveView는 &lt;code&gt;handle_info&lt;/code&gt; 를 사용하여이 이벤트를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="5341cef174c7e030180c57e14cc0a67dcaa4ae50" translate="yes" xml:space="preserve">
          <source>The MFA is invoked with the request &lt;code&gt;%URI{}&lt;/code&gt; as the first argument, followed by arguments in the MFA list.</source>
          <target state="translated">MFA는 요청 &lt;code&gt;%URI{}&lt;/code&gt; 를 첫 번째 인수로 사용하여 호출되고 그 뒤에 MFA 목록의 인수가 이어집니다.</target>
        </trans-unit>
        <trans-unit id="270a37f0365dba4dfda17bef61d0b68ede5a7a86" translate="yes" xml:space="preserve">
          <source>The PKCS#12 format is a container format containing one or more certificates and/or encrypted keys. Such files typically have a &lt;code&gt;.p12&lt;/code&gt; extension.</source>
          <target state="translated">PKCS # 12 형식은 하나 이상의 인증서 및 / 또는 암호화 된 키를 포함하는 컨테이너 형식입니다. 이러한 파일은 일반적으로 &lt;code&gt;.p12&lt;/code&gt; 확장자를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3f1e3a1bf73da067cc61947c8f82ff5aabd55c0a" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.eex&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.eex&lt;/code&gt; 확장자 를 처리하는 Phoenix 엔진 .</target>
        </trans-unit>
        <trans-unit id="97f5600c69f57f57eb8f0eebfbf4c79da16ad178" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.exs&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.exs&lt;/code&gt; 확장명 을 처리하는 Phoenix 엔진 .</target>
        </trans-unit>
        <trans-unit id="7c893ff0c14a28253d63b6b6ebed042b7d8d1529" translate="yes" xml:space="preserve">
          <source>The Plug connection.</source>
          <target state="translated">플러그 연결.</target>
        </trans-unit>
        <trans-unit id="922dcb442d54e2eb649f3edaeaaef6847fb03b26" translate="yes" xml:space="preserve">
          <source>The Plug pipeline</source>
          <target state="translated">플러그 파이프 라인</target>
        </trans-unit>
        <trans-unit id="6a8a63036ac108e3e027fabac2b118fd6784c36b" translate="yes" xml:space="preserve">
          <source>The Schema</source>
          <target state="translated">스키마</target>
        </trans-unit>
        <trans-unit id="c4c6b8de891ce76973a55d8788f25b02282a6500" translate="yes" xml:space="preserve">
          <source>The Strict-Transport-Security header can be disabled altogether by setting &lt;code&gt;hsts: false&lt;/code&gt; in the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 옵션 에서 &lt;code&gt;hsts: false&lt;/code&gt; 를 설정하여 Strict-Transport-Security 헤더를 모두 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c9c578a9e075a767d2efcef454f02f30cab843" translate="yes" xml:space="preserve">
          <source>The Telemetry supervisor</source>
          <target state="translated">Telemetry 감독자</target>
        </trans-unit>
        <trans-unit id="75bea59495492e66c838d460fdfd553076619980" translate="yes" xml:space="preserve">
          <source>The Telemetry.Metrics package provides a common interface for defining metrics. It exposes a set of &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics&quot;&gt;five metric type functions&lt;/a&gt; that are responsible for structuring a given Telemetry event as a particular measurement.</source>
          <target state="translated">Telemetry.Metrics 패키지는 메트릭 정의를위한 공통 인터페이스를 제공합니다. 특정 측정으로 주어진 Telemetry 이벤트를 구조화하는 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics&quot;&gt;5 개의 메트릭 유형 함수&lt;/a&gt; 세트를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="44b0c7e1640a8c7aaaeec212113c4828dc9f200b" translate="yes" xml:space="preserve">
          <source>The URL generated in the named URL helpers is based on the configuration for &lt;code&gt;:url&lt;/code&gt;, &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt;. However, if for some reason you need to manually control the URL generation, the url helpers also allow you to pass in a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct:</source>
          <target state="translated">명명 된 URL 헬퍼에서 생성 된 URL은 &lt;code&gt;:url&lt;/code&gt; , &lt;code&gt;:http&lt;/code&gt; 및 &lt;code&gt;:https&lt;/code&gt; 구성을 기반으로합니다 . 그러나 어떤 이유로 URL 생성을 수동으로 제어해야하는 경우 URL 헬퍼를 사용하여 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 구조체 를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01f10584ffce5babefcdc2a0a4a9fa67e62fc824" translate="yes" xml:space="preserve">
          <source>The above approach is the preferred one when passing blocks to &lt;code&gt;do/end&lt;/code&gt;. However, if you are outside of a .leex template and you want to invoke a component passing a &lt;code&gt;do/end&lt;/code&gt; block, you will have to explicitly handle the assigns by giving it a &lt;code&gt;-&amp;gt;&lt;/code&gt; clause:</source>
          <target state="translated">위의 접근 방식은 블록을 &lt;code&gt;do/end&lt;/code&gt; 로 전달할 때 선호되는 접근 방식입니다 . 그러나 .leex 템플릿 외부에 있고 &lt;code&gt;do/end&lt;/code&gt; 블록을 전달하는 구성 요소를 호출 하려면 &lt;code&gt;-&amp;gt;&lt;/code&gt; 절 을 제공하여 할당을 명시 적으로 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="439164b882483574280fd7b6ddd89690e34cb2f9" translate="yes" xml:space="preserve">
          <source>The above example matches all the posts which are tied for being the most visited.</source>
          <target state="translated">위의 예는 가장 많이 방문한 것으로 연결된 모든 게시물과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="90e2cd8ec0b373e2a840d10a660fde9ed74b82f4" translate="yes" xml:space="preserve">
          <source>The above is specially useful to dynamically join on existing queries, for example, to dynamically choose a source, or by choosing between public posts or posts that have been recently published:</source>
          <target state="translated">위의 내용은 동적으로 소스를 선택하거나 최근에 게시 된 공개 게시물 또는 게시물 중에서 선택하여 기존 쿼리에 동적으로 참여하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ba48186478fa2045834150142a3421eea75c78b0" translate="yes" xml:space="preserve">
          <source>The above life-cycle callbacks have in-scope access to the following attributes:</source>
          <target state="translated">위의 수명주기 콜백에는 다음 속성에 대한 범위 내 액세스 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04796d750e2caa373bfdeb6b87607dcbc4363014" translate="yes" xml:space="preserve">
          <source>The action may be any atom.</source>
          <target state="translated">동작은 어떤 원자라도 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e8e7c6d83aa7057d13eecb45b68bd52baf600f" translate="yes" xml:space="preserve">
          <source>The action may be one of &lt;code&gt;:insert&lt;/code&gt;, &lt;code&gt;:update&lt;/code&gt;, &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:replace&lt;/code&gt;.</source>
          <target state="translated">조치는 &lt;code&gt;:insert&lt;/code&gt; , &lt;code&gt;:update&lt;/code&gt; , &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:replace&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99e3ae0551db581b86eb9b59e1bc23af5b2492a7" translate="yes" xml:space="preserve">
          <source>The actual routes we get all look right, except for the path helper &lt;code&gt;review_path&lt;/code&gt; at the beginning of each line. We are getting the same helper for both the user facing review routes and the admin ones, which is not correct.</source>
          <target state="translated">각 줄의 시작 부분에 있는 경로 도우미 &lt;code&gt;review_path&lt;/code&gt; 를 제외하고 우리가 얻는 실제 경로는 모두 올바르게 보입니다 . 우리는 사용자가 직면 한 검토 경로와 관리자 경로 모두에 대해 동일한 도우미를 얻습니다. 이는 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fa523a4ad5df57fc1402bd4a02afcabbc3fd16b" translate="yes" xml:space="preserve">
          <source>The admin review paths could be prefixed with &lt;code&gt;/admin&lt;/code&gt;.</source>
          <target state="translated">관리자 검토 경로는 &lt;code&gt;/admin&lt;/code&gt; 접두사로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="568c1593cd6ebf7435ec1fe16f10bd8ce0b59776" translate="yes" xml:space="preserve">
          <source>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</source>
          <target state="translated">이러한 속성을 통해 스키마를 구성하면 응용 프로그램 전체 기본값을 구성하기 위해 매크로를 사용하여 스키마를 설정할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="12424a03c3ce8ae50505e2f4d39be7ede0456bb6" translate="yes" xml:space="preserve">
          <source>The aggregation will fail if any &lt;code&gt;group_by&lt;/code&gt; field is set.</source>
          <target state="translated">&lt;code&gt;group_by&lt;/code&gt; 필드가 설정 되면 집계가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="fd3788421c7ea60194ff0b67a68304eebb16c4a2" translate="yes" xml:space="preserve">
          <source>The allowed values are:</source>
          <target state="translated">허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea72cf622646db7be3f6fbd8024e8493b451ac92" translate="yes" xml:space="preserve">
          <source>The answer is we've decided to expose &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; as a public &lt;em&gt;data-structure&lt;/em&gt; in our application. We saw before how changesets allow us to track field changes, perform validations, and generate error messages. Its use here is decoupled from the private Repo access and Ecto changeset API internals. We're exposing a data structure that the caller understands which contains the rich information like field errors. Conveniently for us, the &lt;code&gt;phoenix_ecto&lt;/code&gt; project implements the necessary &lt;a href=&quot;phoenix.param&quot;&gt;&lt;code&gt;Phoenix.Param&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../phoenix_html/phoenix.html.formdata&quot;&gt;&lt;code&gt;Phoenix.HTML.FormData&lt;/code&gt;&lt;/a&gt; protocols which know how to handle &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt;'s for things like form generation and error messages. You can also think about it as being as if you had defined your own &lt;code&gt;%Accounts.Changes{}&lt;/code&gt; struct for the same purpose and implemented the Phoenix protocols for the web-layer integration.</source>
          <target state="translated">답은 &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; 를 애플리케이션 의 공용 &lt;em&gt;데이터 구조&lt;/em&gt; 로 노출하기로 결정한 것입니다. 변경 세트를 통해 필드 변경 사항을 추적하고 유효성 검사를 수행하고 오류 메시지를 생성하는 방법을 살펴 보았습니다. 여기서의 사용은 개인 Repo 액세스 및 Ecto 변경 집합 API 내부와 분리되어 있습니다. 필드 오류와 같은 풍부한 정보를 포함하는 호출자가 이해하는 데이터 구조를 노출합니다. 편리하게 우리를 들면, &lt;code&gt;phoenix_ecto&lt;/code&gt; 의 프로젝트 구현에 필요한 &lt;a href=&quot;phoenix.param&quot;&gt; &lt;code&gt;Phoenix.Param&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../phoenix_html/phoenix.html.formdata&quot;&gt; &lt;code&gt;Phoenix.HTML.FormData&lt;/code&gt; &lt;/a&gt; 처리하는 방법을 알고 프로토콜 &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; 양식 생성 및 오류 메시지와 같은 것입니다. 같은 목적으로 자신의 &lt;code&gt;%Accounts.Changes{}&lt;/code&gt; 구조체를 정의 하고 웹 계층 통합을 위해 Phoenix 프로토콜을 구현 한 것처럼 생각할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84bd30260d2ce05fc55d7e66349743b933c0b4f2" translate="yes" xml:space="preserve">
          <source>The argument given to &lt;code&gt;:select_merge&lt;/code&gt; must always be a map. The value being merged on must be a struct or a map. If it is a struct, the fields merged later on must be part of the struct, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;:select_merge&lt;/code&gt; 에 제공된 인수 는 항상 맵이어야합니다. 병합되는 값은 구조체 또는 맵이어야합니다. 구조체 인 경우 나중에 병합 된 필드는 구조체의 일부 여야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="21c3223c139377b3829c552e343068576edd50ef" translate="yes" xml:space="preserve">
          <source>The argument, which defaults to &lt;code&gt;Presence&lt;/code&gt;, defines the module name of the Presence tracker.</source>
          <target state="translated">&lt;code&gt;Presence&lt;/code&gt; 로 기본 설정되는 인수 는 Presence 추적기의 모듈 이름을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fde4255a8dc0fcc4b0ec76dc711d0f44d251bab" translate="yes" xml:space="preserve">
          <source>The assign tracking feature also implies that you MUST avoid performing direct operations in the template. For example, if you perform a database query in your template:</source>
          <target state="translated">또한 추적 할당 기능은 템플릿에서 직접 작업을 수행하지 않아야 함을 의미합니다. 예를 들어 템플릿에서 데이터베이스 쿼리를 수행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2a43c3065c3f85e925ab838ea91589ca677d687c" translate="yes" xml:space="preserve">
          <source>The associated data may be given in different formats:</source>
          <target state="translated">관련 데이터는 다른 형식으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af98cf8faab35d0cae464cb5a1cd4f56217e0ba" translate="yes" xml:space="preserve">
          <source>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</source>
          <target state="translated">연관은 연관된 스키마에 대한 외부 키를 포함하는 결합 스키마 또는 소스를 통해 발생합니다. 예를 들어 아래 연결은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="888fd6b9696e2737394550f497e91b80c4256ba5" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; associations.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 및 &lt;code&gt;has_many&lt;/code&gt; 연관에 대한 연관 구조 .</target>
        </trans-unit>
        <trans-unit id="c3f2a2472baf2138a4d294eca1e823e09180b2a8" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; through associations.</source>
          <target state="translated">연관을 통한 &lt;code&gt;has_one&lt;/code&gt; 및 &lt;code&gt;has_many&lt;/code&gt; 에 대한 연관 구조 .</target>
        </trans-unit>
        <trans-unit id="581a7057c4a1b009249b52b9b19b5e74771aaf2a" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;many_to_many&lt;/code&gt; associations.</source>
          <target state="translated">&lt;code&gt;many_to_many&lt;/code&gt; 연관에 대한 연관 구조 .</target>
        </trans-unit>
        <trans-unit id="66e6c87098b4230d834f2d5a056760f88cae1720" translate="yes" xml:space="preserve">
          <source>The association struct for a &lt;code&gt;belongs_to&lt;/code&gt; association.</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 연관을 위한 연관 구조체 .</target>
        </trans-unit>
        <trans-unit id="5205f046f1668f8df50e1a7dbf5d13e856ecfbab" translate="yes" xml:space="preserve">
          <source>The atoms that can be used in place of the status code in many functions are inflected from the reason phrase of the status code. With the above configuration, the following will all work:</source>
          <target state="translated">많은 기능에서 상태 코드 대신 사용할 수있는 원자는 상태 코드의 이유 문구에서 반영됩니다. 위의 구성으로 다음이 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="480698b107c5364224299e11120625edd4811333" translate="yes" xml:space="preserve">
          <source>The behaviour above is by design to keep the changes between &lt;code&gt;where&lt;/code&gt; and &lt;code&gt;or_where&lt;/code&gt; minimal. Plus, if you have a keyword list and you would like each pair to be combined using &lt;code&gt;or&lt;/code&gt;, it can be easily done with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위의 동작은 의도적으로 &lt;code&gt;where&lt;/code&gt; 와 &lt;code&gt;or_where&lt;/code&gt; 사이의 변경을 최소화하기위한 것입니다. 게다가, 당신은 키워드 목록이 있고 사용하여 결합 될 각 쌍을 좋아하면 것인지 &lt;code&gt;or&lt;/code&gt; 그것을 쉽게 수행 할 수 있습니다, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3bc279bd4a05a0f1e2ea5d2a5959b414a345411f" translate="yes" xml:space="preserve">
          <source>The benefit of having explicit changesets is that we can easily provide different changesets for different use cases. For example, one could easily provide specific changesets for registering and updating users:</source>
          <target state="translated">명시적인 변경 세트를 사용하면 다른 사용 사례에 대해 다른 변경 세트를 쉽게 제공 할 수 있다는 이점이 있습니다. 예를 들어, 사용자 등록 및 업데이트를위한 특정 변경 세트를 쉽게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33976fda84cd70626bac12299c44a1b4814775d" translate="yes" xml:space="preserve">
          <source>The binary is assumed to be encoded in &quot;x-www-form-urlencoded&quot; format. The format is decoded and then validated for proper UTF-8 encoding.</source>
          <target state="translated">바이너리는 &quot;x-www-form-urlencoded&quot;형식으로 인코딩 된 것으로 간주됩니다. 형식이 디코딩 된 다음 적절한 UTF-8 인코딩에 대해 유효성이 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="0833558fe12b0d9b2e81768ddbb74f8c8021373c" translate="yes" xml:space="preserve">
          <source>The browser can send a variety of events to a LiveView via &lt;code&gt;phx-&lt;/code&gt; bindings, which are sent to the &lt;code&gt;handle_event/3&lt;/code&gt; callback. To test events sent by the browser and assert on the rendered side effect of the event, use the &lt;code&gt;render_*&lt;/code&gt; functions:</source>
          <target state="translated">브라우저는 &lt;code&gt;phx-&lt;/code&gt; binding을 통해 LiveView에 다양한 이벤트를 보낼 수 있으며,이 이벤트 는 &lt;code&gt;handle_event/3&lt;/code&gt; 콜백으로 전송됩니다 . 브라우저에서 보낸 이벤트를 테스트하고 이벤트의 렌더링 된 부작용에 대해 어설 션하려면 &lt;code&gt;render_*&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="47dd120170d17aa1d0f259374abed03b66d4f7d7" translate="yes" xml:space="preserve">
          <source>The cache can be in 3 states, documented below.</source>
          <target state="translated">캐시는 아래에 설명 된 3 가지 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af03881748bd2064e8f807b0d417c42f2bf8b4b" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code</source>
          <target state="translated">어댑터가 코드를 주입해야하는 경우에 호출 된 콜백</target>
        </trans-unit>
        <trans-unit id="67ef6fb0196e40fee0ed0f4b18726aa52ce6c746" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code.</source>
          <target state="translated">어댑터가 코드를 주입해야하는 경우 호출 된 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="5bbfddd88f74a0c053e76f91efe40fb552ccd1a5" translate="yes" xml:space="preserve">
          <source>The callback will be invoked for all queries, including queries made from associations and preloads. It is not invoked for each individual join inside a query.</source>
          <target state="translated">콜백은 연결 및 사전로드에서 만든 쿼리를 포함하여 모든 쿼리에 대해 호출됩니다. 쿼리 내의 각 개별 조인에 대해 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="465bc3533bd128c95cfecfc17237e61c1f085130" translate="yes" xml:space="preserve">
          <source>The catch-all verb, &lt;code&gt;:*&lt;/code&gt;, may also be used to match all HTTP methods.</source>
          <target state="translated">catch-all 동사 인 &lt;code&gt;:*&lt;/code&gt; 도 모든 HTTP 메소드와 일치시키는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a92f849f6522a2c3db6efb9017fed09736bbac71" translate="yes" xml:space="preserve">
          <source>The certificate and CA chain can also be specified using DER binaries, using the &lt;code&gt;:cert&lt;/code&gt; and &lt;code&gt;:cacerts&lt;/code&gt; options, but this is best avoided. The use of PEM files has been tested much more thoroughly with the Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; application, and there have been a number of issues with DER binary certificates in the past.</source>
          <target state="translated">인증서 및 CA 체인은 &lt;code&gt;:cert&lt;/code&gt; 및 &lt;code&gt;:cacerts&lt;/code&gt; 옵션을 사용하여 DER 바이너리를 사용하여 지정할 수도 있지만 이것은 피하는 것이 가장 좋습니다. PEM 파일의 사용은 Erlang / OTP &lt;code&gt;:ssl&lt;/code&gt; 응용 프로그램으로 훨씬 더 철저하게 테스트 되었으며 과거에는 DER 바이너리 인증서와 관련하여 많은 문제가있었습니다.</target>
        </trans-unit>
        <trans-unit id="abd434dfdfacea66c9516a4ae4981484c3f005f5" translate="yes" xml:space="preserve">
          <source>The certificate files, like keyfile, certfile, cacertfile, dhfile can be given as a relative path. For such, the &lt;code&gt;:otp_app&lt;/code&gt; option must also be given and certificates will be looked from the priv directory of the given application</source>
          <target state="translated">keyfile, certfile, cacertfile, dhfile과 같은 인증서 파일은 상대 경로로 제공 될 수 있습니다. 이를 위해 &lt;code&gt;:otp_app&lt;/code&gt; 옵션도 제공해야하며 인증서는 주어진 응용 프로그램의 priv 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c4d811c59379111f1c1ff93c837d9da4b33e1af" translate="yes" xml:space="preserve">
          <source>The change is to define the &lt;code&gt;live_view&lt;/code&gt; and &lt;code&gt;live_component&lt;/code&gt; functions in your &lt;code&gt;my_app_web.ex&lt;/code&gt; file, while refactoring the &lt;code&gt;view&lt;/code&gt; function. At the end, they will look like this:</source>
          <target state="translated">&lt;code&gt;view&lt;/code&gt; 함수 를 리팩토링하면서 &lt;code&gt;my_app_web.ex&lt;/code&gt; 파일 에서 &lt;code&gt;live_view&lt;/code&gt; 및 &lt;code&gt;live_component&lt;/code&gt; 함수 를 정의하는 것이 변경 되었습니다 . 마지막에는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f895ed3a5a29fab28a57c67512d9e78fea0303d" translate="yes" xml:space="preserve">
          <source>The change tracking also works when rendering other templates as long as they are also &lt;code&gt;.leex&lt;/code&gt; templates:</source>
          <target state="translated">변경 내용 추적은 &lt;code&gt;.leex&lt;/code&gt; 템플릿 인 경우 다른 템플릿을 렌더링 할 때도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a8048a4c70c26c609930c982d23c8e90c3c74914" translate="yes" xml:space="preserve">
          <source>The changeset must have been previously &lt;code&gt;cast&lt;/code&gt; using &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; before this function is invoked.</source>
          <target state="translated">이 함수를 호출하기 전에 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 를 사용하여 변경 세트를 이전에 &lt;code&gt;cast&lt;/code&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="160a4bd88e21d5ca169655a091e64a1bf7eb4d1d" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">소켓을 소유 한 채널은 게시 된 메시지를받지 않습니다. 이벤트 메시지는 직렬화 가능한 맵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="14225c93c28bf8ec888fac6e844921cc19f40df5" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event's message must be a serializable map.</source>
          <target state="translated">소켓을 소유 한 채널은 게시 된 메시지를 수신하지 않습니다. 이벤트의 메시지는 직렬화 가능한 맵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a87a04668a71cfebe522dc33304dfa1bb9aafa32" translate="yes" xml:space="preserve">
          <source>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">검사 제한 조건은 데이터베이스를 사용하여 검사 제한 조건이 위반되었는지 여부를 확인하고, 그렇다면 Ecto가이를 변경 세트 오류로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="189a91a56422abe5ad6f16e83079ee9147df5171" translate="yes" xml:space="preserve">
          <source>The ciphers chosen and related configuration are based on &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP recommendations&lt;/a&gt;, with some modifications as described in the &lt;a href=&quot;plug.ssl#configure/1&quot;&gt;&lt;code&gt;Plug.SSL.configure/1&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">선택한 암호 및 관련 구성은 &lt;a href=&quot;plug.ssl#configure/1&quot;&gt; &lt;code&gt;Plug.SSL.configure/1&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 일부 수정 &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;사항이&lt;/a&gt; 있는 OWASP 권장 사항을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="cb2140aa521991d539b4e2e897df286c32583783" translate="yes" xml:space="preserve">
          <source>The code above builds a query that returns all organizations that belongs to the current user and then validates that the given &quot;org_id&quot; belongs to the user. If there is no such &quot;org_id&quot; or if the user has no access to it, an &lt;code&gt;Ecto.NotFoundError&lt;/code&gt; exception is raised.</source>
          <target state="translated">위의 코드는 현재 사용자에게 속한 모든 조직을 반환하는 쿼리를 작성한 다음 주어진 &quot;org_id&quot;가 사용자에게 속하는지 확인합니다. 그러한 &quot;org_id&quot;가 없거나 사용자에게 액세스 권한이 없으면 &lt;code&gt;Ecto.NotFoundError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e55ac05c44eebe5ced7773b3f09d70f633a77d33" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn&amp;rsquo;t need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="translated">열 이름은 임의적이며 &lt;code&gt;:lock_version&lt;/code&gt; 일 필요는 없습니다 . 이제 스키마에도 필드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="22ce43d9dab9ba680dd79938365e5a367bde9ba9" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn't need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="translated">열 이름은 임의적이며 &lt;code&gt;:lock_version&lt;/code&gt; 이 아니 어도 됩니다. 이제 스키마에도 필드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="75c1a428d5c10266245cfaf3fb20fc81b6b19a29" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via a WebSocket connection. Events are routed by topic to channels:</source>
          <target state="translated">위의 명령은 WebSocket 연결을 통해 들어오는 소켓 연결을 만들 수 있음을 의미합니다. 이벤트는 주제별로 채널로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d46c8827dfa162c3fc24d840406076f113e566" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via the WebSocket transport. Events are routed by topic to channels:</source>
          <target state="translated">위의 명령은 WebSocket 전송을 통해 들어오는 소켓을 연결할 수 있음을 의미합니다. 이벤트는 주제별로 채널로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bed204f25946a181bf872deafb93e1b8f811e4" translate="yes" xml:space="preserve">
          <source>The command above will effectively change the value of &lt;code&gt;conn.scheme&lt;/code&gt; by the one sent in &lt;code&gt;x-forwarded-proto&lt;/code&gt;.</source>
          <target state="translated">위의 명령 은 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 에서 보낸 값으로 &lt;code&gt;conn.scheme&lt;/code&gt; 의 값을 효과적으로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="06d3e38d14906c69fe67c98e93d6ea14a4bb8bfd" translate="yes" xml:space="preserve">
          <source>The component ends up enclosed by the form markup, where LiveView cannot track it. In such cases, you may receive an error such as:</source>
          <target state="translated">구성 요소는 LiveView에서 추적 할 수없는 양식 마크 업으로 묶여 있습니다. 이러한 경우 다음과 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4afae376b75b4be5f358115a2f298594ed796ab" translate="yes" xml:space="preserve">
          <source>The component that is updated must be stateful (the &lt;code&gt;:id&lt;/code&gt; in the assigns must match the &lt;code&gt;:id&lt;/code&gt; associated with the component) and the component must be mounted within the current LiveView.</source>
          <target state="translated">업데이트 된 구성 요소 상태 여야합니다 ( &lt;code&gt;:id&lt;/code&gt; 의 양수인은 일치해야 &lt;code&gt;:id&lt;/code&gt; 상기 구성 요소는 현재의 라이브 뷰 내에 장착되어야하는 구성 요소와 연관된 참조).</target>
        </trans-unit>
        <trans-unit id="7ac44c98f163a9b266d4abe83ee653c46374e382" translate="yes" xml:space="preserve">
          <source>The configuration above takes care of starting the pubsub backend and exposing its functions via the endpoint module. If no adapter but a name is given, nothing will be started, but the pubsub system will work by sending events and subscribing to the given name.</source>
          <target state="translated">위의 구성은 pubsub 백엔드를 시작하고 엔드 포인트 모듈을 통해 해당 기능을 노출하는 것을 처리합니다. 이름이 지정되지 않은 어댑터가 없으면 아무것도 시작되지 않지만 pubsub 시스템은 이벤트를 전송하고 지정된 이름을 구독하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8b296a52b4ef4041ccbced6b08d102098ca424ae" translate="yes" xml:space="preserve">
          <source>The configuration above will start a Redis pubsub and register it with name &lt;code&gt;:my_pubsub&lt;/code&gt;.</source>
          <target state="translated">위의 구성은 Redis pubsub를 시작하고 이름 &lt;code&gt;:my_pubsub&lt;/code&gt; 로 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="0c3243504e5d91d9054ed22ddbd7d15078c0b7c3" translate="yes" xml:space="preserve">
          <source>The configuration below can be given to both &lt;code&gt;:websocket&lt;/code&gt; and &lt;code&gt;:longpoll&lt;/code&gt; keys:</source>
          <target state="translated">아래 구성은 &lt;code&gt;:websocket&lt;/code&gt; 및 &lt;code&gt;:longpoll&lt;/code&gt; 키 모두에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="468fbe7bf04f16c5040863a52f0d55b418c094c8" translate="yes" xml:space="preserve">
          <source>The connection state is used to track the connection lifecycle. It starts as &lt;code&gt;:unset&lt;/code&gt; but is changed to &lt;code&gt;:set&lt;/code&gt; (via &lt;a href=&quot;#resp/3&quot;&gt;&lt;code&gt;resp/3&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:set_chunked&lt;/code&gt; (used only for &lt;code&gt;before_send&lt;/code&gt; callbacks by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:file&lt;/code&gt; (when invoked via &lt;a href=&quot;#send_file/3&quot;&gt;&lt;code&gt;send_file/3&lt;/code&gt;&lt;/a&gt;). Its final result is &lt;code&gt;:sent&lt;/code&gt;, &lt;code&gt;:file&lt;/code&gt; or &lt;code&gt;:chunked&lt;/code&gt; depending on the response model.</source>
          <target state="translated">연결 상태는 연결 수명주기를 추적하는 데 사용됩니다. &lt;code&gt;:unset&lt;/code&gt; 으로 시작 하지만 &lt;code&gt;:set&lt;/code&gt; ( &lt;a href=&quot;#resp/3&quot;&gt; &lt;code&gt;resp/3&lt;/code&gt; &lt;/a&gt; 를 통해 ) 또는 &lt;code&gt;:set_chunked&lt;/code&gt; ( &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; 에&lt;/a&gt; 의해 &lt;code&gt;before_send&lt;/code&gt; 콜백 에만 사용됨 ) 또는 &lt;code&gt;:file&lt;/code&gt; ( &lt;a href=&quot;#send_file/3&quot;&gt; &lt;code&gt;send_file/3&lt;/code&gt; 을&lt;/a&gt; 통해 호출 될 때 )로 변경됩니다. 최종 결과는 응답 모델에 따라 &lt;code&gt;:sent&lt;/code&gt; , &lt;code&gt;:file&lt;/code&gt; 또는 &lt;code&gt;:chunked&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48566362cafe346914c5a6f03d80d57d5efcb820" translate="yes" xml:space="preserve">
          <source>The connection will be configured with the given &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;path_or_action&lt;/code&gt; and &lt;code&gt;params_or_body&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;method&lt;/code&gt; 인 &lt;code&gt;path_or_action&lt;/code&gt; 과 &lt;code&gt;params_or_body&lt;/code&gt; 로 연결이 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d448c7ac90d83c40db5bfb1c89d1edee4438350" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s endpoint will be used for URL generation. See &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt; for details on how the request path is generated.</source>
          <target state="translated">연결 엔드 포인트는 URL 생성에 사용됩니다. 요청 경로 생성 방법에 대한 자세한 내용 은 &lt;a href=&quot;#current_path/1&quot;&gt; &lt;code&gt;current_path/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40469a6ab597b422ee4f68bd557b30e3be2a9ae" translate="yes" xml:space="preserve">
          <source>The container can be customized in different ways:</source>
          <target state="translated">컨테이너는 다양한 방법으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d4bab9d56a81796bac83a3ef42018e650c34ee" translate="yes" xml:space="preserve">
          <source>The context app</source>
          <target state="translated">컨텍스트 앱</target>
        </trans-unit>
        <trans-unit id="0facde72bd2ec18fe66926da4d93236d6aff0bce" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource.</source>
          <target state="translated">컨텍스트는 주어진 리소스에 대한 API 경계 역할을하는 Elixir 모듈입니다. 컨텍스트는 종종 많은 관련 리소스를 보유합니다. 따라서 컨텍스트가 이미 존재하는 경우 주어진 자원에 대한 기능으로 보강됩니다.</target>
        </trans-unit>
        <trans-unit id="f31946d1aec3ffc473697b735314efcde461c192" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource. Note a resource may also be split over distinct contexts (such as Accounts.User and Payments.User).</source>
          <target state="translated">컨텍스트는 주어진 리소스에 대한 API 경계 역할을하는 Elixir 모듈입니다. 컨텍스트에는 종종 많은 관련 리소스가 있습니다. 따라서 컨텍스트가 이미 존재하면 주어진 자원에 대한 기능으로 기능이 보강됩니다. 자원은 고유 한 컨텍스트 (예 : Accounts.User 및 Payments.User)로 분할 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef96e1551a038d10e050b366a6393c8066aa195" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, and so on, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">쿠키 값은 자동으로 이스케이프되지 않습니다. 따라서 쉼표, 따옴표 등으로 값을 저장하려면 값을 명시 적으로 이스케이프하거나 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 와 같은 함수를 사용 하고 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 쿠키를 읽을 때. &lt;code&gt;=&lt;/code&gt; 는 쿠키 값에서 유효한 문자가 아니므로 패딩을 비활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0b75f4c0b3e543c026233950dd58d233dabc0916" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, etc, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">쿠키 값은 자동으로 이스케이프되지 않습니다. 따라서 쉼표, 따옴표 등으로 값을 저장하려면 명시 적으로 이스케이프하거나 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 및 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 와 같은 함수를 사용해야합니다 . 쿠키를 읽을 때. &lt;code&gt;=&lt;/code&gt; 는 쿠키 값에서 유효한 문자가 아니므로 패딩을 비활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc170b7df02149d4f1b41d395782c4bf6a42233e" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues</source>
          <target state="translated">쿠키 헤더로 전송 될 쿠키 값입니다. 보안 문제를 피하려면이 값을 base64로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ed8e930bd798b7f59e1b3906dae0c5ae18ae5f5" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues.</source>
          <target state="translated">쿠키 헤더로 전송 될 쿠키 값입니다. 보안 문제를 피하려면이 값을 base64로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e2028fc8c0e6e2d2a17c2988205cfc1a48f5c7d" translate="yes" xml:space="preserve">
          <source>The core of this action is &lt;code&gt;render(conn, &quot;index.html&quot;)&lt;/code&gt;. It tells Phoenix to render &quot;index.html&quot;. The modules responsible for rendering are views. By default, Phoenix views are named after the controller, so Phoenix is expecting a &lt;code&gt;HelloWeb.HelloView&lt;/code&gt; to exist and handle &quot;index.html&quot; for us.</source>
          <target state="translated">이 액션의 핵심은 &lt;code&gt;render(conn, &quot;index.html&quot;)&lt;/code&gt; 입니다. Phoenix에게 &quot;index.html&quot;을 렌더링하도록 지시합니다. 렌더링을 담당하는 모듈은 뷰입니다. 기본적으로 Phoenix 뷰는 컨트롤러의 이름을 따서 명명되므로 Phoenix는 &lt;code&gt;HelloWeb.HelloView&lt;/code&gt; 가 존재하고 &quot;index.html&quot;을 처리 할 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="0fdf691245b570b56fac13fe863e01499ed9c09b" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shut down and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">현재 LiveView가 종료되고 전체 페이지를 다시로드하지 않고 새 LiveView가 그 자리에 마운트됩니다. 새로 시작하려는 경우 동일한 LiveView를 다시 마운트하는데도 사용할 수 있습니다. 다시 마운트하지 않고 동일한 LiveView로 이동하려면 대신 &lt;a href=&quot;#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0cdcbf70ae3305c8dd93ccd61f868d5e436588" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shutdown and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">현재 LiveView가 종료되고 전체 페이지를 다시로드하지 않고 새 LiveView가 그 자리에 마운트됩니다. 새로 시작하려는 경우 동일한 LiveView를 다시 마운트하는데도 사용할 수 있습니다. 다시 마운트하지 않고 동일한 LiveView로 이동하려면 대신 &lt;a href=&quot;#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b9b1fd62f16ed364400554fa3c072cfdd758b718" translate="yes" xml:space="preserve">
          <source>The current action will always be available inside the LiveView as the &lt;code&gt;@live_action&lt;/code&gt; assign, that can be used to render a LiveComponent:</source>
          <target state="translated">현재 작업은 &lt;code&gt;@live_action&lt;/code&gt; 를 렌더링하는 데 사용할 수있는 @live_action 할당으로 LiveView 내에서 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e46ad87d3469e7e9f3187e46155cee02aaf64d" translate="yes" xml:space="preserve">
          <source>The current schema belongs to zero or one records of the other schema. The other schema often has a &lt;code&gt;has_one&lt;/code&gt; or a &lt;code&gt;has_many&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">현재 스키마는 다른 스키마의 0 개 또는 하나의 레코드에 속합니다. 다른 스키마에는 종종 역 연관 이있는 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f668c1bd4c3e820e33a15f5f380f812917f51d" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</source>
          <target state="translated">현재 스키마에는 그 안에 포함 된 다른 스키마에 대한 레코드가 0 개 이상 있습니다. 임베드에는 일반 스키마의 모든 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb6532e1cfbc40c65e0d70c093c2d84b8c13c97c" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">현재 스키마에는 다른 스키마에 대한 레코드가 0 개 이상 있습니다. 다른 스키마에는 종종 역방향 연관 이있는 &lt;code&gt;belongs_to&lt;/code&gt; 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2400e9bff3b3fcf167090fc4f9675aa1dafa03a" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the &lt;code&gt;:map&lt;/code&gt; type for storage, but allows embeds to have all the things regular schema can.</source>
          <target state="translated">현재 스키마에는 그 안에 포함 된 다른 스키마의 레코드가 없거나 하나 있습니다. 저장 을 위해 &lt;code&gt;:map&lt;/code&gt; 유형 과 유사한 필드를 사용 하지만 임베드는 일반 스키마가 할 수있는 모든 것을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="543e48ecf9a036c8c3265d90420f7f54855d1f07" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">현재 스키마에는 다른 스키마에 대한 레코드가 없거나 하나 있습니다. 다른 스키마에는 종종 역방향 연관 이있는 &lt;code&gt;belongs_to&lt;/code&gt; 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89c1ce17f89437f89ff113dd237432b1779e13f" translate="yes" xml:space="preserve">
          <source>The current time in UTC is retrieved from Elixir and not from the database.</source>
          <target state="translated">UTC가 아닌 현재 시간은 데이터베이스가 아닌 Elixir에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="b052c5d0d8705bd378272066bfc771be8f95160c" translate="yes" xml:space="preserve">
          <source>The data is stored in ETS in the following format:</source>
          <target state="translated">데이터는 다음 형식으로 ETS에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1acda630ba32f073701a386f5cfe162756e7c372" translate="yes" xml:space="preserve">
          <source>The data stored in the token is signed to prevent tampering but not encrypted. This means it is safe to store identification information (such as user IDs) but should not be used to store confidential information (such as credit card numbers).</source>
          <target state="translated">토큰에 저장된 데이터는 변조는 방지하지만 암호화되지는 않도록 서명됩니다. 이는 식별 정보 (예 : 사용자 ID)를 저장하는 것이 안전하지만 기밀 정보 (예 : 신용 카드 번호)를 저장하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d8e9c428788f4e316259dfd396beb63eed3450" translate="yes" xml:space="preserve">
          <source>The data world is your oyster, but we won't be covering these options in these guides.</source>
          <target state="translated">데이터 세계는 당신의 굴이지만이 가이드에서는 이러한 옵션을 다루지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9e3f4c1170977052f6619c9eadd4414d82a1869" translate="yes" xml:space="preserve">
          <source>The database for HelloPhoenix.repo has been created. We're also ready to run any migrations, or do anything else with Ecto that we might choose.</source>
          <target state="translated">HelloPhoenix.repo에 대한 데이터베이스가 생성되었습니다. 또한 마이그레이션을 실행하거나 Ecto로 선택할 수있는 다른 작업을 수행 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="25b03cf10e6fc6af894d1777f43a9e4564e801a7" translate="yes" xml:space="preserve">
          <source>The datetime types</source>
          <target state="translated">날짜 / 시간 유형</target>
        </trans-unit>
        <trans-unit id="57585ba4de2b044b0be68355ad35a6afa2297af3" translate="yes" xml:space="preserve">
          <source>The debug state uses the browser's built-in &lt;code&gt;sessionStorage&lt;/code&gt;, so it will remain in effect for as long as your browser session lasts.</source>
          <target state="translated">디버그 상태는 브라우저의 내장 &lt;code&gt;sessionStorage&lt;/code&gt; 를 사용하므로 브라우저 세션이 지속되는 동안 계속 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d91240847c4c0b4e5c86209a80fab1b682a0b72d" translate="yes" xml:space="preserve">
          <source>The default Endpoint plugs do quite a lot of work. Here they are in order:</source>
          <target state="translated">기본 엔드 포인트 플러그는 많은 작업을 수행합니다. 여기에 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d063536b5fd16a46117b63d1178dfcad16b720" translate="yes" xml:space="preserve">
          <source>The default HTML encoder that ships with Phoenix.</source>
          <target state="translated">Phoenix와 함께 제공되는 기본 HTML 인코더입니다.</target>
        </trans-unit>
        <trans-unit id="b6a5014904611a0144837aa761a0d9c7ac17de4a" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection</source>
          <target state="translated">연결에 아무것도 설정되지 않은 경우 기본 형식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb15ee34b6e76bea7879309e5d7b64c6bf0dee90" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection.</source>
          <target state="translated">연결에 아무것도 설정되어 있지 않으면 기본 형식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="565d3288130af0242285fb747529bfd66f40c7d5" translate="yes" xml:space="preserve">
          <source>The default implementation simply passes &lt;code&gt;presences&lt;/code&gt; through unchanged.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;presences&lt;/code&gt; 를 변경되지 않은 상태로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="6676a691528a06988caceda0bdea8ffb85ace6e8" translate="yes" xml:space="preserve">
          <source>The default option can be given to populate the fields if none is given:</source>
          <target state="translated">필드가 없으면 기본 옵션으로 필드를 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c66e666e4d64f7851485bf4d02d2f008e867eb1" translate="yes" xml:space="preserve">
          <source>The default router is inflected from the application name unless a configuration named &lt;code&gt;:namespace&lt;/code&gt; is set inside your application configuration. For example, the configuration:</source>
          <target state="translated">응용 프로그램 구성 내에 &lt;code&gt;:namespace&lt;/code&gt; 라는 구성 이 설정되어 있지 않으면 기본 라우터는 응용 프로그램 이름에서 영향을받습니다 . 예를 들어 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bef1bc8ef401a761e7d8eba7f4227945005b964c" translate="yes" xml:space="preserve">
          <source>The definition of basic custom types and all of its callbacks is available in this module. You can learn more about parameterized types in &lt;a href=&quot;ecto.parameterizedtype&quot;&gt;&lt;code&gt;Ecto.ParameterizedType&lt;/code&gt;&lt;/a&gt;. If in doubt, prefer to use basic custom types and rely on parameterized types if you need the extra functionality.</source>
          <target state="translated">기본 사용자 정의 유형 및 모든 콜백에 대한 정의는이 모듈에서 사용할 수 있습니다. &lt;a href=&quot;ecto.parameterizedtype&quot;&gt; &lt;code&gt;Ecto.ParameterizedType&lt;/code&gt; &lt;/a&gt; 에서 매개 변수화 된 유형에 대해 자세히 알아볼 수 있습니다 . 확실하지 않은 경우 기본 사용자 지정 형식을 사용하고 추가 기능이 필요한 경우 매개 변수가있는 형식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c9bea1b5faf766b56d93add1c5f07efe92cf9dfa" translate="yes" xml:space="preserve">
          <source>The difference between them is that most validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database. Some validations may happen against the database but they are inherently unsafe. Those validations start with a &lt;code&gt;unsafe_&lt;/code&gt; prefix, such as &lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt;&lt;code&gt;unsafe_validate_unique/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차이점은 대부분의 유효성 검사는 데이터베이스와 상호 작용할 필요없이 실행될 수 있으므로 데이터베이스에 항목을 삽입하거나 업데이트하기 전에 항상 실행된다는 것입니다. 일부 유효성 검사는 데이터베이스에 대해 발생할 수 있지만 본질적으로 안전하지 않습니다. 이러한 유효성 검증 은 &lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt; &lt;code&gt;unsafe_validate_unique/3&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;code&gt;unsafe_&lt;/code&gt; 접두어로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="b905a6abee1408a861b937e78adce0825322527a" translate="yes" xml:space="preserve">
          <source>The dispatcher must be available on all nodes running the PubSub system. The &lt;code&gt;dispatch/3&lt;/code&gt; function of the given module will be invoked with the subscriptions entries, the broadcaster identifier (either a pid or &lt;code&gt;:none&lt;/code&gt;), and the message to broadcast.</source>
          <target state="translated">디스패처는 PubSub 시스템을 실행하는 모든 노드에서 사용할 수 있어야합니다. 주어진 모듈 의 &lt;code&gt;dispatch/3&lt;/code&gt; 함수는 구독 항목, 브로드 캐스터 식별자 (pid 또는 &lt;code&gt;:none&lt;/code&gt; ) 및 브로드 캐스트 할 메시지와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="90a466df0e05cd07db8216347664891ea2d6f388" translate="yes" xml:space="preserve">
          <source>The distinction whether to insert or update will be made on the &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; field &lt;code&gt;:state&lt;/code&gt;. The &lt;code&gt;:state&lt;/code&gt; is automatically set by Ecto when loading or building a schema.</source>
          <target state="translated">삽입 또는 업데이트 여부는 &lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt; 필드 &lt;code&gt;:state&lt;/code&gt; 에서 구분 됩니다. &lt;code&gt;:state&lt;/code&gt; 로드 또는 스키마를 만들 때 자동으로 체외에 의해 설정된다.</target>
        </trans-unit>
        <trans-unit id="98110b4f952a325165904e437acdb05dceca3afb" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &quot;content-disposition&quot; to attachment. The &quot;content-type&quot; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="translated">다운로드는 &quot;content-disposition&quot;을 첨부 파일로 설정하여 수행됩니다. &quot;content-type&quot;도 주어진 파일 이름의 확장자를 기반으로 설정되지만 &lt;code&gt;:content_type&lt;/code&gt; 및 &lt;code&gt;:charset&lt;/code&gt; 옵션을 통해 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bea122452a37ef030f627235ed1844a3ddfe593" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &amp;ldquo;content-disposition&amp;rdquo; to attachment. The &amp;ldquo;content-type&amp;rdquo; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="translated">&amp;ldquo;content-disposition&amp;rdquo;을 첨부 파일로 설정하여 다운로드 할 수 있습니다. &quot;content-type&quot;은 주어진 파일 이름의 확장자를 기반으로 설정되지만 &lt;code&gt;:content_type&lt;/code&gt; 및 &lt;code&gt;:charset&lt;/code&gt; 옵션을 통해 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305f411cb067461e7008b3366143db8315830828" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="translated">임베디드에는 기본 키가 있거나 없을 수 있습니다. Ecto는 기본 키를 사용하여 포함이 업데이트되는지 여부를 감지합니다. 기본이없고 임베드 목록을 계속 업데이트 하려면 &lt;code&gt;:on_replace&lt;/code&gt; 를 &lt;code&gt;:delete&lt;/code&gt; 로 설정해야 새 임베드 목록이 설정 될 때마다 현재 임베드가 모두 삭제되고 새 임베드로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9851fea47b9bbc161a06c36308d9e5222d41ca5d" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="translated">임베디드에는 기본 키가 있거나 없을 수 있습니다. Ecto는 기본 키를 사용하여 포함이 업데이트되는지 여부를 감지합니다. 기본이 없으면 새 내장이 설정 될 때 현재 내장을 업데이트하거나 삭제하려는 경우 &lt;code&gt;:on_replace&lt;/code&gt; 를 &lt;code&gt;:update&lt;/code&gt; 또는 &lt;code&gt;:delete&lt;/code&gt; 로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1949ed7b2d6dffd9e7c7748d7bd6bc3abd5dcf0c" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="translated">임베디드에는 기본 키가있을 수도 있고 없을 수도 있습니다. Ecto는 기본 키를 사용하여 임베드가 업데이트 중인지 여부를 감지합니다. 기본이없고 삽입 목록을 계속 업데이트 하려면 &lt;code&gt;:on_replace&lt;/code&gt; 를 &lt;code&gt;:delete&lt;/code&gt; 로 설정해야합니다 . 그러면 새 삽입 목록이 설정 될 때마다 모든 현재 삽입이 삭제되고 새 삽입으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="af9a17476a78a7a92bdf8fb962890959f1ad1049" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary key is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="translated">임베디드에는 기본 키가있을 수도 있고 없을 수도 있습니다. Ecto는 기본 키를 사용하여 임베드가 업데이트 중인지 여부를 감지합니다. 기본 키가없는 경우, 새 항목이 설정 될 때 현재 포함을 업데이트하거나 삭제하려는 경우 &lt;code&gt;:on_replace&lt;/code&gt; 를 &lt;code&gt;:update&lt;/code&gt; 또는 &lt;code&gt;:delete&lt;/code&gt; 로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="240ba5b0f9226d65d40a221b0aaca6577ac67121" translate="yes" xml:space="preserve">
          <source>The encoding of server data and the decoding of client data is done according to a serializer, defined in &lt;a href=&quot;phoenix.socket.serializer&quot;&gt;&lt;code&gt;Phoenix.Socket.Serializer&lt;/code&gt;&lt;/a&gt;. By default, JSON encoding is used to broker messages to and from clients with &lt;code&gt;Phoenix.Socket.V2.JSONSerializer&lt;/code&gt;.</source>
          <target state="translated">서버 데이터 인코딩 및 클라이언트 데이터 디코딩은 &lt;a href=&quot;phoenix.socket.serializer&quot;&gt; &lt;code&gt;Phoenix.Socket.Serializer&lt;/code&gt; 에&lt;/a&gt; 정의 된 직렬 변환기에 따라 수행됩니다 . 기본적으로 JSON 인코딩은 &lt;code&gt;Phoenix.Socket.V2.JSONSerializer&lt;/code&gt; 를 사용하여 클라이언트와의 메시지를 중개하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffc586997cb9ff4e598fbaf2d150c17e623488e6" translate="yes" xml:space="preserve">
          <source>The endpoint being tested is accessed via the &lt;code&gt;@endpoint&lt;/code&gt; module attribute.</source>
          <target state="translated">테스트중인 엔드 포인트는 &lt;code&gt;@endpoint&lt;/code&gt; 모듈 속성을 통해 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="1085ea34a986c448fabcc15a67e4b94b2cb117ef" translate="yes" xml:space="preserve">
          <source>The endpoint is the boundary where all requests to your web application start. It is also the interface your application provides to the underlying web servers.</source>
          <target state="translated">엔드 포인트는 웹 애플리케이션에 대한 모든 요청이 시작되는 경계입니다. 또한 응용 프로그램이 기본 웹 서버에 제공하는 인터페이스이기도합니다.</target>
        </trans-unit>
        <trans-unit id="74811601480966246292b2b910ca967ac18caf00" translate="yes" xml:space="preserve">
          <source>The endpoint, router, and controllers in Phoenix accept plugs.</source>
          <target state="translated">Phoenix의 엔드 포인트, 라우터 및 컨트롤러는 플러그를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a71e0101c0d6d0c31084c2c74654c8ab5ada1e0f" translate="yes" xml:space="preserve">
          <source>The entry point for defining forms in Phoenix is with the &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt; function. For this example, we will use &lt;code&gt;Ecto.Changeset&lt;/code&gt;, which integrates nicely with Phoenix forms via the &lt;code&gt;phoenix_ecto&lt;/code&gt; package.</source>
          <target state="translated">Phoenix에서 양식을 정의하기위한 시작점은 &lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; 함수입니다. 이 예에서는 &lt;code&gt;phoenix_ecto&lt;/code&gt; 패키지 를 통해 Phoenix 양식과 잘 통합되는 &lt;code&gt;Ecto.Changeset&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="04c6d1a307f90ddcd28dacda1e19147d95f5924b" translate="yes" xml:space="preserve">
          <source>The event callback is called &lt;em&gt;before&lt;/em&gt; the event happens (in this case, before the view is rendered) with the atom &lt;code&gt;:start&lt;/code&gt; as the first argument; see the &amp;ldquo;Before clause&amp;rdquo; section below.</source>
          <target state="translated">이벤트 콜백은 이벤트가 발생 &lt;em&gt;하기 전에&lt;/em&gt; (이 경우 뷰가 렌더링되기 전에) atom &lt;code&gt;:start&lt;/code&gt; 를 첫 번째 인수로 사용하여 호출됩니다. 아래의 &quot;전 조항&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="757e085e21ddd74789de7bdb0bbe8f07bed88c4b" translate="yes" xml:space="preserve">
          <source>The event callback sequence is:</source>
          <target state="translated">이벤트 콜백 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8146ea0120720d389e5e641e32fe81e0949316e4" translate="yes" xml:space="preserve">
          <source>The event occurs (in this case, the view is rendered).</source>
          <target state="translated">이벤트가 발생합니다 (이 경우 뷰가 렌더링 됨).</target>
        </trans-unit>
        <trans-unit id="ae116b624d5b59052eb64f10c8d76ec7dd431042" translate="yes" xml:space="preserve">
          <source>The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">이벤트 메시지는 직렬화 가능한 맵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="59c29c61995ac6adc27d72e58769a2befdbcb1f2" translate="yes" xml:space="preserve">
          <source>The event's message must be a serializable map.</source>
          <target state="translated">이벤트의 메시지는 직렬화 가능한 맵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6f8e9a757d63677055c9099b13a0e178eebb865" translate="yes" xml:space="preserve">
          <source>The example above does not use &lt;code&gt;in&lt;/code&gt; because &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; do not require a reference to the data source. However, extending the query with a where expression would require the use of &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">위의 예에서는 사용하지 않는 &lt;code&gt;in&lt;/code&gt; 인해 &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 데이터 소스에 대한 참조를 필요로하지 않는다. 그러나 where 표현식으로 쿼리를 확장하려면 &lt;code&gt;in&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2a68a419c4788a627e1c523a21aa9c289200ba77" translate="yes" xml:space="preserve">
          <source>The example above renders a template &quot;show.html&quot; from the &lt;code&gt;MyAppWeb.UserView&lt;/code&gt; and sets the response content type to &quot;text/html&quot;.</source>
          <target state="translated">위의 예제는 &lt;code&gt;MyAppWeb.UserView&lt;/code&gt; 에서 &quot;show.html&quot;템플릿을 렌더링 하고 응답 콘텐츠 유형을 &quot;text / html&quot;로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="323718568a794b79b80b9c7f90d47fc0dddb0e78" translate="yes" xml:space="preserve">
          <source>The example above renders a template &amp;ldquo;show.html&amp;rdquo; from the &lt;code&gt;MyApp.UserView&lt;/code&gt; and sets the response content type to &amp;ldquo;text/html&amp;rdquo;.</source>
          <target state="translated">위의 예제는 &lt;code&gt;MyApp.UserView&lt;/code&gt; 에서 &quot;show.html&quot;템플릿을 렌더링 하고 응답 내용 유형을 &quot;text / html&quot;로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="263bcd680d02d0dedd523e55597569bfc7eb4085" translate="yes" xml:space="preserve">
          <source>The example above will fetch all posts from the database and then do a separate query returning all comments associated with the given posts. The comments are then processed and associated to each returned &lt;code&gt;post&lt;/code&gt; under the &lt;code&gt;comments&lt;/code&gt; field.</source>
          <target state="translated">위의 예는 데이터베이스에서 모든 게시물을 가져오고 지정된 게시물과 관련된 모든 의견을 반환하는 별도의 쿼리를 수행합니다. 그런 다음 주석이 처리되고 &lt;code&gt;comments&lt;/code&gt; 필드 아래에 반환 된 각 &lt;code&gt;post&lt;/code&gt; 에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="b71e88e7ed588cf8386d56a8b902c449be09cbf4" translate="yes" xml:space="preserve">
          <source>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by &lt;code&gt;published_at&lt;/code&gt;.</source>
          <target state="translated">위의 예제는 두 개의 쿼리를 발행합니다. 하나는 게시물을로드하고 다른 하나는 게시물과 관련된 주석을로드합니다. 댓글에 의해 정렬됩니다 &lt;code&gt;published_at&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924e9a6b17eb83d28266379ce64871ee77dfc336" translate="yes" xml:space="preserve">
          <source>The example above will work if the input query has 1 or 10 bindings. As long as the number of bindings is less than the number of from + joins, Ecto will match only what you have specified. The first binding always matches the source given in &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">입력 쿼리에 1 또는 10 개의 바인딩이있는 경우 위의 예제가 작동합니다. 바인딩 수가 from + join 수보다 작은 한 Ecto는 지정한 내용 만 일치합니다. 첫 번째 바인딩은 항상 &lt;code&gt;from&lt;/code&gt; 제공된 소스와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="597f52cde33ea3d40cd216eeff98f0f27574f4d6" translate="yes" xml:space="preserve">
          <source>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">제외 제약 조건은 데이터베이스를 사용하여 제외 제약 조건을 위반했는지 여부를 확인하고 해당하는 경우 Ecto에서이를 변경 집합 오류로 변환함으로써 작동합니다.</target>
        </trans-unit>
        <trans-unit id="77dfbd136a0c7b400c0e6cf8e244d45dcfb4c0ae" translate="yes" xml:space="preserve">
          <source>The field name will be used as is to read and write to the database by all of the built-in adapters unless overridden with the &lt;code&gt;:source&lt;/code&gt; option.</source>
          <target state="translated">필드 이름은 &lt;code&gt;:source&lt;/code&gt; 옵션으로 대체되지 않는 한 모든 내장 어댑터가 데이터베이스를 읽고 쓰는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="28d67d8abd4a4854029b14119fba01291b055159" translate="yes" xml:space="preserve">
          <source>The fields are:</source>
          <target state="translated">필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23e99979ef97808c907b0384c23bb476163e1c89" translate="yes" xml:space="preserve">
          <source>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</source>
          <target state="translated">이 매크로에 의해 생성 된 필드는 리포지토리에 값을 삽입하고 업데이트 할 때 현재 시간으로 자동 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a7c7070bdd1da6f37c5437d705a4f71db3064c" translate="yes" xml:space="preserve">
          <source>The first argument can also be a &lt;code&gt;types&lt;/code&gt; map:</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;types&lt;/code&gt; 맵일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49bed0abeb1db58200a4ef0db4c5da86c91aa45c" translate="yes" xml:space="preserve">
          <source>The first argument can be a a schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="translated">첫 번째 인수는 스키마 모듈 또는 맵 (유형) 일 수 있으며 반환 값을 결정합니다 (구조체 또는 맵).</target>
        </trans-unit>
        <trans-unit id="ec0251c98fcdc3180f663f2d434e28c1ff287694" translate="yes" xml:space="preserve">
          <source>The first argument can be a an embedded schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="translated">첫 번째 인수는 포함 된 스키마 모듈 또는 맵 (유형) 일 수 있으며 반환 값 (각각 구조체 또는 맵)을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="500f8521003b9bf543828ad835d40f5eeb6af0a7" translate="yes" xml:space="preserve">
          <source>The first argument is a &lt;code&gt;datetime&lt;/code&gt;, the second one is the count for the interval, which may be either positive or negative and the interval value:</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;datetime&lt;/code&gt; 이고 두 번째 인수는 간격의 개수이며 양수 또는 음수 일 수 있으며 간격 값입니다.</target>
        </trans-unit>
        <trans-unit id="c0e54dc181af943e0b3cceca923e134cbcf1e0c6" translate="yes" xml:space="preserve">
          <source>The first argument is the context module followed by the schema module and its plural name (used as the schema table name).</source>
          <target state="translated">첫 번째 인수는 컨텍스트 모듈 다음에 스키마 모듈과 복수 이름 (스키마 테이블 이름으로 사용됨)이옵니다.</target>
        </trans-unit>
        <trans-unit id="4865c8fae49bc4316a74325ea7181643af770fb4" translate="yes" xml:space="preserve">
          <source>The first argument is the context the callback is being invoked. If it is called because the Repo supervisor is starting, it will be &lt;code&gt;:supervisor&lt;/code&gt;. It will be &lt;code&gt;:runtime&lt;/code&gt; if it is called for reading configuration without actually starting a process.</source>
          <target state="translated">첫 번째 인수는 콜백이 호출되는 컨텍스트입니다. Repo 수퍼바이저가 시작되어 호출 된 경우 &lt;code&gt;:supervisor&lt;/code&gt; 입니다. 그것은 될 것입니다 &lt;code&gt;:runtime&lt;/code&gt; 이 실제로 프로세스를 시작하지 않고 구성을 읽어라고합니다.</target>
        </trans-unit>
        <trans-unit id="abeed1d3f6ef43117d9c456048712438c831279a" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for resources and schema).</source>
          <target state="translated">첫 번째 인수는 모듈 이름 다음에 복수 이름 (자원 및 스키마에 사용)입니다.</target>
        </trans-unit>
        <trans-unit id="964c9cb93e956fb751ffeb1617eb35e4e1dd5ef8" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for the schema).</source>
          <target state="translated">첫 번째 인수는 모듈 이름 뒤에 복수 이름 (스키마에 사용됨)이옵니다.</target>
        </trans-unit>
        <trans-unit id="35f70a15e0108aa4e4b74899ee54723e2a713861" translate="yes" xml:space="preserve">
          <source>The first argument is the path where the static files are located. The &lt;code&gt;-o&lt;/code&gt; option indicates the path that will be used to save the digested and compressed files.</source>
          <target state="translated">첫 번째 인수는 정적 파일이있는 경로입니다. &lt;code&gt;-o&lt;/code&gt; 옵션은 요약 및 압축 파일을 저장하는 데 사용될 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fe4f44a0f785ff10de251522a37c07e0b5ab7bb" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by its plural name (used as the table name).</source>
          <target state="translated">첫 번째 인수는 스키마 모듈 뒤에 복수 이름 (테이블 이름으로 사용)이옵니다.</target>
        </trans-unit>
        <trans-unit id="e4b02077d7ac802cfee0627d193ca5cd0a9be149" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes</source>
          <target state="translated">첫 번째 인수는 스키마 모듈 다음에 스키마 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d11a276567643357f029e74ffc86b05f8be866b2" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes.</source>
          <target state="translated">첫 번째 인수는 스키마 모듈과 그 뒤에 오는 스키마 속성입니다.</target>
        </trans-unit>
        <trans-unit id="85394c0d9cf1f3bd97ab6925f698c432e75e0ba3" translate="yes" xml:space="preserve">
          <source>The first argument should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">첫 번째 인자 중 하나이어야 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; 방출 &lt;code&gt;form_for&lt;/code&gt; 또는 원자이다.</target>
        </trans-unit>
        <trans-unit id="4d5565085e0846e63bdeb7de3b6914b3e5d53f51" translate="yes" xml:space="preserve">
          <source>The first argument to both &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; can be one of:</source>
          <target state="translated">&lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; 에&lt;/a&gt; 대한 첫 번째 인수 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49a3d210dbcdc92bf9475253ce66aa64aa7725b" translate="yes" xml:space="preserve">
          <source>The first field name, &lt;code&gt;:email&lt;/code&gt; in this case, will be used as the error key to the changeset errors keyword list. For example, the above &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; would generate something like:</source>
          <target state="translated">첫 번째 필드 이름 인 &lt;code&gt;:email&lt;/code&gt; 은이 경우 변경 집합 오류 키워드 목록의 오류 키로 사용됩니다. 예를 들어, 위의 &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 것을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="14c98ababa7076deb4b23e215e725e5dcc321dec" translate="yes" xml:space="preserve">
          <source>The first line below the module definition invokes the &lt;code&gt;__using__/1&lt;/code&gt; macro of the &lt;code&gt;HelloWeb&lt;/code&gt; module, which imports some useful modules.</source>
          <target state="translated">모듈 정의 아래의 첫 번째 줄은 몇 가지 유용한 모듈을 가져 오는 &lt;code&gt;HelloWeb&lt;/code&gt; 모듈 의 &lt;code&gt;__using__/1&lt;/code&gt; 매크로를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="79d9874d0b09b5d634a9bffe5a01fb056e0e669b" translate="yes" xml:space="preserve">
          <source>The first line of this module, &lt;code&gt;use HelloWeb, :router&lt;/code&gt;, simply makes Phoenix router functions available in our particular router.</source>
          <target state="translated">이 모듈의 첫 번째 &lt;code&gt;use HelloWeb, :router&lt;/code&gt; 를 사용하면 특정 라우터에서 Phoenix 라우터 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b536e4964b55b3a608e3b733d3258cc0956029a" translate="yes" xml:space="preserve">
          <source>The first parameter is always &lt;code&gt;conn&lt;/code&gt;, a struct which holds information about the request such as the host, path elements, port, query string, and much more. &lt;code&gt;conn&lt;/code&gt;, comes to Phoenix via Elixir's Plug middleware framework. More detailed info about &lt;code&gt;conn&lt;/code&gt; can be found in &lt;a href=&quot;../plug/plug.conn&quot;&gt;plug's documentation&lt;/a&gt;.</source>
          <target state="translated">첫 번째 매개 변수는 항상 &lt;code&gt;conn&lt;/code&gt; , 호스트, 경로 요소, 포트, 쿼리 문자열 등과 같은 요청에 대한 정보를 보유하는 구조체입니다. &lt;code&gt;conn&lt;/code&gt; 은 Elixir의 Plug 미들웨어 프레임 워크를 통해 Phoenix에 제공됩니다. &lt;code&gt;conn&lt;/code&gt; 에 대한 자세한 정보 는 &lt;a href=&quot;../plug/plug.conn&quot;&gt;plug의 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb52f0181ac504af2d274804ae227768df1b3b4" translate="yes" xml:space="preserve">
          <source>The first plug will run only when action is show or edit. The second plug will always run, except for the index action.</source>
          <target state="translated">첫 번째 플러그는 동작이 표시되거나 편집 될 때만 실행됩니다. 인덱스 작업을 제외하고 두 번째 플러그는 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a085c723aa2725f1a835b9fa686c2f8a3dbb9f" translate="yes" xml:space="preserve">
          <source>The first question is, where does that error string come from? The answer is right in the &lt;code&gt;ErrorView&lt;/code&gt;.</source>
          <target state="translated">첫 번째 질문은 오류 문자열의 출처입니다. 대답은 &lt;code&gt;ErrorView&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="87cb90ded997365e136d73bbbbeaa6912dce9a57" translate="yes" xml:space="preserve">
          <source>The first step is to start the adapter of choice in your supervision tree:</source>
          <target state="translated">첫 번째 단계는 감독 트리에서 선택한 어댑터를 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce8e7b83d95aab3d7102e7f0e03f87b4868c2329" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is create a &lt;code&gt;mix/tasks&lt;/code&gt; directory inside of &lt;code&gt;lib&lt;/code&gt;. This is where any of our application specific mix tasks will go.</source>
          <target state="translated">가장 먼저해야 할 일은 &lt;code&gt;lib&lt;/code&gt; 안에 &lt;code&gt;mix/tasks&lt;/code&gt; 디렉토리를 만드는 것 입니다. 이것은 우리의 응용 프로그램 특정 혼합 작업이 진행되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="e521b29a1418c4c03c1262013a47617e674a9abe" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is name our module. All tasks must be defined in &lt;code&gt;Mix.Tasks&lt;/code&gt; namespace. We'd like to invoke this as &lt;code&gt;mix hello.greeting&lt;/code&gt;, so we complete the module name with &lt;code&gt;Hello.Greeting&lt;/code&gt;.</source>
          <target state="translated">가장 먼저해야 할 일은 모듈의 이름을 지정하는 것입니다. 모든 작업은 &lt;code&gt;Mix.Tasks&lt;/code&gt; 네임 스페이스에 정의되어야합니다 . 이것을 &lt;code&gt;mix hello.greeting&lt;/code&gt; 으로 호출 하고 &lt;code&gt;Hello.Greeting&lt;/code&gt; 모듈 이름을 완성 합니다.</target>
        </trans-unit>
        <trans-unit id="29f463e217a7cb3a4cb33031b1d1ba5fe4bbd808" translate="yes" xml:space="preserve">
          <source>The first thing we need to do to create that page is define a route for it. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; in a text editor. For a brand new application, it looks like this:</source>
          <target state="translated">해당 페이지를 생성하기 위해 가장 먼저해야 할 일은 해당 페이지에 대한 경로를 정의하는 것입니다. 텍스트 편집기에서 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 를 엽니 다 . 새로운 애플리케이션의 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8101d8208169439cea8beb089d2fd5b7d5aeff5" translate="yes" xml:space="preserve">
          <source>The flash functionality is handy when mixed with redirects. Perhaps you want to redirect to a page with some extra information. If we re-use the redirect action from the previous section, we can do:</source>
          <target state="translated">플래시 기능은 리디렉션과 함께 사용하면 편리합니다. 추가 정보가있는 페이지로 리디렉션하고 싶을 수 있습니다. 이전 섹션의 리디렉션 작업을 다시 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23dbc44cf8fcb8401ecac56fad2056f3e27fd632" translate="yes" xml:space="preserve">
          <source>The following approach is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">다음과 같은 접근 방식이 &lt;strong&gt;잘못되었습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="27f0532927f5dfde2ed38eb7adc999b8682a2ebd" translate="yes" xml:space="preserve">
          <source>The following assigns are reserved, and cannot be set directly:</source>
          <target state="translated">다음 할당은 예약되어 있으며 직접 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96a9598d7d5639506795473ffa8dad0e7b28cb27" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:longpoll&lt;/code&gt;:</source>
          <target state="translated">다음 구성은 &lt;code&gt;:longpoll&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c9626abcad38b5d2ad7be4a47ee7034e64d5860" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:websocket&lt;/code&gt;.</source>
          <target state="translated">다음 구성은 &lt;code&gt;:websocket&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="13779d40c7bd0138f604faeb9ae943fd9630bdfd" translate="yes" xml:space="preserve">
          <source>The following events are emitted by all Ecto repositories:</source>
          <target state="translated">다음 이벤트는 모든 Ecto 리포지토리에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="697b7462029e6e23c15a3021022337813a16f040" translate="yes" xml:space="preserve">
          <source>The following fields are private and must not be accessed directly.</source>
          <target state="translated">다음 필드는 개인용이며 직접 액세스하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="baaf66ee23187b5f5ad09e6055f8ea194c2622bf" translate="yes" xml:space="preserve">
          <source>The following function lifts &lt;code&gt;metadata.socket.view&lt;/code&gt; and &lt;code&gt;metadata.socket.connected?&lt;/code&gt; to be top-level keys on &lt;code&gt;metadata&lt;/code&gt;, as we did in the previous example.</source>
          <target state="translated">다음 함수는 &lt;code&gt;metadata.socket.view&lt;/code&gt; 및 &lt;code&gt;metadata.socket.connected?&lt;/code&gt; 이전 예에서했던 것처럼 &lt;code&gt;metadata&lt;/code&gt; 최상위 키가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b34d9298df0cbb61838280284087d26545c45a26" translate="yes" xml:space="preserve">
          <source>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</source>
          <target state="translated">다음 간격이 지원됩니다 : 년, 월, 주, 일,시, 분, 초, 밀리 초 및 마이크로 초.</target>
        </trans-unit>
        <trans-unit id="1ff93af922ef6535f32352b2b639755a01dafeb3" translate="yes" xml:space="preserve">
          <source>The following keys are allowed when specifying a window.</source>
          <target state="translated">창을 지정할 때 다음 키가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="59c9c3a965c72c26e14a2014331e87cf4bda5729" translate="yes" xml:space="preserve">
          <source>The following keys are available:</source>
          <target state="translated">사용 가능한 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdd2468c439eb11013c816be656d524ad7f23e6f" translate="yes" xml:space="preserve">
          <source>The following params have special meaning in LiveView:</source>
          <target state="translated">다음 매개 변수는 LiveView에서 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="aebca73a523dda1e7ab387256d00be6cee49a026" translate="yes" xml:space="preserve">
          <source>The following public fields represent the LiveView:</source>
          <target state="translated">다음 공용 필드는 LiveView를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a77ca9c2bc454b722bf0d3007090b822823c3ad6" translate="yes" xml:space="preserve">
          <source>The following public fields represent the element:</source>
          <target state="translated">다음 공용 필드는 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71d94986edc28d20eb6e61b59ed0d6b150611abc" translate="yes" xml:space="preserve">
          <source>The following returns must be handled by transports:</source>
          <target state="translated">다음 반품은 운송으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc0e8fdffd8fa1f0de767e3b482f423a5a285a50" translate="yes" xml:space="preserve">
          <source>The following specialized behavior is performed for forms and keydown bindings:</source>
          <target state="translated">양식 및 keydown 바인딩에 대해 다음과 같은 특수 동작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7450f3bbf7bebc0ac2b8dc21e3fc9b6d5613f466" translate="yes" xml:space="preserve">
          <source>The following status codes can be given as atoms with their respective value shown next:</source>
          <target state="translated">다음 상태 코드는 다음에 표시된 각각의 값을 가진 원자로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c734167c81ee7d5e27dd0815c6c9a86a53980591" translate="yes" xml:space="preserve">
          <source>The following types are supported:</source>
          <target state="translated">다음 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2047e7bdd4c73fd0eee9eccb4cbf4a0fb4bc1b07" translate="yes" xml:space="preserve">
          <source>The following validations may be included in the result. The list is not necessarily exhaustive. For example, custom validations written by the developer will also appear in our return value.</source>
          <target state="translated">다음과 같은 유효성 검사가 결과에 포함될 수 있습니다. 이 목록이 반드시 완전한 것은 아닙니다. 예를 들어 개발자가 작성한 사용자 지정 유효성 검사도 반환 값에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cba133f413c5a544cc032d45c75d5ce55c737264" translate="yes" xml:space="preserve">
          <source>The following values are supported as date:</source>
          <target state="translated">다음 값은 날짜로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5bfa84ecf1155190787c1f7e94a11fe721e17de4" translate="yes" xml:space="preserve">
          <source>The following values are supported as time:</source>
          <target state="translated">다음 값은 시간으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a481ccb6962d389f9f787ae8a2a1fafb0d321119" translate="yes" xml:space="preserve">
          <source>The following window-level bindings are supported:</source>
          <target state="translated">다음 창 수준 바인딩이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">다음과 같은:</target>
        </trans-unit>
        <trans-unit id="4117df297cda8bdfcd48daa253e21cdf1ba31860" translate="yes" xml:space="preserve">
          <source>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</source>
          <target state="translated">외래 키 제약 조건은 데이터베이스를 사용하여 관련 데이터가 있는지 여부를 확인하여 작동합니다. 부모가 데이터베이스에도 존재하는 경우에만 자식이 만들어 지도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9abddf5cdee83822dd2471a1c84adfa00e2761db" translate="yes" xml:space="preserve">
          <source>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</source>
          <target state="translated">양식 데이터는 양식 마크 업에 대해 직접 유효성을 검사하고 변경 / 제출하는 데이터가 실제로 존재하는지 확인합니다. 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e8fa4eb4ae0982343eb1b5d21fa657d106b56303" translate="yes" xml:space="preserve">
          <source>The form generates a CSRF token by default. Your application should check this token on the server to avoid attackers from making requests on your server in behalf of other users. Phoenix by default checks this token.</source>
          <target state="translated">이 양식은 기본적으로 CSRF 토큰을 생성합니다. 공격자가 다른 사용자 대신 서버에서 요청을하지 않도록 응용 프로그램은 서버에서이 토큰을 확인해야합니다. Phoenix는 기본적으로이 토큰을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a1ba555c0e57f112db7c92095d012a43d52db5ee" translate="yes" xml:space="preserve">
          <source>The form receives the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="translated">양식은 &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; 클래스를 받습니다.</target>
        </trans-unit>
        <trans-unit id="f83c045b60690e0951f0d613211981e82b773a3a" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">양식 중 하나이어야 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; 방출 &lt;code&gt;form_for&lt;/code&gt; 또는 원자이다.</target>
        </trans-unit>
        <trans-unit id="8d01992897ad728050b4b855767bf08df37caba2" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">양식 중 하나이어야 &lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; 방출 &lt;code&gt;form_for&lt;/code&gt; 또는 원자이다.</target>
        </trans-unit>
        <trans-unit id="7a6fd6898aaadbc26c2bf3b5a891b41542112f89" translate="yes" xml:space="preserve">
          <source>The form's inputs are set to &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="translated">양식의 입력은 &lt;code&gt;readonly&lt;/code&gt; 으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f1af6d5bfd7bd7fb64c73cbb0bcf39cb8cf169f9" translate="yes" xml:space="preserve">
          <source>The format has to be expressed as a regular expression.</source>
          <target state="translated">형식은 정규식으로 표현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="489cb5dcb56120d97d2c8e93ec7af5be88c2a077" translate="yes" xml:space="preserve">
          <source>The forwarded plug will be initialized at compile time.</source>
          <target state="translated">전달 된 플러그는 컴파일 타임에 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="77d021b8d46e32208156e088e01303ca1c12d18a" translate="yes" xml:space="preserve">
          <source>The full list of &lt;code&gt;:telemetry&lt;/code&gt; events emitted from Phoenix, along with their measurements and metadata, is available in the &quot;Instrumentation&quot; section of the &lt;a href=&quot;phoenix.logger&quot;&gt;&lt;code&gt;Phoenix.Logger&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">측정 및 메타 데이터와 함께 Phoenix에서 방출되는 &lt;code&gt;:telemetry&lt;/code&gt; 이벤트 의 전체 목록은 &lt;a href=&quot;phoenix.logger&quot;&gt; &lt;code&gt;Phoenix.Logger&lt;/code&gt; &lt;/a&gt; 모듈 문서 의 &quot;Instrumentation&quot;섹션에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f475ae2afee4e174380adc1703f946251ee406f" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; can be used to handle these messages.</source>
          <target state="translated">&lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 함수 는 이러한 메시지를 처리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ef8c5833d6215f90102ad8553d89a6b62ac7bf" translate="yes" xml:space="preserve">
          <source>The function above fetches all users from the database who have registered presences for the given topic. The fetched information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user&amp;rsquo;s information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="translated">위의 함수는 주어진 주제에 대해 존재를 등록한 데이터베이스에서 모든 사용자를 가져옵니다. 페치 된 정보는 원래 프레즌스 데이터에서 필수 &lt;code&gt;:metas&lt;/code&gt; 필드 를 유지하면서 사용자 정보의 &lt;code&gt;:user&lt;/code&gt; 키로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bb5d899f787348b0861709cf9aa7599e25a199f" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="translated">이 함수는 상태를 정수 HTTP 상태 또는 원자 (예 : &lt;code&gt;404&lt;/code&gt; 또는 &lt;code&gt;:not_found&lt;/code&gt; ) 로 승인합니다 . 오류가 발생하면 랩핑 된 응답의 3 튜플이 응답의 상태, 헤더 및 본문과 일치하여 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7a00d6812bf7a0419f2a6f9124c6b63f43006264" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. The list of allowed atoms is available in &lt;a href=&quot;../plug/plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="translated">이 함수는 정수 HTTP 상태 또는 원자 (예 : &lt;code&gt;404&lt;/code&gt; 또는 &lt;code&gt;:not_found&lt;/code&gt; ) 로 상태를 허용합니다 . 허용되는 원자 목록은 &lt;a href=&quot;../plug/plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 . 오류가 발생하면 응답의 상태, 헤더 및 본문과 일치하는 래핑 된 응답의 3- 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="34f7c94fd7748f67cd09813bdd7706a2edb3046e" translate="yes" xml:space="preserve">
          <source>The function given to &lt;code&gt;run&lt;/code&gt; must return &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt; as its result. Returning an error will abort any further operations and make the whole multi fail.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 하도록 지정된 함수 는 결과로 &lt;code&gt;{:ok, value}&lt;/code&gt; 또는 &lt;code&gt;{:error, value}&lt;/code&gt; 를 반환해야합니다 . 오류를 반환하면 추가 작업이 중단되고 전체 멀티가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2a481723c76058903ea9cbe576e12efab982d90c" translate="yes" xml:space="preserve">
          <source>The function must return a map of data matching the outlined Presence data structure, including the &lt;code&gt;:metas&lt;/code&gt; key, but can extend the map of information to include any additional information. For example:</source>
          <target state="translated">함수는 &lt;code&gt;:metas&lt;/code&gt; 키를 포함하여 개요 된 Presence 데이터 구조와 일치하는 데이터 맵을 반환해야 하지만 추가 정보를 포함하도록 정보 맵을 확장 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fa901f9a75974fd4d90e6889c130fadce04c365a" translate="yes" xml:space="preserve">
          <source>The function returns a tuple with the first element being a quoted reference to the connection and the second element being the compiled quoted pipeline.</source>
          <target state="translated">이 함수는 첫 번째 요소가 연결에 대한 인용 된 참조이고 두 번째 요소가 컴파일 된 인용 된 파이프 라인 인 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="153b2df483884d8b989e308df19cc7b9893a9689" translate="yes" xml:space="preserve">
          <source>The function should return either &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt;, and receives the repo as the first argument, and the changes so far as the second argument.</source>
          <target state="translated">이 함수는 &lt;code&gt;{:ok, value}&lt;/code&gt; 또는 &lt;code&gt;{:error, value}&lt;/code&gt; 반환 하고 repo를 첫 번째 인수로 받고 변경 사항을 두 번째 인수까지받습니다.</target>
        </trans-unit>
        <trans-unit id="a67c783032e2a201537e306cf6f097d5365e66b6" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &quot;origin&quot; header checks and ensuring only SSL connections are allowed.</source>
          <target state="translated">이 모듈에서 제공하는 기능은 &quot;원본&quot;헤더 검사를 수행하고 SSL 연결 만 허용되도록하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d040f9e18e02bf1e9b7b5a6b1124e1c1c9357436" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &amp;ldquo;origin&amp;rdquo; header checks and ensuring only SSL connections are allowed.</source>
          <target state="translated">이 모듈에서 제공하는 기능은 &quot;원본&quot;헤더 검사를 수행하고 SSL 연결 만 허용하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f3caf5d490d3889e61dbe8db689ddbc1dc882729" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing as a controller often depends on the pipelines invoked in the router and before, unit testing controllers may be helpful in some situations.</source>
          <target state="translated">이 모듈의 기능은 컨트롤러 테스트에도 사용할 수 있습니다. 컨트롤러는 종종 라우터에서 호출 된 파이프 라인에 의존하기 때문에 엔드 포인트 테스트는 컨트롤러 테스트보다 선호되지만 단위 테스트 컨트롤러는 일부 상황에서 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e080e3a5969a0dfe51e38a130fc2af62050c352" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing, especially since the controller in Phoenix plays an integration role between your domain and your views, unit testing controllers may be helpful in some situations.</source>
          <target state="translated">이 모듈의 기능은 컨트롤러 테스트에도 사용할 수 있습니다. 엔드 포인트 테스트가 컨트롤러 테스트보다 선호되는 반면, 특히 Phoenix의 컨트롤러는 도메인과 뷰간에 통합 역할을하기 때문에 일부 상황에서는 유닛 테스트 컨트롤러가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dd86f90d5374c8aba9a2543470a122fcff086c" translate="yes" xml:space="preserve">
          <source>The functions in this module can be used in three distinct scenarios:</source>
          <target state="translated">이 모듈의 기능은 세 가지 시나리오에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca241d49313e0782ffcc88432a8a2d858c13e8e9" translate="yes" xml:space="preserve">
          <source>The generated datetime_select can be customized at will by providing a builder option. Here is an example from EEx:</source>
          <target state="translated">생성 된 datetime_select는 빌더 옵션을 제공하여 원하는대로 사용자 정의 할 수 있습니다. 다음은 EEx의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a05e320bee1a84e2ffca470cb7c31539b99e85c1" translate="yes" xml:space="preserve">
          <source>The generated files will contain:</source>
          <target state="translated">생성 된 파일에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="958104172477f9b5a43c314b73c9b38aabb7fb31" translate="yes" xml:space="preserve">
          <source>The generated migration can be skipped with &lt;code&gt;--no-migration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--no-migration&lt;/code&gt; 으로 생성 된 마이그레이션을 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2360bfab30a1d9a0770994aab3da68e5eb2150e6" translate="yes" xml:space="preserve">
          <source>The generated model will contain:</source>
          <target state="translated">생성 된 모델에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c2fafd8b72db2fda76555b5c3231ac455bc8d91f" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f&quot;.</source>
          <target state="translated">생성 된 요청 ID는 &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="9e5668b35e826d6b7f7128c9281d2999702c5951" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &amp;ldquo;uq8hs30oafhj5vve8ji5pmp7mtopc08f&amp;rdquo;.</source>
          <target state="translated">생성 된 요청 ID는 &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="3f6f61987271b75470a17cf53dff2fe262f3c6a6" translate="yes" xml:space="preserve">
          <source>The generated resource will contain:</source>
          <target state="translated">생성 된 자원에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="07a1ec291d930976c73c9d45dd66aa61e5c367bd" translate="yes" xml:space="preserve">
          <source>The generated route above will match on the path &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; and will dispatch to &lt;code&gt;:show&lt;/code&gt; action in &lt;code&gt;API.V1.PageController&lt;/code&gt;. A named helper &lt;code&gt;api_v1_page_path&lt;/code&gt; will also be generated.</source>
          <target state="translated">생성 된 경로는 위의 경로와 일치합니다 &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; 와에 파견 &lt;code&gt;:show&lt;/code&gt; 에서 액션 &lt;code&gt;API.V1.PageController&lt;/code&gt; . 명명 된 도우미 &lt;code&gt;api_v1_page_path&lt;/code&gt; 도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8eb6914d64c4e5b2458e4e1b429f8d5623fada37" translate="yes" xml:space="preserve">
          <source>The generated schema above will contain:</source>
          <target state="translated">위의 생성 된 스키마에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b0fe9476efd56f82a1ea6f2439a7dfb5f439d397" translate="yes" xml:space="preserve">
          <source>The generator also supports &lt;code&gt;belongs_to&lt;/code&gt; associations via references:</source>
          <target state="translated">또한 생성기는 참조를 통해 &lt;code&gt;belongs_to&lt;/code&gt; 연관을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="a584765639065a0e41059878bfc54d658311e358" translate="yes" xml:space="preserve">
          <source>The generator also supports references, which we will properly associate the given column to the primary key column of the referenced table:</source>
          <target state="translated">또한 생성기는 참조를 지원하며, 지정된 열을 참조 된 테이블의 기본 키 열에 올바르게 연결합니다.</target>
        </trans-unit>
        <trans-unit id="8ae78460b27964100f540d3c51518f56de1ae5d6" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;data&lt;/code&gt; may be either a changeset, a schema struct or a &lt;code&gt;{data, types}&lt;/code&gt; tuple. The second argument is a map of &lt;code&gt;params&lt;/code&gt; that are cast according to the type information from &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;params&lt;/code&gt; is a map with string keys or a map with atom keys containing potentially invalid data.</source>
          <target state="translated">주어진 &lt;code&gt;data&lt;/code&gt; 는 변경 세트, 스키마 구조체 또는 &lt;code&gt;{data, types}&lt;/code&gt; 튜플 일 수 있습니다. 두 번째 인수는 &lt;code&gt;data&lt;/code&gt; 의 유형 정보에 따라 캐스트 되는 &lt;code&gt;params&lt;/code&gt; 맵입니다 . &lt;code&gt;params&lt;/code&gt; 는 문자열 키가있는 맵 또는 잠재적으로 유효하지 않은 데이터가 포함 된 원자 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ed7aeeaafe6c3bad4cfce08f957a5bf97bc013c4" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;function&lt;/code&gt; is invoked with the change value only if there is a change for the given &lt;code&gt;key&lt;/code&gt;. Note that the value of the change can still be &lt;code&gt;nil&lt;/code&gt; (unless the field was marked as required on &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주어진 &lt;code&gt;function&lt;/code&gt; 는 주어진 &lt;code&gt;key&lt;/code&gt; 대한 변경이있는 경우에만 변경 값으로 호출됩니다 . 필드가 &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 에 필요한 것으로 표시되지 않은 한 변경 값은 여전히 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12ae3f1712df00636f70321070eb45b1efc012c4" translate="yes" xml:space="preserve">
          <source>The given attributes are expected to be structured data. If you want to build an association with external data, such as a request parameters, you can use &lt;a href=&quot;ecto.changeset#cast/3&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/3&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">주어진 속성은 구조화 된 데이터 여야합니다. 요청 매개 변수와 같은 외부 데이터와의 연결을 구축하려는 경우 &lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;build_assoc/3&lt;/code&gt; &lt;/a&gt; 후에 &lt;a href=&quot;ecto.changeset#cast/3&quot;&gt; &lt;code&gt;Ecto.Changeset.cast/3&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c33d234c4ff95f48de07c57959d603389ff704eb" translate="yes" xml:space="preserve">
          <source>The given channel is joined in a separate process which is linked to the test process.</source>
          <target state="translated">주어진 채널은 테스트 프로세스에 연결된 별도의 프로세스로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="d4c5415cdd429b8d05fbc81af9046db394117d84" translate="yes" xml:space="preserve">
          <source>The given definition:</source>
          <target state="translated">주어진 정의 :</target>
        </trans-unit>
        <trans-unit id="7187a5e81ba59fd9a2b763b67226ecb68e6f3832" translate="yes" xml:space="preserve">
          <source>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</source>
          <target state="translated">주어진 기능은 트랜잭션을 지원하는 데이터베이스에 대한 변경 세트 작업과 동일한 트랜잭션 내에서 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8584e031d70f2ab97e4e82d41f8a6fb76ac929" translate="yes" xml:space="preserve">
          <source>The goal of this guide is to talk about Phoenix's request life-cycle. This guide will take a practical approach where we will learn by doing: we will add two new pages to our Phoenix project and comment on how the pieces fit together along the way.</source>
          <target state="translated">이 가이드의 목표는 Phoenix의 요청 수명주기에 대해 이야기하는 것입니다. 이 가이드는 수행을 통해 배울 수있는 실용적인 접근 방식을 취할 것입니다. Phoenix 프로젝트에 두 개의 새 페이지를 추가하고 그 과정에서 조각이 어떻게 결합되는지에 대해 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c29577b9a3f39ac89098a852612cb04bd74935b" translate="yes" xml:space="preserve">
          <source>The guides that you are currently looking at provide an overview of all parts that make Phoenix. Here is a rundown of what they provide:</source>
          <target state="translated">현재보고있는 가이드는 Phoenix를 만드는 모든 부품에 대한 개요를 제공합니다. 다음은 그들이 제공하는 내용에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="4310f0789aac7f01d7f849f6e0aa96ec026f81a0" translate="yes" xml:space="preserve">
          <source>The helper function &lt;a href=&quot;#values/2&quot;&gt;&lt;code&gt;values/2&lt;/code&gt;&lt;/a&gt; returns the values for a given schema and field, which can be used in places like form drop-downs. For example, given the following schema:</source>
          <target state="translated">도우미 함수 &lt;a href=&quot;#values/2&quot;&gt; &lt;code&gt;values/2&lt;/code&gt; &lt;/a&gt; 는 양식 드롭 다운과 같은 위치에서 사용할 수있는 지정된 스키마 및 필드에 대한 값을 반환합니다. 예를 들어 다음과 같은 스키마가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef55b811dca93ddd51b8b1f7019f7e4229080fe" translate="yes" xml:space="preserve">
          <source>The hook can push events to the LiveView by using the &lt;code&gt;pushEvent&lt;/code&gt; function and receive a reply from the server via a &lt;code&gt;{:reply, map, socket}&lt;/code&gt; return value. The reply payload will be passed to the optional &lt;code&gt;pushEvent&lt;/code&gt; response callback.</source>
          <target state="translated">후크는 &lt;code&gt;pushEvent&lt;/code&gt; 함수 를 사용하여 이벤트를 LiveView로 푸시 하고 &lt;code&gt;{:reply, map, socket}&lt;/code&gt; 반환 값을 통해 서버로부터 응답을받을 수 있습니다. 응답 페이로드는 선택적 &lt;code&gt;pushEvent&lt;/code&gt; 응답 콜백에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">이 콜백의 구현은 전달 된 구조 &lt;code&gt;data&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 아래 값을 사용 하거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 사용하여 &lt;code&gt;fun&lt;/code&gt; 을 호출해야 합니다. 이 함수는 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 또는 &lt;code&gt;:pop&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d3c9aaa3512be3173ee88a5acfdcc5972b212b6" translate="yes" xml:space="preserve">
          <source>The instructions below will serve if you are installing the latest stable version from Hex. To start using LiveView, add one of the following dependencies to your &lt;code&gt;mix.exs&lt;/code&gt; and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hex에서 최신 안정 버전을 설치하는 경우 아래 지침이 제공됩니다. LiveView 사용을 시작하려면 &lt;code&gt;mix.exs&lt;/code&gt; 에 다음 종속성 중 하나를 추가 하고 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; 을&lt;/a&gt; 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e46bc2ee246632c28439adb8036c4ec274b15b36" translate="yes" xml:space="preserve">
          <source>The internal infrastructure LiveView uses to keep track of stateful components is very lightweight. However, be aware that in order to provide change tracking and to send diffs over the wire, all of the components assigns are kept in memory - exactly as it is done in LiveViews themselves.</source>
          <target state="translated">LiveView가 상태 저장 구성 요소를 추적하는 데 사용하는 내부 인프라는 매우 가볍습니다. 그러나 변경 내용 추적을 제공하고 유선을 통해 diff를 보내기 위해 할당 된 모든 구성 요소가 LiveView 자체에서 수행되는 것과 똑같이 메모리에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="897fcb552f1ed96e5b37d174da2e32ad713e210e" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store</source>
          <target state="translated">상점의 세션에 대한 내부 참조</target>
        </trans-unit>
        <trans-unit id="2b0fb080dc23dfd38867594f47439c384bd3fe00" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store.</source>
          <target state="translated">상점의 세션에 대한 내부 참조입니다.</target>
        </trans-unit>
        <trans-unit id="75c017e0096c8191807383c0ba159f9238866e0c" translate="yes" xml:space="preserve">
          <source>The issue is that we have no guarantees the channel has done processing our message after calling &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. The best solution is to assert the channel sent us a reply before doing any other assertion. First change the channel to send replies:</source>
          <target state="translated">문제는 &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; 를&lt;/a&gt; 호출 한 후 채널이 메시지 처리를 완료했다는 보장이 없다는 것 입니다. 가장 좋은 해결책은 다른 주장을하기 전에 채널이 우리에게 답장을 보내도록 주장하는 것입니다. 먼저 회신을 보내도록 채널을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="bf259ab2dd0402461d9104f43dc12dcf9a9184fd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings.</source>
          <target state="translated">키는 문자열 또는 원자 일 수 있으며, 여기서 원자는 자동으로 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f429352c0b3be43a54afc592d7a8110f87f053dd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings. Can only be invoked on unsent &lt;code&gt;conn&lt;/code&gt;s. Will raise otherwise.</source>
          <target state="translated">키는 문자열 또는 원자 일 수 있으며, 여기서 원자는 자동으로 문자열로 변환됩니다. 보내지 않은 &lt;code&gt;conn&lt;/code&gt; 에서만 호출 할 수 있습니다 . 그렇지 않으면 제기합니다.</target>
        </trans-unit>
        <trans-unit id="b090269894ef022087b95988c4c1c9ea6c329869" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &quot;json-api&quot;, you will be able to use templates with extension &quot;index.json-api&quot; or to force a particular format in a given URL by sending &quot;?_format=json-api&quot;.</source>
          <target state="translated">키는 미디어 유형이고 값은 미디어 유형을 식별 할 수있는 형식 목록입니다. 예를 들어 &quot;json-api&quot;를 사용하면 &quot;index.json-api&quot;확장자가있는 템플릿을 사용하거나 &quot;? _format = json-api&quot;를 전송하여 지정된 URL에서 특정 형식을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4edcd6a27ee607492b3ce414639ce14b3b1badad" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &amp;ldquo;json-api&amp;rdquo;, you will be able to use templates with extension &amp;ldquo;index.json-api&amp;rdquo; or to force a particular format in a given URL by sending &amp;ldquo;?_format=json-api&amp;rdquo;.</source>
          <target state="translated">키는 미디어 유형이고 값은 미디어 유형을 식별 할 수있는 형식의 목록입니다. 예를 들어 &quot;json-api&quot;를 사용하면 확장자가 &quot;index.json-api&quot;인 템플릿을 사용하거나 &quot;? _format = json-api&quot;를 전송하여 지정된 URL에서 특정 형식을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9dd9b6fe649ecbe85232c591304bd2bcb8a124" translate="yes" xml:space="preserve">
          <source>The keys in the list are the names of fields, and the values are a validation associated with the field. A field may occur multiple times in the list.</source>
          <target state="translated">목록의 키는 필드 이름이며 값은 필드와 관련된 유효성 검사입니다. 목록에서 필드가 여러 번 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44118a922e99586055ff7e96b077e2626d08844b" translate="yes" xml:space="preserve">
          <source>The keys of the map will usually point to a resource ID. The value will contain a map with a &lt;code&gt;:metas&lt;/code&gt; key containing a list of metadata for each resource. Additionally, every metadata entry will contain a &lt;code&gt;:phx_ref&lt;/code&gt; key which can be used to uniquely identify metadata for a given key. In the event that the metadata was previously updated, a &lt;code&gt;:phx_ref_prev&lt;/code&gt; key will be present containing the previous &lt;code&gt;:phx_ref&lt;/code&gt; value.</source>
          <target state="translated">맵의 키는 일반적으로 리소스 ID를 가리 킵니다. 값에는 각 리소스의 메타 데이터 목록이 포함 된 &lt;code&gt;:metas&lt;/code&gt; 키 가있는 맵이 포함 됩니다. 또한 모든 메타 데이터 항목에는 주어진 키의 메타 데이터를 고유하게 식별하는 데 사용할 수 있는 &lt;code&gt;:phx_ref&lt;/code&gt; 키 가 포함 됩니다. 메타 데이터가 이전에 업데이트 된 경우 이전 &lt;code&gt;:phx_ref&lt;/code&gt; 값을 포함 하는 &lt;code&gt;:phx_ref_prev&lt;/code&gt; 키가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="cd07e57985bded643428c1ca83408a9f2015bf8e" translate="yes" xml:space="preserve">
          <source>The keyword options passed from the Schema's field macro into &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">스키마의 필드 매크로에서 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 로 전달 된 키워드 옵션</target>
        </trans-unit>
        <trans-unit id="3f06d5aeae7960e61046c9013e3025c273538aad" translate="yes" xml:space="preserve">
          <source>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</source>
          <target state="translated">키워드 기반 및 파이프 기반 예제는 동일합니다. 매크로 사용의 단점은 모든 작업에 대해 바인딩을 지정해야한다는 것입니다. 그러나 키워드 기반 및 파이프 기반 예제는 동일하므로 바인딩없는 구문은 매크로에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="df5c4e04515501f7830b4c4bb804a178cc83618c" translate="yes" xml:space="preserve">
          <source>The last change is to open up &lt;code&gt;lib/hello_phoenix/repo.ex&lt;/code&gt; and make sure to set the &lt;code&gt;:adapter&lt;/code&gt; to &lt;code&gt;Ecto.Adapters.MyXQL&lt;/code&gt;.</source>
          <target state="translated">마지막 변경은 &lt;code&gt;lib/hello_phoenix/repo.ex&lt;/code&gt; 를 열고 &lt;code&gt;:adapter&lt;/code&gt; 를 &lt;code&gt;Ecto.Adapters.MyXQL&lt;/code&gt; 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1d08d545f1b896c36da46b4bc90528258f9af83a" translate="yes" xml:space="preserve">
          <source>The last input with focus is restored (unless another input has received focus)</source>
          <target state="translated">포커스가있는 마지막 입력이 복원됩니다 (다른 입력이 포커스를받은 경우 제외).</target>
        </trans-unit>
        <trans-unit id="1f0f79f452d7d90593329a433992b7a7e7313371" translate="yes" xml:space="preserve">
          <source>The latter could also be bound to any &lt;code&gt;click&lt;/code&gt; event, but this way you can be sure your custom code is only executed when the code of &lt;code&gt;phoenix_html.js&lt;/code&gt; is run.</source>
          <target state="translated">후자는 &lt;code&gt;click&lt;/code&gt; 이벤트 에도 바인딩 될 수 있지만이 방법으로 &lt;code&gt;phoenix_html.js&lt;/code&gt; 코드가 실행될 때만 사용자 지정 코드가 실행되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94ea7e500eb238ec30986cee0999cc9f163d089b" translate="yes" xml:space="preserve">
          <source>The layout given to &lt;code&gt;put_root_layout&lt;/code&gt; must use &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;&lt;/code&gt;. It is typically very barebones, with mostly &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags. For example:</source>
          <target state="translated">주어진 레이아웃 &lt;code&gt;put_root_layout&lt;/code&gt; 는 사용해야합니다 &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;&lt;/code&gt; . 일반적으로 대부분 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그 가있는 매우 베어 본 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6744e96e72ecda721afea0237536fd66db392297" translate="yes" xml:space="preserve">
          <source>The layout must be a tuple, specifying the layout view and the layout name, or false. In case a previous layout is set, &lt;code&gt;put_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">레이아웃은 레이아웃보기와 레이아웃 이름을 지정하는 튜플이거나 false입니다. 이전 레이아웃이 설정된 경우 &lt;code&gt;put_layout&lt;/code&gt; 은 레이아웃 이름을 문자열 또는 원자로 제공합니다. 문자열 인 경우 형식을 포함해야합니다. 아톰을 전달한다는 것은 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 의 템플릿과 비슷한 렌더링 시간에 레이아웃 형식을 찾을 수 있음을 의미합니다 . &lt;code&gt;false&lt;/code&gt; 로 설정할 수도 있습니다 . 이 경우 레이아웃이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7d67a564b0265425038298d81b7c53608deaa1e" translate="yes" xml:space="preserve">
          <source>The lib/hello directory</source>
          <target state="translated">lib / hello 디렉토리</target>
        </trans-unit>
        <trans-unit id="c5d2fa78d75d59a854f8844b73dfc72a968b6f84" translate="yes" xml:space="preserve">
          <source>The lib/hello_web directory</source>
          <target state="translated">lib / hello_web 디렉토리</target>
        </trans-unit>
        <trans-unit id="92154a1db347f64239f68f87cebd039161ceecac" translate="yes" xml:space="preserve">
          <source>The life-cycle of a LiveView as outlined in the &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt; docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</source>
          <target state="translated">&lt;a href=&quot;phoenix.liveview&quot;&gt; &lt;code&gt;Phoenix.LiveView&lt;/code&gt; &lt;/a&gt; 문서에 설명 된 LiveView의 수명주기 는 연결이 끊긴 소켓 상태에서 상태 비 저장 HTML 렌더링으로보기가 시작되는 방법을 자세히 설명합니다. 브라우저가 HTML을 수신하면 서버에 연결되고 새 LiveView 프로세스가 시작되고 연결된 소켓 상태로 다시 마운트되며보기가 상태 그대로 계속됩니다. LiveView 테스트 기능은 분리 된 마운트와 연결된 마운트 모두를 개별적으로 테스트하는 것을 지원합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="477d068a247e238de404418e92a5a9b81e34e717" translate="yes" xml:space="preserve">
          <source>The list of dynamics is always a list of iodatas or components, as we don't perform change tracking inside the comprehensions themselves. Similarly, comprehensions do not have fingerprints because they are only optimized at the root, so conditional evaluation, as the one seen in rendering, is not possible. The only possible outcome for a dynamic field that returns a comprehension is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">역학 목록은 이해 자체 내에서 변경 내용 추적을 수행하지 않기 때문에 항상 iodata 또는 구성 요소의 목록입니다. 마찬가지로, 이해는 루트에서만 최적화되어 있기 때문에 지문이 없습니다. 따라서 렌더링에서 볼 수있는 조건부 평가는 불가능합니다. 이해력을 반환하는 동적 필드에 대해 가능한 유일한 결과는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30777b456b3f6e3c3a181cabf70cf5ee328a6f81" translate="yes" xml:space="preserve">
          <source>The list of hostnames, if none are specified, defaults to:</source>
          <target state="translated">호스트 이름 목록이 지정되지 않은 경우 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9089ed404a90b7ca8405732095979a8fb2093289" translate="yes" xml:space="preserve">
          <source>The list of supported values and their behaviour is described in &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt;. If the given value is not any of values listed there, it will raise.</source>
          <target state="translated">지원되는 값 및 해당 동작의 목록은 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다. 주어진 값이 여기에 나열된 값 중 하나가 아니면 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="1bf6687a8673fe4a0d29060ff11510670a6cb046" translate="yes" xml:space="preserve">
          <source>The location of the web files (LiveView's, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="translated">엄브렐러 애플리케이션에서 웹 파일 (LiveView,보기, 템플릿 등)의 위치는 애플리케이션 &lt;code&gt;:generators&lt;/code&gt; 구성 에있는 &lt;code&gt;:context_app&lt;/code&gt; 구성에 따라 다릅니다 . 설정되면 Phoenix 생성기가 lib 및 테스트 폴더에 웹 파일을 직접 생성합니다. 응용 프로그램이 웹 특정 기능에 격리되어 있다고 가정하기 때문입니다. &lt;code&gt;:context_app&lt;/code&gt; 이 설정되지 않은 경우 응용 프로그램이 웹 및 도메인 특정 기능을 모두 처리한다고 가정하므로 생성기는 웹 관련 lib 및 테스트 파일을 &lt;code&gt;web/&lt;/code&gt; 디렉토리에 배치합니다. 구성 예 :</target>
        </trans-unit>
        <trans-unit id="ba10fe778e8a0ac2bdeed5623f9f0c72f2e97b50" translate="yes" xml:space="preserve">
          <source>The location of the web files (controllers, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="translated">우산 형 응용 프로그램에서 웹 파일 (컨트롤러, 뷰, 템플릿 등)의 위치는 응용 프로그램 &lt;code&gt;:generators&lt;/code&gt; 구성 에있는 &lt;code&gt;:context_app&lt;/code&gt; 구성에 따라 다릅니다 . 설정하면 응용 프로그램이 웹별 기능과 분리되어 있다고 가정하므로 Phoenix 생성기는 lib 및 테스트 폴더에서 직접 웹 파일을 생성합니다. &lt;code&gt;:context_app&lt;/code&gt; 가 설정되지 않은 경우 , 애플리케이션은 웹 및 도메인 특정 기능을 모두 처리하는 것으로 가정되므로 생성기는 웹 관련 lib 및 테스트 파일을 &lt;code&gt;web/&lt;/code&gt; 디렉토리에 배치합니다. 구성 예 :</target>
        </trans-unit>
        <trans-unit id="9838c2015d6a31f43230056050bd48b08264c2d5" translate="yes" xml:space="preserve">
          <source>The log line for each request contains the specific route for that request. This is due to specifying the &lt;code&gt;:tags&lt;/code&gt; option for the summary metric, which takes care of our first requirement; we can use &lt;code&gt;:tags&lt;/code&gt; to group metrics by route. Note that reporters will necessarily handle tags differently depending on the underlying service in use.</source>
          <target state="translated">각 요청의 로그 줄에는 해당 요청에 대한 특정 경로가 포함됩니다. 이는 첫 번째 요구 사항을 처리하는 요약 메트릭에 대해 &lt;code&gt;:tags&lt;/code&gt; 옵션 을 지정했기 때문입니다 . &lt;code&gt;:tags&lt;/code&gt; 를 사용 하여 경로별로 메트릭을 그룹화 할 수 있습니다 . 리포터는 사용중인 기본 서비스에 따라 태그를 반드시 다르게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="5054ea19f1c0872ef56ffb5ac8d9cbaa2ee98017" translate="yes" xml:space="preserve">
          <source>The logger call won&amp;rsquo;t be removed at compile time as custom level is given.</source>
          <target state="translated">사용자 정의 수준이 주어지면 컴파일 타임에 로거 호출이 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="282bfec61ed3e63c6a621589fc9ff184bc2a5dc3" translate="yes" xml:space="preserve">
          <source>The long poll is configurable in your socket:</source>
          <target state="translated">긴 폴링은 소켓에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df55f8f757b374fd6d2aa5a71db086c2cfcd7c1d" translate="yes" xml:space="preserve">
          <source>The main responsibility of a view is to render a template.</source>
          <target state="translated">뷰의 주된 책임은 템플릿을 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c3ad4277ebaf63c095045d7d65ae5d290329b067" translate="yes" xml:space="preserve">
          <source>The map type</source>
          <target state="translated">지도 유형</target>
        </trans-unit>
        <trans-unit id="fd10459a12af6703afd7079ef61598c3879b0473" translate="yes" xml:space="preserve">
          <source>The map type allows developers to store an Elixir map directly in the database:</source>
          <target state="translated">맵 유형을 통해 개발자는 데이터베이스에 직접 Elixir 맵을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080be8664031b1a1bb94955949d3616301947b14" translate="yes" xml:space="preserve">
          <source>The mechanism for passing the token to the client is typically through a cookie, a JSON response body, or HTTP header. For now, assume the client has received a token it can use to validate requests for protected resources.</source>
          <target state="translated">토큰을 클라이언트에 전달하는 메커니즘은 일반적으로 쿠키, JSON 응답 본문 또는 HTTP 헤더를 통해 이루어집니다. 지금은 클라이언트가 보호 된 리소스에 대한 요청의 유효성을 검사하는 데 사용할 수있는 토큰을 받았다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="eb58fc9777d3607a5fbb10fc1f79ea8d98ec0269" translate="yes" xml:space="preserve">
          <source>The message format requires the following keys:</source>
          <target state="translated">메시지 형식에는 다음 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="52f5b43827ed9d61c35f578531a7d764f7e53199" translate="yes" xml:space="preserve">
          <source>The message is a term. It must return one of:</source>
          <target state="translated">메시지는 용어입니다. 다음 중 하나를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0b210dad451da94f2501a9d8d7e918aa3958400" translate="yes" xml:space="preserve">
          <source>The message is represented as &lt;code&gt;{payload, options}&lt;/code&gt;. It must return one of:</source>
          <target state="translated">메시지는 &lt;code&gt;{payload, options}&lt;/code&gt; 로 표시됩니다 . 다음 중 하나를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8368bb195a36e75b24e3aa2abd88acdf1b5b819f" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">어댑터 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 에서 리턴 한 메타 데이터</target>
        </trans-unit>
        <trans-unit id="7b2acf0c1be2b4d18996e01c7970b3c30cc534ab" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어댑터 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 에서 리턴 한 메타 데이터 .</target>
        </trans-unit>
        <trans-unit id="70bfd62abd8739763f40ffef575496a5c549d630" translate="yes" xml:space="preserve">
          <source>The minimum value for &lt;code&gt;length&lt;/code&gt; is 32.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 의 최소값 은 32입니다.</target>
        </trans-unit>
        <trans-unit id="9634db4fa76e01e90a42b4c5e5f87e4ad4910fd5" translate="yes" xml:space="preserve">
          <source>The name of each operation does not have to be an atom. This can be particularly useful when you wish to update a collection of changesets at once, and track their errors individually:</source>
          <target state="translated">각 작업의 이름은 원자 일 필요는 없습니다. 변경 모음을 한 번에 업데이트하고 해당 오류를 개별적으로 추적하려는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0a3d293ea6bec7e5c5b00485c524e67b073803fb" translate="yes" xml:space="preserve">
          <source>The name used in assigns is determined from the view. For example the &lt;code&gt;PageView&lt;/code&gt; will use &lt;code&gt;%{page: page}&lt;/code&gt; and the &lt;code&gt;AuthorView&lt;/code&gt; will use &lt;code&gt;%{author: author}&lt;/code&gt;. This can be overridden with the &lt;code&gt;as&lt;/code&gt; option. Let's assume that the author view uses &lt;code&gt;%{writer: writer}&lt;/code&gt; instead of &lt;code&gt;%{author: author}&lt;/code&gt;:</source>
          <target state="translated">할당에 사용되는 이름은보기에서 결정됩니다. 예를 들어 &lt;code&gt;PageView&lt;/code&gt; 는 &lt;code&gt;%{page: page}&lt;/code&gt; 를 사용 하고 &lt;code&gt;AuthorView&lt;/code&gt; 는 &lt;code&gt;%{author: author}&lt;/code&gt; 합니다. 이는 &lt;code&gt;as&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 작성자 뷰가 &lt;code&gt;%{author: author}&lt;/code&gt; 대신 &lt;code&gt;%{writer: writer}&lt;/code&gt; 를 사용한다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8eacf623a28c1145f1b59317f4cbac89d904671a" translate="yes" xml:space="preserve">
          <source>The named helper can also be customized with the &lt;code&gt;:as&lt;/code&gt; option. Given the route:</source>
          <target state="translated">명명 된 도우미는 &lt;code&gt;:as&lt;/code&gt; 옵션 으로 사용자 지정할 수도 있습니다 . 주어진 경로 :</target>
        </trans-unit>
        <trans-unit id="ee9f556bb40887ceb71d128fe3a1686d36cd09f5" translate="yes" xml:space="preserve">
          <source>The only argument is the module name of the Presence tracker, which defaults to Presence.</source>
          <target state="translated">유일한 인수는 Presence 트래커의 모듈 이름이며 기본값은 Presence입니다.</target>
        </trans-unit>
        <trans-unit id="dd6daf265bd0ac4e906fd4bdd897c5919c6282da" translate="yes" xml:space="preserve">
          <source>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</source>
          <target state="translated">유일한 단점은 Elixir 쿼리를 검사 할 때 조각으로 표시된다는 것입니다. 그 외에는 내장 Ecto 쿼리 함수와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f0266dcf90fe67afe6ef36bb73cebc07fd00eac" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire all Phoenix endpoints, including the socket transports.</source>
          <target state="translated">옵션은 엔드 포인트 구성에서 &lt;code&gt;:http&lt;/code&gt; 및 &lt;code&gt;:https&lt;/code&gt; 키로 전달됩니다 . 그러나 사용자 정의 디스패치 옵션을 통과하면 소켓 전송을 포함하여 모든 Phoenix 엔드 포인트를 수동으로 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="81006dc93621cf7c03e17d32fa7ba38ff44285bc" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire the Phoenix endpoint by adding the following rule:</source>
          <target state="translated">옵션은 엔드 포인트 구성의 &lt;code&gt;:http&lt;/code&gt; 및 &lt;code&gt;:https&lt;/code&gt; 키 모두에 전달됩니다 . 그러나 사용자 지정 디스패치 옵션을 통과하면 다음 규칙을 추가하여 Phoenix 엔드 포인트를 수동으로 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="f34a63fc2945e1d41d9507823f6312b0d54d5e85" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;form_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">옵션은 &lt;code&gt;form_for/4&lt;/code&gt; 와 동일한 옵션 입니다. 구현에서 동작을 구성하는 데 사용할 수 있으며 사용자 정의 필드를 제거하고 기본 구조체에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="e94a4b1ffacdefb101fda0c3d483575fb46108fe" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;inputs_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">옵션은 &lt;code&gt;inputs_for/4&lt;/code&gt; 와 동일한 옵션 입니다. 구현에서 동작을 구성하는 데 사용할 수 있으며 사용자 정의 필드를 제거하고 기본 구조체에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbbc72dee649cfd3da9099e3aaa4dd8de76df598" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#put/4&quot;&gt;&lt;code&gt;put/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete/3&quot;&gt;&lt;code&gt;delete/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 리턴 된 옵션은 &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#put/4&quot;&gt; &lt;code&gt;put/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#delete/3&quot;&gt; &lt;code&gt;delete/3&lt;/code&gt; 에 제공&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d384613558e77407526f0c5fbfadcc4a059844a9" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;code&gt;get/3&lt;/code&gt;, &lt;code&gt;put/4&lt;/code&gt; and &lt;code&gt;delete/3&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 리턴 된 옵션은 &lt;code&gt;get/3&lt;/code&gt; , &lt;code&gt;put/4&lt;/code&gt; 및 &lt;code&gt;delete/3&lt;/code&gt; 에 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="f06bf866fed12855453f8d5f135a5f4e72431100" translate="yes" xml:space="preserve">
          <source>The other fields are merged with the following criteria:</source>
          <target state="translated">다른 필드는 다음 기준과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="3462b00b6bda12e1014b4b6dc443fa44ae87853c" translate="yes" xml:space="preserve">
          <source>The other validators simply take a value:</source>
          <target state="translated">다른 유효성 검사기는 단순히 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="161c387bc2cd3fea40fa9d1d48103ca6f80cdb4b" translate="yes" xml:space="preserve">
          <source>The output folder will contain:</source>
          <target state="translated">출력 폴더에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9dc286e9190cffa49c47ed0399b1d38337f37d16" translate="yes" xml:space="preserve">
          <source>The package does not perform any aggregation of the measurements itself. Instead, it provides a reporter with the Telemetry event-as-measurement definition and the reporter uses that definition to perform aggregations and report them.</source>
          <target state="translated">패키지는 측정 자체의 집계를 수행하지 않습니다. 대신보고자에게 측정으로 원격 측정 이벤트 정의를 제공하고보고자는 해당 정의를 사용하여 집계를 수행하고보고합니다.</target>
        </trans-unit>
        <trans-unit id="bd020c2783347fc6755fe582b2d5c9e69b5635df" translate="yes" xml:space="preserve">
          <source>The page we are going to build will simply say &quot;Hello World, from Phoenix!&quot; when we point our browser to &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http://localhost:4000/hello&lt;/a&gt;.</source>
          <target state="translated">우리가 만들 페이지는 단순히 &quot;Hello World, from Phoenix!&quot;라고 말할 것입니다. 브라우저가 &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http : // localhost : 4000 / hello&lt;/a&gt; 를 가리킬 때 .</target>
        </trans-unit>
        <trans-unit id="7b7216cd22ee3c8f81da71805d223b6947bf81bf" translate="yes" xml:space="preserve">
          <source>The parameters for the ParameterizedType</source>
          <target state="translated">ParameterizedType의 매개 변수</target>
        </trans-unit>
        <trans-unit id="f4662009e29483d0cc5077d2eabc424cdf07a6d6" translate="yes" xml:space="preserve">
          <source>The parameters for the given association will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the associations already in the changeset record.</source>
          <target state="translated">주어진 연관에 대한 매개 변수는 &lt;code&gt;changeset.params&lt;/code&gt; 에서 검색됩니다 . 이러한 매개 변수는 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; 에&lt;/a&gt; 전달 된 매개 변수와 유사한 속성이있는 맵이어야합니다 . 매개 변수가 검색되면 &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; 는 해당 매개 변수를 변경 세트 레코드에 이미있는 연관과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="f162dc3980f9534481973a5e2f3a8df458b6c531" translate="yes" xml:space="preserve">
          <source>The parameters for the given embed will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_embed/3&quot;&gt;&lt;code&gt;cast_embed/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the embeds already in the changeset record. See &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; for an example of working with casts and associations which would also apply for embeds.</source>
          <target state="translated">지정된 포함에 대한 매개 변수는 &lt;code&gt;changeset.params&lt;/code&gt; 에서 검색됩니다 . 이러한 매개 변수는 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; 에&lt;/a&gt; 전달 된 매개 변수와 유사한 속성이있는 맵이어야합니다 . 매개 변수가 검색되면 &lt;a href=&quot;#cast_embed/3&quot;&gt; &lt;code&gt;cast_embed/3&lt;/code&gt; &lt;/a&gt; 는 해당 매개 변수를 이미 변경 세트 레코드에 포함 된 임베드와 일치시킵니다. 임베드에도 적용되는 캐스트 및 연관 작업에 대한 예제는 &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ccf766b41fe567d6380527225e5d0d0c1950285" translate="yes" xml:space="preserve">
          <source>The path helpers now return what we want them to as well. Run &lt;code&gt;iex -S mix&lt;/code&gt; and give it a try yourself.</source>
          <target state="translated">경로 도우미는 이제 우리가 원하는 것을 반환합니다. &lt;code&gt;iex -S mix&lt;/code&gt; 를 실행 하고 직접 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="e6d9d95ae05eb4ab7374f78f148d8ced664f6b15" translate="yes" xml:space="preserve">
          <source>The path will be retrieved from the currently requested path via &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt;. The scheme, host and others will be received from the URL configuration in your Phoenix endpoint. The reason we don't use the host and scheme information in the request is because most applications are behind proxies and the host and scheme may not actually reflect the host and scheme accessed by the client. If you want to access the url precisely as requested by the client, see &lt;a href=&quot;../plug/plug.conn#request_url/1&quot;&gt;&lt;code&gt;Plug.Conn.request_url/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로는 &lt;a href=&quot;#current_path/1&quot;&gt; &lt;code&gt;current_path/1&lt;/code&gt; 을&lt;/a&gt; 통해 현재 요청 된 경로에서 검색됩니다 . 스키마, 호스트 및 기타는 Phoenix 엔드 포인트의 URL 구성에서 수신됩니다. 요청에서 호스트 및 체계 정보를 사용하지 않는 이유는 대부분의 응용 프로그램이 프록시 뒤에 있고 호스트 및 체계가 클라이언트가 액세스하는 호스트 및 체계를 실제로 반영하지 않을 수 있기 때문입니다. 클라이언트가 요청한대로 URL에 정확하게 액세스하려면 &lt;a href=&quot;../plug/plug.conn#request_url/1&quot;&gt; &lt;code&gt;Plug.Conn.request_url/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a51d7ff1518f2fc26effb50af9e146b994aed2db" translate="yes" xml:space="preserve">
          <source>The paths to the user facing reviews would look like a standard resource.</source>
          <target state="translated">사용자가 검토하는 경로는 표준 리소스처럼 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="8461b08dd0b39472d6e7cab05d0df7c89d7a56a5" translate="yes" xml:space="preserve">
          <source>The plug specification.</source>
          <target state="translated">플러그 사양.</target>
        </trans-unit>
        <trans-unit id="43d162b21236b659adf8d5bf3af141f3266eea3d" translate="yes" xml:space="preserve">
          <source>The preferred form is to use &lt;code&gt;:from&lt;/code&gt; with an atom or tuple, since it will make your application independent from the starting directory. For example, if you pass:</source>
          <target state="translated">선호되는 형식은 &lt;code&gt;:from&lt;/code&gt; 을 원자 또는 튜플과 함께 사용 하는 것입니다. 응용 프로그램이 시작 디렉토리와 독립적이되기 때문입니다. 예를 들어, 다음을 통과하면 :</target>
        </trans-unit>
        <trans-unit id="50998ebe5bad0757359a407f8ec8b122a3958b71" translate="yes" xml:space="preserve">
          <source>The prefixes set in the query will be preserved when loading data.</source>
          <target state="translated">쿼리에 설정된 접두사는 데이터를로드 할 때 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="867bac9d8d8d9b0a2e78aebeddd2b3b36f5a8853" translate="yes" xml:space="preserve">
          <source>The prerequisites for running an HTTPS server with Plug include:</source>
          <target state="translated">Plug를 사용하여 HTTPS 서버를 실행하기위한 전제 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1526ebdce848190098bcbfdfb625b2e2ecb877e8" translate="yes" xml:space="preserve">
          <source>The presence information is returned as a map with presences grouped by key, cast as a string, and accumulated metadata, with the following form:</source>
          <target state="translated">프레즌스 정보는 다음과 같은 형식으로 프레즌스를 키별로 그룹화하고 문자열로 캐스트하며 메타 데이터를 누적 한 맵으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e1834c7ca0296001b89ac9864e746de523a9361" translate="yes" xml:space="preserve">
          <source>The primary key will be automatically included in &lt;code&gt;returning&lt;/code&gt; if the field has type &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:binary_id&lt;/code&gt; and no value was set by the developer or none was autogenerated by the adapter.</source>
          <target state="translated">필드의 유형이 &lt;code&gt;:id&lt;/code&gt; 또는 &lt;code&gt;:binary_id&lt;/code&gt; 이고 개발자가 값을 설정하지 않았거나 어댑터가 자동 생성 한 것이없는 경우 기본 키가 &lt;code&gt;returning&lt;/code&gt; 자동으로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2afcc11c269b0c54b1b7ac0efcd7b569f223f2f" translate="yes" xml:space="preserve">
          <source>The primitive types are:</source>
          <target state="translated">기본 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5475cd442271dc875207326bb4064eeb96befb25" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can&amp;rsquo;t use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="translated">이 방법의 문제점은 데이터베이스에서 참조를 손상 시킨다는 것입니다. 외래 키를 사용할 수 없으며 쿼리 시간과 스토리지 측면에서 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7a3a4c7f6a78c9326c8ef25ce0f6c69a3f78f0d2" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can't use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="translated">이 접근 방식의 문제점은 데이터베이스에서 참조를 분리한다는 것입니다. 외래 키를 사용할 수 없으며 쿼리 시간과 스토리지 측면에서 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="8d89d344e6a03d17bab84b370769a6045fb37ec3" translate="yes" xml:space="preserve">
          <source>The public fields are:</source>
          <target state="translated">퍼블릭 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df908dd7366c676a05daf0e41f416b8dbf39971e" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &quot;fresh and new&quot;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="translated">위의 쿼리는 &quot;신규 및 새&quot;카테고리의 모든 게시물을 선택하고 가장 최근에 게시 된 순서로 정렬하며 ID, 제목 및 본문 필드 만 설정된 게시물 구조를 반환합니다. 다음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eff2eebe90fad772cf88b9e84a74f0fcaf7b64c1" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &amp;ldquo;fresh and new&amp;rdquo;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="translated">위의 쿼리는 &quot;fresh and new&quot;범주를 가진 모든 게시물을 가장 최근에 게시 한 순서대로 선택하고 id, title 및 body 필드 만 설정된 Post 구조체를 반환합니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95ca27e8b5eba197d23e18f17cf9ec5d46b73887" translate="yes" xml:space="preserve">
          <source>The query can be also rewritten as:</source>
          <target state="translated">쿼리는 다음과 같이 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0868e0ab6d1da07933f0f38d5ca3b2c0b98ed62" translate="yes" xml:space="preserve">
          <source>The query given to preload may also preload its own associations.</source>
          <target state="translated">사전로드에 제공된 조회는 자체 연관을 사전로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6733486c5b72fc457e7eabc6d95cf5b2c0075a" translate="yes" xml:space="preserve">
          <source>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</source>
          <target state="translated">ASC 열이 DESC 열이되고 (그 반대의 경우도) 쿼리 순서가 자동으로 역전되며 제한이 1로 설정됩니다. 순서가 없으면 기본 키를 통해 쿼리가 자동으로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="0bac158f3c93347932c98c42dee10fb98d800771" translate="yes" xml:space="preserve">
          <source>The query prefix may be set either for the whole query or on each individual &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; expression. If a &lt;code&gt;prefix&lt;/code&gt; is not given to a &lt;code&gt;from&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;, the prefix of the schema given to the &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;join&lt;/code&gt; is used. The query prefix is used only if none of the above are declared.</source>
          <target state="translated">쿼리 접두사는 전체 쿼리 또는 각 개별 &lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 식 에 설정 될 수 있습니다 . 경우 &lt;code&gt;prefix&lt;/code&gt; A를 주어지지 &lt;code&gt;from&lt;/code&gt; 또는이 &lt;code&gt;join&lt;/code&gt; , 스키마의 접두사는 부여 &lt;code&gt;from&lt;/code&gt; 또는 &lt;code&gt;join&lt;/code&gt; 사용된다. 쿼리 접두사는 위의 어느 것도 선언되지 않은 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd403c978b262ae86cb591bfb4e43647aaa3204" translate="yes" xml:space="preserve">
          <source>The query will be automatically ordered by the primary key unless &lt;code&gt;order_by&lt;/code&gt; is given or &lt;code&gt;order_by&lt;/code&gt; is set in the query. Limit is always set to 1.</source>
          <target state="translated">&lt;code&gt;order_by&lt;/code&gt; 가 제공되거나 &lt;code&gt;order_by&lt;/code&gt; 가 쿼리에 설정되어 있지 않으면 기본 키에 의해 쿼리가 자동으로 정렬됩니다 . 한계는 항상 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f356a4a7c8aa772e039cd5fb20e41a523131c1b" translate="yes" xml:space="preserve">
          <source>The race conditions would make this an unreliable way to update the existing table since multiple callers may be updating out of date view values. There's a better way.</source>
          <target state="translated">경쟁 조건은 여러 호출자가 오래된 뷰 값을 업데이트 할 수 있으므로 기존 테이블을 업데이트하는 신뢰할 수없는 방법입니다. 더 나은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae279db8cc5013382df2f8f7a465a8ec13291a8" translate="yes" xml:space="preserve">
          <source>The reason we can use &lt;code&gt;Routes.page_path&lt;/code&gt; instead of the full &lt;code&gt;HelloWeb.Router.Helpers.page_path&lt;/code&gt; name is because &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; is aliased as &lt;code&gt;Routes&lt;/code&gt; by default in the &lt;code&gt;view/0&lt;/code&gt; block defined inside &lt;code&gt;lib/hello_web.ex&lt;/code&gt;. This definition is made available to our templates through &lt;code&gt;use HelloWeb, :view&lt;/code&gt;.</source>
          <target state="translated">전체 &lt;code&gt;HelloWeb.Router.Helpers.page_path&lt;/code&gt; 이름 대신 &lt;code&gt;Routes.page_path&lt;/code&gt; 를 사용할 수있는 이유는 &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; 가 &lt;code&gt;lib/hello_web.ex&lt;/code&gt; 내부에 정의 된 &lt;code&gt;view/0&lt;/code&gt; 블록 에서 기본적 으로 &lt;code&gt;Routes&lt;/code&gt; 로 별칭 지정 되기 때문 입니다. 이 정의는 &lt;code&gt;use HelloWeb, :view&lt;/code&gt; 통해 템플릿에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cfdedb0bfaec211bb278c06c452d42b9de504d0" translate="yes" xml:space="preserve">
          <source>The reason why the example above is wrong is because &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always works with the &lt;strong&gt;full data&lt;/strong&gt;. So the example above will effectively &lt;strong&gt;erase all previous comments&lt;/strong&gt; and only keep the comment you are currently adding. Instead, you could try:</source>
          <target state="translated">위의 예제가 잘못된 이유는 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 가&lt;/a&gt; 항상 &lt;strong&gt;전체 데이터&lt;/strong&gt; 와 함께 작동 하기 때문 입니다. 따라서 위의 예는 &lt;strong&gt;이전의 모든 주석을&lt;/strong&gt; 효과적으로 &lt;strong&gt;지우고&lt;/strong&gt; 현재 추가중인 주석 만 유지합니다. 대신 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87305add73fb47f8d721c5faef9fcb8523b1a68e" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let&amp;rsquo;s discuss some of this extra functionality.</source>
          <target state="translated">유효성 검증, 제한 조건, 연관 처리와 같은이 모듈의 나머지 기능은 변경 세트 조작에 관한 것입니다. 이 추가 기능 중 일부에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2a63cf0d6104e4fb432f90b5c23167e7813b2aa2" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let's discuss some of this extra functionality.</source>
          <target state="translated">유효성 검사, 제약 조건, 연관 처리와 같은이 모듈의 나머지 기능은 변경 집합을 조작하는 것입니다. 이 추가 기능에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="8a0133540c725182eeb9cebba83044fb36adb332" translate="yes" xml:space="preserve">
          <source>The repositories to create are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">만들 리포지토리 는 현재 앱 구성 의 &lt;code&gt;:ecto_repos&lt;/code&gt; 옵션에 지정된 리포지토리 입니다. 그러나 &lt;code&gt;-r&lt;/code&gt; 옵션이 제공되면 &lt;code&gt;:ecto_repos&lt;/code&gt; 구성을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="40dd881afbf4316e3498baa3ef462026d3e04aaa" translate="yes" xml:space="preserve">
          <source>The repositories to drop are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">제거 할 리포지토리 는 현재 앱 구성 의 &lt;code&gt;:ecto_repos&lt;/code&gt; 옵션에 지정된 리포지토리 입니다. 그러나 &lt;code&gt;-r&lt;/code&gt; 옵션이 제공되면 &lt;code&gt;:ecto_repos&lt;/code&gt; 구성을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="01f05ddc7ae85e61bdf357b4f9fe87ebe2fb186e" translate="yes" xml:space="preserve">
          <source>The repository will be placed in the &lt;code&gt;lib&lt;/code&gt; directory.</source>
          <target state="translated">저장소는 &lt;code&gt;lib&lt;/code&gt; 디렉토리에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="fed09d1158b42d77503d7a48e9346028a907f505" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;method&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; are required arguments. &lt;code&gt;method&lt;/code&gt; may be any value that implements &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; and it will properly converted and normalized (e.g., &lt;code&gt;:get&lt;/code&gt; or &lt;code&gt;&quot;post&quot;&lt;/code&gt;).</source>
          <target state="translated">요청 &lt;code&gt;method&lt;/code&gt; 및 &lt;code&gt;path&lt;/code&gt; 는 필수 인수입니다. &lt;code&gt;method&lt;/code&gt; 는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 을 구현하는 모든 값일 수 있으며 올바르게 변환 및 정규화됩니다 (예 &lt;code&gt;:get&lt;/code&gt; 또는 &lt;code&gt;&quot;post&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6553aee7958eb204e762483dc8ab5a0161d11fe" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &quot;x-request-id&quot; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="translated">요청 ID는 Logger 메타 데이터에 &lt;code&gt;:request_id&lt;/code&gt; 로 추가되고 응답은 &quot;x-request-id&quot;HTTP 헤더로 추가됩니다. 로그 출력에서 ​​요청 ID를 보려면 &lt;code&gt;:request_id&lt;/code&gt; 메타 데이터 를 포함하도록 로거 백엔드를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c5f074e9b5c412ad29dd19562310620770be9f5" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &amp;ldquo;x-request-id&amp;rdquo; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="translated">요청 ID는 Logger 메타 데이터에 &lt;code&gt;:request_id&lt;/code&gt; 로 추가되고 응답은&amp;ldquo;x-request-id&amp;rdquo;HTTP 헤더로 추가됩니다. 로그 출력에서 ​​요청 ID를 보려면 &lt;code&gt;:request_id&lt;/code&gt; 메타 데이터 를 포함하도록 로거 백엔드를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb1a8693dbf7be806d104c7fe770e40145397d5f" translate="yes" xml:space="preserve">
          <source>The request information in these fields is not populated until it is fetched using the associated &lt;code&gt;fetch_&lt;/code&gt; function. For example, the &lt;code&gt;cookies&lt;/code&gt; field uses &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 필드의 요청 정보는 연관된 &lt;code&gt;fetch_&lt;/code&gt; 함수를 사용하여 페치 될 때까지 채워지지 않습니다 . 예를 들어, &lt;code&gt;cookies&lt;/code&gt; 필드는 &lt;a href=&quot;#fetch_cookies/2&quot;&gt; &lt;code&gt;fetch_cookies/2&lt;/code&gt; 를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="42d5b6701eebdfc545f5a296c3ed4d4a66bb5d50" translate="yes" xml:space="preserve">
          <source>The request will not be processed due to a client error.</source>
          <target state="translated">클라이언트 오류로 인해 요청이 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ca366dc222472a65071107117c79a6d7bda94b4" translate="yes" xml:space="preserve">
          <source>The resource fields are given using &lt;code&gt;name:type&lt;/code&gt; syntax where type are the types supported by Ecto. Omitting the type makes it default to &lt;code&gt;:string&lt;/code&gt;:</source>
          <target state="translated">자원 필드는 &lt;code&gt;name:type&lt;/code&gt; 구문을 사용하여 제공됩니다 . 여기서 type은 Ecto에서 지원하는 유형입니다. 유형을 생략하면 기본값은 &lt;code&gt;:string&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1097b0ddcaad963de9fecf51f90f2b6fa20570d6" translate="yes" xml:space="preserve">
          <source>The response will be sent with the status code defined within the connection, via &lt;a href=&quot;../plug/plug.conn#put_status/2&quot;&gt;&lt;code&gt;Plug.Conn.put_status/2&lt;/code&gt;&lt;/a&gt;. If no status code is set, a 302 response is sent.</source>
          <target state="translated">응답은 &lt;a href=&quot;../plug/plug.conn#put_status/2&quot;&gt; &lt;code&gt;Plug.Conn.put_status/2&lt;/code&gt; &lt;/a&gt; 를 통해 연결 내에 정의 된 상태 코드와 함께 전송됩니다 . 상태 코드가 설정되지 않은 경우 302 응답이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="cde9dc4c4422fde222d1887d84b0d0b8e0065c5e" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;init/1&lt;/code&gt; is passed as second argument to &lt;code&gt;call/2&lt;/code&gt;. Note that &lt;code&gt;init/1&lt;/code&gt; may be called during compilation and as such it must not return pids, ports or values that are not specific to the runtime.</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; 에 의해 리턴 된 결과는 두 번째 인수로 &lt;code&gt;call/2&lt;/code&gt; 에 전달됩니다 . 참고 &lt;code&gt;init/1&lt;/code&gt; 컴파일 호출 할 수와 같은가 런타임에 특정하지 않은 PID를, 포트 또는 값을 반환하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c468a501cc213c281f4ebc6e80d77300fb92019e" translate="yes" xml:space="preserve">
          <source>The return value of each &amp;ldquo;before&amp;rdquo; event callback will be stored and passed to the corresponding &amp;ldquo;after&amp;rdquo; callback.</source>
          <target state="translated">각 &quot;이전&quot;이벤트 콜백의 반환 값이 저장되고 해당 &quot;이후&quot;콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bdebdedcaeb020e5415f8353d03e0b77bd7af755" translate="yes" xml:space="preserve">
          <source>The returned result is given to &lt;code&gt;execute/6&lt;/code&gt;.</source>
          <target state="translated">반환 된 결과는 &lt;code&gt;execute/6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aa37f4a12198ad1c63cc6b2c6592271817c66fee" translate="yes" xml:space="preserve">
          <source>The right side may either be a list, a literal list or even a column in the database with array type:</source>
          <target state="translated">오른쪽은 목록, 리터럴 목록 또는 배열 유형을 가진 데이터베이스의 열일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a954d2682fa1c3ad1f60f5e9a5ca9d5b1fd15f" translate="yes" xml:space="preserve">
          <source>The route above tells us that any HTTP GET request for the root of the application will be handled by the &lt;code&gt;index&lt;/code&gt; action of the &lt;code&gt;HelloWeb.PageController&lt;/code&gt;.</source>
          <target state="translated">위의 경로는 응용 프로그램의 루트에 대한 모든 HTTP GET 요청 이 &lt;code&gt;HelloWeb.PageController&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 작업에 의해 처리된다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="152177e9ac83ea80f027842928a7dd7f74f8ab54" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyApp.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don&amp;rsquo;t have to repeat the &lt;code&gt;MyApp.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure in the Elixir compiler. If instead we had written:</source>
          <target state="translated">위의 경로는 &lt;code&gt;MyApp.PageController&lt;/code&gt; 로 전달됩니다 . 이 구문은 &lt;code&gt;MyApp.&lt;/code&gt; 을 반복 할 필요가 없으므로 개발자에게 편리 할뿐만 아니라 편리합니다 . 모든 경로에 접두사를 추가하지만 Phoenix가 Elixir 컴파일러에 부담을 덜 줄 수 있습니다. 대신에 우리는 다음과 같이 썼다.</target>
        </trans-unit>
        <trans-unit id="65e16ececbb9266a02583f54b94cf09861ee56a7" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don't have to repeat the &lt;code&gt;MyAppWeb.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure on the Elixir compiler. If instead we had written:</source>
          <target state="translated">위의 경로는 &lt;code&gt;MyAppWeb.PageController&lt;/code&gt; 로 전달됩니다 . 이 구문은 &lt;code&gt;MyAppWeb.&lt;/code&gt; 을 반복 할 필요가 없기 때문에 개발자에게만 편리하지 않습니다 . 모든 경로에 접두사를 붙이지 만 Phoenix는 Elixir 컴파일러에 부담을 덜어줍니다. 대신 우리가 다음과 같이 썼다면 :</target>
        </trans-unit>
        <trans-unit id="49ffcfff6909dca94a4eae307d1f02ebefe5118b" translate="yes" xml:space="preserve">
          <source>The route can dispatch either to a function body or a Plug module.</source>
          <target state="translated">라우트는 함수 본문 또는 플러그 모듈로 디스패치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a585daba1ebd3d0d2a8f8b5826e4a49abe384c1d" translate="yes" xml:space="preserve">
          <source>The route for our &quot;Welcome to Phoenix!&quot; page from the previous Up And Running Guide looks like this.</source>
          <target state="translated">&quot;Welcome to Phoenix!&quot;의 길 이전 Up And Running Guide의 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2939bacf3d39ca96536e1c8b322db4114aa2c1fe" translate="yes" xml:space="preserve">
          <source>The route:</source>
          <target state="translated">경로:</target>
        </trans-unit>
        <trans-unit id="b92d4396a601bd78f5174bee334d0b156a731866" translate="yes" xml:space="preserve">
          <source>The router emits the following telemetry events:</source>
          <target state="translated">라우터는 다음과 같은 원격 분석 이벤트를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1d645c8dddca0a4767932b2d077924d41ae564a8" translate="yes" xml:space="preserve">
          <source>The router file that Phoenix generates, &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, will look something like this one:</source>
          <target state="translated">Phoenix가 생성하는 라우터 파일 인 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="924f6def1ecc58fdee836524dd685a1ca8eb41c0" translate="yes" xml:space="preserve">
          <source>The router invokes a pipeline on a route defined within a scope. Routes outside of a scope have no pipelines. Although the use of nested scopes is discouraged (see above), if we call &lt;code&gt;pipe_through&lt;/code&gt; within a nested scope, the router will invoke all &lt;code&gt;pipe_through&lt;/code&gt;'s from parent scopes, followed by the nested one.</source>
          <target state="translated">라우터는 범위 내에 정의 된 경로에서 파이프 라인을 호출합니다. 범위를 벗어난 경로에는 파이프 라인이 없습니다. 중첩 된 범위의 사용은 권장되지 않지만 (위 참조) 중첩 된 범위 내에서 &lt;code&gt;pipe_through&lt;/code&gt; 를 호출하면 라우터는 상위 범위에서 모든 &lt;code&gt;pipe_through&lt;/code&gt; 를 호출 한 다음 중첩 된 범위를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5e68c3ae1fbcab887151d89b16d2cba345f34fa8" translate="yes" xml:space="preserve">
          <source>The router is itself a plug, which means it can be invoked as:</source>
          <target state="translated">라우터 자체는 플러그이므로 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf405b6509f92f8990929f4ff6aee358761fa42" translate="yes" xml:space="preserve">
          <source>The router maps unique HTTP verb/path pairs to controller/action pairs which will handle them. Controllers in Phoenix are simply Elixir modules. Actions are functions that are defined within these controllers.</source>
          <target state="translated">라우터는 고유 한 HTTP 동사 / 경로 쌍을이를 처리 할 컨트롤러 / 작업 쌍에 매핑합니다. Phoenix의 컨트롤러는 단순히 Elixir 모듈입니다. 액션은 이러한 컨트롤러 내에 정의 된 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a54219a575937cd1ecc7766ae2a1627937d5863d" translate="yes" xml:space="preserve">
          <source>The router provides a set of macros for generating routes that dispatch to specific controllers and actions. Those macros are named after HTTP verbs. For example:</source>
          <target state="translated">라우터는 특정 컨트롤러 및 작업으로 디스패치하는 경로를 생성하기위한 매크로 세트를 제공합니다. 이러한 매크로는 HTTP 동사의 이름을 따서 명명됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e873990af1b506d9425de23745c1354e6b8b3c7a" translate="yes" xml:space="preserve">
          <source>The router supports other macros besides those for HTTP verbs like &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, and &lt;code&gt;put&lt;/code&gt;. The most important among them is &lt;code&gt;resources&lt;/code&gt;. Let's add a resource to our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; file like this:</source>
          <target state="translated">라우터는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 과 같은 HTTP 동사에 대한 매크로 외에 다른 매크로를 지원합니다 . 그중 가장 중요한 것은 &lt;code&gt;resources&lt;/code&gt; 입니다. 다음 과 같이 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 파일에 리소스를 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="49855ec648da9ffc07970ba4da5777bc9db4c4b3" translate="yes" xml:space="preserve">
          <source>The same event callback is called again, this time with the atom &lt;code&gt;:stop&lt;/code&gt; as the first argument; see the &amp;ldquo;After clause&amp;rdquo; section below.</source>
          <target state="translated">같은 이벤트 콜백이 다시 호출됩니다. 이번에는 atom &lt;code&gt;:stop&lt;/code&gt; 을 첫 번째 인수로 사용합니다. 아래의 &quot;후 절&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65de666ef1e1e220f9c0d9372a51d104406e67a1" translate="yes" xml:space="preserve">
          <source>The schema also allows us to interact with a repository:</source>
          <target state="translated">스키마를 통해 저장소와 상호 작용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc68d1c060a62f551303cd6da271796006c2c527" translate="yes" xml:space="preserve">
          <source>The schema can be of any value. The path represents the database name while options are simply merged in.</source>
          <target state="translated">스키마는 임의의 값을 가질 수 있습니다. 경로는 데이터베이스 이름을 나타내며 옵션은 단순히 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="f4534f8ae409e6a396fbbf9dca42834fd3a4a272" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct.</source>
          <target state="translated">스키마는 데이터베이스 필드를 Elixir 구조체에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="f2c63087f504426ce8dc15eb5b941125dcbaa4ed" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct. It is followed by an optional list of attributes, with their respective names and types. See &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; for more information on attributes.</source>
          <target state="translated">스키마는 데이터베이스 필드를 Elixir 구조체로 매핑하는 역할을합니다. 그 다음에는 각각의 이름과 유형이있는 선택적 속성 목록이 나옵니다. 속성에 대한 자세한 정보는 &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e857c9bd7068c28cafcac14000408ae312ea8b02" translate="yes" xml:space="preserve">
          <source>The schema module can be defined inline in the parent schema in simple cases:</source>
          <target state="translated">스키마 모듈은 간단한 경우에 상위 스키마에서 인라인으로 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b62780b2378828f2f7ab21b8fde93c07ed6f06" translate="yes" xml:space="preserve">
          <source>The second and third argument that each event callback takes depends on the callback being an &amp;ldquo;after&amp;rdquo; or a &amp;ldquo;before&amp;rdquo; callback i.e. it depends on the value of the first argument, &lt;code&gt;:start&lt;/code&gt; or &lt;code&gt;:stop&lt;/code&gt;. For this reason, most of the time you will want to define (at least) two separate clauses for each event callback, one for the &amp;ldquo;before&amp;rdquo; and one for the &amp;ldquo;after&amp;rdquo; callbacks.</source>
          <target state="translated">각 이벤트 콜백이 취하는 두 번째 및 세 번째 인수는 콜백이 &quot;after&quot;또는 &quot;before&quot;콜백인지에 따라 달라집니다. 즉, 첫 번째 인수 &lt;code&gt;:start&lt;/code&gt; 또는 &lt;code&gt;:stop&lt;/code&gt; 의 값에 따라 다릅니다 . 이러한 이유로, 대부분의 경우 각 이벤트 콜백에 대해 각각 &quot;전&quot;과 &quot;후&quot;콜백에 대해 두 개의 별도 절을 정의하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8e57d6963dd7d705a901c4d4e7c1eb9745bf3c6f" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;data&lt;/code&gt; specifies fields and values that are to be loaded. It can be a map, a keyword list, or a &lt;code&gt;{fields, values}&lt;/code&gt; tuple. Fields can be atoms or strings.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;data&lt;/code&gt; 는로드 할 필드와 값을 지정합니다. 맵, 키워드 목록 또는 &lt;code&gt;{fields, values}&lt;/code&gt; 튜플 일 수 있습니다. 필드는 원자 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdda78bcfbc0f79c0c506943ef025fc56fbcad4" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &quot;user auth&quot; and treated as namespace when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="translated">두 번째 인수는 &lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 에 대한 두 호출 모두에서 동일해야하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;암호화 솔트&lt;/a&gt; 입니다 . 예를 들어, 채널이나 API에서 사용자를 인증하는 데 사용할 토큰을 생성 할 때 &quot;사용자 인증&quot;이라고하며 네임 스페이스로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbd999bbec42a3e7fb283772187deec6149dcdd" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &amp;ldquo;user auth&amp;rdquo; when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="translated">두 번째 인수는 &lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 호출 모두에서 동일해야하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;암호화 소금&lt;/a&gt; 입니다 . 예를 들어, 채널 또는 API에서 사용자를 인증하는 데 사용될 토큰을 생성 할 때이를 &quot;사용자 인증&quot;이라고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0127918dc247714fd5e025d35570e68dd2593e39" translate="yes" xml:space="preserve">
          <source>The second argument is the repository configuration as stored in the application environment. It must return &lt;code&gt;{:ok, keyword}&lt;/code&gt; with the updated list of configuration or &lt;code&gt;:ignore&lt;/code&gt; (only in the &lt;code&gt;:supervisor&lt;/code&gt; case).</source>
          <target state="translated">두 번째 인수는 애플리케이션 환경에 저장된 저장소 구성입니다. 업데이트 된 구성 목록 또는 &lt;code&gt;:ignore&lt;/code&gt; ( &lt;code&gt;:supervisor&lt;/code&gt; 경우 에만) 와 함께 &lt;code&gt;{:ok, keyword}&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ca2c1c0ef1b8f7a6c12e80c16925947b70511e2" translate="yes" xml:space="preserve">
          <source>The second argument must be &lt;code&gt;{:binary, contents}&lt;/code&gt;, where &lt;code&gt;contents&lt;/code&gt; will be sent as download, or&lt;code&gt;{:file, path}&lt;/code&gt;, where &lt;code&gt;path&lt;/code&gt; is the filesystem location of the file to be sent. Be careful to not interpolate the path from external parameters, as it could allow traversal of the filesystem.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;{:binary, contents}&lt;/code&gt; (여기서 &lt;code&gt;contents&lt;/code&gt; 는 다운로드로 전송 됨) 또는 &lt;code&gt;{:file, path}&lt;/code&gt; (여기서 &lt;code&gt;path&lt;/code&gt; 는 전송 될 파일의 ​​파일 시스템 위치) 여야합니다. 파일 시스템의 통과를 허용 할 수 있으므로 외부 매개 변수의 경로를 보간하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="4644893fe8ba1bf1c5d0e81a9d6a3f7226fe628b" translate="yes" xml:space="preserve">
          <source>The second parameter is &lt;code&gt;params&lt;/code&gt;. Not surprisingly, this is a map which holds any parameters passed along in the HTTP request. It is a good practice to pattern match against params in the function signature to provide data in a simple package we can pass on to rendering. We saw this in the &lt;a href=&quot;request_lifecycle&quot;&gt;Request life-cycle guide&lt;/a&gt; when we added a messenger parameter to our &lt;code&gt;show&lt;/code&gt; route in &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt;.</source>
          <target state="translated">두 번째 매개 변수는 &lt;code&gt;params&lt;/code&gt; 입니다. 당연히 이것은 HTTP 요청에서 전달 된 모든 매개 변수를 보유하는 맵입니다. 렌더링에 전달할 수있는 간단한 패키지로 데이터를 제공하기 위해 함수 시그니처의 매개 변수에 대한 패턴 일치를 사용하는 것이 좋습니다. 우리는이를 보았다 &lt;a href=&quot;request_lifecycle&quot;&gt;요청 수명주기 가이드&lt;/a&gt; 우리에 메신저 매개 변수를 추가 할 때 &lt;code&gt;show&lt;/code&gt; 에서 경로 &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f2d03f9984f042abc33381531414bedeec9588a" translate="yes" xml:space="preserve">
          <source>The serializer &lt;code&gt;decode!&lt;/code&gt; function must return a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; which is forwarded to channels except:</source>
          <target state="translated">직렬 변환기 &lt;code&gt;decode!&lt;/code&gt; 함수는 다음을 제외하고 채널로 전달 되는 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d3f623b2642c248a3d2a66503afa329aff8fe9" translate="yes" xml:space="preserve">
          <source>The server may send messages or replies back. For messages, the ref uniquely identifies the message. For replies, the ref matches the original message. Both data-types also include a join_ref that uniquely identifies the currently joined channel.</source>
          <target state="translated">서버는 메시지를 보내거나 회신 할 수 있습니다. 메시지의 경우 ref는 메시지를 고유하게 식별합니다. 회신의 경우 참조는 원본 메시지와 일치합니다. 두 데이터 유형 모두 현재 결합 된 채널을 고유하게 식별하는 join_ref도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="25af858d19e12fa8099a294c660a40b18c7cf762" translate="yes" xml:space="preserve">
          <source>The server's &lt;code&gt;handle_event/3&lt;/code&gt; would receive a payload:</source>
          <target state="translated">서버의 &lt;code&gt;handle_event/3&lt;/code&gt; 는 페이로드를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="efdb100e8fb22edffbda4a2f9c62ff5b45f532b5" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions</source>
          <target state="translated">세션 내용, &lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt; 및 기타 세션 조작 기능 으로 빌드 된 후 저장 될 최종 데이터</target>
        </trans-unit>
        <trans-unit id="8b95a016960327d8adfb4b2a4fa7945022268acb" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions.</source>
          <target state="translated">세션 내용, &lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt; 및 기타 세션 조작 기능 으로 빌드 된 후 저장 될 최종 데이터 .</target>
        </trans-unit>
        <trans-unit id="a534b349ad0dd4485a26018b51cb99468bc99b42" translate="yes" xml:space="preserve">
          <source>The session id may be nil in case the cookie does not identify any value in the store. The session contents must be a map.</source>
          <target state="translated">쿠키가 상점에서 값을 식별하지 않는 경우 세션 ID는 nil 일 수 있습니다. 세션 내용은 맵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45b3c50494949266d4502d1426e160d856709a04" translate="yes" xml:space="preserve">
          <source>The session is accessed via functions on &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. Cookies and session have to be fetched with &lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt;&lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt;&lt;/a&gt; before the session can be accessed.</source>
          <target state="translated">세션은 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 의&lt;/a&gt; 기능을 통해 액세스됩니다 . 세션에 액세스하려면 쿠키 및 세션을 &lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt; &lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt; &lt;/a&gt; 로 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="ea6faaf4abb4d9eac550e7cdd062da8586b666dd" translate="yes" xml:space="preserve">
          <source>The session is also lazy. Once configured, a cookie header with the session will only be sent to the client if something is written to the session in the first place.</source>
          <target state="translated">세션도 게으르다. 일단 구성되면 세션이있는 쿠키 헤더는 처음에 세션에 무언가가 기록 된 경우에만 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba204c596e34571bf913673b8b59a88885aaca5" translate="yes" xml:space="preserve">
          <source>The signing and encryption keys are derived from the connection's &lt;code&gt;secret_key_base&lt;/code&gt; using a salt that is built by appending &quot;_cookie&quot; to the cookie name. Care should be taken not to derive other keys using this value as the salt. Similarly do not use the same cookie name to store different values with distinct purposes.</source>
          <target state="translated">서명 및 암호화 키는 쿠키 이름에 &quot;_cookie&quot;를 추가하여 빌드 된 솔트를 사용하여 연결의 &lt;code&gt;secret_key_base&lt;/code&gt; 에서 파생됩니다 . 이 값을 솔트로 사용하여 다른 키를 파생하지 않도록주의해야합니다. 마찬가지로 동일한 쿠키 이름을 사용하여 고유 한 목적으로 다른 값을 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e43c5d3c5ff242e45bb3d214b290a81d5f13d3bc" translate="yes" xml:space="preserve">
          <source>The simplest component only needs to define a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">가장 간단한 구성 요소는 &lt;code&gt;render&lt;/code&gt; 함수 만 정의하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="76ed9ada6a0b3a3bc428852c33a8785e0c5e5e57" translate="yes" xml:space="preserve">
          <source>The socket assigns are available directly inside the template as LiveEEx &lt;code&gt;assigns&lt;/code&gt;, such as &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;@bar&lt;/code&gt;. Any assign access should be done using the assigns in the template where proper change tracking takes place.</source>
          <target state="translated">소켓 할당은 &lt;code&gt;@foo&lt;/code&gt; 및 &lt;code&gt;@bar&lt;/code&gt; 와 같이 LiveEEx가 &lt;code&gt;assigns&lt;/code&gt; 한대로 템플릿 내에서 직접 사용할 수 있습니다 . 모든 할당 액세스는 적절한 변경 내용 추적이 수행되는 템플릿의 할당을 사용하여 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42889c924bd9345b669263e4a09c0e69b581550" translate="yes" xml:space="preserve">
          <source>The socket endpoint is read from the &lt;code&gt;@endpoint&lt;/code&gt; variable.</source>
          <target state="translated">소켓 엔드 포인트는 &lt;code&gt;@endpoint&lt;/code&gt; 변수 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e8353003894eb4918615880dd892b3fb26308d6c" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 소켓을 사용하여 채널을 구독하고 참여시킵니다. &lt;code&gt;UserSocket.connect/2&lt;/code&gt; 와 같은 기능에 전달할 빈 소켓을 만들려면이 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="741b1725667e8d637e90c04ad708be61a6c67966" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/3&lt;/code&gt;.</source>
          <target state="translated">소켓은 채널을 구독하고 가입하는 데 사용됩니다. &lt;code&gt;UserSocket.connect/3&lt;/code&gt; 와 같은 함수에 전달할 빈 소켓을 만들려면이 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c75fa9c265b104aea9db5e1b8d2884d15b3c1c" translate="yes" xml:space="preserve">
          <source>The source for these guides is &lt;a href=&quot;https://github.com/phoenixframework/phoenix/tree/master/guides&quot;&gt;on GitHub&lt;/a&gt;. To help improve the guides, please report an &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues&quot;&gt;issue&lt;/a&gt; or open a &lt;a href=&quot;https://github.com/phoenixframework/phoenix/pulls&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">이 가이드의 소스는 &lt;a href=&quot;https://github.com/phoenixframework/phoenix/tree/master/guides&quot;&gt;GitHub에 있습니다&lt;/a&gt; . 가이드를 개선하는 데 도움이되도록 &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues&quot;&gt;문제&lt;/a&gt; 를 신고 하거나 &lt;a href=&quot;https://github.com/phoenixframework/phoenix/pulls&quot;&gt;풀 리퀘스트를여십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df8020d63833291b1200da532130369857dd6057" translate="yes" xml:space="preserve">
          <source>The state of the schema is stored in the &lt;code&gt;:state&lt;/code&gt; field and allows following values:</source>
          <target state="translated">스키마의 상태는 &lt;code&gt;:state&lt;/code&gt; 필드에 저장되며 다음 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="aa78ee5880f730e34341dec231106792a1c1612d" translate="yes" xml:space="preserve">
          <source>The status can be an integer, an atom, or &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">상태는 정수, 원자 또는 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 . 자세한 내용은 &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="549a0fdbf17866c901bbe69f809cf1df06203fc0" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상태 코드는 &lt;code&gt;nil&lt;/code&gt; , 정수 또는 원자 일 수 있습니다 . 허용되는 원자 목록은 &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3baf68608bb7edc0144295a9de68bd827a0c3d1c" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer, or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상태 코드는 &lt;code&gt;nil&lt;/code&gt; , 정수 또는 원자 일 수 있습니다 . 허용되는 원자 목록은 &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b85cd2f546627e7f8e771b8e4dacbd15919de6f" translate="yes" xml:space="preserve">
          <source>The status code we provide must be a valid number.</source>
          <target state="translated">우리가 제공하는 상태 코드는 유효한 숫자 여야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="58d3fec1c36423b15af55e60202f9084e0860082" translate="yes" xml:space="preserve">
          <source>The struct for testing LiveViews.</source>
          <target state="translated">LiveView를 테스트하기위한 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="b011117162e069e69fd96c3b54a5ab2de98fb369" translate="yes" xml:space="preserve">
          <source>The struct representing an internal unique reference to the component instance, available as the &lt;code&gt;@myself&lt;/code&gt; assign in stateful components.</source>
          <target state="translated">상태 저장 구성 요소에서 &lt;code&gt;@myself&lt;/code&gt; 할당으로 사용할 수있는 구성 요소 인스턴스에 대한 내부 고유 참조를 나타내는 구조체 입니다.</target>
        </trans-unit>
        <trans-unit id="1ffbb97758f6664c833c9c9e920b7aabfee8a286" translate="yes" xml:space="preserve">
          <source>The struct returned by .leex templates.</source>
          <target state="translated">.leex 템플릿에서 반환하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="db12a53ec7a2451062d21b0ec8554b50bad078d6" translate="yes" xml:space="preserve">
          <source>The struct returned by &lt;a href=&quot;phoenix.liveviewtest#element/3&quot;&gt;&lt;code&gt;Phoenix.LiveViewTest.element/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;phoenix.liveviewtest#element/3&quot;&gt; &lt;code&gt;Phoenix.LiveViewTest.element/3&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 구조체 입니다.</target>
        </trans-unit>
        <trans-unit id="336f100817cc09f943763c011543a225c024d68e" translate="yes" xml:space="preserve">
          <source>The struct returned by components in .leex templates.</source>
          <target state="translated">.leex 템플릿의 구성 요소가 반환하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="d96032e1804462a375e61aa3becfddf682507fdb" translate="yes" xml:space="preserve">
          <source>The struct returned by for-comprehensions in .leex templates.</source>
          <target state="translated">.leex 템플릿에서 for-comprehensions에 의해 반환 된 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="c2e71fa009e7b2e244d8ad3544b3e79a8a9bae1d" translate="yes" xml:space="preserve">
          <source>The submitted form is reactivated and loses the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="translated">제출 된 양식이 다시 활성화되고 &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; 클래스 가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="44eb57fe50cca343fe8e2ef06f2524d5aeefcf45" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; may be empty strings;</source>
          <target state="translated">제공된 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;pass&lt;/code&gt; 는 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7700abeab24f899ce4198c80479749838f3339" translate="yes" xml:space="preserve">
          <source>The supported keys are:</source>
          <target state="translated">지원되는 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9183fa9d80288d69edd242efa2830a2745f8ab1f" translate="yes" xml:space="preserve">
          <source>The supported values are:</source>
          <target state="translated">지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01f20fe2845d2b1bdb9951b6a8d84f277b6b5d78" translate="yes" xml:space="preserve">
          <source>The syntax above is equivalent to:</source>
          <target state="translated">위의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a40be796b70fed45f015e64809fd60c04642951" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn&amp;rsquo;t set, Plug will look at some environment variables which usually hold the value of the system&amp;rsquo;s temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="translated">호스트 시스템 에서 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 환경 변수를 설정하여 파일이 스트리밍되는 임시 디렉토리를 사용자 정의 할 수 있습니다 . 경우 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 가 설정되어 있지 않은, 플러그는 보통 (같은 시스템의 임시 디렉토리의 값 잡고 몇 가지 환경 변수를 볼 것이다 &lt;code&gt;TMPDIR&lt;/code&gt; 또는 &lt;code&gt;TMP&lt;/code&gt; 를 ). 해당 변수에 값이 없으면 &lt;code&gt;/tmp&lt;/code&gt; 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abfd2e746ee341013e4cdbafc97dfddc04d08e71" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn't set, Plug will look at some environment variables which usually hold the value of the system's temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="translated">파일이 스트리밍되는 임시 디렉토리 는 호스트 시스템 에서 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 환경 변수를 설정하여 사용자 정의 할 수 있습니다 . &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 이 설정되지 않은 경우 Plug는 일반적으로 시스템의 임시 디렉토리 값 (예 : &lt;code&gt;TMPDIR&lt;/code&gt; 또는 &lt;code&gt;TMP&lt;/code&gt; )을 보유하는 일부 환경 변수를 조사 합니다. 이러한 변수에 값이 없으면 &lt;code&gt;/tmp&lt;/code&gt; 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6008af9872175b7be58ce5d3be6044dce8156ae7" translate="yes" xml:space="preserve">
          <source>The test process will not receive the published message. This triggers the &lt;code&gt;handle_out/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">테스트 프로세스는 게시 된 메시지를받지 않습니다. 채널에서 &lt;code&gt;handle_out/3&lt;/code&gt; 콜백을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="96e4f76aa06de2592f470fd3dea7b0c4ef31375c" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won&amp;rsquo;t have the foreign key, instead there is a intermediary table responsible for associating the entries:</source>
          <target state="translated">세 번째이자 마지막 옵션은 &lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 자원 간의 관계를 정의하는 것입니다. 이 경우 주석 테이블에는 외래 키가 없으며 대신 항목을 연결하는 중개 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de91f694a160eac98f8736952f2a3f88136e353" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won't have the foreign key, instead there is an intermediary table responsible for associating the entries:</source>
          <target state="translated">세 번째이자 마지막 옵션은 &lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 리소스 간의 관계를 정의하는 것입니다. 이 경우 주석 테이블에는 외래 키가 없으며 대신 항목 연결을 담당하는 중간 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9b72d684ded4fbc52b2db0fd313e2feea35d4f" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;format&lt;/code&gt; is the format the data has been dumped as. For example, databases may dump embedded to &lt;code&gt;:json&lt;/code&gt;, this function allows such dumped data to be put back into the schemas.</source>
          <target state="translated">세 번째 인수 &lt;code&gt;format&lt;/code&gt; 은 데이터가 덤프 된 형식입니다. 예를 들어 데이터베이스는 &lt;code&gt;:json&lt;/code&gt; 에 내장 된 덤프를 덤프 할 수 있으며 ,이 함수를 사용하면 덤프 된 데이터를 스키마에 다시 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22dfe15ea505dc65004d52b00565b0529f3c5106" translate="yes" xml:space="preserve">
          <source>The third argument can be any term (string, int, list, etc.) that you wish to codify into the token. Upon valid verification, this same term will be extracted from the token.</source>
          <target state="translated">세 번째 인수는 토큰에 코드화하려는 모든 용어 (문자열, 정수, 목록 등) 일 수 있습니다. 유효한 확인이 끝나면 동일한 용어가 토큰에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c2052b68df8425edb8d31ef1ad3c1921b372fa" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms.</source>
          <target state="translated">시간 초과는 밀리 초 단위이며 기본값은 100ms입니다.</target>
        </trans-unit>
        <trans-unit id="ecb554852eb06b5cfc5cc2ec1aa86dbe934028bb" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="translated">시간 초과는 밀리 초 단위이며 기본값은 100ms입니다. 이 매크로는 시간 종료 값으로 테스트를 차단하므로, 과다 사용으로 인해 테스트 스위트가 느려질 수 있으므로 필요할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1304926df4500481102d8f6f3aa1797e91270270" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:assert_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms).</source>
          <target state="translated">타임 아웃을 밀리 초 기본값에있는 &lt;code&gt;:assert_receive_timeout&lt;/code&gt; 온 설정 &lt;code&gt;:ex_unit&lt;/code&gt; 의 응용 프로그램 (이 100ms의 기본값).</target>
        </trans-unit>
        <trans-unit id="b6a222ff7aa627d2ff58408f68862da0a0c1ac3d" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:refute_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms). Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="translated">제한 시간은 밀리 초 및 기본값에 &lt;code&gt;:refute_receive_timeout&lt;/code&gt; 온 세트 &lt;code&gt;:ex_unit&lt;/code&gt; (이 100ms로하는 기본값) 응용 프로그램입니다. 이 매크로는 시간 초과 값으로 테스트를 차단하므로 과도하게 사용하면 테스트 스위트가 확실히 느려지므로 필요할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4fff6f531f38d34226e8259653e269c039cae2" translate="yes" xml:space="preserve">
          <source>The timestamp is updated whenever there is a read or write to the table and it may be used to detect if a session is still active.</source>
          <target state="translated">타임 스탬프는 테이블에 대한 읽기 또는 쓰기가있을 때마다 업데이트되며 세션이 여전히 활성인지 여부를 감지하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81762c19246e6846b2e980ea04896a37c7853877" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &quot;_csrf_token&quot; or a header with name &quot;x-csrf-token&quot;.</source>
          <target state="translated">토큰은 키 &quot;_csrf_token&quot;이있는 매개 변수 또는 이름이 &quot;x-csrf-token&quot;인 헤더를 통해 요청에 의해 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5072feb3a5cec39cc2fc00a21cad324ac72eccb" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &amp;ldquo;_csrf_token&amp;rdquo; or a header with name &amp;ldquo;x-csrf-token&amp;rdquo;.</source>
          <target state="translated">토큰은&amp;ldquo;_csrf_token&amp;rdquo;키가있는 매개 변수 또는&amp;ldquo;x-csrf-token&amp;rdquo;이름의 헤더를 통해 요청에 의해 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c49c933ccb1807a833e99f7dd1b49c2eb650bfa" translate="yes" xml:space="preserve">
          <source>The tracked statics on the client will match the ones on the server the huge majority of times. However, if there is a new deployment, those values may differ. You can use this function to detect those cases and show a banner to the user, asking them to reload the page. To do so, first set the assign on mount:</source>
          <target state="translated">클라이언트에서 추적 된 통계는 대부분의 경우 서버의 통계와 일치합니다. 그러나 새 배포가있는 경우 해당 값이 다를 수 있습니다. 이 기능을 사용하여 이러한 경우를 감지하고 사용자에게 페이지를 다시로드하도록 요청하는 배너를 표시 할 수 있습니다. 이렇게하려면 먼저 마운트시 할당을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fec7f0c751853b58fb208600c6fd51e96a829e62" translate="yes" xml:space="preserve">
          <source>The tracking of changes is done via assigns. Imagine this template:</source>
          <target state="translated">변경 사항 추적은 할당을 통해 수행됩니다. 이 템플릿을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="92ce00aada35b93b3fdf93d5a2e7544465e5a9ee" translate="yes" xml:space="preserve">
          <source>The transaction will return the value given as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">트랜잭션은 &lt;code&gt;{:error, value}&lt;/code&gt; 로 제공된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="144f4cd1edb440f47f1246559392f7aed2405665" translate="yes" xml:space="preserve">
          <source>The transport behaviour</source>
          <target state="translated">수송 행동</target>
        </trans-unit>
        <trans-unit id="ffde96e4790584145c12afb10941ddbcfe63b5c3" translate="yes" xml:space="preserve">
          <source>The transport passes a map of metadata and the socket returns &lt;code&gt;{:ok, state}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. The state must be stored by the transport and returned in all future operations.</source>
          <target state="translated">전송은 메타 데이터 맵을 전달하고 소켓은 &lt;code&gt;{:ok, state}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 를 반환합니다 . 상태는 전송에 의해 저장되고 향후 모든 작업에서 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0618061b416a03f218c617e087e2e53df218e5c9" translate="yes" xml:space="preserve">
          <source>The transport requires one function:</source>
          <target state="translated">운송에는 하나의 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c0b95368d8ebf1cd3519374ade97eb4d383c66c" translate="yes" xml:space="preserve">
          <source>The triggers the &lt;code&gt;handle_in/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">채널에서 &lt;code&gt;handle_in/3&lt;/code&gt; 콜백을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="42337bbf47f302b6017a80123d119d2018afc1ba" translate="yes" xml:space="preserve">
          <source>The underlying data in the JSON column is returned without any additional decoding. This means &quot;null&quot; JSON values are not the same as SQL's &quot;null&quot;. For example, the &lt;code&gt;Repo.all&lt;/code&gt; operation below returns an empty list because &lt;code&gt;p.meta[&quot;author&quot;]&lt;/code&gt; returns JSON's null and therefore &lt;code&gt;is_nil&lt;/code&gt; does not succeed:</source>
          <target state="translated">JSON 열의 기본 데이터는 추가 디코딩없이 반환됩니다. 이는 &quot;null&quot;JSON 값이 SQL의 &quot;null&quot;과 동일하지 않음을 의미합니다. 예를 들어 아래 &lt;code&gt;Repo.all&lt;/code&gt; 작업은 &lt;code&gt;p.meta[&quot;author&quot;]&lt;/code&gt; 가 JSON의 null을 반환하므로 &lt;code&gt;is_nil&lt;/code&gt; 이 성공하지 않기 때문에 빈 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="18e53abaed4d2983226c3cac5079451da818bff2" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inferred from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">기본 사용자는 &lt;code&gt;:user&lt;/code&gt; 로 뷰 및 템플리트에 전달되며 이는 뷰 이름에서 유추됩니다. assigns의 키 이름은 &lt;code&gt;:as&lt;/code&gt; 옵션 으로 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dfd3b303d5fe2aedc67a0b4bc8aa60d95f14665" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inflected from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">기본 사용자는 &lt;code&gt;:user&lt;/code&gt; 로 뷰 및 템플리트에 전달되며 이는 뷰 이름에서 영향을받습니다. assigns의 키 이름은 &lt;code&gt;:as&lt;/code&gt; 옵션 으로 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ece19487ec4f9c9b42291fc4215172a12c3b8537" translate="yes" xml:space="preserve">
          <source>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">고유 제한 조건은 데이터베이스에 의존하여 고유 제한 조건이 위반되었는지 여부를 확인하고, 그렇다면 Ecto가이를 변경 세트 오류로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8f24025f778f23bb692d5c7e74205b6b4b984c73" translate="yes" xml:space="preserve">
          <source>The update expression in Ecto supports the following operators:</source>
          <target state="translated">Ecto의 업데이트 표현식은 다음 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9e941c51bb22eea00a76220d6ae9f744a7be5afe" translate="yes" xml:space="preserve">
          <source>The update function receives the current key's value and returns the updated value. Raises if the key does not exist.</source>
          <target state="translated">업데이트 함수는 현재 키의 값을 수신하고 업데이트 된 값을 반환합니다. 키가 없으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b6d6cdb41018b373e7cfa4867802d99511b1902" translate="yes" xml:space="preserve">
          <source>The valid keys are:</source>
          <target state="translated">유효한 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9ef4c02aad1666d20571d41d03ccfe5bdef87c8" translate="yes" xml:space="preserve">
          <source>The validate callback simply updates the changeset based on all form input values, then assigns the new changeset to the socket. If the changeset changes, such as generating new errors, &lt;a href=&quot;phoenix.liveview#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; is invoked and the form is re-rendered.</source>
          <target state="translated">validate 콜백은 모든 양식 입력 값을 기반으로 변경 집합을 업데이트 한 다음 새 변경 집합을 소켓에 할당합니다. 새 오류 생성과 같이 변경 집합이 변경되면 &lt;a href=&quot;phoenix.liveview#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt; 이 호출되고 양식이 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6cddd8de1840c96ca7fda0519b7a48fb8e1141" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to 8_000_000 may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">위의 값은 정확하지 않습니다. 예를 들어, 길이를 8_000_000으로 설정하면 정지 할 때까지 소켓에서 수백 바이트 더 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62c587734431028a6aa80f1e9be78246f2a1d3f" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to &lt;code&gt;8_000_000&lt;/code&gt; may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">위의 값은 정확하지 않습니다. 예를 들어, 길이를 &lt;code&gt;8_000_000&lt;/code&gt; 으로 설정하면 정지 할 때까지 소켓에서 수백 바이트 더 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ecaa2ac2dc3f10d3435db3d9b4bfce660d8e6fb" translate="yes" xml:space="preserve">
          <source>The view layer also contains conveniences for rendering templates, including support for layouts and encoders per format.</source>
          <target state="translated">또한 뷰 레이어에는 레이아웃 및 형식 별 인코더 지원을 비롯하여 템플릿을 렌더링 할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="60741f2b56ae9c96f4fb20a37607c7c8a04c0e31" translate="yes" xml:space="preserve">
          <source>The view's job is not only to render HTML templates. Views are about data presentation. Given a bag of data, the view's purpose is to present that in a meaningful way given some format, be it HTML, JSON, CSV, or others. Many web apps today return JSON to remote clients, and Phoenix Views are &lt;em&gt;great&lt;/em&gt; for JSON rendering.</source>
          <target state="translated">뷰의 역할은 HTML 템플릿을 렌더링하는 것 뿐만이 아닙니다. 뷰는 데이터 표현에 관한 것입니다. 데이터 가방이 주어지면 뷰의 목적은 HTML, JSON, CSV 등의 형식이 주어지면 의미있는 방식으로이를 표시하는 것입니다. 많은 웹 원격 클라이언트에 오늘 반환 JSON 애플 리케이션, 피닉스보기는 &lt;em&gt;큰&lt;/em&gt; JSON 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="91fa591ef2cba3e61fb437760238714eb628080e" translate="yes" xml:space="preserve">
          <source>The websocket is configurable in your socket:</source>
          <target state="translated">소켓에서 웹 소켓을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b5a7e72a4fe9a475fcfc4b4359c0838c82db1da" translate="yes" xml:space="preserve">
          <source>Then Phoenix will never re-render the section above, even if the number of users in the database changes. Instead, you need to store the users as assigns in your LiveView before it renders the template:</source>
          <target state="translated">그러면 Phoenix는 데이터베이스의 사용자 수가 변경 되더라도 위 섹션을 다시 렌더링하지 않습니다. 대신 템플릿을 렌더링하기 전에 사용자를 LiveView에 할당으로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="19af577dc0e0cc3e9e4137f355fc1af37d4a35b0" translate="yes" xml:space="preserve">
          <source>Then a hook callback object could be defined and passed to the socket:</source>
          <target state="translated">그런 다음 후크 콜백 객체를 정의하여 소켓에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e364d2682313f21c0b364d5a1f63f57084ff3d81" translate="yes" xml:space="preserve">
          <source>Then access &lt;code&gt;@page_title&lt;/code&gt; in the root layout:</source>
          <target state="translated">그런 다음 루트 레이아웃에서 &lt;code&gt;@page_title&lt;/code&gt; 에 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="7196b255ac3408de7a3c568b57c1148a6a5e5f86" translate="yes" xml:space="preserve">
          <source>Then add the &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt;&lt;/a&gt; plug to your browser pipeline, in place of &lt;code&gt;:fetch_flash&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;:fetch_flash&lt;/code&gt; 대신 Phoenix.LiveView.Router.fetch_live_flash &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt; &lt;/a&gt; 플러그를 브라우저 파이프 라인에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="75c95726962fecc66929136723a6281fa6affd6c" translate="yes" xml:space="preserve">
          <source>Then add to your main application's supervision tree (usually in &lt;code&gt;lib/my_app/application.ex&lt;/code&gt;):</source>
          <target state="translated">그런 다음 기본 애플리케이션의 감독 트리 (일반적으로 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 에 있음 )에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dab777042c47d40f4805c33c94a1bf2e15d3974d" translate="yes" xml:space="preserve">
          <source>Then expect them in the test:</source>
          <target state="translated">그런 다음 테스트에서 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="f64fa9df7a55832de8379999e187333ea71240ba" translate="yes" xml:space="preserve">
          <source>Then in your &lt;code&gt;assets/css/app.css&lt;/code&gt; file, import its style:</source>
          <target state="translated">그런 다음 &lt;code&gt;assets/css/app.css&lt;/code&gt; 파일에서 스타일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b070171e3affccf770658d51e9a5a2feeee14f4d" translate="yes" xml:space="preserve">
          <source>Then in your LiveView &lt;code&gt;mount/3&lt;/code&gt;, you can restore the locale:</source>
          <target state="translated">그런 다음 LiveView &lt;code&gt;mount/3&lt;/code&gt; 에서 로케일을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c5001f8e7c44fc4729c6dbfba0bf39f72beb09" translate="yes" xml:space="preserve">
          <source>Then in your LiveView, you can toggle the assign to trigger the form with the current fields on next render:</source>
          <target state="translated">그런 다음 LiveView에서 할당을 전환하여 다음 렌더링시 현재 필드로 양식을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c527e6d510bb99f313314e80e90cb75cc1f4074f" translate="yes" xml:space="preserve">
          <source>Then install the new NPM dependency:</source>
          <target state="translated">그런 다음 새 NPM 종속성을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b44a39ccd5266edb2d9caad076b683f36a1762b6" translate="yes" xml:space="preserve">
          <source>Then it falls back to the &lt;code&gt;@schema_prefix&lt;/code&gt; attribute declared in the schema given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">그런 다음 / &lt;code&gt;join&lt;/code&gt; &lt;code&gt;from&lt;/code&gt; 제공된 스키마에 선언 된 &lt;code&gt;@schema_prefix&lt;/code&gt; 속성으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="5fe6880ddcb09c2b177e0c20e50dae10169afeef" translate="yes" xml:space="preserve">
          <source>Then it falls back to the query prefix</source>
          <target state="translated">그런 다음 쿼리 접두사로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="a1ac12656c2b3f79bd0a2050e3acbce5cba1ab83" translate="yes" xml:space="preserve">
          <source>Then make sure to call it in every LiveView's &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그런 다음 모든 LiveView의 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f55476a7acca9fcf01ed95bca9c169e12918f35" translate="yes" xml:space="preserve">
          <source>Then on the server, all LiveView bindings are handled with the &lt;code&gt;handle_event&lt;/code&gt; callback, for example:</source>
          <target state="translated">그런 다음 서버에서 모든 LiveView 바인딩이 &lt;code&gt;handle_event&lt;/code&gt; 콜백으로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d9c975aa67ad159cfffc8aca53b0fcbfcf6e25a" translate="yes" xml:space="preserve">
          <source>Then the &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; callback of your LiveView should execute those same verifications:</source>
          <target state="translated">그런 다음 LiveView 의 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 콜백이 동일한 확인을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b91bece7078d6127399b4fede7285d49a284f5" translate="yes" xml:space="preserve">
          <source>Then the module for the &lt;code&gt;@view_module&lt;/code&gt; view can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="translated">그런 다음 &lt;code&gt;@view_module&lt;/code&gt; 뷰 의 모듈 은 스크립트를 미리 컴파일 된 템플릿으로 제공하거나 함수를 직접 구현하여 다음과 같이 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14d34a4f2c3d48f59e2e1b8b4a19a69ac94c3f8" translate="yes" xml:space="preserve">
          <source>Then the module under &lt;code&gt;view_module(@conn)&lt;/code&gt; can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="translated">그런 다음 &lt;code&gt;view_module(@conn)&lt;/code&gt; 아래의 모듈 은 미리 컴파일 된 템플릿을 사용하거나 함수를 직접 구현하여 스크립트를 제공할지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd69831783581e277c0c694fce3ca0c8208fd7dc" translate="yes" xml:space="preserve">
          <source>Then the reporter will attach a listener for the &lt;code&gt;&quot;phoenix.endpoint.stop.duration&quot;&lt;/code&gt; event and will respond to this event by calculating a summary metric with the given event metadata and reporting on that metric to the appropriate source.</source>
          <target state="translated">그런 다음 리포터는 &lt;code&gt;&quot;phoenix.endpoint.stop.duration&quot;&lt;/code&gt; 이벤트 에 대한 리스너를 연결 하고 주어진 이벤트 메타 데이터로 요약 메트릭을 계산하고 해당 메트릭에 대해 적절한 소스에보고하여이 이벤트에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="5a0b9d44aabce7da630f72c56a074c5f7a3f3085" translate="yes" xml:space="preserve">
          <source>Then we can reference our new controller as the &lt;code&gt;action_fallback&lt;/code&gt; and simply remove the &lt;code&gt;else&lt;/code&gt; block from our &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="translated">그리고 우리는 우리의 새로운 컨트롤러를 참조 할 수 있습니다 &lt;code&gt;action_fallback&lt;/code&gt; 간단히 제거 &lt;code&gt;else&lt;/code&gt; 우리에서 블록을 &lt;code&gt;with&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b9c5f3948060b97e1164d834dab0e2986a1f273" translate="yes" xml:space="preserve">
          <source>Then we'll change the &lt;code&gt;index&lt;/code&gt; action to do nothing but redirect to our new route.</source>
          <target state="translated">그런 다음 &lt;code&gt;index&lt;/code&gt; 작업을 변경하여 새 경로로 리디렉션하는 것 외에는 아무 작업도 수행하지 않을 것입니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c0dafaeb0118a06673409561de14306159c50ceb" translate="yes" xml:space="preserve">
          <source>Then you are able to use your own datetime_select throughout your whole application.</source>
          <target state="translated">그런 다음 전체 응용 프로그램에서 고유 한 datetime_select를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb5c8aab927695627e6a415525151e60cdf227b" translate="yes" xml:space="preserve">
          <source>Then you can directly create a socket and &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; topics and channels:</source>
          <target state="translated">그런 다음 직접 소켓을 작성하고 &lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt; 주제 및 채널을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584bf72a0acf37e4eddce0ef40e653d37e3153b8" translate="yes" xml:space="preserve">
          <source>Then, in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback, attach the handler to this event using a unique handler id:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; 콜백에서 고유 한 처리기 ID를 사용하여이 이벤트에 처리기를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1745b5a982e4f76414fc6a64641255e30bd82f09" translate="yes" xml:space="preserve">
          <source>Then, pass the basename of the new layout into &lt;code&gt;put_layout/2&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; action in &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 작업에서 새 레이아웃의 기본 이름을 &lt;code&gt;put_layout/2&lt;/code&gt; 에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="4655c959b82e207027f846c0e96c80c6352c98fa" translate="yes" xml:space="preserve">
          <source>There are a couple of interesting things to notice about what we just did. We didn't need to stop and re-start the server while we made these changes. Yes, Phoenix has hot code reloading! Also, even though our &lt;code&gt;index.html.eex&lt;/code&gt; file consisted of only a single &lt;code&gt;div&lt;/code&gt; tag, the page we get is a full HTML document. Our index template is rendered into the application layout - &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;. If you open it, you'll see a line that looks like this:</source>
          <target state="translated">우리가 방금 한 일에 대해 주목할 몇 가지 흥미로운 점이 있습니다. 이러한 변경을 수행하는 동안 서버를 중지했다가 다시 시작할 필요가 없었습니다. 예, Phoenix는 핫 코드를 다시로드합니다! 또한 &lt;code&gt;index.html.eex&lt;/code&gt; 파일이 하나의 &lt;code&gt;div&lt;/code&gt; 태그 로만 구성 되었음에도 불구하고 우리 가 얻는 페이지는 완전한 HTML 문서입니다. 우리의 인덱스 템플릿은 애플리케이션 레이아웃 ( &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; )으로 렌더링 됩니다. 열면 다음과 같은 줄이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7cfb6706dad4ed0adea156a71a400336e56fc4b3" translate="yes" xml:space="preserve">
          <source>There are a few things that can go wrong with &lt;code&gt;ecto.create&lt;/code&gt;. If our Postgres database doesn't have a &quot;postgres&quot; role (user), we'll get an error like this one.</source>
          <target state="translated">&lt;code&gt;ecto.create&lt;/code&gt; 에서 잘못 될 수있는 몇 가지 사항이 있습니다 . Postgres 데이터베이스에 &quot;postgres&quot;역할 (사용자)이 없으면 이와 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0dcdee5113beb075e0f94cbe43ea0dc06f75667" translate="yes" xml:space="preserve">
          <source>There are a number of places to connect with community members at all experience levels.</source>
          <target state="translated">모든 경험 수준에서 커뮤니티 회원과 연결할 수있는 여러 장소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c1b86b915cfde7a7368137f0a2e48d4add28c22" translate="yes" xml:space="preserve">
          <source>There are also optional packages depending on your configuration:</source>
          <target state="translated">구성에 따라 옵션 패키지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e7b53c5d965f68485b3ddac277b810c18b5b6b" translate="yes" xml:space="preserve">
          <source>There are also use cases which are a bad fit for LiveView:</source>
          <target state="translated">LiveView에 적합하지 않은 사용 사례도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7d6ee807af67ee19de04b8ba6fe4bb0e14f07b" translate="yes" xml:space="preserve">
          <source>There are currently a number of built-in Phoenix-specific and Ecto-specific mix tasks available to us within a newly-generated application. We can also create our own application specific tasks.</source>
          <target state="translated">현재 새로 생성 된 애플리케이션 내에서 사용할 수있는 내장형 Phoenix 특정 및 Ecto 특정 혼합 작업이 많이 있습니다. 또한 자체 애플리케이션 별 작업을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4de1bab3bcb78d7de2f1a97fb1645a22d989827" translate="yes" xml:space="preserve">
          <source>There are just a few more things we need to do to make this work. We need to tell our router that it should accept the &lt;code&gt;text&lt;/code&gt; format. We do that by adding &lt;code&gt;text&lt;/code&gt; to the list of accepted formats in the &lt;code&gt;:browser&lt;/code&gt; pipeline. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; and change the &lt;code&gt;plug :accepts&lt;/code&gt; to include &lt;code&gt;text&lt;/code&gt; as well as &lt;code&gt;html&lt;/code&gt; like this.</source>
          <target state="translated">이 작업을 수행하기 위해해야 ​​할 일이 몇 가지 더 있습니다. 라우터에 &lt;code&gt;text&lt;/code&gt; 형식을 허용해야한다고 알려야 합니다. &lt;code&gt;:browser&lt;/code&gt; 파이프 라인 에서 허용되는 형식 목록에 &lt;code&gt;text&lt;/code&gt; 를 추가하면 됩니다 . &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 를 열고 다음 과 같이 &lt;code&gt;html&lt;/code&gt; 뿐만 아니라 &lt;code&gt;text&lt;/code&gt; 도 포함 하도록 &lt;code&gt;plug :accepts&lt;/code&gt; 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6f91d0d9ce57177167c4420ce8468f849e7c8d5c" translate="yes" xml:space="preserve">
          <source>There are many more validations and transformations we can perform in a changeset. Please see the &lt;a href=&quot;../ecto/ecto.changeset&quot;&gt;Ecto Changeset documentation&lt;/a&gt; for more information.</source>
          <target state="translated">변경 집합에서 수행 할 수있는 더 많은 유효성 검사 및 변환이 있습니다. 자세한 내용은 &lt;a href=&quot;../ecto/ecto.changeset&quot;&gt;Ecto Changeset 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e051d2e913fcf9b1ffdbc95cb07006f322d1bf3e" translate="yes" xml:space="preserve">
          <source>There are many use cases where LiveView is an excellent fit right now:</source>
          <target state="translated">현재 LiveView가 매우 적합한 사용 사례가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6aa20209cea63d81eee09d733072aab9dc644cb" translate="yes" xml:space="preserve">
          <source>There are numerous reporters available, for services like StatsD, Prometheus, and more. You can find them by searching for &quot;telemetry_metrics&quot; on &lt;a href=&quot;https://hex.pm/packages?search=telemetry_metrics&quot;&gt;hex.pm&lt;/a&gt;.</source>
          <target state="translated">StatsD, Prometheus 등과 같은 서비스에 사용할 수있는 수많은 리포터가 있습니다. &lt;a href=&quot;https://hex.pm/packages?search=telemetry_metrics&quot;&gt;hex.pm&lt;/a&gt; 에서 &quot;telemetry_metrics&quot;를 검색하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fd294c0e0edd78bdfd8fba29d9ae777edf871" translate="yes" xml:space="preserve">
          <source>There are other HTTP verbs. For example, submitting a form typically uses the POST verb.</source>
          <target state="translated">다른 HTTP 동사가 있습니다. 예를 들어, 양식 제출은 일반적으로 POST 동사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="86d080ada9c12b95f9c19b53c77166860854b8a2" translate="yes" xml:space="preserve">
          <source>There are times when we need to communicate with users during the course of an action. Maybe there was an error updating a schema. Maybe we just want to welcome them back to the application. For this, we have flash messages.</source>
          <target state="translated">작업 과정에서 사용자와 소통해야하는 경우가 있습니다. 스키마를 업데이트하는 중에 오류가 발생했을 수 있습니다. 어쩌면 우리는 그들이 응용 프로그램에 다시 오신 것을 환영하고 싶을 수도 있습니다. 이를 위해 플래시 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa6f049cdcc785decf9d1331374c9b1898ba4cc" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls to keep in mind when using the &lt;code&gt;~L&lt;/code&gt; sigil or &lt;code&gt;.leex&lt;/code&gt; templates.</source>
          <target state="translated">&lt;code&gt;~L&lt;/code&gt; 시길 또는 &lt;code&gt;.leex&lt;/code&gt; 템플릿을 사용할 때 염두에 두어야 할 두 가지 일반적인 함정이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6807336b45c24ae9dbef79351d2099a68159d0ed" translate="yes" xml:space="preserve">
          <source>There are two kind of plugs: function plugs and module plugs.</source>
          <target state="translated">플러그에는 기능 플러그와 모듈 플러그의 두 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea848af2e953be99cd126902e2324fb347af163" translate="yes" xml:space="preserve">
          <source>There are two main mechanisms for testing components. To test stateless components or just a regular rendering of a component, one can use &lt;a href=&quot;#render_component/2&quot;&gt;&lt;code&gt;render_component/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">구성 요소를 테스트하기위한 두 가지 주요 메커니즘이 있습니다. 상태 비 저장 구성 요소 또는 구성 요소의 일반 렌더링을 테스트하려면 &lt;a href=&quot;#render_component/2&quot;&gt; &lt;code&gt;render_component/2&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e1dd6c129ab09fcb3871f141a18dd6dd0425035" translate="yes" xml:space="preserve">
          <source>There are two types of telemetry events. The ones emitted by Ecto and the ones that are adapter specific.</source>
          <target state="translated">두 가지 유형의 원격 분석 이벤트가 있습니다. Ecto에서 내 보낸 것 및 어댑터별로 발생하는 것.</target>
        </trans-unit>
        <trans-unit id="0c3abfdacb3ac569bf8db5e65409f9dce9bb486d" translate="yes" xml:space="preserve">
          <source>There are two ways to define primary keys in Ecto: using the &lt;code&gt;@primary_key&lt;/code&gt; module attribute and using &lt;code&gt;primary_key: true&lt;/code&gt; as option for &lt;a href=&quot;#field/3&quot;&gt;&lt;code&gt;field/3&lt;/code&gt;&lt;/a&gt; in your schema definition. They are not mutually exclusive and can be used together.</source>
          <target state="translated">Ecto에서 기본 키를 정의하는 방법에는 &lt;code&gt;@primary_key&lt;/code&gt; 모듈 속성을 사용하는 방법과 &lt;code&gt;primary_key: true&lt;/code&gt; 를 스키마 정의의 &lt;a href=&quot;#field/3&quot;&gt; &lt;code&gt;field/3&lt;/code&gt; &lt;/a&gt; 옵션으로 사용하는 두 가지 방법이 있습니다 . 상호 배타적이지 않으며 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e7530f090b66e3b01b4d280637820412cb520f" translate="yes" xml:space="preserve">
          <source>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema. If select is given more than once, an error is raised. Use &lt;a href=&quot;#exclude/2&quot;&gt;&lt;code&gt;exclude/2&lt;/code&gt;&lt;/a&gt; if you would like to remove a previous select for overriding or see &lt;a href=&quot;#select_merge/3&quot;&gt;&lt;code&gt;select_merge/3&lt;/code&gt;&lt;/a&gt; for a limited version of &lt;code&gt;select&lt;/code&gt; that is composable and can be called multiple times.</source>
          <target state="translated">쿼리에는 하나의 select 식만있을 수 있습니다. select 식을 생략하면 쿼리는 기본적으로 전체 스키마를 선택합니다. select가 두 번 이상 주어지면 오류가 발생합니다. 재정의를 위해 이전 선택을 제거 하려면 &lt;a href=&quot;#exclude/2&quot;&gt; &lt;code&gt;exclude/2&lt;/code&gt; &lt;/a&gt; 사용 하거나 &lt;a href=&quot;#select_merge/3&quot;&gt; &lt;code&gt;select_merge/3&lt;/code&gt; &lt;/a&gt; 가능하고 여러 번 호출 할 수 있는 제한된 &lt;code&gt;select&lt;/code&gt; 버전에 대해서는 select_merge / 3 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c88e179b2c1fdccf0ace5889abb511cec846bf3" translate="yes" xml:space="preserve">
          <source>There is a fourth &lt;code&gt;router_opts&lt;/code&gt; argument that can be passed. These options are outlined in the &lt;a href=&quot;phoenix.router#scope/2&quot;&gt;&lt;code&gt;Phoenix.Router.scope/2&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">전달할 수 있는 네 번째 &lt;code&gt;router_opts&lt;/code&gt; 인수가 있습니다. 이러한 옵션은 &lt;a href=&quot;phoenix.router#scope/2&quot;&gt; &lt;code&gt;Phoenix.Router.scope/2&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60774986335f094648654b82d018e24c6920015b" translate="yes" xml:space="preserve">
          <source>There is an example of working with changesets in the introductory documentation in the &lt;a href=&quot;ecto&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; module. The functions &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#change/2&quot;&gt;&lt;code&gt;change/2&lt;/code&gt;&lt;/a&gt; are the usual entry points for creating changesets. The first one is used to cast and validate external parameters, such as parameters sent through a form, API, command line, etc. The second one is used to change data directly from your application.</source>
          <target state="translated">&lt;a href=&quot;ecto&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; &lt;/a&gt; 모듈 의 소개 문서에 변경 세트로 작업하는 예가 있습니다 . &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#change/2&quot;&gt; &lt;code&gt;change/2&lt;/code&gt; &lt;/a&gt; 함수 는 변경 세트 작성을위한 일반적인 진입 점입니다. 첫 번째는 폼, API, 명령 행 등을 통해 전송 된 매개 변수와 같은 외부 매개 변수를 캐스트하고 유효성 검증하는 데 사용됩니다. 두 번째는 애플리케이션에서 직접 데이터를 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c51bdfb925eab670614cd9390b950e516f949e0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more that Ecto can do and we've only barely scratched the surface. With a solid Ecto foundation in place, we're now ready to continue building our app and integrate the web facing application with our backend persistence. Along the way, we'll expand our Ecto knowledge and learn how to properly isolate our web interface from the underlying details of our system. Please take a look at the &lt;a href=&quot;../ecto/index&quot;&gt;Ecto documentation&lt;/a&gt; for the rest of the story.</source>
          <target state="translated">Ecto가 할 수있는 일이 훨씬 더 많으며 우리는 표면을 거의 긁지 않았습니다. 견고한 Ecto 기반이 마련되었으므로 이제 앱을 계속 빌드하고 웹 지향 애플리케이션을 백엔드 지속성과 통합 할 준비가되었습니다. 그 과정에서 Ecto 지식을 확장하고 시스템의 기본 세부 정보에서 웹 인터페이스를 적절하게 분리하는 방법을 배울 것입니다. 나머지 이야기 는 &lt;a href=&quot;../ecto/index&quot;&gt;Ecto 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00efdd6792388b25c72cb1b0a5d138f97391c9b0" translate="yes" xml:space="preserve">
          <source>There's a bit of a code here, so let's break it down. First, we rewrote the &lt;code&gt;create_page&lt;/code&gt; function to require a &lt;code&gt;CMS.Author&lt;/code&gt; struct, which represents the author publishing the post. We then take our changeset and pass it to &lt;code&gt;Ecto.Changeset.put_change/2&lt;/code&gt; to place the &lt;code&gt;author_id&lt;/code&gt; association in the changeset. Next, we use &lt;code&gt;Repo.insert&lt;/code&gt; to insert the new page into the database, containing our associated &lt;code&gt;author_id&lt;/code&gt;.</source>
          <target state="translated">여기에 약간의 코드가 있습니다. 그래서 그것을 분해 해 보겠습니다. 먼저 게시물을 게시하는 작성자를 나타내는 &lt;code&gt;CMS.Author&lt;/code&gt; 구조체 를 요구하도록 &lt;code&gt;create_page&lt;/code&gt; 함수를 다시 작성 했습니다. 그런 다음 변경 세트를 &lt;code&gt;Ecto.Changeset.put_change/2&lt;/code&gt; 에 전달 하여 변경 세트에 &lt;code&gt;author_id&lt;/code&gt; 연관 을 배치합니다 . 다음으로 &lt;code&gt;Repo.insert&lt;/code&gt; 를 사용 하여 연관된 &lt;code&gt;author_id&lt;/code&gt; 가 포함 된 새 페이지를 데이터베이스에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="bd27e2a8e827fa726136e1148022cbcd8bbab3bf" translate="yes" xml:space="preserve">
          <source>There's more documentation than code here, but a couple of things are important to highlight. First, we can see again that our Ecto Repo is used under the hood for database access. You probably also noticed the call to &lt;code&gt;User.changeset/2&lt;/code&gt;. We talked about changesets before, and now we see them in action in our context.</source>
          <target state="translated">여기에는 코드보다 더 많은 문서가 있지만 강조해야 할 몇 가지 중요한 사항이 있습니다. 먼저 Ecto Repo가 데이터베이스 액세스를 위해 내부에서 사용된다는 것을 다시 볼 수 있습니다. &lt;code&gt;User.changeset/2&lt;/code&gt; 에 대한 호출도 눈치 채 셨을 것입니다 . 우리는 이전에 변경 세트에 대해 이야기했지만 지금은 우리의 맥락에서 실제로 작동하는 것을 봅니다.</target>
        </trans-unit>
        <trans-unit id="100960a1d19b2df147cb0c67cb03d0ef859b8a72" translate="yes" xml:space="preserve">
          <source>Therefore it is your responsibility to keep only the assigns necessary in each component. For example, avoid passing all of LiveView components when rendering a component:</source>
          <target state="translated">따라서 각 구성 요소에 필요한 할당 만 유지하는 것은 귀하의 책임입니다. 예를 들어 구성 요소를 렌더링 할 때 모든 LiveView 구성 요소를 전달하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bbbe69bd2d1d3f33a0989c0c7daf1e4f17426993" translate="yes" xml:space="preserve">
          <source>Therefore, if you get a warning that the host does not match, it is either because someone is attempting to steal CSRF tokens or because you have a misconfigured host configuration.</source>
          <target state="translated">따라서 호스트가 일치하지 않는다는 경고가 표시되면 누군가 CSRF 토큰을 훔치려 고하거나 호스트 구성이 잘못 구성되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3748dac854496bc8faac9591f1822a153d556a4a" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s that are able to filter and properly cast external data:</source>
          <target state="translated">따라서 외부 데이터로 작업하고 조작 할 때는 외부 데이터 를 필터링하고 올바르게 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 수있는 Ecto.Changeset 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7e8893d85340fc3862c12874dc8c0caa638bca11" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;'s that are able to filter and properly cast external data:</source>
          <target state="translated">따라서 외부 데이터로 작업하고 조작 할 때 외부 데이터 를 필터링하고 적절하게 캐스팅 할 수있는 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d4b6dd62855c1cdb8d6d7226945af7408045cf45" translate="yes" xml:space="preserve">
          <source>These attributes are:</source>
          <target state="translated">이러한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dab402ac1558a423d6bfdf184cdcba60e59a9b1c" translate="yes" xml:space="preserve">
          <source>These fields are reserved for libraries/framework usage.</source>
          <target state="translated">이 필드는 라이브러리 / 프레임 워크 사용을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="31125242793acf4be0a0cc8a21b6685bbae8a6a2" translate="yes" xml:space="preserve">
          <source>These fields contain request information:</source>
          <target state="translated">이 필드에는 요청 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c58c3f5a32cf2cabf47af4ce6c2874bf3d0f839" translate="yes" xml:space="preserve">
          <source>These fields contain response information:</source>
          <target state="translated">이 필드에는 응답 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bf47d1305fab6c065239130eb679be1db4d2859" translate="yes" xml:space="preserve">
          <source>These guides focus on LiveView bindings and client-side integration:</source>
          <target state="translated">이 가이드는 LiveView 바인딩 및 클라이언트 측 통합에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="e13968d858a6aa2228deefd19ee03e436119ab45" translate="yes" xml:space="preserve">
          <source>These guides focus on server-side functionality:</source>
          <target state="translated">이 가이드는 서버 측 기능에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="ef711a090a295d12005974a4d06b792bb140e9c3" translate="yes" xml:space="preserve">
          <source>These options are assigned to &lt;code&gt;:private&lt;/code&gt; in the call&amp;rsquo;s &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 호출의 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;:private&lt;/code&gt; 에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="24e9ee2f9ab53061b515ecbc4fb47faf1d9a6a50" translate="yes" xml:space="preserve">
          <source>Thinking about design</source>
          <target state="translated">디자인에 대한 생각</target>
        </trans-unit>
        <trans-unit id="59fd20a59fd71306464f90cbc93687125b053059" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;:through&lt;/code&gt; association will return all authors for all comments that belongs to that post:</source>
          <target state="translated">이 &lt;code&gt;:through&lt;/code&gt; 협회는 해당 게시물에 속한 모든 댓글에 대한 모든 작성자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4199b4f5db3f20ec0146877224956a5aadb69e6f" translate="yes" xml:space="preserve">
          <source>This ability to introspect HTTP requests is really powerful -- and this is but one of &lt;em&gt;many&lt;/em&gt; telemetry events emitted by the Phoenix framework! We'll discuss more of these events, as well as specific patterns for extracting valuable data from Phoenix/Plug events in the &lt;a href=&quot;#phoenix-metrics&quot;&gt;Phoenix Metrics&lt;/a&gt; section later in this guide.</source>
          <target state="translated">HTTP 요청을 검사하는이 기능은 정말 강력합니다. 이것은 Phoenix 프레임 워크에서 발생하는 &lt;em&gt;많은&lt;/em&gt; 원격 분석 이벤트 중 하나 일뿐입니다! 이 가이드의 뒷부분에 있는 &lt;a href=&quot;#phoenix-metrics&quot;&gt;Phoenix 메트릭&lt;/a&gt; 섹션에서 이러한 이벤트와 Phoenix / Plug 이벤트에서 중요한 데이터를 추출하기위한 특정 패턴에 대해 더 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="007291854548be2f362800441309464462d301ce" translate="yes" xml:space="preserve">
          <source>This adapter uses the following endpoint configuration:</source>
          <target state="translated">이 어댑터는 다음 엔드 포인트 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0c1e7b1a6546a0da231a6c048940c7137b1d0c8" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;.leex&lt;/code&gt; templates to drastically optimize the data sent by comprehensions, as the static parts are emitted only once, regardless of the number of items.</source>
          <target state="translated">이를 통해 &lt;code&gt;.leex&lt;/code&gt; 템플릿은 항목 수에 관계없이 정적 부분이 한 번만 방출되기 때문에 comprehensions에서 보낸 데이터를 대폭 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="314e0a3a76540d899cae17754d71892826cfdce8" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">이를 통해 개발자는 Ecto에서 오는 값을 어댑터 값으로 올바르게 변환 할 수 있습니다. 예를 들어, 데이터베이스가 부울을 지원하지 않고 대신 0과 1을 리턴하면 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34b4dd019d2b68a7383ace93f2215401ec4cad3" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">이를 통해 개발자는 어댑터에서 나오는 값을 Ecto 값으로 올바르게 변환 할 수 있습니다. 예를 들어, 데이터베이스가 부울을 지원하지 않고 대신 0과 1을 리턴하면 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb97fed7c5bb051af51293923cd1d414d840c2fd" translate="yes" xml:space="preserve">
          <source>This approach is useful when both username and password are specified upfront and available at runtime. However, you may also want to compute a different password for each different user. In those cases, we can use the low-level API.</source>
          <target state="translated">이 접근 방식은 사용자 이름과 암호를 모두 미리 지정하고 런타임에 사용할 수있는 경우에 유용합니다. 그러나 각 사용자에 대해 다른 암호를 계산할 수도 있습니다. 이 경우 저수준 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9069e4b8ffaf3bc20294b7bd6a863e30171a4d03" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query.</source>
          <target state="translated">이 방법을 사용하면 쿼리를 작성할 때 바인딩 위치를 추적 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="78e0d97646f179af897c91029155ab3de9f02b8b" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query. The &lt;code&gt;:as&lt;/code&gt; option can be given both on joins and on &lt;code&gt;from&lt;/code&gt;:</source>
          <target state="translated">이 접근 방식을 사용하면 쿼리를 작성할 때 바인딩 위치를 추적하는 것에 대해 걱정할 필요가 없습니다. &lt;code&gt;:as&lt;/code&gt; 옵션이 조인과에 모두 부여 할 수 &lt;code&gt;from&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f59bfe0a957636ece0be8bfd839e81d84f8f0ae" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and a module that implements the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour that uses &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; to broadcast presence updates.</source>
          <target state="translated">이 동작은 주어진 주제에 대한 현재 상태 가져 오기와 같은 현재 상태 기능을 제공하고 실시간으로 발생하는 참여 및 탈퇴 이벤트의 차이를 처리합니다. 이 모듈을 사용하여 감독자 및 모듈을 정의하는 구현하는 &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; 의&lt;/a&gt; 사용 행동 &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 을&lt;/a&gt; 방송 존재 업데이트에.</target>
        </trans-unit>
        <trans-unit id="6967adaf22d337178372537c6118e0d2b8a63bd3" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and allows the calling module to implement the &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour which starts a tracker process to handle presence information.</source>
          <target state="translated">이 동작은 특정 토픽에 대한 프레즌스 가져 오기와 같은 프레즌스 기능을 제공 할뿐만 아니라 실시간으로 발생하는 조인 및 휴가 이벤트의 차이를 처리합니다. 이 모듈을 사용하면 감독자를 정의하고 호출 모듈 이 추적 정보 프로세스를 시작하여 현재 상태 정보를 처리하는 &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 동작 을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21363635aabca14d08079e73432c541e1ab7506" translate="yes" xml:space="preserve">
          <source>This block is only executed in development. It enables live reloading (if you change a CSS file, they are updated in-browser without refreshing the page), code reloading (so we can see changes to our application without restarting the server), and check repo status (which makes sure our database is up to date, raising readable and actionable error otherwise).</source>
          <target state="translated">이 블록은 개발 중에 만 실행됩니다. 라이브 리로딩 (CSS 파일을 변경하면 페이지를 새로 고치지 않고 브라우저에서 업데이트 됨), 코드 리로딩 (서버를 다시 시작하지 않고도 애플리케이션의 변경 사항을 볼 수 있음) 및 리포지토리 상태를 확인할 수 있습니다. 데이터베이스가 최신 상태이므로 읽을 수 있고 실행 가능한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7556041936c271690740591770bfe1ea6222272" translate="yes" xml:space="preserve">
          <source>This callback can be used to further modify the query and options before it is transformed and sent to the database.</source>
          <target state="translated">이 콜백은 쿼리 및 옵션이 변환되어 데이터베이스로 전송되기 전에 추가로 수정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5289f3895306f4a2bb2ce650d1609e9b79d9c7" translate="yes" xml:space="preserve">
          <source>This callback is called on external input and can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value into an Ecto native type. There are two situations where this callback is called:</source>
          <target state="translated">이 콜백은 외부 입력에서 호출되며 &lt;code&gt;dump/1&lt;/code&gt; 함수가 리턴 된 값을 Ecto 기본 유형으로 변환 할 수 있는 한 모든 유형을 리턴 할 수 있습니다 . 이 콜백이 호출되는 상황은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="f6d40809f5928ded0783d1c5bde4c2ca0dacdca6" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receive an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="translated">이 콜백은 데이터베이스에서 데이터를로드하고 Ecto 기본 유형을 수신 할 때 호출됩니다. &lt;code&gt;dump/1&lt;/code&gt; 함수가 리턴 된 값을 Ecto 기본 유형으로 다시 변환 할 수 있는 한 모든 유형을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dba0f0e5df500a1e88b72d27d9b478ed2ccb47c" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receives an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="translated">이 콜백은 데이터베이스에서 데이터를로드 할 때 호출되고 Ecto 기본 유형을 수신합니다. &lt;code&gt;dump/1&lt;/code&gt; 함수가 반환 된 값을 Ecto 네이티브 유형으로 다시 변환 할 수 있는 한 모든 유형을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8391fe8b307eb118c66a1224a190e367cf1e34a5" translate="yes" xml:space="preserve">
          <source>This callback is called with any term that was stored in the struct and it needs to validate them and convert it to an Ecto native type.</source>
          <target state="translated">이 콜백은 구조체에 저장된 용어로 호출되며이를 검증하고 Ecto 기본 유형으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bf00040ea79807475cd31c46b891cb8ded6c579" translate="yes" xml:space="preserve">
          <source>This callback is invoked as the entry point for all repository operations. For example, if you are executing a query with preloads, this callback will be invoked once at the beginning, but the options returned here will be passed to all following operations.</source>
          <target state="translated">이 콜백은 모든 저장소 작업의 진입 점으로 호출됩니다. 예를 들어 사전로드를 사용하여 쿼리를 실행하는 경우이 콜백은 처음에 한 번 호출되지만 여기에 반환 된 옵션은 다음 모든 작업에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="79748d4f4c53c8b678eba754fd8a33ed0dc52111" translate="yes" xml:space="preserve">
          <source>This callback is invoked for all query APIs, including the &lt;code&gt;stream&lt;/code&gt; function, but it is not invoked for &lt;code&gt;insert_all&lt;/code&gt; nor any of the schema functions.</source>
          <target state="translated">이 콜백은 &lt;code&gt;stream&lt;/code&gt; 함수를 포함한 모든 쿼리 API에 대해 호출 되지만 &lt;code&gt;insert_all&lt;/code&gt; 이나 스키마 함수에 대해서는 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b997bebb99d88139d7659f0af87669f8dfb97d13" translate="yes" xml:space="preserve">
          <source>This can be used during tests:</source>
          <target state="translated">테스트 중에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dd66370a2871bfe63d6fef51a35166fbee8602" translate="yes" xml:space="preserve">
          <source>This can be used to load CSRF state into another process. See &lt;a href=&quot;#dump_state/0&quot;&gt;&lt;code&gt;dump_state/0&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;dump_state_from_session/2&lt;/code&gt; for dumping it.</source>
          <target state="translated">CSRF 상태를 다른 프로세스로로드하는 데 사용할 수 있습니다. 덤프에 대해서는 &lt;a href=&quot;#dump_state/0&quot;&gt; &lt;code&gt;dump_state/0&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;dump_state_from_session/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9942f198e47ea544c82a2f3149eb4db211bc77f7" translate="yes" xml:space="preserve">
          <source>This can be used to provide default values per operation that have higher precedence than the values given on configuration or when starting the repository. It can also be used to set query specific options, such as &lt;code&gt;:prefix&lt;/code&gt;.</source>
          <target state="translated">이는 구성에 지정된 값보다 우선 순위가 더 높은 작업 당 기본값을 제공하거나 저장소를 시작할 때 사용할 수 있습니다. 또한 &lt;code&gt;:prefix&lt;/code&gt; 와 같은 쿼리 특정 옵션을 설정하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7451f29af9970208fd48c0f77d572d71c9c6abab" translate="yes" xml:space="preserve">
          <source>This can be useful to implement nested layouts. For example, imagine you have an application layout like this:</source>
          <target state="translated">이는 중첩 된 레이아웃을 구현하는 데 유용 할 수 있습니다. 예를 들어 다음과 같은 애플리케이션 레이아웃이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="04c8c29b8e1afac3fcab4f5358a3e87060ee714f" translate="yes" xml:space="preserve">
          <source>This component is never meant to be output directly into the template. It should always be handled by the diffing algorithm.</source>
          <target state="translated">이 구성 요소는 템플릿에 직접 출력 할 수 없습니다. 항상 diffing 알고리즘에 의해 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="36cde890ab9fc7b08ed69780233aa5e8d306807f" translate="yes" xml:space="preserve">
          <source>This converts the given embedded schema to a map to be serialized with the given format. For example:</source>
          <target state="translated">이것은 주어진 임베디드 스키마를 주어진 형식으로 직렬화 할 맵으로 변환합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fffb99485473cd5f2890d8e671445895fea64111" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can&amp;rsquo;t be read nor tampered with.</source>
          <target state="translated">이 쿠키 저장소는 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt; &lt;/a&gt; 를 기반으로 하며 쿠키를 읽거나 조작 할 수 없도록 각 쿠키를 암호화하고 서명합니다.</target>
        </trans-unit>
        <trans-unit id="53b55df014db1d36aa928a0d1ab68e9498d7f04f" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can't be read nor tampered with.</source>
          <target state="translated">이 쿠키 저장소는 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageVerifier.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageEncryptor.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt; &lt;/a&gt; 를 기반으로 하며 각 쿠키를 암호화하고 서명하여 읽거나 변경할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="88f415484d2416f0c9164e685095abeddba09475" translate="yes" xml:space="preserve">
          <source>This does not expect the repository and therefore does not leverage the cache.</source>
          <target state="translated">이것은 리포지토리를 기대하지 않으므로 캐시를 활용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee92ad563023f60c952d3ce1d1e4f1a71f755d06" translate="yes" xml:space="preserve">
          <source>This doesn't correspond to any action in our controller, which is fine. We'll exercise it in an &lt;code&gt;iex&lt;/code&gt; session. At the root of our project, we can run &lt;code&gt;iex -S mix&lt;/code&gt;, and then explicitly render our template.</source>
          <target state="translated">이것은 우리 컨트롤러의 어떤 행동과도 일치하지 않습니다. &lt;code&gt;iex&lt;/code&gt; 세션 에서 연습 할 것입니다 . 프로젝트의 루트에서 &lt;code&gt;iex -S mix&lt;/code&gt; 를 실행 한 다음 템플릿을 명시 적으로 렌더링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8358ce5c448165474c59ccb6634f95fedb0d2fb6" translate="yes" xml:space="preserve">
          <source>This emulates behaviour performed by browsers where cookies returned in the response are available in following requests.</source>
          <target state="translated">이는 응답에서 반환 된 쿠키가 다음 요청에서 사용 가능한 브라우저에서 수행되는 동작을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="fa7d6e6dcda78ceca060025cce3f5837a513f835" translate="yes" xml:space="preserve">
          <source>This event should be invoked on every query sent to the adapter, including queries that are related to the transaction management.</source>
          <target state="translated">이 이벤트는 트랜잭션 관리와 관련된 쿼리를 포함하여 어댑터로 전송되는 모든 쿼리에서 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c0c41eb119619d93df37edc66780e62d9f72d4b1" translate="yes" xml:space="preserve">
          <source>This exception is commonly raised by &lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt;&lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt;&lt;/a&gt; which negotiates the media types the server is able to serve with the contents the client is able to render.</source>
          <target state="translated">이 예외는 일반적으로 &lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt; &lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt; 에&lt;/a&gt; 의해 발생하며 , 클라이언트가 렌더링 할 수있는 내용으로 서버가 제공 할 수있는 미디어 유형을 협상합니다.</target>
        </trans-unit>
        <trans-unit id="e27c88fc5d1a3d0121b169f096d2ac516c60e1ae" translate="yes" xml:space="preserve">
          <source>This exception is raised by &lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt;&lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt;&lt;/a&gt; which:</source>
          <target state="translated">이 예외는 &lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt; &lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt; 에&lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0fa6cbcebc05c777d1c7368f7969366f4e084a6c" translate="yes" xml:space="preserve">
          <source>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</source>
          <target state="translated">이 기능은 웹 검색 양식, CLI 등과 같은 일부 사용자 입력을 기반으로 쿼리를 작성해야 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="736fb0a01b93ff59374b8773d572c0d61a1c4bf4" translate="yes" xml:space="preserve">
          <source>This first group contains validations that take a keyword list of validators, where the validators are shown immediately following the validation type. This list may also include a &lt;code&gt;message:&lt;/code&gt; key.</source>
          <target state="translated">이 첫 번째 그룹에는 유효성 검사기의 키워드 목록을 사용하는 유효성 검사가 포함되어 있으며 유효성 검사기는 유효성 검사 유형 바로 뒤에 표시됩니다. 이 목록에는 &lt;code&gt;message:&lt;/code&gt; key 도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08a01cc9d2b834ac5065ca0c4859bc17a52873c2" translate="yes" xml:space="preserve">
          <source>This format is used when rendering a template as an atom. For example, &lt;code&gt;render(conn, :foo)&lt;/code&gt; will render &lt;code&gt;&quot;foo.FORMAT&quot;&lt;/code&gt; where the format is the one set here. The default format is typically set from the negotiation done in &lt;a href=&quot;#accepts/2&quot;&gt;&lt;code&gt;accepts/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 형식은 템플릿을 원자로 렌더링 할 때 사용됩니다. 예를 들어 &lt;code&gt;render(conn, :foo)&lt;/code&gt; 는 &lt;code&gt;&quot;foo.FORMAT&quot;&lt;/code&gt; 을 렌더링 합니다. 여기서 형식은 여기에 설정된 형식입니다. 기본 형식은 일반적으로 &lt;a href=&quot;#accepts/2&quot;&gt; &lt;code&gt;accepts/2&lt;/code&gt; &lt;/a&gt; 에서 수행 된 협상에서 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a654e5931463e5b13804f19ebe7438789fab9cac" translate="yes" xml:space="preserve">
          <source>This function accepts all options defined &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;in Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;Erlang / OTP &lt;code&gt;:ssl&lt;/code&gt; 문서에&lt;/a&gt; 정의 된 모든 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="1b203fe59546a0ae658a9d0fdb623d409065b4b9" translate="yes" xml:space="preserve">
          <source>This function accepts and validates all options defined in &lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt;the &lt;code&gt;ssl&lt;/code&gt; erlang module&lt;/a&gt;. With the following additions:</source>
          <target state="translated">이 기능은 받아들이고에 정의 된 모든 옵션의 유효성을 확인 &lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 얼랑 모듈을 . 다음이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff98681cd9fee831827f27fd0a9d833563a2d938" translate="yes" xml:space="preserve">
          <source>This function allows you to automatically sign and encrypt cookies. When signing or encryption is enabled, then any Elixir value can be stored in the cookie (except anonymous functions for security reasons). Once a value is signed or encrypted, you must also call &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt; with the name of the cookies that are either signed or encrypted.</source>
          <target state="translated">이 기능을 사용하면 쿠키에 자동으로 서명하고 암호화 할 수 있습니다. 서명 또는 암호화가 활성화되면 모든 Elixir 값이 쿠키에 저장 될 수 있습니다 (보안상의 이유로 익명 함수 제외). 값이 서명되거나 암호화되면 서명 또는 암호화 된 쿠키 이름으로 &lt;a href=&quot;#fetch_cookies/2&quot;&gt; &lt;code&gt;fetch_cookies/2&lt;/code&gt; &lt;/a&gt; 도 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8560ae300306496e1e57a607297b4be5809ada0e" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#dump/2&quot;&gt;&lt;code&gt;dump/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;dumper&lt;/code&gt; function is used.</source>
          <target state="translated">이 함수 는 지정된 &lt;code&gt;dumper&lt;/code&gt; 기능이 사용되는 복합 유형을 제외하고 &lt;a href=&quot;#dump/2&quot;&gt; &lt;code&gt;dump/2&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="6a586051ba535bcfaa3ec3caebe587edd887bffe" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;loader&lt;/code&gt; function is used.</source>
          <target state="translated">이 함수 는 주어진 &lt;code&gt;loader&lt;/code&gt; 함수가 사용되는 복합 유형을 제외하고 &lt;a href=&quot;#load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e50d6767dc020a64e6d3d29750a6078f1a51289d" translate="yes" xml:space="preserve">
          <source>This function can also be used to dynamically load through associations by giving it a list. For example, to get all authors for all comments for the given posts, do:</source>
          <target state="translated">이 함수는 또한 목록을 제공하여 연관을 통해 동적으로로드하는 데 사용될 수 있습니다. 예를 들어, 주어진 게시물에 대한 모든 의견에 대한 모든 저자를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b31679aebb0e8c28069688039b1fa1e4998948f2" translate="yes" xml:space="preserve">
          <source>This function copies the cookie information in &lt;code&gt;old_conn&lt;/code&gt; into &lt;code&gt;new_conn&lt;/code&gt;, emulating multiple requests done by clients where cookies are always passed forward, and returns the new version of &lt;code&gt;new_conn&lt;/code&gt;.</source>
          <target state="translated">이러한 기능은 복사 쿠키 정보를 &lt;code&gt;old_conn&lt;/code&gt; 에 &lt;code&gt;new_conn&lt;/code&gt; 쿠키는 항상 앞으로 전달되는 클라이언트 및 반환의 새 버전에 의해 수행 여러 요청 모방, &lt;code&gt;new_conn&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1fe1674ac966f1e7e84fdd91a095f600ff50b42e" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when assets are pushed. Calling this function will clear the pushed message from the inbox for the process. To assert on multiple pushes, the result of the function should be stored in a variable.</source>
          <target state="translated">이 기능은 자산이 푸시 될 때 테스트 어댑터가 보낸 메시지를 수집하는 데 달려 있습니다. 이 기능을 호출하면 프로세스의받은 편지함에서 푸시 된 메시지가 지워집니다. 여러 번 푸시하려면 함수 결과를 변수에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="1660cbe1db7037c9964f911ded4eb4f26591a176" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when informational messages, such as an early hint, are sent. Calling this function will clear the informational request messages from the inbox for the process. To assert on multiple informs, the result of the function should be stored in a variable.</source>
          <target state="translated">이 기능은 초기 힌트와 같은 정보 메시지가 전송 될 때 테스트 어댑터가 전송 한 메시지를 수집하는 데 달려 있습니다. 이 함수를 호출하면 프로세스의받은 편지함에서 정보 요청 메시지가 지워집니다. 여러 정보에 대해 주장하려면 함수 결과를 변수에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9a8dbd1e103ae7949082890ccdcca71a8261b80" translate="yes" xml:space="preserve">
          <source>This function does not fetch parameters from the body. To fetch parameters from the body, use the &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug.</source>
          <target state="translated">이 함수는 본문에서 매개 변수를 가져 오지 않습니다. 본문에서 매개 변수를 가져 오려면 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 플러그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="20ea2b75919a9c3dd8b26d94997fe49393523498" translate="yes" xml:space="preserve">
          <source>This function does the following:</source>
          <target state="translated">이 기능은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c8689955a82c196a1de5806c3547594bd18663df" translate="yes" xml:space="preserve">
          <source>This function exists as an extension point for libraries to add new types of associations to Ecto. For the existing APIs, see &lt;a href=&quot;#belongs_to/3&quot;&gt;&lt;code&gt;belongs_to/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_many/3&quot;&gt;&lt;code&gt;has_many/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_one/3&quot;&gt;&lt;code&gt;has_one/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 라이브러리가 Ecto에 새로운 유형의 연관을 추가하기위한 확장 점으로 존재합니다. 기존 API의 경우 &lt;a href=&quot;#belongs_to/3&quot;&gt; &lt;code&gt;belongs_to/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#has_many/3&quot;&gt; &lt;code&gt;has_many/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#has_one/3&quot;&gt; &lt;code&gt;has_one/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; 를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2304f76a58fd59e742ef62114c970eef992a68" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won&amp;rsquo;t get corrupted.</source>
          <target state="translated">이 기능은 애플리케이션 사용자에게 빠른 피드백을 제공하기 위해 존재합니다. 경쟁 조건이 있으며 본질적으로 안전하지 않으므로 데이터 보증에 의존해서는 안됩니다. 예를 들어,이 확인이 같은 시간 간격으로 두 번 발생하면 (사용자가 양식을 두 번 제출했기 때문에) 두 확인이 모두 통과되어 데이터베이스에 중복 항목이 생길 수 있습니다. 따라서 &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 데이터가 손상되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc2d67a85e75f44fb49399d03fb1c45ee6231022" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won't get corrupted.</source>
          <target state="translated">이 기능은 애플리케이션 사용자에게 빠른 피드백을 제공하기 위해 존재합니다. 경쟁 조건이 있고 본질적으로 안전하지 않기 때문에 데이터 보증에 의존해서는 안됩니다. 예를 들어,이 검사가 동일한 시간 간격에 두 번 발생하면 (사용자가 양식을 두 번 제출했기 때문에) 두 검사가 모두 통과되어 데이터베이스에 중복 항목이 생길 수 있습니다. 따라서 데이터가 손상되지 않도록 &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; 도&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="73fef9a49538642527fff343bf96706313c19d33" translate="yes" xml:space="preserve">
          <source>This function expects the current schema, the association cardinality, the association name, the association module (that implements &lt;code&gt;Ecto.Association&lt;/code&gt; callbacks) and a keyword list of options.</source>
          <target state="translated">이 함수는 현재 스키마, 연관 카디널리티, 연관 이름, 연관 모듈 ( &lt;code&gt;Ecto.Association&lt;/code&gt; 콜백 을 구현 하는) 및 키워드 옵션 목록을 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="9dea39cef34defdfd207a8eb99802b8d948cd9f6" translate="yes" xml:space="preserve">
          <source>This function generates the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag without its closing part. Check &lt;a href=&quot;#form_tag/3&quot;&gt;&lt;code&gt;form_tag/3&lt;/code&gt;&lt;/a&gt; for generating an enclosing tag.</source>
          <target state="translated">이 함수 는 닫는 부분없이 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그를 생성합니다 . 둘러싸는 태그를 생성하려면 &lt;a href=&quot;#form_tag/3&quot;&gt; &lt;code&gt;form_tag/3&lt;/code&gt; &lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="53f40e7f6118a94a757813a716439f649282ffc1" translate="yes" xml:space="preserve">
          <source>This function is a shortcut for:</source>
          <target state="translated">이 기능은 다음에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="6306e2e81e647cdb91b3f8a11699265b79a2778b" translate="yes" xml:space="preserve">
          <source>This function is able to handle both chunked and identity transfer-encoding by default.</source>
          <target state="translated">이 기능은 기본적으로 청크 분할 및 신원 전송 인코딩을 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b953f4ee21fe94d4050f234c2003683ae8f4ad" translate="yes" xml:space="preserve">
          <source>This function is called at compile time, and should raise if invalid values are specified. It is idiomatic that the parameters returned from this are a map. &lt;code&gt;field&lt;/code&gt; and &lt;code&gt;schema&lt;/code&gt; will be injected into the options automatically.</source>
          <target state="translated">이 함수는 컴파일 타임에 호출되며 유효하지 않은 값이 지정되면 발생해야합니다. 여기에서 반환 된 매개 변수가지도라는 것은 관용적입니다. &lt;code&gt;field&lt;/code&gt; 와 &lt;code&gt;schema&lt;/code&gt; 가 옵션에 자동으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="fe83ec596d61f20f781d548aba70cef9549cb117" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application&amp;rsquo;s supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">애플리케이션이 기동 된 경우이 함수를 호출 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; (예컨대 그 위에,과 기능 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt; ). 이 기능은 응용 프로그램의 최상위 프로세스를 시작해야합니다 (응용 프로그램이 감독과 관련된 OTP 설계 원칙을 따르는 경우 응용 프로그램 감독 트리의 최고 감독자 여야 함).</target>
        </trans-unit>
        <trans-unit id="f40bd7c1cf4ae95315c3ffd80bd8b3a7c29506eb" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt; 와 같은 그 위에있는 함수)를 사용하여 응용 프로그램이 시작될 때 호출됩니다 . 이 기능은 애플리케이션의 최상위 프로세스를 시작해야합니다 (애플리케이션이 감독과 관련된 OTP 설계 원칙을 따르는 경우 애플리케이션 감독 트리의 최고 감독자가되어야 함).</target>
        </trans-unit>
        <trans-unit id="866cdfbc4d38507dc477d2b6e7b5a6b73c6d3bd8" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use reraise/1 or reraise/4 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. reraise / 1 또는 reraise / 4를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="889e6268cee5d42d732aa072ffb292fc6aa1faee" translate="yes" xml:space="preserve">
          <source>This function is especially useful when parsing raw query results:</source>
          <target state="translated">이 함수는 원시 쿼리 결과를 구문 분석 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1060a96b14370e1a1be3ad60f1c900dfde2028ca" translate="yes" xml:space="preserve">
          <source>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling &lt;a href=&quot;#render_submit/2&quot;&gt;&lt;code&gt;render_submit/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#render_change/2&quot;&gt;&lt;code&gt;render_change/2&lt;/code&gt;&lt;/a&gt;, see their docs for examples.</source>
          <target state="translated">이 기능은 사용자가 실제로 수행 할 수있는 작업을 모방하기위한 것이므로 숨겨진 입력 값을 설정할 수 없습니다. 그러나 &lt;a href=&quot;#render_submit/2&quot;&gt; &lt;code&gt;render_submit/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#render_change/2&quot;&gt; &lt;code&gt;render_change/2&lt;/code&gt; 를&lt;/a&gt; 호출 할 때 숨겨진 값을 제공 할 수 있습니다 . 예제는 해당 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f2fbdc7b6be0d3c0040fc63965553cbf76fdb977" translate="yes" xml:space="preserve">
          <source>This function is often called internally by adapters, such as Cowboy, to validate and set reasonable defaults for SSL handling. Therefore Plug users are not expected to invoke it directly, rather you pass the relevant SSL options to your adapter which then invokes this.</source>
          <target state="translated">이 기능은 종종 SSL과 같은 합리적인 기본값을 확인하고 설정하기 위해 카우보이와 같은 어댑터에 의해 내부적으로 호출됩니다. 따라서 플러그 사용자는 직접 호출하지 않아도되며 관련 SSL 옵션을 어댑터에 전달한 다음이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ce00aa1228b7b92a142997d61b397de721dd3451" translate="yes" xml:space="preserve">
          <source>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</source>
          <target state="translated">이 기능은 모든 연관 및 임베드를 순회하고 모든 오류를 일련의 중첩 된 맵에 배치하므로 변경 세트에서 연관 및 임베드가 캐스트 될 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9ea2792030796068ebee3771205dce320fb98fd5" translate="yes" xml:space="preserve">
          <source>This function is primarily used by &lt;a href=&quot;ecto.query#select_merge/3&quot;&gt;&lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt;&lt;/a&gt; to merge different select clauses.</source>
          <target state="translated">이 함수는 주로 &lt;a href=&quot;ecto.query#select_merge/3&quot;&gt; &lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt; &lt;/a&gt; 에서 다른 select 절을 병합 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="95e4d0ba9a962e855d63d60b4fd26e982ea84569" translate="yes" xml:space="preserve">
          <source>This function is used for authorization purposes and it may be invoked outside of the process that effectively runs the socket.</source>
          <target state="translated">이 함수는 권한 부여 목적으로 사용되며 소켓을 효과적으로 실행하는 프로세스 외부에서 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f60f736835987ffe4d869279d98e0a0470fd3a" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &quot;Example: Adding a comment to a post&quot; section.</source>
          <target state="translated">이 기능은 전체적으로 연관 작업에 사용됩니다. 예를 들어 게시물에 많은 댓글이있는 경우 모든 댓글을 한 번에 추가, 제거 또는 변경할 수 있습니다. 단순히 게시물에 새 댓글을 추가하는 것이 목표 인 경우 나중에 &quot;예 : 게시물에 댓글 추가&quot;섹션에서 설명 하겠지만 수동으로 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22adf8e4771dc77ddcc4249d7919749c29698a38" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &amp;ldquo;Example: Adding a comment to a post&amp;rdquo; section.</source>
          <target state="translated">이 기능은 전체적으로 연관 작업에 사용됩니다. 예를 들어 게시물에 댓글이 많은 경우 모든 댓글을 한 번에 추가, 제거 또는 변경할 수 있습니다. 목표가 단순히 게시물에 새 댓글을 추가하는 것이라면 나중에&amp;ldquo;예 : 게시물에 댓글 추가&amp;rdquo;섹션에서 설명 할 것처럼 수동으로 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="08eda1f3849525ce418b408dadef19a29c0b6f84" translate="yes" xml:space="preserve">
          <source>This function is used to work with embeds as a whole. For embeds with cardinality one, &lt;code&gt;nil&lt;/code&gt; can be used to remove the existing entry. For embeds with many entries, an empty list may be given instead.</source>
          <target state="translated">이 기능은 전체를 포함하여 작업하는 데 사용됩니다. 카디널리티가 1 인 임베드의 경우 &lt;code&gt;nil&lt;/code&gt; 을 사용하여 기존 항목을 제거 할 수 있습니다. 항목이 많은 임베드의 경우 빈 목록이 대신 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd54b454514d325837202458e298d9589a1ceed" translate="yes" xml:space="preserve">
          <source>This function is useful for removing empty strings sent via HTML forms. If you are providing an API, there is likely no need to invoke &lt;a href=&quot;#scrub_params/2&quot;&gt;&lt;code&gt;scrub_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 HTML 양식을 통해 전송 된 빈 문자열을 제거하는 데 유용합니다. API를 제공하는 경우 &lt;a href=&quot;#scrub_params/2&quot;&gt; &lt;code&gt;scrub_params/2&lt;/code&gt; &lt;/a&gt; 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="64ae2d3a9800574311ce709ebfa7b91aac472431" translate="yes" xml:space="preserve">
          <source>This function is useful for sending boolean values to the server.</source>
          <target state="translated">이 함수는 부울 값을 서버로 보내는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2e8d3ec5712ad07392b313c25f730d33813e39fc" translate="yes" xml:space="preserve">
          <source>This function is useful for:</source>
          <target state="translated">이 기능은 다음에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0f8df1aeec38d6ef055f78ffe52b7fd809b11de3" translate="yes" xml:space="preserve">
          <source>This function is useful in JavaScript responses when there is a need to escape HTML rendered from other templates, like in the following:</source>
          <target state="translated">이 함수는 다음과 같이 다른 템플릿에서 렌더링 된 HTML을 이스케이프해야 할 때 JavaScript 응답에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8bd46d36363c15990125532c0d54d1cd70be4c83" translate="yes" xml:space="preserve">
          <source>This function is useful to detect if the client is running on an outdated version of the marked static files. It works by comparing the static paths sent by the client with the one on the server.</source>
          <target state="translated">이 함수는 표시된 정적 파일의 오래된 버전에서 클라이언트가 실행 중인지 감지하는 데 유용합니다. 클라이언트가 보낸 정적 경로를 서버의 경로와 비교하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5f05751e977e06b61bae3058808ef7801122a3bf" translate="yes" xml:space="preserve">
          <source>This function is useful when the code being invoked crashes and there is a need to verify a particular response was sent even with the crash. It returns a tuple with &lt;code&gt;{status, headers, body}&lt;/code&gt;.</source>
          <target state="translated">이 함수는 호출되는 코드가 충돌하고 충돌이 발생하더라도 특정 응답이 전송되었는지 확인할 필요가있을 때 유용합니다. &lt;code&gt;{status, headers, body}&lt;/code&gt; 로 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="feb7b5f249171806db774de8814da72fc6867cc9" translate="yes" xml:space="preserve">
          <source>This function is useful when the multi to be merged requires information from the original multi. Hence the second argument is an anonymous function that receives the multi changes so far. The anonymous function must return another multi.</source>
          <target state="translated">이 기능은 병합 할 멀티에 원래 멀티의 정보가 필요한 경우에 유용합니다. 따라서 두 번째 인수는 지금까지 다중 변경 사항을 수신하는 익명 함수입니다. 익명 함수는 다른 멀티를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea36ab9cf50bba27fd6813a84418b75a89007160" translate="yes" xml:space="preserve">
          <source>This function is useful when you may want to serve different content-types (such as JSON and HTML) from the same routes. However, if you always have distinct routes, you can also disable content negotiation and simply hardcode your format of choice in your route pipelines:</source>
          <target state="translated">이 함수는 동일한 경로에서 다른 콘텐츠 유형 (예 : JSON 및 HTML)을 제공하려는 경우에 유용합니다. 그러나 항상 고유 한 경로가있는 경우 콘텐츠 협상을 비활성화하고 경로 파이프 라인에서 선택한 형식을 간단히 하드 코딩 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ef3241f414eaf2fb4a40b3c68e3fe5a7aa4417" translate="yes" xml:space="preserve">
          <source>This function merges two changesets provided they have been applied to the same data (their &lt;code&gt;:data&lt;/code&gt; field is equal); if the data differs, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised. If one of the changesets has a &lt;code&gt;:repo&lt;/code&gt; field which is not &lt;code&gt;nil&lt;/code&gt;, then the value of that field is used as the &lt;code&gt;:repo&lt;/code&gt; field of the resulting changeset; if both changesets have a non-&lt;code&gt;nil&lt;/code&gt; and different &lt;code&gt;:repo&lt;/code&gt; field, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">이 함수는 동일한 데이터에 적용된 두 개의 변경 세트를 병합합니다 (그들의 &lt;code&gt;:data&lt;/code&gt; 필드는 동일합니다). 데이터가 다르면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 변경 세트 중 하나에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;:repo&lt;/code&gt; 필드가 있는 경우 해당 필드의 값은 결과 변경 세트 의 &lt;code&gt;:repo&lt;/code&gt; 필드 로 사용됩니다 . 두 변경 세트에 모두 &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 &lt;code&gt;:repo&lt;/code&gt; 필드가 있으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dbc0dbbbaa75e1f372b0e07a9f6b951709ad2563" translate="yes" xml:space="preserve">
          <source>This function must be called after the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.CSRFProtection&lt;/code&gt;&lt;/a&gt; plug is invoked. If a token was not yet computed, it will be.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.CSRFProtection&lt;/code&gt; &lt;/a&gt; 플러그가 호출 된 후에 호출되어야합니다 . 토큰이 아직 계산되지 않은 경우 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="47d374217596346a6c9bf2274712172feb075b08" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it&amp;rsquo;s not.</source>
          <target state="translated">이 함수 는 지정된 &lt;code&gt;changeset&lt;/code&gt; 의 &lt;code&gt;:changes&lt;/code&gt; 필드 만보 고 변경이있는 경우 &lt;code&gt;{:ok, value}&lt;/code&gt; , 그렇지 않은 경우 &lt;code&gt;:error&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5e1143e93cf32871e96d09b6d702308f61d09b3a" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it's not.</source>
          <target state="translated">이 함수 는 주어진 &lt;code&gt;changeset&lt;/code&gt; 의 &lt;code&gt;:changes&lt;/code&gt; 필드 만보 고 변경 사항이 있으면 &lt;code&gt;{:ok, value}&lt;/code&gt; 반환하고 그렇지 않으면 &lt;code&gt;:error&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b8bed5158880c80ee8a08504ebf97b167b84dc1" translate="yes" xml:space="preserve">
          <source>This function overrides the default URL generation pulled from the &lt;code&gt;%Plug.Conn{}&lt;/code&gt;'s endpoint configuration.</source>
          <target state="translated">이 함수는 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 의 끝점 구성 에서 가져온 기본 URL 생성을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="58cb08d9d2f1cf23b4f2a78d41b863c40f49073a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;a href=&quot;phoenix.notacceptableerror&quot;&gt;&lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt;&lt;/a&gt;, which is rendered with status 406, whenever the server cannot serve a response in any of the formats expected by the client.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;phoenix.notacceptableerror&quot;&gt; &lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.이 오류는 서버가 클라이언트가 예상 한 형식으로 응답을 제공 할 수 없을 때마다 상태 406으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1c663a7b4ad2604d2adc9bea7e89c5bd791f16f9" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given &lt;code&gt;:length&lt;/code&gt;. If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 주어진 &lt;code&gt;:length&lt;/code&gt; 까지 요청 본문의 청크를 읽습니다 . 읽을 데이터가 더 있으면 &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;{:ok, body, conn}&lt;/code&gt; 이 반환됩니다. 소켓을 읽는 중에 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 이 &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 에&lt;/a&gt; 따라 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="68ac965b424fbcfc28adb7e70510b4a5060b1986" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given length (specified by the &lt;code&gt;:length&lt;/code&gt; option). If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 주어진 길이 ( &lt;code&gt;:length&lt;/code&gt; 옵션으로 지정)까지 ​​요청 본문의 청크를 읽습니다 . 읽을 데이터가 더 있으면 &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;{:ok, body, conn}&lt;/code&gt; 이 반환됩니다. 소켓을 읽는 중에 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 이 &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 에&lt;/a&gt; 따라 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0c8691b7f9dfce0fa8e902a83efb3fb90903475" translate="yes" xml:space="preserve">
          <source>This function removes every key from the session, clearing the session.</source>
          <target state="translated">이 기능은 세션에서 모든 키를 제거하여 세션을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="23ea244127c3693a61fb279dd8a8823e78d495c2" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly build and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="translated">이 기능을 사용하려면 상위 변경 세트가 새로 빌드되고 아직 지속되지 않은 경우를 제외하고 연관된 데이터가 사전로드되어 있어야합니다. 누락 된 데이터는 연결에 정의 된 &lt;code&gt;:on_replace&lt;/code&gt; 동작을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="508ff7af2c7302ba5ea60f62775c6f5a3c9b9900" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly built and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="translated">이 함수를 사용하려면 상위 변경 집합이 새로 빌드되고 아직 유지되지 않은 경우를 제외하고 관련 데이터가 미리로드되어 있어야합니다. 누락 된 데이터는 연관에 정의 된 &lt;code&gt;:on_replace&lt;/code&gt; 동작을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84382455309fc0aaf784468937d5e8642608c1e5" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and receiving data external to the application.</source>
          <target state="translated">이 함수는 전체 연결을 한 번에 처리하고 (다양한 스타일 연결의 단일 요소가 아님) 응용 프로그램 외부의 데이터를 수신 할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3736933a577a29ee24ad93a05c7c32aef1bea88b" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and using data external to the application.</source>
          <target state="translated">이 기능은 한 번에 전체 연관 (다중 스타일 연관의 단일 요소가 아님)을 작업하고 애플리케이션 외부의 데이터를 사용할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="481b5ba0284c556ea198200d20cec067478414db" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;code&gt;stop/1&lt;/code&gt; callback (see the documentation for the &lt;code&gt;c:stop/1&lt;/code&gt; callback for more information).</source>
          <target state="translated">시작에 성공하면 이 함수는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 또는 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; 를 반환해야합니다 . &lt;code&gt;pid&lt;/code&gt; 는 최고 감독자의 PID 여야합니다. &lt;code&gt;state&lt;/code&gt; 는 임의의 용어 일 수 있으며 생략하면 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다 . 응용 프로그램이 나중에 중지되면 &lt;code&gt;state&lt;/code&gt; 는 &lt;code&gt;stop/1&lt;/code&gt; 콜백으로 전달됩니다 (자세한 내용은 &lt;code&gt;c:stop/1&lt;/code&gt; 콜백 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">이 기능은 반환해야합니다 &lt;code&gt;{:ok, value}&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 아래의 값이 &lt;code&gt;key&lt;/code&gt; 키가 장기에 존재하는 경우, 또는 &lt;code&gt;:error&lt;/code&gt; 키가 용어에 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="5ba272759196f5f4398bb53efebf29cecd454930" translate="yes" xml:space="preserve">
          <source>This function should return:</source>
          <target state="translated">이 함수는 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="734b0856ba9ef7d3fe8e856bcb519a57b1180774" translate="yes" xml:space="preserve">
          <source>This function, as well as &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#post/3&quot;&gt;&lt;code&gt;post/3&lt;/code&gt;&lt;/a&gt; and friends, accepts the request body or parameters as last argument:</source>
          <target state="translated">이 함수와 &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#post/3&quot;&gt; &lt;code&gt;post/3&lt;/code&gt; &lt;/a&gt; 및 friends는 요청 본문 또는 매개 변수를 마지막 인수로 승인합니다.</target>
        </trans-unit>
        <trans-unit id="206f33c29b6ec02bb699170e45e3a167ce8f68a1" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for explicit closing of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">이 기능은 주로 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 를 명시 적으로 닫는 익명 함수를 대체하는 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 와의 통합을 위해 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="5e501818f2a9b8d26ee849f92368c85b2aa84ace" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for returning the generated forms instead.</source>
          <target state="translated">이 기능은 대부분 생성 된 양식을 대신 반환하기 위해 익명 함수를 대체하는 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 와의 통합을 위해 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="60a9005f28b867008de687c6b297116271dbe0ee" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of the &lt;code&gt;:phoenix&lt;/code&gt; application. These are the defaults:</source>
          <target state="translated">이 생성기는 &lt;code&gt;:phoenix&lt;/code&gt; 응용 프로그램 의 &lt;code&gt;:generators&lt;/code&gt; 구성에 제공된 기본 옵션을 사용 합니다. 이것이 기본값입니다 :</target>
        </trans-unit>
        <trans-unit id="a8c79d64b76e704cc3305c267e9609ec954e0a9b" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of your application. These are the defaults:</source>
          <target state="translated">이 생성기는 응용 프로그램 의 &lt;code&gt;:generators&lt;/code&gt; 구성에 제공된 기본 옵션을 사용 합니다. 이것이 기본값입니다 :</target>
        </trans-unit>
        <trans-unit id="ea9fd1bcd7395e4e765f0c8c83f634242ed59708" translate="yes" xml:space="preserve">
          <source>This generator will automatically open the config/config.exs after generation if you have &lt;code&gt;ECTO_EDITOR&lt;/code&gt; set in your environment variable.</source>
          <target state="translated">환경 변수에 &lt;code&gt;ECTO_EDITOR&lt;/code&gt; 가 설정되어 있으면 생성기에서 생성 후 config / config.exs를 자동으로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="799bbac2299c4700ae113704fdd4823ec89feb26" translate="yes" xml:space="preserve">
          <source>This guide assumes that we have generated our new application with Ecto integration and that we will be using PostgreSQL. The introductory guides cover how to get your first application up and running. For instructions on switching to MySQL, please see the &lt;a href=&quot;#using-mysql&quot;&gt;Using MySQL&lt;/a&gt; section.</source>
          <target state="translated">이 가이드에서는 Ecto 통합으로 새 애플리케이션을 생성했으며 PostgreSQL을 사용할 것이라고 가정합니다. 소개 가이드에서는 첫 번째 애플리케이션을 시작하고 실행하는 방법을 다룹니다. MySQL로 전환하는 방법에 대한 지침은 MySQL &lt;a href=&quot;#using-mysql&quot;&gt;사용&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9beabe4b707e9a75951987e66a396037df415c99" translate="yes" xml:space="preserve">
          <source>This guide describes how to use these parameters to set up an HTTPS server with Plug, and documents some best-practices and potential pitfalls.</source>
          <target state="translated">이 가이드에서는 이러한 매개 변수를 사용하여 Plug로 HTTPS 서버를 설정하는 방법을 설명하고 몇 가지 모범 사례와 잠재적 인 함정을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="351d79dff782082a2ce188e37bb0ce9252eef229" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &quot;show.json&quot; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="translated">이 내부 표현을 통해 템플릿을 쉽게 렌더링하고 구성 할 수 있습니다. 예를 들어, JSON 데이터를 &lt;code&gt;render/2&lt;/code&gt; 하려면 뷰에서 render / 2 에 &quot;show.json&quot;항목을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ef1c03d35aad86fcc35b135848f7173bd9a0fa9" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &amp;ldquo;show.json&amp;rdquo; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="translated">이 내부 표현을 통해 템플릿을 쉽게 렌더링하고 작성할 수 있습니다. 예를 들어 JSON 데이터를 &lt;code&gt;render/2&lt;/code&gt; 하려면 뷰에서 render / 2 에 &quot;show.json&quot;항목을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="70ed772bfcabd3597901563673c3cda720c91986" translate="yes" xml:space="preserve">
          <source>This is also what calling &lt;a href=&quot;../phoenix_html/phoenix.html.safe#to_iodata/1&quot;&gt;&lt;code&gt;Phoenix.HTML.Safe.to_iodata/1&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structure returns.</source>
          <target state="translated">이것은 &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt; &lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt; &lt;/a&gt; 구조로 &lt;a href=&quot;../phoenix_html/phoenix.html.safe#to_iodata/1&quot;&gt; &lt;code&gt;Phoenix.HTML.Safe.to_iodata/1&lt;/code&gt; &lt;/a&gt; 을 호출하는 것도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9df51736f8af300b7e83be2bba6d0538a65eaf19" translate="yes" xml:space="preserve">
          <source>This is an implementation of EEx.Engine that guarantees templates are HTML Safe.</source>
          <target state="translated">템플릿이 HTML 안전임을 보장하는 EEx.Engine의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="22dfd0ec4ef3534510402dea1f9a067863780a64" translate="yes" xml:space="preserve">
          <source>This is available only inside subqueries.</source>
          <target state="translated">이것은 하위 쿼리 내에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5329254754bcb5b1518f7c46c55cd4246cdc7b2b" translate="yes" xml:space="preserve">
          <source>This is best used in conjunction with &lt;code&gt;parent_as&lt;/code&gt; to correlate the subquery with the parent query to test some condition on related rows in a different table. In the above example the query returns posts which have at least one comment that has more than 5 replies.</source>
          <target state="translated">이는 &lt;code&gt;parent_as&lt;/code&gt; 와 함께 사용 하여 하위 쿼리를 상위 쿼리와 연관시켜 다른 테이블의 관련 행에 대한 일부 조건을 테스트하는 데 가장 적합 합니다. 위의 예에서 쿼리는 답글이 5 개 이상인 댓글이 하나 이상있는 게시물을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd363ee9be583e8940f3872abf411010d65f4b10" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a custom type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;:autogenerate&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;field&lt;/code&gt; 사용자 정의 유형이 제공 될 때 호출되는 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="1eb11a6027445daec6c09612ab24edc4bb15dc55" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a parameterized type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;:autogenerate&lt;/code&gt; 플래그를 사용하여 매개 변수화 된 유형이 &lt;code&gt;field&lt;/code&gt; 제공 될 때 호출되는 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="7a6276fd1995acb9d422ef5b0fccedcd0f49f563" translate="yes" xml:space="preserve">
          <source>This is configured in your application environment like:</source>
          <target state="translated">이것은 응용 프로그램 환경에서 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="543130ccea506a07596bda5da2eb43221176545d" translate="yes" xml:space="preserve">
          <source>This is done as a security measure to avoid attacks that attempt to traverse entries with nil columns. To check that value is &lt;code&gt;nil&lt;/code&gt;, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt;&lt;code&gt;is_nil/1&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">이것은 열이없는 항목을 가로 지르는 공격을 피하기위한 보안 수단으로 수행됩니다. 이 값을 확인하려면 것은 &lt;code&gt;nil&lt;/code&gt; , 사용 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt; &lt;code&gt;is_nil/1&lt;/code&gt; &lt;/a&gt; 대신 :</target>
        </trans-unit>
        <trans-unit id="4067008cb24e88317e907e2f01cf3fea3ce7a290" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they&amp;rsquo;re not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="translated">데이터베이스에서 레코드를 정기적으로 가져 와서 다른 사용자가 레코드 &lt;em&gt;를 업데이트 할 때만&lt;/em&gt; 레코드를 변경했는지 여부를 확인 &lt;em&gt;하면됩니다&lt;/em&gt; . 이 동작은 동일한 레코드에 대한 동시 업데이트 가능성이 낮은 상황에 이상적입니다. 그렇지 않은 경우 비관적 잠금 또는 다른 동시성 패턴이 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="823d31394ade33b7711fd9d9b5d40e1240503c08" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they're not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="translated">이는 데이터베이스에서 정기적으로 레코드를 가져온 다음 레코드 &lt;em&gt;를 업데이트 할 때만&lt;/em&gt; 다른 사용자가 레코드를 변경했는지 여부를 확인하여 수행됩니다 . 이 동작은 동일한 레코드에 대한 동시 업데이트 가능성이 낮은 상황에서 이상적입니다. 그렇지 않은 경우 비관적 잠금 또는 기타 동시성 패턴이 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e8026b3623dfa096a82605e21a4cd8c802a6f2c" translate="yes" xml:space="preserve">
          <source>This is equivalent to setting the status and the body and then calling &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 상태와 본문을 설정 한 다음 &lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9ba82c91234fa5021cfb3b5cb56f8799ec54310" translate="yes" xml:space="preserve">
          <source>This is especially useful when working with subqueries, where you may need to refer to a parent binding with &lt;code&gt;parent_as&lt;/code&gt;, which is not known when writing the subquery:</source>
          <target state="translated">이는 하위 쿼리 를 작성할 때 알려지지 않은 &lt;code&gt;parent_as&lt;/code&gt; 를 사용하여 부모 바인딩을 참조해야하는 하위 쿼리로 작업 할 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="30cd495df7102722d59e1ffd84611b6001636dff" translate="yes" xml:space="preserve">
          <source>This is great, exactly what we want. Note how every route, path helper and controller is properly namespaced.</source>
          <target state="translated">이것은 우리가 원하는 것입니다. 모든 경로, 경로 도우미 및 컨트롤러의 네임 스페이스가 어떻게 올바르게 지정되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="66c9554f976f86ea7cfddef7a13a078b61322160" translate="yes" xml:space="preserve">
          <source>This is helpful when you are not testing joining the channel and just need the socket.</source>
          <target state="translated">채널 가입 테스트를하지 않고 소켓 만 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e67b3c4ca838f0b073d784d2fa79097d1fe7dad2" translate="yes" xml:space="preserve">
          <source>This is invoked only once per socket regardless of the number of transports and should be responsible for setting up any process structure used exclusively by the socket regardless of transports.</source>
          <target state="translated">이것은 전송 수에 관계없이 소켓 당 한 번만 호출되며 전송에 관계없이 소켓에서 독점적으로 사용되는 모든 프로세스 구조를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23ca0e35e10c4c620e6434a93de5f315f4cc8c3f" translate="yes" xml:space="preserve">
          <source>This is just what we saw before when we ran &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt;, except here we see a &lt;code&gt;@doc false&lt;/code&gt; above our &lt;code&gt;changeset/2&lt;/code&gt; function. This tells us that while this function is publicly callable, it's not part of the public context API. Callers that build changesets do so via the context API. For example, &lt;code&gt;Accounts.create_user/1&lt;/code&gt; calls into our &lt;code&gt;User.changeset/2&lt;/code&gt; to build the changeset from user input. Callers, such as our controller actions, do not access &lt;code&gt;User.changeset/2&lt;/code&gt; directly. All interaction with our user changesets is done through the public &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="translated">이것은 우리가 &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; 를&lt;/a&gt; 실행했을 때 이전에 보았던 것입니다. 단 , &lt;code&gt;@doc false&lt;/code&gt; &lt;code&gt;changeset/2&lt;/code&gt; 함수 위에 @doc false가 있는 것을 제외하고는 말입니다 . 이것은이 함수가 공개적으로 호출 가능하지만 공개 컨텍스트 API의 일부가 아님을 알려줍니다. 변경 집합을 빌드하는 호출자는 컨텍스트 API를 통해 수행합니다. 예를 들어 &lt;code&gt;Accounts.create_user/1&lt;/code&gt; 은 &lt;code&gt;User.changeset/2&lt;/code&gt; 를 호출하여 사용자 입력에서 변경 집합을 빌드합니다. 컨트롤러 작업과 같은 호출자는 &lt;code&gt;User.changeset/2&lt;/code&gt; 에 직접 액세스하지 않습니다 . 사용자 변경 세트와의 모든 상호 작용은 공용 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="b7a657048e2c2cbfd50712010e238e2e21a97516" translate="yes" xml:space="preserve">
          <source>This is known to have a plethora of problems including accessibility, large numbers are converted to exponential notation and scrolling can accidentally increase or decrease the number.</source>
          <target state="translated">이것은 접근성을 포함하여 많은 문제를 가지고있는 것으로 알려져 있습니다. 큰 숫자는 지수 표기법으로 변환되며 스크롤은 실수로 숫자를 늘리거나 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575f8d14a96e0e9c2305203019fa9f1c1e03c389" translate="yes" xml:space="preserve">
          <source>This is not intended to be an exhaustive list, as this topic is actually a bit beyond the scope of the current document. The issue is a generic one, not specific to Erlang/Elixir, and further explanations can be found online.</source>
          <target state="translated">이 항목은 실제로 현재 문서의 범위를 약간 벗어 났기 때문에 전체 목록이 아닙니다. 이 문제는 Erlang / Elixir에만 국한되지 않는 일반적인 문제이며 자세한 설명은 온라인에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d0916f452cd067b42f99269461a6e8a22fcd085" translate="yes" xml:space="preserve">
          <source>This is particularly useful when used with &lt;a href=&quot;plug.builder#builder_opts/0&quot;&gt;&lt;code&gt;Plug.Builder.builder_opts/0&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;builder_opts/0&lt;/code&gt; allows us to pass options received when initializing &lt;code&gt;AppRouter&lt;/code&gt; to a specific plug, such as dispatch itself. So if instead of:</source>
          <target state="translated">이것은 &lt;a href=&quot;plug.builder#builder_opts/0&quot;&gt; &lt;code&gt;Plug.Builder.builder_opts/0&lt;/code&gt; &lt;/a&gt; 과 함께 사용할 때 특히 유용합니다 . &lt;code&gt;builder_opts/0&lt;/code&gt; 을 사용하면 &lt;code&gt;AppRouter&lt;/code&gt; 를 초기화 할 때받은 옵션 을 디스패치 자체와 같은 특정 플러그 로 전달할 수 있습니다 . 따라서 대신에 :</target>
        </trans-unit>
        <trans-unit id="0146f85b516e587e6b92b0b400db4374bf1c0f28" translate="yes" xml:space="preserve">
          <source>This is significant because we can use the &lt;code&gt;page_path&lt;/code&gt; function in a template to link to the root of our application. We can then use this helper in our templates:</source>
          <target state="translated">이는 템플릿에서 &lt;code&gt;page_path&lt;/code&gt; 함수를 사용하여 애플리케이션의 루트에 연결할 수 있기 때문에 중요 합니다. 그런 다음 템플릿에서이 도우미를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e4b6dd8b33a2972a835278b18e46ff4920ac2a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to &lt;code&gt;belongs_to&lt;/code&gt; associations.</source>
          <target state="translated">필드가 연관 정의에서 유추된다는 점을 제외하면 &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; &lt;/a&gt; 와 유사합니다 . 부모가 데이터베이스에도 존재하는 경우에만 자식이 만들어 지도록하는 데 유용합니다. 따라서 &lt;code&gt;belongs_to&lt;/code&gt; 연관 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="02210ecf6e704066e98f3f150578efab0c87344d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to &lt;code&gt;has_*&lt;/code&gt; associations.</source>
          <target state="translated">필드가 연관 정의에서 유추된다는 점을 제외하면 &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; &lt;/a&gt; 와 유사합니다 . 데이터베이스에 자식이없는 경우에만 부모를 삭제하거나 기본 키를 변경할 수 있도록하는 데 유용합니다. 따라서 &lt;code&gt;has_*&lt;/code&gt; 연관 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="246766b43ac065cf7a6813d58181faa7501710d2" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;ecto.query#preload/3&quot;&gt;&lt;code&gt;Ecto.Query.preload/3&lt;/code&gt;&lt;/a&gt; except it allows you to preload structs after they have been fetched from the database.</source>
          <target state="translated">이것은 &lt;a href=&quot;ecto.query#preload/3&quot;&gt; &lt;code&gt;Ecto.Query.preload/3&lt;/code&gt; &lt;/a&gt; 와 유사합니다. 구조체에서 데이터베이스에서 가져온 구조체를 미리로드 할 수 있다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e4eed9ef50790eac0932b578ea9d27bff84cfd58" translate="yes" xml:space="preserve">
          <source>This is the documentation for the Phoenix project.</source>
          <target state="translated">이것은 Phoenix 프로젝트에 대한 문서입니다.</target>
        </trans-unit>
        <trans-unit id="3ada68d07e24e1da189679d5236f1b2085cd8c85" translate="yes" xml:space="preserve">
          <source>This is the same mechanism provided by &lt;a href=&quot;../phoenix/phoenix.channel&quot;&gt;&lt;code&gt;Phoenix.Channel&lt;/code&gt;&lt;/a&gt;s. Therefore, if your application uses both channels and LiveViews, you can use the same technique to disconnect any stateful connection.</source>
          <target state="translated">이것은 &lt;a href=&quot;../phoenix/phoenix.channel&quot;&gt; &lt;code&gt;Phoenix.Channel&lt;/code&gt; 에서&lt;/a&gt; 제공하는 것과 동일한 메커니즘 입니다. 따라서 응용 프로그램에서 채널과 LiveView를 모두 사용하는 경우 동일한 기술을 사용하여 상태 저장 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646640f311b4826df55090d4281da13e20dd6b66" translate="yes" xml:space="preserve">
          <source>This is the standard matrix of HTTP verbs, paths, and controller actions. For a while, this was known as RESTful routes, but most consider this a misnomer nowadays. Let's look at them individually, in a slightly different order.</source>
          <target state="translated">이것은 HTTP 동사, 경로 및 컨트롤러 작업의 표준 매트릭스입니다. 한동안 이것은 RESTful 경로로 알려졌지만 오늘날 대부분은 이것을 잘못된 이름으로 간주합니다. 약간 다른 순서로 개별적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d84197d638f69361b43dbeeee6fa00ab6538ceb9" translate="yes" xml:space="preserve">
          <source>This is the task we use to get our application running. It takes no arguments at all. If we pass any in, they will be silently ignored.</source>
          <target state="translated">이것은 우리가 응용 프로그램을 실행하는 데 사용하는 작업입니다. 인수가 전혀 필요하지 않습니다. 우리가 어떤 것을 전달하면 그들은 조용히 무시 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1287cce3e334f0bd268a0fbb70950d2bd00055a6" translate="yes" xml:space="preserve">
          <source>This is the value passed back from &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; and subsequently passed as the last argument to all callbacks. Idiomatically it is a map.</source>
          <target state="translated">이것은 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 에서 다시 전달 된 값 이며 이후 모든 콜백에 마지막 인수로 전달됩니다. 관용적으로는지도입니다.</target>
        </trans-unit>
        <trans-unit id="1871b378b5a1fb4c4012fd59a4ce5d038f416585" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn&amp;rsquo;t valid, but we don&amp;rsquo;t want to show errors until an actual user action has been performed.</source>
          <target state="translated">이는 양식 필드의 유효성 검사 힌트 (예 : 새 양식의 빈 변경 집합)에 유용합니다. 해당 변경 집합은 유효하지 않지만 실제 사용자 작업이 수행 될 때까지 오류를 표시하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8eac94b23ec614fdc27f65b1253b4162ffa8a109" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn't valid, but we don't want to show errors until an actual user action has been performed.</source>
          <target state="translated">이는 양식 필드에 대한 유효성 검사 힌트 (예 : 새 양식에 대한 빈 변경 집합)에 유용합니다. 해당 변경 집합은 유효하지 않지만 실제 사용자 작업이 수행 될 때까지 오류를 표시하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b547124ded5a56cf030283e1096472422e728527" translate="yes" xml:space="preserve">
          <source>This is useful when a specific connection is required for testing a plug or a particular function.</source>
          <target state="translated">플러그 또는 특정 기능을 테스트하기 위해 특정 연결이 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="967c2f65e325112d9e81267fb5e803aaad342521" translate="yes" xml:space="preserve">
          <source>This is useful when building the select by hand. It expects all options and one or more select values.</source>
          <target state="translated">이것은 손으로 선택을 만들 때 유용합니다. 모든 옵션과 하나 이상의 선택 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc164165494ed01035c2fea10f32c91cf135eaeb" translate="yes" xml:space="preserve">
          <source>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere. The IDs received by the preloading function and the result returned depends on the association type:</source>
          <target state="translated">전체 데이터 세트가 이미로드되었거나 다른 곳에서 명시 적으로 가져와야 할 때 유용합니다. 사전로드 기능이 수신 한 ID 및 리턴 된 결과는 연관 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c1ee8628cd73b8b7149d50d393fe7c8fa56a351b" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data from the data layer, like a search form.</source>
          <target state="translated">이는 검색 폼과 같이 데이터 계층의 모든 종류의 데이터가 지원하지 않는 폼을 만들 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0765c6b4474540e333d6f27c42f79680532d7ff2" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data layer. Let's assume that we're submitting a form to the &lt;code&gt;:new&lt;/code&gt; action in the &lt;code&gt;FooController&lt;/code&gt;:</source>
          <target state="translated">이것은 어떤 종류의 데이터 레이어에서도 지원되지 않는 양식을 만들 때 유용합니다. &lt;code&gt;FooController&lt;/code&gt; 의 &lt;code&gt;:new&lt;/code&gt; 액션에 폼을 제출한다고 가정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="557303ac218e1708373d1b4d8a6f4a9c23b313d1" translate="yes" xml:space="preserve">
          <source>This is useful, for example, to recompile modules that depend on external systems, such as directories, databases, etc. Note if you simply depend on external files, &lt;code&gt;@external_resource&lt;/code&gt; annotation should be used.</source>
          <target state="translated">이것은 예를 들어 디렉토리, 데이터베이스 등과 같은 외부 시스템에 의존하는 모듈을 재 컴파일하는 데 유용합니다. 단순히 외부 파일에 의존하는 경우 &lt;code&gt;@external_resource&lt;/code&gt; 주석을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf23281d7b92a37b60472183249bb866a988f802" translate="yes" xml:space="preserve">
          <source>This issue can also happen with other helpers, such as &lt;code&gt;content_tag&lt;/code&gt;:</source>
          <target state="translated">이 문제는 &lt;code&gt;content_tag&lt;/code&gt; 와 같은 다른 도우미에서도 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f798383afb7474b032be11f12e76fdd26cfd9f6b" translate="yes" xml:space="preserve">
          <source>This layout is used by many parts of your application. However, there is a subsection of your application that wants to also add a sidebar. Let's call it &quot;blog.html&quot;. You can build on top of the existing layout in two steps. First, define the blog layout:</source>
          <target state="translated">이 레이아웃은 애플리케이션의 여러 부분에서 사용됩니다. 그러나 사이드 바도 추가하려는 애플리케이션의 하위 섹션이 있습니다. &quot;blog.html&quot;이라고합시다. 두 단계로 기존 레이아웃 위에 빌드 할 수 있습니다. 먼저 블로그 레이아웃을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="eede1c11892e1de751e301f0909a682510d53c2b" translate="yes" xml:space="preserve">
          <source>This looks good, but there is a problem here. Remember that we wanted both user facing reviews routes &lt;code&gt;/reviews&lt;/code&gt; as well as the admin ones &lt;code&gt;/admin/reviews&lt;/code&gt;. If we now include the user facing reviews in our router under the root scope like this:</source>
          <target state="translated">괜찮아 보이지만 여기에 문제가 있습니다. 사용자가 직접 검토하는 경로 &lt;code&gt;/reviews&lt;/code&gt; 뿐만 아니라 관리자 인 &lt;code&gt;/admin/reviews&lt;/code&gt; 를 원한다는 것을 기억하십시오 . 이제 다음과 같이 루트 범위 아래의 라우터에 사용자가 직면 한 리뷰를 포함하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44a1ef9e37129dec0a33744ad55541c8ec1d1309" translate="yes" xml:space="preserve">
          <source>This macro accepts a set of options:</source>
          <target state="translated">이 매크로는 일련의 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="30cad0a3d348831413868904461ce3cb02695bb7" translate="yes" xml:space="preserve">
          <source>This macro also supports passing a nested block of route definitions. This is helpful for nesting children resources within their parents to generate nested routes.</source>
          <target state="translated">이 매크로는 또한 중첩 된 경로 정의 블록 전달을 지원합니다. 이는 부모 리소스 내에 자식 리소스를 중첩하여 중첩 된 경로를 생성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5272cc1708a897442f49d3861c8376d2c1684484" translate="yes" xml:space="preserve">
          <source>This macro doesn&amp;rsquo;t add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;code&gt;compile/1&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 파이프 라인에 새 플러그를 추가 할 때 가드를 추가하지 않습니다. 가드로 플러그를 추가하는 방법에 대한 자세한 내용은 &lt;code&gt;compile/1&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84875e3a7e5339034bbbeafae9696406ba8d0be0" translate="yes" xml:space="preserve">
          <source>This macro doesn't add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;a href=&quot;#compile/3&quot;&gt;&lt;code&gt;compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 파이프 라인에 새 플러그를 추가 할 때 가드를 추가하지 않습니다. 가드가있는 플러그 추가에 대한 자세한 내용은 &lt;a href=&quot;#compile/3&quot;&gt; &lt;code&gt;compile/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa7e3fdecd39a60479ea64ca6e42ffb064952aa0" translate="yes" xml:space="preserve">
          <source>This macro is similar to &lt;a href=&quot;#select/3&quot;&gt;&lt;code&gt;select/3&lt;/code&gt;&lt;/a&gt; except it may be specified multiple times as long as every entry is a map. This is useful for merging and composing selects. For example:</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#select/3&quot;&gt; &lt;code&gt;select/3&lt;/code&gt; &lt;/a&gt; 와 유사하지만 모든 항목이 맵인 경우 여러 번 지정할 수 있습니다. 이것은 선택을 병합하고 구성하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de8d8b58528e44c756543b77e46f1f172b9e7e02" translate="yes" xml:space="preserve">
          <source>This may accomplish what we want, but now we need to wire up the schema relationships in the &lt;code&gt;Accounts&lt;/code&gt; context to the &lt;code&gt;CMS&lt;/code&gt; author. Worse, we have now taken our isolated &lt;code&gt;Accounts&lt;/code&gt; context and required it to know about a content management system, which in turn knows about &lt;code&gt;Accounts&lt;/code&gt; too. With time, cyclic dependencies would blurry the lines between contexts, which is not what we want for isolated responsibilities in our application. There's a better way to handle these requirements.</source>
          <target state="translated">이것은 우리가 원하는 것을 달성 할 수 있지만 이제는 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트 의 스키마 관계를 &lt;code&gt;CMS&lt;/code&gt; 작성자 에게 연결해야합니다 . 더 나쁜 것은, 우리는 지금 우리의 격리 촬영 한 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 차례로 알고 콘텐츠 관리 시스템에 대해 알고하는 데 필요한 &lt;code&gt;Accounts&lt;/code&gt; 도. 시간이 지남에 따라 순환 종속성은 컨텍스트 간의 경계를 모호하게 만들 것입니다. 이는 애플리케이션에서 격리 된 책임에 대해 원하는 것이 아닙니다. 이러한 요구 사항을 처리하는 더 좋은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80844b87a747d5e664d2490ade69aea11936ad23" translate="yes" xml:space="preserve">
          <source>This may also happen on redirects. If you have a POST request to &lt;code&gt;foo.example.com&lt;/code&gt; that redirects to &lt;code&gt;bar.example.com&lt;/code&gt; with status 307, the token will contain a different host than the one in the request.</source>
          <target state="translated">리디렉션에서도 발생할 수 있습니다. 상태가 307 인 &lt;code&gt;bar.example.com&lt;/code&gt; 으로 경로 재지 정하는 &lt;code&gt;foo.example.com&lt;/code&gt; 에 대한 POST 요청이있는 경우 , 토큰은 요청의 호스트와 다른 호스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45fff2b06c5bcdcfb6cfb7a314ec69dd932215c6" translate="yes" xml:space="preserve">
          <source>This means any HTML code inside the given string won't be escaped.</source>
          <target state="translated">이것은 주어진 문자열 내의 모든 HTML 코드가 이스케이프되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4a4f142c5563004d2613132e5bfe4d91c45a1a1d" translate="yes" xml:space="preserve">
          <source>This means guards can be given to &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">이것은 다음과 &lt;code&gt;match&lt;/code&gt; 경비원을 줄 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4e9c6ac4e3bf3b13fcd41f8b0bf87448b7d2126a" translate="yes" xml:space="preserve">
          <source>This means that after each request, &lt;a href=&quot;../plug/plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt;, via &lt;code&gt;:telemetry&lt;/code&gt;, will emit a &quot;stop&quot; event, with a measurement of how long it took to get the response:</source>
          <target state="translated">즉, 각 요청 후 &lt;a href=&quot;../plug/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;:telemetry&lt;/code&gt; 를 통해 응답을받는 데 걸린 시간을 측정하여 &quot;중지&quot;이벤트를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="50ba0c978af1e21d1324664f02c106ebf9733164" translate="yes" xml:space="preserve">
          <source>This means that all routes starting with &lt;code&gt;/jobs&lt;/code&gt; will be sent to the &lt;code&gt;HelloWeb.BackgroundJob.Plug&lt;/code&gt; module. Inside the plug, you can match on subroutes, such as &lt;code&gt;/pending&lt;/code&gt; and &lt;code&gt;/active&lt;/code&gt; that shows the status of certain jobs.</source>
          <target state="translated">이는 &lt;code&gt;/jobs&lt;/code&gt; 로 시작하는 모든 경로 가 &lt;code&gt;HelloWeb.BackgroundJob.Plug&lt;/code&gt; 모듈 로 전송 됨을 의미합니다 . 플러그 내에서 특정 작업의 상태를 표시하는 &lt;code&gt;/pending&lt;/code&gt; 및 &lt;code&gt;/active&lt;/code&gt; 와 같은 하위 경로에서 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46fcd9b428f43bc3ceced700d0d499071542798d" translate="yes" xml:space="preserve">
          <source>This means that when working with changesets that are not meant to be persisted to the database, such as schemaless changesets, you may need to explicitly set the action to one specific value. Frameworks such as Phoenix use the action value to define how HTML forms should act.</source>
          <target state="translated">이는 스키마없는 변경 세트와 같이 데이터베이스에 유지되지 않는 변경 세트로 작업 할 때 조치를 하나의 특정 값으로 명시 적으로 설정해야 할 수도 있음을 의미합니다. Phoenix와 같은 프레임 워크는 action 값을 사용하여 HTML 양식의 작동 방식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="202e52fe595d963585538547933f6a4e3cafd0a0" translate="yes" xml:space="preserve">
          <source>This means that whenever the &lt;code&gt;Ecto.Repo.Supervisor&lt;/code&gt; starts, it will emit an event, via &lt;code&gt;:telemetry&lt;/code&gt;, with a measurement of the time at start-up.</source>
          <target state="translated">즉, &lt;code&gt;Ecto.Repo.Supervisor&lt;/code&gt; 가 시작될 때마다 시작 시 시간 측정과 함께 &lt;code&gt;:telemetry&lt;/code&gt; 를 통해 이벤트를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="07a058b3195ea17c39bf63ddac4c41f7f9ee1528" translate="yes" xml:space="preserve">
          <source>This means the plugs in the &lt;code&gt;authenticate_user&lt;/code&gt; and &lt;code&gt;ensure_admin&lt;/code&gt; pipelines will be called before the &lt;code&gt;BackgroundJob.Plug&lt;/code&gt; allowing them to send an appropriate response and halt the request accordingly.</source>
          <target state="translated">즉, &lt;code&gt;authenticate_user&lt;/code&gt; 및 &lt;code&gt;ensure_admin&lt;/code&gt; 파이프 라인 의 플러그가 &lt;code&gt;BackgroundJob.Plug&lt;/code&gt; 전에 호출 되어 적절한 응답을 보내고 그에 따라 요청을 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee54c80446b3760c6fb0a7486f59b47f284f3002" translate="yes" xml:space="preserve">
          <source>This mimics the behaviour existing in clients.</source>
          <target state="translated">이것은 클라이언트에 존재하는 동작을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="c496c6a2b0bd7dfb1281705f319360c782f54b15" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 또한 어느 시점에서 &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 에&lt;/a&gt; 액세스 할 수있는 전송 환경에서 안전한 환경을 가능하게하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0f3ec12e95282c603be600f76b1efa0ba48fef74" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 또한 어느 시점에서 &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 에&lt;/a&gt; 액세스 할 수있는 전송에서 보안 환경을 활성화하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6ebb63837f361cbf03a3796451f4fe31cebbd7a9" translate="yes" xml:space="preserve">
          <source>This module also provides functions to simulate leaving and closing a channel. Once you leave or close a channel, because the channel is linked to the test process on join, it will crash the test process:</source>
          <target state="translated">이 모듈은 또한 채널을 떠나고 닫는 것을 시뮬레이션하는 기능을 제공합니다. 채널은 연결시 테스트 프로세스에 연결되므로 채널을 종료하거나 닫으면 테스트 프로세스가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="85f9b5e0210ecd7fadc5d5b219e6eb2289448aaa" translate="yes" xml:space="preserve">
          <source>This module also specifies a behaviour that all the parsers to be used with Plug should adopt.</source>
          <target state="translated">이 모듈은 또한 Plug와 함께 사용되는 모든 파서가 채택해야하는 동작을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d9c3143248084cc9c9ababd5b063a0b53a122a9b" translate="yes" xml:space="preserve">
          <source>This module can be &lt;code&gt;use&lt;/code&gt;-d into a module in order to build a plug pipeline:</source>
          <target state="translated">플러그 파이프 라인을 빌드하기 위해이 모듈을 -d를 모듈에 &lt;code&gt;use&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b51e359d7e48f146d0d1e937d9d0255d91dad914" translate="yes" xml:space="preserve">
          <source>This module can be used in your test cases, like this:</source>
          <target state="translated">이 모듈은 다음과 같이 테스트 케이스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fc81812b5b90ffe59423aab0c8bc729d76484f" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체와 Plug 연결 작업을위한 주요 기능을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="070196252438bbce61c0f717094acdcf2e81b7f0" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;plug.conn#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;plug.conn#content&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체와 플러그 연결 작업을위한 주요 기능을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="3a8c2c7d59b4c13115d6ac023bd8ac70e7f55fc3" translate="yes" xml:space="preserve">
          <source>This module describes what is required to build a Phoenix transport. The transport sits between the socket and channels, forwarding client messages to channels and vice-versa.</source>
          <target state="translated">이 모듈은 Phoenix 전송을 구축하는 데 필요한 사항을 설명합니다. 전송은 소켓과 채널 사이에 위치하여 클라이언트 메시지를 채널로 전달하거나 그 반대로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1bf3d32030d6f8a66f143a02bbf8343a335a4b15" translate="yes" xml:space="preserve">
          <source>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</source>
          <target state="translated">이 모듈은 해당 매크로 각각을 문서화하여 키워드 쿼리 및 파이프 표현식 형식으로 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a4abc0ee1ab071690365f6c903e68103b59a8146" translate="yes" xml:space="preserve">
          <source>This module is commonly used within a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;plug.router&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; and it wraps the &lt;code&gt;call/2&lt;/code&gt; function.</source>
          <target state="translated">이 모듈은 일반적으로 내에서 사용 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;plug.router&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; 그리고 랩 &lt;code&gt;call/2&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="bf931afdfdb9158aece8ce5e671b27951b8f8dc7" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 1 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 1.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. Cowboy 1 with Plug를 사용하려면 &lt;code&gt;mix.exs&lt;/code&gt; 파일 에 &lt;code&gt;plug_cowboy&lt;/code&gt; 버전 1.0 이상을 포함 하십시오. &lt;code&gt;Plug.Cowboy&lt;/code&gt; 대신 Plug.Cowboy 모듈을 직접 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4a03284231b4c9beab2d0b3147c2e873d6724e04" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 2 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 2.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy2</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. Cowboy 2 with Plug를 사용하려면 &lt;code&gt;mix.exs&lt;/code&gt; 파일 에 &lt;code&gt;plug_cowboy&lt;/code&gt; 버전 2.0 이상을 포함 시키 십시오 . &lt;code&gt;Plug.Cowboy&lt;/code&gt; 대신 Plug.Cowboy 모듈을 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b1128cd9517be1b80b829d37c77e14445123041b" translate="yes" xml:space="preserve">
          <source>This module is used by Phoenix pubsub adapters to handle their local node subscriptions and it is usually not accessed directly. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; for an example integration.</source>
          <target state="translated">이 모듈은 Phoenix pubsub 어댑터에서 로컬 노드 구독을 처리하는 데 사용되며 일반적으로 직접 액세스되지 않습니다. 통합 예는 &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18749daab402c4f9221f76b108eba5a09277b12b" translate="yes" xml:space="preserve">
          <source>This module is used to define the application&amp;rsquo;s main view, which serves as the base for all other views and templates.</source>
          <target state="translated">이 모듈은 다른 모든보기 및 템플릿의 기본 역할을하는 응용 프로그램의 기본보기를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bfcb71b5835a83213d4dfa6ee58017a4845f8d7" translate="yes" xml:space="preserve">
          <source>This module is used to define the application's main view, which serves as the base for all other views and templates.</source>
          <target state="translated">이 모듈은 다른 모든보기 및 템플릿의 기반 역할을하는 애플리케이션의 기본보기를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd0bbb57a64e46e86f20c8dc2b8b74868181cea" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates:</source>
          <target state="translated">이 모듈은 특정 디렉토리에서 모든 파일을 읽고 단일 모듈에 임베드하는 편의를 제공합니다. 템플릿이있는 디렉토리가 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="4237a22f395fffa8c90b7f272130e1f9c638e3db" translate="yes" xml:space="preserve">
          <source>This module specifies a behaviour that all sockets must implement. &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; is just one possible implementation of a socket that multiplexes events over multiple channels. Developers can implement their own sockets as long as they implement the behaviour outlined here.</source>
          <target state="translated">이 모듈은 모든 소켓이 구현해야하는 동작을 지정합니다. &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt; 은 여러 채널을 통해 이벤트를 다중화하는 소켓의 가능한 구현 중 하나입니다. 개발자는 여기에 설명 된 동작을 구현하는 한 자체 소켓을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c536ba16d8fed4f4c995fae380610c356225909" translate="yes" xml:space="preserve">
          <source>This module will be the public API for all account functionality in our system. For example, in addition to user account management, we may also handle user login credentials, account preferences, and password reset generation. If we look at the &lt;code&gt;list_users/0&lt;/code&gt; function, we can see the private details of user fetching. And it's super simple. We have a call to &lt;code&gt;Repo.all(User)&lt;/code&gt;. We saw how Ecto repo queries worked in &lt;a href=&quot;ecto&quot;&gt;the Ecto guide&lt;/a&gt;, so this call should look familiar. Our &lt;code&gt;list_users&lt;/code&gt; function is a generalized function specifying the &lt;em&gt;intent&lt;/em&gt; of our code &amp;ndash; namely to list users. The details of that intent where we use our Repo to fetch the users from our PostgreSQL database is hidden from our callers. This is a common theme we'll see re-iterated as we use the Phoenix generators. Phoenix will push us to think about where we have different responsibilities in our application, and then to wrap up those different areas behind well-named modules and functions that make the intent of our code clear, while encapsulating the details.</source>
          <target state="translated">이 모듈은 시스템의 모든 계정 기능에 대한 공용 API가됩니다. 예를 들어, 사용자 계정 관리 외에도 사용자 로그인 자격 증명, 계정 기본 설정 및 암호 재설정 생성을 처리 할 수 ​​있습니다. 우리가 보면 &lt;code&gt;list_users/0&lt;/code&gt; 기능, 우리는 사용자 페칭의 개인 세부 정보를 볼 수 있습니다. 그리고 그것은 매우 간단합니다. &lt;code&gt;Repo.all(User)&lt;/code&gt; 대한 호출이 있습니다. &lt;a href=&quot;ecto&quot;&gt;Ecto 가이드&lt;/a&gt; 에서 Ecto repo 쿼리가 작동하는 방식을 보았으므로이 호출은 익숙해 보일 것입니다. 우리 &lt;code&gt;list_users&lt;/code&gt; 의 기능은 지정하는 일반화 된 기능입니다 &lt;em&gt;의도를&lt;/em&gt;즉, 사용자를 나열합니다. Repo를 사용하여 PostgreSQL 데이터베이스에서 사용자를 가져 오는 인 텐트의 세부 정보는 호출자에게 숨겨져 있습니다. 이것은 Phoenix 생성기를 사용할 때 반복되는 공통 테마입니다. Phoenix는 애플리케이션에서 우리가 다른 책임이 어디에 있는지 생각하고 세부 사항을 캡슐화하면서 코드의 의도를 명확하게하는 잘 명명 된 모듈과 함수 뒤에있는 다른 영역을 마무리하도록 우리를 밀어 붙일 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1f8c7a704d8b281a05ab2c2ee94c670ce893f15" translate="yes" xml:space="preserve">
          <source>This must be executed from the process that will effectively operate the socket.</source>
          <target state="translated">이것은 소켓을 효과적으로 운영 할 프로세스에서 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a54461d29fcec4b636adb86f49d11ebedc8a4319" translate="yes" xml:space="preserve">
          <source>This operation uses the query cache if one is available.</source>
          <target state="translated">이 작업은 사용 가능한 경우 쿼리 캐시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2e6392283fe53096fd6723c6a52bb14c1fbe0eee" translate="yes" xml:space="preserve">
          <source>This operation will return the underlying data with changes regardless if the changeset is valid or not.</source>
          <target state="translated">이 작업은 변경 집합이 유효한지 여부에 관계없이 기본 데이터를 변경 내용으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="049c09158996c650e55b8f1ec4561fa180509070" translate="yes" xml:space="preserve">
          <source>This option assumes the project was generated with the &lt;code&gt;--binary-id&lt;/code&gt; option, that sets up models to use &lt;code&gt;binary_id&lt;/code&gt; by default. If that&amp;rsquo;s not the case you can still set all your models to use &lt;code&gt;binary_id&lt;/code&gt; by default, by adding the following to your &lt;code&gt;model&lt;/code&gt; function in &lt;code&gt;web/web.ex&lt;/code&gt; or before the &lt;code&gt;schema&lt;/code&gt; declaration:</source>
          <target state="translated">이 옵션은 &lt;code&gt;--binary-id&lt;/code&gt; 옵션으로 프로젝트가 생성되었다고 가정합니다.이 옵션은 모델이 기본적으로 &lt;code&gt;binary_id&lt;/code&gt; 를 사용 하도록 설정합니다. 그렇지 않은 경우 &lt;code&gt;web/web.ex&lt;/code&gt; 의 &lt;code&gt;model&lt;/code&gt; 함수에 또는 &lt;code&gt;schema&lt;/code&gt; 선언 전에 다음을 모델 함수에 추가하여 기본적으로 &lt;code&gt;binary_id&lt;/code&gt; 를 사용하도록 모든 모델을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0391ffae92290b282aabdcb9895807452f2bfe1" translate="yes" xml:space="preserve">
          <source>This option is passed as the &lt;code&gt;:init_mode&lt;/code&gt; to &lt;a href=&quot;plug/plug.builder#compile/3&quot;&gt;&lt;code&gt;Plug.Builder.compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;:init_mode&lt;/code&gt; 로 &lt;a href=&quot;plug/plug.builder#compile/3&quot;&gt; &lt;code&gt;Plug.Builder.compile/3&lt;/code&gt; 에&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="60fcee5e8373c0151773e4d41d75fd04ea48fab0" translate="yes" xml:space="preserve">
          <source>This plug also fetches query params in the connection through &lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt;&lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플러그는 또한 &lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt; &lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt; 를&lt;/a&gt; 통해 연결에서 쿼리 매개 변수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="40a4f301d5fad92658d3d0724f2518201be2787a" translate="yes" xml:space="preserve">
          <source>This plug can be mounted in a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; pipeline as follows:</source>
          <target state="translated">이 플러그는 다음과 같이 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 파이프 라인에 장착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6cd45326cadd9e10a4b5dcc83af5b2968ec6084" translate="yes" xml:space="preserve">
          <source>This plug doesn&amp;rsquo;t accept any options.</source>
          <target state="translated">이 플러그에는 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="50cd1542f80ce2c27c4180007ab1670d825bb257" translate="yes" xml:space="preserve">
          <source>This plug doesn't accept any options.</source>
          <target state="translated">이 플러그는 옵션을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="540542716621eaa96ff36e27e48730d06833088f" translate="yes" xml:space="preserve">
          <source>This plug expects the body parameters to be already parsed and fetched. Those can be fetched with &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플러그는 본문 매개 변수가 이미 구문 분석되고 페치 될 것으로 예상합니다. 이것들은 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01da79a8a81b2988c34c2c491464c98d17827644" translate="yes" xml:space="preserve">
          <source>This plug only parses the body if the request method is one of the following:</source>
          <target state="translated">이 플러그는 요청 메소드가 다음 중 하나 인 경우에만 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="dbc4a6cf27af703236d09b35d3f5b453a3411f43" translate="yes" xml:space="preserve">
          <source>This plug overrides the request&amp;rsquo;s &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="translated">이 플러그 는 &lt;code&gt;_method&lt;/code&gt; 요청 매개 변수에 정의 된 메소드로 요청의 &lt;code&gt;POST&lt;/code&gt; 메소드를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="f9183cda5f0f143ddaa1b79b7dc207c527edb3d2" translate="yes" xml:space="preserve">
          <source>This plug overrides the request's &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="translated">이 플러그 는 &lt;code&gt;_method&lt;/code&gt; 요청 매개 변수에 정의 된 메소드로 요청의 &lt;code&gt;POST&lt;/code&gt; 메소드를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="9cbb2239965b1d685814f5586def8ff4895965d5" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicitly accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">이 플러그는 지정된 형식으로 요청을 구문 분석 할 수없고 MIME 형식이 &lt;code&gt;:pass&lt;/code&gt; 옵션 으로 명시 적으로 허용되지 않은 경우 기본적으로 &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="662ed6e00ff1f8efa3e545b88277587544f54665" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicity accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">이 플러그는 지정된 형식으로 요청을 구문 분석 할 수없고 &lt;code&gt;:pass&lt;/code&gt; 옵션 으로 MIME 형식을 명시 적으로 허용하지 않은 경우 기본적으로 &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="20bad4ce825285978d82d9c5c3e6eb11442c40e0" translate="yes" xml:space="preserve">
          <source>This plug won&amp;rsquo;t generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="translated">이 플러그는 토큰을 자동으로 생성하지 않습니다. 대신, &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 필요한 경우에만 토큰이 생성됩니다 . 특정 특정 URL에 대한 토큰을 생성하는 경우 다른 응용 프로그램으로 토큰이 유출되지 않도록 &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ebbff7ffc8f75e2adf94800f3c930587cc10fe90" translate="yes" xml:space="preserve">
          <source>This plug won't generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="translated">이 플러그는 토큰을 자동으로 생성하지 않습니다. 대신 토큰은 &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 필요할 때만 생성됩니다 . 특정 URL에 대한 토큰을 생성하는 경우 &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; &lt;/a&gt; 을 사용해야 토큰이 다른 애플리케이션으로 유출되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c4c29b3d1afbe8ceed819dcb85452fb4b99844" translate="yes" xml:space="preserve">
          <source>This presents a problem, however: only privileged processes can bind to TCP port numbers under 1024, and it is bad idea to run the application as 'root'.</source>
          <target state="translated">그러나 이것은 문제를 제시합니다. 권한이있는 프로세스 만 1024 미만의 TCP 포트 번호에 바인딩 할 수 있으며 응용 프로그램을 '루트'로 실행하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d38ed574d39239d3ce1ee54fa402c6b77436c31" translate="yes" xml:space="preserve">
          <source>This process is two-fold:</source>
          <target state="translated">이 과정은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="a867af678f59d04d7a0076e28e130a1a90e313f4" translate="yes" xml:space="preserve">
          <source>This protocol is used by URL helpers and other parts of the Phoenix stack. For example, when you write:</source>
          <target state="translated">이 프로토콜은 URL 도우미 및 Phoenix 스택의 다른 부분에서 사용됩니다. 예를 들어 다음과 같이 쓸 때</target>
        </trans-unit>
        <trans-unit id="b21ceddd638e1843ee72cb36616db0e5a04aafff" translate="yes" xml:space="preserve">
          <source>This storage is meant to be used by libraries and frameworks to avoid writing to the user storage (the &lt;code&gt;:assigns&lt;/code&gt; field). It is recommended for libraries/frameworks to prefix the keys with the library name.</source>
          <target state="translated">이 스토리지는 사용자 스토리지 ( &lt;code&gt;:assigns&lt;/code&gt; 필드)에 쓰지 않도록 라이브러리와 프레임 워크에서 사용됩니다 . 라이브러리 / 프레임 워크가 키 앞에 라이브러리 이름을 붙일 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="bcee46e9d2a4acc15bb7cd9f93742faef542611d" translate="yes" xml:space="preserve">
          <source>This store does not create the ETS table; it expects that an existing named table with public properties is passed as an argument.</source>
          <target state="translated">이 상점은 ETS 테이블을 작성하지 않습니다. 공용 속성을 가진 기존 명명 된 테이블이 인수로 전달 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="625b9c2d872b70c5c1c2329e2373298bcd36763e" translate="yes" xml:space="preserve">
          <source>This store, however, can be used as an example for creating custom storages, based on Redis, Memcached, or a database itself.</source>
          <target state="translated">그러나이 저장소는 Redis, Memcached 또는 데이터베이스 자체를 기반으로 사용자 지정 저장소를 만드는 예제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caef9692752dfc364ac9616409959d533077b374" translate="yes" xml:space="preserve">
          <source>This task accepts the same command-line arguments as &lt;code&gt;run&lt;/code&gt;. For additional information, refer to the documentation for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;Mix.Tasks.Run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 작업은 &lt;code&gt;run&lt;/code&gt; 과 동일한 명령 줄 인수를 허용 합니다 . 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;Mix.Tasks.Run&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4685cbdc9dfbc82df635ef6b5492cf1beef5ab7b" translate="yes" xml:space="preserve">
          <source>This task does two things, it creates a digest for our static assets and then compresses them.</source>
          <target state="translated">이 작업은 두 가지 작업을 수행합니다. 정적 자산에 대한 다이제스트를 만든 다음 압축합니다.</target>
        </trans-unit>
        <trans-unit id="c3709bb1a06688cab88fd712fbb47b0071d18988" translate="yes" xml:space="preserve">
          <source>This task has a single purpose, to show us all the routes defined for a given router. We saw it used extensively in the &lt;a href=&quot;routing&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="translated">이 작업은 주어진 라우터에 대해 정의 된 모든 경로를 표시하는 단일 목적을 가지고 있습니다. &lt;a href=&quot;routing&quot;&gt;라우팅 가이드&lt;/a&gt; 에서 광범위하게 사용되는 것을 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="7ffde0bcebb123a904c4c4eeafe54e75892f6516" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Ecto project without web integration, which serves as a core application of your domain for web applications and your greater umbrella platform to integrate with.</source>
          <target state="translated">이 작업은 웹 통합없이 베어 Ecto 프로젝트를 생성하기위한 것으로, 웹 애플리케이션을위한 도메인의 핵심 애플리케이션 및 통합 할 더 큰 우산 플랫폼 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="b654c66530201e2da733b3ab537a9860c5fdd5a9" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Phoenix project without database integration, which interfaces with your greater umbrella application(s).</source>
          <target state="translated">이 작업은 더 큰 우산 응용 프로그램과 상호 작용하는 데이터베이스 통합없이 베어 Phoenix 프로젝트를 생성하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="616b0415ae742d1d7d15218ab99e676b4a35f1b7" translate="yes" xml:space="preserve">
          <source>This task will create the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto), but we can pass in another repo if we want.</source>
          <target state="translated">이 작업은 리포지토리에 지정된 데이터베이스를 생성합니다. 기본적으로 애플리케이션 이름을 딴 저장소 (ecto를 선택 해제하지 않는 한 앱으로 생성 된 저장소)를 찾지 만 원하는 경우 다른 저장소를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc7b8c4356e5eb337a5225b8d22d082a6a6a76d" translate="yes" xml:space="preserve">
          <source>This task will drop the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto). It will not prompt us to check if we're sure we want to drop the db, so do exercise caution.</source>
          <target state="translated">이 작업은 리포지토리에 지정된 데이터베이스를 삭제합니다. 기본적으로 애플리케이션 이름을 따서 명명 된 저장소를 찾습니다 (ecto에서 옵트 아웃하지 않는 한 앱으로 생성 된 저장소). db를 삭제할 것인지 확인하라는 메시지가 표시되지 않으므로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="409b40ea015d00380841d68310ab0678da039272" translate="yes" xml:space="preserve">
          <source>This task will generate a Presence tracker. The module name can be passed as an argument, &lt;code&gt;Presence&lt;/code&gt; is used if no module name is passed.</source>
          <target state="translated">이 작업은 현재 상태 추적기를 생성합니다. 모듈 이름은 인수로 전달할 수 있으며 모듈 이름이 전달되지 않으면 &lt;code&gt;Presence&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d1b8cbdd20775d05499dc18c230d380cd892e5" translate="yes" xml:space="preserve">
          <source>This task will generate a basic Phoenix channel as well a test case for it. It takes the module name for the channel as argument:</source>
          <target state="translated">이 작업은 기본 Phoenix 채널과 이에 대한 테스트 사례를 생성합니다. 채널의 모듈 이름을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="890ecd7a0ef9885062476b818cf0b34cea8d84a4" translate="yes" xml:space="preserve">
          <source>This time around, we used &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt;, which is just like &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt;, except it doesn't generate the web files for us. Since we already have controllers and templates for managing users, we can integrate the new credential features into our existing web form.</source>
          <target state="translated">이번에는 &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; 를&lt;/a&gt; 사용 했는데 이것은 우리를 위해 웹 파일을 생성하지 않는다는 점을 제외하면 &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt; &lt;code&gt;mix phx.gen.html&lt;/code&gt; &lt;/a&gt; 과 같습니다 . 사용자 관리를위한 컨트롤러와 템플릿이 이미 있으므로 새로운 자격 증명 기능을 기존 웹 양식에 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db029b73bc27a4de904b6e1ad6e35f7d5b2ddda5" translate="yes" xml:space="preserve">
          <source>This time we passed the &lt;code&gt;--web&lt;/code&gt; option to the generator. This tells Phoenix what namespace to use for the web modules, such as controllers and views. This is useful when you have conflicting resources in the system, such as our existing &lt;code&gt;PageController&lt;/code&gt;, as well as a way to naturally namespace paths and functionality of different features, like a CMS system. Phoenix instructed us to add a new &lt;code&gt;scope&lt;/code&gt; to the router for a &lt;code&gt;&quot;/cms&quot;&lt;/code&gt; path prefix. Let's copy paste the following into our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, but we'll make one modification to the &lt;code&gt;pipe_through&lt;/code&gt; macro:</source>
          <target state="translated">이번에는 &lt;code&gt;--web&lt;/code&gt; 옵션을 생성기에 전달했습니다 . 이는 Phoenix에게 컨트롤러 및 뷰와 같은 웹 모듈에 사용할 네임 스페이스를 알려줍니다. 이는 기존 &lt;code&gt;PageController&lt;/code&gt; 와 같이 시스템에 충돌하는 리소스가있을 때 유용 할 뿐만 아니라 CMS 시스템과 같은 다양한 기능의 네임 스페이스 경로 및 기능을 자연스럽게 만드는 방법입니다. Phoenix 는 &lt;code&gt;&quot;/cms&quot;&lt;/code&gt; 경로 접두사에 대해 라우터에 새 &lt;code&gt;scope&lt;/code&gt; 를 추가하도록 지시했습니다 . 다음을 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 에 복사 해 보겠습니다 . 그러나 &lt;code&gt;pipe_through&lt;/code&gt; 매크로 를 한 가지 수정 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d5878eb3c414b2f8b0bc85b921219b0b8c00c144" translate="yes" xml:space="preserve">
          <source>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</source>
          <target state="translated">이 유효성 검사는 하나의 특정 매개 변수가 true인지 확인하는 데 사용되므로 스키마 또는 유효성을 검사하는 데이터에 필드가 효과적으로 존재하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d696deb31d0b50d9d5193d12918eed93ff0a69c5" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won&amp;rsquo;t be changed.</source>
          <target state="translated">이렇게하면 특정 국가의 연결 만 전송하고 업데이트 할 수 있습니다. 부분 변경의 중요한 점은 미리로드되지 않은 주소는 변경되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a25d158d0047cb15049aa3798895382c7cd6f354" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won't be changed.</source>
          <target state="translated">이렇게하면 해당 국가의 연결 만 전송하고 업데이트 할 수 있습니다. 부분 변경의 중요한 점은 미리로드되지 않은 주소는 변경되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="96c8ad2e97ff0533cdfdce33b58a986331978807" translate="yes" xml:space="preserve">
          <source>This will force the token to be deleted once the response is sent.</source>
          <target state="translated">응답이 전송되면 토큰이 강제로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c6845572f50f3240fbaa36674696b8cf400c3eda" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index.</source>
          <target state="translated">&lt;code&gt;:integer&lt;/code&gt; 열이 &lt;code&gt;:user_id&lt;/code&gt; 인 마이그레이션이 발생 하고 인덱스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="cde93bead76f590b8ac92f4411245903df6471af" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index. It will also generate the appropriate &lt;code&gt;belongs_to&lt;/code&gt; entry in the schema.</source>
          <target state="translated">&lt;code&gt;:integer&lt;/code&gt; 열이 &lt;code&gt;:user_id&lt;/code&gt; 인 마이그레이션이 발생 하고 인덱스가 작성됩니다. 또한 스키마에서 적절한 &lt;code&gt;belongs_to&lt;/code&gt; 엔트리를 생성 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7e29ee867b8709dab14972a2f1549cbc060ff5db" translate="yes" xml:space="preserve">
          <source>This will set up all the correct dependencies and configuration for us automatically. Once we install those dependencies with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;, we'll be ready to begin working with Ecto in our application.</source>
          <target state="translated">이렇게하면 모든 올바른 종속성과 구성이 자동으로 설정됩니다. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; &lt;/a&gt; 을 사용하여 이러한 종속성을 설치하면 애플리케이션에서 Ecto 작업을 시작할 준비가 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c4b144557001b546396a316d80e5ba0955281ab" translate="yes" xml:space="preserve">
          <source>This works because both &quot;index.json&quot; and &quot;show.json&quot; builds themselves on top of an internal &quot;page.json&quot; clause.</source>
          <target state="translated">이것은 &quot;index.json&quot;과 &quot;show.json&quot;이 내부 &quot;page.json&quot;절 위에 구축되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c5fe4ec7110a029f93aee2c49d16dd655e8fb777" translate="yes" xml:space="preserve">
          <source>Those are a lot of words bunched up together. Let's take a look at some examples to untangle their meaning.</source>
          <target state="translated">그것들은 함께 묶인 많은 단어들입니다. 그 의미를 풀기 위해 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="36a1b1b32231c3e4ff53add950295c72883cbbfb" translate="yes" xml:space="preserve">
          <source>Those functions are imported from two modules:</source>
          <target state="translated">이러한 기능은 다음 두 모듈에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6208b0413cd71b1dcc6adedd2bd128dd9d87591a" translate="yes" xml:space="preserve">
          <source>Those guards work like regular Elixir guards and the only variables accessible in the guard are &lt;code&gt;conn&lt;/code&gt;, the &lt;code&gt;action&lt;/code&gt; as an atom and the &lt;code&gt;controller&lt;/code&gt; as an alias.</source>
          <target state="translated">이 가드는 일반 Elixir 가드처럼 작동하며 가드에서 액세스 할 수있는 유일한 변수는 &lt;code&gt;conn&lt;/code&gt; , 원자로서의 &lt;code&gt;action&lt;/code&gt; 및 별명으로 &lt;code&gt;controller&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f149875499b6816d281bb93f8f7b7be48949a3a5" translate="yes" xml:space="preserve">
          <source>Those values can now be accessed on the connected mount as &lt;a href=&quot;#get_connect_info/1&quot;&gt;&lt;code&gt;get_connect_info/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이러한 값은 이제 연결된 마운트에서 &lt;a href=&quot;#get_connect_info/1&quot;&gt; &lt;code&gt;get_connect_info/1&lt;/code&gt; &lt;/a&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c33c34b9d82c886b7a72a0d75a72202741c4d268" translate="yes" xml:space="preserve">
          <source>Through &lt;em&gt;telemetry&lt;/em&gt;, Phoenix is able to collect metrics and send monitoring events of your application. The &lt;code&gt;lib/hello_web/telemetry.ex&lt;/code&gt; file defines the supervisor responsible for managing the telemetry processes. You can find more information on this topic in the &lt;a href=&quot;telemetry&quot;&gt;Telemetry guide&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;원격 측정을&lt;/em&gt; 통해 Phoenix는 메트릭을 수집하고 애플리케이션의 모니터링 이벤트를 보낼 수 있습니다. &lt;code&gt;lib/hello_web/telemetry.ex&lt;/code&gt; 파일은 원격 프로세스를 관리하는 책임을 맡은 관리자를 정의합니다. 이 항목에 대한 자세한 내용은 &lt;a href=&quot;telemetry&quot;&gt;원격 측정 가이드&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a630c7d1a3b50b97144115174bddba022d807367" translate="yes" xml:space="preserve">
          <source>Time unit</source>
          <target state="translated">시간 단위</target>
        </trans-unit>
        <trans-unit id="39d358d22755c113807898f4d747028acc84c714" translate="yes" xml:space="preserve">
          <source>Timeout while waiting for the request.</source>
          <target state="translated">요청을 기다리는 동안 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="e399371341816e13494a8f090bb6bc62bee13531" translate="yes" xml:space="preserve">
          <source>To aid debugging on the client when troubleshooting issues, the &lt;code&gt;enableDebug()&lt;/code&gt; and &lt;code&gt;disableDebug()&lt;/code&gt; functions are exposed on the &lt;code&gt;LiveSocket&lt;/code&gt; JavaScript instance. Calling &lt;code&gt;enableDebug()&lt;/code&gt; turns on debug logging which includes LiveView life-cycle and payload events as they come and go from client to server. In practice, you can expose your instance on &lt;code&gt;window&lt;/code&gt; for quick access in the browser's web console, for example:</source>
          <target state="translated">문제를 해결할 때 클라이언트에서 디버깅을 지원하기 위해 &lt;code&gt;enableDebug()&lt;/code&gt; 및 &lt;code&gt;disableDebug()&lt;/code&gt; 함수가 &lt;code&gt;LiveSocket&lt;/code&gt; JavaScript 인스턴스 에 노출됩니다 . &lt;code&gt;enableDebug()&lt;/code&gt; 호출 하면 클라이언트에서 서버로 들어오고 나가는 LiveView 수명주기 및 페이로드 이벤트를 포함하는 디버그 로깅이 설정됩니다. 실제로 브라우저의 웹 콘솔에서 빠르게 액세스 할 수 있도록 &lt;code&gt;window&lt;/code&gt; 에 인스턴스를 노출 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4909edd3c35b1902875bfd0c83e9c081850f71db" translate="yes" xml:space="preserve">
          <source>To allow the user to download contents that are in memory as a binary or string:</source>
          <target state="translated">사용자가 메모리에있는 컨텐츠를 2 진 또는 문자열로 다운로드 할 수있게하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e6a6975b062fa8a73779dc6d912719d7498131ee" translate="yes" xml:space="preserve">
          <source>To assert that your channel closes or errors asynchronously, you can monitor the channel process with the tools provided by Elixir, and wait for the &lt;code&gt;:DOWN&lt;/code&gt; message. Imagine an implementation of the &lt;code&gt;handle_info/2&lt;/code&gt; function that closes the channel when it receives &lt;code&gt;:some_message&lt;/code&gt;:</source>
          <target state="translated">채널이 비동기 적으로 닫히거나 오류가 발생하도록하려면 Elixir에서 제공하는 도구를 사용하여 채널 프로세스를 모니터링하고 &lt;code&gt;:DOWN&lt;/code&gt; 메시지를 기다리십시오 . 구현의 상상 &lt;code&gt;handle_info/2&lt;/code&gt; 가 수신되면 상기 채널을 닫는 기능 &lt;code&gt;:some_message&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53a832ff355a8bff56d545715860a666b9283a42" translate="yes" xml:space="preserve">
          <source>To authorize a socket in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:ok, socket}&lt;/code&gt;. To refuse authorization in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;join/3&lt;/code&gt; 의 소켓에 권한을 부여하려면 &lt;code&gt;{:ok, socket}&lt;/code&gt; 리턴하십시오 . &lt;code&gt;join/3&lt;/code&gt; 에서 권한 부여를 거부하려면 &lt;code&gt;{:error, reply}&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="de3aa50e1fa13ab8540858290ff3bab5cc1ae7a1" translate="yes" xml:space="preserve">
          <source>To authorize a socket, return &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, reply, socket}&lt;/code&gt;. To refuse authorization, return &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">소켓을 인증하려면 &lt;code&gt;{:ok, socket}&lt;/code&gt; 또는 &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 반환하십시오 . 승인을 거부하려면 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="68caf8123fc9000c1892d49a830e2a777c1a2f79" translate="yes" xml:space="preserve">
          <source>To avoid race conditions, all code reloads are funneled through a sequential call operation.</source>
          <target state="translated">경쟁 조건을 피하기 위해 모든 코드 재로드는 순차적 호출 작업을 통해 퍼널 링됩니다.</target>
        </trans-unit>
        <trans-unit id="8adf099970e8f40f42c4a78cc8072bacf109f61f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &quot;age&quot; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="translated">항상 유형을 지정하는 반복을 피하기 위해 &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; 를&lt;/a&gt; 정의 할 수 있습니다 . 이러한 경우, Ecto는 쿼리를 분석하고 &lt;code&gt;u.age&lt;/code&gt; 필드 와 비교할 때 보간 된 &quot;age&quot;를 자동으로 캐스팅합니다. 단 , age 필드가 스키마에서 &lt;code&gt;:integer&lt;/code&gt; 유형으로 정의 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da79393192b9d811f048b628589434c69cfc70f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &amp;ldquo;age&amp;rdquo; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="translated">항상 유형을 지정하는 반복을 피하기 위해 &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; 를&lt;/a&gt; 정의 할 수 있습니다 . 이러한 경우 Ecto는 연령 필드가 스키마에서 &lt;code&gt;:integer&lt;/code&gt; 유형으로 정의되어 있는 한 &lt;code&gt;u.age&lt;/code&gt; 필드 와 비교할 때 쿼리를 분석하고 보간 된 &quot;나이&quot;를 자동으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="8207ca543301d2f877c271b7b261d6d50b3481d1" translate="yes" xml:space="preserve">
          <source>To capture additional user-defined metadata, the &lt;code&gt;metadata&lt;/code&gt; option for keydown events may be provided to the &lt;code&gt;LiveSocket&lt;/code&gt; constructor. For example:</source>
          <target state="translated">추가 사용자 정의 메타 데이터를 캡처하기 위해 키 다운 이벤트에 대한 &lt;code&gt;metadata&lt;/code&gt; 옵션이 &lt;code&gt;LiveSocket&lt;/code&gt; 생성자에 제공 될 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="671a861e30e1350c320f440b81de252cf52633f6" translate="yes" xml:space="preserve">
          <source>To check if a given value is not nil use:</source>
          <target state="translated">주어진 값이 아닌지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01fee11f0023eae7979272d215e7845252d7aad1" translate="yes" xml:space="preserve">
          <source>To check that we are on Elixir 1.6 and Erlang 20 or later, run:</source>
          <target state="translated">Elixir 1.6 및 Erlang 20 이상을 사용하고 있는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="79d31d5fab3f480e2385850ab0894e631ce9ef5d" translate="yes" xml:space="preserve">
          <source>To complete the web changes, let's display the author when showing a page. First, open up &lt;code&gt;lib/hello_web/views/cms/page_view.ex&lt;/code&gt; and add a helper function to handle formatting the author's name:</source>
          <target state="translated">웹 변경을 완료하기 위해 페이지를 표시 할 때 작성자를 표시하겠습니다. 먼저 &lt;code&gt;lib/hello_web/views/cms/page_view.ex&lt;/code&gt; 를 열고 작성자 이름 형식을 처리하는 도우미 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c397997817b65b5ed32d80d0da887e047de03d3c" translate="yes" xml:space="preserve">
          <source>To convert a single DER-encoded certificate to PEM format: &lt;code&gt;openssl x509 -in server.crt -inform der -out cert.pem&lt;/code&gt;</source>
          <target state="translated">단일 DER 인코딩 인증서를 PEM 형식으로 변환하려면 : &lt;code&gt;openssl x509 -in server.crt -inform der -out cert.pem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21c91ab4294a0c1228f999e655eeea2400a408db" translate="yes" xml:space="preserve">
          <source>To convert an RSA private key from DER to PEM format: &lt;code&gt;openssl rsa -in privkey.der -inform der -out privkey.pem&lt;/code&gt;. If the private key is a Elliptic Curve key, for use with an ECDSA certificate, replace &lt;code&gt;rsa&lt;/code&gt; with &lt;code&gt;ec&lt;/code&gt;. You may want to add the &lt;code&gt;-aes128&lt;/code&gt; argument to produce an encrypted, password protected PEM file.</source>
          <target state="translated">RSA 개인 키를 DER에서 PEM 형식으로 변환하려면 : &lt;code&gt;openssl rsa -in privkey.der -inform der -out privkey.pem&lt;/code&gt; . 개인 키가 Elliptic Curve 키인 경우 ECDSA 인증서와 함께 사용하려면 &lt;code&gt;rsa&lt;/code&gt; 를 &lt;code&gt;ec&lt;/code&gt; 로 바꿉니다 . &lt;code&gt;-aes128&lt;/code&gt; 인수 를 추가하여 암호화되고 암호로 보호 된 PEM 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5971dfca497a6c6184fac2256a6394332e77294b" translate="yes" xml:space="preserve">
          <source>To create a parameterized type, create a module as shown below:</source>
          <target state="translated">매개 변수화 된 유형을 생성하려면 아래와 같이 모듈을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="32b59c202fb3d6f550fc3db4a98cf2a4a434dded" translate="yes" xml:space="preserve">
          <source>To customize the JSON library, including the following in your &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; 에 다음을 포함하여 JSON 라이브러리를 사용자 정의하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf7347e6fe2acbe195851637b64939807583f935" translate="yes" xml:space="preserve">
          <source>To deny connection, return &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">연결을 거부하려면 &lt;code&gt;:error&lt;/code&gt; 를 반환 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2be30a876faae18a5e22e23e0ff825ea8e07d2e2" translate="yes" xml:space="preserve">
          <source>To detect when the page itself has received focus or blur, &lt;code&gt;phx-window-focus&lt;/code&gt; and &lt;code&gt;phx-window-blur&lt;/code&gt; may be specified. These window level events may also be necessary if the element in consideration (most often a &lt;code&gt;div&lt;/code&gt; with no tabindex) cannot receive focus. Like other bindings, &lt;code&gt;phx-value-*&lt;/code&gt; can be provided on the bound element, and those values will be sent as part of the payload. For example:</source>
          <target state="translated">페이지 자체가 포커스 또는 블러를 &lt;code&gt;phx-window-focus&lt;/code&gt; 감지하기 위해 phx-window-focus 및 &lt;code&gt;phx-window-blur&lt;/code&gt; 를 지정할 수 있습니다. 고려중인 요소 (대부분 tabindex가없는 &lt;code&gt;div&lt;/code&gt; )가 포커스를받을 수없는 경우에도 이러한 창 수준 이벤트가 필요할 수 있습니다. 다른 바인딩과 마찬가지로 &lt;code&gt;phx-value-*&lt;/code&gt; 는 바인딩 된 요소에 제공 될 수 있으며 해당 값은 페이로드의 일부로 전송됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="698f42b33364629b9c00b1979a5fc7ddebd7d515" translate="yes" xml:space="preserve">
          <source>To determine which key has been pressed you should use &lt;code&gt;key&lt;/code&gt; value. The available options can be found on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;MDN&lt;/a&gt; or via the &lt;a href=&quot;https://w3c.github.io/uievents/tools/key-event-viewer.html&quot;&gt;Key Event Viewer&lt;/a&gt;.</source>
          <target state="translated">어떤 키를 눌렀는지 확인하려면 &lt;code&gt;key&lt;/code&gt; 값을 사용해야 합니다. 사용 가능한 옵션은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;MDN&lt;/a&gt; 또는 &lt;a href=&quot;https://w3c.github.io/uievents/tools/key-event-viewer.html&quot;&gt;키 이벤트 뷰어&lt;/a&gt; 를 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ee4e1597fac73b7cdbd9aafc8a4cfde3cac889d" translate="yes" xml:space="preserve">
          <source>To discuss new features in the framework, email the &lt;a href=&quot;https://groups.google.com/group/phoenix-core&quot;&gt;phoenix-core mailing list&lt;/a&gt;.</source>
          <target state="translated">프레임 워크의 새로운 기능에 대해 논의하려면 &lt;a href=&quot;https://groups.google.com/group/phoenix-core&quot;&gt;phoenix-core 메일 링리스트로&lt;/a&gt; 이메일을 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="50ac5d4ffcf89463b90bde0bceaf630200030aa1" translate="yes" xml:space="preserve">
          <source>To do so, the first step is to mark which assigns are temporary and what values they should be reset to on mount:</source>
          <target state="translated">이를 위해 첫 번째 단계는 임시 할당을 표시하고 마운트시 재설정해야하는 값을 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="75f92de1c10aadb6a962f6da37154da77404e61e" translate="yes" xml:space="preserve">
          <source>To do that, we'll use the special EEx tags for executing Elixir expressions - &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;. Notice that the initial tag has an equals sign like this: &lt;code&gt;&amp;lt;%=&lt;/code&gt; . That means that any Elixir code that goes between those tags will be executed, and the resulting value will replace the tag. If the equals sign were missing, the code would still be executed, but the value would not appear on the page.</source>
          <target state="translated">이를 위해 Elixir 표현식 실행에 특수 EEx 태그 인 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 합니다. 초기 태그에는 다음과 같은 등호가 있습니다. &lt;code&gt;&amp;lt;%=&lt;/code&gt; . 즉, 해당 태그 사이에있는 모든 Elixir 코드가 실행되고 결과 값이 태그를 대체합니다. 등호 기호가없는 경우 코드는 계속 실행되지만 값은 페이지에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7207faf406837a635de5a70263b6dfda70627f88" translate="yes" xml:space="preserve">
          <source>To do this we modify the &lt;code&gt;index&lt;/code&gt; action as follows:</source>
          <target state="translated">이를 위해 &lt;code&gt;index&lt;/code&gt; 작업을 다음과 같이 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c26c7d45e6051c71e7fe3c380da3a4f17f88bda" translate="yes" xml:space="preserve">
          <source>To dump the state from the current process and load into another one:</source>
          <target state="translated">현재 프로세스에서 상태를 덤프하고 다른 프로세스로로드하려면 :</target>
        </trans-unit>
        <trans-unit id="1756faaf0ba51188a497e41da02799505ffedbc4" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#build_conn/0&quot;&gt;&lt;code&gt;build_conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="translated">이 동작을 모방하기 위해이 모듈은 재활용에 대한 아이디어를 제공합니다. &lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt; 함수에 의해 리턴 된 것과 유사한 연결 복귀 새로운 연결 수신 &lt;a href=&quot;#build_conn/0&quot;&gt; &lt;code&gt;build_conn/0&lt;/code&gt; &lt;/a&gt; 요청 헤더로 정의 이전 연결 모든 응답을 쿠키. 이는 쿠키 또는 세션이 작동해야하는 여러 경로를 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="384f423fceb68dce0e44059e7dc17f0229bd095a" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#conn/0&quot;&gt;&lt;code&gt;conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="translated">이 동작을 모방하기 위해이 모듈은 재활용 아이디어를 제공합니다. &lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt; 함수에 의해 리턴 된 것과 유사한 연결 복귀 새로운 연결 수신 &lt;a href=&quot;#conn/0&quot;&gt; &lt;code&gt;conn/0&lt;/code&gt; &lt;/a&gt; 요청 헤더로 정의 이전 연결 모든 응답을 쿠키. 쿠키 나 세션이 작동해야하는 여러 경로를 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="091d07c554f0a419f1e21a5c0aae91e5f028e992" translate="yes" xml:space="preserve">
          <source>To encrypt an existing PEM-encoded RSA key use the OpenSSL CLI: &lt;code&gt;openssl rsa -in privkey.pem -out privkey_aes.pem -aes128&lt;/code&gt;. Use &lt;code&gt;ec&lt;/code&gt; instead of &lt;code&gt;rsa&lt;/code&gt; when using an ECDSA certificate. Don't forget to securely erase the unencrypted copy afterwards! Best practice would be to encrypt the file immediately during initial key generation: please refer to the instructions provided by the CA.</source>
          <target state="translated">기존 PEM 인코딩 RSA 키를 암호화하려면 OpenSSL CLI를 사용하십시오. &lt;code&gt;openssl rsa -in privkey.pem -out privkey_aes.pem -aes128&lt;/code&gt; . ECDSA 인증서를 사용할 때 &lt;code&gt;rsa&lt;/code&gt; 대신 &lt;code&gt;ec&lt;/code&gt; 를 사용하십시오 . 나중에 암호화되지 않은 사본을 안전하게 지우는 것을 잊지 마십시오! 가장 좋은 방법은 초기 키 생성 중에 파일을 즉시 암호화하는 것입니다. CA에서 제공하는 지침을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce8e7a44c764d649b22d4767dfb19181500bc611" translate="yes" xml:space="preserve">
          <source>To encrypt, you would do:</source>
          <target state="translated">암호화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="df2c16aad4e09f5b6f276b143ea796814d9ed388" translate="yes" xml:space="preserve">
          <source>To extract a private key from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nocerts -nodes -out privkey.pem&lt;/code&gt;. You may want to replace the &lt;code&gt;-nodes&lt;/code&gt; argument with &lt;code&gt;-aes128&lt;/code&gt; to produce an encrypted, password protected PEM file.</source>
          <target state="translated">PKCS # 12 파일에서 PEM 파일로 개인 키를 추출하려면 : &lt;code&gt;openssl pkcs12 -in server.p12 -nocerts -nodes -out privkey.pem&lt;/code&gt; . 당신은 대체 할 수 &lt;code&gt;-nodes&lt;/code&gt; 으로 인수를 &lt;code&gt;-aes128&lt;/code&gt; 암호화, 암호로 보호 된 PEM 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2808505a7c943eb2ca42f02d966df7c8298102af" translate="yes" xml:space="preserve">
          <source>To extract all certificates from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nokeys -out fullchain.pem&lt;/code&gt;. The resulting file contains all certificates from the input file, typically the server certificate and any CA certificates that make up the CA chain. You can split the file into seperate &lt;code&gt;cert.pem&lt;/code&gt; and &lt;code&gt;chain.pem&lt;/code&gt; files using a text editor, or you can just pass &lt;code&gt;certfile: fullchain.pem&lt;/code&gt; to the HTTPS adapter.</source>
          <target state="translated">PKCS # 12 파일에서 PEM 파일로 모든 인증서를 추출하려면 : &lt;code&gt;openssl pkcs12 -in server.p12 -nokeys -out fullchain.pem&lt;/code&gt; . 결과 파일에는 입력 파일의 모든 인증서, 일반적으로 서버 인증서 및 CA 체인을 구성하는 모든 CA 인증서가 포함됩니다. 텍스트 편집기를 사용하여 파일을 별도의 &lt;code&gt;cert.pem&lt;/code&gt; 및 &lt;code&gt;chain.pem&lt;/code&gt; 파일로 분할 하거나 &lt;code&gt;certfile: fullchain.pem&lt;/code&gt; 을 HTTPS 어댑터에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34840b98dd241bba5b79a7b5023d3157b2b9193b" translate="yes" xml:space="preserve">
          <source>To fix this, we can change the password in the environment specific configuration file. For the development environment the password used can be found at the bottom of the &lt;code&gt;config/dev.exs&lt;/code&gt; file.</source>
          <target state="translated">이 문제를 해결하기 위해 환경 별 구성 파일에서 비밀번호를 변경할 수 있습니다. 개발 환경의 경우 사용 된 비밀번호는 &lt;code&gt;config/dev.exs&lt;/code&gt; 파일 하단에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e7d714947644732e2d22535431e05bc99b95dad" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user in the &lt;code&gt;psql&lt;/code&gt; console to allow database creation.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;psql&lt;/code&gt; 콘솔 에서 &quot;postgres&quot;사용자의 권한을 변경하여 데이터베이스 생성을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5820c90b7b57a2442e1e4a6a440c255446634ff" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user to allow login.</source>
          <target state="translated">이 문제를 해결하려면 로그인을 허용하도록 &quot;postgres&quot;사용자의 권한을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="12f12d3a42e639e525547c376c3befad88231e53" translate="yes" xml:space="preserve">
          <source>To forgo automatic form recovery, set &lt;code&gt;phx-auto-recover=&quot;ignore&quot;&lt;/code&gt;.</source>
          <target state="translated">자동 양식 복구를 중단하려면 &lt;code&gt;phx-auto-recover=&quot;ignore&quot;&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9add98f21666a54716c50850567b90f96e0b16a8" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &quot;priv/static&quot;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">&lt;code&gt;@conn&lt;/code&gt; 엔드 포인트를 사용 하여 애플리케이션 &quot;priv / static&quot;에서 호스팅되는 이미지에 대한 경로를 생성하려면 &lt;code&gt;static_path/2&lt;/code&gt; 를 사용 하여 캐시 제어 매개 변수가있는 URL을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b31df5e294e6f54107ca6b36caf70de5a703ae9d" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, use &lt;code&gt;static_path/1&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">애플리케이션 &quot;priv / static&quot;에서 호스팅되는 이미지의 경로를 생성하려면 &lt;code&gt;static_path/1&lt;/code&gt; 을 사용 하여 캐시 제어 매개 변수가있는 URL을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="166e05bfe8272abd2c663bb42e431b56b9c76ee6" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">&lt;code&gt;@conn&lt;/code&gt; 엔드 포인트를 사용 하여 애플리케이션 &quot;priv / static&quot;에서 호스팅되는 이미지의 경로를 생성하려면 &lt;code&gt;static_path/2&lt;/code&gt; 를 사용 하여 캐시 제어 매개 변수가있는 URL을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="da5cf0c3b662f85cf689692d186e495d82685f37" translate="yes" xml:space="preserve">
          <source>To get started, define the module attribute &lt;code&gt;@endpoint&lt;/code&gt; in your test case pointing to your application endpoint.</source>
          <target state="translated">시작하려면 테스트 케이스에서 애플리케이션 엔드 포인트를 가리키는 모듈 속성 &lt;code&gt;@endpoint&lt;/code&gt; 를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f00e2408e6e8f684d6ca6cbd6ebed088bfa8147" translate="yes" xml:space="preserve">
          <source>To get started, see our &lt;a href=&quot;phoenix/overview&quot;&gt;overview guides&lt;/a&gt;.</source>
          <target state="translated">시작하려면 &lt;a href=&quot;phoenix/overview&quot;&gt;개요 가이드를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="7ba9a108051080537e0193e44354907bb5392a7d" translate="yes" xml:space="preserve">
          <source>To give it a try, let's add this plug to our router:</source>
          <target state="translated">시도해보기 위해이 플러그를 라우터에 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f52a3e3b8dd3d57e8b74bdd60fe023df58eda4ed" translate="yes" xml:space="preserve">
          <source>To handle custom client-side JavaScript when an element is added, updated, or removed by the server, a hook object may be provided with the following life-cycle callbacks:</source>
          <target state="translated">서버에서 요소를 추가, 업데이트 또는 제거 할 때 사용자 지정 클라이언트 측 JavaScript를 처리하기 위해 후크 개체에 다음 수명주기 콜백을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c9f6eff2338b6f7de44ce146c839d9e841d092" translate="yes" xml:space="preserve">
          <source>To handle form changes and submissions, use the &lt;code&gt;phx-change&lt;/code&gt; and &lt;code&gt;phx-submit&lt;/code&gt; events. In general, it is preferred to handle input changes at the form level, where all form fields are passed to the LiveView's callback given any single input change. For example, to handle real-time form validation and saving, your template would use both &lt;code&gt;phx_change&lt;/code&gt; and &lt;code&gt;phx_submit&lt;/code&gt; bindings:</source>
          <target state="translated">양식 변경 및 제출을 처리하려면 &lt;code&gt;phx-change&lt;/code&gt; 및 &lt;code&gt;phx-submit&lt;/code&gt; 이벤트를 사용하십시오. 일반적으로 단일 입력 변경이 주어지면 모든 양식 필드가 LiveView의 콜백으로 전달되는 양식 수준에서 입력 변경을 처리하는 것이 좋습니다. 예를 들어 실시간 양식 유효성 검사 및 저장을 처리하기 위해 템플릿은 &lt;code&gt;phx_change&lt;/code&gt; 및 &lt;code&gt;phx_submit&lt;/code&gt; 바인딩을 모두 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="267d7ad17f4eb697f730fe2dade15352df2b644f" translate="yes" xml:space="preserve">
          <source>To handle latent events, any HTML tag can be annotated with &lt;code&gt;phx-disable-with&lt;/code&gt;, which swaps the element's &lt;code&gt;innerText&lt;/code&gt; with the provided value during event submission. For example, the following code would change the &quot;Save&quot; button to &quot;Saving...&quot;, and restore it to &quot;Save&quot; on acknowledgment:</source>
          <target state="translated">잠재 이벤트를 처리하기 위해 모든 HTML 태그에 &lt;code&gt;phx-disable-with&lt;/code&gt; 주석을 달 수 있습니다.이 태그는 이벤트 제출 중에 요소의 &lt;code&gt;innerText&lt;/code&gt; 를 제공된 값 으로 교체 합니다. 예를 들어, 다음 코드는 &quot;저장&quot;버튼을 &quot;저장 중 ...&quot;으로 변경하고 승인시 &quot;저장&quot;으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="2c017a576254a552f3b45b37a156813727bf60fc" translate="yes" xml:space="preserve">
          <source>To have coalesce/2 available, just import the module that defines it.</source>
          <target state="translated">통합 / 2를 사용 가능하게하려면이를 정의하는 모듈을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="e75ef0e9c4fd7b13190431887d04db3dc76e0ef4" translate="yes" xml:space="preserve">
          <source>To hide a fields value from the inspect protocol of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;, mark the field as &lt;code&gt;redact: true&lt;/code&gt; in the schema, and it will display with the value &lt;code&gt;**redacted**&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 의 검사 프로토콜에서 필드 값을 숨기려면 스키마에서 필드를 redact &lt;code&gt;redact: true&lt;/code&gt; 로 표시하면 &lt;code&gt;**redacted**&lt;/code&gt; 값으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="855cc0ad003d98da4f4ca9c2d54547a476da02d3" translate="yes" xml:space="preserve">
          <source>To keep things simple, we added both our sign-in and sign-out forms in this template. For our sign-in form, we pass the &lt;code&gt;@conn&lt;/code&gt; directly to &lt;code&gt;form_for&lt;/code&gt;, pointing our form action at &lt;code&gt;session_path(@conn, :create)&lt;/code&gt;. We also pass the &lt;code&gt;as: :user&lt;/code&gt; option which tells Phoenix to wrap the form parameters inside a &lt;code&gt;&quot;user&quot;&lt;/code&gt; key. Next, we used the &lt;code&gt;text_input&lt;/code&gt; and &lt;code&gt;password_input&lt;/code&gt; functions to send up an &lt;code&gt;&quot;email&quot;&lt;/code&gt; and &lt;code&gt;&quot;password&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">간단하게하기 위해이 템플릿에 로그인 및 로그 아웃 양식을 모두 추가했습니다. 로그인 양식의 경우 &lt;code&gt;@conn&lt;/code&gt; 을 &lt;code&gt;form_for&lt;/code&gt; 로 직접 전달하여 &lt;code&gt;session_path(@conn, :create)&lt;/code&gt; 에서 양식 작업을 가리 킵니다 . 또한 &lt;code&gt;&quot;user&quot;&lt;/code&gt; 키 안에 양식 매개 변수를 감싸도록 Phoenix에 지시 하는 &lt;code&gt;as: :user&lt;/code&gt; 옵션 도 전달합니다 . 다음으로 &lt;code&gt;text_input&lt;/code&gt; 및 &lt;code&gt;password_input&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&quot;email&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;password&quot;&lt;/code&gt; 매개 변수 를 전송했습니다 .</target>
        </trans-unit>
        <trans-unit id="41ef78913465515a398d685d02fba061196e4bdf" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; you can read the &lt;a href=&quot;mix_tasks#phoenix-specific-mix-tasks&quot;&gt;Mix Tasks Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 에 대해 자세히 알아 보려면 &lt;a href=&quot;mix_tasks#phoenix-specific-mix-tasks&quot;&gt;Mix Tasks Guide를&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="41d3efd7490499ce0623a7738176753951ffa31a" translate="yes" xml:space="preserve">
          <source>To learn more about Plugs, see the documentation for &lt;a href=&quot;https://hexdocs.pm/plug&quot;&gt;the Plug project&lt;/a&gt;, which provides many built-in plugs and functionalities.</source>
          <target state="translated">Plugs에 대해 자세히 알아 보려면 다양한 기본 제공 플러그인 및 기능을 제공 &lt;a href=&quot;https://hexdocs.pm/plug&quot;&gt;하는 Plug 프로젝트&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="07ecc754901c9b7b1612b2347516e5e86c89fd01" translate="yes" xml:space="preserve">
          <source>To load data from non-database sources, use &lt;a href=&quot;ecto#embedded_load/3&quot;&gt;&lt;code&gt;Ecto.embedded_load/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 데이터베이스 소스에서 데이터를로드하려면 &lt;a href=&quot;ecto#embedded_load/3&quot;&gt; &lt;code&gt;Ecto.embedded_load/3&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9c5bfde6fe357ce410561f8996b3ca30aa626e4" translate="yes" xml:space="preserve">
          <source>To log the status of requests being sent:</source>
          <target state="translated">전송중인 요청의 상태를 기록하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ee680d8d89287bdbf31b386e8103c640bb092faa" translate="yes" xml:space="preserve">
          <source>To log the status of response being sent:</source>
          <target state="translated">전송중인 응답의 상태를 기록하려면 :</target>
        </trans-unit>
        <trans-unit id="b84dbd8c1d5f506769b351fa5d09d5ae2afb79fe" translate="yes" xml:space="preserve">
          <source>To make that happen, let's create a new &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; file, and make it look like the following:</source>
          <target state="translated">이를 위해 새 &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; 파일을 만들고 다음과 같이 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4ba9cdf779e09df433f92db1ffd43f9ee1c2b0dd" translate="yes" xml:space="preserve">
          <source>To make the value label easier to read, we can update our private function to generate more user friendly names. We'll run the value of the &lt;code&gt;:view&lt;/code&gt; through &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/1&quot;&gt;&lt;code&gt;inspect/1&lt;/code&gt;&lt;/a&gt; to remove the &lt;code&gt;Elixir.&lt;/code&gt; prefix and call another private function to convert the &lt;code&gt;connected?&lt;/code&gt; boolean into human readable text.</source>
          <target state="translated">값 레이블을 더 쉽게 읽을 수 있도록 개인 함수를 업데이트하여 사용자에게 더 친숙한 이름을 생성 할 수 있습니다. &lt;code&gt;Elixir.&lt;/code&gt; 를 제거 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/1&quot;&gt; &lt;code&gt;inspect/1&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:view&lt;/code&gt; 에서 inspect / 1 까지 의 값을 실행할 것 입니다. 접두사를 입력하고 다른 개인 함수를 호출하여 &lt;code&gt;connected?&lt;/code&gt; 것을 변환 합니까? 사람이 읽을 수있는 텍스트로 부울.</target>
        </trans-unit>
        <trans-unit id="67920df22e1378273bb126fe074d93ace6df9e19" translate="yes" xml:space="preserve">
          <source>To make this all work, we converted the nested blocks of code and used &lt;code&gt;halt(conn)&lt;/code&gt; whenever we reached a failure path. The &lt;code&gt;halt(conn)&lt;/code&gt; functionality is essential here: it tells Plug that the next plug should not be invoked.</source>
          <target state="translated">이 모든 것이 작동하도록하기 위해 중첩 된 코드 블록을 변환하고 실패 경로에 도달 할 때마다 &lt;code&gt;halt(conn)&lt;/code&gt; 사용 했습니다. 여기서 &lt;code&gt;halt(conn)&lt;/code&gt; 기능은 필수적입니다. Plug에 다음 플러그가 호출되지 않아야 함을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8b981e8d2840a199b1a09b482f3875a4d2e4d12a" translate="yes" xml:space="preserve">
          <source>To prevent downgrade attacks, in which an attacker intercepts a plain HTTP request to the server before the redirect to HTTPS takes place, &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; by default sets the '&lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet&quot;&gt;Strict-Transport-Security&lt;/a&gt;' (HSTS) header. This informs the browser that the current site must only ever be accessed over HTTPS, even if the user typed or clicked a plain HTTP URL. This only works if the site is reachable on port 443 (see &lt;a href=&quot;#listening-on-port-443&quot;&gt;Listening on Port 443&lt;/a&gt;, below).</source>
          <target state="translated">HTTPS로 리디렉션되기 전에 공격자가 서버에 대한 일반 HTTP 요청을 가로채는 다운 그레이드 공격을 방지하기 위해 &lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 은 기본적으로 ' &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet&quot;&gt;Strict-Transport-Security&lt;/a&gt; '(HSTS) 헤더를 설정합니다. 이는 사용자가 일반 HTTP URL을 입력하거나 클릭 한 경우에도 현재 사이트에 HTTPS를 통해서만 액세스해야 함을 브라우저에 알립니다. 이것은 사이트가 포트 443에서 도달 할 수있는 경우에만 작동합니다 ( 아래의 &lt;a href=&quot;#listening-on-port-443&quot;&gt;포트 443&lt;/a&gt; 에서 듣기 참조).</target>
        </trans-unit>
        <trans-unit id="4cc58fd422ebb28e73e66dcbc49fcc7dea92cf94" translate="yes" xml:space="preserve">
          <source>To print the Phoenix installer version, pass &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--version&lt;/code&gt;, for example:</source>
          <target state="translated">Phoenix 설치 프로그램 버전을 인쇄하려면 &lt;code&gt;-v&lt;/code&gt; 또는 &lt;code&gt;--version&lt;/code&gt; 을 전달 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26c8218895c269e2f70bd1d662ea87120136ac06" translate="yes" xml:space="preserve">
          <source>To protect the private key on disk it is best stored in encrypted PEM format, protected by a password. When configuring a Plug server with an encrypted private key, specify the password using the &lt;code&gt;:password&lt;/code&gt; option:</source>
          <target state="translated">디스크의 개인 키를 보호하려면 암호로 보호되는 암호화 된 PEM 형식으로 저장하는 것이 가장 좋습니다. 암호화 된 개인 키로 플러그 서버를 구성 할 때 &lt;code&gt;:password&lt;/code&gt; 옵션을 사용하여 암호를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="08f005693574383d47c51cc61b7ad7263f57b279" translate="yes" xml:space="preserve">
          <source>To push out-of-band events to the client, for example to render charting points, one could do:</source>
          <target state="translated">예를 들어 차트 포인트를 렌더링하기 위해 대역 외 이벤트를 클라이언트에 푸시하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccb94c57dedc205e8813c5305e1507bc38c480d" translate="yes" xml:space="preserve">
          <source>To render the template within the layout, simply call &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assign:</source>
          <target state="translated">레이아웃 내에서 템플릿을 렌더링하려면 &lt;code&gt;@view_module&lt;/code&gt; 및 &lt;code&gt;@view_template&lt;/code&gt; assign을 사용하여 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 를 호출 하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa8723d880ffe7172650143b48a2d4553d915169" translate="yes" xml:space="preserve">
          <source>To run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies, you can run:</source>
          <target state="translated">종속성을 확인하지 않고 &lt;code&gt;phx.server&lt;/code&gt; 를 실행하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1965798572eff34dbe863a6ecca7a38fdba4475" translate="yes" xml:space="preserve">
          <source>To see an example of how Phoenix LiveDashboard uses these events to create metrics, visit &lt;a href=&quot;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&quot;&gt;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&lt;/a&gt;.</source>
          <target state="translated">Phoenix LiveDashboard가 이러한 이벤트를 사용하여 메트릭을 만드는 방법에 대한 예를 보려면 &lt;a href=&quot;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&quot;&gt;https://hexdocs.pm/phoenix_live_dashboard/metrics.html을&lt;/a&gt; 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="780f2579e6ee8b79fb5eebbb6a2bad044f0a1da4" translate="yes" xml:space="preserve">
          <source>To see the assign in action, go to the layout in &quot;lib/hello_web/templates/layout/app.html.eex&quot; and add the following close to the main container:</source>
          <target state="translated">작업중인 할당을 보려면 &quot;lib / hello_web / templates / layout / app.html.eex&quot;의 레이아웃으로 이동하여 기본 컨테이너에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ac659bbda0b5959d98ced3480e408112f77540e4" translate="yes" xml:space="preserve">
          <source>To see this in action, let's write a module plug that puts the &lt;code&gt;:locale&lt;/code&gt; key and value into the connection assign for downstream use in other plugs, controller actions, and our views. Put the contents above to a file named &quot;lib/hello_web/plugs/locale.ex&quot;:</source>
          <target state="translated">이 동작을 확인하기 위해 다른 플러그, 컨트롤러 동작 및 뷰에서 다운 스트림 사용을 위해 연결 할당에 &lt;code&gt;:locale&lt;/code&gt; 키와 값 을 넣는 모듈 플러그를 작성해 보겠습니다 . 위의 내용을 &quot;lib / hello_web / plugs / locale.ex&quot;라는 파일에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="52a700000692ac76dd990fc6ece3a9849d62392d" translate="yes" xml:space="preserve">
          <source>To send a file that is stored inside your application priv directory:</source>
          <target state="translated">응용 프로그램 개인 디렉토리에 저장된 파일을 보내려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="35a9af194f11f81b8d5034792059c6fe96098baa" translate="yes" xml:space="preserve">
          <source>To sign, you would do:</source>
          <target state="translated">서명하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="44fd47beed516022715facac2a1ae8d92a4df5b5" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfifured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the OWASP recommendations found here: https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</source>
          <target state="translated">TLS 기본값의 구성을 단순화하기 위해 Plug는 &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 및 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 두 가지 사전 구성된 옵션을 제공합니다 . 선택한 암호 및 관련 구성은 여기에있는 OWASP 권장 사항에서 가져옵니다. https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</target>
        </trans-unit>
        <trans-unit id="0648eaf88db893b2046b349febdc511815782796" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;.</source>
          <target state="translated">TLS 기본값 구성을 단순화하기 위해 Plug는 사전 구성된 두 가지 옵션 인 &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 및 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9f0f28f03a276631d1d8cb8b076f6c25bc731344" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults, this function provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP Cipher String Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">TLS 기본값 구성을 단순화하기 위해이 함수는 사전 구성된 두 가지 옵션 인 &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 및 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 합니다. 선택한 암호 및 관련 구성은 &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP 암호 문자열 치트 시트&lt;/a&gt; 에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="05cfddf3dfec406094311ddae72d16bd5088244a" translate="yes" xml:space="preserve">
          <source>To solve this, all &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structs also contain a fingerprint field that uniquely identifies it. If the fingerprints are equal, you have the same template, and therefore it is possible to only transmit its changes.</source>
          <target state="translated">이를 해결하기 위해 모든 &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt; &lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt; &lt;/a&gt; 구조체에는이를 고유하게 식별하는 지문 필드도 포함됩니다. 지문이 같으면 템플릿이 같으므로 변경 사항 만 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fcf5b5fb3d94c82b9314b323af893477190f87" translate="yes" xml:space="preserve">
          <source>To specify private options on &lt;code&gt;match&lt;/code&gt; that can be used by plugs before &lt;code&gt;dispatch&lt;/code&gt; pass an option with key &lt;code&gt;:private&lt;/code&gt; containing a map. Example:</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; 전에 플러그가 사용할 수있는 개인 옵션을 &lt;code&gt;match&lt;/code&gt; 시키려면 맵이 포함 된 key &lt;code&gt;:private&lt;/code&gt; 옵션을 전달하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="b3f3f98dc901f9abeb9304c536e620a40b09a54d" translate="yes" xml:space="preserve">
          <source>To specify the endpoint that will provide instrumentation, the first argument can be:</source>
          <target state="translated">계측을 제공 할 끝점을 지정하기 위해 첫 번째 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1d40c54757f1d4613e7479119437d84155bd019" translate="yes" xml:space="preserve">
          <source>To start a tracker, first add the tracker to your supervision tree:</source>
          <target state="translated">추적기를 시작하려면 먼저 감시 트리에 추적기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="865274f6fae09ebe9585b2086ee27cd4cbdb840c" translate="yes" xml:space="preserve">
          <source>To start, let's think of a function name that describes what we want to accomplish. To authenticate a user by email address, we'll need a way to lookup that user and verify their entered credentials are valid. We can do this by exposing a single function on our &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="translated">시작하기 위해 우리가 달성하고자하는 것을 설명하는 함수 이름을 생각해 봅시다. 이메일 주소로 사용자를 인증하려면 해당 사용자를 조회하고 입력 한 자격 증명이 유효한지 확인하는 방법이 필요합니다. &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트 에 단일 기능을 노출하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe9098d8b92793a95404f15371666be5a41249f2" translate="yes" xml:space="preserve">
          <source>To stop it, we hit &lt;code&gt;ctrl-c&lt;/code&gt; twice.</source>
          <target state="translated">그것을 멈추기 위해 우리는 &lt;code&gt;ctrl-c&lt;/code&gt; 를 두 번 칩니다 .</target>
        </trans-unit>
        <trans-unit id="d581dcb8a5c7aee4d296819c687a1a0e294823ae" translate="yes" xml:space="preserve">
          <source>To stream data use &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; allows aborting the execution if &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; fails to deliver the chunk of data.</source>
          <target state="translated">데이터를 스트리밍하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; 가 데이터 청크를 전달하지 못하면 실행을 중단 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="9fa929e9e71e2e4dc6c3efe3b0fa423875bca234" translate="yes" xml:space="preserve">
          <source>To submit a form along with some with hidden input values:</source>
          <target state="translated">숨겨진 입력 값이있는 일부 양식과 함께 양식을 제출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="968cfb95ef76146b6409c3b657948cdd5f1f4f75" translate="yes" xml:space="preserve">
          <source>To sum it up:</source>
          <target state="translated">그것을 요 ​​약하기:</target>
        </trans-unit>
        <trans-unit id="102bc3a62eadfb6175b1787787fb41a6baa07e87" translate="yes" xml:space="preserve">
          <source>To sum up:</source>
          <target state="translated">요약하자면 :</target>
        </trans-unit>
        <trans-unit id="a410cd8f3e812852d23e13de76f2d28e929bd21f" translate="yes" xml:space="preserve">
          <source>To switch adapters, we need to remove the Postgrex dependency and add a new one for Mariaex instead.</source>
          <target state="translated">어댑터를 전환하려면 Postgrex 종속성을 제거하고 대신 Mariaex에 대한 새 종속성을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a2ee59d6482fe8d57fcc8a0083e0c4366e7446c" translate="yes" xml:space="preserve">
          <source>To template that goes inside the layout will be placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign:</source>
          <target state="translated">레이아웃 내부로 들어가는 템플릿은 &lt;code&gt;@inner_content&lt;/code&gt; 할당에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="80e061ad3871e4c5c14888dba30a6440671c5a6d" translate="yes" xml:space="preserve">
          <source>To test:</source>
          <target state="translated">테스트하려면 :</target>
        </trans-unit>
        <trans-unit id="26b1ef54f7afb80af1f92d1a44fccf208e6f5b11" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;web/templates/user/&lt;/code&gt;.</source>
          <target state="translated">미리 컴파일 된 템플릿을 사용하려면 &lt;code&gt;templates&lt;/code&gt; 디렉토리에서 렌더링하려는 해당보기에 대한 &lt;code&gt;scripts.html.eex&lt;/code&gt; 파일을 만듭니다 . 예를 들어, &lt;code&gt;UserView&lt;/code&gt; 의 &lt;code&gt;scripts.html.eex&lt;/code&gt; &lt;code&gt;web/templates/user/&lt;/code&gt; scripts.html.eex 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f114bef104473c93c624dc15c134a2506e1bf712" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;your_app_web/templates/user/&lt;/code&gt;.</source>
          <target state="translated">미리 컴파일 된 템플릿을 사용하려면 렌더링 할 해당 뷰 의 &lt;code&gt;templates&lt;/code&gt; 디렉토리에 &lt;code&gt;scripts.html.eex&lt;/code&gt; 파일을 만듭니다 . 예를 들어 &lt;code&gt;UserView&lt;/code&gt; 의 &lt;code&gt;scripts.html.eex&lt;/code&gt; &lt;code&gt;your_app_web/templates/user/&lt;/code&gt; scripts.html.eex 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f17a125a5e6e8a005867e5e43c2e03a3bc9ba5a1" translate="yes" xml:space="preserve">
          <source>To use inform for early hints send one or more informs with a status of 103.</source>
          <target state="translated">조기 힌트에 정보를 사용하려면 상태가 103 인 하나 이상의 정보를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4c9225f6845b572057c82d533463516a01a74a81" translate="yes" xml:space="preserve">
          <source>To use it as the type for the id in our schema, we can use the &lt;code&gt;@primary_key&lt;/code&gt; module attribute:</source>
          <target state="translated">스키마에서 ID의 유형으로 사용하려면 &lt;code&gt;@primary_key&lt;/code&gt; 모듈 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c71555f84c848ebd550b0b2837d6569d68c6e857" translate="yes" xml:space="preserve">
          <source>To use it as your PubSub adapter, simply add it to your Endpoint&amp;rsquo;s config:</source>
          <target state="translated">PubSub 어댑터로 사용하려면 간단히 엔드 포인트의 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="187cfa2127b5960446298f89ad2cfe623ccc0476" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module.</source>
          <target state="translated">사용하려면 원하는 모듈에 꽂기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2e14f0d8d5504cedce23ae26e51fc49f968cc49d" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module:</source>
          <target state="translated">사용하려면 원하는 모듈에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="595e3caee2e048e5b6af233064a5c06aa1ae0dd2" translate="yes" xml:space="preserve">
          <source>To use the live layout, update your LiveView to pass the &lt;code&gt;:layout&lt;/code&gt; option to &lt;code&gt;use Phoenix.LiveView&lt;/code&gt;:</source>
          <target state="translated">라이브 레이아웃 을 &lt;code&gt;use Phoenix.LiveView&lt;/code&gt; 를 사용하도록 LiveView를 업데이트하여 &lt;code&gt;:layout&lt;/code&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="a467a95e3bae25f66e655cb0e95ae8997b92d46e" translate="yes" xml:space="preserve">
          <source>To use this adapter outside of Phoenix, you must start an instance of this module as part of your supervision tree:</source>
          <target state="translated">Phoenix 외부에서이 어댑터를 사용하려면 감독 트리의 일부로이 모듈의 인스턴스를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8cc58c102127e1478be2cb62bee842868d8e23c" translate="yes" xml:space="preserve">
          <source>To use this functionality, the first step is to annotate which static files you want to be tracked by LiveView, with the &lt;code&gt;phx-track-static&lt;/code&gt;. For example:</source>
          <target state="translated">이 기능을 사용하기위한 첫 번째 단계는 &lt;code&gt;phx-track-static&lt;/code&gt; 을 사용하여 LiveView에서 추적 할 정적 파일에 주석을 추가하는 것 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="117496c10ce2870a7a485406c87644c6a1d5cede" translate="yes" xml:space="preserve">
          <source>To use this plug, just plug it into the desired module:</source>
          <target state="translated">이 플러그를 사용하려면 원하는 모듈에 꽂기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed35357476c8058b977ba69de2188d350955b6b" translate="yes" xml:space="preserve">
          <source>To use this type in a schema field, specify the type and parameters like this:</source>
          <target state="translated">스키마 필드에서이 유형을 사용하려면 다음과 같이 유형 및 매개 변수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0be2552a6f37a24285cf8c9a4bbf18c028914ee4" translate="yes" xml:space="preserve">
          <source>To wrap a label around an input, see &lt;a href=&quot;#label/1&quot;&gt;&lt;code&gt;label/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 주위에 레이블을 감싸려면 &lt;a href=&quot;#label/1&quot;&gt; &lt;code&gt;label/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3ba8aacdac746a9e58d91fb33fc6cb9465a0339" translate="yes" xml:space="preserve">
          <source>Token generation</source>
          <target state="translated">토큰 생성</target>
        </trans-unit>
        <trans-unit id="f80aa637b7d7bc4574011a6f03ec544bfb7d8aa0" translate="yes" xml:space="preserve">
          <source>Tokens provide a way to generate and verify bearer tokens for use in Channels or API authentication.</source>
          <target state="translated">토큰은 채널 또는 API 인증에 사용할 베어러 토큰을 생성하고 확인하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20a6a1c796f4bedac7e31cb355e60cefd679db64" translate="yes" xml:space="preserve">
          <source>Topic Patterns</source>
          <target state="translated">주제 패턴</target>
        </trans-unit>
        <trans-unit id="7ab575de50dde2e85ca0c17176dc52fba2687bb2" translate="yes" xml:space="preserve">
          <source>Topics &amp;amp; Callbacks</source>
          <target state="translated">주제 및 콜백</target>
        </trans-unit>
        <trans-unit id="c05de3133bb80093a252ef28feff7623186b061e" translate="yes" xml:space="preserve">
          <source>Track a channel's process as a presence.</source>
          <target state="translated">채널의 프로세스를 현재 상태로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="261a0221d2b8ed7abd71a3e4620a5971130fd19b" translate="yes" xml:space="preserve">
          <source>Track an arbitrary process as a presence.</source>
          <target state="translated">임의의 프로세스를 존재로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="01ecb082b24a5ab812ebd962ccc4da0fcdfbcfae" translate="yes" xml:space="preserve">
          <source>Tracked presences are grouped by &lt;code&gt;key&lt;/code&gt;, cast as a string. For example, to group each user's channels together, use user IDs as keys. Each presence can be associated with a map of metadata to store small, emphemeral state, such as a user's online status. To store detailed information, see &lt;a href=&quot;#c:fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추적 된 존재는 &lt;code&gt;key&lt;/code&gt; 별로 그룹화되고 문자열로 캐스트됩니다. 예를 들어 각 사용자의 채널을 함께 그룹화하려면 사용자 ID를 키로 사용하십시오. 각 현재 상태는 메타 데이터 맵과 연결되어 사용자의 온라인 상태와 같은 작고 일시적인 상태를 저장할 수 있습니다. 자세한 정보를 저장하려면 &lt;a href=&quot;#c:fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1815ae87e1ed66b14331696c387c97e3da9eb63" translate="yes" xml:space="preserve">
          <source>Tracker servers use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Instead, each node runs one or more &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; servers and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">트래커 서버는 하트 비트 프로토콜과 CRDT를 사용하여 일관성 있고 충돌이없는 방식으로 클러스터에 존재 정보를 복제합니다. 이 디자인에서는 단일 한 진실의 원천이나 글로벌 프로세스가 없습니다. 대신, 각 노드는 하나 이상의 &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 서버를 실행 하고 노드 로컬 변경 사항은 클러스터 전체에 복제되고 변경 사항으로 로컬로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e426db3c83832b5b1a9b212c38c2b26124ea17c3" translate="yes" xml:space="preserve">
          <source>Tracker shards use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Each node runs a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">트래커 샤드는 하트 비트 프로토콜과 CRDT를 사용하여 일관성 있고 충돌이없는 방식으로 클러스터에 존재 정보를 복제합니다. 이 디자인에서는 단일 한 진실의 원천이나 글로벌 프로세스가 없습니다. 각 노드는 &lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; &lt;/a&gt; 풀을 실행 하고 노드 로컬 변경 사항은 클러스터 전체에 복제되어 변경 사항으로 로컬로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a6bb7d4cf7d24a007e92d554e3f03f18d78e05" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">추적기는 &lt;code&gt;start_link/1&lt;/code&gt; , &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;handle_diff/2&lt;/code&gt; 를 구현해야합니다 . &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백은 내에서 실행하는 경우 자신의 상태를 관리 할 수있는 추적 할 수 있습니다 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; 의&lt;/a&gt; 서버를. &lt;code&gt;handle_diff&lt;/code&gt; 의 콜백은 존재의 사랑하는 호출에 가입하고 휴가 이벤트, 주제별로 그룹화됩니다. 복제본이 하트 비트 및 데이터를 복제하면 로컬 추적기 상태가 원격 데이터와 병합되고 diff가 콜백으로 전송됩니다. 핸들러는 위와 같이이 정보를 사용하여 구독자에게 이벤트를 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="386e43727163f9c18a619e32e79443e6e4a3c763" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">트래커는 &lt;code&gt;start_link/1&lt;/code&gt; , &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;handle_diff/2&lt;/code&gt; 를 구현해야합니다 . &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백은 내에서 실행하는 경우 자신의 상태를 관리 할 수있는 추적 할 수 있습니다 &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; 의&lt;/a&gt; 서버를. &lt;code&gt;handle_diff&lt;/code&gt; 의 콜백은 존재의 사랑하는 호출에 가입하고 휴가 이벤트, 주제별로 그룹화됩니다. 하트 비트 및 복제 데이터를 복제 할 때 로컬 추적기 상태가 원격 데이터와 병합되고 diff가 콜백으로 전송됩니다. 핸들러는이 정보를 사용하여 위와 같이 가입자에게 이벤트를 통지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a1ce6393d7c243fe58a4abc442faa4d6b63e426" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;code&gt;init/1&lt;/code&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;code&gt;init/1&lt;/code&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">트래커는 &lt;code&gt;start_link/1&lt;/code&gt; , &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;handle_diff/2&lt;/code&gt; 를 구현해야합니다 . &lt;code&gt;init/1&lt;/code&gt; 콜백은 내에서 실행하는 경우 자신의 상태를 관리 할 수있는 추적 할 수 있습니다 &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; 의&lt;/a&gt; 서버를. &lt;code&gt;handle_diff&lt;/code&gt; 의 콜백은 존재의 사랑하는 호출에 가입하고 휴가 이벤트, 주제별로 그룹화됩니다. 하트 비트 및 복제 데이터를 복제 할 때 로컬 추적기 상태가 원격 데이터와 병합되고 diff가 콜백으로 전송됩니다. 핸들러는이 정보를 사용하여 위와 같이 가입자에게 이벤트를 통지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec88a8caf33e733f9f82eb74118f40a505db5749" translate="yes" xml:space="preserve">
          <source>Tracking changes</source>
          <target state="translated">변경 사항 추적</target>
        </trans-unit>
        <trans-unit id="bfd71a4b69dd23e4fec03cebbf6443963a3bb4f1" translate="yes" xml:space="preserve">
          <source>Tracks a presence</source>
          <target state="translated">현재 상태 추적</target>
        </trans-unit>
        <trans-unit id="f77d00c25a6c8aa2f028ccd4ee433e0eac247ebb" translate="yes" xml:space="preserve">
          <source>Tracks a presence.</source>
          <target state="translated">현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="4d967b73b508c2dfcc359e0a2212dfc6cf38b5f5" translate="yes" xml:space="preserve">
          <source>Tracks the source prefix in the data storage.</source>
          <target state="translated">데이터 저장소에서 소스 접두사를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="04dbde923a480822fb49f6a9f57a11e1e45c2f34" translate="yes" xml:space="preserve">
          <source>Translates a &lt;a href=&quot;phoenix.socket.broadcast&quot;&gt;&lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt;&lt;/a&gt; struct to fastlane format</source>
          <target state="translated">변환 &lt;a href=&quot;phoenix.socket.broadcast&quot;&gt; &lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt; 의&lt;/a&gt; 추월 차선 형식으로 구조체를</target>
        </trans-unit>
        <trans-unit id="fa2fb74c7c1ff29a1c97955f10736fc44d4c709e" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</source>
          <target state="translated">기본 SQL ILIKE 쿼리로 변환합니다. 이 작업은 PostgreSQL에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e04600e3ea7e7907ea952ea71a5864369b3424b" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive &lt;code&gt;like&lt;/code&gt; in PostgreSQL, see &lt;a href=&quot;#ilike/2&quot;&gt;&lt;code&gt;ilike/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 SQL LIKE 쿼리로 변환하므로 해당 동작은 데이터베이스에 따라 다릅니다. 특히 PostgreSQL은 대소 문자를 구분하며 다른 데이터베이스는 대소 문자를 구분하지 않습니다. PostgreSQL에서 &lt;code&gt;like&lt;/code&gt; 대소 문자를 구분하지 &lt;a href=&quot;#ilike/2&quot;&gt; &lt;code&gt;ilike/2&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="892c52a641684add2f2c13d64228138e346b88e9" translate="yes" xml:space="preserve">
          <source>Transports can optionally implement &lt;a href=&quot;#c:handle_control/2&quot;&gt;&lt;code&gt;handle_control/2&lt;/code&gt;&lt;/a&gt; for handling control frames such as &lt;code&gt;:ping&lt;/code&gt; and &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="translated">전송은 선택적 으로 &lt;code&gt;:ping&lt;/code&gt; 및 &lt;code&gt;:pong&lt;/code&gt; 과 같은 제어 프레임을 처리하기 위해 &lt;a href=&quot;#c:handle_control/2&quot;&gt; &lt;code&gt;handle_control/2&lt;/code&gt; &lt;/a&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50ec8431700d39c092c58101a53cd1456d35e7d7" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages</source>
          <target state="translated">변경 세트 오류를 ​​트래버스하고 지정된 함수를 오류 메시지에 적용</target>
        </trans-unit>
        <trans-unit id="8cbe92e33468200a0827118c7f3d01b4a4843741" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages.</source>
          <target state="translated">변경 세트 오류를 ​​트래버스하고 지정된 기능을 오류 메시지에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0f6e81017aaf95b363450b6d7b0752a8fb3d2fef" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;{module, function, args}&lt;/code&gt; can be passed to be invoked each time the plug is checking whether to redirect host. Provided function needs to receive at least one argument (&lt;code&gt;host&lt;/code&gt;).</source>
          <target state="translated">튜플 &lt;code&gt;{module, function, args}&lt;/code&gt; 는 플러그가 호스트를 리디렉션할지 여부를 확인할 때마다 호출되도록 전달 될 수 있습니다. 제공된 함수는 적어도 하나의 인수 ( &lt;code&gt;host&lt;/code&gt; ) 를 받아야 합니다.</target>
        </trans-unit>
        <trans-unit id="98a6dbefab197c1c589aaa284bb9c90aca73a018" translate="yes" xml:space="preserve">
          <source>Two or more consecutive newlines &lt;code&gt;\n\n&lt;/code&gt; or &lt;code&gt;\r\n\r\n&lt;/code&gt; are considered as a paragraph and text between them is wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags. One newline &lt;code&gt;\n&lt;/code&gt; or &lt;code&gt;\r\n&lt;/code&gt; is considered as a linebreak and a &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; tag is inserted.</source>
          <target state="translated">두 개 이상의 연속적인 줄 바꿈 &lt;code&gt;\n\n&lt;/code&gt; 또는 &lt;code&gt;\r\n\r\n&lt;/code&gt; 은 단락으로 간주되며 그 사이의 텍스트는 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 태그로 묶습니다. 하나의 줄 바꿈 &lt;code&gt;\n&lt;/code&gt; 또는 &lt;code&gt;\r\n&lt;/code&gt; 은 줄 바꿈 으로 간주되며 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 태그가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="154308bd4c8a066d5d9c6258416a1b30f7bd6212" translate="yes" xml:space="preserve">
          <source>Type and subtype are case insensitive while the sensitiveness of params depends on their keys and therefore are not handled by this parser.</source>
          <target state="translated">유형과 하위 유형은 대소 문자를 구분하지 않지만 매개 변수의 민감도는 해당 키에 따라 다르므로이 파서에서 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="2b93aaf665984dcdc2d122fc68d22290dc98430f" translate="yes" xml:space="preserve">
          <source>Types and casting</source>
          <target state="translated">유형과 주조</target>
        </trans-unit>
        <trans-unit id="fccbdec63f1e673c35ac4ad2b3198a6d03985d97" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;pool_timeout&lt;/code&gt;, &lt;code&gt;pool_size&lt;/code&gt;:</source>
          <target state="translated">URL에는 공유 및 어댑터 별 옵션 &lt;code&gt;ssl&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;pool_timeout&lt;/code&gt; , &lt;code&gt;pool_size&lt;/code&gt; 를 재정의하는 쿼리 매개 변수가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2062e8d014f9cc3812946feab252c6f50a8a1a8d" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options, like &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;pool_size&lt;/code&gt;. The following example shows how to pass these configuration values:</source>
          <target state="translated">URL에는 &lt;code&gt;ssl&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; 및 &lt;code&gt;pool_size&lt;/code&gt; 와 같은 공유 및 어댑터 별 옵션을 재정의하는 쿼리 매개 변수가 포함될 수 있습니다 . 다음 예는 이러한 구성 값을 전달하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="c936fe014fbf52d248e23e83c4f7c389f5578501" translate="yes" xml:space="preserve">
          <source>UTF-8 encoded &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">UTF-8로 인코딩 된 &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0541e2d015eef80c9c2da6778b6e2c6a68cb7f30" translate="yes" xml:space="preserve">
          <source>Umbrella projects do not have a default router and therefore always expect a router to be given.</source>
          <target state="translated">우산 프로젝트에는 기본 라우터가 없으므로 항상 라우터가 제공 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="8768d73251c0569d327c1e364eafb4d5ea1eb2da" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation</source>
          <target state="translated">단항이 &lt;code&gt;not&lt;/code&gt; 작동</target>
        </trans-unit>
        <trans-unit id="ae6d1341c40bcf85b2e3992e163df198136c8fe0" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation.</source>
          <target state="translated">단항 작동 &lt;code&gt;not&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8528d9a060404341b909c95a03193ce5217db1fb" translate="yes" xml:space="preserve">
          <source>Uncomment or add the following to this list of children in your Telemetry supervision tree (usually in &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt;):</source>
          <target state="translated">Telemetry 감독 트리 (일반적으로 &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt; 에 있음 ) 의이 하위 목록에 다음 주석을 제거하거나 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e20734e624a02ccb4b9b198469134b0f85370de0" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#build_conn/3&quot;&gt;&lt;code&gt;build_conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">다른 상황에서는 처리를 위해 연결이 필요한보기 또는 다른 계층을 테스트 할 수 있습니다. 이러한 경우 &lt;a href=&quot;#build_conn/3&quot;&gt; &lt;code&gt;build_conn/3&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 연결을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b5c67037bf5470da236e2bdde573521f2424de5" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#conn/3&quot;&gt;&lt;code&gt;conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">다른 상황에서는 처리를 위해 연결이 필요한보기 또는 다른 계층을 테스트 할 수 있습니다. 이러한 경우 &lt;a href=&quot;#conn/3&quot;&gt; &lt;code&gt;conn/3&lt;/code&gt; &lt;/a&gt; 헬퍼를 사용하여 연결을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ff53ee2862d2d446a35b1e8111b19a37147a3a" translate="yes" xml:space="preserve">
          <source>Understanding template compilation</source>
          <target state="translated">템플릿 컴파일 이해</target>
        </trans-unit>
        <trans-unit id="d3c65bf16f98fec621f47e764e587b2f2e1621e5" translate="yes" xml:space="preserve">
          <source>Unexpected scenarios</source>
          <target state="translated">예상치 못한 시나리오</target>
        </trans-unit>
        <trans-unit id="03a6558018657fa99e805a8a68718f47b7b414d0" translate="yes" xml:space="preserve">
          <source>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the &lt;code&gt;:citext&lt;/code&gt; type/extension. In your migration:</source>
          <target state="translated">불행히도, 다른 데이터베이스는 대소 문자를 구분할 때 다른 보장을 제공합니다. 예를 들어 MySQL에서 비교는 기본적으로 대소 문자를 구분하지 않습니다. Postgres에서 사용자는 &lt;code&gt;:citext&lt;/code&gt; type / extension 을 사용하여 대소 문자를 구분하지 않는 열을 정의 할 수 있습니다 . 마이그레이션에서 :</target>
        </trans-unit>
        <trans-unit id="ebda784e9b2848ef9558c97ee4b8fa423fa74c91" translate="yes" xml:space="preserve">
          <source>Union expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to combine multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#union_all/2&quot;&gt;&lt;code&gt;union_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">통합 식은 각 쿼리가 고유 한 결과를 반환 한 것처럼 고유 한 행만 반환합니다. 성능이 저하 될 수 있습니다. 중복 행을 제거하지 않고 여러 결과 세트를 결합해야하는 경우 &lt;a href=&quot;#union_all/2&quot;&gt; &lt;code&gt;union_all/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b3223e5b025350dc7c873af657f6279cba89acf" translate="yes" xml:space="preserve">
          <source>Unique columns can be automatically generated by using:</source>
          <target state="translated">다음을 사용하여 고유 한 열을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a9c9a9da9b4997ddb48f0c0710b0ce5b2a182a" translate="yes" xml:space="preserve">
          <source>Unless held-down keys are required, a better approach is generally to use &lt;code&gt;phx-keyup&lt;/code&gt; bindings which only trigger on key up, thereby being self-limiting. However, &lt;code&gt;phx-keydown&lt;/code&gt; is useful for games and other use cases where a constant press on a key is desired. In such cases, throttle should always be used.</source>
          <target state="translated">누르고있는 키가 필요하지 않는 한, 더 나은 접근 방식은 일반적으로 키를 올릴 때만 트리거되는 &lt;code&gt;phx-keyup&lt;/code&gt; 바인딩 을 사용 하여 자체 제한하는 것입니다. 그러나 &lt;code&gt;phx-keydown&lt;/code&gt; 은 키를 계속 눌러야하는 게임 및 기타 사용 사례에 유용합니다. 이러한 경우에는 항상 스로틀을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="364ff4689b83184f9cf200c53fb47d7dfe4a19d2" translate="yes" xml:space="preserve">
          <source>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</source>
          <target state="translated">열이 수십 개가 아닌 한, 개발자에게는 더 간단하고 모든면에서 DB 친화적이고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6dbbc01e9238f5b47a1c02fc53c7e8b555358fa3" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic</source>
          <target state="translated">PubSub 어댑터의 주제에서 호출자를 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="482cecc4861f7c77f0cec819a536c79e2d690881" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic.</source>
          <target state="translated">PubSub 어댑터의 주제에서 호출자를 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="c4431f0ea76c1f1e2f3d65fe926de8de3246221b" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter's topic.</source>
          <target state="translated">PubSub 어댑터의 주제에서 호출자를 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="181cb46e23fe9bb176c35f8d9f9e02d873ba1397" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic</source>
          <target state="translated">주어진 주제에서 발신자를 탈퇴</target>
        </trans-unit>
        <trans-unit id="dfb3c1161312f219c23d938f551cae6ab3a67d2a" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic.</source>
          <target state="translated">주어진 주제에서 발신자를 탈퇴합니다.</target>
        </trans-unit>
        <trans-unit id="8e4d4756b56c5c2a38de9c36247d3bf735dff1a1" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic</source>
          <target state="translated">주제에서 pid를 탈퇴</target>
        </trans-unit>
        <trans-unit id="937f4447c61b885d2272aeadbcc25a892061149c" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic.</source>
          <target state="translated">주제에서 pid를 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="f7f95de69369cee5491d0b2318e7e16ee32f3693" translate="yes" xml:space="preserve">
          <source>Untracks a presence</source>
          <target state="translated">프레즌스 추적</target>
        </trans-unit>
        <trans-unit id="00a3c6eca2c9c5467d7eda3ff19f2b3a3f0b9f13" translate="yes" xml:space="preserve">
          <source>Untracks a presence.</source>
          <target state="translated">현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="f662645adc1966f7f57b2b2a62ac566f868b5e24" translate="yes" xml:space="preserve">
          <source>Up and Running</source>
          <target state="translated">설치 및 실행</target>
        </trans-unit>
        <trans-unit id="fb41bed7c754707f32bbce1dc683efccb4519d20" translate="yes" xml:space="preserve">
          <source>Update a channel presence's metadata.</source>
          <target state="translated">채널 존재의 메타 데이터를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d1e9810594beffedf05646229838b1d174fadeb7" translate="yes" xml:space="preserve">
          <source>Update a process presence's metadata.</source>
          <target state="translated">프로세스 존재의 메타 데이터를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c76d18079a076ee34ffc62b5b9bd0909da356dce" translate="yes" xml:space="preserve">
          <source>Updates</source>
          <target state="translated">Updates</target>
        </trans-unit>
        <trans-unit id="efde7464a7ffd43310a0d38ea8d45264ea41ceae" translate="yes" xml:space="preserve">
          <source>Updates a change</source>
          <target state="translated">변경 사항 업데이트</target>
        </trans-unit>
        <trans-unit id="4960f1d23ffd2b7d1ab51393bbb07ff03fb4eeb5" translate="yes" xml:space="preserve">
          <source>Updates a change.</source>
          <target state="translated">변경 사항을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9e3e9b085b2135f1f85213c1f86af920a1755f04" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key</source>
          <target state="translated">기본 키를 사용하여 변경 세트를 업데이트합니다</target>
        </trans-unit>
        <trans-unit id="c93c04e332aa599946d58eaecaa78d3cdd5a2eb1" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key.</source>
          <target state="translated">기본 키를 사용하여 변경 세트를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="3385b9dce3c90d599cae02d4653dbca93a29bcc4" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata</source>
          <target state="translated">현재 상태 메타 데이터 업데이트</target>
        </trans-unit>
        <trans-unit id="0acdc22a28ee11a8afdd3431b0315855715fa2bc" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata.</source>
          <target state="translated">현재 상태의 메타 데이터를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="132594d301d9e633427f4d91489bd56edf757c2c" translate="yes" xml:space="preserve">
          <source>Updates a presence's metadata.</source>
          <target state="translated">현재 상태의 메타 데이터를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c01320a0cc1e6fafc6bb2e70c6fddc03bae55710" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value</source>
          <target state="translated">요청 헤더가있는 경우 업데이트하고, 그렇지 않으면 초기 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="045227cef9e475014998b6e238302ad6bc1ea08b" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">요청 헤더가 있으면 업데이트하고, 그렇지 않으면 초기 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0458896d317ccb81c30dba901118e2743e4a5416" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value</source>
          <target state="translated">응답 헤더가있는 경우 업데이트하고, 그렇지 않으면 초기 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="aca7d4e48cb32323eeef9d6da6338f24bc32a47f" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">응답 헤더가있는 경우 업데이트하고, 그렇지 않으면 초기 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="607386542c3c782f031294b17742c0818b532a58" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters</source>
          <target state="translated">주어진 필터로 단일 구조체를 업데이트합니다</target>
        </trans-unit>
        <trans-unit id="b883e138c47eee8bc7395bc0ee931698e3b1bac8" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters.</source>
          <target state="translated">주어진 필터로 단일 구조체를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c6a6a639373c46aeccd5f9b2b8b38de4b2dae7bd" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values</source>
          <target state="translated">주어진 쿼리와 일치하는 모든 항목을 주어진 값으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="330ebb6cefd9ef9f1f8a72396cfd06403a7c55e1" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values.</source>
          <target state="translated">주어진 쿼리와 일치하는 모든 항목을 주어진 값으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1c2e283ce7915c1bbb24433633c806a5a301b678" translate="yes" xml:space="preserve">
          <source>Updates an existing key in the socket assigns.</source>
          <target state="translated">소켓 할당의 기존 키를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="7762e945e6baaa0818bffbab49c2f32dcef1ea19" translate="yes" xml:space="preserve">
          <source>Updates are patched to the DOM as usual</source>
          <target state="translated">업데이트는 평소와 같이 DOM에 패치됩니다.</target>
        </trans-unit>
        <trans-unit id="9274df775f7c52402be32f42089e570c5a110dfe" translate="yes" xml:space="preserve">
          <source>Updates are used to update the filtered entries. In order for updates to be applied, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt; must be invoked.</source>
          <target state="translated">업데이트는 필터링 된 항목을 업데이트하는 데 사용됩니다. 업데이트를 적용 하려면 &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="30d7abe8ce119c87145e38b618e0cb0eb1692bb6" translate="yes" xml:space="preserve">
          <source>Updates the Phoenix project generator locally.</source>
          <target state="translated">Phoenix 프로젝트 생성기를 로컬로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b34140753c1f89b23cafca5f1dc7b6027ceb0a21" translate="yes" xml:space="preserve">
          <source>Updating of embeds must be done using a changeset for each changed embed.</source>
          <target state="translated">임베드 업데이트는 변경된 각 임베드에 대한 변경 세트를 사용하여 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="825dd96949706e54c171f42804e730ef000fc8f8" translate="yes" xml:space="preserve">
          <source>Updating the HTML document title</source>
          <target state="translated">HTML 문서 제목 업데이트</target>
        </trans-unit>
        <trans-unit id="fde3a12f19329145c5a153296de9637412067eac" translate="yes" xml:space="preserve">
          <source>Uploaded files are stored in a temporary directory and removed from that directory after the process that requested the file dies.</source>
          <target state="translated">업로드 된 파일은 임시 디렉토리에 저장되며 파일을 요청한 프로세스가 종료 된 후 해당 디렉토리에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="37fa1abd2298ec59d4f7430940833863a90e31b7" translate="yes" xml:space="preserve">
          <source>Upserts</source>
          <target state="translated">Upserts</target>
        </trans-unit>
        <trans-unit id="46c68148d8a37fd928ca23894beb97c2d0282df9" translate="yes" xml:space="preserve">
          <source>Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL.</source>
          <target state="translated">Upserts는 Postgres와 같은 데이터베이스에서 &quot;ON CONFLICT&quot;로 매핑되고 MySQL과 같은 데이터베이스에서 &quot;ON DUPLICATE KEY&quot;로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="f343f4451a0d5b77ecb46c9d17300b873c9ec642" translate="yes" xml:space="preserve">
          <source>Upserts map to &amp;ldquo;ON CONFLICT&amp;rdquo; on databases like Postgres and &amp;ldquo;ON DUPLICATE KEY&amp;rdquo; on databases such as MySQL.</source>
          <target state="translated">Upsert는 Postgres와 같은 데이터베이스에서 &quot;ON CONFLICT&quot;로, MySQL과 같은 데이터베이스에서 &quot;ON DUPLICATE KEY&quot;로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
