<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="8dbd5bf505a906190aaecf44ee8fc72561677242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;endpoint&lt;/code&gt; - The endpoint module, for example &lt;code&gt;MyApp.Endpoint&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; -엔드 포인트 모듈 (예 : &lt;code&gt;MyApp.Endpoint&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d9edaabc945a49faf042447eabee463458415d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errors&lt;/code&gt; - All errors from validations</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; - 유효성 검사의 모든 오류</target>
        </trans-unit>
        <trans-unit id="59b58aaaab5203cea8b44f2fbc67a701acda2a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errors&lt;/code&gt; and &lt;code&gt;validations&lt;/code&gt; - they are simply concatenated.</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 및 &lt;code&gt;validations&lt;/code&gt; -단순히 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f3f00b87b9c8454bc078c02c62011828df10aa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;event&lt;/code&gt;- The string event name, for example &amp;ldquo;phx_join&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; - 문자열 이벤트 이름, 예를 들어 &quot;phx_join&quot;에 대한</target>
        </trans-unit>
        <trans-unit id="668c87f2a5869478320481db801806d9e77f78c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;field&lt;/code&gt; - The name of the association field on the schema</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; - 스키마에 연결 필드의 이름</target>
        </trans-unit>
        <trans-unit id="4a91378666385a214e2ba31bed3572337c0ff59b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 는 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="44fdddd9aec385a0927980e479f82a27a6485358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; also support index hints, as found in databases such as &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/index-hints.html&quot;&gt;MySQL&lt;/a&gt; and &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table?view=sql-server-2017&quot;&gt;MSSQL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 은 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/index-hints.html&quot;&gt;MySQL&lt;/a&gt; 및 &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table?view=sql-server-2017&quot;&gt;MSSQL&lt;/a&gt; 과 같은 데이터베이스에있는 인덱스 힌트도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="cba3ce899573666d281b9ff444ae82b36f411003" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gc_server&lt;/code&gt; - The registered server name or pid</source>
          <target state="translated">&lt;code&gt;gc_server&lt;/code&gt; - 등록 된 서버 이름 또는 pid</target>
        </trans-unit>
        <trans-unit id="05eaf59bb6cde2c9fd3f75d19d83116a1f08a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; is a Phoenix macro that corresponds to the HTTP verb GET. Similar macros exist for other HTTP verbs including POST, PUT, PATCH, DELETE, OPTIONS, CONNECT, TRACE and HEAD.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 은 HTTP 동사 GET에 해당하는 Phoenix 매크로입니다. POST, PUT, PATCH, DELETE, OPTIONS, CONNECT, TRACE 및 HEAD를 포함한 다른 HTTP 동사에 대해서도 유사한 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c657f7e7c4efa726387b5bca016ed8175980cdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;options&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;head&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;options&lt;/code&gt; , &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;head&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 는 검색된 값입니다 (반환되기 전에 작동 가능).</target>
        </trans-unit>
        <trans-unit id="50ec8f6c4a4f0f0d84457bf3294f81154d218c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_by&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in source. For more complicated queries you can access fields directly instead of atoms.</source>
          <target state="translated">&lt;code&gt;group_by&lt;/code&gt; 는 또한 각 원자가 소스의 필드를 나타내는 원자 목록을 허용합니다. 보다 복잡한 쿼리의 경우 원자 대신 필드에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a10d6c2d72038d70bb97861d2206068620bead68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;halted&lt;/code&gt; - the boolean status on whether the pipeline was halted</source>
          <target state="translated">&lt;code&gt;halted&lt;/code&gt; -파이프 라인이 중지되었는지 여부에 대한 부울 상태</target>
        </trans-unit>
        <trans-unit id="df11e0f777caddadd28752850c0ea1c11432e553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handleEvent(event, (payload) =&amp;gt; ...)&lt;/code&gt; - method to handle an event pushed from the server</source>
          <target state="translated">&lt;code&gt;handleEvent(event, (payload) =&amp;gt; ...)&lt;/code&gt; -서버에서 푸시 된 이벤트를 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="4600c41d3365badfa7e4209327292730b13256cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_out/3&lt;/code&gt; callbacks must return one of:</source>
          <target state="translated">&lt;code&gt;handle_out/3&lt;/code&gt; 콜백은 다음 중 하나를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0128554f32d386f4289598774287e4e88d7412d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; - The socket module where this socket originated, for example: &lt;code&gt;MyApp.UserSocket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; -이 소켓이 시작된 소켓 모듈, 예를 들어 : &lt;code&gt;MyApp.UserSocket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e46b883edcd4081fc95cc313d38c36152a77636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; a MFArgs that will be executed when this action is triggered</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 이 작업이 트리거 될 때 실행될 MFArg를 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="524f7e30658816b4fd6a4b55651f92f65c49b7d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_many&lt;/code&gt; can be used to define hierarchical relationships within a single schema, for example threaded comments.</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 는 단일 스키마 내에서 계층 관계를 정의하는 데 사용할 수 있습니다 (예 : 스레드 주석).</target>
        </trans-unit>
        <trans-unit id="bdeb6930f3287707d3e196bf9ad5e2e53ad7094a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hooks&lt;/code&gt; &amp;ndash; a reference to a user-defined hooks namespace, containing client callbacks for server/client interop. See the interop section below for details.</source>
          <target state="translated">&lt;code&gt;hooks&lt;/code&gt; &amp;ndash; 서버 / 클라이언트 interop에 대한 클라이언트 콜백을 포함하는 사용자 정의 후크 네임 스페이스에 대한 참조입니다. 자세한 내용은 아래 interop 섹션을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="b077bbf122963118bf4bd9a4e8595f7482dbeb98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; - the requested host as a binary, example: &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; - 이진, 예를 들어 같은 요청 호스트 : &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02b1f40fbd54a788648bfdb46a54042d80f2234b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id/1&lt;/code&gt; - receives the socket returned by &lt;code&gt;connect/2&lt;/code&gt; and returns the id of this connection as a string. The &lt;code&gt;id&lt;/code&gt; is used to identify socket connections, often to a particular user, allowing us to force disconnections. For sockets requiring no authentication, &lt;code&gt;nil&lt;/code&gt; can be returned.</source>
          <target state="translated">&lt;code&gt;id/1&lt;/code&gt; - &lt;code&gt;connect/2&lt;/code&gt; 에 의해 리턴 된 소켓을 수신 하고이 연결의 id를 문자열로 리턴합니다. &lt;code&gt;id&lt;/code&gt; 우리가 단선을 강제 할 수 있도록, 종종 특정 사용자에게, 소켓 연결을 식별하는 데 사용됩니다. 인증이 필요없는 소켓의 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a083637f878534b4f996b95618db816a2068b3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id/1&lt;/code&gt; - receives the socket returned by &lt;code&gt;connect/3&lt;/code&gt; and returns the id of this connection as a string. The &lt;code&gt;id&lt;/code&gt; is used to identify socket connections, often to a particular user, allowing us to force disconnections. For sockets requiring no authentication, &lt;code&gt;nil&lt;/code&gt; can be returned</source>
          <target state="translated">&lt;code&gt;id/1&lt;/code&gt; - &lt;code&gt;connect/3&lt;/code&gt; 에서 반환 된 소켓을 수신 하고이 연결의 ID를 문자열로 반환합니다. &lt;code&gt;id&lt;/code&gt; 우리가 단선을 강제 할 수 있도록, 종종 특정 사용자에게, 소켓 연결을 식별하는 데 사용됩니다. 인증이 필요하지 않은 소켓의 경우 &lt;code&gt;nil&lt;/code&gt; 이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8760f24908d1cc31e129470b0c3921f1006f2be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - The DOM id of the LiveView</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -LiveView의 DOM ID</target>
        </trans-unit>
        <trans-unit id="c0f36b342982b9967c866bd37637dac595318f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - The string id of the socket</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; - 소켓의 문자열 ID</target>
        </trans-unit>
        <trans-unit id="3b7899c38049ecfa25c353f9e0684db46c9045e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; - ignores updates to the DOM regardless of new content changes</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; - 새 컨텐츠 변경에 관계없이 DOM에 대한 업데이트를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1b1d9bad82657262f6d8fa3e6465e57b2815237a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inc&lt;/code&gt; - increments (or decrements if the value is negative) the given field in the table by the given value</source>
          <target state="translated">&lt;code&gt;inc&lt;/code&gt; - 주어진 값만큼 테이블의 주어진 필드를 증가 (또는 값이 음수이면 감소)</target>
        </trans-unit>
        <trans-unit id="8a4163994855fbc15bd391cf9497da10628839eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init/1&lt;/code&gt; which initializes any arguments or options to be passed to &lt;code&gt;call/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; &lt;code&gt;call/2&lt;/code&gt; 에 전달할 인수 또는 옵션을 초기화하는 init / 1</target>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_arg&lt;/code&gt; 는 start_link &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 전달 된 인수 용어 (두 번째 인수) 입니다.</target>
        </trans-unit>
        <trans-unit id="d9dff694619e6e23269799d025b46fd57d376dce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_path&lt;/code&gt; - The path where the assets are located</source>
          <target state="translated">&lt;code&gt;input_path&lt;/code&gt; - 자산이 위치한 경로</target>
        </trans-unit>
        <trans-unit id="c5ae964f45075d85a78e2dea260e5b094dfe3d80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_defaults&lt;/code&gt; - A list of defaults for join associations</source>
          <target state="translated">&lt;code&gt;join_defaults&lt;/code&gt; - 조인 연결에 대한 기본값 목록</target>
        </trans-unit>
        <trans-unit id="72e4ee4913f961c9a4b7c29d32492f68e19f6e4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_keys&lt;/code&gt; - The keyword list with many to many join keys</source>
          <target state="translated">&lt;code&gt;join_keys&lt;/code&gt; - 많은 수의 조인 키가있는 키워드 목록</target>
        </trans-unit>
        <trans-unit id="4475cd0a0d4fef0b5617f1e177a632cda8408a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_ref&lt;/code&gt; - The ref sent by the client when joining</source>
          <target state="translated">&lt;code&gt;join_ref&lt;/code&gt; - 가입 할 때 클라이언트가 보낸 심판</target>
        </trans-unit>
        <trans-unit id="033042548c899de9336607002781cabe646ba3ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_through&lt;/code&gt; - Atom (representing a schema) or a string (representing a table) for many to many associations</source>
          <target state="translated">&lt;code&gt;join_through&lt;/code&gt; -다 대다 연관에 대한 원자 (스키마를 나타냄) 또는 문자열 (테이블을 나타냄)</target>
        </trans-unit>
        <trans-unit id="4ff2cd1f26d7677d1ea7be8a102c57a144123171" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joined&lt;/code&gt; - If the socket has effectively joined the channel</source>
          <target state="translated">&lt;code&gt;joined&lt;/code&gt; - 소켓이 채널에 효과적으로 참여한 경우</target>
        </trans-unit>
        <trans-unit id="ba377f67ecee40301795593b5845f36339a1c83d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep&lt;/code&gt; - The number of old versions to keep</source>
          <target state="translated">&lt;code&gt;keep&lt;/code&gt; -유지할 이전 버전 수</target>
        </trans-unit>
        <trans-unit id="aa2a4d88e36458095a07be41cda1bef97c2d53cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - The key identifying this presence</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; -이 존재를 식별하는 키</target>
        </trans-unit>
        <trans-unit id="0783a714f2079cf68176ecedddab548909d2517d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - The key of the presence</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; - 존재의 핵심</target>
        </trans-unit>
        <trans-unit id="74dee47697a859176e1ea99bc7d001624d5b6176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; is an atom that represents any field, embed or association in the changeset. Note the &lt;code&gt;value&lt;/code&gt; is directly stored in the changeset with no validation whatsoever. For this reason, this function is meant for working with data internal to the application.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 는 변경 세트에서 필드, 임베드 또는 연관을 나타내는 원자입니다. 노트 &lt;code&gt;value&lt;/code&gt; 없이 직접 검증 무엇이든지로 변경 집합에 저장됩니다. 이러한 이유로이 기능은 응용 프로그램 내부의 데이터로 작업하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fec2c01dfd33d8ea1494f964482b06773fd44184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;label&lt;/code&gt; a string/binary that names this action</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 이 작업의 이름을 지정하는 문자열 / 이진 레이블 을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="23a54cc6f718e22576f0892705f452d338d0f519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; - a directory that holds your application source code. This directory is broken into two subdirectories, &lt;code&gt;lib/hello&lt;/code&gt; and &lt;code&gt;lib/hello_web&lt;/code&gt;. The &lt;code&gt;lib/hello&lt;/code&gt; directory will be responsible to host all of your business logic and business domain. It typically interacts directly with the database - it is the &quot;Model&quot; in Model-View-Controller (MVC) architecture. &lt;code&gt;lib/hello_web&lt;/code&gt; is responsible for exposing your business domain to the world, in this case, through a web application. It holds both the View and Controller from MVC. We will discuss the contents of these directories with more detail in the next sections</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; - 애플리케이션 소스 코드가있는 디렉토리. 이 디렉토리는 &lt;code&gt;lib/hello&lt;/code&gt; 및 &lt;code&gt;lib/hello_web&lt;/code&gt; 이라는 두 개의 하위 디렉토리로 나뉩니다 . &lt;code&gt;lib/hello&lt;/code&gt; 디렉토리는 비즈니스 로직 및 비즈니스 도메인의 모든 호스트 할 책임이 있습니다. 일반적으로 데이터베이스와 직접 상호 작용하며 MVC (Model-View-Controller) 아키텍처의 &quot;모델&quot;입니다. &lt;code&gt;lib/hello_web&lt;/code&gt; 은이 경우 웹 애플리케이션을 통해 비즈니스 도메인을 세계에 노출하는 역할을합니다. MVC의 View와 Controller를 모두 보유합니다. 이 디렉토리의 내용은 다음 섹션에서 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1bbea57c14a5631a6b8d6992eb1b336e0649deb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;live_component&lt;/code&gt; - compartmentalizes state, markup, and events</source>
          <target state="translated">&lt;code&gt;live_component&lt;/code&gt; - 상태, 마크 업 및 이벤트를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="4cb29cafab5d3a6fd4e5e13463c75a3c8614561a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;live_render&lt;/code&gt; - compartmentalizes state, markup, events, and error isolation</source>
          <target state="translated">&lt;code&gt;live_render&lt;/code&gt; - 상태, 마크 업, 이벤트 및 오류 격리를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="3532c1a568b33337de71436794ff90d6697591a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lv:clear-flash&lt;/code&gt; &amp;ndash; clears the flash when sent to the server. If a &lt;code&gt;phx-value-key&lt;/code&gt; is provided, the specific key will be removed from the flash.</source>
          <target state="translated">&lt;code&gt;lv:clear-flash&lt;/code&gt; &amp;ndash; 서버로 전송 될 때 플래시를 지 웁니다. 경우 &lt;code&gt;phx-value-key&lt;/code&gt; 제공되고, 특정 키가 플래시에서 제거 될 것이다.</target>
        </trans-unit>
        <trans-unit id="d6efc4486225466bcb4bb3a50a9925455d3cba9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_delta_sizes&lt;/code&gt; - The list of delta generation sizes to keep before falling back to sending entire state. Defaults &lt;code&gt;[100, 1000, 10_000]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_delta_sizes&lt;/code&gt; - 전체 상태 전송으로 돌아 가기 전에 유지할 델타 생성 크기 목록입니다. 기본값은 &lt;code&gt;[100, 1000, 10_000]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="987ff9001ecd494c25e6ef563e17f3fe60fc42da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_silent_periods&lt;/code&gt; - The max integer of broadcast periods for which no delta broadcasts have been sent. Defaults &lt;code&gt;10&lt;/code&gt; (15s heartbeat)</source>
          <target state="translated">&lt;code&gt;max_silent_periods&lt;/code&gt; - 델타 브로드 캐스트가 전송되지 않은 브로드 캐스트 기간의 최대 정수입니다. 기본값 &lt;code&gt;10&lt;/code&gt; (15 초 하트 비트)</target>
        </trans-unit>
        <trans-unit id="492c66a3f6bfa5477a4c651d837532e7ec419a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;measurements&lt;/code&gt; - A map of atom keys (e.g. &lt;code&gt;:duration&lt;/code&gt;) and numeric values.</source>
          <target state="translated">&lt;code&gt;measurements&lt;/code&gt; -원자 키 (예 &lt;code&gt;:duration&lt;/code&gt; ) 및 숫자 값 의 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="3de05497aed68e61231371d7fde7ad036371310b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - The payload of the broadcast</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; -방송의 페이로드</target>
        </trans-unit>
        <trans-unit id="a98979d797e9cd1b3df09361e9856e1361a9f82f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta&lt;/code&gt; - Either a new map of metadata to attach to this presence, or a function. The function will receive the current metadata as input and the return value will be used as the new metadata</source>
          <target state="translated">&lt;code&gt;meta&lt;/code&gt; - 이 존재에 첨부 할 새로운 메타 데이터 맵 또는 함수입니다. 이 함수는 현재 메타 데이터를 입력으로 수신하고 반환 값은 새 메타 데이터로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="dd95b5eeb5bcdf67736b6285795ac639e6b3439b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta&lt;/code&gt; - The map of metadata to attach to this presence</source>
          <target state="translated">&lt;code&gt;meta&lt;/code&gt; - 이 존재에 첨부 할 메타 데이터 맵</target>
        </trans-unit>
        <trans-unit id="463053aaa0c8f9b257e3fbd97f8167c647fff086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; - A map of key/value pairs that can be used for tagging metrics.</source>
          <target state="translated">&lt;code&gt;metadata&lt;/code&gt; -측정 항목에 태그를 지정하는 데 사용할 수있는 키 / 값 쌍의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="9f1cfc9235e334bda47946b04d8e6153452ac028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method-param&lt;/code&gt; - a request parameter where expected a custom HTTP method</source>
          <target state="translated">&lt;code&gt;method-param&lt;/code&gt; - 사용자 정의 HTTP 메소드가 필요한 요청 매개 변수</target>
        </trans-unit>
        <trans-unit id="073a7768fad0def734e63a744eb526e08585ef4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method&lt;/code&gt; - the request method as a binary, example: &lt;code&gt;&quot;GET&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; - 바이너리로 요청 방법, 예 : &lt;code&gt;&quot;GET&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aafb8a58dea8783be5dbf5934648d694c596e504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The channel module handler, for example &lt;code&gt;MyApp.RoomChannel&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; - 채널 모듈 처리기, 예를 들어 대 &lt;code&gt;MyApp.RoomChannel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07716c12c4ba76513695593e8b1f76d9cbb8f36d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The channel module handler, for example &lt;code&gt;MyAppWeb.RoomChannel&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; - 채널 모듈 처리기, 예를 들어 대 &lt;code&gt;MyAppWeb.RoomChannel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dad28da3c44d59a50496cb192cbac75bc618c3d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The module of the running LiveView</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; - 실행중인 라이브 뷰의 모듈</target>
        </trans-unit>
        <trans-unit id="50ffe6d07d8740ddcb2d86532bc91a2f75d71e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mounted&lt;/code&gt; - the element has been added to the DOM and its server LiveView has finished mounting</source>
          <target state="translated">&lt;code&gt;mounted&lt;/code&gt; -요소가 DOM에 추가되었으며 서버 LiveView가 마운트를 완료했습니다.</target>
        </trans-unit>
        <trans-unit id="d2eaf9afb0b18cfd6c31c3c8e4486386b57c6369" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mssql&lt;/code&gt; - via &lt;a href=&quot;https://github.com/livehelpnow/tds&quot;&gt;https://github.com/livehelpnow/tds&lt;/a&gt; Please check the driver docs for more information and requirements. Defaults to &quot;postgres&quot;.</source>
          <target state="translated">&lt;code&gt;mssql&lt;/code&gt; - &lt;a href=&quot;https://github.com/livehelpnow/tds&quot;&gt;https: &lt;/a&gt;//github.com/livehelpnow/tds 를 통해 자세한 정보와 요구 사항은 드라이버 문서를 확인하십시오. 기본값은 &quot;postgres&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="cf3781c5f33126b6b5a463a7271b48a2e2f4458c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql&lt;/code&gt; - via &lt;a href=&quot;https://github.com/elixir-ecto/myxql&quot;&gt;https://github.com/elixir-ecto/myxql&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;mysql&lt;/code&gt; - &lt;a href=&quot;https://github.com/elixir-ecto/myxql&quot;&gt;https: &lt;/a&gt;//github.com/elixir-ecto/myxql을 통해</target>
        </trans-unit>
        <trans-unit id="88ae990434cd3c2bf55e963d5908aec7e902bf32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct which has no timezone information.</source>
          <target state="translated">&lt;code&gt;naive_datetime&lt;/code&gt; - 초의 정밀도 를 가지며 시간대 정보가없는 Elixir의 &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체에 값을 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="72190aad3be538b4ccd471924a62f1cbc3d0c5ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct which has no timezone information.</source>
          <target state="translated">&lt;code&gt;naive_datetime&lt;/code&gt; - 초의 정밀도 를 가지며 시간대 정보가없는 Elixir의 &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체로 값을 캐스팅합니다 .</target>
        </trans-unit>
        <trans-unit id="8ea7a90df3b84001b80cc2821e898e38884aab0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime_usec&lt;/code&gt; - has a default precision of microseconds and also casts values to &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; with no timezone information.</source>
          <target state="translated">&lt;code&gt;naive_datetime_usec&lt;/code&gt; - 기본 정밀도는 마이크로 초이며 시간대 정보없이 &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 에&lt;/a&gt; 값을 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="51dbf7e5041587314a31577e6618e8e0b3f71e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - A string (e.g. &lt;code&gt;&quot;my_app.worker.stop&quot;&lt;/code&gt;) or a list of atoms that uniquely identifies the event.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; - 문자열 (예 : &lt;code&gt;&quot;my_app.worker.stop&quot;&lt;/code&gt; ) 또는 이벤트를 고유하게 식별하는 원자의 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="92e5ba0cc31bfe12a2a673e8b795bd8b531755e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be a compile-time literal string that is being used as the table name to join the CTE in the main query or in the recursive CTE.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 기본 쿼리 또는 재귀 CTE에서 CTE를 조인하기위한 테이블 이름으로 사용되는 컴파일 타임 리터럴 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 는 인 &lt;code&gt;data&lt;/code&gt; 의 값을 업데이트 한 후 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;update_value&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="071b5d9e60612b566cae9b30348f283cff64086a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - meaning there is no body</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; - 몸이 없다는 의미</target>
        </trans-unit>
        <trans-unit id="7b257868b5b9b8cea561cf9f4b32865bee4efdd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - meaning there is no body;</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; - 몸이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="68dababfbb700643426a41acecf9015e6b58146f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - which specifies the field must be nil</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; - 필드가 nil이어야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ee8c2088dd46a5d35247fd24c0dc0bd6022b5a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; comparison</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="cc683e64d5f1778f0dbc56cc4b9ca496abe8bff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; comparison in filters, such as where and having, is forbidden and it will raise an error:</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 위치 및 위치와 같은 필터의 nil 비교는 금지되며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71fa2cf56455786b265a7233aef687e50babc74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node&lt;/code&gt; - The name of the node to broadcast the message on</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; - 메시지를 브로드 캐스트 할 노드의 이름</target>
        </trans-unit>
        <trans-unit id="07e06948f26eebc207946c1a1321c20825534155" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_name&lt;/code&gt; - The target node name</source>
          <target state="translated">&lt;code&gt;node_name&lt;/code&gt; - 대상 노드 이름</target>
        </trans-unit>
        <trans-unit id="b73bbef6c9ffd1b91b3deb04a55da27fe4ecd4a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_delete&lt;/code&gt; - The action taken on associations when schema is deleted</source>
          <target state="translated">&lt;code&gt;on_delete&lt;/code&gt; - 스키마가 삭제 될 때 연관에 대해 수행되는 조치</target>
        </trans-unit>
        <trans-unit id="923388859240c359e51473bac2954f8deb1180cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_replace&lt;/code&gt; - The action taken on associations when schema is replaced</source>
          <target state="translated">&lt;code&gt;on_replace&lt;/code&gt; - 스키마 교체시 연관에 대해 수행되는 조치</target>
        </trans-unit>
        <trans-unit id="c61e57c28cd8a177ef5ec74fa6da524fb7e6252d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; are expected to be an enumerable which will be used to generate each respective &lt;code&gt;option&lt;/code&gt;. The enumerable may have:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 은 각각의 &lt;code&gt;option&lt;/code&gt; 을 생성하는 데 사용될 열거 가능한 것으로 예상됩니다 . 열거 형은 다음을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a80a03019e5358fdaba91b26dbe5cc34797b1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options, see below</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; - 옵션 옵션 목록 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="127c528cc267bb9f764ed45f5d305d3765aa7530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options. See below.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; - 옵션 옵션 목록. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ae92590e66d6da2ffacaab3f46c3815c5a0a917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options. Supported options only include &lt;code&gt;:link&lt;/code&gt; to link the subscriber to local</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; - 옵션 옵션 목록. 지원되는 옵션에는 &lt;code&gt;:link&lt;/code&gt; 포함됩니다 : 가입자와 로컬을 연결하는 링크</target>
        </trans-unit>
        <trans-unit id="f89598295ec5406306e8e4e687fc49c58df5335e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or_where&lt;/code&gt; also accepts a keyword list where each key is a field to be compared with the given value. Each key-value pair will be combined using &lt;code&gt;AND&lt;/code&gt;, exactly as in &lt;code&gt;where&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;or_where&lt;/code&gt; 는 각 키가 지정된 값과 비교할 필드 인 키워드 목록도 허용합니다. 각 키 - 값 쌍을 사용하여 결합 될 &lt;code&gt;AND&lt;/code&gt; 정확히 같이 &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe0427ecfac7944aecab028a79f8e4a7d29bde93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_by&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in source or a keyword list where the direction is given as key and the field to order as value.</source>
          <target state="translated">&lt;code&gt;order_by&lt;/code&gt; 는 또한 각 원자가 소스의 필드를 가리키는 원자 목록 또는 방향이 키로 제공되고 키워드로 필드가 값으로 지정된 키워드 목록을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d3da5895b3011962cca4dbc711f49b48d9c3e8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_by&lt;/code&gt; may be invoked or listed in a query many times. New expressions are always appended to the previous ones.</source>
          <target state="translated">&lt;code&gt;order_by&lt;/code&gt; 는 여러 번 호출되거나 호출 될 수 있습니다. 새로운 표현은 항상 이전 표현에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f58a2cf9edd237804c53fa379e1e5635d41834e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otp_app&lt;/code&gt; - The OTP app running the endpoint, for example &lt;code&gt;:my_app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;otp_app&lt;/code&gt; - 엔드 포인트를 실행하는 OTP 앱 (예 &lt;code&gt;:my_app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2deb7e032d83f08bd7758501f0932a6aa9918387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otp_app&lt;/code&gt; - The otp app running the endpoint, for example &lt;code&gt;:my_app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;otp_app&lt;/code&gt; - 엔드 포인트를 실행하는 otp 앱 (예 &lt;code&gt;:my_app&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="12fb980e7f3f48b6f24141c40027c59c1d0184e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_path&lt;/code&gt; - The path where the compiled/compressed files will be saved</source>
          <target state="translated">&lt;code&gt;output_path&lt;/code&gt; - 컴파일 / 압축 파일이 저장 될 경로</target>
        </trans-unit>
        <trans-unit id="68edc15d932ff45243dead20fabfe1070fcdf0bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt; - The schema where the association was defined</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; - 연관이 정의 된 스키마</target>
        </trans-unit>
        <trans-unit id="901d6a0f8edb0eb1c7c9bedf21edaf1d45c558f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt; - the Elixir process that owns the connection</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; - 연결을 소유하고있는 비약 과정</target>
        </trans-unit>
        <trans-unit id="90512376c1abfde667c0a6f445cf21b920c60e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner_key&lt;/code&gt; - The key on the &lt;code&gt;owner&lt;/code&gt; schema used for the association</source>
          <target state="translated">&lt;code&gt;owner_key&lt;/code&gt; - 연관에 사용 된 &lt;code&gt;owner&lt;/code&gt; 스키마 의 키</target>
        </trans-unit>
        <trans-unit id="448ea9b0456e88e43b6a224745193e838be17490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;page_path&lt;/code&gt; is an example of what Phoenix calls a path helper, and we'll talk about those very soon.</source>
          <target state="translated">&lt;code&gt;page_path&lt;/code&gt; 는 Phoenix가 경로 도우미라고 부르는 예이며 곧 이에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0c9bfe1f54ef877ded2b8eead583711db874095f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - The parameters as given on changeset creation</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - 변경 세트 작성시 제공되는 매개 변수</target>
        </trans-unit>
        <trans-unit id="ec7aaecc40dfea835f8b0490814983d1101ded9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - a map of string keys which contain public information that can be set by the user. The map contains the query params as well as any router path parameter. If the LiveView was not mounted at the router, this argument is the atom &lt;code&gt;:not_mounted_at_router&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - 사용자가 설정할 수있는 공개 정보를 포함하는 문자열 키 맵입니다. 맵에는 쿼리 매개 변수와 라우터 경로 매개 변수가 포함됩니다. LiveView가 라우터에 마운트되지 않은 경우이 인수는 원자입니다 &lt;code&gt;:not_mounted_at_router&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36f0ddf7ae31b39a6199cc3eab0b4eeab1477d7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - params are merged (not deep-merged) giving precedence to the params of &lt;code&gt;changeset2&lt;/code&gt; in case of a conflict. If both changesets have their &lt;code&gt;:params&lt;/code&gt; fields set to &lt;code&gt;nil&lt;/code&gt;, the resulting changeset will have its params set to &lt;code&gt;nil&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - 충돌이 발생할 경우 매개 변수가 병합되어 (깊게 병합되지 않은) &lt;code&gt;changeset2&lt;/code&gt; 의 매개 변수보다 우선합니다 . 두 변경 세트 의 &lt;code&gt;:params&lt;/code&gt; 필드가 &lt;code&gt;nil&lt;/code&gt; 로 설정 되면 결과 변경 세트의 매개 변수 도 &lt;code&gt;nil&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b04c7f2e5980a1aab79664ac4aefb583b8812ee6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the &lt;code&gt;connect_params&lt;/code&gt; to pass to the view's mount callback. May be a literal object or closure returning an object. When a closure is provided, the function receives the view's phx-view name.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - &lt;code&gt;connect_params&lt;/code&gt; 은 의 콜백 마운트 뷰에 전달합니다. 리터럴 객체 또는 객체를 반환하는 클로저 일 수 있습니다. 클로저가 제공되면 함수는 뷰의 phx-view 이름을받습니다.</target>
        </trans-unit>
        <trans-unit id="0b8c4501335fa225540f5cac4229b077861a1d11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the request params, the result of merging the &lt;code&gt;:body_params&lt;/code&gt; and &lt;code&gt;:query_params&lt;/code&gt; with &lt;code&gt;:path_params&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - 요청 PARAMS의 병합의 결과 &lt;code&gt;:body_params&lt;/code&gt; 및 &lt;code&gt;:query_params&lt;/code&gt; 로 &lt;code&gt;:path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9deea4976a44c1b62c166b6685aa8d76a27998d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the request params, the result of merging the &lt;code&gt;:path_params&lt;/code&gt; on top of &lt;code&gt;:body_params&lt;/code&gt; on top of &lt;code&gt;:query_params&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; - 요청 PARAMS의 병합의 결과 &lt;code&gt;:path_params&lt;/code&gt; 을 위에 &lt;code&gt;:body_params&lt;/code&gt; 위에 &lt;code&gt;:query_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b29b71eb92ce43b45fbe014e176fdd74366bad17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt;, the content-type parameters (e.g., &lt;code&gt;%{&quot;foo&quot; =&amp;gt; &quot;bar&quot;}&lt;/code&gt; for the &lt;code&gt;&quot;text/plain; foo=bar&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; , 콘텐츠 형식 매개 변수 (예를 들어, &lt;code&gt;%{&quot;foo&quot; =&amp;gt; &quot;bar&quot;}&lt;/code&gt; 에 대한 &lt;code&gt;&quot;text/plain; foo=bar&quot;&lt;/code&gt; 콘텐츠 유형)</target>
        </trans-unit>
        <trans-unit id="3cb54fa84580a04ac3087492a8f37a5807040416" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path_info&lt;/code&gt; - the path split into segments, example: &lt;code&gt;[&quot;hello&quot;, &quot;world&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;path_info&lt;/code&gt; - 세그먼트로 분할 된 경로, 예 : &lt;code&gt;[&quot;hello&quot;, &quot;world&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cee62762965ac6c4625c3e275f4efb6eadb01d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path_params&lt;/code&gt; - the request path params, populated by routers such as &lt;a href=&quot;plug.router&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;path_params&lt;/code&gt; - 요청 경로 매개 변수, &lt;a href=&quot;plug.router&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; 와 같은 라우터로 채워짐</target>
        </trans-unit>
        <trans-unit id="1223e490ecfc7361507926c307a8089c528e37a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt; - The message payload</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; -메시지 페이로드</target>
        </trans-unit>
        <trans-unit id="2933a2b21e8195530e82cab1b95856032107cd6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt; - The reply payload</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; -응답 페이로드</target>
        </trans-unit>
        <trans-unit id="d114dfeb57999b3181c1ba3d704b9dbb5aaba20f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peer&lt;/code&gt; - the actual TCP peer that connected, example: &lt;code&gt;{{127, 0, 0, 1}, 12345}&lt;/code&gt;. Often this is not the actual IP and port of the client, but rather of a load-balancer or request-router.</source>
          <target state="translated">&lt;code&gt;peer&lt;/code&gt; - 접속하는 실제 TCP 피어 예 : &lt;code&gt;{{127, 0, 0, 1}, 12345}&lt;/code&gt; . 종종 이것은 클라이언트의 실제 IP 및 포트가 아니라로드 밸런서 또는 요청 라우터입니다.</target>
        </trans-unit>
        <trans-unit id="aeafb991ec912a189e0a0ffc11b88e8bd6c91af9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;permdown_period&lt;/code&gt; - The interval in milliseconds to flag a replica as permanently down, and discard its state. Note: This must be at least greater than the &lt;code&gt;down_period&lt;/code&gt;. Default &lt;code&gt;1_200_000&lt;/code&gt; (20 minutes)</source>
          <target state="translated">&lt;code&gt;permdown_period&lt;/code&gt; - 복제본을 영구적으로 중지 된 것으로 플래그 지정하고 해당 상태를 버리는 간격 (밀리 초)입니다. 참고 : 최소한 &lt;code&gt;down_period&lt;/code&gt; 보다 커야합니다 . 기본 &lt;code&gt;1_200_000&lt;/code&gt; (20 분)</target>
        </trans-unit>
        <trans-unit id="5e2c9759cd69952e44c050ca670bb66efc3ea2da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phoenix_html.js&lt;/code&gt; does trigger a custom event &lt;code&gt;phoenix.link.click&lt;/code&gt; on the clicked DOM element when a click happened. This allows you to intercept the event on it&amp;rsquo;s way bubbling up to &lt;code&gt;window&lt;/code&gt; and do your own custom logic to enhance or replace how the &lt;code&gt;data-confirm&lt;/code&gt; attribute is handled.</source>
          <target state="translated">&lt;code&gt;phoenix_html.js&lt;/code&gt; 는 클릭이 발생하면 클릭 한 DOM 요소에서 사용자 정의 이벤트 &lt;code&gt;phoenix.link.click&lt;/code&gt; 을 트리거합니다 . 이를 통해 &lt;code&gt;window&lt;/code&gt; 까지 버블 링하는 방식으로 이벤트를 가로 챌 수 있으며 , &lt;code&gt;data-confirm&lt;/code&gt; 속성이 처리되는 방식을 향상 시키거나 바꾸는 고유 한 사용자 지정 논리를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48d4d1773633b82236f1ba6658e7610cf2d44d59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phoenix_html.js&lt;/code&gt; does trigger a custom event &lt;code&gt;phoenix.link.click&lt;/code&gt; on the clicked DOM element when a click happened. This allows you to intercept the event on it's way bubbling up to &lt;code&gt;window&lt;/code&gt; and do your own custom logic to enhance or replace how the &lt;code&gt;data-confirm&lt;/code&gt; attribute is handled.</source>
          <target state="translated">&lt;code&gt;phoenix_html.js&lt;/code&gt; 는 클릭이 발생했을 때 클릭 된 DOM 요소에 대해 사용자 지정 이벤트 &lt;code&gt;phoenix.link.click&lt;/code&gt; 을 트리거합니다 . 이를 통해 &lt;code&gt;window&lt;/code&gt; 으로 떠오르는 이벤트를 가로 채고 자신의 사용자 지정 논리를 수행하여 &lt;code&gt;data-confirm&lt;/code&gt; 속성이 처리되는 방식을 개선하거나 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2cbb3c82f5b4f60d943d241eaea8f1aa261da0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-auto-recover&lt;/code&gt;, &lt;code&gt;phx-trigger-action&lt;/code&gt;, &lt;code&gt;phx-disable-with&lt;/code&gt;, &lt;code&gt;phx-feedback-for&lt;/code&gt;, &lt;code&gt;phx-submit&lt;/code&gt;, &lt;code&gt;phx-change&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-auto-recover&lt;/code&gt;, &lt;code&gt;phx-trigger-action&lt;/code&gt;, &lt;code&gt;phx-disable-with&lt;/code&gt;, &lt;code&gt;phx-feedback-for&lt;/code&gt;, &lt;code&gt;phx-submit&lt;/code&gt;, &lt;code&gt;phx-change&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8fb312adabbf0552b622da3a94886b994ae0557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-blur&lt;/code&gt; - &lt;code&gt;phx-blur-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-blur&lt;/code&gt; - &lt;code&gt;phx-blur-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28c8714e6386f77ac2f374db06544246b2c3e2ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-capture-click&lt;/code&gt;, &lt;code&gt;phx-click&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-capture-click&lt;/code&gt;, &lt;code&gt;phx-click&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db92fccb3c46c996463982244f8313ef5ed26001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-change&lt;/code&gt; - &lt;code&gt;phx-change-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-change&lt;/code&gt; - &lt;code&gt;phx-change-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58832a55f5df7de9d0edee81cdea089d029717b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-click&lt;/code&gt; - &lt;code&gt;phx-click-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-click&lt;/code&gt; - &lt;code&gt;phx-click-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffabb8a70f8c2052ceafff296c2944bcbf4ddcbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-debounce&lt;/code&gt; - Accepts either an integer timeout value (in milliseconds), or &lt;code&gt;&quot;blur&quot;&lt;/code&gt;. When an integer is provided, emitting the event is delayed by the specified milliseconds. When &lt;code&gt;&quot;blur&quot;&lt;/code&gt; is provided, emitting the event is delayed until the field is blurred by the user. Debouncing is typically used for input elements.</source>
          <target state="translated">&lt;code&gt;phx-debounce&lt;/code&gt; - 정수 시간 초과 값 (밀리 초) 또는 &lt;code&gt;&quot;blur&quot;&lt;/code&gt; 를 허용 합니다. 정수가 제공되면 이벤트 생성이 지정된 밀리 초만큼 지연됩니다. 경우 &lt;code&gt;&quot;blur&quot;&lt;/code&gt; 제공되는 필드는 사용자가 흐리게 될 때까지 이벤트를 방출하는 것이 지연된다. 디 바운싱은 일반적으로 입력 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="efc515e4bbf9f4beb0c78793ecdf190bca028bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-focus&lt;/code&gt; - &lt;code&gt;phx-focus-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-focus&lt;/code&gt; - &lt;code&gt;phx-focus-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c8b11d12c014ad087525d80e98e6e2ac34f0a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-submit&lt;/code&gt; - &lt;code&gt;phx-submit-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-submit&lt;/code&gt; - &lt;code&gt;phx-submit-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ddd7d8809d3fd3b369b8d58f482947aa6744858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-throttle&lt;/code&gt; - Accepts an integer timeout value to throttle the event in milliseconds. Unlike debounce, throttle will immediately emit the event, then rate limit it at once per provided timeout. Throttling is typically used to rate limit clicks, mouse and keyboard actions.</source>
          <target state="translated">&lt;code&gt;phx-throttle&lt;/code&gt; - 밀리 초 단위로 이벤트를 제한하는 정수 제한 시간 값을 허용합니다. 디 바운스와 달리 스로틀은 즉시 이벤트를 방출 한 다음 제공된 시간 제한 당 한 번에 속도를 제한합니다. 제한은 일반적으로 클릭, 마우스 및 키보드 동작을 제한하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c34079b1868e1438698e4b0a09c3f2eddfe88a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-throttle&lt;/code&gt;, &lt;code&gt;phx-debounce&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-throttle&lt;/code&gt;, &lt;code&gt;phx-debounce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90c5c10c097847e447c713015924e37964201781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-focus&lt;/code&gt;, &lt;code&gt;phx-window-blur&lt;/code&gt;, &lt;code&gt;phx-focus&lt;/code&gt;, &lt;code&gt;phx-blur&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-window-focus&lt;/code&gt;, &lt;code&gt;phx-window-blur&lt;/code&gt;, &lt;code&gt;phx-focus&lt;/code&gt;, &lt;code&gt;phx-blur&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac1eabb5acd1dc8417f8dcd42f26a83420e77b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keydown&lt;/code&gt; - &lt;code&gt;phx-keydown-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-window-keydown&lt;/code&gt; - &lt;code&gt;phx-keydown-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8f608ad2c2460764db8454f7cdbd5d10ee51ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keyup&lt;/code&gt; - &lt;code&gt;phx-keyup-loading&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-window-keyup&lt;/code&gt; - &lt;code&gt;phx-keyup-loading&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="933466f1d2e5d315646e7d6410e2de5331a36b6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keyup&lt;/code&gt;, &lt;code&gt;phx-window-keydown&lt;/code&gt;, &lt;code&gt;phx-keyup&lt;/code&gt;, &lt;code&gt;phx-keydown&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;phx-window-keyup&lt;/code&gt;, &lt;code&gt;phx-window-keydown&lt;/code&gt;, &lt;code&gt;phx-keyup&lt;/code&gt;, &lt;code&gt;phx-keydown&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc052edab4778366aac1a8c1777d16fd4fa1606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid being tracked</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - PID는 추적 중</target>
        </trans-unit>
        <trans-unit id="586a289164baf27b93ba186d6aca8f2bbfd353c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid of the running LiveView</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - 실행중인 라이브 뷰의 PID</target>
        </trans-unit>
        <trans-unit id="71e9584b12c52b8df2b4881e4ff2e2ed55a1cde3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid to track</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - PID는 추적</target>
        </trans-unit>
        <trans-unit id="c090d4cd50b9fad51b3912b2fcc9a9ee21ce65cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid to untrack</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - untrack에 PID를</target>
        </trans-unit>
        <trans-unit id="9608880e65f853fe83ad37569b04353c3f3d0a08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The subscriber pid</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - 구독자 pid</target>
        </trans-unit>
        <trans-unit id="8e03e5969b840a9d6cc0769b7c9d98e82792440c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plug/2&lt;/code&gt; in controllers supports guards, allowing a developer to configure a plug to only run in some particular action:</source>
          <target state="translated">&lt;code&gt;plug/2&lt;/code&gt; 컨트롤러의 플러그 / 2 는 가드를 지원하여 개발자가 특정 작업에서만 플러그가 실행되도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1b930a5728103fb2750c42096186fa075ef60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool_opts&lt;/code&gt; - The list of options used to construct the shard pool</source>
          <target state="translated">&lt;code&gt;pool_opts&lt;/code&gt; - 샤드 풀을 구성하는 데 사용되는 옵션 목록</target>
        </trans-unit>
        <trans-unit id="0d6e683099195f6ef8b283b6de0568c9060a1743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool_size&lt;/code&gt; - The size of the pool</source>
          <target state="translated">&lt;code&gt;pool_size&lt;/code&gt; - 풀의 크기</target>
        </trans-unit>
        <trans-unit id="c14c92366576b23bc218cbaefd053999dbcbf2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; - the requested port as an integer, example: &lt;code&gt;80&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; - 요청 된 포트를 정수로 표시합니다 (예 : &lt;code&gt;80&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a833ed8b631b0d4e3cca3dea77a48882349e72f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres&lt;/code&gt; - via &lt;a href=&quot;https://github.com/elixir-ecto/postgrex&quot;&gt;https://github.com/elixir-ecto/postgrex&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; - &lt;a href=&quot;https://github.com/elixir-ecto/postgrex&quot;&gt;https: &lt;/a&gt;//github.com/elixir-ecto/postgrex 를 통해</target>
        </trans-unit>
        <trans-unit id="5b4a7fc3ad2ee71ab8ddde9cda3989ffcecae263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; - prepend the new DOM contents instead of replacing</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; - 대체하는 대신 새 DOM 콘텐츠를 앞에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f5e949a29563c28dc3145cea09f4a341fe859328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priv&lt;/code&gt; - a directory that keeps all assets that are necessary in production but are not directly part of your source code. You typically keep database scripts, translation files, and more in here</source>
          <target state="translated">&lt;code&gt;priv&lt;/code&gt; - 프로덕션에 필요하지만 소스 코드의 일부가 아닌 모든 자산을 보관하는 디렉토리입니다. 일반적으로 데이터베이스 스크립트, 번역 파일 등을 여기에 보관합니다.</target>
        </trans-unit>
        <trans-unit id="1619e19e8a919eba5757593d3f3ea0464a6ea0a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; - shared library data as a map</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; -공유 라이브러리 데이터를 맵으로</target>
        </trans-unit>
        <trans-unit id="48930653af2def94bfc00bd03545f2774cbc49af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub&lt;/code&gt; - The name of the pubsub system</source>
          <target state="translated">&lt;code&gt;pubsub&lt;/code&gt; -pubsub 시스템의 이름</target>
        </trans-unit>
        <trans-unit id="5638e2e4c33a393548e5181a434030d0bec9df77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered name of the socket&amp;rsquo;s pubsub server</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; - 소켓의 pubsub 서버의 등록 된 이름</target>
        </trans-unit>
        <trans-unit id="6ba478ff86a260e4f4a3986bd24b579a4a76140f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered server name</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; - 등록 된 서버 이름</target>
        </trans-unit>
        <trans-unit id="e5b8312e520039e95e40ce565fc676c1dd6888a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered server name or pid</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; - 등록 된 서버 이름 또는 pid</target>
        </trans-unit>
        <trans-unit id="da15f0e5a718ccd0e3cdfc6dc7d068b211ab29a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pull&lt;/code&gt; - pulls (removes) the given value from the array field</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; - 배열 필드에서 주어진 값을 가져옵니다 (제거)</target>
        </trans-unit>
        <trans-unit id="a629837f9a57aeca3ef555b09707eb8a125f0e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&lt;/code&gt; - pushes (appends) the given value to the end of the array field</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; - 푸시 (추가)에 지정된 값을 배열 필드의 끝까지</target>
        </trans-unit>
        <trans-unit id="d4bac5180c1f87eeb0a942ed84909c3e9891e00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushEvent(event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; - method to push an event from the client to the LiveView server</source>
          <target state="translated">&lt;code&gt;pushEvent(event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; -클라이언트에서 LiveView 서버로 이벤트를 푸시하는 방법</target>
        </trans-unit>
        <trans-unit id="90b4b8171837e2dc29aa5afe04beb00844882268" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushEventTo(selectorOrTarget, event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; - method to push targeted events from the client to LiveViews and LiveComponents.</source>
          <target state="translated">&lt;code&gt;pushEventTo(selectorOrTarget, event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; -클라이언트에서 LiveView 및 LiveComponents로 대상 이벤트를 푸시하는 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="09ee3eefa1290ef7ade7849d1d1b89bc1caa9806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query_params&lt;/code&gt; - the request query params, populated through &lt;a href=&quot;#fetch_query_params/2&quot;&gt;&lt;code&gt;fetch_query_params/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;query_params&lt;/code&gt; - 요청 조회 매개 변수, &lt;a href=&quot;#fetch_query_params/2&quot;&gt; &lt;code&gt;fetch_query_params/2&lt;/code&gt; 를&lt;/a&gt; 통해 채워짐</target>
        </trans-unit>
        <trans-unit id="9519c1e0b9c58949cef4772842762ba75e426893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query_string&lt;/code&gt; - the request query string as a binary, example: &lt;code&gt;&quot;foo=bar&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;query_string&lt;/code&gt; - 요청 조회 문자열을 2 진으로 표시합니다 (예 : &lt;code&gt;&quot;foo=bar&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e30e87edb2f79ee96ef8e4bc145a697cb7884a77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryable&lt;/code&gt; - The real query to use for querying association</source>
          <target state="translated">&lt;code&gt;queryable&lt;/code&gt; - 조회 연관에 사용할 실제 조회</target>
        </trans-unit>
        <trans-unit id="ab4d545de4c74d29b7d4594beef12c9708c3ec1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reconnected&lt;/code&gt; - the element's parent LiveView has reconnected to the server</source>
          <target state="translated">&lt;code&gt;reconnected&lt;/code&gt; - 요소의 상위 LiveView가 서버에 다시 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="101a37bd418688184ba7c148e37dcab0e247c271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; - The latest ref sent by the client</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; - 클라이언트가 보낸 최신 참조</target>
        </trans-unit>
        <trans-unit id="0d768cd7ea6b9ee7c2188696db754b59cc3bbd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; - The unique string ref</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; - 고유 한 문자열 ref</target>
        </trans-unit>
        <trans-unit id="efadf3dccf2973d05a0309e7bc7fbef284eaf334" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;related&lt;/code&gt; - The schema that is associated</source>
          <target state="translated">&lt;code&gt;related&lt;/code&gt; - 연관된 스키마</target>
        </trans-unit>
        <trans-unit id="a44d2751224113b596d5778ef410d8589b2d6dd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;related_key&lt;/code&gt; - The key on the &lt;code&gt;related&lt;/code&gt; schema used for the association</source>
          <target state="translated">&lt;code&gt;related_key&lt;/code&gt; - 연관에 사용되는 &lt;code&gt;related&lt;/code&gt; 스키마 의 키</target>
        </trans-unit>
        <trans-unit id="21aa5e4e1c5e0396872c7f763922a2a86c66a71c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default &lt;code&gt;:child&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; 지정된 스키마와의 관계, 기본값 &lt;code&gt;:child&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d24603a5755dc5590959ca98e117b0fdb5753358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default &lt;code&gt;:parent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; 지정된 스키마와의 관계, 기본값 &lt;code&gt;:parent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8198e35a26fb1610134ff582a4d568c1a3ee0aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default is &lt;code&gt;:child&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; 지정된 스키마와의 관계. 기본값은 &lt;code&gt;:child&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="279bbb4744ce1c8638d5e66399287c26b08925bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy&amp;rsquo;s PROXY protocol. It defaults to peer&amp;rsquo;s IP</source>
          <target state="translated">&lt;code&gt;remote_ip&lt;/code&gt; - 클라이언트의 IP 예 : &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt; . 이 필드는 예를 들어 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더 또는 HAProxy의 PROXY 프로토콜 을 이해하는 플러그로 덮어 써야합니다. 기본적으로 피어의 IP</target>
        </trans-unit>
        <trans-unit id="4de8b9c8e0d2f8c562549e4e7f2c9bc3c5a6ac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy&amp;rsquo;s PROXY protocol. It defaults to peer&amp;rsquo;s IP.</source>
          <target state="translated">&lt;code&gt;remote_ip&lt;/code&gt; - 클라이언트의 IP 예 : &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt; . 이 필드는 예를 들어 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더 또는 HAProxy의 PROXY 프로토콜 을 이해하는 플러그로 덮어 써야합니다. 피어의 IP가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d391b4a2bae0547b91d55585b723536c915fce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy's PROXY protocol. It defaults to peer's IP</source>
          <target state="translated">&lt;code&gt;remote_ip&lt;/code&gt; - 클라이언트의 IP, 예 : &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt; . 이 필드는 예를 들어 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더 또는 HAProxy의 PROXY 프로토콜 을 이해하는 플러그로 덮어 쓰기됩니다 . 기본값은 피어의 IP입니다.</target>
        </trans-unit>
        <trans-unit id="5f3a9a7f5d67913708e29f87d0f54930fb38c904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render/3&lt;/code&gt; will also pass the value which the &lt;code&gt;show&lt;/code&gt; action received for &lt;code&gt;messenger&lt;/code&gt; from the params as an assign.</source>
          <target state="translated">&lt;code&gt;render/3&lt;/code&gt; 는 또한 매개 변수로부터 &lt;code&gt;messenger&lt;/code&gt; 대해받은 &lt;code&gt;show&lt;/code&gt; 액션 의 값을 할당으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6f9fb90b69be1b28020d819ca38f79d243383186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; - compartmentalizes markup</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; -마크 업을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="c0e87dd1de9614cad2d1a3977d5ef0ced83abf44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace&lt;/code&gt; - the default operation. Replaces the element with the contents</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; - 기본 작업입니다. 요소를 내용으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0ca491a5efb3da72b88c1921230f0a8746f71dc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repo&lt;/code&gt; - The repository applying the changeset (only set after a Repo function is called)</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; - 변경 세트를 적용하는 저장소 (Repo 함수가 호출 된 후에 만 ​​설정 됨)</target>
        </trans-unit>
        <trans-unit id="e4763165fcbf61ace38314ad898960d8ea1af421" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repo_opts&lt;/code&gt; - A keyword list of options given to the underlying repository operation</source>
          <target state="translated">&lt;code&gt;repo_opts&lt;/code&gt; - 기본 리포지토리 작업에 제공된 옵션의 키워드 목록</target>
        </trans-unit>
        <trans-unit id="3d51ec606413cad00064814387679d26c89e472a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_cookies&lt;/code&gt; - the request cookies (without the response ones)</source>
          <target state="translated">&lt;code&gt;req_cookies&lt;/code&gt; - 요청 쿠키 (응답 쿠키 제외)</target>
        </trans-unit>
        <trans-unit id="24588e6a6d03b7a536204372ff6992859cb63f43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_headers&lt;/code&gt; - the request headers as a list, example: &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt;. Note all headers will be downcased</source>
          <target state="translated">&lt;code&gt;req_headers&lt;/code&gt; - 요청 헤더 목록 (예 : &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt; . 모든 헤더는 소문자로 표시됩니다</target>
        </trans-unit>
        <trans-unit id="e9dcff9717db7374944b01dee18a077c6626c196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_headers&lt;/code&gt; - the request headers as a list, example: &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt;. Note all headers will be downcased.</source>
          <target state="translated">&lt;code&gt;req_headers&lt;/code&gt; - 요청 헤더 목록 (예 : &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt; . 모든 헤더는 소문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a05778542387a94ac620874443a90c1b1b661817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request_path&lt;/code&gt; - the requested path, example: &lt;code&gt;/trailing/and//double//slashes/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;request_path&lt;/code&gt; - 요청 된 경로, 예 : &lt;code&gt;/trailing/and//double//slashes/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52dfa603921109f668d5806807de9b5f0ebc41b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;required&lt;/code&gt; - All required fields as a list of atoms</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; -원자 목록으로 모든 필수 필드</target>
        </trans-unit>
        <trans-unit id="0dd7d96519c5250b3619288d0042ef4be36b771b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;required&lt;/code&gt; - required fields are merged; all the fields that appear in the required list of both changesets are moved to the required list of the resulting changeset.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; -필수 필드가 병합됩니다. 두 변경 세트의 필수 목록에 나타나는 모든 필드가 결과 변경 세트의 필수 목록으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4ecc2849315302f2f8781193df1f4160a26ba41b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_body&lt;/code&gt; - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections.</source>
          <target state="translated">&lt;code&gt;resp_body&lt;/code&gt; - 응답 본문은 기본적으로 빈 문자열입니다. 테스트 연결을 제외하고 응답이 전송 된 후 nil로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="63874ea7f11075ada6462ede5978c14d61267a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_body&lt;/code&gt; - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections. The response charset used defaults to &quot;utf-8&quot;.</source>
          <target state="translated">&lt;code&gt;resp_body&lt;/code&gt; - 응답 본문은 기본적으로 빈 문자열입니다. 테스트 연결을 제외하고 응답이 전송 된 후 nil로 설정됩니다. 사용 된 응답 문자 세트는 기본적으로 &quot;utf-8&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="378c18fb5b006d3619383e311eee70821aa6bc49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_charset&lt;/code&gt; - the response charset, defaults to &amp;ldquo;utf-8&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;resp_charset&lt;/code&gt; - 응답 문자셋, 기본값은 &quot;utf-8&quot;</target>
        </trans-unit>
        <trans-unit id="33c05281c7d9417a2d6c473d0d303bb3b857bab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_cookies&lt;/code&gt; - the response cookies with their name and options</source>
          <target state="translated">&lt;code&gt;resp_cookies&lt;/code&gt; - 이름과 옵션이있는 응답 쿠키</target>
        </trans-unit>
        <trans-unit id="bdbe3bcda2074df88c297579fe6592ff06d9a359" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_headers&lt;/code&gt; - the response headers as a list of tuples, by default &lt;code&gt;cache-control&lt;/code&gt; is set to &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt;. Note, response headers are expected to have lower-case keys.</source>
          <target state="translated">&lt;code&gt;resp_headers&lt;/code&gt; - 기본적으로 &lt;code&gt;cache-control&lt;/code&gt; 는 튜플 목록으로서 응답 헤더 가 &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt; 됩니다. 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="66d3cbf3d421d453d7089fda11411d601070c4ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_headers&lt;/code&gt; - the response headers as a list of tuples, by default &lt;code&gt;cache-control&lt;/code&gt; is set to &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt;. Note, response headers are expected to have lowercase keys.</source>
          <target state="translated">&lt;code&gt;resp_headers&lt;/code&gt; - 기본적으로 &lt;code&gt;cache-control&lt;/code&gt; 는 튜플 목록으로서 응답 헤더 가 &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt; 됩니다. 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="22c688d476534e17678a3cbf023f13d36df40ede" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_of_before_callback&lt;/code&gt; is the return value of the &amp;ldquo;before&amp;rdquo; clause of the same &lt;code&gt;event_callback&lt;/code&gt;. This is a means of passing data from the &amp;ldquo;before&amp;rdquo; clause to the &amp;ldquo;after&amp;rdquo; clause when instrumenting.</source>
          <target state="translated">&lt;code&gt;result_of_before_callback&lt;/code&gt; 은 동일한 &lt;code&gt;event_callback&lt;/code&gt; 의&amp;ldquo;before&amp;rdquo;절의 반환 값입니다 . 계측 할 때 &quot;이전&quot;절에서 &quot;이후&quot;절로 데이터를 전달하는 수단입니다.</target>
        </trans-unit>
        <trans-unit id="889001db9546bb8ae5d1b4c1e9819dcaefa903d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reuse_sessions: true&lt;/code&gt; - for improved handshake performance of recurring connections</source>
          <target state="translated">&lt;code&gt;reuse_sessions: true&lt;/code&gt; 반복 연결의 핸드 셰이크 성능 향상</target>
        </trans-unit>
        <trans-unit id="103b1466ccea7577fc2a4b9b0c2aa6b7c282417e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runtime_metadata&lt;/code&gt; is a map of runtime data that the instrumentation passes to the callbacks. This can be used for any purposes: for example, when instrumenting the rendering of a view, the name of the view could be passed in these runtime data so that instrumenters know which view is being rendered (&lt;code&gt;instrument(:view_render, %{view: &quot;index.html&quot;}, fn
...)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;runtime_metadata&lt;/code&gt; 는 계측이 콜백에 전달하는 런타임 데이터의 맵입니다. 예를 들어, 뷰 렌더링을 계측 할 때 이러한 런타임 데이터에 뷰 이름을 전달하면 인스트루먼트가 어떤 뷰가 렌더링되는지 알 수 있습니다 ( &lt;code&gt;instrument(:view_render, %{view: &quot;index.html&quot;}, fn ...)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="246a6e125a6cf67c0c1df577f1bce26aa4280292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runtime_metadata&lt;/code&gt; may be omitted and defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;runtime_metadata&lt;/code&gt; 는 생략 될 수 있으며 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36b7f3342f55b56b6b713d16862546295104a9d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme&lt;/code&gt; - the request scheme as an atom, example: &lt;code&gt;:http&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scheme&lt;/code&gt; -원자로서의 요청 체계, 예 : &lt;code&gt;:http&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="980eef85fef584aef6bf3226e97f3b0808c7379f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL&amp;rsquo;s path that corresponds to the application routing, as segments, example: &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;script_name&lt;/code&gt; - 세그먼트로 애플리케이션 라우팅에 해당하는 URL 경로의 초기 부분 (예 : &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cab0fd37e630576ecdaeed217e5a0c392005a958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL&amp;rsquo;s path that corresponds to the application routing, as segments, example: [&amp;ldquo;sub&amp;rdquo;,&amp;rdquo;app&amp;rdquo;].</source>
          <target state="translated">&lt;code&gt;script_name&lt;/code&gt; - 응용 프로그램 라우팅에 해당하는 URL 경로의 초기 부분입니다 (예 : [&amp;ldquo;sub&amp;rdquo;,&amp;rdquo;app&amp;rdquo;]).</target>
        </trans-unit>
        <trans-unit id="7afeaf635368e4ff1b981a38f4e9d5045170e061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL's path that corresponds to the application routing, as segments, example: &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;script_name&lt;/code&gt; - 애플리케이션 라우팅에 해당하는 URL 경로의 초기 부분 (예 : &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd76c23ddceb864d0c5a514fe4c77eddb9a07c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="translated">&lt;code&gt;secret_key_base&lt;/code&gt; - 쿠키를 확인하고 암호화하는 데 사용되는 비밀 키. 해당 기능 중 하나를 사용할 때마다 필드를 수동으로 설정해야합니다. 이 데이터는 연결 상태로 유지해야하며 직접 사용 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt; &lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt; &lt;/a&gt; 항상 Plug.Crypto.KeyGenerator.generate / 3 를 사용하여 키를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4bcf6de75da5881e20edb522c80c5be8e712788e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="translated">&lt;code&gt;secret_key_base&lt;/code&gt; - 쿠키를 확인하고 암호화하는 데 사용되는 비밀 키입니다. 이러한 기능 중 하나를 사용할 때마다 필드를 수동으로 설정해야합니다. 이 데이터는 연결에 유지되어야하며 직접 사용되지 않아야합니다. 항상 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt; &lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 키를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1253f664065a2d62b14b6ef67f605e6b39aaddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;plug.crypto.keygenerator#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="translated">&lt;code&gt;secret_key_base&lt;/code&gt; - 쿠키를 확인하고 암호화하는 데 사용되는 비밀 키. 해당 기능 중 하나를 사용할 때마다 필드를 수동으로 설정해야합니다. 이 데이터는 연결 상태로 유지해야하며 직접 사용 &lt;a href=&quot;plug.crypto.keygenerator#generate/3&quot;&gt; &lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt; &lt;/a&gt; 항상 Plug.Crypto.KeyGenerator.generate / 3 를 사용하여 키를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="15c7700e939b6aee43091eff79c04cb08f48d4e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secure_renegotiate: true&lt;/code&gt; - to avoid certain types of man-in-the-middle attacks</source>
          <target state="translated">&lt;code&gt;secure_renegotiate: true&lt;/code&gt; 특정 유형의 중간자 (man-in-the-middle) 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="f29f5db6bf5d13386e17da68d405842a111c081d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in the source to be selected.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 는 또한 각 원자가 선택할 소스의 필드를 나타내는 원자 목록을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6eb899148e2dbea005f987b933cbbd3fc701448e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select_merge&lt;/code&gt; cannot be used to set fields in associations, as associations are always loaded later, overriding any previous value.</source>
          <target state="translated">&lt;code&gt;select_merge&lt;/code&gt; 연관은 항상 나중에로드되어 이전 값을 대체하므로 select_merge 는 연관의 필드를 설정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1288249154ccf26ed1bd0af1917adbe00c8851c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;selector&lt;/code&gt; - The query selector</source>
          <target state="translated">&lt;code&gt;selector&lt;/code&gt; -쿼리 선택기</target>
        </trans-unit>
        <trans-unit id="296aa6876fe50d49e496600ad420f7a74bc5f953" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serializer&lt;/code&gt; - The serializer for socket messages, for example: &lt;code&gt;Phoenix.Transports.WebSocketSerializer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;serializer&lt;/code&gt; - 소켓 메시지 용 serializer (예 : &lt;code&gt;Phoenix.Transports.WebSocketSerializer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f182d3c71f466a802a29f20fd63a50cc07f0725a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; - The Pid or registered server name and optional node to scope the broadcast, for example: &lt;code&gt;MyApp.PubSub&lt;/code&gt;, &lt;code&gt;{MyApp.PubSub, :a@node}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; -는 PID 또는 등록 된 서버 이름 및 범위, 예를 들어 방송에 대한 선택적 노드 : &lt;code&gt;MyApp.PubSub&lt;/code&gt; , &lt;code&gt;{MyApp.PubSub, :a@node}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6ba97119409938a372ed07abe79b4f2a78dc862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; - The Pid registered name of the server</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; server- 서버 의 Pid 등록 이름</target>
        </trans-unit>
        <trans-unit id="8ba0c0aa20ef9eae031396a7362b2436588887b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_name&lt;/code&gt; - The name to register the server under</source>
          <target state="translated">&lt;code&gt;server_name&lt;/code&gt; - 서버를 등록 할 이름</target>
        </trans-unit>
        <trans-unit id="3c518eea11ddca7b2d680df360f5d8403cda7a85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_name&lt;/code&gt; - The registered name of the tracker server</source>
          <target state="translated">&lt;code&gt;server_name&lt;/code&gt; - 추적기 서버의 등록 된 이름</target>
        </trans-unit>
        <trans-unit id="468a0024f46153b84f2646395de16c5687b51120" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_opts&lt;/code&gt; - The list of options to pass to the tracker server</source>
          <target state="translated">&lt;code&gt;server_opts&lt;/code&gt; - 추적기 서버에 전달할 옵션 목록</target>
        </trans-unit>
        <trans-unit id="9f99c928fdd62c94778f35581da024c947615843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;session&lt;/code&gt; - the connection session</source>
          <target state="translated">&lt;code&gt;session&lt;/code&gt; - 연결 세션</target>
        </trans-unit>
        <trans-unit id="1c2caff887e3641f298e723dd4b4026ae8a72bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; - sets the given field in the table to the given value</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; - 테이블의 주어진 필드를 주어진 값으로 설정</target>
        </trans-unit>
        <trans-unit id="969589494be74cc19063eaeaf82923ad34fa3b86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shard&lt;/code&gt; - The shard, for example &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;shard&lt;/code&gt; -샤드 (예 : &lt;code&gt;1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8c60ab2092a1e2475588b6f411dda59ca6bb30a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; - the LiveView socket</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; -LiveView 소켓</target>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 사양 키 에서 응용 프로그램으로 전달되는 인수입니다 (예 &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1befc5d39644d1bc3134d4c35ea706fb5258286c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (for example, &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 사양 키 에서 응용 프로그램에 전달 된 인수입니다 (예 &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 은 응용 프로그램이 시작되는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="35fa3a8f992225f09ede7699a77894f22bf1e585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; - the connection state</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; - 연결 상태</target>
        </trans-unit>
        <trans-unit id="93d5d93af48ac493f86cb5c0f186995d526d56ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; - The reply status as an atom</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; - 아톰으로서의 회신 상태</target>
        </trans-unit>
        <trans-unit id="a653ee9b901321d4e0e464e5acafb89c9db427ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; - the response status</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; - 응답 상태</target>
        </trans-unit>
        <trans-unit id="9a9c2fbae62d06a0662539678563891fb5ef99c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string()&lt;/code&gt; (as a UUID)</source>
          <target state="translated">&lt;code&gt;string()&lt;/code&gt; (UUID로)</target>
        </trans-unit>
        <trans-unit id="705f2e4e2e1ae4604f80f8a3ab30c307d1eed659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subquery&lt;/code&gt; is supported in &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, and &lt;code&gt;where&lt;/code&gt;, in the form &lt;code&gt;p.x in subquery(q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subquery&lt;/code&gt; 는 &lt;code&gt;p.x in subquery(q)&lt;/code&gt; 형식 으로 &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;join&lt;/code&gt; 및 &lt;code&gt;where&lt;/code&gt; 에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb525b4942d6766e450faa45994038bf3ca03dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; - subscribes the given pid to the given topic sends: &lt;code&gt;{:subscribe, pid, topic, opts}&lt;/code&gt; respond with: &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; - 주어진 pid를 주어진 주제에 전송합니다. &lt;code&gt;{:subscribe, pid, topic, opts}&lt;/code&gt; 응답 : &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="025234015f846a4668be839441d90c3e0c97f6f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtype&lt;/code&gt;, the content-type subtype (e.g., &lt;code&gt;&quot;json&quot;&lt;/code&gt; for the &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;subtype&lt;/code&gt; , 내용 유형의 하위 유형 (예를 들어, &lt;code&gt;&quot;json&quot;&lt;/code&gt; 에 대한 &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; 콘텐츠 유형)</target>
        </trans-unit>
        <trans-unit id="b1edaa577016afa1a9b706807612a7bc094252dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table_name&lt;/code&gt; - The name of the local table</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; - 로컬 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="4be0315f043e8f1fa9b565bd0abe60e158adf0ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;te&amp;middot;lem&amp;middot;e&amp;middot;try&lt;/code&gt; - the process of recording and transmitting the readings of an instrument.</source>
          <target state="translated">&lt;code&gt;te&amp;middot;lem&amp;middot;e&amp;middot;try&lt;/code&gt; 기기의 판독 값을 기록하고 전송하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="e29cca9cee2573fbb090c7741c42c557985c4cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; - which may be an atom or a string. If an atom, like &lt;code&gt;:index&lt;/code&gt;, it will render a template with the same format as the one returned by &lt;a href=&quot;#get_format/1&quot;&gt;&lt;code&gt;get_format/1&lt;/code&gt;&lt;/a&gt;. For example, for an HTML request, it will render the &quot;index.html&quot; template. If the template is a string, it must contain the extension too, like &quot;index.json&quot;</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; -원자 또는 문자열 일 수 있습니다. &lt;code&gt;:index&lt;/code&gt; 와 같은 원자의 경우 &lt;a href=&quot;#get_format/1&quot;&gt; &lt;code&gt;get_format/1&lt;/code&gt; 에서&lt;/a&gt; 반환 된 것과 동일한 형식으로 템플릿을 렌더링합니다 . 예를 들어, HTML 요청의 경우 &quot;index.html&quot;템플릿을 렌더링합니다. 템플릿이 문자열 인 경우 &quot;index.json&quot;과 같은 확장자도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="24f5c9dcbba2baa8247f22c33896313396653b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; - which may be an atom or a string. If an atom, like &lt;code&gt;:index&lt;/code&gt;, it will render a template with the same format as the one returned by &lt;a href=&quot;#get_format/1&quot;&gt;&lt;code&gt;get_format/1&lt;/code&gt;&lt;/a&gt;. For example, for an HTML request, it will render the &amp;ldquo;index.html&amp;rdquo; template. If the template is a string, it must contain the extension too, like &amp;ldquo;index.json&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; - 원자 또는 문자열 일 수 있습니다. &lt;code&gt;:index&lt;/code&gt; 와 같은 아톰 인 경우 &lt;a href=&quot;#get_format/1&quot;&gt; &lt;code&gt;get_format/1&lt;/code&gt; 이&lt;/a&gt; 반환 한 것과 같은 형식의 템플릿을 렌더링합니다 . 예를 들어 HTML 요청의 경우 &quot;index.html&quot;템플릿을 렌더링합니다. 템플릿이 문자열 인 경우 &quot;index.json&quot;과 같이 확장명도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="40617c48abbb67b22a917287876283c98cda5471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;terminate/2&lt;/code&gt;, however, won&amp;rsquo;t be invoked in case of errors nor in case of exits. This is the same behaviour as you find in Elixir abstractions like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and others. Typically speaking, if you want to clean something up, it is better to monitor your channel process and do the clean up from another process. Similar to GenServer, it would also be possible &lt;code&gt;:trap_exit&lt;/code&gt; to guarantee that &lt;code&gt;terminate/2&lt;/code&gt; is invoked. This practice is not encouraged though.</source>
          <target state="translated">&lt;code&gt;terminate/2&lt;/code&gt; 그러나 오류가 발생하거나 종료되는 경우 terminate / 2 가 호출되지 않습니다. 이것은 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 및 기타와 같은 Elixir 추상화에서와 동일한 동작 입니다. 일반적으로 무언가를 정리하려면 채널 프로세스를 모니터링하고 다른 프로세스에서 정리하는 것이 좋습니다. GenServer와 유사하게, &lt;code&gt;terminate/2&lt;/code&gt; 가 호출 되도록 보장하는 &lt;code&gt;:trap_exit&lt;/code&gt; 도 가능합니다 . 그러나이 방법은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36a680d7091b1ca241f6dce63dff5aa660ef11d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;terminate/2&lt;/code&gt;, however, won't be invoked in case of errors nor in case of exits. This is the same behaviour as you find in Elixir abstractions like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and others. Typically speaking, if you want to clean something up, it is better to monitor your channel process and do the clean up from another process. Similar to GenServer, it would also be possible &lt;code&gt;:trap_exit&lt;/code&gt; to guarantee that &lt;code&gt;terminate/2&lt;/code&gt; is invoked. This practice is not encouraged though.</source>
          <target state="translated">&lt;code&gt;terminate/2&lt;/code&gt; 그러나 terminate / 2 는 오류나 종료시 호출되지 않습니다. 이것은 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 및 기타와 같은 Elixir 추상화에서 볼 수있는 것과 동일한 동작 입니다. 일반적으로 무언가를 정리하려면 채널 프로세스를 모니터링하고 다른 프로세스에서 정리하는 것이 좋습니다. GenServer와 유사하게, &lt;code&gt;terminate/2&lt;/code&gt; 가 호출 되도록 보장하기 위해 &lt;code&gt;:trap_exit&lt;/code&gt; 도 가능합니다 . 하지만이 방법은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bad0009e8b2606979a22152f77f7f53217f2b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; - a directory with all of our application tests. It often mirrors the same structure found in &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; - 모든 애플리케이션 테스트가있는 디렉토리. 종종 &lt;code&gt;lib&lt;/code&gt; 에 있는 것과 동일한 구조를 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="67950da0b6afe6e6fe65e5fd50ec29a1f1b09807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text_filter&lt;/code&gt; - The text to further filter the element</source>
          <target state="translated">&lt;code&gt;text_filter&lt;/code&gt; - 요소를 추가로 필터링 할 텍스트</target>
        </trans-unit>
        <trans-unit id="9e855ced77c34f3098976240974358faddd93281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;through&lt;/code&gt; - The through associations</source>
          <target state="translated">&lt;code&gt;through&lt;/code&gt; -협회를 통해</target>
        </trans-unit>
        <trans-unit id="03b0edaaf74d039e9dba4da8b7f2b59a45942944" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time_diff&lt;/code&gt; is an integer representing the time it took to execute the instrumented function &lt;strong&gt;in native units&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;time_diff&lt;/code&gt; 는 계측 된 함수 &lt;strong&gt;를 기본 단위&lt;/strong&gt; 로 실행하는 데 걸린 시간을 나타내는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="1ee719ca0cf2a2f8c0cf5080f44ff4dbd99aeb9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - &lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 의&lt;/a&gt; 주제</target>
        </trans-unit>
        <trans-unit id="513bfa6e57effcfca4a3772c43a797cf30762ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 이 존재에 대한 &lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; 주제</target>
        </trans-unit>
        <trans-unit id="b4e43962e773022e68cf2010c40617e7736b0193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic to untrack for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - &lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 의&lt;/a&gt; 이 존재 untrack에 대한 주제</target>
        </trans-unit>
        <trans-unit id="f650123c92c7ad8edc76f65a3e935e24ebc774ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic to update for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 이 존재를 위해 업데이트 할 &lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; 주제</target>
        </trans-unit>
        <trans-unit id="b56ea91d6b7462453b3977d65c982fb652cd6ceb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic or topic:subtopic pair namespace, for example &amp;ldquo;messages&amp;rdquo;, &amp;ldquo;messages:123&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 문자열 주제 또는 topic : subtopic 쌍 네임 스페이스 (예 :&amp;ldquo;messages&amp;rdquo;,&amp;ldquo;messages : 123&amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="62ca51cf60a4e7f5b9da63e0397a88e8ad88609c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic, for example &amp;ldquo;users:123&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 문자열 주제 (예 : &quot;users : 123&quot;)</target>
        </trans-unit>
        <trans-unit id="e2064db7041ede42a88b29d1726530a1b5b8d6ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic, for example &lt;code&gt;&quot;room:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 문자열 주제 (예 &lt;code&gt;&quot;room:123&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edf299c5dbeef14f8b8c536496bbd0431d856fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The topic to broadcast to, ie: &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 브로드 캐스트 할 주제입니다 (예 : &lt;code&gt;&quot;users:123&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="894ba3ea473520823628d4e2116154bf7205e0f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The topic to subscribe to, for example: &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 구독 할 주제 (예 : &lt;code&gt;&quot;users:123&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f027e260bd6880e4c8d9c4ea1a35a185186f4f8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic_pattern&lt;/code&gt; - The string pattern, for example &amp;ldquo;room:&lt;em&gt;&amp;ldquo;, &amp;ldquo;users:&lt;/em&gt;&amp;rdquo;, &amp;ldquo;system&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic_pattern&lt;/code&gt; - 문자열 패턴 (예 : &lt;em&gt;&quot;&lt;/em&gt; room : &lt;em&gt;&quot;, &quot;users :&lt;/em&gt; &quot;, &quot;system&quot;)</target>
        </trans-unit>
        <trans-unit id="2b0455a9d341c92f8f02bcd81fcde1839f019225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic_pattern&lt;/code&gt; - The string pattern, for example &lt;code&gt;&quot;room:*&quot;&lt;/code&gt;, &lt;code&gt;&quot;users:*&quot;&lt;/code&gt;, or &lt;code&gt;&quot;system&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic_pattern&lt;/code&gt; - 문자열 패턴 (예 &lt;code&gt;&quot;room:*&quot;&lt;/code&gt; , &lt;code&gt;&quot;users:*&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;system&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5bf1f400268378a94a0377161a93e52059884fd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker&lt;/code&gt; - The name of the tracker handler module implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour</source>
          <target state="translated">&lt;code&gt;tracker&lt;/code&gt; - &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 동작을 구현하는 추적기 핸들러 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="51127dc0e8ed50c2e4ac714b42eb9545ead7bc45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker&lt;/code&gt; - The name of the tracker handler module implementing the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour</source>
          <target state="translated">&lt;code&gt;tracker&lt;/code&gt; - &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 동작을 구현하는 추적기 핸들러 모듈의 이름</target>
        </trans-unit>
        <trans-unit id="77cebe9e072f836bf905c4ed2b9563d461835f10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker_opts&lt;/code&gt; - The list of options to pass to the tracker handler</source>
          <target state="translated">&lt;code&gt;tracker_opts&lt;/code&gt; - 추적기 핸들러에 전달할 옵션 목록</target>
        </trans-unit>
        <trans-unit id="fe9158957cb6b89c0989ca69bb67857bd1251d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport&lt;/code&gt; - The socket&amp;rsquo;s transport, for example: &lt;a href=&quot;phoenix.transports.websocket&quot;&gt;&lt;code&gt;Phoenix.Transports.WebSocket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;transport&lt;/code&gt; - 소켓의 전송 (예 : &lt;a href=&quot;phoenix.transports.websocket&quot;&gt; &lt;code&gt;Phoenix.Transports.WebSocket&lt;/code&gt; )&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52c7d5d6612d5c389b1ae03d18193b2b2c4a4a63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_name&lt;/code&gt; - The socket&amp;rsquo;s transport, for example: &lt;code&gt;:websocket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;transport_name&lt;/code&gt; - 소켓의 전송 (예 : &lt;code&gt;:websocket&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d4e0128be65ba382ba951e0aeb79f0f7de5fa4b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_pid&lt;/code&gt; - The pid of the socket&amp;rsquo;s transport process</source>
          <target state="translated">&lt;code&gt;transport_pid&lt;/code&gt; - 소켓의 전송 프로세스의 pid</target>
        </trans-unit>
        <trans-unit id="a4f127cc373d7b32f78f8038b43cccc790509f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt;, the content-type type (e.g., &lt;code&gt;&quot;x-sample&quot;&lt;/code&gt; for the &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 콘텐츠 타입 타입 (예를 들면, &lt;code&gt;&quot;x-sample&quot;&lt;/code&gt; 위한 &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; 콘텐츠 - 타입)</target>
        </trans-unit>
        <trans-unit id="062d04ecaa276f6909e2313139f4ce94130c6e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;types&lt;/code&gt; - Cache of the data&amp;rsquo;s field types</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; - 데이터의 필드 유형의 캐시</target>
        </trans-unit>
        <trans-unit id="c8b50124a73354ee02cfe1c5ba6e0f181090027f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;types&lt;/code&gt; - Cache of the data's field types</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; - 데이터의 필드 유형의 캐시</target>
        </trans-unit>
        <trans-unit id="713f014d797ed832327c6a83bf5c270ceefef5a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsubscribe&lt;/code&gt; - unsubscribes the given pid from the given topic sends: &lt;code&gt;{:unsubscribe, pid, topic}&lt;/code&gt; respond with: &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; -주어진 주제에서 지정된 pid를 구독 취소합니다. &lt;code&gt;{:unsubscribe, pid, topic}&lt;/code&gt; 응답 : &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래에 저장 될 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="d5c8c2d6ab1b22d38f2b49bfcf2e2126f69250a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updated&lt;/code&gt; - the element has been updated in the DOM by the server</source>
          <target state="translated">&lt;code&gt;updated&lt;/code&gt; -요소가 서버에 의해 DOM에서 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 은 &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백에 대한 기본 구현을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f029332e3f810fd92d38f3083e897e8184ebdd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct and expects the time zone to be set to UTC.</source>
          <target state="translated">&lt;code&gt;utc_datetime&lt;/code&gt; - 초 단위의 정밀도를 가지며 값을 Elixir의 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 구조체로 캐스트 하고 시간대가 UTC로 설정 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="a9f39c1df4afb4b9ab024f8cb6f1c062713a2335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime&lt;/code&gt; - has a precision of seconds and casts values to to Elixir&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct and expects the time zone to be set to UTC.</source>
          <target state="translated">&lt;code&gt;utc_datetime&lt;/code&gt; - 초의 정밀도를 가지며 값을 Elixir의 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 구조체 로 캐스트 하고 시간대가 UTC로 설정 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="e9e1e45943bf4766719c1bda7724db4c7eb55ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime_usec&lt;/code&gt; has a default precision of microseconds and also casts values to &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; expecting the time zone be set to UTC.</source>
          <target state="translated">&lt;code&gt;utc_datetime_usec&lt;/code&gt; 의 기본 정밀도는 마이크로 초이며 표준 시간대가 UTC로 설정 될 것으로 예상하는 값을 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 으로&lt;/a&gt; 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="6428f4d916f7c3da2df5ccc59cbddf4233c65f59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;valid?&lt;/code&gt; - Stores if the changeset is valid</source>
          <target state="translated">&lt;code&gt;valid?&lt;/code&gt; -변경 세트가 유효한 경우 저장</target>
        </trans-unit>
        <trans-unit id="5a9362538e127041a217667b8c0f8856c71d7d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;viewName&lt;/code&gt; - attribute matching the DOM node's phx-view value</source>
          <target state="translated">&lt;code&gt;viewName&lt;/code&gt; -DOM 노드의 phx-view 값과 일치하는 속성</target>
        </trans-unit>
        <trans-unit id="800dbbe2d2fe1d80d14941fd47d688d0a838a2e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vsn&lt;/code&gt; - The protocol version of the client, for example: &amp;ldquo;2.0.0&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;vsn&lt;/code&gt; - 클라이언트의 프로토콜 버전 (예 :&amp;ldquo;2.0.0&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bec0997386133df0de916bdcffadd8ddf31241c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; also accepts a keyword list where the field given as key is going to be compared with the given value. The fields will always refer to the source given in &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 키로 제공된 필드가 주어진 값과 비교 될 키워드 목록도 허용합니다. 필드는 항상 &lt;code&gt;from&lt;/code&gt; 제공된 소스를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="e963437caf7417e9123875fd4e9fceb427d7fad7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; expressions are used to filter the result set. If there is more than one where expression, they are combined with an &lt;code&gt;and&lt;/code&gt; operator. All where expressions have to evaluate to a boolean value.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 표현식은 결과 집합을 필터링하는 데 사용됩니다. where식이 둘 이상 있으면 &lt;code&gt;and&lt;/code&gt; 연산자 와 결합됩니다 . 모든 표현식이 부울 값으로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5bdcde824f497b1ae0d2fe1777d38d65f7add27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; and a &lt;code&gt;join&lt;/code&gt;&amp;rsquo;s `on&amp;rsquo;</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; , &lt;code&gt;having&lt;/code&gt; 와는 &lt;code&gt;join&lt;/code&gt; '에's '를</target>
        </trans-unit>
        <trans-unit id="713294ed2c5afa2c740c2785661ab1cfeb397890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; and a &lt;code&gt;join&lt;/code&gt;'s `on'</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; , &lt;code&gt;having&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 'on'</target>
        </trans-unit>
        <trans-unit id="c607056e1afb24aa096d965e0f605e009e055a4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-content-type-options&lt;/code&gt; - set to nosniff. This requires script and style tags to be sent with proper content type</source>
          <target state="translated">&lt;code&gt;x-content-type-options&lt;/code&gt; - nosniff로 설정합니다. 이를 위해서는 스크립트 및 스타일 태그가 적절한 콘텐츠 유형과 함께 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a091a58cd8a1c6400461dafc74edd2c7171ea32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-download-options&lt;/code&gt; - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)</source>
          <target state="translated">&lt;code&gt;x-download-options&lt;/code&gt; - HTML 파일이 인라인으로 렌더링되고 애플리케이션의 보안 컨텍스트 (예 : 중요한 도메인 쿠키)에 액세스하지 않도록 브라우저에서 다운로드를 직접 열지 않도록 브라우저에 지시하려면 noopen으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d50fef96676e9c72ddc82a4a9d7987f6ee849c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-frame-options&lt;/code&gt; - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin</source>
          <target state="translated">&lt;code&gt;x-frame-options&lt;/code&gt; options-동일한 출처가 아닌 경우 iframe을 통한 클릭 재킹을 방지하려면 SAMEORIGIN으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0031b6ee0f819de850592207a859181426da60b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-permitted-cross-domain-policies&lt;/code&gt; - set to none to restrict Adobe Flash Player&amp;rsquo;s access to data</source>
          <target state="translated">&lt;code&gt;x-permitted-cross-domain-policies&lt;/code&gt; - 데이터에 대한 Adobe Flash Player의 액세스를 제한하려면 none으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d7892c834608e4e5db30616a441a1a0aa13e72d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-xss-protection&lt;/code&gt; - set to &quot;1; mode=block&quot; to improve XSS protection on both Chrome and IE</source>
          <target state="translated">&lt;code&gt;x-xss-protection&lt;/code&gt; - Chrome과 IE 모두에서 XSS 보호를 향상 시키려면 &quot;1; mode = block&quot;으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6011c602d9c8c976b96c14f349f4591db71f2bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, :too_large, conn}&lt;/code&gt; if the request goes over the given limit</source>
          <target state="translated">&lt;code&gt;{:error, :too_large, conn}&lt;/code&gt; 요청이 주어진 제한을 초과하면 {: error, : too_large, conn}</target>
        </trans-unit>
        <trans-unit id="ff1cb34c75e3cf8ae6970e904169f2b701f48c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason, reply}&lt;/code&gt; - An error occurred and the reply must be sent as result</source>
          <target state="translated">&lt;code&gt;{:error, reason, reply}&lt;/code&gt; -오류가 발생했으며 결과로 회신을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; - 응용 프로그램이 배포되고 있기 때문에 노드에 장애 조치의 현재 노드에서 시작되는 경우에 사용 &lt;code&gt;node&lt;/code&gt; , 응용 프로그램 사양 키 &lt;code&gt;:start_phases&lt;/code&gt; 은 아니다 &lt;code&gt;:undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c84184adc130a442aeee883a22d84dae1d9d3a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fragment, expr}&lt;/code&gt; - which specifies a fragment string as the filter (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) with the field's value given to it as the only argument</source>
          <target state="translated">&lt;code&gt;{:fragment, expr}&lt;/code&gt; - 필드의 값이 유일한 인수로 지정된 필터로 조각 문자열을 지정합니다 ( &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cb3a98608ab0606cfccacc4b8d59a3aa25d84052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:in, list}&lt;/code&gt; - which specifies the field must be one of the values in a list</source>
          <target state="translated">&lt;code&gt;{:in, list}&lt;/code&gt; -필드가 목록의 값 중 하나 여야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="062660b1e65ffc26be85526ef4749cafef267adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:joined, channel_pid, reply}&lt;/code&gt; - The channel was joined and the reply must be sent as result</source>
          <target state="translated">&lt;code&gt;{:joined, channel_pid, reply}&lt;/code&gt; -채널에 가입했으며 결과로 답장을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="905c7b552a0a3f84ecae4b26e5f03fcfdb35c892" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:next, conn}&lt;/code&gt; if the next parser should be invoked</source>
          <target state="translated">&lt;code&gt;{:next, conn}&lt;/code&gt; 다음 구문 분석기를 호출해야하는 경우 {: next, conn}</target>
        </trans-unit>
        <trans-unit id="17faa2644282a117df8deb0b5b5b5e18fcfd3222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:not, nil}&lt;/code&gt; - which specifies the field must not be nil</source>
          <target state="translated">&lt;code&gt;{:not, nil}&lt;/code&gt; -필드가 nil이 아니어야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a9f3a07e7cb34d66220a5536ba35d5dfd70ba87b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, body_params, conn}&lt;/code&gt; if the parser is able to handle the given content-type; &lt;code&gt;body_params&lt;/code&gt; should be a map</source>
          <target state="translated">&lt;code&gt;{:ok, body_params, conn}&lt;/code&gt; 파서가 주어진 컨텐츠 유형을 처리 할 수있는 경우 {: ok, body_params, conn} ; &lt;code&gt;body_params&lt;/code&gt; 는 맵이어야합니다</target>
        </trans-unit>
        <trans-unit id="1113731703331bd1d15a150da69e718c748007c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, state}&lt;/code&gt; - continues the socket with no reply</source>
          <target state="translated">&lt;code&gt;{:ok, state}&lt;/code&gt; -응답없이 소켓 계속</target>
        </trans-unit>
        <trans-unit id="af57bcf2b2958150c93d64000a61a51313730a9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, type, subtype, map_of_params}&lt;/code&gt; if everything goes fine</source>
          <target state="translated">&lt;code&gt;{:ok, type, subtype, map_of_params}&lt;/code&gt; 모든 것이 잘되면 {: ok, type, subtype, map_of_params}</target>
        </trans-unit>
        <trans-unit id="4ec082e3567953282fbd04048fb57421c37cee80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:push, reply, state}&lt;/code&gt; - continues the socket with reply</source>
          <target state="translated">&lt;code&gt;{:push, reply, state}&lt;/code&gt; -응답으로 소켓 계속</target>
        </trans-unit>
        <trans-unit id="09123fe74ae8c7bd7d51f4f56a6c5fae42afdbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace, fields}&lt;/code&gt; - replace only specific columns. This option requires &lt;code&gt;:conflict_target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:replace, fields}&lt;/code&gt; -특정 열만 교체합니다. 이 옵션에는 &lt;code&gt;:conflict_target&lt;/code&gt; 이 필요합니다 . : conflict_target</target>
        </trans-unit>
        <trans-unit id="b215e61c191074394dbf923bb41775a8fa5ada4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace, fields}&lt;/code&gt; - replace only specific columns. This option requires conflict_target</source>
          <target state="translated">&lt;code&gt;{:replace, fields}&lt;/code&gt; -특정 열만 바꿉니다. 이 옵션에는 conflict_target이 필요합니다</target>
        </trans-unit>
        <trans-unit id="2423076ca328831d0e7e9294dc0b46567732aed9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace_all_except, fields}&lt;/code&gt; - same as above except the given fields are not replaced. This option requires a schema</source>
          <target state="translated">&lt;code&gt;{:replace_all_except, fields}&lt;/code&gt; -주어진 필드가 대체되지 않는다는 점을 제외하면 위와 동일합니다. 이 옵션에는 스키마가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6b48052644bac2fb11ba3eccfa5fdff9e19af9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:reply, reply}&lt;/code&gt; - The reply to be sent to the client</source>
          <target state="translated">&lt;code&gt;{:reply, reply}&lt;/code&gt; -고객에게 보낼 답장</target>
        </trans-unit>
        <trans-unit id="c60dbc36cfe28a4ec203e872e06ba60411705be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:reply, status, reply, state}&lt;/code&gt; - continues the socket with reply</source>
          <target state="translated">&lt;code&gt;{:reply, status, reply, state}&lt;/code&gt; -응답과 함께 소켓 계속</target>
        </trans-unit>
        <trans-unit id="c33ebebf91abd6f69c095b828bb5a73be4ab23ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:session, session_config}&lt;/code&gt; - the session information from &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;session_config&lt;/code&gt; is an exact copy of the arguments given to &lt;a href=&quot;../plug/plug.session&quot;&gt;&lt;code&gt;Plug.Session&lt;/code&gt;&lt;/a&gt;. This requires the &quot;_csrf_token&quot; to be given as request parameter with the value of &lt;code&gt;URI.encode_www_form(Plug.CSRFProtection.get_csrf_token())&lt;/code&gt; when connecting to the socket. It can also be a MFA to allow loading config in runtime &lt;code&gt;{MyAppWeb.Auth, :get_session_config, []}&lt;/code&gt;. Otherwise the session will be &lt;code&gt;nil&lt;/code&gt;. Arbitrary keywords may also appear following the above valid keys, which is useful for passing custom connection information to the socket. For example: socket &quot;/socket&quot;, AppWeb.UserSocket, websocket: [</source>
          <target state="translated">&lt;code&gt;{:session, session_config}&lt;/code&gt; &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 의 세션 정보입니다 . &lt;code&gt;session_config&lt;/code&gt; 은 주어진 인수의 정확한 사본입니다 &lt;a href=&quot;../plug/plug.session&quot;&gt; &lt;code&gt;Plug.Session&lt;/code&gt; &lt;/a&gt; . 이렇게하려면 소켓에 연결할 때 &lt;code&gt;URI.encode_www_form(Plug.CSRFProtection.get_csrf_token())&lt;/code&gt; 값과 함께 요청 매개 변수로 &quot;_csrf_token&quot;을 제공 해야합니다. 또한 런타임 &lt;code&gt;{MyAppWeb.Auth, :get_session_config, []}&lt;/code&gt; 에서 구성로드를 허용하는 MFA 일 수 있습니다 . 그렇지 않으면 세션은 &lt;code&gt;nil&lt;/code&gt; 이 됩니다. 임의의 키워드가 위의 유효한 키 뒤에 나타날 수도 있으며, 이는 사용자 지정 연결 정보를 소켓에 전달하는 데 유용합니다. 예 : socket &quot;/ socket&quot;, AppWeb.UserSocket, websocket : [</target>
        </trans-unit>
        <trans-unit id="28f6d0aa05a90f073bac9010871ba07c79ec5ed5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:stop, reason, state}&lt;/code&gt; - stops the socket</source>
          <target state="translated">&lt;code&gt;{:stop, reason, state}&lt;/code&gt; -소켓 중지</target>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -응용 프로그램이 배포되고 노드 &lt;code&gt;node&lt;/code&gt; 의 장애 조치로 인해 현재 노드에서 시작된 경우 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="94add01753d5f0af3e82d4a2cf547589069cba4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE:&lt;/em&gt; Make sure you've read the &lt;a href=&quot;assigns-eex&quot;&gt;Assigns and LiveEEx templates&lt;/a&gt; guide before moving forward.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 진행하기 전에 &lt;a href=&quot;assigns-eex&quot;&gt;Assigns 및 LiveEEx 템플릿&lt;/a&gt; 가이드를 읽었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="27bbd69bf6fe8a187def7224a56685257b153244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This feature depends on the internals of Cowboy 1.0 API and how it integrates with Phoenix. Those may change at &lt;em&gt;any time&lt;/em&gt;, without backwards compatibility, specifically when Cowboy 2.0 is released.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; :이 기능은 Cowboy 1.0 API의 내부 및 Phoenix와의 통합 방법에 따라 다릅니다. 이전 버전과의 호환성없이, 특히 Cowboy 2.0이 출시 될 때 &lt;em&gt;언제든지&lt;/em&gt; 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f88b0db28d31a4e9cf8dfc8eb5f3b6931d4a763" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This feature depends on the internals of Cowboy 1.0 API and how it integrates with Phoenix. Those may change at &lt;em&gt;any time&lt;/em&gt;, without backwards compatibility.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; :이 기능은 Cowboy 1.0 API의 내부 및 Phoenix와 통합되는 방식에 따라 다릅니다. 이전 버전과의 호환성없이 &lt;em&gt;언제든지&lt;/em&gt; 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbe2088f6f79d4966a5e5be72bf95f44681f6fd4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; the above assumes there is &lt;code&gt;plug :put_root_layout&lt;/code&gt; call in your router that configures the LiveView layout. This call is automatically included by &lt;code&gt;mix phx.new --live&lt;/code&gt; and described in the installation guide. If you don't want to configure a root layout, you must pass &lt;code&gt;layout: {MyAppWeb.LayoutView, &quot;app.html&quot;}&lt;/code&gt; as an option to the &lt;code&gt;live&lt;/code&gt; macro above.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 위의 내용은 LiveView 레이아웃을 구성하는 라우터에 &lt;code&gt;plug :put_root_layout&lt;/code&gt; 호출 이 있다고 가정 합니다. 이 호출은 &lt;code&gt;mix phx.new --live&lt;/code&gt; 에 의해 자동으로 포함되며 설치 가이드에 설명되어 있습니다. 루트 레이아웃을 구성하지 않으려면 위 의 &lt;code&gt;live&lt;/code&gt; 매크로에 대한 옵션으로 &lt;code&gt;layout: {MyAppWeb.LayoutView, &quot;app.html&quot;}&lt;/code&gt; 을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c5eb8339e35e619d28e1600159a8638879a94c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: If you find yourself needing to dynamically patch other parts of the base layout, such as injecting new scripts or styles into the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; during live navigation, &lt;em&gt;then a regular, non-live, page navigation should be used instead&lt;/em&gt;. Assigning the &lt;code&gt;@page_title&lt;/code&gt; updates the &lt;code&gt;document.title&lt;/code&gt; directly, and therefore cannot be used to update any other part of the base layout.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 라이브 탐색 중에 새 스크립트 또는 스타일을 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 에 삽입하는 것과 같이 기본 레이아웃의 다른 부분을 동적으로 패치 &lt;em&gt;해야하는 경우에는 대신 일반 비 라이브 페이지 탐색을 사용해야합니다&lt;/em&gt; . &lt;code&gt;@page_title&lt;/code&gt; 을 할당하면 &lt;code&gt;document.title&lt;/code&gt; 이 직접 업데이트 되므로 기본 레이아웃의 다른 부분을 업데이트하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2808c210a7f7d14573dceaa04938aca641e0452d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In such cases, a &lt;code&gt;socket_ref&lt;/code&gt; should be generated and passed to the external process, so the &lt;code&gt;socket&lt;/code&gt; itself is not leaked outside the channel. The &lt;code&gt;socket&lt;/code&gt; holds information such as assigns and transport configuration, so it&amp;rsquo;s important to not copy this information outside of the channel that owns it.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 그러한 경우 &lt;code&gt;socket_ref&lt;/code&gt; 가 생성되어 외부 프로세스로 전달되어야하므로 &lt;code&gt;socket&lt;/code&gt; 자체가 채널 외부로 누출되지 않습니다. &lt;code&gt;socket&lt;/code&gt; 그것을 소유하는 채널의이 정보를 외부에 복사하지하는 것이 중요하므로, 이러한 할당하고 전송 구성 등의 정보를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="13d6b2e1abd760c9dc2a4bb9d197a15886553be1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In such cases, a &lt;code&gt;socket_ref&lt;/code&gt; should be generated and passed to the external process, so the &lt;code&gt;socket&lt;/code&gt; itself is not leaked outside the channel. The &lt;code&gt;socket&lt;/code&gt; holds information such as assigns and transport configuration, so it's important to not copy this information outside of the channel that owns it.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 이러한 경우 &lt;code&gt;socket_ref&lt;/code&gt; 를 생성하여 외부 프로세스로 전달해야 &lt;code&gt;socket&lt;/code&gt; 자체가 채널 외부로 유출되지 않습니다. &lt;code&gt;socket&lt;/code&gt; 그것을 소유하는 채널의이 정보를 외부에 복사하지하는 것이 중요하므로, 이러한 할당하고 전송 구성 등의 정보를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="416a2feb44d7d80ca93d06445e0f0d6695814482" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: LiveView redirects rely on instructing client to perform a &lt;code&gt;window.location&lt;/code&gt; update on the provided redirect location. The whole page will be reloaded and all state will be discarded.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : LiveView 리디렉션은 제공된 리디렉션 위치에서 &lt;code&gt;window.location&lt;/code&gt; 업데이트 를 수행하도록 클라이언트에 지시하는 데 의존합니다 . 전체 페이지가 다시로드되고 모든 상태가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="689867568d0b83836769c6639adde50a32fff317" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: The live layout is always wrapped by the LiveView's &lt;code&gt;:container&lt;/code&gt; tag.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 라이브 레이아웃은 항상 LiveView의 &lt;code&gt;:container&lt;/code&gt; 태그로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9f18d44220f56045e84bb12ec592e03d17051f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: The token is deleted only after a response has been sent.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 토큰은 응답이 전송 된 후에 만 ​​삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c83f347ad9b455d3ad455e2be7b3168749ae9553" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: While you can use &lt;a href=&quot;#put_flash/3&quot;&gt;&lt;code&gt;put_flash/3&lt;/code&gt;&lt;/a&gt; inside a &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt;, components have their own &lt;code&gt;@flash&lt;/code&gt; assigns. The &lt;code&gt;@flash&lt;/code&gt; assign in a component is only copied to its parent LiveView if the component calls &lt;a href=&quot;#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 사용할 수 있지만 &lt;a href=&quot;#put_flash/3&quot;&gt; &lt;code&gt;put_flash/3&lt;/code&gt; 을&lt;/a&gt; 돌며 &lt;a href=&quot;phoenix.livecomponent&quot;&gt; &lt;code&gt;Phoenix.LiveComponent&lt;/code&gt; &lt;/a&gt; , 구성 요소는 자신이 &lt;code&gt;@flash&lt;/code&gt; 의 양수인. 구성 요소 의 &lt;code&gt;@flash&lt;/code&gt; 할당은 구성 요소가 &lt;a href=&quot;#push_redirect/2&quot;&gt; &lt;code&gt;push_redirect/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; 를&lt;/a&gt; 호출하는 경우에만 상위 LiveView에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="51c66fe47c0b7a6becc905dbb63cc3eec67f4303" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: You must also place the &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt;&lt;/a&gt; plug in your browser's pipeline in place of &lt;code&gt;fetch_flash&lt;/code&gt; to be supported, for example:</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;fetch_flash&lt;/code&gt; 대신 Phoenix.LiveView.Router.fetch_live_flash &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt; &lt;/a&gt; 플러그를 브라우저의 파이프 라인에 배치 해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="425130fd13ec208a7e979100759f959622e8601b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: events pushed from the server via &lt;code&gt;push_event&lt;/code&gt; are global and will be dispatched to all active hooks on the client who are handling that event.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;push_event&lt;/code&gt; 를 통해 서버에서 푸시 된 이벤트 는 전역 적이며 해당 이벤트를 처리하는 클라이언트의 모든 활성 후크로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b652c457ecb4e96144d6d341db4cccb9992577" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: events will be dispatched to all active hooks on the client who are handling the given &lt;code&gt;event&lt;/code&gt;. Scoped events can be achieved by namespacing your event names.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 이벤트는 주어진 &lt;code&gt;event&lt;/code&gt; 처리하는 클라이언트의 모든 활성 후크로 전달됩니다 . 범위가 지정된 이벤트는 이벤트 이름을 네임 스페이스로 지정하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b3a3429c330d8a5bc256900671e64cce2552d03" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: intercepting events can introduce significantly more overhead if a large number of subscribers must customize a message since the broadcast will be encoded N times instead of a single shared encoding across all subscribers.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 브로드 캐스트가 모든 가입자의 단일 공유 인코딩 대신 N 번 인코딩되므로 많은 수의 가입자가 메시지를 사용자 정의해야하는 경우 인터셉트 이벤트로 인해 더 많은 오버 헤드가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c693c0d232226e41f03629572986788a6d71a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: when using &lt;code&gt;phx-hook&lt;/code&gt;, a unique DOM ID must always be set.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;phx-hook&lt;/code&gt; 을 사용할 때는 항상 고유 한 DOM ID를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76786bc8f27ef8b9694e60a85180adc54c43e8c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reminder&lt;/em&gt;: &lt;a href=&quot;../phoenix_html/phoenix.html.form#form_for/3&quot;&gt;&lt;code&gt;form_for/3&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; helper. Don't forget to include &lt;code&gt;use Phoenix.HTML&lt;/code&gt; at the top of your LiveView, if using &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; helpers. Also, if using &lt;code&gt;error_tag/2&lt;/code&gt;, don't forget to &lt;code&gt;import MyAppWeb.ErrorHelpers&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;알림&lt;/em&gt; : &lt;a href=&quot;../phoenix_html/phoenix.html.form#form_for/3&quot;&gt; &lt;code&gt;form_for/3&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 도우미입니다. &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 도우미를 사용하는 경우 LiveView 상단에 &lt;code&gt;use Phoenix.HTML&lt;/code&gt; 을 포함 하는 것을 잊지 마십시오 . 또한 &lt;code&gt;error_tag/2&lt;/code&gt; 를 사용하는 경우 MyAppWeb.ErrorHelpers 를 &lt;code&gt;import MyAppWeb.ErrorHelpers&lt;/code&gt; 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0635c4e59f4ac617f91b3e1be5ccfef68e754d43" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1&lt;/small&gt; 플러그 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4da554e7fe1ec57273ea1d33e2f985b69b05a763" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Builder</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Builder</target>
        </trans-unit>
        <trans-unit id="aa42a1adde8a113e02082dae9533f8561225479f" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRFProtection</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRF 보호</target>
        </trans-unit>
        <trans-unit id="264d7cf86d36ea1be2d233f002d900f20b56006f" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1fe748d2262322cb6cbbd6a03a57b51dcad38f37" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1&lt;/small&gt; Plug.Conn</target>
        </trans-unit>
        <trans-unit id="80fcb6333504bf0e1c7f39339725ea605e61734a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Adapter &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1 Plug.Conn.&lt;/small&gt; 어댑터 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="55c898df50a7c928eda926b82ee44dddd7399876" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.AlreadySentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.AlreadySentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e57bd4797c634a8b9dcf71208edb3d67d104ebaa" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.InvalidHeaderError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.InvalidHeaderError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="63331bcc1835611faf672f2959fdecfd4d5c1daf" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Status</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1 플러그 연결&lt;/small&gt; 상태</target>
        </trans-unit>
        <trans-unit id="905f6e7e3b764e49f9967706b405db035388994e" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Unfetched</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Unfetched</target>
        </trans-unit>
        <trans-unit id="dc9f8cb59dacff68156a99ef05d7414dbe6e373e" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Debugger</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1 플러그.&lt;/small&gt; 디버거</target>
        </trans-unit>
        <trans-unit id="60949a24623a399ffc2370b8da9591869ed80c75" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.ErrorHandler</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.ErrorHandler</target>
        </trans-unit>
        <trans-unit id="bbbe09eb8f97d63b6fb2a2e21735d0d6f60d70f2" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Logger</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Logger</target>
        </trans-unit>
        <trans-unit id="d57575107f5b55d343939df8f1e7eca100ff5c53" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="55a10e3ffa87078e1efb41a31b592e500583e202" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.JSON</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.JSON</target>
        </trans-unit>
        <trans-unit id="f47a6c54600a9ee120ba5e2ba162b895bda1e8bd" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.MULTIPART</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.MULTIPART</target>
        </trans-unit>
        <trans-unit id="0d4b80fe55addaa628fa41bbda2b51fd8a5fb4ff" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.ParseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c8643c6cc94e9185394ccd9f5c37bfaa0cdee2a4" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.RequestTooLargeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.RequestTooLargeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c8a390ef6b10c8e069846b17065d5b6fa0054039" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.URLENCODED</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.URLENCODED</target>
        </trans-unit>
        <trans-unit id="15e5ec3b84994d33f555bd33d4116ed203a3649c" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c0c2f15abfc84dbe3965a6fc4b9842b962090e1b" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Router</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1 플러그&lt;/small&gt; 라우터</target>
        </trans-unit>
        <trans-unit id="432cb22acb7925383544c23b6916eb4d5c0aabab" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Upload</source>
          <target state="translated">&lt;small&gt;플러그 v1.7.1 플러그&lt;/small&gt; 업로드</target>
        </trans-unit>
        <trans-unit id="9e9d66999fd6756aa9f9cb7d7324b3476d436574" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DO NOT&lt;/strong&gt; use this function if you wish to broadcast to the current node, as it is always serialized, use &lt;a href=&quot;#local_broadcast/4&quot;&gt;&lt;code&gt;local_broadcast/4&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;현재 노드에 브로드 캐스트하려면이 함수를 사용 &lt;strong&gt;하지 마십시오.&lt;/strong&gt; 항상 직렬화 &lt;a href=&quot;#local_broadcast/4&quot;&gt; &lt;code&gt;local_broadcast/4&lt;/code&gt; &lt;/a&gt; 대신 local_broadcast / 4를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41f23e5535e3c18658aa43bcf9d416b91c4733a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT!&lt;/strong&gt; Beware of using CTEs. In raw SQL, CTEs can be used as a mechanism to organize queries, but said mechanism has no purpose in Ecto since Ecto queries are composable by definition. In other words, if you need to break a large query into parts, use all of the functionality in Elixir and in this module to structure your code. Furthermore, breaking a query into CTEs can negatively impact performance, as the database may not optimize efficiently across CTEs. The main use case for CTEs in Ecto is to provide recursive definitions, which we outline in the following section. Non-recursive CTEs can often be written as joins or subqueries, which provide better performance.</source>
          <target state="translated">&lt;strong&gt;중대한! &lt;/strong&gt;CTE 사용에주의하십시오. 원시 SQL에서 CTE는 쿼리를 구성하는 메커니즘으로 사용할 수 있지만 Ecto 쿼리는 정의에 따라 구성 할 수 있기 때문에 Ecto에서는 해당 메커니즘이 목적이 없습니다. 즉, 큰 쿼리를 여러 부분으로 나누어야하는 경우 Elixir 및이 모듈의 모든 기능을 사용하여 코드를 구조화하십시오. 또한 쿼리를 CTE로 분할하면 데이터베이스가 CTE 전체에서 효율적으로 최적화되지 않을 수 있으므로 성능에 부정적인 영향을 미칠 수 있습니다. Ecto에서 CTE의 주요 사용 사례는 다음 섹션에서 설명하는 재귀 정의를 제공하는 것입니다. 비재 귀적 CTE는 종종 더 나은 성능을 제공하는 조인 또는 하위 쿼리로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b589139db6d88819986a51bc3d02ac436a6272ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; : 연관 필드를 필터링 할 때 관계에 사용 된 외래 키를 포함해야합니다. 그렇지 않으면 Ecto가 관련 레코드를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b2ad0477449f7a71e16e1afcd84ee9487948a91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important!&lt;/strong&gt; Please use this feature only when strictly necessary, otherwise it is very easy to end-up with large schemas with dozens of different associations polluting your schema and affecting your application performance. For instance, if you are using associations only for different querying purposes, then it is preferable to build and compose queries, rather than defining multiple associations:</source>
          <target state="translated">&lt;strong&gt;중대한! &lt;/strong&gt;이 기능은 꼭 필요한 경우에만 사용하십시오. 그렇지 않으면 스키마를 오염시키고 응용 프로그램 성능에 영향을 미치는 수십 개의 서로 다른 연관이있는 큰 스키마로 쉽게 종료 할 수 있습니다. 예를 들어, 다른 쿼리 목적으로 만 연결을 사용하는 경우 여러 연결을 정의하는 대신 쿼리를 작성하고 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="16620b5f139013681ae6f8a76df54fbcb3c0fa41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; Because event and payload are patterns, they will be matched. This means that if you wish to assert that the received payload is equivalent to an existing variable, you need to pin the variable in the assertion expression.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이벤트 및 페이로드는 패턴이므로 일치합니다. 즉, 수신 된 페이로드가 기존 변수와 동일하다고 주장하려면 어설 션 표현식에서 변수를 고정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d9ae0b945e7e9fc678fd551239242d252c19116" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note this feature is experimental and may be changed or removed in future releases.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 기능은 실험적이며 향후 릴리스에서 변경되거나 제거 될 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bfb26765a6c5a896b8cc0fa69110abf657471932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;, it must be used after &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 모듈을 &lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 경우 Plug.Debugger 다음에 &lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3d8f6162f9e88d04385e9a8ead3a5bb4dcbdec4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt;, only one of them will effectively handle errors. For this reason, it is recommended that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; is used before &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt; and only in particular environments, like &lt;code&gt;:dev&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 모듈을 &lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt; 와 함께 사용하면 그중 하나만 오류를 효과적으로 처리합니다. 이러한 이유로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt; 이전에 사용 하고 &lt;code&gt;:dev&lt;/code&gt; 와 같은 특정 환경에서만 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="712668559f0783d4307835ecbfbbb87be49ac12c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt;, only one of them will effectively handle errors. For this reason, it is recommended that &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; is used before &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt; and only in particular environments, like &lt;code&gt;:dev&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 모듈을 &lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt; 와 함께 사용하면 그 중 하나만 효과적으로 오류를 처리합니다. 이러한 이유로 &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt; 이전에 사용되며 &lt;code&gt;:dev&lt;/code&gt; 와 같은 특정 환경에서만 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9482570896b7c3cca1137460db7a742f49634771" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Phoenix v1.5 comes with built-in support for LiveView apps. Just create your application with &lt;code&gt;mix phx.new my_app --live&lt;/code&gt;. If you are using earlier Phoenix versions or your app already exists, keep on reading.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Phoenix v1.5에는 LiveView 앱에 대한 기본 지원이 제공됩니다. &lt;code&gt;mix phx.new my_app --live&lt;/code&gt; 로 애플리케이션을 만드십시오 . 이전 Phoenix 버전을 사용 중이거나 앱이 이미 존재하는 경우 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="bb4ad858b8596ea7eba578880589b13173617f56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if you want to see form recovery working in development, please make sure to disable live reloading in development by commenting out the LiveReload plug in your &lt;code&gt;endpoint.ex&lt;/code&gt; file or by setting &lt;code&gt;code_reloader: false&lt;/code&gt; in your &lt;code&gt;config/dev.exs&lt;/code&gt;. Otherwise live reloading may cause the current page to be reloaded whenever you restart the server, which will discard all form state.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 개발중인 양식 복구를 보려면 &lt;code&gt;endpoint.ex&lt;/code&gt; 파일 에서 LiveReload 플러그를 주석 처리 하거나 &lt;code&gt;config/dev.exs&lt;/code&gt; 에서 &lt;code&gt;code_reloader: false&lt;/code&gt; 를 설정 하여 개발중인 라이브 다시로드를 비활성화해야합니다 . 그렇지 않으면 라이브 다시로드로 인해 서버를 다시 시작할 때마다 현재 페이지가 다시로드되어 모든 양식 상태가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf568569e74e68cdba50c82d5b1db96640507dd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; only set &lt;code&gt;phx-track-static&lt;/code&gt; on your own assets. For example, do not set it in external JavaScript files:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 자신의 자산 에만 &lt;code&gt;phx-track-static&lt;/code&gt; 을 설정하십시오. 예를 들어 외부 JavaScript 파일에는 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c0d91c61e9d56f0fdcdc183a40c90744c633d092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this functionality requires Phoenix v1.5.2 or later.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능을 사용하려면 Phoenix v1.5.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f296ef2f03398d2799d4e2d331b80c16fad3e8fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;#send_update/2&quot;&gt;&lt;code&gt;send_update/2&lt;/code&gt;&lt;/a&gt; cannot update a LiveComponent that is mounted in a different LiveView. To update a component in a different LiveView you must send a message to the LiveView process that the LiveComponent is mounted within (often via &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;#send_update/2&quot;&gt; &lt;code&gt;send_update/2&lt;/code&gt; &lt;/a&gt; 는 다른 LiveView에 마운트 된 LiveComponent를 업데이트 할 수 없습니다. 다른 라이브 뷰의 구성 요소를 업데이트하려면 당신은 LiveComponent은 (종종 통해 내부에 장착되어있는 라이브 뷰 프로세스에 메시지를 전송해야 &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0767479b021c0de0f302fe86039d02c2ae1fb455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as mentioned in the documentation for &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;:plug&lt;/code&gt; application has to be started in order to upload files and use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 설명서에서 언급 한 바와 같이 : &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;:plug&lt;/code&gt; 응용 프로그램은 파일을 업로드하고 사용하려면 시작해야합니다 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; 의&lt;/a&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="7aa3026c84902e7be059c21f940d107febb0b3d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as mentioned in the documentation for &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;:plug&lt;/code&gt; application has to be started in order to upload files and use the &lt;a href=&quot;plug.upload#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 설명서에서 언급 한 바와 같이 : &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;:plug&lt;/code&gt; 응용 프로그램은 파일을 업로드하고 사용하려면 시작해야합니다 &lt;a href=&quot;plug.upload#content&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; 의&lt;/a&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59391d7d5398eb304cc656f88d0830c5d1c30f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through &lt;a href=&quot;ecto&quot;&gt;the Ecto guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요구 사항&lt;/strong&gt; :이 가이드는 &lt;a href=&quot;ecto&quot;&gt;Ecto 가이드&lt;/a&gt; 를 완료 한 것으로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="d7d6a920b2ee73611590d57c0146b8b0d0874e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through &lt;a href=&quot;request_lifecycle&quot;&gt;the Request life-cycle guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요구 사항&lt;/strong&gt; :이 가이드 &lt;a href=&quot;request_lifecycle&quot;&gt;에서는 요청 수명주기 가이드&lt;/a&gt; 를 완료 한 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="d751ca8d591ad6c6735e33aa779071b43fabe4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through the introductory guides and got a Phoenix application up and running.</source>
          <target state="translated">&lt;strong&gt;요구 사항&lt;/strong&gt; :이 가이드는 입문 가이드를 살펴보고 Phoenix 애플리케이션을 실행하고 있다고 예상합니다.</target>
        </trans-unit>
        <trans-unit id="84ad9da37360c471418cbd7a4f6532031cedec2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The cipher suites were last updated on 2018-JUN-14.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;암호 제품군은 2018 년 6 월 14 일에 마지막으로 업데이트되었습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec27dad402bd53d8520685e4f8f307f07ab67066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: ensure that clients cannot spoof their IP address by including this header in their original request, by filtering such headers in the proxy!</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 프록시에서 이러한 헤더를 필터링하여 클라이언트가 원래 요청에이 헤더를 포함하여 IP 주소를 스푸핑 할 수 없도록하십시오!</target>
        </trans-unit>
        <trans-unit id="23f83bb1796aaae4c795a3fe999b12c9e63b618a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: it is very difficult, if not impossible, to revert the effect of HSTS before the entry stored in the browser expires! Consider using a short &lt;code&gt;:expires&lt;/code&gt; value initially, and increasing it to a large value (e.g. 31536000 seconds for 1 year) after testing.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 브라우저에 저장된 항목이 만료되기 전에 HSTS의 효과를 되 돌리는 것은 불가능하지는 않지만 매우 어렵습니다! 초기에 짧은 &lt;code&gt;:expires&lt;/code&gt; 값을 사용하고 테스트 후 큰 값 (예 : 1 년 동안 31536000 초)으로 늘리는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="977713adc75f83a5b3473a95460185fd112627aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: use self-signed certificates only for local testing, and do not mark such test certificates as globally trusted in browsers or operating system!</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 자체 서명 된 인증서는 로컬 테스트에만 사용하고 이러한 테스트 인증서를 브라우저 나 운영 체제에서 전역 적으로 신뢰할 수있는 것으로 표시하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="1cad69f4d5c0cf72c96c3c5640bf1b9c6d65b2cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can use Ecto schemas and changesets to cast and validate any kind of data, regardless if the data will be persisted to an Ecto repository or not&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;데이터가 Ecto 리포지토리에 유지되는지 여부에 관계없이 Ecto 스키마 및 변경 집합을 사용하여 모든 종류의 데이터를 캐스팅하고 유효성을 검사 할 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e8d365a24b2c40cbaa5529ec29ec24dafb15a83e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; will match any route regardless of the HTTP method. Check &lt;a href=&quot;#match/3&quot;&gt;&lt;code&gt;match/3&lt;/code&gt;&lt;/a&gt; for more information on how route compilation works and a list of supported options.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 에 관계없이 HTTP 방식의 경로와 일치합니다. 라우트 컴파일 작동 방법 및 지원되는 옵션 목록에 대한 자세한 정보는 &lt;a href=&quot;#match/3&quot;&gt; &lt;code&gt;match/3&lt;/code&gt; &lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d6ab7944440e9f874b849eecf02f234b32e425" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;phx-keydown&lt;/code&gt; binding is only throttled for key repeats. Unique keypresses back-to-back will dispatch the pressed key events.</source>
          <target state="translated">&lt;code&gt;phx-keydown&lt;/code&gt; 단지 키 반복을 위해 스로틀 바인딩. 고유 한 키 누름은 연속적으로 누름 된 키 이벤트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="19e294d8f5196b8fffae61a23b79786066eff46e" translate="yes" xml:space="preserve">
          <source>A DELETE request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;delete&lt;/code&gt; action with an ID to remove the individual user from the data store.</source>
          <target state="translated">&lt;code&gt;/users/:id&lt;/code&gt; 에 대한 DELETE 요청 은 데이터 저장소에서 개별 사용자를 제거하기 위해 ID와 함께 &lt;code&gt;delete&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f89e5b3085312297a30ccdec8fedb775a68739" translate="yes" xml:space="preserve">
          <source>A DSL to define a routing algorithm that works with Plug.</source>
          <target state="translated">플러그와 함께 작동하는 라우팅 알고리즘을 정의하는 DSL입니다.</target>
        </trans-unit>
        <trans-unit id="40955228103fb4a3febe39027046c4264cc8b9f8" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/:id/edit&lt;/code&gt; will invoke the &lt;code&gt;edit&lt;/code&gt; action with an ID to retrieve an individual user from the data store and present the information in a form for editing.</source>
          <target state="translated">&lt;code&gt;/users/:id/edit&lt;/code&gt; 에 대한 GET 요청 은 ID를 사용 하여 &lt;code&gt;edit&lt;/code&gt; 작업을 호출 하여 데이터 저장소에서 개별 사용자를 검색하고 편집 할 양식으로 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="305f1f3765fad844b78b2517312b9a7447803d28" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;show&lt;/code&gt; action with an id to show an individual user identified by that ID.</source>
          <target state="translated">&lt;code&gt;/users/:id&lt;/code&gt; 에 대한 GET 요청 은 해당 ID로 식별되는 개별 사용자를 표시하기 위해 ID와 함께 &lt;code&gt;show&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fdad7d2c9029b1baf5442355eaea158e595e28dc" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/new&lt;/code&gt; will invoke the &lt;code&gt;new&lt;/code&gt; action to present a form for creating a new user.</source>
          <target state="translated">&lt;code&gt;/users/new&lt;/code&gt; 에 대한 GET 요청 은 새 사용자를 만들기위한 양식을 제공하기 위해 &lt;code&gt;new&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2d6b6c89ab31051a71f9f3a18c63c71e0147e1b3" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users&lt;/code&gt; will invoke the &lt;code&gt;index&lt;/code&gt; action to show all the users.</source>
          <target state="translated">&lt;code&gt;/users&lt;/code&gt; 에 대한 GET 요청 은 모든 사용자를 표시하기 위해 &lt;code&gt;index&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="184bae6e7ea63ef87415e22542b422c2059fed96" translate="yes" xml:space="preserve">
          <source>A LiveView begins as a regular HTTP request and HTML response, and then upgrades to a stateful view on client connect, guaranteeing a regular HTML page even if JavaScript is disabled. Any time a stateful view changes or updates its socket assigns, it is automatically re-rendered and the updates are pushed to the client.</source>
          <target state="translated">LiveView는 일반 HTTP 요청 및 HTML 응답으로 시작된 다음 클라이언트 연결시 상태 저장보기로 업그레이드되어 JavaScript가 비활성화 된 경우에도 일반 HTML 페이지를 보장합니다. 상태 저장 뷰가 소켓 할당을 변경하거나 업데이트 할 때마다 자동으로 다시 렌더링되고 업데이트가 클라이언트에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c9c9a794022eb65022923b31e317a5956253d4b" translate="yes" xml:space="preserve">
          <source>A LiveView can be routed to by using the &lt;code&gt;live&lt;/code&gt; macro with a path and the name of the LiveView:</source>
          <target state="translated">LiveView 의 경로 및 이름과 함께 &lt;code&gt;live&lt;/code&gt; 매크로를 사용하여 LiveView를 라우팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd9145e78df8bb2fbf84cd52bb65185ee2bd1af3" translate="yes" xml:space="preserve">
          <source>A LiveView is a simple module that requires two callbacks: &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">LiveView는 &lt;a href=&quot;#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; 의&lt;/a&gt; 두 가지 콜백이 필요한 간단한 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="da0c1cf567abac8b773c1074de7eb911fb691dcc" translate="yes" xml:space="preserve">
          <source>A PATCH request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;update&lt;/code&gt; action with an ID to save the updated user to the data store.</source>
          <target state="translated">&lt;code&gt;/users/:id&lt;/code&gt; 에 대한 PATCH 요청 은 업데이트 된 사용자를 데이터 저장소에 저장하는 ID로 &lt;code&gt;update&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ec262fd36b04c39661285e3a619dc48715cd927f" translate="yes" xml:space="preserve">
          <source>A POST request to &lt;code&gt;/users&lt;/code&gt; will invoke the &lt;code&gt;create&lt;/code&gt; action to save a new user to the data store.</source>
          <target state="translated">&lt;code&gt;/users&lt;/code&gt; 에 대한 POST 요청 은 데이터 저장소에 새 사용자를 저장하는 &lt;code&gt;create&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="10210c3154f0f0fe1d9cae3fedb5f1315b683380" translate="yes" xml:space="preserve">
          <source>A PUT request to &lt;code&gt;/users/:id&lt;/code&gt; will also invoke the &lt;code&gt;update&lt;/code&gt; action with an ID to save the updated user to the data store.</source>
          <target state="translated">&lt;code&gt;/users/:id&lt;/code&gt; 에 대한 PUT 요청 은 또한 업데이트 된 사용자를 데이터 저장소에 저장하는 ID로 &lt;code&gt;update&lt;/code&gt; 작업을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="11d464647b1c302ddfced5ce15ec52a3a34c1b76" translate="yes" xml:space="preserve">
          <source>A Phoenix Example</source>
          <target state="translated">피닉스의 예</target>
        </trans-unit>
        <trans-unit id="7ae1a7e1a27cda948880c8475e2814e96b706399" translate="yes" xml:space="preserve">
          <source>A Plug Adapter that supports HTTPS, e.g. &lt;a href=&quot;https://hex.pm/packages/plug_cowboy&quot;&gt;Plug.Cowboy&lt;/a&gt;</source>
          <target state="translated">HTTPS를 지원하는 플러그 어댑터 (예 : &lt;a href=&quot;https://hex.pm/packages/plug_cowboy&quot;&gt;Plug.Cowboy)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56ae008b2dbb8e2c8b9d49a21483781040acd885" translate="yes" xml:space="preserve">
          <source>A Plug to convert &lt;code&gt;HEAD&lt;/code&gt; requests to &lt;code&gt;GET&lt;/code&gt; requests.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 요청을 &lt;code&gt;GET&lt;/code&gt; 요청 으로 변환하는 플러그 입니다.</target>
        </trans-unit>
        <trans-unit id="d9c9bd80e3aec4eb14e3119b821163e1e2ebc9cd" translate="yes" xml:space="preserve">
          <source>A Telemetry event is made up of the following:</source>
          <target state="translated">Telemetry 이벤트는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9212b48251284e0caf9388416e943cd719c4abfa" translate="yes" xml:space="preserve">
          <source>A behaviour that serializes incoming and outgoing socket messages.</source>
          <target state="translated">들어오고 나가는 소켓 메시지를 직렬화하는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b010a98e050eb10dc2e5f1b11c9caa3386cee439" translate="yes" xml:space="preserve">
          <source>A callback executed when the repo starts or when configuration is read</source>
          <target state="translated">리포지토리가 시작되거나 구성을 읽을 때 실행되는 콜백</target>
        </trans-unit>
        <trans-unit id="fcc767a7e430e354ff1bfd81d0d475cdd63612f4" translate="yes" xml:space="preserve">
          <source>A callback executed when the repo starts or when configuration is read.</source>
          <target state="translated">리포지토리가 시작되거나 구성을 읽을 때 실행되는 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="7eb7511e858848219f54b95873996b4e099e5689" translate="yes" xml:space="preserve">
          <source>A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the &lt;code&gt;changes&lt;/code&gt; part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored.</source>
          <target state="translated">더티 변경을 추적하는 유일한 메커니즘이므로 변경 세트가 필요합니다. &lt;code&gt;changes&lt;/code&gt; 의 변경 부분에 있는 필드 만 데이터베이스로 전송됩니다. 스키마에 대한 다른 메모리 내 변경 사항은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="388bae3344dc49c248c086da49078f3c9a747194" translate="yes" xml:space="preserve">
          <source>A changeset is supplied along with a function to apply to each error message as the changeset is traversed. The error message function receives an error tuple &lt;code&gt;{msg, opts}&lt;/code&gt;, for example:</source>
          <target state="translated">변경 세트가 순회 될 때 각 오류 메시지에 적용하는 기능과 함께 변경 세트가 제공됩니다. 오류 메시지 함수는 오류 튜플 &lt;code&gt;{msg, opts}&lt;/code&gt; 받습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbc0ed247dabdd047db8fd7f074aba54c53f0214" translate="yes" xml:space="preserve">
          <source>A collection is any enumerable of structs. This function returns the rendered collection in a list:</source>
          <target state="translated">컬렉션은 열거 가능한 구조체입니다. 이 함수는 렌더링 된 컬렉션을 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f2e0d0c42f6c749eef59802dc33214c5b12f1eb" translate="yes" xml:space="preserve">
          <source>A collection of helpers to be imported into your views.</source>
          <target state="translated">뷰로 가져올 도우미 모음입니다.</target>
        </trans-unit>
        <trans-unit id="620ac80b98e2b486fda0b863dfdd7ce97f8761ec" translate="yes" xml:space="preserve">
          <source>A common table expression (CTE) also known as WITH expression.</source>
          <target state="translated">WITH 식이라고도하는 CTE (공통 테이블 식)입니다.</target>
        </trans-unit>
        <trans-unit id="c608908c246ab16423c148e6fa64ef056979bdbb" translate="yes" xml:space="preserve">
          <source>A common use case is updating a counter cache, in this case updating a post&amp;rsquo;s comment count when a comment is created:</source>
          <target state="translated">일반적인 사용 사례는 카운터 캐시를 업데이트하는 것입니다.이 경우 의견을 만들 때 게시물의 의견 수를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="eb98855a0c95e34d029258a274731d0384744968" translate="yes" xml:space="preserve">
          <source>A common use case is updating a counter cache, in this case updating a post's comment count when a comment is created:</source>
          <target state="translated">일반적인 사용 사례는 카운터 캐시를 업데이트하는 것입니다.이 경우 댓글이 생성 될 때 게시물의 댓글 수를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d16b4ddf57438100c6143c5af9cff2f6af21dff5" translate="yes" xml:space="preserve">
          <source>A constraint is a map with the following fields:</source>
          <target state="translated">구속 조건은 다음 필드가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="025d095189152f316c790811b01d5dd5842fe730" translate="yes" xml:space="preserve">
          <source>A container can be marked with &lt;code&gt;phx-update&lt;/code&gt;, allowing the DOM patch operations to avoid updating or removing portions of the LiveView, or to append or prepend the updates rather than replacing the existing contents. This is useful for client-side interop with existing libraries that do their own DOM operations. The following &lt;code&gt;phx-update&lt;/code&gt; values are supported:</source>
          <target state="translated">컨테이너는 &lt;code&gt;phx-update&lt;/code&gt; 로 표시 될 수 있으므로 DOM 패치 작업이 LiveView의 일부를 업데이트하거나 제거하지 않도록하거나 기존 콘텐츠를 교체하는 대신 업데이트를 추가하거나 앞에 추가 할 수 있습니다. 이는 자체 DOM 작업을 수행하는 기존 라이브러리와의 클라이언트 측 상호 운용에 유용합니다. 다음 &lt;code&gt;phx-update&lt;/code&gt; 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="57963828a8668feeba8780dca8ee7c47104fb07a" translate="yes" xml:space="preserve">
          <source>A controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.</source>
          <target state="translated">기본적으로 컨트롤러는 연결 조작, 템플릿 렌더링 등을위한 많은 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b5a1b658082aeefd7644070c78660f46428db9d" translate="yes" xml:space="preserve">
          <source>A couple of files were generated with this task. First, we have a &lt;code&gt;user.ex&lt;/code&gt; file, containing our Ecto schema with our schema definition of the fields we passed to the task. Next, a migration file was generated inside &lt;code&gt;priv/repo/migrations&lt;/code&gt; which will create our database table that our schema maps to.</source>
          <target state="translated">이 작업으로 몇 개의 파일이 생성되었습니다. 먼저 작업에 전달한 필드의 스키마 정의와 함께 Ecto 스키마가 포함 된 &lt;code&gt;user.ex&lt;/code&gt; 파일이 있습니다. 다음으로 마이그레이션 파일이 &lt;code&gt;priv/repo/migrations&lt;/code&gt; 내부에 생성되어 스키마가 매핑되는 데이터베이스 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fa6f9752dd3b6d0d7372c3ed36166a0a7f66b682" translate="yes" xml:space="preserve">
          <source>A custom channel implementation MUST invoke &lt;code&gt;GenServer.reply(from, {:ok | :error, reply_payload})&lt;/code&gt; during its initialization with a custom &lt;code&gt;reply_payload&lt;/code&gt; that will be sent as a reply to the client. Failing to do so will block the socket forever.</source>
          <target state="translated">사용자 정의 채널 구현은 클라이언트에 응답으로 전송 될 사용자 정의 &lt;code&gt;reply_payload&lt;/code&gt; 를 사용하여 초기화 중에 &lt;code&gt;GenServer.reply(from, {:ok | :error, reply_payload})&lt;/code&gt; 호출해야 합니다. 그렇게하지 않으면 소켓이 영원히 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca58df44db6ae9f0299d01c621c3b42cefdf8aa" translate="yes" xml:space="preserve">
          <source>A custom channel receives &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; structs as regular messages from the transport. Replies to those messages and custom messages can be sent to the socket at any moment by building an appropriate &lt;a href=&quot;phoenix.socket.reply&quot;&gt;&lt;code&gt;Phoenix.Socket.Reply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; structs, encoding them with the serializer and dispatching the serialized result to the transport.</source>
          <target state="translated">사용자 지정 채널은 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 구조체를 전송에서 일반 메시지로 받습니다 . 적절한 &lt;a href=&quot;phoenix.socket.reply&quot;&gt; &lt;code&gt;Phoenix.Socket.Reply&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 구조체 를 빌드 하고 직렬화 기로 인코딩하고 직렬화 된 결과를 전송에 전달하여 해당 메시지 및 사용자 지정 메시지에 대한 응답을 언제든지 소켓으로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82dd2f5d8c41c25be625b40823e37d6a67414f02" translate="yes" xml:space="preserve">
          <source>A custom dispatcher may also be given as a fifth, optional argument. See the &quot;Custom dispatching&quot; section in the module documentation.</source>
          <target state="translated">사용자 지정 디스패처는 다섯 번째 선택적 인수로 제공 될 수도 있습니다. 모듈 설명서의 &quot;사용자 지정 디스패치&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3cb5897eb86fc23c7e36c4eb41697d2fd081125" translate="yes" xml:space="preserve">
          <source>A custom dispatcher may also be given as a fourth, optional argument. See the &quot;Custom dispatching&quot; section in the module documentation.</source>
          <target state="translated">사용자 지정 디스패처는 네 번째 선택적 인수로 제공 될 수도 있습니다. 모듈 설명서의 &quot;사용자 지정 디스패치&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10349bdecbe830d7172782cfe20d007bc64bc5ed" translate="yes" xml:space="preserve">
          <source>A custom headers map may also be given to be merged with defaults.</source>
          <target state="translated">사용자 정의 헤더 맵이 기본값과 병합되도록 제공 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e063bc35d1255698a1fa0aa80b8b85e8b4cd7b5" translate="yes" xml:space="preserve">
          <source>A custom headers map may also be given to be merged with defaults. It is recommended for custom header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses.</source>
          <target state="translated">기본값과 병합되도록 사용자 정의 헤더 맵을 제공 할 수도 있습니다. 요청에서 중복 키를 보내지 않도록 사용자 지정 헤더 키를 소문자로 지정하는 것이 좋습니다. 또한 HTTP / 2를 통해 제공되는 대소 문자 혼합 헤더가있는 응답은 일반 클라이언트에서 유효하지 않은 것으로 간주되어 응답이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9d48a1d706334ebdad1d7db287b9b4c843bc42eb" translate="yes" xml:space="preserve">
          <source>A custom type expects 4 functions to be implemented, all documented and described below. We also provide two examples of how custom types can be used in Ecto to augment existing types or providing your own types.</source>
          <target state="translated">커스텀 타입은 아래에 문서화되고 설명 된 4 가지 기능이 구현 될 것으로 예상합니다. 또한 Ecto에서 사용자 정의 유형을 사용하여 기존 유형을 보강하거나 고유 한 유형을 제공하는 방법에 대한 두 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d94ac0cca4c4677f5902badcf2266800aa7d904e" translate="yes" xml:space="preserve">
          <source>A custom type is a module that implements one of the &lt;a href=&quot;ecto.type&quot;&gt;&lt;code&gt;Ecto.Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ecto.parameterizedtype&quot;&gt;&lt;code&gt;Ecto.ParameterizedType&lt;/code&gt;&lt;/a&gt; behaviours. By default, Ecto provides the following custom types:</source>
          <target state="translated">사용자 지정 형식은 &lt;a href=&quot;ecto.type&quot;&gt; &lt;code&gt;Ecto.Type&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ecto.parameterizedtype&quot;&gt; &lt;code&gt;Ecto.ParameterizedType&lt;/code&gt; &lt;/a&gt; 동작 중 하나를 구현하는 모듈입니다 . 기본적으로 Ecto는 다음 사용자 지정 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d0900a0ddd633e5ba8eb37fff9e014676868d66" translate="yes" xml:space="preserve">
          <source>A custom type is a module that implements the &lt;a href=&quot;ecto.type&quot;&gt;&lt;code&gt;Ecto.Type&lt;/code&gt;&lt;/a&gt; behaviour. By default, Ecto provides the following custom types:</source>
          <target state="translated">커스텀 타입은 &lt;a href=&quot;ecto.type&quot;&gt; &lt;code&gt;Ecto.Type&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 모듈입니다 . 기본적으로 Ecto는 다음과 같은 사용자 정의 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32ecdd8fd7b37025f58b39a7dfbbcc8988a24674" translate="yes" xml:space="preserve">
          <source>A custom type that maps atoms to strings.</source>
          <target state="translated">원자를 문자열에 매핑하는 사용자 지정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a747bda5fdf562428478cd022242ed593cda1f33" translate="yes" xml:space="preserve">
          <source>A distinct query expression</source>
          <target state="translated">고유 한 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="684e1d79ed9b5db07cdfaeb906b9f0d3ebe6eb5a" translate="yes" xml:space="preserve">
          <source>A distinct query expression.</source>
          <target state="translated">고유 한 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="a1950dd57a002a1593df01e1817a7cc274948fc4" translate="yes" xml:space="preserve">
          <source>A dynamic expression can always be interpolated inside another dynamic expression and into the constructs described below.</source>
          <target state="translated">동적 표현식은 항상 다른 동적 표현식 내부와 아래 설명 된 구문으로 보간 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d7b4b4305750e4d404e970af1ab7cae58df9eb" translate="yes" xml:space="preserve">
          <source>A fallback plug is useful to translate common domain data structures into a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; response. If the controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt;, the provided plug will be called and receive the controller&amp;rsquo;s &lt;code&gt;%Plug.Conn{}&lt;/code&gt; as it was before the action was invoked along with the value returned from the controller action.</source>
          <target state="translated">대체 플러그는 일반적인 도메인 데이터 구조를 유효한 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 응답 으로 변환하는 데 유용합니다 . 컨트롤러 조치가 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 을 리턴하지 못하면 , 제공된 플러그 가 호출되고 제어기 조치에서 리턴 된 값과 함께 조치가 호출되기 전과 같이 제어기의 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="d6555cacc367409b90fbe3e36d37ce1f09e91f5c" translate="yes" xml:space="preserve">
          <source>A fallback plug is useful to translate common domain data structures into a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; response. If the controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt;, the provided plug will be called and receive the controller's &lt;code&gt;%Plug.Conn{}&lt;/code&gt; as it was before the action was invoked along with the value returned from the controller action.</source>
          <target state="translated">폴백 플러그는 일반적인 도메인 데이터 구조를 유효한 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 응답 으로 변환하는 데 유용합니다 . 컨트롤러 작업이 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 을 반환하지 못하면 제공된 플러그 가 호출되고 컨트롤러 작업에서 반환 된 값과 함께 작업이 호출되기 전의 컨트롤러의 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="7d23f8d08ce26c75baca863635b315ac840b822e" translate="yes" xml:space="preserve">
          <source>A field marked with &lt;code&gt;redact: true&lt;/code&gt; will display a value of &lt;code&gt;**redacted**&lt;/code&gt; when inspected in changes inside a &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; and be excluded from inspect on the schema unless the schema module is tagged with the option &lt;code&gt;@ecto_derive_inspect_for_redacted_fields false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redact: true&lt;/code&gt; 로 표시된 필드 는 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 내부의 변경 사항을 검사 할 때 &lt;code&gt;**redacted**&lt;/code&gt; 값을 표시 하고 스키마 모듈에 &lt;code&gt;@ecto_derive_inspect_for_redacted_fields false&lt;/code&gt; 옵션 태그가 지정되지 않은 경우 스키마 검사에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="508aa6b4e12f81428e50ac3d49c96bbbcea5e73e" translate="yes" xml:space="preserve">
          <source>A format encoder must export a function called &lt;code&gt;encode_to_iodata!/1&lt;/code&gt; which receives the rendering artifact and returns iodata.</source>
          <target state="translated">형식 인코더는 렌더링 아티팩트를 수신하고 iodata를 반환하는 &lt;code&gt;encode_to_iodata!/1&lt;/code&gt; 이라는 함수를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="6a13566eef334c9b65766da05ab4d4d43827f5f6" translate="yes" xml:space="preserve">
          <source>A fragment can also be used:</source>
          <target state="translated">단편도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae51f9dac9d7c54bb8170a15411f44df70ca2084" translate="yes" xml:space="preserve">
          <source>A fragment which defines the frame for window functions.</source>
          <target state="translated">윈도우 기능의 프레임을 정의하는 프래그먼트.</target>
        </trans-unit>
        <trans-unit id="611554aaafb2bfcecee33fba1d8e4c075165ef62" translate="yes" xml:space="preserve">
          <source>A full list of all Phoenix telemetry events can be found in &lt;a href=&quot;phoenix.logger&quot;&gt;&lt;code&gt;Phoenix.Logger&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">모든 피닉스 원격 측정 이벤트의 전체 목록에서 찾을 수 있습니다 &lt;a href=&quot;phoenix.logger&quot;&gt; &lt;code&gt;Phoenix.Logger&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3323426ad17b0c275178d48cb6477e1d9c4b9815" translate="yes" xml:space="preserve">
          <source>A function plug is any function that receives a connection and a set of options and returns a connection. Its type signature must be:</source>
          <target state="translated">기능 플러그는 연결 및 옵션 세트를 수신하고 연결을 반환하는 모든 기능입니다. 형식 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="41b63ea3ad4c061f35ede93ceeae9bcd925674fe" translate="yes" xml:space="preserve">
          <source>A garbage collector process that cleans up the table used by &lt;a href=&quot;phoenix.pubsub.local&quot;&gt;&lt;code&gt;Phoenix.PubSub.Local&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub.local&quot;&gt; &lt;code&gt;Phoenix.PubSub.Local&lt;/code&gt; 에서&lt;/a&gt; 사용하는 테이블을 정리하는 가비지 수집기 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="8e2bc2fa7d983a2e362056403cedaf0dcf21134b" translate="yes" xml:space="preserve">
          <source>A group by query expression</source>
          <target state="translated">쿼리 식별 그룹</target>
        </trans-unit>
        <trans-unit id="fbf7205eb24f77046d9fe35fbd00e1a311c37da6" translate="yes" xml:space="preserve">
          <source>A group by query expression.</source>
          <target state="translated">쿼리 식별 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="9a0412ffa16bcb7f7b88bbbe0e9a5d658142fc6a" translate="yes" xml:space="preserve">
          <source>A handler will need to implement a &lt;code&gt;child_spec/3&lt;/code&gt; function which takes:</source>
          <target state="translated">핸들러는 다음과 같은 &lt;code&gt;child_spec/3&lt;/code&gt; 함수 를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e98770d454075eda4766670bca1c8638c4ddaf13" translate="yes" xml:space="preserve">
          <source>A hex-encoded UUID string</source>
          <target state="translated">16 진수로 인코딩 된 UUID 문자열</target>
        </trans-unit>
        <trans-unit id="1e5d0b6bf037b68f0ab5247229dfbbf297cc5801" translate="yes" xml:space="preserve">
          <source>A hex-encoded UUID string.</source>
          <target state="translated">16 진수로 인코딩 된 UUID 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="94b525fd40b558cf7c5cb8a17c62318c0f7519cc" translate="yes" xml:space="preserve">
          <source>A join query expression</source>
          <target state="translated">조인 쿼리 식</target>
        </trans-unit>
        <trans-unit id="5ac8a34ba321b659953392223945bc3aec2d71a5" translate="yes" xml:space="preserve">
          <source>A join query expression.</source>
          <target state="translated">조인 쿼리 식</target>
        </trans-unit>
        <trans-unit id="fc626b639569e14ed38b80e4cfe297a5eee2e775" translate="yes" xml:space="preserve">
          <source>A keyword list can also be interpolated:</source>
          <target state="translated">키워드 목록을 보간 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98c43a93fb2b8df9b43baa37305537ee03813e9" translate="yes" xml:space="preserve">
          <source>A limit query expression</source>
          <target state="translated">제한 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="3a42a9b46de5122ad916b07756c8c98239bd5464" translate="yes" xml:space="preserve">
          <source>A limit query expression.</source>
          <target state="translated">제한 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="9326a99d5f5cbfad236b420591e04582f7a5b112" translate="yes" xml:space="preserve">
          <source>A list of atoms can also be interpolated for dynamic partitioning:</source>
          <target state="translated">동적 파티셔닝을 위해 원자 목록을 보간 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="548895d9732aa70eb4ec1302a1c7dc3677eeb752" translate="yes" xml:space="preserve">
          <source>A list of fields to order the window by, for example:</source>
          <target state="translated">창을 정렬 할 필드 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="211d256aebc6a4475a22f354ec17c5858108776e" translate="yes" xml:space="preserve">
          <source>A list of fields to partition the window by, for example:</source>
          <target state="translated">창을 분할하는 필드 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0b5bde25a22d39b8961db0c9a86938d6ab92eea" translate="yes" xml:space="preserve">
          <source>A lock query expression</source>
          <target state="translated">잠금 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="af0f90fc01dd0405acd985a97f28893c9c38969e" translate="yes" xml:space="preserve">
          <source>A lock query expression.</source>
          <target state="translated">잠금 쿼리 표현식.</target>
        </trans-unit>
        <trans-unit id="8a37515c314028cb265ffc9da11d9cb1972f95a3" translate="yes" xml:space="preserve">
          <source>A macro that stores a new plug. &lt;code&gt;opts&lt;/code&gt; will be passed unchanged to the new plug</source>
          <target state="translated">새로운 플러그를 저장하는 매크로. &lt;code&gt;opts&lt;/code&gt; 는 새 플러그로 변경없이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1492bad3d66e2fb22babef1faa31465bcbf67766" translate="yes" xml:space="preserve">
          <source>A macro that stores a new plug. &lt;code&gt;opts&lt;/code&gt; will be passed unchanged to the new plug.</source>
          <target state="translated">새로운 플러그를 저장하는 매크로. &lt;code&gt;opts&lt;/code&gt; 는 새 플러그로 변경없이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9669ce760ff0d6134d348fbea236193aa5997022" translate="yes" xml:space="preserve">
          <source>A map of metadata is returned with the following keys:</source>
          <target state="translated">메타 데이터 맵은 다음 키와 함께 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5636e85e1ef2bad613229d74bc0e9b119b4eb8" translate="yes" xml:space="preserve">
          <source>A migration file for the repository and test files for the context and controller features will also be generated.</source>
          <target state="translated">컨텍스트 및 컨트롤러 기능에 대한 저장소 및 테스트 파일의 마이그레이션 파일도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="220aa5b54ca715c2d2f9fb2d1024b813114578fe" translate="yes" xml:space="preserve">
          <source>A migration file for the repository and test files for the context will also be generated.</source>
          <target state="translated">저장소의 마이그레이션 파일과 컨텍스트의 테스트 파일도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a3495195f1b2b7fec8c8882cb005197b94803116" translate="yes" xml:space="preserve">
          <source>A minimal HTTPS listener, using Plug.Cowboy, might be defined as follows:</source>
          <target state="translated">Plug.Cowboy를 사용하는 최소 HTTPS 리스너는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7ad10c915de9107d9847304f90f45300a717e2" translate="yes" xml:space="preserve">
          <source>A module (&lt;strong&gt;not a plug&lt;/strong&gt;) for debugging in development.</source>
          <target state="translated">개발시 디버깅을위한 모듈 ( &lt;strong&gt;플러그&lt;/strong&gt; 아님)</target>
        </trans-unit>
        <trans-unit id="bb7b6f80c2f49bcca36ea5f27d90c322f347cbf7" translate="yes" xml:space="preserve">
          <source>A module plug is an extension of the function plug. It is a module that must export:</source>
          <target state="translated">모듈 플러그는 기능 플러그의 확장입니다. 내 보내야하는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1f14577898ec9c27ef3bf73631758c3ef60637ef" translate="yes" xml:space="preserve">
          <source>A module to be used in your existing plugs in order to provide error handling.</source>
          <target state="translated">오류 처리를 위해 기존 플러그에 사용되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="67a9117a71efdc61533ad05c49c69886601f4a9c" translate="yes" xml:space="preserve">
          <source>A new Controller</source>
          <target state="translated">새로운 컨트롤러</target>
        </trans-unit>
        <trans-unit id="c07076627092ae2d0bfa89573bd3a550b3b1b0df" translate="yes" xml:space="preserve">
          <source>A new View</source>
          <target state="translated">새로운 관점</target>
        </trans-unit>
        <trans-unit id="2ae6beb758947fcfcf89be24aca92bbc2e9b06a7" translate="yes" xml:space="preserve">
          <source>A new file will be generated in:</source>
          <target state="translated">새로운 파일이 생성됩니다 :</target>
        </trans-unit>
        <trans-unit id="3ddc1a83cdb6a8f6d2ed02bae29d0825caa1c372" translate="yes" xml:space="preserve">
          <source>A new route</source>
          <target state="translated">새로운 경로</target>
        </trans-unit>
        <trans-unit id="6884c72d6fc3447702cd7e913579b82af22ac1e6" translate="yes" xml:space="preserve">
          <source>A newly generated Phoenix app will have a single controller, the &lt;code&gt;PageController&lt;/code&gt;, which can be found at &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; and looks like this.</source>
          <target state="translated">새로 생성 된 Phoenix 앱은 하나의 컨트롤러 인 &lt;code&gt;PageController&lt;/code&gt; 를 갖게 될 것입니다 . 이것은 &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; 에서 찾을 수 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16c226a26e1ad46c351166c932b41f1d8b22e2f6" translate="yes" xml:space="preserve">
          <source>A newly generated Phoenix application has three view modules - &lt;code&gt;ErrorView&lt;/code&gt;, &lt;code&gt;LayoutView&lt;/code&gt;, and &lt;code&gt;PageView&lt;/code&gt; - which are all in the, &lt;code&gt;lib/hello_web/views&lt;/code&gt; directory.</source>
          <target state="translated">새로 생성 된 Phoenix 애플리케이션에는 모두 &lt;code&gt;lib/hello_web/views&lt;/code&gt; 디렉터리 에있는 &lt;code&gt;ErrorView&lt;/code&gt; , &lt;code&gt;LayoutView&lt;/code&gt; 및 &lt;code&gt;PageView&lt;/code&gt; 의 세 가지보기 모듈 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4048094f5a6bb946c03a21815ec3a451989dff82" translate="yes" xml:space="preserve">
          <source>A note about &lt;a href=&quot;ecto&quot;&gt;Ecto&lt;/a&gt;: Ecto allows our Phoenix application to communicate with a data store, such as PostgreSQL, MySQL, and others. If our application will not require this component we can skip this dependency by passing the &lt;code&gt;--no-ecto&lt;/code&gt; flag to &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt;. This flag may also be combined with &lt;code&gt;--no-webpack&lt;/code&gt; to create a skeleton application.</source>
          <target state="translated">&lt;a href=&quot;ecto&quot;&gt;Ecto에&lt;/a&gt; 대한 참고 사항 : Ecto를 사용하면 Phoenix 애플리케이션이 PostgreSQL, MySQL 등과 같은 데이터 저장소와 통신 할 수 있습니다. 응용 프로그램에이 구성 요소가 필요하지 않은 경우 &lt;code&gt;--no-ecto&lt;/code&gt; 플래그를 전달하여 &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 를 혼합하여이 종속성을 건너 뛸 수 있습니다 . 이 플래그를 &lt;code&gt;--no-webpack&lt;/code&gt; 과 결합 하여 스켈레톤 애플리케이션을 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="342e293abf9ffaccbc624dc414e0fbdda464fb47" translate="yes" xml:space="preserve">
          <source>A note about &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; before we begin: Phoenix will use webpack for asset management by default. Webpack's dependencies are installed via the node package manager, not mix. Phoenix will prompt us to install them at the end of the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; task. If we say &quot;no&quot; at that point, and if we don't install those dependencies later with &lt;code&gt;npm install&lt;/code&gt;, our application will raise errors when we try to start it, and our assets may not load properly. If we don't want to use webpack at all, we can simply pass &lt;code&gt;--no-webpack&lt;/code&gt; to &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작하기 전에 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;웹팩에&lt;/a&gt; 대한 참고 사항 : Phoenix는 기본적으로 자산 관리를 위해 웹팩을 사용합니다. Webpack의 종속성은 혼합이 아닌 노드 패키지 관리자를 통해 설치됩니다. Phoenix는 &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 작업 이 끝나면 설치하라는 메시지를 표시합니다 . 그 시점에서 &quot;아니오&quot;라고 말하고 나중에 &lt;code&gt;npm install&lt;/code&gt; 을 사용 하여 이러한 종속성을 설치하지 않으면 응용 프로그램을 시작하려고 할 때 오류가 발생하고 자산이 제대로로드되지 않을 수 있습니다. webpack을 전혀 사용하지 않으려면 &lt;code&gt;--no-webpack&lt;/code&gt; 을 전달 하여 phx.new 를 &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6f9a6dd1d438af7a0c3c1923a719b2d5b36b31" translate="yes" xml:space="preserve">
          <source>A note about Erlang and Phoenix: while Phoenix itself only requires Erlang 20 or later, one of Phoenix's dependencies, &lt;a href=&quot;https://github.com/ninenines/cowboy&quot;&gt;cowboy&lt;/a&gt;, depends on Erlang 22 or later since cowboy 2.8.0. It is recommended to either install Erlang 22 or add &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; to your mix.exs once your app has been created.</source>
          <target state="translated">얼랑 피닉스에 관한 참고 : 피닉스 자체는 얼랑 20 이상, 피닉스의 종속성 중 하나, 필요 동안 &lt;a href=&quot;https://github.com/ninenines/cowboy&quot;&gt;카우보이&lt;/a&gt; , 얼랑 (22)에 따라 이상 카우보이 2.8.0입니다. 앱이 생성되면 Erlang 22를 설치하거나 mix.exs 에 &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; 을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d9e5ef5ae95a7e3c031bedf9b8401adb9938c8ce" translate="yes" xml:space="preserve">
          <source>A note on &lt;code&gt;:errors&lt;/code&gt;</source>
          <target state="translated">참고 사항 &lt;code&gt;:errors&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a57d03ff9e283e3ddf26983d0193c0170612bd7a" translate="yes" xml:space="preserve">
          <source>A note on hot code reloading: Some editors with their automatic linters may prevent hot code reloading from working. If it's not working for you, please see the discussion in &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues/1165&quot;&gt;this issue&lt;/a&gt;.</source>
          <target state="translated">핫 코드 다시로드에 대한 참고 사항 : 자동 린터를 사용하는 일부 편집기는 핫 코드 다시로드가 작동하지 않도록 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 작동하지 않는 &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues/1165&quot;&gt;경우이 문제&lt;/a&gt; 의 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="247b0c48eb92d7683ad37a2e4faf194583434289" translate="yes" xml:space="preserve">
          <source>A plug and module to handle automatic code reloading.</source>
          <target state="translated">자동 코드 재로드를 처리하기위한 플러그 및 모듈.</target>
        </trans-unit>
        <trans-unit id="a3bfffaf045864dc467604253ad832210e0baa2d" translate="yes" xml:space="preserve">
          <source>A plug for generating a unique request id for each request.</source>
          <target state="translated">각 요청에 대해 고유 한 요청 ID를 생성하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="6446fa6bdbded8c6574e97c1eed133777cab6564" translate="yes" xml:space="preserve">
          <source>A plug for logging basic request information in the format:</source>
          <target state="translated">기본 요청 정보를 다음 형식으로 기록하기위한 플러그 :</target>
        </trans-unit>
        <trans-unit id="c8c318dc543ea007fb59d22f6b41bb1242501ed2" translate="yes" xml:space="preserve">
          <source>A plug for parsing the request body.</source>
          <target state="translated">요청 본문을 구문 분석하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="2e570b41fcca81d0056177ea2ef5b9015a670923" translate="yes" xml:space="preserve">
          <source>A plug for serving static assets.</source>
          <target state="translated">정적 자산을 제공하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="fa0549f72da9c53f30cb36c6df15f5ac9aabf768" translate="yes" xml:space="preserve">
          <source>A plug pipeline can be halted with &lt;a href=&quot;plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt;. The builder will prevent further plugs downstream from being invoked and return the current connection. In the following example, the &lt;a href=&quot;plug.logger&quot;&gt;&lt;code&gt;Plug.Logger&lt;/code&gt;&lt;/a&gt; plug never gets called:</source>
          <target state="translated">&lt;a href=&quot;plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; 로&lt;/a&gt; 플러그 파이프 라인을 정지시킬 수 있습니다 . 빌더는 추가 플러그 다운 스트림이 호출되는 것을 방지하고 현재 연결을 리턴합니다. 다음 예제에서 &lt;a href=&quot;plug.logger&quot;&gt; &lt;code&gt;Plug.Logger&lt;/code&gt; &lt;/a&gt; 플러그는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1886091b6bf7d12212133283469ad01791c28906" translate="yes" xml:space="preserve">
          <source>A plug that may convert a JSON response into a JSONP one</source>
          <target state="translated">JSON 응답을 JSONP로 변환 할 수있는 플러그</target>
        </trans-unit>
        <trans-unit id="27cc908ac178d8d6210d66299d0d2aa753f4c446" translate="yes" xml:space="preserve">
          <source>A plug that may convert a JSON response into a JSONP one.</source>
          <target state="translated">JSON 응답을 JSONP로 변환 할 수있는 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="d140e1ea5763f3091fa07f469fc491efe441881f" translate="yes" xml:space="preserve">
          <source>A plug to force SSL connections and enable HSTS.</source>
          <target state="translated">SSL 연결을 강제하고 HSTS를 활성화하는 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="7067fa076310914c5a187337eb8e079351e6240a" translate="yes" xml:space="preserve">
          <source>A plug to force SSL connections.</source>
          <target state="translated">SSL 연결을 강제 실행하는 플러그</target>
        </trans-unit>
        <trans-unit id="602566e61299332b20ef3537013b8af7450cd0d2" translate="yes" xml:space="preserve">
          <source>A plug to handle session cookies and session stores.</source>
          <target state="translated">세션 쿠키 및 세션 저장소를 처리하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="8471dd87a69a9fbbd3f9a4c22829ffc8050ef8ee" translate="yes" xml:space="preserve">
          <source>A plug to instrument the pipeline with &lt;code&gt;:telemetry&lt;/code&gt; events.</source>
          <target state="translated">&lt;code&gt;:telemetry&lt;/code&gt; 이벤트 를 사용하여 파이프 라인을 계측하는 플러그 입니다.</target>
        </trans-unit>
        <trans-unit id="1fc44f87aaffe938c4a1ae5d714f1c364e1ed200" translate="yes" xml:space="preserve">
          <source>A plug to rewrite the request's host/port/protocol from &lt;code&gt;x-forwarded-*&lt;/code&gt; headers.</source>
          <target state="translated">&lt;code&gt;x-forwarded-*&lt;/code&gt; 헤더 에서 요청의 호스트 / 포트 / 프로토콜을 다시 작성하는 플러그 입니다.</target>
        </trans-unit>
        <trans-unit id="590c592f611c77a032618a2af7a44e9550877726" translate="yes" xml:space="preserve">
          <source>A possible implementation would be to load the user on the &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">가능한 구현은 &lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt; 콜백 에서 사용자를로드하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a113601eea84699381389fc145edb16d078c8038" translate="yes" xml:space="preserve">
          <source>A prefix can be specified for a subquery, similar to standard repo operations:</source>
          <target state="translated">표준 리포 작업과 유사한 하위 쿼리에 접두사를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da6161e51728ffed7549eff7d59573edeb482aec" translate="yes" xml:space="preserve">
          <source>A process may be tracked multiple times, provided the topic and key pair are unique for any prior calls for the given process.</source>
          <target state="translated">주제와 키 쌍이 주어진 프로세스에 대한 이전 호출에 고유 한 경우 프로세스를 여러 번 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecd7cda5bcf7d72985a664f3c9340020d656a7d1" translate="yes" xml:space="preserve">
          <source>A process may be tracked multipled times, provided the topic and key pair are unique for any prior calls for the given process.</source>
          <target state="translated">주제와 키 쌍이 주어진 프로세스에 대한 이전 호출에 고유 한 경우 프로세스가 여러 번 추적 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6fce133c9e9afd0fc76959bbab1a15ebc56c715" translate="yes" xml:space="preserve">
          <source>A product matches in the above example if a line item was created since the provided date where the customer purchased at least 10 units.</source>
          <target state="translated">고객이 최소 10 개 단위를 구매 한 제공된 날짜 이후에 광고 항목이 생성 된 경우 위의 예에서 제품이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a15dac21b7bcee2c91dfe8f35a5617aa5f6ee9e6" translate="yes" xml:space="preserve">
          <source>A project at the given APP directory will be created. The application name and module name will be retrieved from the application name, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="translated">주어진 APP 디렉토리에 프로젝트가 생성됩니다. &lt;code&gt;--module&lt;/code&gt; 또는 &lt;code&gt;--app&lt;/code&gt; 이 제공 되지 않는 한 애플리케이션 이름과 모듈 이름은 애플리케이션 이름에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b7c7e3dbab6f551e809bcd37eae034f6b3551ed" translate="yes" xml:space="preserve">
          <source>A project at the given PATH will be created. The application name and module name will be retrieved from the path, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="translated">주어진 PATH에 프로젝트가 생성됩니다. &lt;code&gt;--module&lt;/code&gt; 또는 &lt;code&gt;--app&lt;/code&gt; 이 제공 되지 않으면 애플리케이션 이름과 모듈 이름이 경로에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb11d08c12532805958b64aa7f5232d9f8361526" translate="yes" xml:space="preserve">
          <source>A protocol that converts data structures into URL parameters.</source>
          <target state="translated">데이터 구조를 URL 매개 변수로 변환하는 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="a810227ea598a60f15fb0d07a9b08121f6023fee" translate="yes" xml:space="preserve">
          <source>A protocol that extends exceptions to be status-code aware.</source>
          <target state="translated">상태 코드를 인식하도록 예외를 확장하는 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="9b55f92a72a93f9b4051d36f398e4e4e4e15aa6c" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema, both for the join_through and the destination. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see an example:</source>
          <target state="translated">join_through 및 대상 모두에 대해 스키마 대신 쿼리를 제공 할 수도 있습니다. 연관을 조회, 결합 또는 사전로드하면 주어진 조회가 사용됩니다. 현재 쿼리에서 where 절을 제공 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="57b3d5d222f71f480afb39c6c01de765a7a9d056" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see an example:</source>
          <target state="translated">스키마 대신 쿼리를 제공 할 수도 있습니다. 연관을 조회, 결합 또는 사전로드하면 주어진 조회가 사용됩니다. 현재 쿼리에서 where 절을 제공 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="fa830660e15cdaa4dc6eab8c330789488fe7bf9d" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see some examples:</source>
          <target state="translated">스키마 대신 쿼리를 제공 할 수도 있습니다. 연관을 조회, 결합 또는 사전로드하면 주어진 조회가 사용됩니다. 현재 쿼리에서 where 절을 제공 할 수 있습니다. 몇 가지 예를 보자.</target>
        </trans-unit>
        <trans-unit id="6c16c5a7a0e6e3bd5d7267cbb006505cc93761f6" translate="yes" xml:space="preserve">
          <source>A raw binary representation of a UUID</source>
          <target state="translated">UUID의 원시 이진 표현</target>
        </trans-unit>
        <trans-unit id="f6365cf3f64e3ca89e5511ac308a4440b906f106" translate="yes" xml:space="preserve">
          <source>A raw binary representation of a UUID.</source>
          <target state="translated">UUID의 원시 이진 표현입니다.</target>
        </trans-unit>
        <trans-unit id="17d99d2006e78017bdc0cb317ef24f2c49c0675d" translate="yes" xml:space="preserve">
          <source>A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.</source>
          <target state="translated">저장소는 어댑터에 의해 제어되는 기본 데이터 저장소에 맵핑됩니다. 예를 들어, Ecto는 PostgreSQL 데이터베이스에 데이터를 저장하는 Postgres 어댑터와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4bdfc36fdfdd2bc045633b2cc0a5938d44cd56" translate="yes" xml:space="preserve">
          <source>A route can also specify parameters which will then be available in the function body:</source>
          <target state="translated">라우트는 함수 본문에서 사용할 수있는 매개 변수를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be5953e95ef0d7bf21d698beeb476b75a6419062" translate="yes" xml:space="preserve">
          <source>A route should specify only one of &lt;code&gt;:do&lt;/code&gt; or &lt;code&gt;:to&lt;/code&gt; options.</source>
          <target state="translated">경로는 &lt;code&gt;:do&lt;/code&gt; 또는 &lt;code&gt;:to&lt;/code&gt; 옵션 중 하나만 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8be751a044d822045b1eaba342f9baa71ee2a42" translate="yes" xml:space="preserve">
          <source>A scope may then use this pipeline as:</source>
          <target state="translated">그런 다음 범위는이 파이프 라인을 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64707c17a82fafbfa181761a4306f357e5402b6f" translate="yes" xml:space="preserve">
          <source>A select query expression</source>
          <target state="translated">선택 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="52159915deda5630e0d675da42a0327fd8ad0a83" translate="yes" xml:space="preserve">
          <source>A select query expression.</source>
          <target state="translated">선택 쿼리 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="d15a1414e1dabc4b77e0578af24e25bba1b64638" translate="yes" xml:space="preserve">
          <source>A server (a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; specifically) that manages uploaded files.</source>
          <target state="translated">업로드 된 파일을 관리 하는 서버 (특히 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5eb2282eff957c7edee6fbf213e15ead022d6693" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;form_for(changeset, url, [])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;form_for(changeset, url, [])&lt;/code&gt; 의 단축키입니다 .</target>
        </trans-unit>
        <trans-unit id="679ddb5ec5c04f2352ccd686eb689981aa0578a3" translate="yes" xml:space="preserve">
          <source>A shortcut that renders the given template in the given view</source>
          <target state="translated">주어진 템플릿을 주어진 뷰에서 렌더링하는 바로 가기</target>
        </trans-unit>
        <trans-unit id="360b1f0139a93d8cac8e04f96457dacccd4755ad" translate="yes" xml:space="preserve">
          <source>A shortcut that renders the given template in the given view.</source>
          <target state="translated">주어진보기에서 주어진 템플릿을 렌더링하는 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="a3bd2deed4cd1a4e3f23be9ce997e4465341c885" translate="yes" xml:space="preserve">
          <source>A single key value pair may be passed, a keyword list or map of assigns may be provided to be merged into existing socket assigns.</source>
          <target state="translated">단일 키 값 쌍이 전달 될 수 있고 키워드 목록 또는 할당 맵이 기존 소켓 할당에 병합되도록 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="281877018fb4680e1f3e3563380eab9840f150e5" translate="yes" xml:space="preserve">
          <source>A single key value pair may be passed, or a keyword list or a map of assigns may be provided to be merged into existing socket assigns.</source>
          <target state="translated">단일 키 값 쌍이 전달되거나 기존 소켓 할당에 병합되도록 키워드 목록 또는 할당 맵이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="203df8270968063b9a7a2981211a19746083887a" translate="yes" xml:space="preserve">
          <source>A socket implementation that multiplexes messages over channels.</source>
          <target state="translated">채널을 통해 메시지를 다중화하는 소켓 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d6ceabc6982edc10020bcc03fa4510f767f1ce7d" translate="yes" xml:space="preserve">
          <source>A stateful component is a component that receives an &lt;code&gt;:id&lt;/code&gt; on &lt;code&gt;live_component/3&lt;/code&gt;:</source>
          <target state="translated">상태 저장 구성 요소는 &lt;code&gt;live_component/3&lt;/code&gt; 에서 &lt;code&gt;:id&lt;/code&gt; 를받는 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="f6653d758e2b31f0c35929242f95f2ed71bb3c02" translate="yes" xml:space="preserve">
          <source>A stateless component is always mounted, updated, and rendered whenever the parent template changes. That's why they are stateless: no state is kept after the component.</source>
          <target state="translated">상태 비 저장 구성 요소는 상위 템플릿이 변경 될 때마다 항상 마운트, 업데이트 및 렌더링됩니다. 이것이 상태 비 저장 인 이유입니다. 구성 요소 뒤에 상태가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeeadfaeb332d1926c6944d870d58481661e7138" translate="yes" xml:space="preserve">
          <source>A step beyond this is rendering pure JSON with the &lt;code&gt;json/2&lt;/code&gt; function. We need to pass it something that the &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason library&lt;/a&gt; can decode into JSON, such as a map. (Jason is one of Phoenix's dependencies.)</source>
          <target state="translated">그 이상의 단계는 &lt;code&gt;json/2&lt;/code&gt; 함수를 사용하여 순수한 JSON을 렌더링하는 것입니다. 지도와 같이 &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason 라이브러리&lt;/a&gt; 가 JSON으로 디코딩 할 수 있는 무언가를 전달해야합니다 . (Jason은 Phoenix의 종속성 중 하나입니다.)</target>
        </trans-unit>
        <trans-unit id="a4fdf6155a375fda05bd4126f4ac1b93d003da78" translate="yes" xml:space="preserve">
          <source>A struct representing subqueries.</source>
          <target state="translated">하위 쿼리를 나타내는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="4f89fcb81d2ce506035c4ee187c02c8467c2a257" translate="yes" xml:space="preserve">
          <source>A struct used as default on unfetched fields.</source>
          <target state="translated">페치되지 않은 필드에서 기본값으로 사용되는 구조체.</target>
        </trans-unit>
        <trans-unit id="1f61bdf60f93bab8b9e6b0fb5866d4197adbd5c1" translate="yes" xml:space="preserve">
          <source>A successful transaction returns the value returned by the function wrapped in a tuple as &lt;code&gt;{:ok, value}&lt;/code&gt;.</source>
          <target state="translated">성공적인 트랜잭션은 튜플에 싸인 함수가 반환 한 값을 &lt;code&gt;{:ok, value}&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad64c20203140b06d2f22b694f40b5efa96b9519" translate="yes" xml:space="preserve">
          <source>A telemetry &lt;code&gt;:metadata&lt;/code&gt; map including the following fields. Each database adapter may emit different information here. For Ecto.SQL databases, it will look like this:</source>
          <target state="translated">다음 필드를 포함 하는 원격 측정 &lt;code&gt;:metadata&lt;/code&gt; 맵. 각 데이터베이스 어댑터는 여기에서 다른 정보를 내보낼 수 있습니다. Ecto.SQL 데이터베이스의 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dc4724ee93112728013257157e88358eda90382" translate="yes" xml:space="preserve">
          <source>A template file has the following structure: &lt;code&gt;NAME.FORMAT.TEMPLATING_LANGUAGE&lt;/code&gt;. In our case, we will create a &quot;index.html.eex&quot; file at &quot;lib/hello_web/templates/hello/index.html.eex&quot;. &quot;.eex&quot; stands for &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt;&lt;code&gt;EEx&lt;/code&gt;&lt;/a&gt;, which is a library for embedding Elixir that ships as part of Elixir itself. Phoenix enhances EEx to include automatic escaping of values. This protects you from security vulnerabilities like Cross-Site-Scripting with no extra work on your part.</source>
          <target state="translated">템플릿 파일의 구조는 &lt;code&gt;NAME.FORMAT.TEMPLATING_LANGUAGE&lt;/code&gt; 입니다. 이 경우 &quot;lib / hello_web / templates / hello / index.html.eex&quot;에 &quot;index.html.eex&quot;파일을 생성합니다. &quot;.eex&quot;는 Elixir 자체의 일부로 제공되는 Elixir를 포함하기위한 라이브러리 인 &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt; &lt;code&gt;EEx&lt;/code&gt; 를&lt;/a&gt; 의미 합니다. Phoenix는 값의 자동 이스케이프를 포함하도록 EEx를 향상시킵니다. 이는 추가 작업없이 Cross-Site-Scripting과 같은 보안 취약성으로부터 사용자를 보호합니다.</target>
        </trans-unit>
        <trans-unit id="a3a3f96eb8d57f2d8f5d346f69678cc061505ef5" translate="yes" xml:space="preserve">
          <source>A template has a name, which also contains a format. For example, in the previous section we have rendered the &quot;index.html&quot; template:</source>
          <target state="translated">템플릿에는 형식도 포함 된 이름이 있습니다. 예를 들어, 이전 섹션에서 &quot;index.html&quot;템플릿을 렌더링했습니다.</target>
        </trans-unit>
        <trans-unit id="4ddd2b27cf9e32e87fad09c73b095d8e9c8a4457" translate="yes" xml:space="preserve">
          <source>A template has a name, which also contains a format. For example, in the previous section we have rendered the &amp;ldquo;index.html&amp;rdquo; template:</source>
          <target state="translated">템플릿에는 이름이 있으며 형식도 포함됩니다. 예를 들어, 이전 섹션에서 &quot;index.html&quot;템플릿을 렌더링했습니다.</target>
        </trans-unit>
        <trans-unit id="b87af6c93e951760a8f8005aa61e60d4437a4d31" translate="yes" xml:space="preserve">
          <source>A template rendered inside a component can use &lt;code&gt;live_patch&lt;/code&gt; and &lt;code&gt;live_redirect&lt;/code&gt; calls. The &lt;code&gt;live_patch&lt;/code&gt; is always handled by the parent &lt;code&gt;LiveView&lt;/code&gt;, as components do not provide &lt;code&gt;handle_params&lt;/code&gt;.</source>
          <target state="translated">구성 요소 내부에서 렌더링 된 템플릿은 &lt;code&gt;live_patch&lt;/code&gt; 및 &lt;code&gt;live_redirect&lt;/code&gt; 호출을 사용할 수 있습니다 . &lt;code&gt;live_patch&lt;/code&gt; 는 항상 부모에 의해 처리되는 &lt;code&gt;LiveView&lt;/code&gt; 구성 요소를 제공하지 않는 한, &lt;code&gt;handle_params&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1e660c6a6ee5d0e8ffddf28c0fa00526d5a8e3c6" translate="yes" xml:space="preserve">
          <source>A transport is responsible for:</source>
          <target state="translated">운송은 다음을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="946470e01e91e9929c4d53bc6f328c1d76bbc84a" translate="yes" xml:space="preserve">
          <source>A typical example is calling &lt;code&gt;MyRepo.insert/1&lt;/code&gt; with a struct and acting on the return value:</source>
          <target state="translated">일반적인 예는 구조체를 사용하여 &lt;code&gt;MyRepo.insert/1&lt;/code&gt; 을 호출 하고 반환 값에 작용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb5d317cfc71e83a7571c5f18c2490db22159483" translate="yes" xml:space="preserve">
          <source>A union all query expression</source>
          <target state="translated">모든 쿼리 식 통합</target>
        </trans-unit>
        <trans-unit id="25362305321b57a805c92a0acf72bc0d06d1a7dc" translate="yes" xml:space="preserve">
          <source>A union all query expression.</source>
          <target state="translated">모든 쿼리 식을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="d5b99cd9b0922c56851d9e0469e48511c48aeeee" translate="yes" xml:space="preserve">
          <source>A union query expression</source>
          <target state="translated">통합 쿼리 식</target>
        </trans-unit>
        <trans-unit id="4a920618e68127f219a3396142a47a00705a7fad" translate="yes" xml:space="preserve">
          <source>A union query expression.</source>
          <target state="translated">통합 쿼리 식</target>
        </trans-unit>
        <trans-unit id="679419f70975d183c742f7e11403ca44939004d4" translate="yes" xml:space="preserve">
          <source>A user customizable callback invoked for query-based operations.</source>
          <target state="translated">쿼리 기반 작업을 위해 호출되는 사용자 지정 가능한 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="44888c14caef36bb9c69024eae824ef0f11b9228" translate="yes" xml:space="preserve">
          <source>A user customizable callback invoked to retrieve default options for operations.</source>
          <target state="translated">작업에 대한 기본 옵션을 검색하기 위해 호출되는 사용자 정의 가능한 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="70b82fdaa5a10d034891a006719cc0e0a60994bc" translate="yes" xml:space="preserve">
          <source>A valid certificate and associated private key</source>
          <target state="translated">유효한 인증서 및 관련 개인 키</target>
        </trans-unit>
        <trans-unit id="fd7c2aef5660b74e939eea17604c8c896f7fa67b" translate="yes" xml:space="preserve">
          <source>API for building transports.</source>
          <target state="translated">교통 수단 구축을위한 API.</target>
        </trans-unit>
        <trans-unit id="86e6e8774db247384ff44f8f11bcef9d757da165" translate="yes" xml:space="preserve">
          <source>API for exporting a webserver.</source>
          <target state="translated">웹 서버를 내보내기위한 API.</target>
        </trans-unit>
        <trans-unit id="ed58cd8a2d9a5daa39ac65e4c3c4492641a76fb5" translate="yes" xml:space="preserve">
          <source>API used by Plug to invoke the code reloader on every request</source>
          <target state="translated">모든 요청에서 코드 리 로더를 호출하기 위해 Plug에 의해 사용되는 API</target>
        </trans-unit>
        <trans-unit id="4542405f0cabd3872e11baabdbce2401445cdbd7" translate="yes" xml:space="preserve">
          <source>API used by Plug to invoke the code reloader on every request.</source>
          <target state="translated">모든 요청에서 코드 리 로더를 호출하기 위해 Plug에 의해 사용되는 API.</target>
        </trans-unit>
        <trans-unit id="b79e3df9bbb0579360a4e4a0a03f1496f2475c10" translate="yes" xml:space="preserve">
          <source>API used by Plug to start the code reloader</source>
          <target state="translated">코드 리 로더를 시작하기 위해 Plug에서 사용하는 API</target>
        </trans-unit>
        <trans-unit id="7396c45721b461084efb7c8093672b44804d5ca9" translate="yes" xml:space="preserve">
          <source>API used by Plug to start the code reloader.</source>
          <target state="translated">코드 리 로더를 시작하기 위해 Plug에 의해 사용되는 API.</target>
        </trans-unit>
        <trans-unit id="70229b697d877c060248372885d62cc0b19c248b" translate="yes" xml:space="preserve">
          <source>ASC columns become DESC columns (and vice-versa). If the query has no order_bys, it orders by the inverse of the primary key.</source>
          <target state="translated">ASC 열은 DESC 열이됩니다 (반대의 경우도 마찬가지). 쿼리에 order_bys가 없으면 기본 키의 역순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="89ef021e223e176e371690ff7d78917f2535be99" translate="yes" xml:space="preserve">
          <source>About the arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="1adb4622e0cea24e2bb59e45a0fa949aa9cd4487" translate="yes" xml:space="preserve">
          <source>Accepts the module name for the channel</source>
          <target state="translated">채널의 모듈 이름을 승인합니다</target>
        </trans-unit>
        <trans-unit id="9ea67e607d24763f974e3d47b4034a46471d7ec5" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:delete/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:delete/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete/2&lt;/code&gt; &lt;/a&gt; 와 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="789dafed93ccbf4c05b49e24fc1da0571474c267" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt; &lt;/a&gt; 와 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="8c9553ee56bf0e31f097af5dc4f874d1c0bb310b" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert/2&quot;&gt;&lt;code&gt;Ecto.Repo.insert/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:insert/2&quot;&gt; &lt;code&gt;Ecto.Repo.insert/2&lt;/code&gt; &lt;/a&gt; 와 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="c752d4234a4cb721c1653ecd6f90b58c69994dcd" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.insert_all/3&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:insert_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.insert_all/3&lt;/code&gt; &lt;/a&gt; 과 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="b6480d325c63afe5877a0e30d3f5c75205c3ad50" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert_or_update/2&quot;&gt;&lt;code&gt;Ecto.Repo.insert_or_update/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:insert_or_update/2&quot;&gt; &lt;code&gt;Ecto.Repo.insert_or_update/2&lt;/code&gt; &lt;/a&gt; 와 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="8614a768a0a859c086c15abf0c73d40064b5fd00" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:update/2&quot;&gt;&lt;code&gt;Ecto.Repo.update/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:update/2&quot;&gt; &lt;code&gt;Ecto.Repo.update/2&lt;/code&gt; &lt;/a&gt; 와 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="1bc7635d2d0b3f661ed3f03cc2b0aef2100ccbd1" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt; 과 동일한 인수 및 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5950487ce2abf21dfb3acc6f897accc6cb91d221" translate="yes" xml:space="preserve">
          <source>Accepts the same command line options as &lt;code&gt;archive.install hex phx_new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;archive.install hex phx_new&lt;/code&gt; 와 동일한 명령 줄 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="adf777534a81a3c2426b5193f04a57a4b66913e5" translate="yes" xml:space="preserve">
          <source>Access the endpoint configuration given by key</source>
          <target state="translated">키로 제공된 엔드 포인트 구성에 액세스</target>
        </trans-unit>
        <trans-unit id="7b547055b41922089c3f74a93f478751d56aeb74" translate="yes" xml:space="preserve">
          <source>Access the endpoint configuration given by key.</source>
          <target state="translated">키로 지정된 엔드 포인트 구성에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="81fae5657d85417ee15ec92ce63c4c0103a12a5b" translate="yes" xml:space="preserve">
          <source>Accesses the connect info from the socket to use on connected mount.</source>
          <target state="translated">연결된 마운트에서 사용할 소켓의 연결 정보에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="7652d1e0348eb900dba83366501f144c1dbfefb5" translate="yes" xml:space="preserve">
          <source>Accesses the connect params sent by the client for use on connected mount.</source>
          <target state="translated">연결된 마운트에서 사용하기 위해 클라이언트가 보낸 연결 매개 변수에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0a4a92cf9a0b562797569d10e9e6816e10751772" translate="yes" xml:space="preserve">
          <source>According to the SQL standard it affects all CTEs in the query, not individual ones.</source>
          <target state="translated">SQL 표준에 따르면 개별 CTE가 아닌 쿼리의 모든 CTE에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="db4130792628ddb7da8b596a88089ecd9ac10945" translate="yes" xml:space="preserve">
          <source>Action Fallback</source>
          <target state="translated">조치 대체</target>
        </trans-unit>
        <trans-unit id="6cc7108ee58aa53d3b12f9e7023ebf5b27bb71f5" translate="yes" xml:space="preserve">
          <source>Action Fallback allows us to centralize error handling code in plugs which are called when a controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt; struct. These plugs receive both the &lt;code&gt;conn&lt;/code&gt; which was originally passed to the controller action along with the return value of the action.</source>
          <target state="translated">Action Fallback을 사용하면 컨트롤러 작업이 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 구조체 를 반환하지 못할 때 호출되는 플러그의 오류 처리 코드를 중앙 집중화 할 수 있습니다 . 이 플러그 는 액션의 반환 값과 함께 원래 컨트롤러 액션에 전달 된 &lt;code&gt;conn&lt;/code&gt; 을 모두받습니다 .</target>
        </trans-unit>
        <trans-unit id="ca491b8098405012c835e8927dd9ce64ef76acc0" translate="yes" xml:space="preserve">
          <source>Actionable Errors</source>
          <target state="translated">실행 가능한 오류</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="b263592eb8439a9f7f436a2911c2b555ca40cdcc" translate="yes" xml:space="preserve">
          <source>Actions and live navigation</source>
          <target state="translated">액션 및 라이브 내비게이션</target>
        </trans-unit>
        <trans-unit id="3fd09e68bf55b280210825b15b236e9e13c1e3cf" translate="yes" xml:space="preserve">
          <source>Adapter configuration</source>
          <target state="translated">어댑터 구성</target>
        </trans-unit>
        <trans-unit id="3287c69d8ddb53d15fe6cf2d9da75fd606c69c5d" translate="yes" xml:space="preserve">
          <source>Adapter-specific events</source>
          <target state="translated">어댑터 별 이벤트</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="7617cde4f91c3e1cfebf93bcdb04619e2cac150e" translate="yes" xml:space="preserve">
          <source>Add LiveView NPM dependencies to your &lt;code&gt;assets/package.json&lt;/code&gt;. For a regular project, do:</source>
          <target state="translated">&lt;code&gt;assets/package.json&lt;/code&gt; 에 LiveView NPM 종속성을 추가하십시오 . 일반 프로젝트의 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="57ac10db42fa6a0dcda32f077ad04482a86c9281" translate="yes" xml:space="preserve">
          <source>Add the following private function to your Telemetry module to lift the &lt;code&gt;:method&lt;/code&gt; value from the &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct:</source>
          <target state="translated">다음 개인 함수를 Telemetry 모듈에 추가하여 &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체 에서 &lt;code&gt;:method&lt;/code&gt; 값 을 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="e7e559fadb1d3b3cb4b5f949ab9c4a18973eab8f" translate="yes" xml:space="preserve">
          <source>Add the following to the list in your Telemetry supervisor's &lt;code&gt;periodic_measurements/0&lt;/code&gt; function, which is a private function that returns a list of measurements to take on a specified interval.</source>
          <target state="translated">Telemetry 감독자의 &lt;code&gt;periodic_measurements/0&lt;/code&gt; 함수 목록에 다음을 추가합니다. 이 함수는 지정된 간격에서 수행 할 측정 목록을 반환하는 개인 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7784ef3802e7b67bed0bf4318177efcf145c0392" translate="yes" xml:space="preserve">
          <source>Add the resulting file to your application&amp;rsquo;s &lt;code&gt;priv&lt;/code&gt; directory and pass the path using the &lt;code&gt;:dhfile&lt;/code&gt; key. It is best practice to rotate the file periodically.</source>
          <target state="translated">결과 파일을 애플리케이션의 &lt;code&gt;priv&lt;/code&gt; 디렉토리에 추가하고 &lt;code&gt;:dhfile&lt;/code&gt; 키를 사용하여 경로를 전달하십시오 . 파일을 주기적으로 회전하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0e8440557f2a0d433179d94e6804cfc69e836a1c" translate="yes" xml:space="preserve">
          <source>Adding Account functions</source>
          <target state="translated">계정 기능 추가</target>
        </trans-unit>
        <trans-unit id="c43c6cb1972e14253bb3b093d2ecce3b5ea8e551" translate="yes" xml:space="preserve">
          <source>Adding CMS functions</source>
          <target state="translated">CMS 기능 추가</target>
        </trans-unit>
        <trans-unit id="3b75b9f09dd7f1c4f62971b222b73c1de85d0d0b" translate="yes" xml:space="preserve">
          <source>Adding a new page</source>
          <target state="translated">새 페이지 추가</target>
        </trans-unit>
        <trans-unit id="d76d5b975035c940f1eedd666a63b0716ce4514a" translate="yes" xml:space="preserve">
          <source>Adding an Accounts Context</source>
          <target state="translated">계정 컨텍스트 추가</target>
        </trans-unit>
        <trans-unit id="6f55dbe5531ad6865c67ed95836c2557b5aeb8ba" translate="yes" xml:space="preserve">
          <source>Adding and removal of embeds can only be done via the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; API so Ecto can properly track the embed life-cycle:</source>
          <target state="translated">임베드 추가 및 제거는 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; API 를 통해서만 수행 할 수 있으므로 Ecto는 임베드 수명주기를 올바르게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54b958439b49e646480d341aff1a59341fcaef9" translate="yes" xml:space="preserve">
          <source>Additional Telemetry events are executed by Ecto adapters.</source>
          <target state="translated">추가 Telemetry 이벤트는 Ecto 어댑터에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f67e21d45717d2e7d5f6b8d4a9516ab30653948c" translate="yes" xml:space="preserve">
          <source>Additional options can be given to the session store, see the store&amp;rsquo;s documentation for the options it accepts.</source>
          <target state="translated">추가 옵션은 세션 저장소에 제공 될 수 있습니다. 허용되는 옵션에 대해서는 저장소 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5cec8513a17ee4ace1a1b38c87e62e48714bde0d" translate="yes" xml:space="preserve">
          <source>Additional options can be given to the session store, see the store's documentation for the options it accepts.</source>
          <target state="translated">세션 저장소에 추가 옵션을 제공 할 수 있습니다. 수락하는 옵션은 저장소 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae72c3e10c537af193c1abb9885797bdd492a3bb" translate="yes" xml:space="preserve">
          <source>Additional options can be set by selecting a predefined profile or by setting &lt;code&gt;:ssl&lt;/code&gt; options individually.</source>
          <target state="translated">미리 정의 된 프로필을 선택하거나 &lt;code&gt;:ssl&lt;/code&gt; 옵션을 개별적 으로 설정하여 추가 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a6f7fc13964d1c28a7b6f4385efa1513289c0ae" translate="yes" xml:space="preserve">
          <source>Additionally, the right side may also be a subquery:</source>
          <target state="translated">또한 오른쪽은 하위 ​​쿼리 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5633402537e80588fb2bf8033dabfd8b24d78124" translate="yes" xml:space="preserve">
          <source>Additionally, we strongly recommend including a unique HTML &quot;id&quot; attribute on the form. When DOM siblings change, elements without an ID will be replaced rather than moved, which can cause issues such as form fields losing focus.</source>
          <target state="translated">또한 양식에 고유 한 HTML &quot;id&quot;속성을 포함하는 것이 좋습니다. DOM 형제가 변경되면 ID가없는 요소가 이동되지 않고 대체되므로 양식 필드가 포커스를 잃는 것과 같은 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46698b76037699bcd1a6db8f4d893bf0a0f099e" translate="yes" xml:space="preserve">
          <source>Adds a delete operation to the multi</source>
          <target state="translated">멀티에 삭제 작업을 추가합니다</target>
        </trans-unit>
        <trans-unit id="9ee3d694f5156d312afd606d349abf63df55f685" translate="yes" xml:space="preserve">
          <source>Adds a delete operation to the multi.</source>
          <target state="translated">멀티에 삭제 작업을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="769fbcf8531ada2965f956c88b8bab5fa2107391" translate="yes" xml:space="preserve">
          <source>Adds a delete_all operation to the multi</source>
          <target state="translated">멀티에 delete_all 연산을 추가합니다</target>
        </trans-unit>
        <trans-unit id="cbe4492b83cbb0046f04cfc470e840e81af8e8f2" translate="yes" xml:space="preserve">
          <source>Adds a delete_all operation to the multi.</source>
          <target state="translated">멀티에 delete_all 연산을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5fef906b63f89a8348bcb81845ee544aab475f05" translate="yes" xml:space="preserve">
          <source>Adds a flash message to the socket to be displayed.</source>
          <target state="translated">표시 할 소켓에 플래시 메시지를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="58349070033bbd9b9269bd6e6931b771e8a71bc2" translate="yes" xml:space="preserve">
          <source>Adds a function to run as part of the multi</source>
          <target state="translated">멀티의 일부로 실행할 함수를 추가합니다</target>
        </trans-unit>
        <trans-unit id="1bec869c3e831e0a6c85e17cba5a4af86ccc6ec3" translate="yes" xml:space="preserve">
          <source>Adds a function to run as part of the multi.</source>
          <target state="translated">멀티의 일부로 실행할 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="34e192fedbb4eabab58579f23b6132b3af1a3750" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a date</source>
          <target state="translated">주어진 간격을 날짜에 추가합니다</target>
        </trans-unit>
        <trans-unit id="6d007da43a8bd9b39162829b023c276b326e5dbc" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a date.</source>
          <target state="translated">주어진 간격을 날짜에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="194676ec87039fc824f39013dabad1414b7f21a3" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a datetime</source>
          <target state="translated">주어진 시간을 날짜 시간에 추가합니다</target>
        </trans-unit>
        <trans-unit id="ed19d9c7db347a5112a39c5dddd3a119f1642683" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a datetime.</source>
          <target state="translated">주어진 시간 간격을 날짜 시간에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f176eb799f6d0e21b8db3090cb17b0b1910d9fd4" translate="yes" xml:space="preserve">
          <source>Adds a new element to the set</source>
          <target state="translated">세트에 새로운 요소를 추가</target>
        </trans-unit>
        <trans-unit id="cea99954f15fe72a878575aafe645073a0bcb4b1" translate="yes" xml:space="preserve">
          <source>Adds a new element to the set.</source>
          <target state="translated">세트에 새로운 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5137472dd63745ac60a833c182654bc64ff4bd48" translate="yes" xml:space="preserve">
          <source>Adds a new request header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">새로운 요청 헤더 (추가 &lt;code&gt;key&lt;/code&gt; 달리하여 해당 헤더의 이전 값 대체) 존재하지 않는 경우 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4e9e3bae320c79d590690ad5143c1c8375375b" translate="yes" xml:space="preserve">
          <source>Adds a new request header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">새로운 요청 헤더 (추가 &lt;code&gt;key&lt;/code&gt; 달리하여 해당 헤더의 이전 값 대체)가 존재하지 않는 경우 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c2bf518fb38cf26c49db68d29cada83da6c1888" translate="yes" xml:space="preserve">
          <source>Adds a new response header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">새로운 응답 헤더 (추가 &lt;code&gt;key&lt;/code&gt; 달리하여 해당 헤더의 이전 값 대체) 존재하지 않는 경우 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dea66064c01516ce1ce2f232671c9e6df2d28b6" translate="yes" xml:space="preserve">
          <source>Adds a new response header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">새로운 응답 헤더 (추가 &lt;code&gt;key&lt;/code&gt; 달리하여 해당 헤더의 이전 값 대체)가 존재하지 않는 경우 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7384ebe47a1b17e11afd5a17b7481276360f53a4" translate="yes" xml:space="preserve">
          <source>Adds an error to the changeset</source>
          <target state="translated">변경 세트에 오류를 추가합니다</target>
        </trans-unit>
        <trans-unit id="8fd325b36f13567a54758748114ef41ca1fff6fb" translate="yes" xml:space="preserve">
          <source>Adds an error to the changeset.</source>
          <target state="translated">변경 세트에 오류를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d1f9282c9f061f154b56dad9390ad5d59a06b52c" translate="yes" xml:space="preserve">
          <source>Adds an insert operation to the multi</source>
          <target state="translated">멀티에 삽입 작업을 추가합니다</target>
        </trans-unit>
        <trans-unit id="5a732255ac22c5c6065191d204bc188d1d7d11f9" translate="yes" xml:space="preserve">
          <source>Adds an insert operation to the multi.</source>
          <target state="translated">멀티에 삽입 작업을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6f1d356ee7af97c290a0983fcc393be6d69fc9fe" translate="yes" xml:space="preserve">
          <source>Adds an insert_all operation to the multi</source>
          <target state="translated">멀티에 insert_all 연산을 추가합니다</target>
        </trans-unit>
        <trans-unit id="18fb34baf7a00ef35058866f1cd06182f6556828" translate="yes" xml:space="preserve">
          <source>Adds an insert_all operation to the multi.</source>
          <target state="translated">멀티에 insert_all 연산을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4fea338f938382b22df2ad7873e19fba67b7dc02" translate="yes" xml:space="preserve">
          <source>Adds an update operation to the multi</source>
          <target state="translated">멀티에 업데이트 작업을 추가합니다</target>
        </trans-unit>
        <trans-unit id="c3cc5c39ec6abb44d01e956bf112b8e5cfa6f1f5" translate="yes" xml:space="preserve">
          <source>Adds an update operation to the multi.</source>
          <target state="translated">멀티에 업데이트 작업을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2dab70e220b97494a706a2a537167adfafecc13d" translate="yes" xml:space="preserve">
          <source>Adds an update_all operation to the multi</source>
          <target state="translated">멀티에 update_all 작업을 추가합니다</target>
        </trans-unit>
        <trans-unit id="427f83a0359dd0e43a3da4e151a7253d8e9a4062" translate="yes" xml:space="preserve">
          <source>Adds an update_all operation to the multi.</source>
          <target state="translated">멀티에 update_all 작업을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9cc89a0814520555ed99c796dba3165d5cca397a" translate="yes" xml:space="preserve">
          <source>Adds key value pairs to socket assigns.</source>
          <target state="translated">소켓 할당에 키 값 쌍을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="77d8ef9e9593e05de16fcb185362ded29dbcdd47" translate="yes" xml:space="preserve">
          <source>Adds key/value pair to socket assigns</source>
          <target state="translated">소켓 할당에 키 / 값 쌍을 추가합니다</target>
        </trans-unit>
        <trans-unit id="0d847ebf435901217a855c2d3a9bd63d85d34c23" translate="yes" xml:space="preserve">
          <source>Adds key/value pair to socket assigns.</source>
          <target state="translated">소켓 할당에 키 / 값 쌍을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2ebb729e6f4563c0b483c5ecfc0f09681da14fb9" translate="yes" xml:space="preserve">
          <source>Adds the given interval to the current time in UTC</source>
          <target state="translated">주어진 시간을 UTC로 현재 시간에 더합니다</target>
        </trans-unit>
        <trans-unit id="042bc7077804c2ab95f410b2330b189b5fef8ec7" translate="yes" xml:space="preserve">
          <source>Adds the given interval to the current time in UTC.</source>
          <target state="translated">주어진 시간을 UTC로 현재 시간에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3b5a0d13c97aaad5ec8dba3e8924ba9778eb0ba4" translate="yes" xml:space="preserve">
          <source>After a client has successfully joined a channel, incoming events from the client are routed through the channel&amp;rsquo;s &lt;code&gt;handle_in/3&lt;/code&gt; callbacks. Within these callbacks, you can perform any action. Typically you&amp;rsquo;ll either forward a message to all listeners with &lt;a href=&quot;#broadcast!/3&quot;&gt;&lt;code&gt;broadcast!/3&lt;/code&gt;&lt;/a&gt;, or push a message directly down the socket with &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. Incoming callbacks must return the &lt;code&gt;socket&lt;/code&gt; to maintain ephemeral state.</source>
          <target state="translated">클라이언트가 채널에 성공적으로 참여하면 클라이언트에서 들어오는 이벤트가 채널의 &lt;code&gt;handle_in/3&lt;/code&gt; 콜백을 통해 라우팅됩니다 . 이러한 콜백 내에서 모든 작업을 수행 할 수 있습니다. 일반적으로 당신도 앞으로 모든 청취자에게 메시지거야 &lt;a href=&quot;#broadcast!/3&quot;&gt; &lt;code&gt;broadcast!/3&lt;/code&gt; &lt;/a&gt; 하거나와 소켓 아래로 직접 메시지를 푸시 &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; . 수신 콜백은 임시 상태를 유지하기 위해 &lt;code&gt;socket&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4108bb7b421c03ddfde669d012f6caf3a8a55f8" translate="yes" xml:space="preserve">
          <source>After a client has successfully joined a channel, incoming events from the client are routed through the channel's &lt;code&gt;handle_in/3&lt;/code&gt; callbacks. Within these callbacks, you can perform any action. Typically you'll either forward a message to all listeners with &lt;a href=&quot;#broadcast!/3&quot;&gt;&lt;code&gt;broadcast!/3&lt;/code&gt;&lt;/a&gt;, or push a message directly down the socket with &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. Incoming callbacks must return the &lt;code&gt;socket&lt;/code&gt; to maintain ephemeral state.</source>
          <target state="translated">클라이언트가 채널에 성공적으로 참여한 후 클라이언트에서 들어오는 이벤트는 채널의 &lt;code&gt;handle_in/3&lt;/code&gt; 콜백을 통해 라우팅됩니다 . 이러한 콜백 내에서 모든 작업을 수행 할 수 있습니다. 일반적으로 당신도 앞으로 모든 청취자에게 메시지거야 &lt;a href=&quot;#broadcast!/3&quot;&gt; &lt;code&gt;broadcast!/3&lt;/code&gt; &lt;/a&gt; 하거나와 소켓 아래로 직접 메시지를 푸시 &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; . 수신 콜백은 임시 상태를 유지하기 위해 &lt;code&gt;socket&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4903a2f13a8bc80aa4ddc4c8cfc092578f620745" translate="yes" xml:space="preserve">
          <source>After a match is found, the block given as &lt;code&gt;do/end&lt;/code&gt; is stored as a function in the connection. This function is then retrieved and invoked in the &lt;code&gt;dispatch&lt;/code&gt; plug.</source>
          <target state="translated">일치가 발견되면 &lt;code&gt;do/end&lt;/code&gt; 로 지정된 블록 이 연결에 함수로 저장됩니다. 그런 다음이 기능은 &lt;code&gt;dispatch&lt;/code&gt; 플러그 에서 검색 및 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="26032b36670746e3434c695506614fe60aeea546" translate="yes" xml:space="preserve">
          <source>After casting, the changeset is given to many &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; functions that validate only the &lt;strong&gt;changed fields&lt;/strong&gt;. In other words: if a field was not given as a parameter, it won&amp;rsquo;t be validated at all. For example, if the params map contain only the &amp;ldquo;name&amp;rdquo; and &amp;ldquo;email&amp;rdquo; keys, the &amp;ldquo;age&amp;rdquo; validation won&amp;rsquo;t run.</source>
          <target state="translated">캐스트 후 변경 세트는 &lt;strong&gt;변경된 필드&lt;/strong&gt; 만 유효성 검증 하는 많은 &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; 함수에 제공 &lt;strong&gt;됩니다&lt;/strong&gt; . 즉, 필드가 매개 변수로 제공되지 않은 경우에는 필드의 유효성이 전혀 검증되지 않습니다. 예를 들어 params 맵에 &quot;name&quot;및 &quot;email&quot;키만 포함되어 있으면 &quot;age&quot;유효성 검사가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf0e063e152ca973c9a117163e8a4b6bc3228047" translate="yes" xml:space="preserve">
          <source>After casting, the changeset is given to many &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; functions that validate only the &lt;strong&gt;changed fields&lt;/strong&gt;. In other words: if a field was not given as a parameter, it won't be validated at all. For example, if the params map contain only the &quot;name&quot; and &quot;email&quot; keys, the &quot;age&quot; validation won't run.</source>
          <target state="translated">캐스팅 후 &lt;strong&gt;변경된 필드&lt;/strong&gt; 만 확인 하는 많은 &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; 함수에 변경 집합이 제공 &lt;strong&gt;됩니다&lt;/strong&gt; . 즉, 필드가 매개 변수로 제공되지 않으면 전혀 유효성이 검증되지 않습니다. 예를 들어 params 맵에 &quot;name&quot;및 &quot;email&quot;키만 포함 된 경우 &quot;age&quot;유효성 검사가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6aa70809ce1014ac0c0f588a1a20ec2a8f93b3c" translate="yes" xml:space="preserve">
          <source>After exploring the documentation and guides, consider checking out the &lt;a href=&quot;http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0&quot;&gt;&amp;ldquo;What&amp;rsquo;s new in Ecto 2.1&amp;rdquo;&lt;/a&gt; free ebook to learn more about many features in Ecto 2.1 such as &lt;code&gt;many_to_many&lt;/code&gt;, schemaless queries, concurrent testing and more. Note the book still largely applies to Ecto 3.0 as the major change in Ecto 3.0 was the removal of the outdated Ecto datetime types in favor of Elixir&amp;rsquo;s Calendar types.</source>
          <target state="translated">설명서 및 안내서 를 &lt;code&gt;many_to_many&lt;/code&gt; 후 &lt;a href=&quot;http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0&quot;&gt;&quot;Ecto 2.1의 새로운&lt;/a&gt; 기능 &quot; 무료 전자 책을 확인하여 many_to_many , 스키마없는 쿼리, 동시 테스트 등과 같은 Ecto 2.1의 많은 기능에 대해 자세히 알아보십시오 . Ecto 3.0의 주요 변경 사항은 Elixir의 달력 유형을 선호하는 오래된 Ecto 날짜 시간 유형을 제거했기 때문에이 책은 여전히 ​​Ecto 3.0에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc99a9383f7a49a0f5304d5703304af8b357577" translate="yes" xml:space="preserve">
          <source>After modifying our config file, we need to restart our server in order for this change to take effect. After restarting the server, let's go to &lt;a href=&quot;http://localhost:4000/such/a/wrong/path&quot;&gt;http://localhost:4000/such/a/wrong/path&lt;/a&gt; for a running local application and see what we get.</source>
          <target state="translated">구성 파일을 수정 한 후이 변경 사항을 적용하려면 서버를 다시 시작해야합니다. 서버를 다시 시작한 후 실행중인 로컬 애플리케이션에 대해 &lt;a href=&quot;http://localhost:4000/such/a/wrong/path&quot;&gt;http : // localhost : 4000 / such / a / wrong / path&lt;/a&gt; 로 이동하여 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bdea6ffdf38afdd8a0ea1ddf12cc241f602f9239" translate="yes" xml:space="preserve">
          <source>After persisting &lt;code&gt;weather&lt;/code&gt; to the database, it will return a new copy of &lt;code&gt;%Weather{}&lt;/code&gt; with the primary key (the &lt;code&gt;id&lt;/code&gt;) set. We can use this value to read a struct back from the repository:</source>
          <target state="translated">&lt;code&gt;weather&lt;/code&gt; 를 데이터베이스에 유지 한 후 기본 키 ( &lt;code&gt;id&lt;/code&gt; )가 설정된 새 &lt;code&gt;%Weather{}&lt;/code&gt; 복사본을 반환합니다 . 이 값을 사용하여 저장소에서 구조체를 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda22db6835aca19ce8bec03b7cbe8f1e16ab622" translate="yes" xml:space="preserve">
          <source>After reloading &lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt;, we should see a very different page, one with no title, logo image, or css styling at all.</source>
          <target state="translated">&lt;a href=&quot;http://localhost:4000/&quot;&gt;http : // localhost : 4000 /을&lt;/a&gt; 다시로드 하면 제목, 로고 ​​이미지 또는 CSS 스타일이 전혀없는 매우 다른 페이지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c66edcfc2858cc5138aa21b5e8f79ef414cd14b3" translate="yes" xml:space="preserve">
          <source>After rendering the static page, LiveView connects from the client to the server where stateful views are spawned to push rendered updates to the browser, and receive client events via &lt;code&gt;phx-&lt;/code&gt; bindings. Just like the first rendering, &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is invoked with params, session, and socket state, where mount assigns values for rendering. However in the connected client case, a LiveView process is spawned on the server, pushes the result of &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; to the client and continues on for the duration of the connection. If at any point during the stateful life-cycle a crash is encountered, or the client connection drops, the client gracefully reconnects to the server, calling &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; once again.</source>
          <target state="translated">정적 페이지를 렌더링 한 후 LiveView는 클라이언트에서 상태 저장 뷰가 생성되는 서버에 연결하여 렌더링 된 업데이트를 브라우저에 푸시하고 &lt;code&gt;phx-&lt;/code&gt; 바인딩을 통해 클라이언트 이벤트를 수신합니다 . 첫 번째 렌더링과 마찬가지로 &lt;a href=&quot;#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 는 매개 변수, 세션 및 소켓 상태를 사용하여 호출됩니다. 여기서 mount는 렌더링 값을 할당합니다. 그러나 연결된 클라이언트의 경우 LiveView 프로세스가 서버에서 생성되고 &lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt; 의 결과를 클라이언트에 푸시 하고 연결 기간 동안 계속됩니다. 상태 저장 수명주기 중 어느 시점에서든 충돌이 발생하거나 클라이언트 연결이 끊어지면 클라이언트는 정상적으로 서버에 다시 연결하여 &lt;a href=&quot;#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 를 다시 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="afc8a3c116cb06fd08163a570db09643a9c02a4b" translate="yes" xml:space="preserve">
          <source>After the callback is invoked, the error is re-raised.</source>
          <target state="translated">콜백이 호출 된 후 오류가 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb9d6f19b212137313eaa3e9853e9ac315788ddf" translate="yes" xml:space="preserve">
          <source>After the client connects, &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; will be invoked inside a spawned LiveView process. At this point, you can use &lt;a href=&quot;#connected?/1&quot;&gt;&lt;code&gt;connected?/1&lt;/code&gt;&lt;/a&gt; to conditionally perform stateful work, such as subscribing to pubsub topics, sending messages, etc. For example, you can periodically update a LiveView with a timer:</source>
          <target state="translated">클라이언트가 연결되면 생성 된 LiveView 프로세스 내 에서 &lt;a href=&quot;#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 이 시점에서 &lt;a href=&quot;#connected?/1&quot;&gt; &lt;code&gt;connected?/1&lt;/code&gt; &lt;/a&gt; 를 사용 하여 pubsub 주제 구독, 메시지 보내기 등과 같은 상태 저장 작업을 조건부로 수행 할 수 있습니다. 예를 들어, 타이머를 사용하여 LiveView를 주기적으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de59739d4d270b220874ec766f302986a4a91d4" translate="yes" xml:space="preserve">
          <source>After this change, you must recompile plug:</source>
          <target state="translated">이 변경 후에는 플러그를 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="a23f504d0f093acbbb6fce5be9ab673b58ff415c" translate="yes" xml:space="preserve">
          <source>Again, if we add a key/value pair to the end of the function call, it is added to the query string.</source>
          <target state="translated">다시 말하지만, 함수 호출 끝에 키 / 값 쌍을 추가하면 쿼리 문자열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f26115df05290ceff8e59ff5a98695a4781e050a" translate="yes" xml:space="preserve">
          <source>Again, let's think of a function name that describes what we want to accomplish.</source>
          <target state="translated">다시 말하지만, 우리가 달성하고자하는 것을 설명하는 함수 이름을 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="7959cb53fcd6fb73c38fe9b93d515c18a416d2d0" translate="yes" xml:space="preserve">
          <source>Again, we can run this task with the &lt;code&gt;-r&lt;/code&gt; flag and another repo if we need to.</source>
          <target state="translated">다시 말하지만, 필요한 경우 &lt;code&gt;-r&lt;/code&gt; 플래그와 다른 repo를 사용 하여이 작업을 실행할 수 있습니다 . ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="252ef139af6f0fdc730b089eed9232ba35c0bc13" translate="yes" xml:space="preserve">
          <source>Aggregates: &lt;a href=&quot;#count/0&quot;&gt;&lt;code&gt;count/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sum/1&quot;&gt;&lt;code&gt;sum/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">집계 : &lt;a href=&quot;#count/0&quot;&gt; &lt;code&gt;count/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sum/1&quot;&gt; &lt;code&gt;sum/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e8415fa4e4b7fad95b1c595d45c2c52cfcfe2c3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;phx-&lt;/code&gt; event bindings apply their own css classes when pushed. For example the following markup:</source>
          <target state="translated">모든 &lt;code&gt;phx-&lt;/code&gt; 이벤트 바인딩은 푸시 될 때 자체 CSS 클래스를 적용합니다. 예를 들어 다음 마크 업 :</target>
        </trans-unit>
        <trans-unit id="a4d268907b39f21873cee1e69528e4ae39983cee" translate="yes" xml:space="preserve">
          <source>All HTTP requests start in our application endpoint. You can find it as a module named &lt;code&gt;HelloWeb.Endpoint&lt;/code&gt; in &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt;. Once you open up the endpoint file, you will see that, similar to the router, the endpoint has many calls to &lt;code&gt;plug&lt;/code&gt;. &lt;a href=&quot;../plug/plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; is a library and specification for stitching web applications together. It is an essential part of how Phoenix handles requests and we will discuss it in detail &lt;a href=&quot;plug&quot;&gt;in the Plug guide&lt;/a&gt; coming next.</source>
          <target state="translated">모든 HTTP 요청은 애플리케이션 엔드 포인트에서 시작됩니다. &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt; 에서 &lt;code&gt;HelloWeb.Endpoint&lt;/code&gt; 라는 모듈로 찾을 수 있습니다 . 엔드 포인트 파일을 열면 라우터와 유사하게 엔드 포인트에 &lt;code&gt;plug&lt;/code&gt; 에 대한 많은 호출이 있음을 알 수 있습니다. &lt;a href=&quot;../plug/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 는 웹 애플리케이션을 함께 연결하기위한 라이브러리 및 사양입니다. 이것은 Phoenix가 요청을 처리하는 방법의 필수적인 부분이며 다음에 나오는 &lt;a href=&quot;plug&quot;&gt;Plug 가이드&lt;/a&gt; 에서 자세히 논의 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c172a0bad59b89ef6d9a76d5ce1da6b2bf7d1af3" translate="yes" xml:space="preserve">
          <source>All adapters are required to implement a clause for :binary_id types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">모든 어댑터는 어댑터마다 다르기 때문에 : binary_id 유형에 대한 절을 구현해야합니다. 어댑터가 이진 ID를 제공하지 않으면 간단히 &lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69c12b3b6c00c84ec71486ef08e3c19bbae79e25" translate="yes" xml:space="preserve">
          <source>All adapters are required to implement a clause for &lt;code&gt;:binary_id&lt;/code&gt; types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">모든 어댑터는 어댑터마다 &lt;code&gt;:binary_id&lt;/code&gt; 때문에 : binary_id 유형에 대한 절을 구현해야합니다 . 어댑터가 이진 ID를 제공하지 않으면 간단히 &lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ab4c8d0ec0fc810d465b494368a4623df96ffed" translate="yes" xml:space="preserve">
          <source>All controller actions take two arguments. The first is &lt;code&gt;conn&lt;/code&gt;, a struct which holds a ton of data about the request. The second is &lt;code&gt;params&lt;/code&gt;, which are the request parameters. Here, we are not using &lt;code&gt;params&lt;/code&gt;, and we avoid compiler warnings by adding the leading &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">모든 컨트롤러 작업은 두 가지 인수를 사용합니다. 첫 번째는 요청에 대한 수많은 데이터를 보유하는 구조체 인 &lt;code&gt;conn&lt;/code&gt; 입니다. 두 번째는 요청 매개 변수 인 &lt;code&gt;params&lt;/code&gt; 입니다. 여기에서는 &lt;code&gt;params&lt;/code&gt; 를 사용하지 않으며 선행 &lt;code&gt;_&lt;/code&gt; 을 추가하여 컴파일러 경고를 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="0d45225e1467161970b40e45c5803f0dbfd88ffa" translate="yes" xml:space="preserve">
          <source>All endpoints are configured in your application environment. For example:</source>
          <target state="translated">모든 엔드 포인트는 애플리케이션 환경에서 구성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b09c1ec9758d43f4962774adb6d17753fba520f" translate="yes" xml:space="preserve">
          <source>All event callbacks are run in the same process that calls the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro; hence, instrumenters should be careful to avoid performing blocking actions. If an event callback fails in any way (exits, throws, or raises), it won&amp;rsquo;t affect anything as the error is caught, but the failure will be logged. Note that &amp;ldquo;after&amp;rdquo; callbacks are not guaranteed to be called as, for example, a link may break before they&amp;rsquo;ve been called.</source>
          <target state="translated">모든 이벤트 콜백은 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로 를 호출하는 동일한 프로세스에서 실행됩니다 . 따라서 계측기는 차단 작업을 수행하지 않도록주의해야합니다. 이벤트 콜백이 어떤 식 으로든 실패하면 (종료, 발생 또는 발생) 오류가 발생해도 아무 영향을 미치지 않지만 실패는 기록됩니다. 예를 들어, 링크가 호출되기 전에 링크가 끊어 질 수 있으므로 &quot;후&quot;콜백이 호출되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c602e54c21759c3a3e81e03de5c0cba22e852a4f" translate="yes" xml:space="preserve">
          <source>All events can be rate-limited on the client by using the &lt;code&gt;phx-debounce&lt;/code&gt; and &lt;code&gt;phx-throttle&lt;/code&gt; bindings, with the following behavior:</source>
          <target state="translated">모든 이벤트는 다음 동작으로 &lt;code&gt;phx-debounce&lt;/code&gt; 및 &lt;code&gt;phx-throttle&lt;/code&gt; 바인딩 을 사용하여 클라이언트에서 속도를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad7544f2dd291d98846f1fadb6ce98ab43a5d856" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying input, default values are provided for id, name and textarea content if possible.</source>
          <target state="translated">주어진 모든 옵션은 기본 입력으로 전달되며 가능한 경우 id, name 및 textarea content에 대한 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="813dc7e9919c783a01744c6de9aa6e536e1981be" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying input, default values are provided for id, name and value if possible.</source>
          <target state="translated">주어진 모든 옵션은 기본 입력으로 전달되며 가능한 경우 id, name 및 value에 대한 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9f5563600902eea5e57e862ead255e4eba991ece" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying tag. A default value is provided for &lt;code&gt;for&lt;/code&gt; attribute but can be overriden if you pass a value to the &lt;code&gt;for&lt;/code&gt; option. Text content would be inferred from &lt;code&gt;field&lt;/code&gt; if not specified.</source>
          <target state="translated">주어진 모든 옵션은 기본 태그로 전달됩니다. 기본 값은 제공됩니다 &lt;code&gt;for&lt;/code&gt; 속성하지만 당신은에 값을 전달하면 오버라이드 (override) 할 수 있습니다 &lt;code&gt;for&lt;/code&gt; 옵션을 선택합니다. 지정하지 않으면 텍스트 내용이 &lt;code&gt;field&lt;/code&gt; 에서 유추 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1d5f62ff32c78721a5a9fe3e9145cb94c0df7f" translate="yes" xml:space="preserve">
          <source>All layouts must call &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; to inject the content rendered by the layout.</source>
          <target state="translated">모든 레이아웃은 &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; 를 호출 하여 레이아웃에 의해 렌더링 된 콘텐츠를 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="e79ca9879a7fed3a2fbfd722b280d01bd7565c08" translate="yes" xml:space="preserve">
          <source>All measurements are given in the &lt;code&gt;:native&lt;/code&gt; time unit. You can read more about it in the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 측정은 &lt;code&gt;:native&lt;/code&gt; 시간 단위로 제공됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 문서에서 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="499393acc73825c4c36e7d2c38f112f85ee41bf0" translate="yes" xml:space="preserve">
          <source>All names must be unique between both structures.</source>
          <target state="translated">모든 이름은 두 구조간에 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="8db0c93c2441d2db62c9efdff79f4e349d222d42" translate="yes" xml:space="preserve">
          <source>All of Phoenix configuration, except the Compile-time configuration below can be set dynamically from the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">아래 컴파일 시간 구성을 제외한 모든 Phoenix 구성은 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 콜백 에서 동적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d326ac593831af17363500f0a14d30fbbe28b9a" translate="yes" xml:space="preserve">
          <source>All of the &lt;code&gt;assigns&lt;/code&gt; given are forwarded directly to the &lt;code&gt;live_component&lt;/code&gt;:</source>
          <target state="translated">주어진 모든 &lt;code&gt;assigns&lt;/code&gt; 은 &lt;code&gt;live_component&lt;/code&gt; 로 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb9f406d1a62409ed175f5228b87871665950184" translate="yes" xml:space="preserve">
          <source>All of the data in a LiveView is stored in the socket as assigns. The &lt;a href=&quot;phoenix.liveview#assign/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.assign/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#assign/3&quot;&gt;&lt;code&gt;Phoenix.LiveView.assign/3&lt;/code&gt;&lt;/a&gt; functions help store those values. Those values can be accessed in the LiveView as &lt;code&gt;socket.assigns.name&lt;/code&gt; but they are accessed inside LiveView templates as &lt;code&gt;@name&lt;/code&gt;.</source>
          <target state="translated">LiveView의 모든 데이터는 할당 된대로 소켓에 저장됩니다. &lt;a href=&quot;phoenix.liveview#assign/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.assign/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phoenix.liveview#assign/3&quot;&gt; &lt;code&gt;Phoenix.LiveView.assign/3&lt;/code&gt; &lt;/a&gt; 기능에 도움을 저장하는 값. 이러한 값은 LiveView에서 &lt;code&gt;socket.assigns.name&lt;/code&gt; 으로 액세스 할 수 있지만 LiveView 템플릿 내에서 &lt;code&gt;@name&lt;/code&gt; 으로 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9361d164562daf4b061c64bab712118835ec777" translate="yes" xml:space="preserve">
          <source>All of the files which are currently in the &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;templates&lt;/code&gt;, and &lt;code&gt;views&lt;/code&gt; directories are there to create the &quot;Welcome to Phoenix!&quot; page we saw in the &quot;Up and running&quot; guide. The &lt;code&gt;channels&lt;/code&gt; directory is where we will add code related to building real-time Phoenix applications.</source>
          <target state="translated">현재 &lt;code&gt;controllers&lt;/code&gt; , &lt;code&gt;templates&lt;/code&gt; 및 &lt;code&gt;views&lt;/code&gt; 디렉토리 에있는 모든 파일 은 &quot;Welcome to Phoenix!&quot;를 만들기 위해 있습니다. &quot;설치 및 실행&quot;가이드에서 본 페이지입니다. &lt;code&gt;channels&lt;/code&gt; 디렉토리는 우리가 실시간 피닉스 응용 프로그램을 구축하는 관련 코드를 추가 곳입니다.</target>
        </trans-unit>
        <trans-unit id="d51449954d7b0982db1a36b8fd5c9a56660ab117" translate="yes" xml:space="preserve">
          <source>All of the imports and aliases we make in our view will also be available in our templates. That's because templates are effectively compiled into functions inside their respective views. For example, if you define a function in your view, you will be able to invoke it directly from the template. Let's see this in practice.</source>
          <target state="translated">뷰에서 만든 모든 가져 오기 및 별칭은 템플릿에서도 사용할 수 있습니다. 템플릿이 각 뷰 내의 함수로 효과적으로 컴파일되기 때문입니다. 예를 들어 뷰에서 함수를 정의하면 템플릿에서 직접 호출 할 수 있습니다. 이것을 실제로 봅시다.</target>
        </trans-unit>
        <trans-unit id="c19589522633ca77d3991d5f5b28ef40ee94b972" translate="yes" xml:space="preserve">
          <source>All of these files are our static assets. Now let's run the &lt;a href=&quot;mix.tasks.phx.digest&quot;&gt;&lt;code&gt;mix phx.digest&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">이 모든 파일은 우리의 정적 자산입니다. 이제 &lt;a href=&quot;mix.tasks.phx.digest&quot;&gt; &lt;code&gt;mix phx.digest&lt;/code&gt; &lt;/a&gt; 작업을 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="10b993f627ba62806b1f8752d0a4bbd00b261025" translate="yes" xml:space="preserve">
          <source>All of those types are represented by the same timestamp/datetime in the underlying data storage, the difference are in their precision and how the data is loaded into Elixir.</source>
          <target state="translated">이러한 모든 유형은 기본 데이터 저장소에서 동일한 타임 스탬프 / 날짜 시간으로 표시되며 차이는 정밀도와 데이터가 Elixir에로드되는 방식에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e2d3cafbf3b1257c66222879054524fa83042b" translate="yes" xml:space="preserve">
          <source>All operations will be executed in the order they were added.</source>
          <target state="translated">모든 작업은 추가 된 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcf9cd3751eb31bdc1527fb2f1dc7715bab71c1" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying button tag.</source>
          <target state="translated">모든 옵션은 기본 버튼 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="422eebfcbf3c24c00aab6148bd4fb9a777d80147" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying button tag. When called with a &lt;code&gt;do:&lt;/code&gt; block, the button tag options come first.</source>
          <target state="translated">모든 옵션은 기본 버튼 태그로 전달됩니다. &lt;code&gt;do:&lt;/code&gt; 블록으로 호출 하면 버튼 태그 옵션이 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="522ddbe1f1dfe285f4aa9236aba2fc9ba59e6950" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying input tag.</source>
          <target state="translated">모든 옵션은 기본 입력 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ea466da3a996e67a1497fcb65a8eac06f270b70a" translate="yes" xml:space="preserve">
          <source>All options are passed directly to the &lt;a href=&quot;../phoenix/phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; constructor, except for the following LiveView specific options:</source>
          <target state="translated">다음 LiveView 특정 옵션을 제외하고 모든 옵션은 &lt;a href=&quot;../phoenix/phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt; 생성자에 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7009b3da1def9b1ee6d1bd825e69020e72baee8d" translate="yes" xml:space="preserve">
          <source>All options are simply forwarded to the underlying HTML tag.</source>
          <target state="translated">모든 옵션은 단순히 기본 HTML 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="558de1b31a7f35b365da32ef41bf2e958a244056" translate="yes" xml:space="preserve">
          <source>All options can be pre-configured by setting &lt;code&gt;@timestamps_opts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@timestamps_opts&lt;/code&gt; 를 설정하여 모든 옵션을 사전 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28bc82a547f8d0a9365fca95f1387101711c40f1" translate="yes" xml:space="preserve">
          <source>All options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt; are also supported here. They are repeated here for convenience:</source>
          <target state="translated">&lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; &lt;/a&gt; 가 지원하는 모든 옵션 도 여기에서 지원됩니다. 편의를 위해 여기에 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="26fa0e94a406535f7bfd860c9bddab30dd1bbfc7" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the LiveView for rendering. Refer to &lt;a href=&quot;phoenix.liveview.helpers#live_render/3&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_render/3&lt;/code&gt;&lt;/a&gt; for a list of supported render options.</source>
          <target state="translated">다른 모든 옵션은 렌더링을 위해 LiveView로 전달됩니다. 지원되는 렌더링 옵션 목록은 &lt;a href=&quot;phoenix.liveview.helpers#live_render/3&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_render/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c88f2411e8c83ee2c14ec0b1738ea5968198922f" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the anchor tag.</source>
          <target state="translated">다른 모든 옵션은 앵커 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="45cc7909dee625c35daed3413858b850ca7b70cf" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">다른 모든 옵션은 기본 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0de8e7fa31635bbc8b9cb09d4c14202e448a3833" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying HTML tag.</source>
          <target state="translated">다른 모든 옵션은 기본 HTML 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6f0461c97a5f7c04f3543b8d31b32467f48a927a" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying button input.</source>
          <target state="translated">다른 모든 옵션은 기본 버튼 입력으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d3cdbef73beb37bb98e96f11d133934f74a806ca" translate="yes" xml:space="preserve">
          <source>All other options are forwarded. See &lt;a href=&quot;#text_input/3&quot;&gt;&lt;code&gt;text_input/3&lt;/code&gt;&lt;/a&gt; for example and docs.</source>
          <target state="translated">다른 모든 옵션이 전달됩니다. 예를 들어, 문서는 &lt;a href=&quot;#text_input/3&quot;&gt; &lt;code&gt;text_input/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5ce54eed717637497450620d027b4dc6f39dc64" translate="yes" xml:space="preserve">
          <source>All other options are passed to the underlying HTML tag.</source>
          <target state="translated">다른 모든 옵션은 기본 HTML 태그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f06429df7c982138e6fece80594cc2823997c039" translate="yes" xml:space="preserve">
          <source>All other types and dynamic values must be passed as a parameter using interpolation as explained below.</source>
          <target state="translated">다른 모든 유형과 동적 값은 아래 설명과 같이 보간을 사용하여 매개 변수로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e0ed724d9fd7f66ef5b095b68eed5927f535ac7" translate="yes" xml:space="preserve">
          <source>All paths that match the forwarded prefix will be sent to the forwarded plug. This is useful for sharing a router between applications or even breaking a big router into smaller ones. The router pipelines will be invoked prior to forwarding the connection.</source>
          <target state="translated">전달 된 접두사와 일치하는 모든 경로가 전달 된 플러그로 전송됩니다. 응용 프로그램간에 라우터를 공유하거나 큰 라우터를 작은 라우터로 나누는 데 유용합니다. 연결을 전달하기 전에 라우터 파이프 라인이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62b34ea36e859428b611c71d81b082ea47b9c097" translate="yes" xml:space="preserve">
          <source>All presences for a given Pid can be untracked by calling the &lt;a href=&quot;phoenix.tracker#untrack/2&quot;&gt;&lt;code&gt;Phoenix.Tracker.untrack/2&lt;/code&gt;&lt;/a&gt; signature of this function.</source>
          <target state="translated">이 함수 의 &lt;a href=&quot;phoenix.tracker#untrack/2&quot;&gt; &lt;code&gt;Phoenix.Tracker.untrack/2&lt;/code&gt; &lt;/a&gt; 서명을 호출하면 주어진 Pid에 대한 모든 존재를 추적 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6a339d2d44001129cb1c12faf11686559a271e99" translate="yes" xml:space="preserve">
          <source>All routes are compiled to a match function that receives three arguments: the method, the request path split on &lt;code&gt;/&lt;/code&gt; and the connection. Consider this example:</source>
          <target state="translated">모든 경로는 메소드, 요청 경로가 &lt;code&gt;/&lt;/code&gt; 및 연결의 세 가지 인수를받는 일치 함수로 컴파일됩니다 . 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d12952e472708b80423f06432a2383dee2f914b2" translate="yes" xml:space="preserve">
          <source>All serialized, remote client messages should be deserialized and forwarded through this function by adapters.</source>
          <target state="translated">모든 직렬화 된 원격 클라이언트 메시지는이 기능을 통해 직렬화 해제되고 어댑터에 의해 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="93047db332d3fa7598466b439197809e8a9cb06e" translate="yes" xml:space="preserve">
          <source>All the instrumenter modules that export a &lt;code&gt;render_view/3&lt;/code&gt; function will be notified of the event so that they can perform their respective actions.</source>
          <target state="translated">&lt;code&gt;render_view/3&lt;/code&gt; 함수 를 내보내는 모든 인스트루먼트 모듈은 해당 조치를 수행 할 수 있도록 이벤트에 대한 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="cb13a27a6b2fabbab41cab0702575683d1146342" translate="yes" xml:space="preserve">
          <source>All these parameters, including the global defaults mentioned above, can be overridden by specifying custom &lt;code&gt;:ssl&lt;/code&gt; configuration options.</source>
          <target state="translated">위에서 언급 한 전역 기본값을 포함하여 이러한 모든 매개 변수는 사용자 정의 &lt;code&gt;:ssl&lt;/code&gt; 구성 옵션 을 지정하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee5dcdc1845852a6cf857d54a045b05a91fe4b6" translate="yes" xml:space="preserve">
          <source>Allows a field to be dynamically accessed</source>
          <target state="translated">필드에 동적으로 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="500d682f2e570192910057021d322d492c7d8b70" translate="yes" xml:space="preserve">
          <source>Allows a field to be dynamically accessed.</source>
          <target state="translated">필드에 동적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0feeacfc10a32e5cfe789e8b160f86661a34f0f9" translate="yes" xml:space="preserve">
          <source>Allows instrumenting operation defined by &lt;code&gt;function&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 정의 된 계측 작업 가능</target>
        </trans-unit>
        <trans-unit id="a267a50bfe0914d97c375bc375ed4341bebf430f" translate="yes" xml:space="preserve">
          <source>Allows instrumenting operation defined by &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 정의 된 계측 작업을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="e9d7b7bbf93231434f82632551b53bdeb2d392f3" translate="yes" xml:space="preserve">
          <source>Almost all of the repository functions outlined in this module accept the following options:</source>
          <target state="translated">이 모듈에 설명 된 거의 모든 저장소 기능은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="008d76871a9d79cfc587210844bce1eeecbd67bd" translate="yes" xml:space="preserve">
          <source>Almost all of the repository operations below accept the following options:</source>
          <target state="translated">아래의 거의 모든 리포지토리 작업은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="11b63d2e626bbf29994f29ed30f1ba4744b7a184" translate="yes" xml:space="preserve">
          <source>Also note that if &lt;code&gt;:on_conflict&lt;/code&gt; is a query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query.</source>
          <target state="translated">또한 &lt;code&gt;:on_conflict&lt;/code&gt; 가 쿼리 인 경우 MySQL은 시도 된 항목 수와 UPDATE 쿼리에 의해 수정 된 항목 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81baec4d7ec64823c1289f28fd5d3c4cb6bd701b" translate="yes" xml:space="preserve">
          <source>Also note the given &lt;code&gt;:id&lt;/code&gt; is not necessarily used as the DOM ID. If you want to set a DOM ID, it is your responsibility to set it when rendering:</source>
          <target state="translated">또한 주어진 &lt;code&gt;:id&lt;/code&gt; 가 반드시 DOM ID로 사용되는 것은 아닙니다. DOM ID를 설정하려면 렌더링 할 때이를 설정하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="8b9be8e8ffe8be69521563d9ef94e7723bf5a909" translate="yes" xml:space="preserve">
          <source>Also notice that these pages are going to be shown in production. If you are looking for error handling to help during development, consider using &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한이 페이지는 프로덕션에 표시 될 것입니다. 개발 중에 도움이되는 오류 처리를 찾고 있다면 &lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; 사용을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="22cd88359c4a50b92411312b68b7a8bbbdb9b33f" translate="yes" xml:space="preserve">
          <source>Also, change &lt;code&gt;lib/hello/cms/page.ex&lt;/code&gt; to remove &lt;code&gt;:views&lt;/code&gt; from the permitted params:</source>
          <target state="translated">또한 &lt;code&gt;lib/hello/cms/page.ex&lt;/code&gt; 를 변경 하여 허용 된 매개 변수에서 &lt;code&gt;:views&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2a173642ed7a4ddf0000bbbe1795e679a521c855" translate="yes" xml:space="preserve">
          <source>Also, most adapters provide direct APIs for queries, like &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt;, allowing developers to completely bypass Ecto queries.</source>
          <target state="translated">또한 대부분의 어댑터는 &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt; 와 같은 쿼리에 대한 직접 API를 제공 하므로 개발자가 Ecto 쿼리를 완전히 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd52f213e28e01580c031fd88b310e77b168c916" translate="yes" xml:space="preserve">
          <source>Also, since the store is in-memory, it means sessions are not shared between servers. If you deploy to more than one machine, using this store is again not recommended.</source>
          <target state="translated">또한 저장소가 메모리에 있기 때문에 서버간에 세션이 공유되지 않습니다. 둘 이상의 머신에 배치하는 경우이 저장소를 다시 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a8cf34f26d13a0056310f2520c841766dc8c37c" translate="yes" xml:space="preserve">
          <source>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let&amp;rsquo;s start over and define a new Comment schema:</source>
          <target state="translated">또는 Ecto가 스키마를 주어진 테이블에 연결하지 않기 때문에 각 연관에 대해 별도의 테이블을 사용할 수 있습니다. 다시 시작하고 새로운 주석 스키마를 정의 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f304a61eac0b8370145fa3e55918d747117ffe93" translate="yes" xml:space="preserve">
          <source>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let's start over and define a new Comment schema:</source>
          <target state="translated">또는 Ecto는 스키마를 주어진 테이블에 연결하지 않기 때문에 각 연결에 대해 별도의 테이블을 사용할 수 있습니다. 다시 시작하고 새 Comment 스키마를 정의 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="321dd6338631d0cf6375c9af526cc1849ab8b29e" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't have a connection, you can pass &lt;code&gt;:foo&lt;/code&gt; as the form data source and explicitly pass the value for every input:</source>
          <target state="translated">또는 연결이없는 경우 &lt;code&gt;:foo&lt;/code&gt; 를 양식 데이터 소스로 전달하고 모든 입력에 대한 값을 명시 적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5169095178c6c8c94640863a129d86d2a2dae9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of having the component directly send a message to the parent, the component could broadcast the update using &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;. Such as:</source>
          <target state="translated">또는 구성 요소가 부모에게 직접 메시지를 보내도록하는 대신 구성 요소가 &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 를&lt;/a&gt; 사용하여 업데이트를 브로드 캐스트 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8d9e91e29aab7f205ddafcbe7467410ed8756db7" translate="yes" xml:space="preserve">
          <source>Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database:</source>
          <target state="translated">또는 별도의 쿼리로 데이터베이스에서 데이터를 다시 읽습니다. 이 옵션을 사용하려면 데이터베이스에서 기본 키를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="96b57a7146f6ce2d246b6a8f8a80250e9febe6b8" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;--context-app&lt;/code&gt; option may be supplied to the generator:</source>
          <target state="translated">또는 &lt;code&gt;--context-app&lt;/code&gt; 옵션을 생성기에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6614e2051b53d4085816bb5cbdd8196885f12ba0" translate="yes" xml:space="preserve">
          <source>Alternatively, the OpenSSL CLI or other utilities can be used to generate a self-signed certificate. Instructions are widely available online.</source>
          <target state="translated">또는 OpenSSL CLI 또는 기타 유틸리티를 사용하여 자체 서명 된 인증서를 생성 할 수 있습니다. 지침은 온라인에서 광범위하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="910b77d9dd831282aea4711919085610ee3b22d6" translate="yes" xml:space="preserve">
          <source>Alternatively, the root layout can be passed individually to the &lt;code&gt;live&lt;/code&gt; macro of your &lt;strong&gt;live routes&lt;/strong&gt;:</source>
          <target state="translated">또는 루트 레이아웃을 &lt;strong&gt;라이브 경로&lt;/strong&gt; 의 &lt;code&gt;live&lt;/code&gt; 매크로에 개별적으로 전달할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9acd6358ace335206d78edde3fec71a9150e3da0" translate="yes" xml:space="preserve">
          <source>Alternatively, we can make sure that when we create a comment, it is already associated to the post:</source>
          <target state="translated">또는 주석을 작성할 때 주석이 이미 게시물과 연관되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc05913dcdaaade0ac224b9471c84283def29199" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;code&gt;live_render&lt;/code&gt; from any template:</source>
          <target state="translated">또는 템플릿에서 &lt;code&gt;live_render&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3dcc6126e45a81167622b0e7f1ed0c26c4277a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can continue reading these guides to have a quick introduction into all the parts that make your Phoenix application. If that's the case, you can read the guides in any order or start with our guide that explains the &lt;a href=&quot;directory_structure&quot;&gt;Phoenix directory structure&lt;/a&gt;.</source>
          <target state="translated">또는이 가이드를 계속 읽으면 Phoenix 애플리케이션을 구성하는 모든 부품에 대한 간략한 소개를받을 수 있습니다. 이 경우 가이드를 순서에 관계없이 읽거나 &lt;a href=&quot;directory_structure&quot;&gt;Phoenix 디렉토리 구조&lt;/a&gt; 를 설명하는 가이드로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f69c752723942f38a03a10f6c3ef30bc5e097d42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can give both &lt;code&gt;unique_index&lt;/code&gt; and &lt;code&gt;unique_constraint&lt;/code&gt; the same name:</source>
          <target state="translated">또는 &lt;code&gt;unique_index&lt;/code&gt; 와 &lt;code&gt;unique_constraint&lt;/code&gt; 에 동일한 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6efb46ef343f6ed0e3216dfe518786d8f03f09e1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can keep the &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; callback but delegate to an existing &lt;a href=&quot;../phoenix/phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; module in your application. For example:</source>
          <target state="translated">또는 &lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt; 콜백을 유지하면서 애플리케이션 의 기존 &lt;a href=&quot;../phoenix/phoenix.view&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt; 모듈에 위임 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="155429fd793002e8c29430c2e209cabe0d391fe9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;code&gt;@foreign_key_type EncodedId&lt;/code&gt; after &lt;code&gt;@primary_key&lt;/code&gt; to automatically configure the type of all &lt;code&gt;belongs_to&lt;/code&gt; fields.</source>
          <target state="translated">다른 방법으로는 설정할 수 있습니다 &lt;code&gt;@foreign_key_type EncodedId&lt;/code&gt; 을 한 후 &lt;code&gt;@primary_key&lt;/code&gt; 자동으로 모든 유형 구성 &lt;code&gt;belongs_to&lt;/code&gt; 의 필드.</target>
        </trans-unit>
        <trans-unit id="93e785a14001e49c9b84753b2825d9f6cb5b13bb" translate="yes" xml:space="preserve">
          <source>Alternatively, you could define a &lt;code&gt;plug_status&lt;/code&gt; field directly in the exception struct:</source>
          <target state="translated">또는 예외 구조에서 직접 &lt;code&gt;plug_status&lt;/code&gt; 필드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a4516cb4d9630fe735eff5b37d5a2a87dbfc11" translate="yes" xml:space="preserve">
          <source>Alternatively, you could invoke only the Endpoint, and Router:</source>
          <target state="translated">또는 엔드 포인트 및 라우터 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8738df28b370bcf5efa3bfda949331ffc50808f" translate="yes" xml:space="preserve">
          <source>Alternatively, you could only invoke the Endpoint's plugs:</source>
          <target state="translated">또는 엔드 포인트의 플러그 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b850ace8350ffbceab4c0b79db20ea808bef7c" translate="yes" xml:space="preserve">
          <source>Alternatively, you may just want to ack the status of the operation:</source>
          <target state="translated">또는 작업 상태를 확인하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34317bebd405610c93dc7524d10be7d18f71d8c" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;#get_session/2&quot;&gt;&lt;code&gt;get_session/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#put_session/3&quot;&gt;&lt;code&gt;put_session/3&lt;/code&gt;&lt;/a&gt; allow atom keys, they are always normalized to strings. So this function always returns a map with string keys.</source>
          <target state="translated">비록 &lt;a href=&quot;#get_session/2&quot;&gt; &lt;code&gt;get_session/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#put_session/3&quot;&gt; &lt;code&gt;put_session/3&lt;/code&gt; &lt;/a&gt; 원자 키를 허용, 그들은 항상 문자열로 정규화된다. 따라서이 함수는 항상 문자열 키가있는 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b82e0c2efff897466ba5c521ebd48ecd4d5d5b5" translate="yes" xml:space="preserve">
          <source>Although bindings are extremely useful when working with joins, they are not necessary when the query has only the &lt;code&gt;from&lt;/code&gt; clause. For such cases, Ecto supports a way for building queries without specifying the binding:</source>
          <target state="translated">조인 작업시 바인딩은 매우 유용하지만 쿼리에 &lt;code&gt;from&lt;/code&gt; 절만 있는 경우에는 바인딩이 필요하지 않습니다 . 이러한 경우 Ecto는 바인딩을 지정하지 않고 쿼리를 작성하는 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1f64f45f378a0ba87745eec7c28990a06414ce18" translate="yes" xml:space="preserve">
          <source>Although forms provide the &lt;code&gt;accept-charset&lt;/code&gt; attribute, which we set to UTF-8, Internet Explorer 5 up to 8 may ignore the value of this attribute if the user chooses their browser to do so. This ends up triggering the browser to send data in a format that is not understandable by the server.</source>
          <target state="translated">양식은 &lt;code&gt;accept-charset&lt;/code&gt; 속성을 제공하지만 UTF-8로 설정 했지만 Internet Explorer 5에서 최대 8까지는 사용자가 브라우저를 선택하면이 속성의 값을 무시할 수 있습니다. 이로 인해 서버가 이해할 수없는 형식으로 데이터를 보내도록 브라우저가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="17d3aa2c2d04f2fcc928e33bb2ddcbcbfc203565" translate="yes" xml:space="preserve">
          <source>Although in the example above we have directly inserted and deleted the struct in the repository, operations on top of schemas are done through changesets so Ecto can efficiently track changes.</source>
          <target state="translated">위의 예에서 저장소에 구조체를 직접 삽입하고 삭제했지만 스키마 상단의 작업은 변경 세트를 통해 수행되므로 Ecto는 변경을 효율적으로 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9d520b19f1b97df56a3c0d2d0343f82052d807" translate="yes" xml:space="preserve">
          <source>Although it accepts an &lt;code&gt;opts&lt;/code&gt; argument, there are no options currently supported by &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 인수를 허용하지만 현재 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 에서 지원하는 옵션이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c9be422a570b817ed3d855feb6098dce936d8989" translate="yes" xml:space="preserve">
          <source>Although subqueries are not allowed in WHERE expressions, most subqueries in WHERE expression can be rewritten as JOINs. Imagine you want to write this query:</source>
          <target state="translated">WHERE 표현식에서는 서브 쿼리가 허용되지 않지만 WHERE 표현식의 대부분의 서브 쿼리는 JOIN으로 재 작성 될 수 있습니다. 이 쿼리를 작성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="38d0db682914b6a090cc5cf3303e1cf56459aa19" translate="yes" xml:space="preserve">
          <source>Although the root layout is not updated by LiveView, by simply assigning to &lt;code&gt;page_title&lt;/code&gt;, LiveView knows you want the title to be updated:</source>
          <target state="translated">루트 레이아웃은 LiveView에 의해 업데이트되지 않지만 단순히 &lt;code&gt;page_title&lt;/code&gt; 에 할당하면 LiveView는 제목이 업데이트되기를 원한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2a66e6d0030e1b4305c62e74a0858c305811a6" translate="yes" xml:space="preserve">
          <source>Although this function accepts an &lt;code&gt;opts&lt;/code&gt; argument, there are no options currently supported by &lt;a href=&quot;#put_embed/4&quot;&gt;&lt;code&gt;put_embed/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;opts&lt;/code&gt; 인수를 허용하지만 &lt;a href=&quot;#put_embed/4&quot;&gt; &lt;code&gt;put_embed/4&lt;/code&gt; 가&lt;/a&gt; 현재 지원하는 옵션은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0641530ad7e78210b89579523486c166e2b46440" translate="yes" xml:space="preserve">
          <source>Although using fragments in joins is discouraged in favor of Ecto Query syntax, they are necessary when writing lateral joins as lateral joins require a subquery that refer to previous bindings:</source>
          <target state="translated">Ecto Query 구문을 선호하는 경우 조인에서 조각을 사용하지 않는 것이 좋지만 측면 조인은 이전 바인딩을 참조하는 하위 쿼리가 필요하므로 측면 조인을 작성할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="55d091c50c4e2abce0a3176b2d62d4cfb4bd4e84" translate="yes" xml:space="preserve">
          <source>Although we have passed empty lists as options (they are required), you could pass any option there and it would be given to the underlying select input.</source>
          <target state="translated">빈 목록을 옵션으로 전달했지만 (필수), 옵션을 전달할 수 있으며 기본 선택 입력에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="140149a20a6971f6d5a40d50bec976229608679d" translate="yes" xml:space="preserve">
          <source>Although we used the &lt;code&gt;:through&lt;/code&gt; association in the example above, Ecto also allows developers to dynamically build the through associations using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">위 예제에서 &lt;code&gt;:through&lt;/code&gt; 연관을 사용했지만 Ecto를 사용하면 개발자가 &lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 스루 연관을 동적으로 빌드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aeef3747bb3efd51e4e60eff7db9a330f2778ae5" translate="yes" xml:space="preserve">
          <source>Always use this function when you need to access the operations you have defined in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt;. Inspecting the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct internals directly is discouraged.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 에서 정의한 작업에 액세스해야 할 때 항상이 함수를 사용하십시오 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 구조체 내부를 직접 검사하는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24fba89e4fce0a2ce2702abaf702532a39ce135c" translate="yes" xml:space="preserve">
          <source>Always use this function when you need to access the operations you have defined in &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt;. Inspecting the &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct internals directly is discouraged.</source>
          <target state="translated">&lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 에서 정의한 작업에 액세스해야 할 때 항상이 기능을 사용하십시오 . &lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 구조체 내부를 직접 검사하는 것은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5e6980a6207bfda1df7d8524d322c342c91585" translate="yes" xml:space="preserve">
          <source>An AND having query expression</source>
          <target state="translated">쿼리 표현식이있는 AND</target>
        </trans-unit>
        <trans-unit id="ff58307b231d1a6631bb29744d6ded1a8700a2d2" translate="yes" xml:space="preserve">
          <source>An AND having query expression.</source>
          <target state="translated">쿼리 표현식이있는 AND입니다.</target>
        </trans-unit>
        <trans-unit id="d7200124991255eec599c4a84169b97fd56a8907" translate="yes" xml:space="preserve">
          <source>An AND where query expression</source>
          <target state="translated">AND where 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="8369e04976e5489b84e7a49a7bab27b831a68025" translate="yes" xml:space="preserve">
          <source>An AND where query expression.</source>
          <target state="translated">AND where 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="118c95ad3087fa9270f38101f192fcebb74c98f7" translate="yes" xml:space="preserve">
          <source>An Ecto Example</source>
          <target state="translated">Ecto 예제</target>
        </trans-unit>
        <trans-unit id="85f6b794368cf376b191f2b1a8caf6b0c1cae948" translate="yes" xml:space="preserve">
          <source>An Ecto schema is used to map any data source into an Elixir struct. The definition of the schema is possible through two main APIs: &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ecto 스키마는 모든 데이터 소스를 Elixir 구조체에 매핑하는 데 사용됩니다. 스키마의 정의는 &lt;a href=&quot;#schema/2&quot;&gt; &lt;code&gt;schema/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; 의&lt;/a&gt; 두 가지 주요 API를 통해 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9a78c7a83d38ff7d46dcb4af94da86b3e6249f86" translate="yes" xml:space="preserve">
          <source>An Ecto type for UUIDs strings.</source>
          <target state="translated">UUID 문자열에 대한 Ecto 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ee46e7344e9c28c8dc0c8ffba9e6f569b7f50779" translate="yes" xml:space="preserve">
          <source>An Ecto type, primitive or custom</source>
          <target state="translated">Ecto 유형, 기본 또는 사용자 정의</target>
        </trans-unit>
        <trans-unit id="8753ca89d3033960625e32cacf9b8fa1380573d9" translate="yes" xml:space="preserve">
          <source>An Ecto type, primitive or custom.</source>
          <target state="translated">Ecto 유형, 기본 또는 사용자 정의.</target>
        </trans-unit>
        <trans-unit id="1499f024456d3f29759e8d864a77949d738934a4" translate="yes" xml:space="preserve">
          <source>An OR having query expression</source>
          <target state="translated">쿼리 표현식이있는 OR</target>
        </trans-unit>
        <trans-unit id="ba50741815527d5b973e074417869ccab912f791" translate="yes" xml:space="preserve">
          <source>An OR having query expression.</source>
          <target state="translated">쿼리식이있는 OR</target>
        </trans-unit>
        <trans-unit id="23272f9f7cc78f869c4f93ecdc53976c326941ef" translate="yes" xml:space="preserve">
          <source>An OR where query expression</source>
          <target state="translated">OR 식 쿼리 식</target>
        </trans-unit>
        <trans-unit id="6eb1fef5cd61957f88210544d0ec10e50372df50" translate="yes" xml:space="preserve">
          <source>An OR where query expression.</source>
          <target state="translated">OR 식 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="6a2d43b1af1e0b2dcdb60baef14605ef1b374ed9" translate="yes" xml:space="preserve">
          <source>An action is a regular function that receives the connection and the request parameters as arguments. The connection is a &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct, as specified by the Plug library.</source>
          <target state="translated">작업은 연결 및 요청 매개 변수를 인수로받는 일반 함수입니다. 연결은 Plug 라이브러리에 지정된 &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="40ac62949b4ea3b0d9e9b75feb023914d2fa707d" translate="yes" xml:space="preserve">
          <source>An action is a regular function that receives the connection and the request parameters as arguments. The connection is a &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct, as specified by the Plug library.</source>
          <target state="translated">작업은 연결 및 요청 매개 변수를 인수로받는 일반 함수입니다. 연결은 Plug 라이브러리에 지정된대로 &lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="bddff83f0e69da582ee7c2d814251936eff28fb7" translate="yes" xml:space="preserve">
          <source>An additional field called &lt;code&gt;__meta__&lt;/code&gt; is added to the struct for storing internal Ecto state. This field always has a &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; struct as value and can be manipulated with the &lt;a href=&quot;ecto#put_meta/2&quot;&gt;&lt;code&gt;Ecto.put_meta/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">내부 Ecto 상태를 저장하기위한 구조체에 &lt;code&gt;__meta__&lt;/code&gt; 라는 추가 필드 가 추가됩니다. 이 필드는 항상 &lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt; 구조체를 값으로 가지며 &lt;a href=&quot;ecto#put_meta/2&quot;&gt; &lt;code&gt;Ecto.put_meta/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae9eb87297abc7420a4adb2f4971432ff909c98" translate="yes" xml:space="preserve">
          <source>An additional keyword list &lt;code&gt;keys&lt;/code&gt; can be passed to provide additional contextual information for the error. This is useful when using &lt;a href=&quot;#traverse_errors/2&quot;&gt;&lt;code&gt;traverse_errors/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">오류에 대한 추가 컨텍스트 정보를 제공하기 위해 추가 키워드 목록 &lt;code&gt;keys&lt;/code&gt; 를 전달할 수 있습니다. &lt;a href=&quot;#traverse_errors/2&quot;&gt; &lt;code&gt;traverse_errors/2&lt;/code&gt; 를&lt;/a&gt; 사용할 때 유용합니다</target>
        </trans-unit>
        <trans-unit id="938db368635dcd9641d56cee87115aa027d219f1" translate="yes" xml:space="preserve">
          <source>An easy rule of thumb is to stick with &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;live_redirect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; and use the patch helpers only in the cases where you want to minimize the amount of data sent when navigating within the same LiveView (for example, if you want to change the sorting of a table while also updating the URL).</source>
          <target state="translated">경험상 쉬운 규칙은 &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt; &lt;code&gt;live_redirect/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt; &lt;code&gt;push_redirect/2&lt;/code&gt; &lt;/a&gt; 를 고수 하고 동일한 LiveView 내에서 탐색 할 때 전송되는 데이터의 양을 최소화하려는 경우에만 패치 도우미를 사용하는 것입니다 (예 : 변경하려는 경우). URL을 업데이트하면서 테이블 정렬).</target>
        </trans-unit>
        <trans-unit id="3cbecaa468000b1cd8e9438a0f21c36bad5b7afb" translate="yes" xml:space="preserve">
          <source>An embedded schema is either embedded into another schema or kept exclusively in memory. For this reason, an embedded schema does not require a source name and it does not include a metadata field.</source>
          <target state="translated">임베드 된 스키마는 다른 스키마에 임베드되거나 독점적으로 메모리에 보관됩니다. 이러한 이유로 임베디드 스키마에는 소스 이름이 필요하지 않으며 메타 데이터 필드가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ab7ad8e3a3ea01a0e010a1f3d78b1a31b131365" translate="yes" xml:space="preserve">
          <source>An empty request body is parsed as an empty map.</source>
          <target state="translated">빈 요청 본문은 빈 맵으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="e437d69f5b4b7cd7366f20508cb7cc728cfa22eb" translate="yes" xml:space="preserve">
          <source>An endpoint is simply a module defined with the help of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Endpoint&lt;/code&gt;&lt;/a&gt;. If you have used the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; generator, an endpoint was automatically generated as part of your application:</source>
          <target state="translated">엔드 포인트는 단순히 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Endpoint&lt;/code&gt; &lt;/a&gt; 의 도움으로 정의 된 모듈 입니다. 당신이 사용하는 경우 &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 발전기, 엔드 포인트가 자동으로 응용 프로그램의 일부로 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="3b4b6b176041a548d4533de816c409382e35bce6" translate="yes" xml:space="preserve">
          <source>An endpoint is simply a module defined with the help of &lt;a href=&quot;phoenix.endpoint#content&quot;&gt;&lt;code&gt;Phoenix.Endpoint&lt;/code&gt;&lt;/a&gt;. If you have used the &lt;code&gt;mix phx.new&lt;/code&gt; generator, an endpoint was automatically generated as part of your application:</source>
          <target state="translated">엔드 포인트는 단순히 &lt;a href=&quot;phoenix.endpoint#content&quot;&gt; &lt;code&gt;Phoenix.Endpoint&lt;/code&gt; &lt;/a&gt; 의 도움으로 정의 된 모듈 입니다. &lt;code&gt;mix phx.new&lt;/code&gt; 생성기를 사용한 경우 애플리케이션의 일부로 엔드 포인트가 자동으로 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cde03332fee4ff115f16002c9f108e996e9a75a6" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">오류가 발생했으며 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 다른 메커니즘으로 처리됩니다 . 이 방법은 지연 후 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출 하여 재시작을 시도하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7551c55fc80ae2c95b1ad1165031ff791674af5" translate="yes" xml:space="preserve">
          <source>An example configuration with custom &lt;code&gt;:ssl&lt;/code&gt; options might look like this:</source>
          <target state="translated">사용자 정의 &lt;code&gt;:ssl&lt;/code&gt; 옵션이 있는 예제 구성 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85d6ba7886e5493304a69c583a7b939934f2bf94" translate="yes" xml:space="preserve">
          <source>An except (set difference) query expression</source>
          <target state="translated">예외 (차이) 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="a5b26fb8a6cee45d37102dcd6e34101d2586040f" translate="yes" xml:space="preserve">
          <source>An except (set difference) query expression.</source>
          <target state="translated">예외 (차이) 쿼리 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="c13e83a84aa2694371b1a8ed1723cbe11eddc1f1" translate="yes" xml:space="preserve">
          <source>An exception on mount is caught and converted to an exception page by Phoenix error views - pretty much like the way it works with controllers</source>
          <target state="translated">마운트시 예외가 포착되어 Phoenix 오류보기에 의해 예외 페이지로 변환됩니다. 컨트롤러에서 작동하는 방식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bcade1f1ea3d0a589e1111aff1e48bf248c48b6c" translate="yes" xml:space="preserve">
          <source>An exception on mount will crash the LiveView process - which will be logged</source>
          <target state="translated">마운트시 예외로 인해 LiveView 프로세스가 중단되며 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a86c97233377ac8c34017ea9c780741efcd5ce" translate="yes" xml:space="preserve">
          <source>An informational response, such as an early hint, must happen prior to a response being sent. If an informational request is attempted after a response is sent then a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; will be raised. Only status codes from 100-199 are valid.</source>
          <target state="translated">초기 힌트와 같은 정보 응답은 응답을 보내기 전에 발생해야합니다. 응답이 전송 된 후 정보 요청이 시도되면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 100-199의 상태 코드 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c082ed6b2def64ed72b5ea45a1fc1293aa16df24" translate="yes" xml:space="preserve">
          <source>An intersect query expression</source>
          <target state="translated">교차 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="f37d10b2a22904ef45fb94fc0d7c0dcd59a32a4d" translate="yes" xml:space="preserve">
          <source>An intersect query expression.</source>
          <target state="translated">교차 쿼리 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="869fb8b610e0b6bb65e566732a732a81015cf3d5" translate="yes" xml:space="preserve">
          <source>An offset query expression</source>
          <target state="translated">오프셋 쿼리 식</target>
        </trans-unit>
        <trans-unit id="165b52f75af17c46b4b3fa96c13c255f0bde19ed" translate="yes" xml:space="preserve">
          <source>An offset query expression.</source>
          <target state="translated">오프셋 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="15e5c0ffc706898d12d9ae95b7fc36283bd41e5e" translate="yes" xml:space="preserve">
          <source>An optional text filter may be given to filter the results by the query selector. If the text filter is a string or a regex, it will match any element that contains the string or matches the regex. After the text filter is applied, only one element must remain, otherwise an error is raised.</source>
          <target state="translated">쿼리 선택기로 결과를 필터링하기 위해 선택적 텍스트 필터가 제공 될 수 있습니다. 텍스트 필터가 문자열 또는 정규식 인 경우 해당 문자열을 포함하거나 정규식과 일치하는 모든 요소와 일치합니다. 텍스트 필터가 적용된 후에는 하나의 요소 만 남아 있어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79928e4dd3b57a8c42acb325b5879c6056476cbb" translate="yes" xml:space="preserve">
          <source>An order by query expression</source>
          <target state="translated">쿼리 표현 식별 순서</target>
        </trans-unit>
        <trans-unit id="10e6e45231ed552f934b7c86d653cb891f6f2153" translate="yes" xml:space="preserve">
          <source>An order by query expression.</source>
          <target state="translated">쿼리 식별 순서입니다.</target>
        </trans-unit>
        <trans-unit id="22439862de76cde9fbf60016e20e02131f76032d" translate="yes" xml:space="preserve">
          <source>An update query expression</source>
          <target state="translated">업데이트 쿼리 식</target>
        </trans-unit>
        <trans-unit id="ffcb9217c46e5f5eaa187819e15623ec94356a15" translate="yes" xml:space="preserve">
          <source>An update query expression.</source>
          <target state="translated">업데이트 쿼리 식입니다.</target>
        </trans-unit>
        <trans-unit id="31ab765f91aa6f68439ffd097dd31b46e4c842ad" translate="yes" xml:space="preserve">
          <source>Analogous to the &lt;code&gt;_format&lt;/code&gt; query string param, we can render any sort of format we want by modifying the HTTP Content-Type Header and providing the appropriate template.</source>
          <target state="translated">&lt;code&gt;_format&lt;/code&gt; 쿼리 문자열 매개 변수 와 유사하게 HTTP Content-Type 헤더를 수정하고 적절한 템플릿을 제공하여 원하는 모든 형식을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06802c5d56fe2d8e7757449833a3c7492e6642fb" translate="yes" xml:space="preserve">
          <source>And finally, we'll start the Phoenix server:</source>
          <target state="translated">마지막으로 Phoenix 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7ffc9401405c31a1f9423d595d2efa929141b0ab" translate="yes" xml:space="preserve">
          <source>And here's what that translates to in the actual &lt;code&gt;users&lt;/code&gt; table.</source>
          <target state="translated">그리고 이것이 실제 &lt;code&gt;users&lt;/code&gt; 테이블 에서 번역되는 내용입니다 .</target>
        </trans-unit>
        <trans-unit id="2ab1249bd2abffa87777da45f6ab25d5772ddde1" translate="yes" xml:space="preserve">
          <source>And it works! We now have two isolated contexts responsible for user accounts and content management. We coupled the content management system to accounts where necessary, while keeping each system isolated wherever possible. This gives us a great base to grow our application from.</source>
          <target state="translated">그리고 작동합니다! 이제 사용자 계정과 콘텐츠 관리를 담당하는 두 개의 격리 된 컨텍스트가 있습니다. 필요한 경우 콘텐츠 관리 시스템을 계정에 연결하고 각 시스템을 가능한 한 격리 된 상태로 유지했습니다. 이것은 우리의 응용 프로그램을 성장시킬 수있는 훌륭한 기반을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d32de79e50a18b2c10b2499fb3ad6f596ca4c0db" translate="yes" xml:space="preserve">
          <source>And now we want to make sure to return both the post title and the comment body. Although we may not know how many bindings there are in the query, we are sure posts is the first binding and comments are the last one, so we can write:</source>
          <target state="translated">이제 게시물 제목과 댓글 본문을 모두 반환해야합니다. 쿼리에 몇 개의 바인딩이 있는지 알 수 없지만 게시물이 첫 번째 바인딩이고 주석이 마지막 바인딩이므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e9bcc3bf6ef74ce2cfbfff9b59b847e7893f8f" translate="yes" xml:space="preserve">
          <source>And now you can simply use it from your controller:</source>
          <target state="translated">이제 컨트롤러에서 간단히 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50fb2f2cee17d104e440238643e1e3cbf6bf874f" translate="yes" xml:space="preserve">
          <source>And now you can use it in accepts too:</source>
          <target state="translated">그리고 이제 당신도 그것을 받아 들일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2c4e72f0d50cebdec0f44072c0eaeb395f418357" translate="yes" xml:space="preserve">
          <source>And that's it for now. As you work on your project, we will add files and modules to this directory.</source>
          <target state="translated">지금은 그게 다입니다. 프로젝트에서 작업 할 때이 디렉토리에 파일과 모듈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6096a937df9489c331022496b40ed0add88510d4" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;render/2&lt;/code&gt; matching &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;&quot;show.json&quot;&lt;/code&gt; 과 일치하는 &lt;code&gt;render/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3d95105c6d043f42a186cb1cb95338bb3b8c9e5" translate="yes" xml:space="preserve">
          <source>And the plug will only be executed for the &lt;code&gt;index&lt;/code&gt; action.</source>
          <target state="translated">그리고 플러그는 &lt;code&gt;index&lt;/code&gt; 동작에 대해서만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="991f232167df9cd3bdbc26decca8e97ad1a93963" translate="yes" xml:space="preserve">
          <source>And then &lt;code&gt;assets/&lt;/code&gt; which should look similar to this:</source>
          <target state="translated">그런 다음 &lt;code&gt;assets/&lt;/code&gt; 은 다음과 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="56ec252cb1d699087781a4616d1dc2ca2a889473" translate="yes" xml:space="preserve">
          <source>And then execute the query:</source>
          <target state="translated">그런 다음 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="93eedaeceafc99ad0e82d5139f6dd534c247a1f9" translate="yes" xml:space="preserve">
          <source>And then in the client:</source>
          <target state="translated">그리고 클라이언트에서 :</target>
        </trans-unit>
        <trans-unit id="472517d2f4a0e418d297e5ec5530acd44bec9147" translate="yes" xml:space="preserve">
          <source>And then in your views:</source>
          <target state="translated">그리고 당신의 견해에서 :</target>
        </trans-unit>
        <trans-unit id="ea31ee587d02a91a451bbdb640b8acd677a970c2" translate="yes" xml:space="preserve">
          <source>And then on the client:</source>
          <target state="translated">그리고 클라이언트에서 :</target>
        </trans-unit>
        <trans-unit id="cd2adc164cca27fb8f1d47278c4947b99b757d83" translate="yes" xml:space="preserve">
          <source>And this is what the template should look like:</source>
          <target state="translated">그리고 다음은 템플릿의 모습입니다.</target>
        </trans-unit>
        <trans-unit id="f54c39fdeca73300d3e081fb2d149c7d1f6d5e7b" translate="yes" xml:space="preserve">
          <source>And to rate limit a volume up click to once every second:</source>
          <target state="translated">그리고 볼륨 높이기 클릭을 1 초에 한 번으로 제한하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bda7ca64d6a7be94ce39c9e370ab0974be1dea51" translate="yes" xml:space="preserve">
          <source>Animations - animations, menus, and general events that do not need the server in the first place are a bad fit for LiveView, as they can be achieved purely with CSS and/or CSS transitions;</source>
          <target state="translated">애니메이션-처음부터 서버가 필요하지 않은 애니메이션, 메뉴 및 일반 이벤트는 CSS 및 / 또는 CSS 전환으로 만 달성 할 수 있으므로 LiveView에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="858ad2f63ffc7c337c04d12219e741685eb346ff" translate="yes" xml:space="preserve">
          <source>Annotates a plug will receive the options given to the current module itself as arguments</source>
          <target state="translated">플러그는 현재 모듈 자체에 인수로 주어진 옵션을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca7c7d5899dadd1120e30c45c0410c89a0f196d" translate="yes" xml:space="preserve">
          <source>Annotates a plug will receive the options given to the current module itself as arguments.</source>
          <target state="translated">주석은 플러그가 현재 모듈 자체에 인수로 주어진 옵션을받습니다.</target>
        </trans-unit>
        <trans-unit id="103998d4eb32a89668e537c98c324cc30584871c" translate="yes" xml:space="preserve">
          <source>Annotates the socket for navigation to another LiveView.</source>
          <target state="translated">다른 LiveView 로의 탐색을 위해 소켓에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="892c24fb11c5b7e93791a977b684fdf1ceafbe45" translate="yes" xml:space="preserve">
          <source>Annotates the socket for navigation within the current LiveView.</source>
          <target state="translated">현재 LiveView 내에서 탐색을 위해 소켓에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="b8e5aa94673f39ee4dbbc53f7778394852216425" translate="yes" xml:space="preserve">
          <source>Annotates the socket for redirect to a destination path.</source>
          <target state="translated">대상 경로로 리디렉션하기 위해 소켓에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="965a5d9407e704c6a66f6a80235a06c707d5d61f" translate="yes" xml:space="preserve">
          <source>Another New Page</source>
          <target state="translated">또 다른 새 페이지</target>
        </trans-unit>
        <trans-unit id="6c7f32ee11fa615e66a13dec2e34a0dfb1c524e9" translate="yes" xml:space="preserve">
          <source>Another advantage of using schemas is that we no longer need to specify the select option in queries, as by default Ecto will retrieve all fields specified in the schema:</source>
          <target state="translated">스키마 사용의 또 다른 장점은 기본적으로 Ecto가 스키마에 지정된 모든 필드를 검색하므로 쿼리에서 선택 옵션을 지정할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1c86f6d10d0bf2429514d920bb8250e03a07332" translate="yes" xml:space="preserve">
          <source>Another function in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;, which allows someone to build an associated struct with the proper fields:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; 의&lt;/a&gt; 또 다른 기능 은 &lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;build_assoc/3&lt;/code&gt; 입니다&lt;/a&gt; . 이것은 누군가가 적절한 필드와 관련된 구조체를 만들 수 있도록합니다 :</target>
        </trans-unit>
        <trans-unit id="3aef06e4e0539721c1ea8108e13b3694b5a7fb56" translate="yes" xml:space="preserve">
          <source>Another function in &lt;a href=&quot;ecto#content&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;, which allows someone to build an associated struct with the proper fields:</source>
          <target state="translated">&lt;a href=&quot;ecto#content&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; 의&lt;/a&gt; 또 다른 함수 는 &lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;build_assoc/3&lt;/code&gt; &lt;/a&gt; 이며,이를 통해 누군가가 적절한 필드로 관련 구조체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c094452b606f1027780eff1ec7f357c6e158a2c" translate="yes" xml:space="preserve">
          <source>Another limitation of components is that they must always be change tracked. For example, if you render a component inside &lt;code&gt;form_for&lt;/code&gt;, like this:</source>
          <target state="translated">구성 요소의 또 다른 제한은 항상 변경 내용을 추적해야한다는 것입니다. 예를 들어 다음 과 같이 &lt;code&gt;form_for&lt;/code&gt; 내부의 구성 요소를 렌더링하는 경우 :</target>
        </trans-unit>
        <trans-unit id="35452525e55bd9ad296aa31292df28fe37e9cef6" translate="yes" xml:space="preserve">
          <source>Another new Action</source>
          <target state="translated">또 다른 새로운 행동</target>
        </trans-unit>
        <trans-unit id="87e0d97d55cdf75cee079b931b92c6f9771aa51e" translate="yes" xml:space="preserve">
          <source>Another new Route</source>
          <target state="translated">또 다른 새로운 경로</target>
        </trans-unit>
        <trans-unit id="f7c58fe3aff941a0ae5866b804e7906a16f18837" translate="yes" xml:space="preserve">
          <source>Another new Template</source>
          <target state="translated">또 다른 새로운 템플릿</target>
        </trans-unit>
        <trans-unit id="ed128006347c8b2ccd955b95f618e9b540afdae3" translate="yes" xml:space="preserve">
          <source>Another optimization done by &lt;code&gt;.leex&lt;/code&gt; templates is to track comprehensions. If your code has this:</source>
          <target state="translated">&lt;code&gt;.leex&lt;/code&gt; 템플릿이 수행하는 또 다른 최적화 는 이해를 추적하는 것입니다. 코드에 다음이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="fd51eafaf130785ca495e1b2d9c65d26d8d92ea8" translate="yes" xml:space="preserve">
          <source>Another option for flexibly building queries with joins are named bindings. Coming back to the previous example, provided we bind a join to a concrete name:</source>
          <target state="translated">조인으로 유연하게 쿼리를 작성하는 또 다른 옵션은 이름 지정된 바인딩입니다. 이전 예제로 돌아가서 구체적인 이름에 조인을 바인딩하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="200acbdf3a75ec17dbadb3ee966de0aa5a5aec87" translate="yes" xml:space="preserve">
          <source>Another pitfall of &lt;code&gt;.leex&lt;/code&gt; templates is related to variables. Due to the scope of variables, LiveView has to disable change tracking whenever variables are used in the template, with the exception of variables introduced by Elixir basic &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and other block constructs. Therefore, you &lt;strong&gt;must avoid&lt;/strong&gt; code like this in your LiveEEx:</source>
          <target state="translated">&lt;code&gt;.leex&lt;/code&gt; 템플릿 의 또 다른 함정은 변수와 관련이 있습니다. 변수의 범위로 인해 LiveView는 Elixir 기본 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 기타 블록 구조에서 도입 된 변수를 제외하고 템플릿에서 변수가 사용될 때마다 변경 내용 추적을 비활성화해야합니다 . 따라서 LiveEEx에서 다음과 같은 코드 &lt;strong&gt;를 피해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="73617edc1beeb9766f6f3e5570ec94af54a71244" translate="yes" xml:space="preserve">
          <source>Another security consideration is how to disconnect all instances of a given live user. For example, imagine the user logs outs, its account is terminated, or any other reason.</source>
          <target state="translated">또 다른 보안 고려 사항은 지정된 라이브 사용자의 모든 인스턴스 연결을 끊는 방법입니다. 예를 들어 사용자가 로그 아웃하거나 계정이 종료되거나 다른 이유가 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="71a1d2bae841fd6d3cbb64b750fa8f6aa10792f8" translate="yes" xml:space="preserve">
          <source>Any element of the path can be dynamic:</source>
          <target state="translated">Any element of the path can be dynamic:</target>
        </trans-unit>
        <trans-unit id="446a599b7f56e42924adcc359314759564aef04a" translate="yes" xml:space="preserve">
          <source>Any key in &lt;code&gt;on&lt;/code&gt; will apply to the currently joined expression.</source>
          <target state="translated">의 모든 키 &lt;code&gt;on&lt;/code&gt; 현재 가입 표현에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b582ea3bb7814c5e356182d52bb73802a875238e" translate="yes" xml:space="preserve">
          <source>Any number of optional &lt;code&gt;phx-value-&lt;/code&gt; prefixed attributes, such as:</source>
          <target state="translated">다음과 같이 임의의 수의 선택적 &lt;code&gt;phx-value-&lt;/code&gt; 접두사 속성 :</target>
        </trans-unit>
        <trans-unit id="42fff788290a25f5f8125c374d15463e517d9097" translate="yes" xml:space="preserve">
          <source>Any of these routes may be nested.</source>
          <target state="translated">이러한 경로는 모두 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="560e74426a5a7adb796c4d5bc65d55748987b23c" translate="yes" xml:space="preserve">
          <source>Any of these routes may be scoped to a given path.</source>
          <target state="translated">이러한 경로는 지정된 경로로 범위가 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7975e28c47c5f1c7d5d84990d36a6f61381c95cb" translate="yes" xml:space="preserve">
          <source>Any of those choices can be disabled on a per choice basis by specifying the equivalent SSL option alongside the cipher suite.</source>
          <target state="translated">암호화 제품군과 함께 동등한 SSL 옵션을 지정하여 선택 사항별로 선택 사항을 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f75593bfe3c7c9fa04ff0433e00417f5df7957" translate="yes" xml:space="preserve">
          <source>Any parameter that was not explicitly listed in the fields list will be ignored.</source>
          <target state="translated">필드 목록에 명시 적으로 나열되지 않은 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="41770eb3e1ebe73b5cee06e82ee72c33af97f4d3" translate="yes" xml:space="preserve">
          <source>Any preload or select in the query will be ignored in favor of the column being aggregated.</source>
          <target state="translated">쿼리에서 사전로드 또는 선택은 집계되는 열을 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8003575824cb241e72db8ad63398a3ff6314ed" translate="yes" xml:space="preserve">
          <source>Any process exit is treated as an error by the socket layer unless a &lt;code&gt;{:socket_close, pid, reason}&lt;/code&gt; message is sent to the socket before shutdown.</source>
          <target state="translated">Any process exit is treated as an error by the socket layer unless a &lt;code&gt;{:socket_close, pid, reason}&lt;/code&gt; message is sent to the socket before shutdown.</target>
        </trans-unit>
        <trans-unit id="300cfabfd4866cec4228fbe86fd289ab17ee02d3" translate="yes" xml:space="preserve">
          <source>Any schema module will generate the &lt;code&gt;__schema__&lt;/code&gt; function that can be used for runtime introspection of the schema:</source>
          <target state="translated">모든 스키마 모듈은 스키마의 런타임 내부 검사에 사용할 수있는 &lt;code&gt;__schema__&lt;/code&gt; 함수를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6e3a58d59ec917c307d1a1fb3de7a558a9eaf30c" translate="yes" xml:space="preserve">
          <source>Any schemas using &lt;code&gt;MyApp.Schema&lt;/code&gt; will get the &lt;code&gt;:id&lt;/code&gt; field with type &lt;code&gt;:binary_id&lt;/code&gt; as the primary key. We explain what the &lt;code&gt;:binary_id&lt;/code&gt; type entails in the next section.</source>
          <target state="translated">&lt;code&gt;MyApp.Schema&lt;/code&gt; 를 사용하는 모든 스키마 는 &lt;code&gt;:binary_id&lt;/code&gt; 유형 의 &lt;code&gt;:id&lt;/code&gt; 필드를 기본 키로 가져옵니다 . 다음 섹션에서 &lt;code&gt;:binary_id&lt;/code&gt; 유형의 내용을 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="e0ebb8325f89e8834d39e539dc55c7e384f4c218" translate="yes" xml:space="preserve">
          <source>Any submit button on the form is disabled</source>
          <target state="translated">양식의 모든 제출 버튼이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5a47721bdd6f49dc71fd1d1d556d93aeac0052dc" translate="yes" xml:space="preserve">
          <source>Any topic coming into the router with the &lt;code&gt;&quot;room:&quot;&lt;/code&gt; prefix would dispatch to &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; in the above example. Topics can also be pattern matched in your channels&amp;rsquo; &lt;code&gt;join/3&lt;/code&gt; callback to pluck out the scoped pattern:</source>
          <target state="translated">접두사가 &lt;code&gt;&quot;room:&quot;&lt;/code&gt; 라우터로 들어오는 모든 주제 는 위 예에서 &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; 로 발송됩니다 . 채널의 &lt;code&gt;join/3&lt;/code&gt; 콜백 에서 주제를 패턴 일치 하여 범위가 지정된 패턴을 추출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c78b7ad84b8b92a86b6384a17069d524569aa3d2" translate="yes" xml:space="preserve">
          <source>Any topic coming into the router with the &lt;code&gt;&quot;room:&quot;&lt;/code&gt; prefix would dispatch to &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; in the above example. Topics can also be pattern matched in your channels' &lt;code&gt;join/3&lt;/code&gt; callback to pluck out the scoped pattern:</source>
          <target state="translated">Any topic coming into the router with the &lt;code&gt;&quot;room:&quot;&lt;/code&gt; prefix would dispatch to &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; in the above example. Topics can also be pattern matched in your channels' &lt;code&gt;join/3&lt;/code&gt; callback to pluck out the scoped pattern:</target>
        </trans-unit>
        <trans-unit id="7499220bee9b9eb7645271f804030e1f15a440df" translate="yes" xml:space="preserve">
          <source>Any valid query selector for &lt;code&gt;phx-target&lt;/code&gt; is supported, provided that the matched nodes are children of a LiveView or LiveComponent, for example to send the &lt;code&gt;close&lt;/code&gt; event to multiple components:</source>
          <target state="translated">&lt;code&gt;phx-target&lt;/code&gt; 에 대한 유효한 쿼리 선택기 가 지원되며, 일치하는 노드가 LiveView 또는 LiveComponent의 자식 인 경우 (예 : 여러 구성 요소에 &lt;code&gt;close&lt;/code&gt; 이벤트 보내기)</target>
        </trans-unit>
        <trans-unit id="380633ac14a276ca3da8d636824d32f161eeaebb" translate="yes" xml:space="preserve">
          <source>Any value can be used on the right-side of &lt;code&gt;in&lt;/code&gt; as long as it implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. For now, we know the protocol is implemented for both atoms (like &lt;code&gt;User&lt;/code&gt;) and strings (like &quot;users&quot;).</source>
          <target state="translated">Any value can be used on the right-side of &lt;code&gt;in&lt;/code&gt; as long as it implements the &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; protocol. For now, we know the protocol is implemented for both atoms (like &lt;code&gt;User&lt;/code&gt; ) and strings (like &quot;users&quot;).</target>
        </trans-unit>
        <trans-unit id="4f22fd2991e728e7d7b2e3f805e73ae5fa52bfbf" translate="yes" xml:space="preserve">
          <source>Any value can be used on the right-side of &lt;code&gt;in&lt;/code&gt; as long as it implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. For now, we know the protocol is implemented for both atoms (like &lt;code&gt;User&lt;/code&gt;) and strings (like &amp;ldquo;users&amp;rdquo;).</source>
          <target state="translated">상관 값의 오른쪽에 이용 될 수 &lt;code&gt;in&lt;/code&gt; 한 그것이 구현으로 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; 프로토콜. 현재는 &lt;code&gt;User&lt;/code&gt; 와 같은 원자 와 문자열 ( &quot;users&quot;) 모두에 프로토콜이 구현되어 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b887cbd7add6f099fb444c6f2429533dcfaf8283" translate="yes" xml:space="preserve">
          <source>Appends the second multi to the first one</source>
          <target state="translated">두 번째 멀티를 첫 번째 멀티에 추가</target>
        </trans-unit>
        <trans-unit id="b9edef6586142e33c6c60f9e0c8390125159a8a7" translate="yes" xml:space="preserve">
          <source>Appends the second multi to the first one.</source>
          <target state="translated">두 번째 멀티를 첫 번째 멀티에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1b1ea95f65514cccb0b50f920b09136d8b861a77" translate="yes" xml:space="preserve">
          <source>Applications with &quot;users&quot; are naturally heavily user driven. After all, our software is typically designed to be used by human end-users one way or another. Instead of extending our &lt;code&gt;Accounts.User&lt;/code&gt; struct to track every field and responsibility of our entire platform, it's better to keep those responsibilities with the modules who own that functionality. In our case, we can create a &lt;code&gt;CMS.Author&lt;/code&gt; struct that holds author specific fields as it relates to a CMS. Now we can place fields like &quot;role&quot; and &quot;bio&quot; here, where they naturally live. Likewise, we also gain specialized datastructures in our application that are suited to the domain that we are operating in, rather than a single &lt;code&gt;%User{}&lt;/code&gt; in the system that has to be everything to everyone.</source>
          <target state="translated">&quot;사용자&quot;가있는 애플리케이션은 당연히 사용자 중심적입니다. 결국, 우리의 소프트웨어는 일반적으로 인간의 최종 사용자가 어떤 식 으로든 사용하도록 설계되었습니다. &lt;code&gt;Accounts.User&lt;/code&gt; 구조체를 확장 하여 전체 플랫폼의 모든 필드와 책임을 추적 하는 대신 해당 기능을 소유 한 모듈로 이러한 책임을 유지하는 것이 좋습니다. 이 경우 CMS와 관련된 작성자 별 필드를 보유 하는 &lt;code&gt;CMS.Author&lt;/code&gt; 구조체를 만들 수 있습니다 . 이제 여기에 &quot;역할&quot;및 &quot;바이오&quot;와 같은 필드를 배치 할 수 있습니다. 마찬가지로, 우리는 또한 모든 사람에게 모든 것이되어야하는 시스템 의 단일 &lt;code&gt;%User{}&lt;/code&gt; 대신 우리가 운영하고있는 도메인에 적합한 특수 데이터 구조를 애플리케이션에서 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="334894d99b92fe73d7e7aa140d76f7f561fafb65" translate="yes" xml:space="preserve">
          <source>Applies optimistic locking to the changeset</source>
          <target state="translated">변경 세트에 낙관적 잠금 적용</target>
        </trans-unit>
        <trans-unit id="4361b172649775394dfd72f667908efc6452872f" translate="yes" xml:space="preserve">
          <source>Applies optimistic locking to the changeset.</source>
          <target state="translated">변경 세트에 낙관적 잠금을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="09556e7e4517fe9725dfbd42cbf5a36cc2e87d68" translate="yes" xml:space="preserve">
          <source>Applies the changeset action if the changes are valid or raises an error.</source>
          <target state="translated">Applies the changeset action if the changes are valid or raises an error.</target>
        </trans-unit>
        <trans-unit id="031274fb912bb51836441a5c22085b2001b18f45" translate="yes" xml:space="preserve">
          <source>Applies the changeset action only if the changes are valid</source>
          <target state="translated">변경 사항이 유효한 경우에만 변경 사항 조치를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b050c53ebe07c3d28361a411d8cbd7b0f72b7844" translate="yes" xml:space="preserve">
          <source>Applies the changeset action only if the changes are valid.</source>
          <target state="translated">변경 사항이 유효한 경우에만 변경 사항 조치를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2761b7d6b04d3d8fdfdb82fe84e797e17b5c434a" translate="yes" xml:space="preserve">
          <source>Applies the changeset changes to the changeset data</source>
          <target state="translated">변경 세트 변경 사항을 변경 세트 데이터에 적용</target>
        </trans-unit>
        <trans-unit id="58edcf307fce02ffe026656721ed37ef1c218b4f" translate="yes" xml:space="preserve">
          <source>Applies the changeset changes to the changeset data.</source>
          <target state="translated">변경 세트 변경 사항을 변경 세트 데이터에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f1c024b9973dc724f6ab98ed916d0ccb4c1312df" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;params&lt;/code&gt; as changes for the given &lt;code&gt;data&lt;/code&gt; according to the given set of &lt;code&gt;permitted&lt;/code&gt; keys. Returns a changeset</source>
          <target state="translated">주어진 &lt;code&gt;permitted&lt;/code&gt; 키 세트에 따라 주어진 &lt;code&gt;params&lt;/code&gt; 를 주어진 &lt;code&gt;data&lt;/code&gt; 에 대한 변경으로 적용합니다 . 변경 세트를 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="f1c1d0d5bec454128305edccd7c51e64e4e6fa92" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;params&lt;/code&gt; as changes for the given &lt;code&gt;data&lt;/code&gt; according to the given set of &lt;code&gt;permitted&lt;/code&gt; keys. Returns a changeset.</source>
          <target state="translated">주어진 &lt;code&gt;permitted&lt;/code&gt; 키 세트에 따라 주어진 &lt;code&gt;params&lt;/code&gt; 를 주어진 &lt;code&gt;data&lt;/code&gt; 에 대한 변경으로 적용합니다 . 변경 세트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="86680b93bfe5f3d5e136ea751760d9739bc9e99c" translate="yes" xml:space="preserve">
          <source>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres</source>
          <target state="translated">주어진 표현식을 집계에 대해 FILTER 절로 적용합니다. 이것은 현재 Postgres에서만 지원됩니다</target>
        </trans-unit>
        <trans-unit id="0ea218082f0918b6c6d6196ff4808dba4c0ad11c" translate="yes" xml:space="preserve">
          <source>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres.</source>
          <target state="translated">주어진 표현식을 집계에 대해 FILTER 절로 적용합니다. 이것은 현재 Postgres에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4400f576bc0c89e7f88b6372000ac8456cf2427f" translate="yes" xml:space="preserve">
          <source>Applying a limit to the association can be achieved with &lt;code&gt;inner_lateral_join&lt;/code&gt;:</source>
          <target state="translated">Applying a limit to the association can be achieved with &lt;code&gt;inner_lateral_join&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="12ba74c0de8af933a3a3f56bbea3b38757e06f95" translate="yes" xml:space="preserve">
          <source>Arithmetic operators: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">산술 연산자 : &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aee5aacb98321221728d086e57edc8138d0ba9b" translate="yes" xml:space="preserve">
          <source>Arrays: &lt;code&gt;[1, 2, 3]&lt;/code&gt;, &lt;code&gt;~w(interpolate words)&lt;/code&gt;</source>
          <target state="translated">배열 : &lt;code&gt;[1, 2, 3]&lt;/code&gt; , &lt;code&gt;~w(interpolate words)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1a93145914c19a817e2f83d25abe14b25ed5208" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;code&gt;select&lt;/code&gt; allows developers to take fields without an explicit call to &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">편의상 &lt;code&gt;select&lt;/code&gt; 를 사용하면 개발자가 &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 호출하지 않고도 필드를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c498ddcfc7c00342094648686289bc00b3b0dc5c" translate="yes" xml:space="preserve">
          <source>As an example, imagine &lt;code&gt;:title&lt;/code&gt; is marked as a unique column in the database:</source>
          <target state="translated">예를 들어 상상 &lt;code&gt;:title&lt;/code&gt; 은 데이터베이스에서 고유 한 열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="79d5d9b16bafc29af957487e6b081f397b4bee65" translate="yes" xml:space="preserve">
          <source>As an example, let's take the &lt;code&gt;PageController&lt;/code&gt; index action from a newly generated app. Out of the box, this has the right view, &lt;code&gt;PageView&lt;/code&gt;, the right templates directory, &lt;code&gt;lib/hello_web/templates/page&lt;/code&gt;, and the right template for rendering HTML, &lt;code&gt;index.html.eex&lt;/code&gt;.</source>
          <target state="translated">예를 들어 새로 생성 된 앱에서 &lt;code&gt;PageController&lt;/code&gt; 색인 작업을 수행해 보겠습니다 . &lt;code&gt;lib/hello_web/templates/page&lt;/code&gt; 올바른 뷰인 &lt;code&gt;PageView&lt;/code&gt; , 올바른 템플릿 디렉토리 lib / hello_web / templates / page 및 HTML 렌더링을위한 올바른 템플릿 &lt;code&gt;index.html.eex&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ac25f18fe082956a1b5832c11ba04b5460ef65" translate="yes" xml:space="preserve">
          <source>As an umbrella:</source>
          <target state="translated">우산으로 :</target>
        </trans-unit>
        <trans-unit id="ede5a74258fd5fb816fbcfefa32286c05d2157f3" translate="yes" xml:space="preserve">
          <source>As any other Plug, we can use the &lt;code&gt;basic_auth&lt;/code&gt; at runtime by simply wrapping it in a function:</source>
          <target state="translated">다른 플러그와 마찬가지로 런타임에 &lt;code&gt;basic_auth&lt;/code&gt; 를 간단히 함수로 래핑하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a23b6d0328db4bd7b84c97eaea8ba3456c0bd022" translate="yes" xml:space="preserve">
          <source>As are the variables matched defined in a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;cond&lt;/code&gt; 에 정의 된 일치하는 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fddced341e63f42b257c605c248116bc9912aea3" translate="yes" xml:space="preserve">
          <source>As controllers are plugs, they implement both &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;, and it also provides a function named &lt;code&gt;action/2&lt;/code&gt; which is responsible for dispatching the appropriate action after the plug stack (and is also overridable).</source>
          <target state="translated">컨트롤러는 플러그이므로 &lt;code&gt;init/1&lt;/code&gt; 과 &lt;code&gt;call/2&lt;/code&gt; 를 모두 구현하며 , 플러그 스택 이후에 적절한 조치를 전달하는 역할을하는 &lt;code&gt;action/2&lt;/code&gt; 라는 함수를 제공합니다 (재정의 가능).</target>
        </trans-unit>
        <trans-unit id="2f2c06fb780697e369f25f7c87ee7118c0b20715" translate="yes" xml:space="preserve">
          <source>As in your application, the connection is also the main abstraction in testing. &lt;code&gt;build_conn()&lt;/code&gt; returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</source>
          <target state="translated">응용 프로그램에서와 마찬가지로 연결도 테스트의 주요 추상화입니다. &lt;code&gt;build_conn()&lt;/code&gt; 은 새 연결을 반환 하며이 모듈의 함수를 사용하여 끝점으로 디스패치하기 전에 연결을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b210531fbb3bd27c9f7aaf52afc8d05c910d1cc5" translate="yes" xml:space="preserve">
          <source>As in your router and controllers, the connection is the main abstraction in testing. &lt;code&gt;build_conn()&lt;/code&gt; returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</source>
          <target state="translated">As in your router and controllers, the connection is the main abstraction in testing. &lt;code&gt;build_conn()&lt;/code&gt; returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</target>
        </trans-unit>
        <trans-unit id="c796c7f3ac16197066e697bf71c6c72770c4ba4d" translate="yes" xml:space="preserve">
          <source>As long as the parent LiveView subscribes to the &quot;board:ID&quot; topic, it will receive updates. The advantage of using PubSub is that we get distributed updates out of the box. Now, if any user connected to the board changes a card, all other users will see the change.</source>
          <target state="translated">상위 LiveView가 &quot;board : ID&quot;주제를 구독하는 한 업데이트를 수신합니다. PubSub를 사용할 때의 장점은 즉시 배포 된 업데이트를받을 수 있다는 것입니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이제 보드에 연결된 사용자가 카드를 변경하면 다른 모든 사용자가 변경 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="808d46d3e3e0f6f7f131fef1fd1b60fe8faaf80e" translate="yes" xml:space="preserve">
          <source>As long as we change the action name in the &lt;code&gt;PageController&lt;/code&gt; to &lt;code&gt;test&lt;/code&gt; as well, the welcome page will load as before.</source>
          <target state="translated">만큼 우리가에서 작업 이름을 변경하면 &lt;code&gt;PageController&lt;/code&gt; 에 &lt;code&gt;test&lt;/code&gt; 뿐만 아니라, 환영 페이지 이전으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="cff517968c1c330a71aa1134978cf184158a1dc9" translate="yes" xml:space="preserve">
          <source>As of early 2020, the following avoids these pitfalls and will likely serve your application's needs and users much better. According to &lt;a href=&quot;https://caniuse.com/#search=inputmode&quot;&gt;https://caniuse.com/#search=inputmode&lt;/a&gt;, the following is supported by 90% of the global mobile market with Firefox yet to implement.</source>
          <target state="translated">2020 년 초부터 다음은 이러한 함정을 피하고 애플리케이션의 요구 사항과 사용자에게 훨씬 더 나은 서비스를 제공 할 것입니다. &lt;a href=&quot;https://caniuse.com/#search=inputmode&quot;&gt;https://caniuse.com/#search=inputmode&lt;/a&gt; 에 따르면 아직 구현되지 않은 Firefox를 사용하는 전 세계 모바일 시장의 90 %가 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5c0636dd8dd5611c756ba959ee083d5a9473b102" translate="yes" xml:space="preserve">
          <source>As seen earlier, you start by instantiating a single LiveSocket to enable LiveView client/server interaction, for example:</source>
          <target state="translated">앞서 살펴본 것처럼 단일 LiveSocket을 인스턴스화하여 LiveView 클라이언트 / 서버 상호 작용을 활성화하는 것으로 시작합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="229436c1260793d8c0dc3e318e1138522f1fb3f4" translate="yes" xml:space="preserve">
          <source>As the list of cards in the parent socket was updated, the parent will be re-rendered, sending the updated card to the component. So in the end, the component does get the updated card, but always driven from the parent.</source>
          <target state="translated">부모 소켓의 카드 목록이 업데이트되면 부모가 다시 렌더링되어 업데이트 된 카드를 구성 요소에 보냅니다. 따라서 결국 구성 요소는 업데이트 된 카드를 받지만 항상 상위에서 구동됩니다.</target>
        </trans-unit>
        <trans-unit id="9152bca7977631eb6dcbaafbab88915d2ad4c4e4" translate="yes" xml:space="preserve">
          <source>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</source>
          <target state="translated">이름에서 알 수 있듯이이 기능이 작동하려면 데이터베이스에 제한이 필요합니다. 이러한 제약 조건은 종종 자식 테이블에 대한 참조로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba940f8fbd73fccb95624e24614ba319a8d87947" translate="yes" xml:space="preserve">
          <source>As their names suggest, the &lt;code&gt;:browser&lt;/code&gt; pipeline prepares for routes which render requests for a browser. The &lt;code&gt;:api&lt;/code&gt; pipeline prepares for routes which produce data for an api.</source>
          <target state="translated">이름에서 알 수 있듯이 &lt;code&gt;:browser&lt;/code&gt; 파이프 라인은 브라우저에 대한 요청을 렌더링하는 경로를 준비합니다. &lt;code&gt;:api&lt;/code&gt; 파이프 라인은 API에 대한 데이터를 생성 경로에 대한 준비합니다.</target>
        </trans-unit>
        <trans-unit id="16ef7ec7284c632cb98296deb90a681d81b3ec19" translate="yes" xml:space="preserve">
          <source>As this configuration is Plug specific, Plug will need to be recompiled for the changes to take place: this will not happen automatically as dependencies are not automatically recompiled when their configuration changes. To recompile Plug:</source>
          <target state="translated">이 구성은 플러그 전용이므로 변경 사항을 적용하려면 플러그를 다시 컴파일해야합니다. 구성이 변경 될 때 종속성이 자동으로 다시 컴파일되지 않으므로 자동으로 발생하지 않습니다. 플러그를 다시 컴파일하려면</target>
        </trans-unit>
        <trans-unit id="3aa8f57e35993de6767035bb3d069ba1ccc735ac" translate="yes" xml:space="preserve">
          <source>As we built our first page, we could start to understand how the request life-cycle is put together. Now let's take a more holistic look at it.</source>
          <target state="translated">첫 페이지를 만들면서 요청 수명주기가 어떻게 결합되는지 이해하기 시작할 수있었습니다. 이제 좀 더 전체 론적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="334d7e352cb7a7f766913827757bcf8b0f35ec8d" translate="yes" xml:space="preserve">
          <source>As we can see, we're calling &lt;code&gt;render/3&lt;/code&gt; with the individual view responsible for our test template, the name of our test template, and an empty map representing any assigns we might have wanted to pass in. The return value is a tuple beginning with the atom &lt;code&gt;:safe&lt;/code&gt; and the resultant io list of the interpolated template. &quot;Safe&quot; here means that Phoenix has escaped the contents of our rendered template to avoid XSS injection attacks.</source>
          <target state="translated">보시다시피 테스트 템플릿을 담당하는 개별 뷰, 테스트 템플릿의 이름, 전달하려는 할당을 나타내는 빈 맵을 사용하여 &lt;code&gt;render/3&lt;/code&gt; 를 호출 합니다. 반환 값은 튜플입니다. atom &lt;code&gt;:safe&lt;/code&gt; 및 보간 된 템플릿의 결과 io 목록으로 시작합니다. 여기서 &quot;안전&quot;은 Phoenix가 XSS 주입 공격을 피하기 위해 렌더링 된 템플릿의 내용을 이스케이프했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="429b7898d95292088a6a9ba5f3da7941b7fe802e" translate="yes" xml:space="preserve">
          <source>As we did last time, the first thing we'll do is create a new route.</source>
          <target state="translated">지난번에했던 것처럼 가장 먼저 할 일은 새 경로를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9b4bd0b6a2cd5027da43fb01f182776ca3485b6" translate="yes" xml:space="preserve">
          <source>As we explored the context API, you might have wondered:</source>
          <target state="translated">컨텍스트 API를 살펴보면서 궁금한 점이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7457e7f50b46549cb637fd1cddab7ebcad06d948" translate="yes" xml:space="preserve">
          <source>As we have seen, LiveView begins its life-cycle as a regular HTTP request. Then a stateful connection is established. Both the HTTP request and the stateful connection receives the client data via parameters and session. This means that any session validation must happen both in the HTTP request and the stateful connection.</source>
          <target state="translated">이미 살펴본 것처럼 LiveView는 일반 HTTP 요청으로 수명주기를 시작합니다. 그런 다음 상태 저장 연결이 설정됩니다. HTTP 요청과 상태 저장 연결 모두 매개 변수와 세션을 통해 클라이언트 데이터를 수신합니다. 이는 모든 세션 유효성 검사가 HTTP 요청과 상태 저장 연결 모두에서 발생해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c0bcd2ed6f294fc4464e5815ba90d6d66fe1e74" translate="yes" xml:space="preserve">
          <source>As we will see in &lt;a href=&quot;routing&quot;&gt;the Routing guide&lt;/a&gt;, the pipelines themselves are plugs. There we will also discuss all plugs in the &lt;code&gt;:browser&lt;/code&gt; pipeline.</source>
          <target state="translated">&lt;a href=&quot;routing&quot;&gt;라우팅 가이드&lt;/a&gt; 에서 볼 수 있듯이 파이프 라인 자체는 플러그입니다. 여기에서 &lt;code&gt;:browser&lt;/code&gt; 파이프 라인 의 모든 플러그에 대해서도 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="ec4b354848c4c238d7f3d05ba632a1e321221959" translate="yes" xml:space="preserve">
          <source>As we've seen throughout this guide, both mix itself and the dependencies we bring in to our application provide a number of really useful tasks for free. Since neither of these could possibly anticipate all our individual application's needs, mix allows us to create our own custom tasks. That's exactly what we are going to do now.</source>
          <target state="translated">이 가이드 전체에서 살펴본 바와 같이, 혼합 자체와 애플리케이션에 가져 오는 종속성은 정말 유용한 많은 작업을 무료로 제공합니다. 이들 중 어느 것도 우리의 개별 응용 프로그램의 모든 요구를 예상 할 수 없기 때문에 mix를 사용하면 사용자 지정 작업을 만들 수 있습니다. 그것이 바로 우리가 지금 할 일입니다.</target>
        </trans-unit>
        <trans-unit id="871be10c0f7df0592f19a11a6e110ad51e1ddfdc" translate="yes" xml:space="preserve">
          <source>As we've seen, designing with contexts gives you a solid foundation to grow your application from. Using discrete, well-defined APIs that expose the intent of your system allows you to write more maintainable applications with reusable code.</source>
          <target state="translated">지금까지 살펴본 것처럼 컨텍스트를 사용한 디자인은 애플리케이션을 성장시킬 수있는 견고한 기반을 제공합니다. 시스템의 의도를 노출하는 잘 정의 된 별개의 API를 사용하면 재사용 가능한 코드로 더 유지 관리가 가능한 애플리케이션을 작성할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="60ff1bbd92ceef868ed8e4680400f13d86c1a3bc" translate="yes" xml:space="preserve">
          <source>As we've seen, your context modules are dedicated modules that expose and group related functionality. Phoenix generates generic functions, such as &lt;code&gt;list_users&lt;/code&gt; and &lt;code&gt;update_user&lt;/code&gt;, but they only serve as a basis for you to grow your business logic and application from. To begin extending our &lt;code&gt;Accounts&lt;/code&gt; context with real features, let's address an obvious issue of our application &amp;ndash; we can create users with credentials in our system, but they have no way of signing in with those credentials. Building a complete user authentication system is beyond the scope of this guide, but let's get started with a basic email-only sign-in page that allows us to track a current user's session. This will let us focus on extending our &lt;code&gt;Accounts&lt;/code&gt; context while giving you a good start to grow a complete authentication solution from.</source>
          <target state="translated">지금까지 살펴본 것처럼 컨텍스트 모듈은 관련 기능을 노출하고 그룹화하는 전용 모듈입니다. Phoenix는 &lt;code&gt;list_users&lt;/code&gt; 및 &lt;code&gt;update_user&lt;/code&gt; 와 같은 일반 함수를 생성 하지만 비즈니스 로직 및 애플리케이션을 확장하기위한 기초 역할 만합니다 . 실제 기능으로 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트를 확장하기 위해 애플리케이션의 명백한 문제를 해결하겠습니다. 시스템에서 자격 증명을 사용하여 사용자를 만들 수 있지만 해당 자격 증명으로 로그인 할 방법이 없습니다. 완전한 사용자 인증 시스템을 구축하는 것은이 가이드의 범위를 벗어나지 만 현재 사용자의 세션을 추적 할 수있는 기본 이메일 전용 로그인 페이지부터 시작하겠습니다. 이를 통해 &lt;code&gt;Accounts&lt;/code&gt; 확장에 집중할 수 있습니다. 완벽한 인증 솔루션을 성장시킬 수있는 좋은 출발점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d28976d77d0ac5ae799851b8fa02ff44a5eea6d9" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#render_submit/2&quot;&gt;&lt;code&gt;render_submit/2&lt;/code&gt;&lt;/a&gt;, hidden input field values can be provided like so:</source>
          <target state="translated">&lt;a href=&quot;#render_submit/2&quot;&gt; &lt;code&gt;render_submit/2&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 숨겨진 입력 필드 값을 다음과 같이 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a063bfa11fd130bfec49f4aa0ff0c57a16e8ade9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;where&lt;/code&gt; and friends, it is not possible to pass dynamics outside of a root. For example, this won't work:</source>
          <target state="translated">As with &lt;code&gt;where&lt;/code&gt; and friends, it is not possible to pass dynamics outside of a root. For example, this won't work:</target>
        </trans-unit>
        <trans-unit id="0ef18598d1271d2d73abb69726ba544c972e24be" translate="yes" xml:space="preserve">
          <source>As with any other Elixir code, exceptions may happen during the LiveView life-cycle. In this section we will describe how LiveView reacts to errors at different stages.</source>
          <target state="translated">다른 Elixir 코드와 마찬가지로 LiveView 수명주기 동안 예외가 발생할 수 있습니다. 이 섹션에서는 LiveView가 여러 단계에서 오류에 어떻게 반응하는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d9df39041001cb183a32f86f88c0a2f7d5beaded" translate="yes" xml:space="preserve">
          <source>As with other &lt;code&gt;handle_*&lt;/code&gt; callback, changes to the state inside &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; will trigger a server render.</source>
          <target state="translated">다른 &lt;code&gt;handle_*&lt;/code&gt; 콜백 과 마찬가지로 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt; 내부의 상태를 변경 하면 서버 렌더링이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="868db82198436ae137106ae18a1c27c3628d32a7" translate="yes" xml:space="preserve">
          <source>As with routers, controllers also have their own plug pipeline. However, different from routers, controllers have a single pipeline:</source>
          <target state="translated">라우터와 마찬가지로 컨트롤러에도 자체 플러그 파이프 라인이 있습니다. 그러나 라우터와 달리 컨트롤러에는 단일 파이프 라인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13b8d369d8e5d9d561d4e6a9af6e49bd6113fb8" translate="yes" xml:space="preserve">
          <source>As you follow along with this guide, we will introduce you to the core concepts of Telemetry, you will initialize a reporter to capture your application's events as they occur, and we will guide you through the steps to properly instrument your own functions using &lt;code&gt;:telemetry&lt;/code&gt;. Let's take a closer look at how Telemetry works in your application.</source>
          <target state="translated">이 가이드를 따라 가면서 Telemetry의 핵심 개념을 소개하고, 애플리케이션의 이벤트가 발생하면이를 캡처하도록 리포터를 초기화하고, &lt;code&gt;:telemetry&lt;/code&gt; 를 사용하여 자신의 함수를 적절하게 계측하는 단계를 안내합니다 . . 애플리케이션에서 Telemetry가 어떻게 작동하는지 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="58211b3a044ad9d59816ab93e7995e3ad07c0dae" translate="yes" xml:space="preserve">
          <source>As you may recall, Elixir templates use Embedded Elixir, known as &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt;&lt;code&gt;EEx&lt;/code&gt;&lt;/a&gt;. We use &lt;code&gt;&amp;lt;%= expression %&amp;gt;&lt;/code&gt; to execute Elixir expressions. The result of the expression is interpolated into the template. You can use pretty much any Elixir expression. For example, in order to have conditionals:</source>
          <target state="translated">기억 하시겠지만 Elixir 템플릿은 &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt; &lt;code&gt;EEx&lt;/code&gt; 로&lt;/a&gt; 알려진 Embedded Elixir를 사용 합니다. 우리가 사용하는 &lt;code&gt;&amp;lt;%= expression %&amp;gt;&lt;/code&gt; 비약 식을 실행합니다. 표현식의 결과는 템플릿에 삽입됩니다. 거의 모든 Elixir 표현을 사용할 수 있습니다. 예를 들어, 조건문을 가지려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="71076af94cd1aff015f5fde9464389c381fb4d31" translate="yes" xml:space="preserve">
          <source>As you may suspect, keeping the whole chat conversation in memory and resending it on every update would be too expensive, even with LiveView smart change tracking. By using temporary assigns and phx-update, we don't need to keep any messages in memory, and send messages to be appended to the UI only when there are new ones.</source>
          <target state="translated">짐작할 수 있듯이 LiveView 스마트 변경 추적을 사용하더라도 전체 채팅 대화를 메모리에 저장하고 업데이트 할 때마다 다시 보내는 것은 너무 비쌉니다. 임시 할당 및 phx-update를 사용하면 메시지를 메모리에 보관할 필요가 없으며 새 메시지가있을 때만 UI에 추가 할 메시지를 보낼 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="f633ddebff9318c264a20f27c58016efb19bd167" translate="yes" xml:space="preserve">
          <source>Ask or answer questions about Phoenix on &lt;a href=&quot;https://elixirforum.com/c/phoenix-forum&quot;&gt;Elixir Forum&lt;/a&gt; or &lt;a href=&quot;http://stackoverflow.com/questions/tagged/phoenix-framework&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://elixirforum.com/c/phoenix-forum&quot;&gt;Elixir Forum&lt;/a&gt; 또는 &lt;a href=&quot;http://stackoverflow.com/questions/tagged/phoenix-framework&quot;&gt;Stack Overflow&lt;/a&gt; 에서 Phoenix에 대해 질문하거나 답변하십시오 .</target>
        </trans-unit>
        <trans-unit id="475b9e09b92d98b6d96cb1e2b9b95148e9c2b0c7" translate="yes" xml:space="preserve">
          <source>Asks if the user wants to open a file based on ECTO_EDITOR</source>
          <target state="translated">사용자가 ECTO_EDITOR를 기반으로 파일을 열려고하는지 묻습니다.</target>
        </trans-unit>
        <trans-unit id="006f6f8b5cb840127d26d2d28ee9849be1f8d9fc" translate="yes" xml:space="preserve">
          <source>Asks if the user wants to open a file based on ECTO_EDITOR.</source>
          <target state="translated">사용자가 ECTO_EDITOR를 기반으로 파일을 열지 여부를 묻습니다.</target>
        </trans-unit>
        <trans-unit id="6dc21f6456de8c94602f412eaba76e77b8fa179d" translate="yes" xml:space="preserve">
          <source>Asserts a hook reply was returned from a &lt;code&gt;handle_event&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;handle_event&lt;/code&gt; 콜백 에서 후크 응답이 리턴 되었음을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="adaf4cf4c61a7303edd08b21684c8eab128ddeed" translate="yes" xml:space="preserve">
          <source>Asserts a live patch was performed.</source>
          <target state="translated">라이브 패치가 수행되었음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="969492330997b420ecd871d0cc0056d6d9e9bf2e" translate="yes" xml:space="preserve">
          <source>Asserts a live patch will happen within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 라이브 패치가 발생한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="812a6202573bcb920f610b23008af522ed8d26cc" translate="yes" xml:space="preserve">
          <source>Asserts a redirect was performed.</source>
          <target state="translated">리디렉션이 수행되었음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="23de39b8a1ad126d48631687777de4468b1fcbce" translate="yes" xml:space="preserve">
          <source>Asserts a redirect will happen within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 리디렉션이 발생한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8d826fc68bb29920fcc1466f25e2e36d3d47b6" translate="yes" xml:space="preserve">
          <source>Asserts an error was wrapped and sent with the given status</source>
          <target state="translated">주어진 상태로 오류가 랩핑되어 전송되었음을 확인</target>
        </trans-unit>
        <trans-unit id="14dacb2eaf39d88a53c805aade746d59005bd40d" translate="yes" xml:space="preserve">
          <source>Asserts an error was wrapped and sent with the given status.</source>
          <target state="translated">주어진 상태로 오류가 랩핑되어 전송되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6dab300ce3e8854ad3067c32d62ed6ade4f7b216" translate="yes" xml:space="preserve">
          <source>Asserts an event will be pushed within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">이벤트가 &lt;code&gt;timeout&lt;/code&gt; 내에 푸시 될 것임을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f561847fbcc30ef099c2fdb4d7f9ecbb769368b9" translate="yes" xml:space="preserve">
          <source>Asserts the channel has broadcast a message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">채널이 &lt;code&gt;timeout&lt;/code&gt; 내에 메시지를 브로드 캐스트했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="69c1aafea3e15d75f9b8e5e7f4b7ee180908fa25" translate="yes" xml:space="preserve">
          <source>Asserts the channel has broadcast a message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">채널이 &lt;code&gt;timeout&lt;/code&gt; 내에 메시지를 브로드 캐스트했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c1e0c079e28ea0e490465ee00c1b2e6b15935463" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not broadcast a message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 채널이 메시지를 브로드 캐스트하지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c140d2f9a5c6e70b4bddb0b29be0b82e3d7034fa" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not broadcast a message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">채널이 &lt;code&gt;timeout&lt;/code&gt; 내에 메시지를 브로드 캐스트하지 않았 음을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="d424205c41f2118eb9fd5a7f0610874508d900e3" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not pushed a message to the client matching the given event and payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">채널이 지정된 이벤트 및 페이로드가 &lt;code&gt;timeout&lt;/code&gt; 내에 일치하는 메시지를 클라이언트에 푸시하지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dd195750fce0de0311eeab0dd8758295106faf6a" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not pushed a message to the client matching the given event and payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">채널이 지정된 이벤트 및 페이로드가 &lt;code&gt;timeout&lt;/code&gt; 내에 일치하는 메시지를 클라이언트에 푸시하지 않았 음을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f37dd31b07d6e30495dbce12a320ab6f115b7072" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not replied with a matching payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 채널이 일치하는 페이로드로 응답하지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f543c3267625ded4bf34a8f8595eb6f80560c8b7" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not replied with a matching payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 채널이 일치하는 페이로드로 응답하지 않았 음을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="fb8e710870c1e8f2ae11881ad6a7b9f893cf92f6" translate="yes" xml:space="preserve">
          <source>Asserts the channel has pushed a message back to the client with the given event and payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">지정된 이벤트 및 페이로드가 &lt;code&gt;timeout&lt;/code&gt; 내에 채널에서 클라이언트로 메시지를 푸시했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fb7f0ad50740a6b05d2126fa477ce96ef0a8211" translate="yes" xml:space="preserve">
          <source>Asserts the channel has pushed a message back to the client with the given event and payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">지정된 이벤트 및 페이로드가 &lt;code&gt;timeout&lt;/code&gt; 내에 채널에서 클라이언트로 메시지를 푸시했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c887a57a1301c3376a8b187b83da77d3b9304d5f" translate="yes" xml:space="preserve">
          <source>Asserts the channel has replied to the given message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 채널이 지정된 메시지에 응답했는지 확인</target>
        </trans-unit>
        <trans-unit id="6ddf47c3c727b5b98212842dc153fb9ef73dfb67" translate="yes" xml:space="preserve">
          <source>Asserts the channel has replied to the given message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 채널이 지정된 메시지에 응답했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ea30be74b1b6dfeafbc74b5278e93a1ef8635f78" translate="yes" xml:space="preserve">
          <source>Asserts the given status code and returns the response body if one was set or sent</source>
          <target state="translated">주어진 상태 코드를 확인하고 설정 또는 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40aec7b844428bccf332b76d4a7cea4d73c9f80b" translate="yes" xml:space="preserve">
          <source>Asserts the given status code and returns the response body if one was set or sent.</source>
          <target state="translated">주어진 상태 코드를 확인하고 설정 또는 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92eed7d512a2ff5c15049fbde292f3357c386ba4" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have a json response and returns the decoded JSON response if one was set or sent.</source>
          <target state="translated">Asserts the given status code, that we have a json response and returns the decoded JSON response if one was set or sent.</target>
        </trans-unit>
        <trans-unit id="519c68c331196b4f0042ee79374fcbf0eb6379f0" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have a text response and returns the response body if one was set or sent.</source>
          <target state="translated">Asserts the given status code, that we have a text response and returns the response body if one was set or sent.</target>
        </trans-unit>
        <trans-unit id="4361d343642668ab91330760dcb1e9daf427439b" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an html response and returns the response body if one was set or sent</source>
          <target state="translated">주어진 상태 코드를 확인합니다. HTML 응답이 있고 응답 본문이 설정되거나 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01ce9d8e19df4acc7484e73368b791392c2f5b64" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an html response and returns the response body if one was set or sent.</source>
          <target state="translated">주어진 상태 코드를 확인하여 HTML 응답이 있고 응답 본문이 설정되거나 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94ee684deb18054648b499b661eaeadc364ac50c" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent</source>
          <target state="translated">주어진 상태 코드를 확인합니다. json 응답이 있고 디코딩 된 JSON 응답이 설정되거나 전송 된 경우이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad672702a882d944ba4089007ddd2cb6a47abb2f" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent.</source>
          <target state="translated">주어진 상태 코드를 확인하여 json 응답이 있고 디코딩 된 JSON 응답이 설정되거나 전송 된 경우이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b22bfbfa6302d6cc628263305e33e5e5b9d808c" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an text response and returns the response body if one was set or sent</source>
          <target state="translated">주어진 상태 코드를 확인하여 텍스트 응답이 있고 응답 본문이 설정되거나 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7d64fc3c8c80b2f0927ca8acf2d9a14e5e45982" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an text response and returns the response body if one was set or sent.</source>
          <target state="translated">주어진 상태 코드를 확인하여 텍스트 응답이 있고 응답 본문이 설정되거나 전송 된 경우 응답 본문을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf03c483d1adf4976212ba47ed8fb5319fbdac" translate="yes" xml:space="preserve">
          <source>Assigning Layouts</source>
          <target state="translated">레이아웃 할당</target>
        </trans-unit>
        <trans-unit id="9f2a0cc5f167ef3113974a9fe34af5506e805041" translate="yes" xml:space="preserve">
          <source>Assigns</source>
          <target state="translated">Assigns</target>
        </trans-unit>
        <trans-unit id="574364eee69f68c55eb9dcc71dd468285d889db6" translate="yes" xml:space="preserve">
          <source>Assigns a new &lt;strong&gt;private&lt;/strong&gt; key and value in the connection</source>
          <target state="translated">연결에 새로운 &lt;strong&gt;개인&lt;/strong&gt; 키와 값을 할당 합니다</target>
        </trans-unit>
        <trans-unit id="bd83d5499e834c53bd79fb4fa56ff025df78093c" translate="yes" xml:space="preserve">
          <source>Assigns a new &lt;strong&gt;private&lt;/strong&gt; key and value in the connection.</source>
          <target state="translated">연결에 새로운 &lt;strong&gt;개인&lt;/strong&gt; 키와 값을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="7a78ed34e6eee12d271b969d452bf691c6a1c3b5" translate="yes" xml:space="preserve">
          <source>Assigns a value into the socket only if it does not exist.</source>
          <target state="translated">값이 존재하지 않는 경우에만 소켓에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ee9efccff63c64323b5a4f98fca8d2c724142663" translate="yes" xml:space="preserve">
          <source>Assigns a value to a key in the connection</source>
          <target state="translated">연결에서 키에 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="da5add16ce8a8cf627204ed4d5648a3d1ca3a351" translate="yes" xml:space="preserve">
          <source>Assigns a value to a key in the connection.</source>
          <target state="translated">연결에서 키에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ad133374d6d5235b0b1fd7164e56e8711c4ef530" translate="yes" xml:space="preserve">
          <source>Assigns and LiveEEx</source>
          <target state="translated">할당 및 LiveEEx</target>
        </trans-unit>
        <trans-unit id="dbe95ee0ca00c4adc99619cc358095693451bc12" translate="yes" xml:space="preserve">
          <source>Assigns and LiveEEx templates</source>
          <target state="translated">할당 및 LiveEEx 템플릿</target>
        </trans-unit>
        <trans-unit id="9c6b589d013aaba3d63ab9b088addc693226eaa6" translate="yes" xml:space="preserve">
          <source>Assigns are meant to be user data that will be available in templates. However, there are keys under assigns that are specially handled by Phoenix, they are:</source>
          <target state="translated">할당은 템플릿에서 사용할 수있는 사용자 데이터입니다. 그러나 피닉스가 특별히 처리하는 할당 키 아래에는 다음과 같은 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="147d0c86a092ea030ef3bda841fe74477ec9e5a7" translate="yes" xml:space="preserve">
          <source>Assigns multiple &lt;strong&gt;private&lt;/strong&gt; keys and values in the connection</source>
          <target state="translated">연결에 여러 &lt;strong&gt;개인&lt;/strong&gt; 키와 값을 할당 합니다</target>
        </trans-unit>
        <trans-unit id="757ea09ed7848c39bfeb25a79e148f85064a7e1a" translate="yes" xml:space="preserve">
          <source>Assigns multiple &lt;strong&gt;private&lt;/strong&gt; keys and values in the connection.</source>
          <target state="translated">연결에 여러 &lt;strong&gt;개인&lt;/strong&gt; 키와 값을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="a6dddc082668f89921e5bc9a19c53fadbba95e74" translate="yes" xml:space="preserve">
          <source>Assigns multiple values to keys in the connection</source>
          <target state="translated">연결에서 키에 여러 값을 할당</target>
        </trans-unit>
        <trans-unit id="6cc9a184a076e8b32ad317761089937067633e4a" translate="yes" xml:space="preserve">
          <source>Assigns multiple values to keys in the connection.</source>
          <target state="translated">연결의 키에 여러 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="b802e5b1cff34526d856a0a100a2dbbb152b074d" translate="yes" xml:space="preserve">
          <source>Associations, embeds and on replace</source>
          <target state="translated">연관, 임베드 및 교체</target>
        </trans-unit>
        <trans-unit id="56f8a2dd87419ea091ce075611de251ffc698b80" translate="yes" xml:space="preserve">
          <source>Assuming the above code, a request to &lt;code&gt;/users/sign_in&lt;/code&gt; will be forwarded to the &lt;code&gt;UserRouter&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/sign_in&lt;/code&gt;.</source>
          <target state="translated">위의 코드를 가정하면 &lt;code&gt;/users/sign_in&lt;/code&gt; 에 대한 요청 은 &lt;code&gt;UserRouter&lt;/code&gt; 플러그 로 전달되며 ,이 값은 &lt;code&gt;/sign_in&lt;/code&gt; 에 대한 요청으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c804cad0774fdc88933e3e582b28b80f3857c48a" translate="yes" xml:space="preserve">
          <source>Assuming we have a &lt;code&gt;Post&lt;/code&gt; schema (stored in the &lt;code&gt;posts&lt;/code&gt; table), the first step is to add a version column to the &lt;code&gt;posts&lt;/code&gt; table:</source>
          <target state="translated">우리는이 가정 &lt;code&gt;Post&lt;/code&gt; 합니다 (저장 스키마 &lt;code&gt;posts&lt;/code&gt; 테이블), 첫 번째 단계는에 버전 열을 추가하는 것입니다 &lt;code&gt;posts&lt;/code&gt; 테이블 :</target>
        </trans-unit>
        <trans-unit id="86c8bfff0642e8f1e006970ab9967dd6f94624c9" translate="yes" xml:space="preserve">
          <source>Asynchronously updates a &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt; with new assigns.</source>
          <target state="translated">새로운 할당 으로 &lt;a href=&quot;phoenix.livecomponent&quot;&gt; &lt;code&gt;Phoenix.LiveComponent&lt;/code&gt; &lt;/a&gt; 를 비동기 적으로 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="730f20a52e86a944cd13ad339e3ca66cf8875996" translate="yes" xml:space="preserve">
          <source>At the end of the day, a LiveView is nothing more than a process that receives events as messages and updates its state. The state itself is nothing more than functional and immutable Elixir data structures. The events are either internal application messages (usually emitted by &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;) or sent by the client/browser.</source>
          <target state="translated">하루가 끝나면 LiveView는 이벤트를 메시지로 수신하고 상태를 업데이트하는 프로세스에 지나지 않습니다. 상태 자체는 기능적이고 불변의 Elixir 데이터 구조 일뿐입니다. 이벤트는 내부 애플리케이션 메시지 (일반적으로 &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 에서 내보냄&lt;/a&gt; )이거나 클라이언트 / 브라우저에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5aebdf401ce4f348f998b1ebf4d450c362241ea4" translate="yes" xml:space="preserve">
          <source>At the end of the day, by replacing the nested blocks of code with a flattened series of plug transformations, we are able to achieve the same functionality in a much more composable, clear, and reusable way.</source>
          <target state="translated">하루가 끝나면 중첩 된 코드 블록을 평면화 된 일련의 플러그 변환으로 대체하여 훨씬 더 구성 가능하고 명확하며 재사용 가능한 방식으로 동일한 기능을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af8f720335af4138486691722f60532c39d648f" translate="yes" xml:space="preserve">
          <source>At the end of the day, our templates are always compiled into Elixir code. Let's learn more about this.</source>
          <target state="translated">하루가 끝나면 템플릿은 항상 Elixir 코드로 컴파일됩니다. 이것에 대해 더 배우자.</target>
        </trans-unit>
        <trans-unit id="14e654e0b50eb6a926a4d9b3a00a855ad5876525" translate="yes" xml:space="preserve">
          <source>At the end of the day, regardless if you invoke &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt;&lt;code&gt;link/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;live_redirect/2&lt;/code&gt;&lt;/a&gt; from the client, or &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt;&lt;code&gt;redirect/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; from the server, the user will end-up on the same page. The difference between those is mostly the amount of data sent over the wire:</source>
          <target state="translated">에 관계없이 하루의 끝에서 만약 당신이 호출 &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt; &lt;code&gt;link/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt; &lt;code&gt;live_redirect/2&lt;/code&gt; &lt;/a&gt; 클라이언트, 또는에서 &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt; &lt;code&gt;redirect/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt; &lt;code&gt;push_redirect/2&lt;/code&gt; &lt;/a&gt; 서버에서, 사용자는 최종까지합니다 같은 페이지에. 이들의 차이점은 대부분 유선을 통해 전송되는 데이터의 양입니다.</target>
        </trans-unit>
        <trans-unit id="56b36c55a19e26ff96a0b6dd23511c3329ef78c0" translate="yes" xml:space="preserve">
          <source>At the end of this section, you must have installed Elixir, Hex, Phoenix, PostgreSQL and node.js. Now that we have everything installed, let's create our first Phoenix application and get &lt;a href=&quot;up_and_running&quot;&gt;up and running&lt;/a&gt;.</source>
          <target state="translated">이 섹션이 끝나면 Elixir, Hex, Phoenix, PostgreSQL 및 node.js가 설치되어 있어야합니다. 이제 우리는 모든 설치되어 있는지,의 우리의 첫 피닉스 응용 프로그램을 만들 수 있도록 &lt;a href=&quot;up_and_running&quot;&gt;하고 실행&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0b9aa74251acf133476dd7a1fb25e39fd253e6" translate="yes" xml:space="preserve">
          <source>At the end sets the connection state to &lt;code&gt;:sent&lt;/code&gt;.</source>
          <target state="translated">마지막에 연결 상태를 &lt;code&gt;:sent&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c2f85717edc27497c79c08aabb877d7e0f9cec" translate="yes" xml:space="preserve">
          <source>At the moment, using a schema with source fields in CTE may emit invalid queries. If you are running into such scenarios, your best option is to use a fragment as your CTE.</source>
          <target state="translated">At the moment, using a schema with source fields in CTE may emit invalid queries. If you are running into such scenarios, your best option is to use a fragment as your CTE.</target>
        </trans-unit>
        <trans-unit id="475bdea221d93e5676e928712140b57516957c55" translate="yes" xml:space="preserve">
          <source>At the simplest level, the Plug specification comes in two flavors: &lt;em&gt;function plugs&lt;/em&gt; and &lt;em&gt;module plugs&lt;/em&gt;.</source>
          <target state="translated">가장 간단한 수준에서 플러그 사양은 &lt;em&gt;기능 플러그&lt;/em&gt; 와 &lt;em&gt;모듈 플러그의&lt;/em&gt; 두 가지 형태로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7efd02772e9aae7a884306c7395cc454402ec969" translate="yes" xml:space="preserve">
          <source>At this moment, you may be thinking this can be a lot of steps to simply render a page. However, as our application grows in complexity, we will see that each layer serves a distinct purpose:</source>
          <target state="translated">현재로서는 단순히 페이지를 렌더링하는 많은 단계가 될 수 있다고 생각할 수 있습니다. 그러나 애플리케이션이 복잡 해짐에 따라 각 계층이 고유 한 목적을 수행한다는 것을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4927c7da0be48fa0923cc88982ae3b251f69456" translate="yes" xml:space="preserve">
          <source>Atoms (other than booleans and &lt;code&gt;nil&lt;/code&gt;): &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:bar&lt;/code&gt;</source>
          <target state="translated">Atoms (other than booleans and &lt;code&gt;nil&lt;/code&gt; ): &lt;code&gt;:foo&lt;/code&gt; , &lt;code&gt;:bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4272dc1f3f36ae0db4df38f283b5fe8748a6ff3" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection&amp;rsquo;s request body given the content-type type, subtype, and its parameters</source>
          <target state="translated">컨텐츠 유형, 하위 유형 및 해당 매개 변수가 제공된 경우 연결 요청 본문을 구문 분석하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5adb472163a6582271e0a7f045107d9d435aeb4d" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection&amp;rsquo;s request body given the content-type type, subtype, and its parameters.</source>
          <target state="translated">컨텐츠 유형, 하위 유형 및 해당 매개 변수가 제공된 경우 연결 요청 본문을 구문 분석하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2d090490f8273f292dfbf2b46b5622e07c157083" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection's request body given the content-type type, subtype, and its parameters.</source>
          <target state="translated">Attempts to parse the connection's request body given the content-type type, subtype, and its parameters.</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="37f1e388727dba012ec8b58b5511aeea7f852344" translate="yes" xml:space="preserve">
          <source>Author information should appear with the page, and include information such as author bio and role within the CMS, such as &lt;code&gt;&quot;editor&quot;&lt;/code&gt;, &lt;code&gt;&quot;writer&quot;&lt;/code&gt;, or &lt;code&gt;&quot;intern&quot;&lt;/code&gt;.</source>
          <target state="translated">작성자 정보는 페이지와 함께 나타나야하며 &lt;code&gt;&quot;editor&quot;&lt;/code&gt; , &lt;code&gt;&quot;writer&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;intern&quot;&lt;/code&gt; 과 같은 작성자 약력 및 CMS 내 역할과 같은 정보를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e25ce007aa95ea2ea8b158aee9c630a32ea5616" translate="yes" xml:space="preserve">
          <source>Authorization</source>
          <target state="translated">Authorization</target>
        </trans-unit>
        <trans-unit id="7dd6dabb0c5ff27d14867c7a0d5f7ad8c0d3dd31" translate="yes" xml:space="preserve">
          <source>Autogenerate</source>
          <target state="translated">Autogenerate</target>
        </trans-unit>
        <trans-unit id="03dcefaf5fdafcdcee4b084ba846e764fc47771f" translate="yes" xml:space="preserve">
          <source>Available for transports that generate a connection.</source>
          <target state="translated">연결을 생성하는 전송에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8c754fb0802b948868dd2247860ee54e3521f8dc" translate="yes" xml:space="preserve">
          <source>Avoid defining local variables, except within &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and friends</source>
          <target state="translated">, &lt;code&gt;case&lt;/code&gt; 및 친구 &lt;code&gt;for&lt;/code&gt; 제외하고 지역 변수를 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0c0f599c56667a33df59b19c4fa8286c2b38c862" translate="yes" xml:space="preserve">
          <source>Avoid passing block expressions to library and custom functions</source>
          <target state="translated">블록 표현식을 라이브러리 및 사용자 지정 함수에 전달하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8faf407e50cfbddaaa8c6b940974389bbb77f58e" translate="yes" xml:space="preserve">
          <source>Awaits the completion of an async assign</source>
          <target state="translated">비동기 할당 완료를 기다립니다</target>
        </trans-unit>
        <trans-unit id="2168f4814ee9c5fe1b06e3b972eb6f903c518991" translate="yes" xml:space="preserve">
          <source>Awaits the completion of an async assign.</source>
          <target state="translated">비동기 할당 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="b1ff57d696aa3ec09bd76c88944e1a7097ee37a3" translate="yes" xml:space="preserve">
          <source>Bad:</source>
          <target state="translated">Bad:</target>
        </trans-unit>
        <trans-unit id="6f69f815f19f72bb41c1c4436ba66d01cf0d77fa" translate="yes" xml:space="preserve">
          <source>Be aware that a &lt;code&gt;:multiple&lt;/code&gt; option will not generate a correctly functioning multiple select element. Use &lt;a href=&quot;#multiple_select/4&quot;&gt;&lt;code&gt;multiple_select/4&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&amp;bull; 그래도주의 &lt;code&gt;:multiple&lt;/code&gt; 옵션은 제대로 작동 여러 선택 요소를 생성하지 않습니다. 대신 &lt;a href=&quot;#multiple_select/4&quot;&gt; &lt;code&gt;multiple_select/4&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b7cf944c5f95100a7935a4fa47e890840645b9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;:join_through&lt;/code&gt; contains a schema, in such cases, autogenerated values and primary keys will be automatically handled by Ecto.</source>
          <target state="translated">&lt;code&gt;:join_through&lt;/code&gt; 에는 스키마가 포함 되므로 이러한 경우 자동 생성 된 값과 기본 키는 Ecto에서 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2842d72449f72f76dd6436b34b221777bfc86a74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is unable to compute diffs inside anonymous functions, Phoenix.HTML provides &lt;a href=&quot;#form_for/3&quot;&gt;&lt;code&gt;form_for/3&lt;/code&gt;&lt;/a&gt; that works without passing an anonymous function. Inside live views, instead of</source>
          <target state="translated">Because &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is unable to compute diffs inside anonymous functions, Phoenix.HTML provides &lt;a href=&quot;#form_for/3&quot;&gt; &lt;code&gt;form_for/3&lt;/code&gt; &lt;/a&gt; that works without passing an anonymous function. Inside live views, instead of</target>
        </trans-unit>
        <trans-unit id="9262b037e2212c6d03d3d7d5fb577f82e1400995" translate="yes" xml:space="preserve">
          <source>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value &lt;em&gt;before&lt;/em&gt; the checkbox field to ensure the &lt;code&gt;unchecked_value&lt;/code&gt; is sent when the checkbox is not marked.</source>
          <target state="translated">선택하지 않은 확인란이 서버로 전송되지 않으므로 Phoenix 는 확인란이 표시 &lt;code&gt;unchecked_value&lt;/code&gt; 경우 unchecked_value 가 전송 되도록 확인란 필드 &lt;em&gt;앞에&lt;/em&gt; unchecked_value가있는 숨겨진 필드를 자동으로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="3e6dd93facd60dadc7922885b15c8f608eb6e973" translate="yes" xml:space="preserve">
          <source>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value &lt;em&gt;before&lt;/em&gt; the checkbox field to ensure the &lt;code&gt;unchecked_value&lt;/code&gt; is sent when the checkbox is not marked. Set &lt;code&gt;hidden_input&lt;/code&gt; to false If you don't want to send values from unchecked checkbox to the server.</source>
          <target state="translated">Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value &lt;em&gt;before&lt;/em&gt; the checkbox field to ensure the &lt;code&gt;unchecked_value&lt;/code&gt; is sent when the checkbox is not marked. Set &lt;code&gt;hidden_input&lt;/code&gt; to false If you don't want to send values from unchecked checkbox to the server.</target>
        </trans-unit>
        <trans-unit id="bdb9a6e7bde3ab5a7bc1495dec9bb0e16986001a" translate="yes" xml:space="preserve">
          <source>Because channels are spawned from the transport process, transports must trap exits and correctly handle the &lt;code&gt;{:EXIT, _, _}&lt;/code&gt; messages arriving from channels, relaying the proper response to the client.</source>
          <target state="translated">전송 프로세스에서 채널이 생성되므로 전송은 엑시트를 트랩하고 채널에서 도착한 &lt;code&gt;{:EXIT, _, _}&lt;/code&gt; 메시지를 올바르게 처리 하여 클라이언트에 올바른 응답을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="075cd0e73f7ec163ee1bd17ac66ecb22aea6420b" translate="yes" xml:space="preserve">
          <source>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, requests with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped requests. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, requests with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped requests. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0ffd1482ad9b039cd9a1b7189da93b88ba55a74b" translate="yes" xml:space="preserve">
          <source>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="efbb223e1e0205999506019f53282716fca5c16e" translate="yes" xml:space="preserve">
          <source>Because many databases do not support direct encoding and decoding of embeds, it is often emulated by Ecto by using specific encoding and decoding rules.</source>
          <target state="translated">많은 데이터베이스가 임베드의 직접 인코딩 및 디코딩을 지원하지 않기 때문에 Ecto는 종종 특정 인코딩 및 디코딩 규칙을 사용하여 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="ff3b261bdf6330bac84251a0b0895a163e937f12" translate="yes" xml:space="preserve">
          <source>Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the &lt;code&gt;:on_conflict&lt;/code&gt; option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association.</source>
          <target state="translated">Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the &lt;code&gt;:on_conflict&lt;/code&gt; option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association.</target>
        </trans-unit>
        <trans-unit id="fe0d51764665fe5a0cca90e95e7b401430abc9ea" translate="yes" xml:space="preserve">
          <source>Because of the inability to know if the struct is up to date or not, using associations with the &lt;code&gt;:on_conflict&lt;/code&gt; option is not recommended. For instance, Ecto may even trigger constraint violations when associations are used with &lt;code&gt;on_conflict: :nothing&lt;/code&gt;, as no ID will be available in the case the record already exists, and it is not possible for Ecto to detect such cases reliably.</source>
          <target state="translated">struct가 최신인지 여부를 알 수 없으므로 &lt;code&gt;:on_conflict&lt;/code&gt; 옵션 과의 연관을 사용 하지 않는 것이 좋습니다. 예를 들어, 레코드가 이미 존재하는 경우 ID를 사용할 수 없으므로 Ecto가 그러한 경우를 안정적으로 감지 할 수 없으므로 &lt;code&gt;on_conflict: :nothing&lt;/code&gt; 과의 연관을 사용할 때 Ecto는 제약 조건 위반을 트리거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aff02a4110b82074d8c12773ef5ce6582b3ab82" translate="yes" xml:space="preserve">
          <source>Because such indexes have usually more complex names, we need to explicitly tell the changeset which constraint name to use (here we&amp;rsquo;re using the naming convention that &lt;code&gt;unique_index&lt;/code&gt; uses):</source>
          <target state="translated">이러한 인덱스는 일반적으로 더 복잡한 이름을 가지므로 변경 세트에 사용할 제한 조건 이름을 명시 적으로 알려야합니다 (여기서 &lt;code&gt;unique_index&lt;/code&gt; 에서 사용 하는 이름 지정 규칙을 사용함).</target>
        </trans-unit>
        <trans-unit id="224c09d9b7dd7d9d454778c8be5dd88e43a0c6ad" translate="yes" xml:space="preserve">
          <source>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let&amp;rsquo;s suppose the e-mails are scoped by company id. We would write in a migration:</source>
          <target state="translated">제약 조건 논리는 데이터베이스에 있기 때문에 정의 할 때 모든 데이터베이스 기능을 활용할 수 있습니다. 예를 들어, 전자 우편이 회사 ID별로 범위가 지정되었다고 가정하십시오. 우리는 마이그레이션에서 쓸 것입니다 :</target>
        </trans-unit>
        <trans-unit id="29fa3508631dd99aed1ca4933a5f561d0c8393e8" translate="yes" xml:space="preserve">
          <source>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let's suppose the e-mails are scoped by company id:</source>
          <target state="translated">Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let's suppose the e-mails are scoped by company id:</target>
        </trans-unit>
        <trans-unit id="b6739a5ab828592734049508a18dd56e17882475" translate="yes" xml:space="preserve">
          <source>Because the request body can be of any size, reading the body will only work once, as Plug will not cache the result of these operations. If you need to access the body multiple times, it is your responsibility to store it. Finally keep in mind some plugs like &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; may read the body, so the body may be unavailable after being accessed by such plugs.</source>
          <target state="translated">요청 본문은 모든 크기가 될 수 있기 때문에 플러그는 이러한 작업의 결과를 캐시하지 않으므로 본문을 한 번만 읽을 수 있습니다. 신체에 여러 번 접근해야하는 경우, 보관하는 것은 귀하의 책임입니다. 마지막으로 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 와 같은 일부 플러그 는 본문을 읽을 수 있으므로 이러한 플러그로 액세스 한 후 본문을 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd52c1c8179fc7e4ac27700b9459684e52d30867" translate="yes" xml:space="preserve">
          <source>Because the root layout from the Plug pipeline is rendered outside of LiveView, the contents cannot be dynamically changed. The one exception is the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; of the HTML document. Phoenix LiveView special cases the &lt;code&gt;@page_title&lt;/code&gt; assign to allow dynamically updating the title of the page, which is useful when using live navigation, or annotating the browser tab with a notification. For example, to update the user's notification count in the browser's title bar, first set the &lt;code&gt;page_title&lt;/code&gt; assign on mount:</source>
          <target state="translated">플러그 파이프 라인의 루트 레이아웃은 LiveView 외부에서 렌더링되기 때문에 콘텐츠를 동적으로 변경할 수 없습니다. 한 가지 예외는 HTML 문서 의 &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 입니다. Phoenix LiveView의 특수한 경우 &lt;code&gt;@page_title&lt;/code&gt; 은 페이지 제목을 동적으로 업데이트 할 수 있도록 할당합니다. 이는 실시간 탐색을 사용하거나 알림이 있는 브라우저 탭에 주석을 달 때 유용합니다. 예를 들어 브라우저의 제목 표시 줄에서 사용자의 알림 수를 업데이트하려면 먼저 탑재시 &lt;code&gt;page_title&lt;/code&gt; 할당을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d5b0de0d771e3732a5b80433909083879a3d87" translate="yes" xml:space="preserve">
          <source>Because the whole communication is asynchronous, the following test would be very brittle:</source>
          <target state="translated">전체 통신이 비동기 적이기 때문에 다음 테스트는 매우 취약합니다.</target>
        </trans-unit>
        <trans-unit id="15004b08989be5acc9e143193d78d8c2df3ea58b" translate="yes" xml:space="preserve">
          <source>Because we have defined the template root to be &quot;lib/your_app_web/templates&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; will automatically load all templates at &quot;your_app_web/templates/user&quot; and include them in the &lt;code&gt;YourApp.UserView&lt;/code&gt;. For example, imagine we have the template:</source>
          <target state="translated">Because we have defined the template root to be &quot;lib/your_app_web/templates&quot;, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt; will automatically load all templates at &quot;your_app_web/templates/user&quot; and include them in the &lt;code&gt;YourApp.UserView&lt;/code&gt; . For example, imagine we have the template:</target>
        </trans-unit>
        <trans-unit id="4e845000c50c1ebb2862affdc57cdca9446402dc" translate="yes" xml:space="preserve">
          <source>Because we have defined the template root to be &amp;ldquo;lib/web/templates&amp;rdquo;, &lt;a href=&quot;phoenix.view#content&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; will automatically load all templates at &amp;ldquo;web/templates/user&amp;rdquo; and include them in the &lt;code&gt;YourApp.UserView&lt;/code&gt;. For example, imagine we have the template:</source>
          <target state="translated">우리가 &quot;lib 디렉토리 / 웹 / 템플릿&quot;으로 템플릿 루트를 정의하기 때문에, &lt;a href=&quot;phoenix.view#content&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; 는&lt;/a&gt; 자동으로 &quot;웹 / 템플릿 / 사용자&quot;모든 템플릿을로드하고이에 포함됩니다 &lt;code&gt;YourApp.UserView&lt;/code&gt; . 예를 들어 템플릿이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="39f7cc114f2fc6cf106968527a393ef7ef7dc2da" translate="yes" xml:space="preserve">
          <source>Because we used &lt;code&gt;on_conflict: :nothing&lt;/code&gt;, instead of getting an error, we got &lt;code&gt;{:ok, struct}&lt;/code&gt;. However the returned struct does not reflect the data in the database. One possible mechanism to detect if an insert or nothing happened in case of &lt;code&gt;on_conflict: :nothing&lt;/code&gt; is by checking the &lt;code&gt;id&lt;/code&gt; field. &lt;code&gt;id&lt;/code&gt; will be nil if the field is autogenerated by the database and no insert happened.</source>
          <target state="translated">&lt;code&gt;on_conflict: :nothing&lt;/code&gt; 을 사용했기 때문에 오류 대신 &lt;code&gt;{:ok, struct}&lt;/code&gt; . 그러나 반환 된 구조체는 데이터베이스의 데이터를 반영하지 않습니다. &lt;code&gt;on_conflict: :nothing&lt;/code&gt; 경우 삽입 또는 아무것도 발생하지 않았는지 감지하는 한 가지 가능한 메커니즘 은 &lt;code&gt;id&lt;/code&gt; 필드 를 확인하는 것 입니다. 필드가 데이터베이스에 의해 자동 생성되고 삽입이 발생하지 않으면 &lt;code&gt;id&lt;/code&gt; 는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="cec01231d5cf7fe423826e9f5aced9fc26335180" translate="yes" xml:space="preserve">
          <source>Because you don't actually serve the file above, LiveView will interpret the static above as missing, and this function will return true.</source>
          <target state="translated">실제로 위의 파일을 제공하지 않기 때문에 LiveView는 위의 정적을 누락 된 것으로 해석하고이 함수는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cd2824c40cb6a858f71c571b7a9552c3251a948" translate="yes" xml:space="preserve">
          <source>Before asserting anything was broadcast, we must first subscribe to the topic of the channel in the test process:</source>
          <target state="translated">방송 된 것을 주장하기 전에 먼저 테스트 과정에서 채널의 주제를 구독해야합니다.</target>
        </trans-unit>
        <trans-unit id="10e2a276b7b8a66e21797960dc92a40e33aa0198" translate="yes" xml:space="preserve">
          <source>Before rendering, the &lt;code&gt;@live_module&lt;/code&gt; assign will be added to the connection assigns for reference.</source>
          <target state="translated">렌더링하기 전에 &lt;code&gt;@live_module&lt;/code&gt; 할당이 참조를 위해 연결 할당에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="48f2cdc0c1b8ff7cade454fbcf03343ddac9bcb5" translate="yes" xml:space="preserve">
          <source>Before we begin, please take a minute to read the &lt;a href=&quot;installation&quot;&gt;Installation Guide&lt;/a&gt;. By installing any necessary dependencies beforehand, we'll be able to get our application up and running smoothly.</source>
          <target state="translated">시작하기 전에 잠시 시간을내어 &lt;a href=&quot;installation&quot;&gt;설치 가이드&lt;/a&gt; 를 읽으십시오 . 필요한 종속성을 미리 설치하면 응용 프로그램을 원활하게 시작하고 실행할 수있을 것입니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="3f320c637a311d1fd877641dfa2301a8e1bd919b" translate="yes" xml:space="preserve">
          <source>Before we continue, we have a final migration to generate. Now that we have an authors table, we can associate pages and authors. Let's add an &lt;code&gt;author_id&lt;/code&gt; field to the pages table. Run the following command to generate a new migration:</source>
          <target state="translated">계속하기 전에 생성 할 최종 마이그레이션이 있습니다. 이제 작성자 테이블이 있으므로 페이지와 작성자를 연결할 수 있습니다. 페이지 테이블에 &lt;code&gt;author_id&lt;/code&gt; 필드를 추가해 보겠습니다 . 다음 명령을 실행하여 새 마이그레이션을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="053f49277ab135f6aca7d45e3e5dfbf937a0ab6f" translate="yes" xml:space="preserve">
          <source>Before we create a new layout, though, let's do the simplest possible thing and render a template with no layout at all.</source>
          <target state="translated">새 레이아웃을 만들기 전에 가능한 가장 간단한 작업을 수행하고 레이아웃이 전혀없는 템플릿을 렌더링 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0a5e4791b3b4e3bca9c0730f7fbb4694921315ec" translate="yes" xml:space="preserve">
          <source>Before we create any pages, we need page authors. Let's run the &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; generator to generate an &lt;code&gt;Author&lt;/code&gt; schema along with injected context functions:</source>
          <target state="translated">페이지를 만들기 전에 페이지 작성자가 필요합니다. 삽입 된 컨텍스트 함수와 함께 &lt;code&gt;Author&lt;/code&gt; 스키마 를 생성하기 위해 &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt; 생성기를 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d001e489410b0ef02cdf34a9be0452fe9a980231" translate="yes" xml:space="preserve">
          <source>Before we dive into this, let's see what the rendered &lt;code&gt;404 not found&lt;/code&gt; message looks like in a browser. In the development environment, Phoenix will debug errors by default, showing us a very informative debugging page. What we want here, however, is to see what page the application would serve in production. In order to do that we need to set &lt;code&gt;debug_errors: false&lt;/code&gt; in &lt;code&gt;config/dev.exs&lt;/code&gt;.</source>
          <target state="translated">이에 대해 자세히 알아보기 전에 렌더링 된 &lt;code&gt;404 not found&lt;/code&gt; 메시지가 브라우저에서 어떻게 보이는지 살펴 보겠습니다 . 개발 환경에서 Phoenix는 기본적으로 오류를 디버깅하여 매우 유익한 디버깅 페이지를 보여줍니다. 그러나 여기서 우리가 원하는 것은 애플리케이션이 프로덕션에서 어떤 페이지를 제공하는지 확인하는 것입니다. 이를 위해 &lt;code&gt;config/dev.exs&lt;/code&gt; 에서 &lt;code&gt;debug_errors: false&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acbb8816a2938865e0801c384dbfe24d5f743c61" translate="yes" xml:space="preserve">
          <source>Before we integrate credentials in the web layer, we need to let our context know how to associate users and credentials. First, open up &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt; and add the following association:</source>
          <target state="translated">웹 레이어에 자격 증명을 통합하기 전에 컨텍스트에 사용자와 자격 증명을 연결하는 방법을 알려야합니다. 먼저 &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt; 를 열고 다음 연결을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="85c3afb52167376c3a01845b237a79d4a27d5dd3" translate="yes" xml:space="preserve">
          <source>Before we jump into the generated code, let's start the server with &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt; and visit &lt;a href=&quot;http://localhost:4000/users&quot;&gt;http://localhost:4000/users&lt;/a&gt;. Let's follow the &quot;New User&quot; link and click the &quot;Submit&quot; button without providing any input. We should be greeted with the following output:</source>
          <target state="translated">생성 된 코드로 이동하기 전에 &lt;a href=&quot;mix.tasks.phx.server&quot;&gt; &lt;code&gt;mix phx.server&lt;/code&gt; 로&lt;/a&gt; 서버를 시작하고 &lt;a href=&quot;http://localhost:4000/users&quot;&gt;http : // localhost : 4000 / users를&lt;/a&gt; 방문 하십시오 . &quot;새 사용자&quot;링크를 따라 가서 입력하지 않고 &quot;제출&quot;버튼을 클릭 해 보겠습니다. 우리는 다음과 같은 출력을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="66ac6cd1d9b12dabda154c745aa7c9d4026165e8" translate="yes" xml:space="preserve">
          <source>Before we migrate our database, we need to handle data integrity once again in the newly generated &lt;code&gt;*_create_authors.exs&lt;/code&gt; migration. Open up the new file in &lt;code&gt;priv/repo/migrations&lt;/code&gt; and make the following change to the foreign key constraint:</source>
          <target state="translated">데이터베이스를 마이그레이션하기 전에 새로 생성 된 &lt;code&gt;*_create_authors.exs&lt;/code&gt; 마이그레이션 에서 데이터 무결성을 다시 한 번 처리해야 합니다. &lt;code&gt;priv/repo/migrations&lt;/code&gt; 에서 새 파일을 열고 외래 키 제약 조건을 다음과 같이 변경합니다.</target>
        </trans-unit>
        <trans-unit id="25d9f6c13b631445db64e327c46b4dbb16706aa1" translate="yes" xml:space="preserve">
          <source>Before we run our migrations, we need to make one change to the generated migration to enforce data integrity of user account credentials. In our case, we want a user's credentials to be deleted when the parent user is removed. Make the following change to your &lt;code&gt;*_create_credentials.exs&lt;/code&gt; migration file in &lt;code&gt;priv/repo/migrations/&lt;/code&gt;:</source>
          <target state="translated">마이그레이션을 실행하기 전에 생성 된 마이그레이션을 한 번 변경하여 사용자 계정 자격 증명의 데이터 무결성을 적용해야합니다. 이 경우 상위 사용자가 제거 될 때 사용자의 자격 증명이 삭제되기를 원합니다. &lt;code&gt;priv/repo/migrations/&lt;/code&gt; 에서 &lt;code&gt;*_create_credentials.exs&lt;/code&gt; 마이그레이션 파일 을 다음과 같이 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="a6563eb04be423b3a4271c47271a162e1bfb1daf" translate="yes" xml:space="preserve">
          <source>Before we run this task let's inspect the contents of two directories in our hello application.</source>
          <target state="translated">이 작업을 실행하기 전에 hello 애플리케이션에서 두 디렉토리의 내용을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ed0aeef3ce1f1355fb7dd0f793d3f8076fad30cd" translate="yes" xml:space="preserve">
          <source>Before we use the generators, we need to undo the changes we made in the Ecto guide, so we can give our user schema a proper home. Run these commands to undo our previous work:</source>
          <target state="translated">생성기를 사용하기 전에 Ecto 가이드에서 변경 한 사항을 취소해야 사용자 스키마에 적절한 홈을 제공 할 수 있습니다. 이전 작업을 취소하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7fcc2b3eb968342e0c6f964691dd598210edfa61" translate="yes" xml:space="preserve">
          <source>Before writing your first example, make sure that Phoenix LiveView is properly installed. If you are just getting started, this can be easily done by running &lt;code&gt;mix phx.new my_app --live&lt;/code&gt;. The &lt;code&gt;phx.new&lt;/code&gt; command with the &lt;code&gt;--live&lt;/code&gt; flag will create a new project with LiveView installed and configured. Otherwise, please follow the steps in the &lt;a href=&quot;installation&quot;&gt;installation guide&lt;/a&gt; before continuing.</source>
          <target state="translated">첫 번째 예제를 작성하기 전에 Phoenix LiveView가 제대로 설치되었는지 확인하십시오. 막 시작했다면 &lt;code&gt;mix phx.new my_app --live&lt;/code&gt; 를 실행하여 쉽게 수행 할 수 있습니다 . &lt;code&gt;--live&lt;/code&gt; 플래그가 있는 &lt;code&gt;phx.new&lt;/code&gt; 명령은 LiveView가 설치 및 구성된 새 프로젝트를 만듭니다. 그렇지 않으면 계속하기 전에 &lt;a href=&quot;installation&quot;&gt;설치 가이드&lt;/a&gt; 의 단계를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="4041ca44c3c741eba05c3336903154a869e43ff0" translate="yes" xml:space="preserve">
          <source>Behaves exactly the same as &lt;code&gt;where&lt;/code&gt; except it combines with any previous expression by using an &lt;code&gt;OR&lt;/code&gt;. All expressions have to evaluate to a boolean value.</source>
          <target state="translated">&lt;code&gt;OR&lt;/code&gt; 을 사용하여 이전 표현식과 결합 &lt;code&gt;where&lt;/code&gt; 것을 제외하고는 위치 와 정확히 동일하게 작동합니다 . 모든 표현식은 부울 값으로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="69bb93f8733104d33c3d36e7e5b282df9df17548" translate="yes" xml:space="preserve">
          <source>Behind the scenes, it uses &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뒤에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; 을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d35a0bd824cc8e4b8d193117df8ed871a26f82ac" translate="yes" xml:space="preserve">
          <source>Behind the scenes, it uses &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뒤에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e403e0ae9721d5783b70c50d5880748cf9f3c38e" translate="yes" xml:space="preserve">
          <source>Below we list all events developers should expect from Ecto. All examples below consider a repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;:</source>
          <target state="translated">Below we list all events developers should expect from Ecto. All examples below consider a repository named &lt;code&gt;MyApp.Repo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ad3316378f3ecae2aa5789e6ae98417f0d92ae" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:binary_id&lt;/code&gt;, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any column.</source>
          <target state="translated">기본 키와 외래 키에서 자주 사용되는 &lt;code&gt;:id&lt;/code&gt; 및 &lt;code&gt;:binary_id&lt;/code&gt; 외에도 Ecto는 모든 열에서 사용할 수있는 다양한 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5608ffc54f8eb63f27799f6ae50c2cfc29178f8" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:binary_id&lt;/code&gt;, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any field.</source>
          <target state="translated">Besides &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:binary_id&lt;/code&gt; , which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any field.</target>
        </trans-unit>
        <trans-unit id="0e1489eea1b6f3bbd4b7bfb5da234da05e74fa76" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;Repo.all/1&lt;/code&gt; which returns all entries, repositories also provide &lt;code&gt;Repo.one/1&lt;/code&gt; which returns one entry or nil, &lt;code&gt;Repo.one!/1&lt;/code&gt; which returns one entry or raises, &lt;code&gt;Repo.get/2&lt;/code&gt; which fetches entries for a particular ID and more.</source>
          <target state="translated">게다가 &lt;code&gt;Repo.all/1&lt;/code&gt; 모든 항목을 반환 저장소도 제공 &lt;code&gt;Repo.one/1&lt;/code&gt; 하나 개의 항목 또는 전무를 반환 &lt;code&gt;Repo.one!/1&lt;/code&gt; 하나 개의 항목이나 레이즈를 반환 &lt;code&gt;Repo.get/2&lt;/code&gt; 특정에 대한 항목을 가져옵니다 아이디 등</target>
        </trans-unit>
        <trans-unit id="6437183553c7f4ee91c137266b2ec8a881ba0341" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;put_flash/3&lt;/code&gt; and &lt;code&gt;get_flash/2&lt;/code&gt;, the &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module has another useful function worth knowing about. &lt;code&gt;clear_flash/1&lt;/code&gt; takes only &lt;code&gt;conn&lt;/code&gt; and removes any flash messages which might be stored in the session.</source>
          <target state="translated">게다가 &lt;code&gt;put_flash/3&lt;/code&gt; 및 &lt;code&gt;get_flash/2&lt;/code&gt; 의 &lt;a href=&quot;phoenix.controller&quot;&gt; &lt;code&gt;Phoenix.Controller&lt;/code&gt; 의&lt;/a&gt; 모듈은 또 다른 유용한 기능의 가치에 대해 알고있다. &lt;code&gt;clear_flash/1&lt;/code&gt; 은 &lt;code&gt;conn&lt;/code&gt; 만 취하고 세션에 저장 될 수있는 모든 플래시 메시지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4db60d335ebdbdc7119cfd198fa9382586d6f219" translate="yes" xml:space="preserve">
          <source>Besides being a Plug, this module also provides conveniences for configuring SSL. See &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그 외에도이 모듈은 SSL 구성을위한 편의성을 제공합니다. &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89f5e6bc915be700f158a6ce56ae0826017ba369" translate="yes" xml:space="preserve">
          <source>Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning &lt;code&gt;{:ok, changes}&lt;/code&gt;. In case of any errors the transaction will be rolled back and &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; will be returned.</source>
          <target state="translated">함수 외에도 Ecto.Multi 구조체와 함께 트랜잭션을 사용할 수 있습니다. 트랜잭션이 시작되고 모든 작업이 적용되며 성공한 경우 &lt;code&gt;{:ok, changes}&lt;/code&gt; 반환이 커밋 됩니다. 오류가 발생하면 트랜잭션이 롤백되고 &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="318f727872b2ac407eed6b2cc5b760e863528d41" translate="yes" xml:space="preserve">
          <source>Besides functions, transactions can be used with an &lt;a href=&quot;ecto.multi&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct. A transaction will be started, all operations applied and in case of success committed returning &lt;code&gt;{:ok, changes}&lt;/code&gt;. In case of any errors the transaction will be rolled back and &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; will be returned.</source>
          <target state="translated">Besides functions, transactions can be used with an &lt;a href=&quot;ecto.multi&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; struct. A transaction will be started, all operations applied and in case of success committed returning &lt;code&gt;{:ok, changes}&lt;/code&gt; . In case of any errors the transaction will be rolled back and &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; will be returned.</target>
        </trans-unit>
        <trans-unit id="6eb623724b9e9c7ad93a2b376a13191ce506c435" translate="yes" xml:space="preserve">
          <source>Besides providing primitive types, Ecto allows custom types to be implemented by developers, allowing Ecto behaviour to be extended.</source>
          <target state="translated">기본 유형을 제공하는 것 외에도 Ecto를 사용하면 개발자가 사용자 정의 유형을 구현하여 Ecto 동작을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76cc7d58981a3e9ddfb52f7f3e74c5fabe82b2f6" translate="yes" xml:space="preserve">
          <source>Besides template engines, Phoenix has the concept of format encoders. Format encoders work per format and are responsible for encoding a given format to string once the view layer finishes processing.</source>
          <target state="translated">Besides template engines, Phoenix has the concept of format encoders. Format encoders work per format and are responsible for encoding a given format to string once the view layer finishes processing.</target>
        </trans-unit>
        <trans-unit id="95f14d33b401893a277d4f99cbdd9eff770e0035" translate="yes" xml:space="preserve">
          <source>Besides the &amp;ldquo;Shared options&amp;rdquo; section at the module documentation, it accepts:</source>
          <target state="translated">모듈 문서의 &quot;공유 옵션&quot;섹션 외에도 다음을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6dddd5d4e0ebfe01e4b2b072c831bf0ff01a10bb" translate="yes" xml:space="preserve">
          <source>Besides the directories mentioned, &lt;code&gt;lib/hello_web&lt;/code&gt; has four files at its root. &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt; is the entry-point for HTTP requests. Once the browser accesses &lt;code&gt;http://localhost:4000&lt;/code&gt;, the endpoint starts processing the data, eventually leading to the router, which is defined in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;. The router defines the rules to dispatch requests to &quot;controllers&quot;, which then uses &quot;views&quot; and &quot;templates&quot; to render HTML pages back to clients. We explore these layers in length in other guides, starting with the &quot;Request life-cycle&quot; guide coming next.</source>
          <target state="translated">언급 된 디렉토리 외에도 &lt;code&gt;lib/hello_web&lt;/code&gt; 에는 루트에 4 개의 파일이 있습니다. &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt; 는 HTTP 요청의 진입 점입니다. 브라우저가 &lt;code&gt;http://localhost:4000&lt;/code&gt; 에 액세스 하면 엔드 포인트가 데이터 처리를 시작하고 결국 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 에 정의 된 라우터로 연결됩니다 . 라우터는 &quot;컨트롤러&quot;에 요청을 전달하는 규칙을 정의한 다음 &quot;보기&quot;및 &quot;템플릿&quot;을 사용하여 HTML 페이지를 클라이언트에 다시 렌더링합니다. 다음에 오는 &quot;요청 수명주기&quot;가이드부터 시작하여 다른 가이드에서 이러한 레이어를 자세히 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="e5b702522385247fe472a44b3b7dab0d4a04a627" translate="yes" xml:space="preserve">
          <source>Besides the four components above, most developers use Ecto to interact with SQL databases, such as Postgres and MySQL via the &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt;&lt;code&gt;ecto_sql&lt;/code&gt;&lt;/a&gt; project. &lt;code&gt;ecto_sql&lt;/code&gt; provides many conveniences for working with SQL databases as well as the ability to version how your database changes through time via &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.html#module-migrations&quot;&gt;database migrations&lt;/a&gt;.</source>
          <target state="translated">Besides the four components above, most developers use Ecto to interact with SQL databases, such as Postgres and MySQL via the &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt; &lt;code&gt;ecto_sql&lt;/code&gt; &lt;/a&gt; project. &lt;code&gt;ecto_sql&lt;/code&gt; provides many conveniences for working with SQL databases as well as the ability to version how your database changes through time via &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.html#module-migrations&quot;&gt;database migrations&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3db8569d9e6815ffe5de50966c22aaf56621ce54" translate="yes" xml:space="preserve">
          <source>Besides the options from &lt;code&gt;:ssl&lt;/code&gt;, this function adds on extra option:</source>
          <target state="translated">Besides the options from &lt;code&gt;:ssl&lt;/code&gt; , this function adds on extra option:</target>
        </trans-unit>
        <trans-unit id="30337ca422dc9c9379566c110b3f0dab3fec92a6" translate="yes" xml:space="preserve">
          <source>Besides the options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt;, the multipart parser also checks for &lt;code&gt;:headers&lt;/code&gt; option that contains the same &lt;code&gt;:length&lt;/code&gt;, &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options which are used explicitly for parsing multipart headers.</source>
          <target state="translated">멀티 파트 파서는 &lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; 가&lt;/a&gt; 지원하는 옵션 외에도 멀티 파트 헤더를 구문 분석하는 데 명시 적으로 사용되는 동일한 &lt;code&gt;:length&lt;/code&gt; , &lt;code&gt;:read_length&lt;/code&gt; 및 &lt;code&gt;:read_timeout&lt;/code&gt; 옵션을 포함하는 &lt;code&gt;:headers&lt;/code&gt; 옵션을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="15b3f19a233cd9d8ebad91d3ec8ed466fb101712" translate="yes" xml:space="preserve">
          <source>Besides the options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt;, the multipart parser also checks for:</source>
          <target state="translated">Besides the options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; &lt;/a&gt;, the multipart parser also checks for:</target>
        </trans-unit>
        <trans-unit id="97011ba97fa273b21e33aa944bda2e2a278636f0" translate="yes" xml:space="preserve">
          <source>Besides working as data mappers, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; can also be used together to decouple how the data is represented in your applications from the database. Let&amp;rsquo;s see some examples.</source>
          <target state="translated">데이터 맵퍼로 작업하는 것 외에도 &lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#schema/2&quot;&gt; &lt;code&gt;schema/2&lt;/code&gt; &lt;/a&gt; 를 함께 사용하여 데이터베이스에서 응용 프로그램에서 데이터가 표현되는 방식을 분리 할 수 ​​있습니다. 몇 가지 예를 봅시다.</target>
        </trans-unit>
        <trans-unit id="89bd0a3cbaf58f8c800ca549b4e25ac38a02f8ca" translate="yes" xml:space="preserve">
          <source>Besides working as data mappers, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; can also be used together to decouple how the data is represented in your applications from the database. Let's see some examples.</source>
          <target state="translated">Besides working as data mappers, &lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#schema/2&quot;&gt; &lt;code&gt;schema/2&lt;/code&gt; &lt;/a&gt; can also be used together to decouple how the data is represented in your applications from the database. Let's see some examples.</target>
        </trans-unit>
        <trans-unit id="3962ea5600f34c37c915cbc046d82c04df4d77b4" translate="yes" xml:space="preserve">
          <source>Binaries: &lt;code&gt;&amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이진 : &lt;code&gt;&amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1aad9799a97fc162affbf249838fba4245ed1b2" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;!=&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;!=&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="aab4967633fa340878f5b6ff0fac9275456b4095" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;!=&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;!=&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="e5506cd20d34fa992131eae37a4118f8df942d59" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;&amp;gt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="dfa1236ca139dea1e736031c6c010136c1156745" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;&amp;gt;&lt;/code&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="68b8b7e6a0cafe89fe9d42b45a144301795984d6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;=&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="9fff762f48965b1b90e231f1c2e9b7b77d9c0279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;=&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="897a4bf146dd662af8918814f6299d5d45bc9385" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;&amp;lt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="516964b86b828e773af99b35b730166419b08ee0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;&amp;lt;&lt;/code&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="55d4095acf2b6cfdaf2462ee0715df5c7aac35c1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;=&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="0be463179ad26307edb01739fad99fe4901b5a8f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;=&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="ed4b8e4fd8d9b29d992761dfa2dd4c4489e1ed65" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;*&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;*&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="37acde5499dd91e7f0cda6308db090f03a77b072" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;*&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;*&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="d333c5e55aa960b56f8ce9b2461bef92b1d3519a" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;+&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;+&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="becb3295fec718a8db321dbab17c20c240047390" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;+&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;+&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="04e6fcacb4fa7beb340b0fd4aebae3a486fae794" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;-&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;-&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="98d8ffdbb4452da8517c3805068ed9208643de11" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;-&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;-&lt;/code&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="e6178994dd1feef09124c4590ccdad76e17713e2" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;/&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;/&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="09212b0697d203478dadb5e24a3aa03f5d34b600" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;/&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;/&lt;/code&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="ccbea1b86603234afe1e75963168f22d91c68d0f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;==&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;==&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="59b65609ffb053adfebf42fcdef021d829543b4b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;==&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;==&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="4248aa7253f6eb7de8c22a0d449b4507ceab3e76" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;and&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;and&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="679d74c0e77d203b30ac50ea095340b58793e663" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;and&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;and&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="56942b29b92b3a8bc97ce0aee7ae63719e0afac4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;or&lt;/code&gt; operation</source>
          <target state="translated">이진 &lt;code&gt;or&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="1efbf5460110f2b42e9a177b65ee9dbf7064f3f6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;or&lt;/code&gt; operation.</source>
          <target state="translated">이진 &lt;code&gt;or&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="34c54b1df07d242138e07a00276cdb9c596ce135" translate="yes" xml:space="preserve">
          <source>Bindingless operations</source>
          <target state="translated">바인딩없는 작업</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="b7d81cd1aa76a8c75003ee4db6d6aa59eab833b5" translate="yes" xml:space="preserve">
          <source>Bindings are not exposed from the query. When composing queries you must specify bindings again for each refinement query. For example to further narrow-down above query we again need to tell Ecto what bindings to expect:</source>
          <target state="translated">바인딩은 쿼리에서 노출되지 않습니다. 쿼리를 작성할 때 각 구체화 쿼리에 대해 바인딩을 다시 지정해야합니다. 예를 들어 쿼리를 더 좁히려면 Ecto에게 어떤 바인딩을 기대해야하는지 다시 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="6bbf6933797073c25a6cfb9a9635145f3caa2e87" translate="yes" xml:space="preserve">
          <source>Bindings are not exposed from the query. When composing queries, you must specify bindings again for each refinement query. For example, to further narrow down the above query, we again need to tell Ecto what bindings to expect:</source>
          <target state="translated">Bindings are not exposed from the query. When composing queries, you must specify bindings again for each refinement query. For example, to further narrow down the above query, we again need to tell Ecto what bindings to expect:</target>
        </trans-unit>
        <trans-unit id="6a768c2cec7b7bc8e20929e8467fb8b1cdbcd4ee" translate="yes" xml:space="preserve">
          <source>Bindings in Ecto are positional, and the names do not have to be consistent between input and refinement queries. For example, the query above could also be written as:</source>
          <target state="translated">Ecto의 바인딩은 위치에 따라 다르며, 입력 쿼리와 구체화 쿼리간에 이름이 일치하지 않아도됩니다. 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="e7785ac12e9b48c7d8da92df06d805c335db37ed" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;</source>
          <target state="translated">부울 연산자 : &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7133f12719661511054ab5e011b7efd42eff73c9" translate="yes" xml:space="preserve">
          <source>Boolean values</source>
          <target state="translated">부울 값</target>
        </trans-unit>
        <trans-unit id="2984126e4505fef2ec09b8e1991aadd393d7b750" translate="yes" xml:space="preserve">
          <source>Booleans: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">부울 : &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b765af8d436cfcf6ee0928b70c18c8a282ae2484" translate="yes" xml:space="preserve">
          <source>Booting sockets</source>
          <target state="translated">Booting sockets</target>
        </trans-unit>
        <trans-unit id="072691eed4da8ad84159768206095389395590ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; must be given a subquery as an argument, and theyu must be used on the right hand side of a comparison. Both can be used with every comparison operator: &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">Both &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; must be given a subquery as an argument, and theyu must be used on the right hand side of a comparison. Both can be used with every comparison operator: &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138dbeb06701882a099e2f68d3e08d5ed686d058" translate="yes" xml:space="preserve">
          <source>Both JSON and HTML formats will be encoded only when passing the data to the controller via the &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; function uses the notion of format encoders to convert a particular format to its string/iodata representation.</source>
          <target state="translated">JSON 및 HTML 형식은 &lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; &lt;/a&gt; 함수 를 통해 데이터를 컨트롤러에 전달할 때만 인코딩됩니다 . &lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; &lt;/a&gt; 함수는 문자열 / iodata 표현으로 특정 형식을 변환 할 포맷 인코더의 개념을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf5e5abefed5cab48db50ba6d9ed06bb2b3bd7c7" translate="yes" xml:space="preserve">
          <source>Both approaches shown above rely on static configuration. Let's see alternatives.</source>
          <target state="translated">위에 표시된 두 접근 방식은 모두 정적 구성에 의존합니다. 대안을 봅시다.</target>
        </trans-unit>
        <trans-unit id="7f7a07162f18c4dab6556ad58150d663a794593d" translate="yes" xml:space="preserve">
          <source>Both queries are equivalent. However, if you are using the same partitioning over and over again, defining a window will reduce the query size. See &lt;a href=&quot;ecto.query#windows/3&quot;&gt;&lt;code&gt;Ecto.Query.windows/3&lt;/code&gt;&lt;/a&gt; for all possible window expressions, such as &lt;code&gt;:partition_by&lt;/code&gt; and &lt;code&gt;:order_by&lt;/code&gt;.</source>
          <target state="translated">두 쿼리 모두 동일합니다. 그러나 동일한 파티션을 반복해서 사용하는 경우 창을 정의하면 쿼리 크기가 줄어 듭니다. &lt;code&gt;:partition_by&lt;/code&gt; 및 &lt;code&gt;:order_by&lt;/code&gt; 와 같은 가능한 모든 창 표현식 은 &lt;a href=&quot;ecto.query#windows/3&quot;&gt; &lt;code&gt;Ecto.Query.windows/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f53a37385676a460a743f3f86e272723cbe6eceb" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions defined by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; can be manually overridden. For example, the &lt;code&gt;init/1&lt;/code&gt; function provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; returns the options that it receives as an argument, but its behaviour can be customized:</source>
          <target state="translated">Both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions defined by &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; can be manually overridden. For example, the &lt;code&gt;init/1&lt;/code&gt; function provided by &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; returns the options that it receives as an argument, but its behaviour can be customized:</target>
        </trans-unit>
        <trans-unit id="9841089641d10cbb68ba9932954832d08f20b29e" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions defined by &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; can be manually overridden. For example, the &lt;code&gt;init/1&lt;/code&gt; function provided by &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; returns the options that it receives as an argument, but its behaviour can be customized:</source>
          <target state="translated">모두 &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 에 의해 정의 함수 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 는&lt;/a&gt; 수동으로 재정의 할 수 있습니다. 예를 들어 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 에서&lt;/a&gt; 제공 하는 &lt;code&gt;init/1&lt;/code&gt; 함수 는 인수로받는 옵션을 반환하지만 해당 동작을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef5922fa8013b702194c2f1e7cc36353301a4e8b" translate="yes" xml:space="preserve">
          <source>Both the router and controller module names will be prefixed with the name you gave your application instead of &lt;code&gt;HelloWeb&lt;/code&gt;.</source>
          <target state="translated">라우터 및 컨트롤러 모듈 이름 모두 &lt;code&gt;HelloWeb&lt;/code&gt; 대신 애플리케이션에 지정한 이름이 접두사로 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="0b13a8d60d1d3de64ef4fd72fc97d6965aae27f8" translate="yes" xml:space="preserve">
          <source>Broadcast an event to all subscribers of the socket topic</source>
          <target state="translated">소켓 주제의 모든 구독자에게 이벤트 브로드 캐스트</target>
        </trans-unit>
        <trans-unit id="bad0a78dd2fd78e872af83332fe02ca2f663da8e" translate="yes" xml:space="preserve">
          <source>Broadcast an event to all subscribers of the socket topic.</source>
          <target state="translated">소켓 주제의 모든 구독자에게 이벤트를 브로드 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="846b5dd1c1f901604c81013a76597f6f855e2d20" translate="yes" xml:space="preserve">
          <source>Broadcast event from pid to all subscribers of the socket topic</source>
          <target state="translated">소켓 주제의 모든 구독자에게 pid에서 브로드 캐스트 이벤트</target>
        </trans-unit>
        <trans-unit id="851a8a80337ee20b89c3d123943d6ad3318e4e3c" translate="yes" xml:space="preserve">
          <source>Broadcast event from pid to all subscribers of the socket topic.</source>
          <target state="translated">pid에서 소켓 주제의 모든 구독자에게 이벤트를 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="7459c0c85fb18346d48a15ecd0ee62798126c617" translate="yes" xml:space="preserve">
          <source>Broadcasting to an external topic</source>
          <target state="translated">외부 주제로 방송</target>
        </trans-unit>
        <trans-unit id="430c9f20aa06eb11805b71cdf9305b868b70a06a" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;topic&lt;/code&gt; 에서 &lt;code&gt;msg&lt;/code&gt; 를 &lt;code&gt;event&lt;/code&gt; 로 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="41d4a918d7ada7063a5d54f173d1fb2b78ec2966" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</source>
          <target state="translated">Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</target>
        </trans-unit>
        <trans-unit id="3ad30a6e73447865104d74a754edbdbb847221a5" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</source>
          <target state="translated">Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</target>
        </trans-unit>
        <trans-unit id="9be84a5fac4b66af00295240a8a9fd8406098ea3" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;topic&lt;/code&gt; 에서 &lt;code&gt;msg&lt;/code&gt; 를 &lt;code&gt;event&lt;/code&gt; 로 브로드 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="2a381d4f84303afe830a779813c8ff51ca44d964" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;</source>
          <target state="translated">브로드 캐스트 &lt;code&gt;msg&lt;/code&gt; 주어진에서를 &lt;code&gt;from&lt;/code&gt; 로 &lt;code&gt;event&lt;/code&gt; 주어진에서 &lt;code&gt;topic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f5bcc1aac9a59de4ee2320d6d3de3b015ff24b6" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</source>
          <target state="translated">Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</target>
        </trans-unit>
        <trans-unit id="9dcc5aa9001938c0fa121a5a07fb5cb71c8216ac" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</source>
          <target state="translated">Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</target>
        </trans-unit>
        <trans-unit id="da547b962c3b435f39e695241e267c345324e49f" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">브로드 캐스트 &lt;code&gt;msg&lt;/code&gt; 주어진에서 &lt;code&gt;from&lt;/code&gt; 같은 &lt;code&gt;event&lt;/code&gt; 주어진에서 &lt;code&gt;topic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2128b2a68ac127e87f9c6c480329ff8af263ea9f" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic</source>
          <target state="translated">주어진 주제에 대한 메시지를 방송</target>
        </trans-unit>
        <trans-unit id="3e575d0da9aea600efd895513bb1b0d422de8ace" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic across the whole cluster.</source>
          <target state="translated">Broadcasts message on given topic across the whole cluster.</target>
        </trans-unit>
        <trans-unit id="8a8ed8128ad3266a3e3ed17060b3688cd98d5484" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic from a given process only for the current node.</source>
          <target state="translated">Broadcasts message on given topic from a given process only for the current node.</target>
        </trans-unit>
        <trans-unit id="bc32e492fe1951ff9c5a65a298a35717bdab0d23" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic from the given process across the whole cluster.</source>
          <target state="translated">Broadcasts message on given topic from the given process across the whole cluster.</target>
        </trans-unit>
        <trans-unit id="a6cf1d8af5af2a25fd80f311ae513c176bc7fe41" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic only for the current node.</source>
          <target state="translated">Broadcasts message on given topic only for the current node.</target>
        </trans-unit>
        <trans-unit id="7502e5d44055067546fa115fcbb0ed4dfdcfae02" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic to a given node.</source>
          <target state="translated">Broadcasts message on given topic to a given node.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
