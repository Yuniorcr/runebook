<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="c268739f07b40440ff73d328a7a5b1783a45e413" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &amp;ldquo;lower(?)&amp;rdquo; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">데이터베이스에서 &quot;낮은 (?)&quot;기능을 실행하는 동안 예를 들어, 모든 게시물을 얻을 수 &lt;code&gt;p.title&lt;/code&gt; 는 대신에 보간을 &lt;code&gt;?&lt;/code&gt; , 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="712a75ed27773b36d6dab2e762ed7d44810db42c" translate="yes" xml:space="preserve">
          <source>For example, to handle &quot;phx_leave&quot; messages, which is recommended to be handled by all channel implementations, one may do:</source>
          <target state="translated">예를 들어 모든 채널 구현에서 처리하도록 권장되는 &quot;phx_leave&quot;메시지를 처리하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ed93477deaeccf8f807f263aeb1aa8094e246a0" translate="yes" xml:space="preserve">
          <source>For example, to implement infinite scrolling, one might do:</source>
          <target state="translated">예를 들어 무한 스크롤을 구현하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa80c213499c1e4e2ebabd1a68490863d99b23c" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phoenix.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">예를 들어, 종속성을 확인하지 않고 &lt;code&gt;phoenix.server&lt;/code&gt; 를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="52d1730d810a3213b8ae35feb4a46172562acd1e" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">예를 들어, 종속성을 확인하지 않고 &lt;code&gt;phx.server&lt;/code&gt; 를 실행하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb24d75387baa2ce86c09393fcd13aa1468c60e5" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without recompiling:</source>
          <target state="translated">예를 들어, 다시 컴파일하지 않고 &lt;code&gt;phx.server&lt;/code&gt; 를 실행 하려면 :</target>
        </trans-unit>
        <trans-unit id="ee191307a2caef15a68ebec9dbfb940793de8194" translate="yes" xml:space="preserve">
          <source>For example, we can use the &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt; function in the test to push messages to the channel (it will invoke &lt;code&gt;handle_in/3&lt;/code&gt;):</source>
          <target state="translated">예를 들어 테스트에서 &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 메시지를 채널로 푸시 할 수 있습니다 ( &lt;code&gt;handle_in/3&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="f8d98d4e6c4113b73111361aa0eeba5ba04454b2" translate="yes" xml:space="preserve">
          <source>For example, you can define a new &lt;code&gt;live.html.leex&lt;/code&gt; layout with dynamic content. You must use &lt;code&gt;@inner_content&lt;/code&gt; where the output of the actual template will be placed at:</source>
          <target state="translated">예를 들어 동적 콘텐츠 로 새 &lt;code&gt;live.html.leex&lt;/code&gt; 레이아웃을 정의 할 수 있습니다 . 실제 템플릿의 출력이 위치 할 &lt;code&gt;@inner_content&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a9c7054e90670cbc4ed17910aed6f38d7ea04bcd" translate="yes" xml:space="preserve">
          <source>For example, you may define it as:</source>
          <target state="translated">예를 들어 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f038621e4427f7e69c128ca2c67366fe95857d" translate="yes" xml:space="preserve">
          <source>For example, you may way to generate an https URL from an http request. You could define a function like the following:</source>
          <target state="translated">예를 들어 http 요청에서 https URL을 생성 할 수 있습니다. 다음과 같은 기능을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0d6a26a7fdf008c2173a9711decbd13ce937b5b" translate="yes" xml:space="preserve">
          <source>For example, your &lt;code&gt;MyAppWeb.ErrorHelpers&lt;/code&gt; may use this function:</source>
          <target state="translated">예를 들어 &lt;code&gt;MyAppWeb.ErrorHelpers&lt;/code&gt; 는 다음 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="011fbae011e4f284a1bc4a3f9f03b9f3860ee774" translate="yes" xml:space="preserve">
          <source>For further details refer to &lt;a href=&quot;plug.rewriteon&quot;&gt;&lt;code&gt;Plug.RewriteOn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;plug.rewriteon&quot;&gt; &lt;code&gt;Plug.RewriteOn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed904b738db7c4a3075c6e430608f75222bb23b" translate="yes" xml:space="preserve">
          <source>For graceful exits, the channel will notify the transort it is gracefully terminating via the following message:</source>
          <target state="translated">정상 종료의 경우 채널은 트랜스 포트에 다음 메시지를 통해 정상적으로 종료되고 있음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="92926b5f41b64990dae4306af8842a9e143deef7" translate="yes" xml:space="preserve">
          <source>For instance, here is how you would pass the SSL options to the Cowboy adapter:</source>
          <target state="translated">예를 들어 SSL 옵션을 Cowboy 어댑터에 전달하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29be4bc5c201dd9ca580d6ef9202fab40016be15" translate="yes" xml:space="preserve">
          <source>For instance, imagine you wrote:</source>
          <target state="translated">예를 들어, 다음과 같이 썼다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="c93a52e328a78cb6709c141ab080c4cb225cf8de" translate="yes" xml:space="preserve">
          <source>For instance, to receive all query events published by a repository called &lt;code&gt;MyApp.Repo&lt;/code&gt;, one would define a module:</source>
          <target state="translated">예를 들어 &lt;code&gt;MyApp.Repo&lt;/code&gt; 라는 저장소에서 게시 한 모든 쿼리 이벤트를 수신하려면 모듈을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0b013b3f06f541fc367f235e64b28c47860501ef" translate="yes" xml:space="preserve">
          <source>For integration with client-side libraries which require a broader access to full DOM management, the &lt;code&gt;LiveSocket&lt;/code&gt; constructor accepts a &lt;code&gt;dom&lt;/code&gt; option with an &lt;code&gt;onBeforeElUpdated&lt;/code&gt; callback. The &lt;code&gt;fromEl&lt;/code&gt; and &lt;code&gt;toEl&lt;/code&gt; DOM nodes are passed to the function just before the DOM patch operations occurs in LiveView. This allows external libraries to (re)initialize DOM elements or copy attributes as necessary as LiveView performs its own patch operations. The update operation cannot be cancelled or deferred, and the return value is ignored. For example, the following option could be used to add &lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Alpine.js&lt;/a&gt; support to your project:</source>
          <target state="translated">전체 DOM 관리에 대한 광범위한 액세스가 필요한 클라이언트 측 라이브러리와의 통합을 위해 &lt;code&gt;LiveSocket&lt;/code&gt; 생성자는 &lt;code&gt;onBeforeElUpdated&lt;/code&gt; 콜백 과 함께 &lt;code&gt;dom&lt;/code&gt; 옵션을 허용합니다 . &lt;code&gt;fromEl&lt;/code&gt; 및 &lt;code&gt;toEl&lt;/code&gt; DOM 노드는 DOM 패치 작업이 라이브 뷰에서 발생 직전 함수에 전달됩니다. 이를 통해 LiveView가 자체 패치 작업을 수행 할 때 외부 라이브러리가 DOM 요소를 (재) 초기화하거나 필요에 따라 속성을 복사 할 수 있습니다. 업데이트 작업은 취소하거나 연기 할 수 없으며 반환 값은 무시됩니다. 예를 들어 다음 옵션을 사용 하여 프로젝트에 &lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Alpine.js&lt;/a&gt; 지원을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6efb74f6dd168bb1337862be11f36c1c678d8fed" translate="yes" xml:space="preserve">
          <source>For internationalization with &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;gettext&lt;/a&gt;, the locale used within your Plug pipeline can be stored in the Plug session and restored within your LiveView mount. For example, after user signs in or preference changes, you can write the locale to the session:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;gettext&lt;/a&gt; 를 사용한 국제화 의 경우 Plug 파이프 라인 내에서 사용되는 로케일을 Plug 세션에 저장하고 LiveView 마운트 내에서 복원 할 수 있습니다. 예를 들어 사용자가 로그인하거나 기본 설정을 변경 한 후 세션에 로케일을 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b6a50a25c3fab8c56cff540874a439588e5f9c" translate="yes" xml:space="preserve">
          <source>For larger templates, you can place them in a file in the same directory and same name as the LiveView. For example, if the file above is placed at &lt;code&gt;lib/my_app_web/live/thermostat_live.ex&lt;/code&gt;, you can also remove the &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; definition above and instead put the template code at &lt;code&gt;lib/my_app_web/live/thermostat_live.html.leex&lt;/code&gt;.</source>
          <target state="translated">더 큰 템플릿의 경우 LiveView와 동일한 디렉토리 및 동일한 이름의 파일에 배치 할 수 있습니다. 예를 들어 위의 파일이 &lt;code&gt;lib/my_app_web/live/thermostat_live.ex&lt;/code&gt; 에있는 경우 위 의 &lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt; 정의를 제거 하고 대신 &lt;code&gt;lib/my_app_web/live/thermostat_live.html.leex&lt;/code&gt; 에 템플릿 코드를 넣을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8cfc16e6569e0061a6e7eac0c582cf092d25b4b" translate="yes" xml:space="preserve">
          <source>For live page navigation via &lt;code&gt;live_redirect&lt;/code&gt; and &lt;code&gt;live_patch&lt;/code&gt;, as well as form submits via &lt;code&gt;phx-submit&lt;/code&gt;, the JavaScript events &lt;code&gt;&quot;phx:page-loading-start&quot;&lt;/code&gt; and &lt;code&gt;&quot;phx:page-loading-stop&quot;&lt;/code&gt; are dispatched on window. Additionally, any &lt;code&gt;phx-&lt;/code&gt; event may dispatch page loading events by annotating the DOM element with &lt;code&gt;phx-page-loading&lt;/code&gt;. This is useful for showing main page loading status, for example:</source>
          <target state="translated">&lt;code&gt;live_redirect&lt;/code&gt; 및 &lt;code&gt;live_patch&lt;/code&gt; 를 통한 라이브 페이지 탐색 과 phx &lt;code&gt;phx-submit&lt;/code&gt; 통한 양식 제출의 경우 JavaScript 이벤트 &lt;code&gt;&quot;phx:page-loading-start&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;phx:page-loading-stop&quot;&lt;/code&gt; 이 창에 전달됩니다. 또한 모든 &lt;code&gt;phx-&lt;/code&gt; 이벤트는 &lt;code&gt;phx-page-loading&lt;/code&gt; 으로 DOM 요소에 주석을 추가 하여 페이지로드 이벤트를 전달할 수 있습니다. 이는 기본 페이지로드 상태를 표시하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa8555f356953d9e411a255f6f895244740945a0" translate="yes" xml:space="preserve">
          <source>For logging out, we simply defined a form that sends the &lt;code&gt;DELETE&lt;/code&gt; HTTP method to server's session delete path. Now if you visit the sign-in page at &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http://localhost:4000/sessions/new&lt;/a&gt; and enter a bad email address, you should be greeted with your flash message. Entering a valid email address will redirect to the home page with a success flash notice.</source>
          <target state="translated">로그 아웃을 위해 &lt;code&gt;DELETE&lt;/code&gt; HTTP 메소드를 서버의 세션 삭제 경로로 보내는 양식을 간단히 정의했습니다 . 이제 &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http : // localhost : 4000 / sessions / new&lt;/a&gt; 의 로그인 페이지를 방문하여 잘못된 이메일 주소를 입력하면 플래시 메시지가 표시됩니다. 유효한 이메일 주소를 입력하면 성공 플래시 알림과 함께 홈페이지로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="d9022c5a0c8964d6ea0f8ae4b3dab94f265d3706" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">이러한 데이터베이스에서 맵이 작동하려면 Ecto에 JSON 라이브러리가 필요합니다. 기본적으로 Ecto는 &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; 을 사용 하며 &lt;code&gt;mix.exs&lt;/code&gt; 의 뎁에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad179f69fed4d39adf90ca8b668b0dcf60ff8610" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html.&lt;/a&gt;</source>
          <target state="translated">ETS 테이블에 대한 자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html&lt;/a&gt; 의 Erlang 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8aba17a165f8cb7c095fcd429f135914d9b29c38" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at http://www.erlang.org/doc/man/ets.html.</source>
          <target state="translated">ETS 테이블에 대한 자세한 내용은 Erlang 설명서 (http://www.erlang.org/doc/man/ets.html)를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="1a5b5eefc79a13a3a9a181a1c7ba5819905b9c98" translate="yes" xml:space="preserve">
          <source>For more information on casting, see &lt;a href=&quot;ecto.type#c:cast/1&quot;&gt;&lt;code&gt;Ecto.Type.cast/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">캐스팅에 대한 자세한 내용은 &lt;a href=&quot;ecto.type#c:cast/1&quot;&gt; &lt;code&gt;Ecto.Type.cast/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="959df3fd0cfdc74970dc2d4527558d71775f58df" translate="yes" xml:space="preserve">
          <source>For more information on dumping, see &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when dumping a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">덤프에 대한 자세한 정보는 &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt; &lt;code&gt;Ecto.Type.dump/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 이 콜백 &lt;em&gt;은 &lt;/em&gt;&lt;a href=&quot;ecto.type#c:dump/1&quot;&gt; &lt;code&gt;Ecto.Type.dump/1&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;nil&lt;/code&gt; 값을 덤프 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="39c5c587c188573e903e09204ede4dad88b83c93" translate="yes" xml:space="preserve">
          <source>For more information on embedding, see &lt;a href=&quot;ecto.type#c:embed_as/1&quot;&gt;&lt;code&gt;Ecto.Type.embed_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">임베딩에 대한 자세한 내용은 &lt;a href=&quot;ecto.type#c:embed_as/1&quot;&gt; &lt;code&gt;Ecto.Type.embed_as/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aaf3cc1f04b722de715fcdda4f43335a0fa29ca2" translate="yes" xml:space="preserve">
          <source>For more information on how to modify your database schema please refer to the ecto's migration dsl &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html&quot;&gt;ecto migration docs&lt;/a&gt;. For example, to alter an existing schema see the documentation on ecto&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2&quot;&gt;&lt;code&gt;alter/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">데이터베이스 스키마를 수정하는 방법에 대한 자세한 내용은 ecto의 마이그레이션 dsl &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html&quot;&gt;ecto 마이그레이션 문서&lt;/a&gt; 를 참조하십시오 . 예를 들어, 기존 스키마를 변경하려면 ecto의 &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2&quot;&gt; &lt;code&gt;alter/2&lt;/code&gt; &lt;/a&gt; 함수 에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5fe3d8e56fdc17686d2e30d6867234c608125eb" translate="yes" xml:space="preserve">
          <source>For more information on loading, see &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when loading a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로드에 대한 자세한 내용은 &lt;a href=&quot;ecto.type#c:load/1&quot;&gt; &lt;code&gt;Ecto.Type.load/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 이 콜백 &lt;em&gt;은 &lt;/em&gt;&lt;a href=&quot;ecto.type#c:load/1&quot;&gt; &lt;code&gt;Ecto.Type.load/1&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;nil&lt;/code&gt; 값을 로드 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7497a10d07df46f2b4b817a1e9655c0d2b08b83d" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &quot;Named bindings&quot; in this module doc.</source>
          <target state="translated">명명 된 바인딩에 대한 자세한 내용은이 모듈 문서의 &quot;명명 된 바인딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86dc89db4b6ce2937afc00f7c25bd37c98b90786" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &amp;ldquo;Named bindings&amp;rdquo; in this module doc.</source>
          <target state="translated">명명 된 바인딩에 대한 자세한 내용은이 모듈 설명서의 &quot;명명 된 바인딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f575930ba40732ed5321d4dfc902877f97a260e8" translate="yes" xml:space="preserve">
          <source>For more information on schema types, see &lt;a href=&quot;ecto.type#c:type/0&quot;&gt;&lt;code&gt;Ecto.Type.type/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">스키마 유형에 대한 자세한 내용은 &lt;a href=&quot;ecto.type#c:type/0&quot;&gt; &lt;code&gt;Ecto.Type.type/0&lt;/code&gt; 을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4afd6eff44c1ca0a8cddb75ff5a6a8d39a20181b" translate="yes" xml:space="preserve">
          <source>For most use cases, this is all you need and form recovery will happen without consideration. In some cases, where forms are built step-by-step in a stateful fashion, it may require extra recovery handling on the server outside of your existing &lt;code&gt;phx-change&lt;/code&gt; callback code. To enable specialized recovery, provide a &lt;code&gt;phx-auto-recover&lt;/code&gt; binding on the form to specify a different event to trigger for recovery, which will receive the form params as usual. For example, imagine a LiveView wizard form where the form is stateful and built based on what step the user is on and by prior selections:</source>
          <target state="translated">대부분의 사용 사례에서 이것이 필요한 전부이며 양식 복구는 고려하지 않고 수행됩니다. 양식이 상태 저장 방식으로 단계별로 빌드되는 경우 기존 &lt;code&gt;phx-change&lt;/code&gt; 콜백 코드 외부의 서버에서 추가 복구 처리가 필요할 수 있습니다. 특수 복구를 사용하려면 양식에 &lt;code&gt;phx-auto-recover&lt;/code&gt; 바인딩을 제공하여 복구를 위해 트리거 할 다른 이벤트를 지정하면 평소와 같이 양식 매개 변수가 수신됩니다. 예를 들어, 사용자가 어떤 단계에 있는지와 이전 선택에 따라 양식이 상태 저장되고 빌드되는 LiveView 마법사 양식을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e7028da18781b4d884d99f3ee7b8c02bf1245d37" translate="yes" xml:space="preserve">
          <source>For new applications, the ErrorView looks like this:</source>
          <target state="translated">새 애플리케이션의 경우 ErrorView는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="282464bf76622e75b3765b0efb4b281d44c1c143" translate="yes" xml:space="preserve">
          <source>For now it doesn't matter that we don't actually have a &lt;code&gt;HelloWeb.UserController&lt;/code&gt;.</source>
          <target state="translated">현재로서는 실제로 &lt;code&gt;HelloWeb.UserController&lt;/code&gt; 가 없다는 것은 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a56f6e0fcb2fe492fc12d986fac6e6954793e6c8" translate="yes" xml:space="preserve">
          <source>For now, it suffices to say that each Plug defines a slice of request processing. In the endpoint you will find a skeleton roughly like this:</source>
          <target state="translated">지금은 각 Plug가 요청 처리 조각을 정의한다고해도 충분합니다. 끝점에서 대략 다음과 같은 골격을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886bdd0ff64c15f2da68e1f96f4b3b6b7cac28a4" translate="yes" xml:space="preserve">
          <source>For now, user credentials will contain only email information. Our first order of business is to decide where credentials live in the application. We have our &lt;code&gt;Accounts&lt;/code&gt; context, which manages user accounts. User credentials is a natural fit here. Phoenix is also smart enough to generate code inside an existing context, which makes adding new resources to a context a breeze. Run the following command at your project root:</source>
          <target state="translated">지금은 사용자 자격 증명에 이메일 정보 만 포함됩니다. 첫 번째 비즈니스 순서는 애플리케이션에서 자격 증명이있는 위치를 결정하는 것입니다. 우리는 우리가 &lt;code&gt;Accounts&lt;/code&gt; 사용자 계정을 관리 컨텍스트를. 사용자 자격 증명은 여기에 자연스럽게 적합합니다. Phoenix는 또한 기존 컨텍스트 내에서 코드를 생성 할 수있을만큼 똑똑하므로 컨텍스트에 새 리소스를 쉽게 추가 할 수 있습니다. 프로젝트 루트에서 다음 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0e16e993fd473ea76243c2fdc4e544518d69c0e0" translate="yes" xml:space="preserve">
          <source>For now, we'll ignore the pipelines and the use of &lt;code&gt;scope&lt;/code&gt; here and just focus on adding a route. We will discuss those in &lt;a href=&quot;routing&quot;&gt;the Routing guide&lt;/a&gt;.</source>
          <target state="translated">지금은 여기서 파이프 라인과 &lt;code&gt;scope&lt;/code&gt; 사용을 무시하고 경로 추가에만 집중하겠습니다. &lt;a href=&quot;routing&quot;&gt;라우팅 가이드&lt;/a&gt; 에서 이에 대해 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="47623288c6f7e25e0286078a9bc973202790385a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션과 예제는 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa05355f3967ad546f604ed6817bb6dc2f2810a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_one/3&quot;&gt;&lt;code&gt;embeds_one/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션과 예제는 &lt;a href=&quot;#embeds_one/3&quot;&gt; &lt;code&gt;embeds_one/3&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f762b81db42047b1f8e5c705f799a2c497f5c89" translate="yes" xml:space="preserve">
          <source>For preloads, the selected fields may be specified from the parent:</source>
          <target state="translated">사전로드의 경우 선택한 필드를 상위에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b2911ab549294cdbf33bc1636f3d5c92514f4c" translate="yes" xml:space="preserve">
          <source>For proper form error tag updates, the error tag must specify which input it belongs to. This is accomplished with the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute. Failing to add the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute will result in displaying error messages for form fields that the user has not changed yet (e.g. required fields further down on the page).</source>
          <target state="translated">적절한 형식의 오류 태그 업데이트를 위해 오류 태그는 ​​그것이 속한 입력을 지정해야합니다. 이것은 &lt;code&gt;phx-feedback-for&lt;/code&gt; 속성으로 수행됩니다. &lt;code&gt;phx-feedback-for&lt;/code&gt; 속성 을 추가하지 않으면 사용자가 아직 변경하지 않은 양식 필드 (예 : 페이지 아래의 필수 필드)에 대한 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a741dc08e6f8380624e48ef2c45211a0061c62e0" translate="yes" xml:space="preserve">
          <source>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</source>
          <target state="translated">관계형 데이터베이스의 경우 이는 해당 명령문의 RETURNING 옵션이 사용됨을 의미합니다. 이러한 이유로 MySQL은이 옵션을 지원하지 않으며 쓰기 후 읽기 필드로 스키마를 삽입 / 업데이트하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00597a349fb6a62ad730ce7a374a1fd3fdf60dfa" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#get_change/3&quot;&gt;&lt;code&gt;get_change/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계의 경우이 함수는 변경 사항이 적용된 변경 세트 데이터를 반환합니다. 원시 변경 세트를 검색하려면 &lt;a href=&quot;#get_change/3&quot;&gt; &lt;code&gt;get_change/3&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a48c0cb962716952cf875975eac6007455ad2f0" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#fetch_change/2&quot;&gt;&lt;code&gt;fetch_change/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계의 경우이 함수는 변경 사항이 적용된 변경 세트 원본 데이터를 반환합니다. 원시 변경 세트를 검색하려면 &lt;a href=&quot;#fetch_change/2&quot;&gt; &lt;code&gt;fetch_change/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e438c72243585ad24059c796c9627a8dd79cb75" translate="yes" xml:space="preserve">
          <source>For requests with a different request method, this plug will only fetch the query params.</source>
          <target state="translated">요청 방법이 다른 요청의 경우이 플러그는 쿼리 매개 변수 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9e5eaa2ebb08d285e2d07000eb79f966c0f46f7d" translate="yes" xml:space="preserve">
          <source>For responsive images, pass a map, list or string through &lt;code&gt;:srcset&lt;/code&gt;.</source>
          <target state="translated">반응 형 이미지의 경우 &lt;code&gt;:srcset&lt;/code&gt; 를 통해지도, 목록 또는 문자열을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="fd8f14bec39884e1bac29f6af6c015070597aa14" translate="yes" xml:space="preserve">
          <source>For security reasons, the form data and parameter values are never re-used in &lt;a href=&quot;#password_input/3&quot;&gt;&lt;code&gt;password_input/3&lt;/code&gt;&lt;/a&gt;. Pass the value explicitly if you would like to set one.</source>
          <target state="translated">보안상의 이유로 양식 데이터 및 매개 변수 값은 &lt;a href=&quot;#password_input/3&quot;&gt; &lt;code&gt;password_input/3&lt;/code&gt; &lt;/a&gt; 에서 재사용되지 않습니다 . 값을 설정하려면 명시 적으로 값을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0c9c55ef99a1b85442974d55919cef61666635f0" translate="yes" xml:space="preserve">
          <source>For security, &lt;code&gt;:to&lt;/code&gt; only accepts paths. Use the &lt;code&gt;:external&lt;/code&gt; option to redirect to any URL.</source>
          <target state="translated">보안을 위해 &lt;code&gt;:to&lt;/code&gt; 는 경로 만 허용합니다. &lt;code&gt;:external&lt;/code&gt; 옵션을 사용하여 URL로 리디렉션하십시오.</target>
        </trans-unit>
        <trans-unit id="c3bb42014432d8496efa23344529a842fdecd850" translate="yes" xml:space="preserve">
          <source>For solutions that operate below the HTTP layer, e.g. using HAProxy, the client IP address can sometimes be passed through the 'PROXY protocol'. Extracting this information must be handled by the Plug adapter. Please refer to the Plug adapter documentation for further information.</source>
          <target state="translated">HTTP 계층 아래에서 작동하는 솔루션 (예 : HAProxy 사용)의 경우 클라이언트 IP 주소가 때때로 'PROXY 프로토콜'을 통해 전달 될 수 있습니다. 이 정보 추출은 플러그 어댑터에서 처리해야합니다. 자세한 정보는 플러그 어댑터 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d04c64cf7b36c911c0f825bd502b4d9dcf238921" translate="yes" xml:space="preserve">
          <source>For staging and production it is necessary to obtain a CA-signed certificate from a trusted Certificate Authority, such as &lt;a href=&quot;https://letsencrypt.org&quot;&gt;Let's Encrypt&lt;/a&gt;. Certificates issued by a CA usually come with an additional file containing one or more certificates that make up the 'CA chain'.</source>
          <target state="translated">스테이징 및 프로덕션을 위해서는 &lt;a href=&quot;https://letsencrypt.org&quot;&gt;Let 's Encrypt&lt;/a&gt; 와 같은 신뢰할 수있는 인증 기관에서 CA 서명 인증서를 얻어야합니다 . CA에서 발급 한 인증서는 일반적으로 'CA 체인'을 구성하는 하나 이상의 인증서가 포함 된 추가 파일과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fff536d187e3538d188ab49aed8a72744fd84f9c" translate="yes" xml:space="preserve">
          <source>For stylesheet files found under the given path, Phoenix will replace asset references with the digested paths, as long as the asset exists in the generated cache manifest.</source>
          <target state="translated">지정된 경로 아래에있는 스타일 시트 파일의 경우 자산이 생성 된 캐시 매니페스트에있는 한 Phoenix는 자산 참조를 다이제스트 된 경로로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8c36fe9b2a7c749e8571085eb2af112fd9083639" translate="yes" xml:space="preserve">
          <source>For such cases, just pass an atom representing the action to dispatch:</source>
          <target state="translated">그러한 경우, 파견 할 조치를 나타내는 원자를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3e369afedac592425ec8d8e891860e0bbe16c64c" translate="yes" xml:space="preserve">
          <source>For such cases, you need to set the &lt;code&gt;@endpoint&lt;/code&gt; attribute to your controller and pass an atom representing the action to dispatch:</source>
          <target state="translated">이러한 경우 &lt;code&gt;@endpoint&lt;/code&gt; 속성을 컨트롤러 에 설정하고 디스패치 할 작업을 나타내는 아톰을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0c25469cbfa8dfe50c32adf8947d072adc5da07" translate="yes" xml:space="preserve">
          <source>For testing purposes it may be sufficient to use a self-signed certificate. Such certificates generally result in warnings in browsers and failed connections from other tools, but these can be overridden to enable HTTPS testing. This is especially useful for local testing of HTTP 2, which is only specified over TLS.</source>
          <target state="translated">테스트 목적으로 자체 서명 된 인증서를 사용하는 것으로 충분할 수 있습니다. 이러한 인증서는 일반적으로 브라우저에 경고를 표시하고 다른 도구의 연결에 실패하지만 HTTPS 테스트를 사용하도록 재정의 할 수 있습니다. 이는 TLS를 통해서만 지정되는 HTTP 2의 로컬 테스트에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="20a1f9c6c25c59a377c89a60f258c5d3b208854e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">의 경우 &lt;code&gt;:decimal&lt;/code&gt; 유형, &lt;code&gt;+Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 과 &lt;code&gt;NaN&lt;/code&gt; 값은 지원되지 않습니다에도 불구하고 &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 라이브러리 핸들 그들. 이를 지원하기 위해 사용자 정의 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d601251c886cf09d8df301039ddd66e5410dddf0" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">의 경우 &lt;code&gt;:decimal&lt;/code&gt; 유형, &lt;code&gt;+Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 과 &lt;code&gt;NaN&lt;/code&gt; 값은 지원되지 않습니다에도 불구하고 &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 라이브러리 핸들 그들. 이를 지원하기 위해 사용자 정의 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780c2570702e69db99f32922ce1d16997b165979" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;{:array, inner_type}&lt;/code&gt; and &lt;code&gt;{:map, inner_type}&lt;/code&gt; type, replace &lt;code&gt;inner_type&lt;/code&gt; with one of the valid types, such as &lt;code&gt;:string&lt;/code&gt;.</source>
          <target state="translated">를 들어 &lt;code&gt;{:array, inner_type}&lt;/code&gt; 과 &lt;code&gt;{:map, inner_type}&lt;/code&gt; 유형, 대체 &lt;code&gt;inner_type&lt;/code&gt; 을 같은 유효한 유형 중 하나 &lt;code&gt;:string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b121a5201e5fe9abd71ff02499c57b1592c223e" translate="yes" xml:space="preserve">
          <source>For the endpoint:</source>
          <target state="translated">엔드 포인트의 경우 :</target>
        </trans-unit>
        <trans-unit id="b1f1151b7b2d1e19979f082133ff2e9a94a228d5" translate="yes" xml:space="preserve">
          <source>For the last piece of this puzzle, we'll need a new template. Since it is for the &lt;code&gt;show&lt;/code&gt; action of the &lt;code&gt;HelloController&lt;/code&gt;, it will go into the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory and be called &lt;code&gt;show.html.eex&lt;/code&gt;. It will look surprisingly like our &lt;code&gt;index.html.eex&lt;/code&gt; template, except that we will need to display the name of our messenger.</source>
          <target state="translated">이 퍼즐의 마지막 조각에는 새 템플릿이 필요합니다. &lt;code&gt;HelloController&lt;/code&gt; 의 &lt;code&gt;show&lt;/code&gt; 작업을 위한 것이므로 &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; 디렉토리 로 이동하여 &lt;code&gt;show.html.eex&lt;/code&gt; 라고 합니다. 메신저의 이름을 표시해야한다는 점을 제외하면 &lt;code&gt;index.html.eex&lt;/code&gt; 템플릿 과 놀랍게도 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="d19fd3691f7d4d31387de8d41929bd14c258e795" translate="yes" xml:space="preserve">
          <source>For the live-reload websocket:</source>
          <target state="translated">라이브 리로드 웹 소켓의 경우 :</target>
        </trans-unit>
        <trans-unit id="81005f9cec33e8f78401fbfd630c9003c91a58e8" translate="yes" xml:space="preserve">
          <source>For these use cases, the &lt;code&gt;phx-change&lt;/code&gt; input does not concern itself with disabling input editing while an event to the server is in flight. When a &lt;code&gt;phx-change&lt;/code&gt; event is sent to the server, the input tag and parent form tag receive the &lt;code&gt;phx-change-loading&lt;/code&gt; css class, then the payload is pushed to the server with a &lt;code&gt;&quot;_target&quot;&lt;/code&gt; param in the root payload containing the keyspace of the input name which triggered the change event.</source>
          <target state="translated">이러한 사용 사례의 경우 &lt;code&gt;phx-change&lt;/code&gt; 입력은 서버에 대한 이벤트가 진행중인 동안 입력 편집을 비활성화하는 것과 관련이 없습니다. 때 &lt;code&gt;phx-change&lt;/code&gt; 이벤트 서버로 전송되면, 입력 된 태그와 부모 폼 태그 수신 &lt;code&gt;phx-change-loading&lt;/code&gt; CSS 클래스, 그 페이로드가 함께 서버로 푸시 &lt;code&gt;&quot;_target&quot;&lt;/code&gt; KEYSPACE 함유 루트 페이로드 PARAM 변경 이벤트를 트리거 한 입력 이름의.</target>
        </trans-unit>
        <trans-unit id="c7fe2c0bee48cd8643f3d8a46b8a6fe43bb8e581" translate="yes" xml:space="preserve">
          <source>For this exercise, we're going to re-use the &lt;code&gt;HelloController&lt;/code&gt; we just created and just add a new &lt;code&gt;show&lt;/code&gt; action. We'll add a line just below our last route, like this:</source>
          <target state="translated">이 연습에서는 방금 만든 &lt;code&gt;HelloController&lt;/code&gt; 를 다시 사용하고 새 &lt;code&gt;show&lt;/code&gt; 작업을 추가 할 것 입니다. 다음과 같이 마지막 경로 바로 아래에 줄을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b6cc26f40ba25b58fe4ceb1492cc4ebe433ed3db" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the plug stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">이 플러그가 작동하려면 세션이 이전에 페치되었을 것으로 예상됩니다. 그런 다음 세션에 저장된 플러그를 요청이 보낸 플러그와 비교하여 요청의 유효성을 확인합니다. 유효하지 않은 요청의 경우 조치는 &lt;code&gt;:with&lt;/code&gt; 옵션을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c19aeef5835b8730002052f32c829b18a9a1b368" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the token stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">이 플러그가 작동하려면 세션이 이전에 페치되었을 것으로 예상됩니다. 그런 다음 세션에 저장된 토큰을 요청이 보낸 토큰과 비교하여 요청의 유효성을 확인합니다. 유효하지 않은 요청의 경우 조치는 &lt;code&gt;:with&lt;/code&gt; 옵션을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="acbd3da24abf12ae2ee4b4dbe388f7d784a60abf" translate="yes" xml:space="preserve">
          <source>For this reason, Phoenix automatically includes a &amp;ldquo;_utf8=✓&amp;rdquo; parameter in your forms, to force those browsers to send the data in the proper encoding. This technique has been seen in the Rails web framework and reproduced here.</source>
          <target state="translated">이러한 이유로 Phoenix는 양식에&amp;ldquo;_utf8 = ✓&amp;rdquo;매개 변수를 자동으로 포함하여 해당 브라우저가 데이터를 적절한 인코딩으로 보내도록합니다. 이 기술은 Rails 웹 프레임 워크에서 보았으며 여기서 재현되었습니다.</target>
        </trans-unit>
        <trans-unit id="93af13c5fc0bdc9bd0b9d349f954f83799c8aaa8" translate="yes" xml:space="preserve">
          <source>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</source>
          <target state="translated">이러한 이유로 나머지 예제에서는 스키마를 사용하지만 쿼리를 작성하기 위해 Ecto에서는 스키마를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4eee2cf416e710c5d41ff3bd324c67e1310cb64b" translate="yes" xml:space="preserve">
          <source>For use with Plug the certificates and key should be stored in PEM format, containing Base64-encoded data between 'BEGIN' and 'END' markers. Some useful OpenSSL commands for converting certificates/keys from other formats can be found at &lt;a href=&quot;#converting-certificates-and-keys&quot;&gt;the end of this document&lt;/a&gt;.</source>
          <target state="translated">Plug와 함께 사용하려면 인증서와 키를 'BEGIN'과 'END'마커 사이에 Base64로 인코딩 된 데이터를 포함하는 PEM 형식으로 저장해야합니다. 다른 형식의 인증서 / 키를 변환하는 데 유용한 OpenSSL 명령 &lt;a href=&quot;#converting-certificates-and-keys&quot;&gt;은이 문서의 끝에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e5ab937cf7dceafaad92974cb027e2587d7a76" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously</source>
          <target state="translated">주어진 pid가 비동기 적으로 다운되었으므로 테이블 정리를 강제하십시오.</target>
        </trans-unit>
        <trans-unit id="8297c64e60d581b16d4f160782d093bba37f69c8" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously.</source>
          <target state="translated">지정된 pid가 비동기 적으로 다운되었으므로 테이블 정리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9376e40f7dd57bd0a80a45f4b597decef3430bb5" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection</source>
          <target state="translated">소켓 연결에서 SSL을 강제 실행</target>
        </trans-unit>
        <trans-unit id="f2f36ba3d6535af9ad03fa2741c09ec0c941cf53" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection.</source>
          <target state="translated">소켓 연결에서 SSL을 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a94803f581b82f9ba5bdaf6f21212ed730ebfce9" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 강제 변경</target>
        </trans-unit>
        <trans-unit id="ba1f8f66627e0e0f8fe7b916b77edc9622c220fc" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 강제 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">양식 이벤트</target>
        </trans-unit>
        <trans-unit id="cfc11712b7350cabf491f94f3c35d6b7b4841ba2" translate="yes" xml:space="preserve">
          <source>Form bindings</source>
          <target state="translated">양식 바인딩</target>
        </trans-unit>
        <trans-unit id="d59e0684db2c7234ae793772920708c7ec986309" translate="yes" xml:space="preserve">
          <source>Format encoders</source>
          <target state="translated">인코더 포맷</target>
        </trans-unit>
        <trans-unit id="c97fca207ecbaf116ba6ca44368cce3e0a305b92" translate="yes" xml:space="preserve">
          <source>Fortunately that&amp;rsquo;s easily solvable by simply rewriting it to:</source>
          <target state="translated">다행히도 간단히 다음과 같이 다시 작성하면 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0ce27512362c06a1b5491aeb75239f7f72fd68" translate="yes" xml:space="preserve">
          <source>Fortunately that's easily solvable by simply rewriting it to:</source>
          <target state="translated">다행히 다음과 같이 간단히 다시 작성하면 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e135da21707dbf32a06679cd1c1f36d2117cbc6" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; provides the following options to help you classify your events:</source>
          <target state="translated">다행히 &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt; &lt;code&gt;Telemetry.Metrics&lt;/code&gt; &lt;/a&gt; 는 이벤트를 분류하는 데 도움이되는 다음 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0dd153d2c6179415e41d49146fab6f4c5d3731e1" translate="yes" xml:space="preserve">
          <source>Fortunately, our application layout, &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;, already has markup for displaying flash messages.</source>
          <target state="translated">다행히도 애플리케이션 레이아웃 &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; 에는 이미 플래시 메시지를 표시하기위한 마크 업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba4e72261283258434788542ba397135c10f39d8" translate="yes" xml:space="preserve">
          <source>Forward</source>
          <target state="translated">Forward</target>
        </trans-unit>
        <trans-unit id="243792f59615d8e2d372bd2223d968fccda687be" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug</source>
          <target state="translated">주어진 경로에서 요청을 플러그로 전달</target>
        </trans-unit>
        <trans-unit id="16e33ad48d9a60b2973610a401cef5c85f913f57" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug.</source>
          <target state="translated">주어진 경로에서 요청을 플러그로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b32cf12685ca5dc27b473a969f37f02beef213d2" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;</source>
          <target state="translated">요청을 다른 플러그로 전달합니다. &lt;code&gt;path_info&lt;/code&gt; 전달은 연결의 호출로 지정된 경로의 일부 제외한다 &lt;code&gt;forward&lt;/code&gt; . 경로에 매개 변수가 포함 된 경우 대상 플러그인에서 사용할 수 있습니다. &lt;code&gt;conn.params&lt;/code&gt; 및 &lt;code&gt;conn.path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2b6fd862c663433fb18b8d94573b799a0d0c715" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;.</source>
          <target state="translated">요청을 다른 플러그로 전달합니다. &lt;code&gt;path_info&lt;/code&gt; 전달은 연결의 호출로 지정된 경로의 일부 제외한다 &lt;code&gt;forward&lt;/code&gt; . 경로에 매개 변수가 포함되어 있으면 대상 플러그인 &lt;code&gt;conn.params&lt;/code&gt; 및 &lt;code&gt;conn.path_params&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676ca63eda9f110339bc4562d41c4087d1f58d05" translate="yes" xml:space="preserve">
          <source>Four different datetime primitive types are available:</source>
          <target state="translated">4 가지 다른 날짜 / 시간 기본 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="24ecc99e6f92d07b027a8f31eee228f80d919122" translate="yes" xml:space="preserve">
          <source>From DER to PEM</source>
          <target state="translated">DER에서 PEM으로</target>
        </trans-unit>
        <trans-unit id="a3351c1a0bc423227fbc6658fde3c845ebb20e75" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 20, channels automatically hibernate to save memory after 15_000 milliseconds of inactivity. This can be customized by passing the &lt;code&gt;:hibernate_after&lt;/code&gt; option to &lt;code&gt;use Phoenix.Channel&lt;/code&gt;:</source>
          <target state="translated">Erlang / OTP 20에서 채널은 15_000 밀리 초 동안 활동이 없으면 메모리를 절약하기 위해 자동으로 최대 절전 모드로 전환됩니다. &lt;code&gt;use Phoenix.Channel&lt;/code&gt; 을 사용 하기 위해 &lt;code&gt;:hibernate_after&lt;/code&gt; 옵션을 전달하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ea65443ee14e0c13f251a23f3960e33cefea03e" translate="yes" xml:space="preserve">
          <source>From PKCS#12 to PEM</source>
          <target state="translated">PKCS # 12에서 PEM으로</target>
        </trans-unit>
        <trans-unit id="78e393595a2078a0309f19323b539709581858c3" translate="yes" xml:space="preserve">
          <source>From endpoint to views</source>
          <target state="translated">끝점에서보기로</target>
        </trans-unit>
        <trans-unit id="e148084f6ad05655c1539a8c5e852e406d1b752b" translate="yes" xml:space="preserve">
          <source>From the client - this is done by replacing &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt;&lt;code&gt;Phoenix.HTML.Link.link/2&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_redirect/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">클라이언트에서 &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt; &lt;code&gt;Phoenix.HTML.Link.link/2&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_patch/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_redirect/2&lt;/code&gt; &lt;/a&gt; 로 대체하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c883c0cead87878c13107898743ee64b746f1b75" translate="yes" xml:space="preserve">
          <source>From the description, it's clear we need a &lt;code&gt;Page&lt;/code&gt; resource for storing page information. What about our author information? While we could extend our existing &lt;code&gt;Accounts.User&lt;/code&gt; schema to include information such as bio and role, that would violate the responsibilities we've set up for our contexts. Why should our Account system now be aware of author information? Worse, with a field like &quot;role&quot;, the CMS role in the system will likely conflict or be confused with other account roles for our application. There's a better way.</source>
          <target state="translated">설명에서 페이지 정보를 저장하기 위해 &lt;code&gt;Page&lt;/code&gt; 리소스 가 필요하다는 것이 분명 합니다. 저자 정보는 어떻습니까? 약력 및 역할과 같은 정보를 포함하도록 기존 &lt;code&gt;Accounts.User&lt;/code&gt; 스키마를 확장 할 수 있지만 이는 컨텍스트에 대해 설정 한 책임을 위반하는 것입니다. 이제 계정 시스템이 작성자 정보를 인식해야하는 이유는 무엇입니까? 더 나쁜 것은 &quot;역할&quot;과 같은 필드를 사용하면 시스템의 CMS 역할이 애플리케이션의 다른 계정 역할과 충돌하거나 혼동 될 가능성이 있습니다. 더 나은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c42ad7be67b12c5ded49ac88365867cded7985" translate="yes" xml:space="preserve">
          <source>From the server - this is done by replacing &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt;&lt;code&gt;Phoenix.Controller.redirect/2&lt;/code&gt;&lt;/a&gt; calls by &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_redirect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버에서이 작업은 &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt; &lt;code&gt;Phoenix.Controller.redirect/2&lt;/code&gt; &lt;/a&gt; 호출을 &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.push_patch/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.push_redirect/2&lt;/code&gt; &lt;/a&gt; 로 대체하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d57ff449f79bf9c5a7e5e0c8035c5660c71a840" translate="yes" xml:space="preserve">
          <source>From this moment on, all future queries done by the current process will run on &lt;code&gt;:tenant_foo&lt;/code&gt;.</source>
          <target state="translated">이 순간부터 현재 프로세스가 수행하는 모든 향후 쿼리는 &lt;code&gt;:tenant_foo&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7091d22a2b4d23609cc93c591d186ab2886edba6" translate="yes" xml:space="preserve">
          <source>Front-end to Phoenix pubsub layer.</source>
          <target state="translated">Phoenix pubsub 레이어의 프런트 엔드</target>
        </trans-unit>
        <trans-unit id="9a3dd8d119f213e54043ceb85ba50067487df91c" translate="yes" xml:space="preserve">
          <source>Function Plugs</source>
          <target state="translated">기능 플러그</target>
        </trans-unit>
        <trans-unit id="9bf236d048ccab1956dd5420be9ebe7d7c44331e" translate="yes" xml:space="preserve">
          <source>Function plugs</source>
          <target state="translated">기능 플러그</target>
        </trans-unit>
        <trans-unit id="2dd4a4a3d83639ed1b8ee2c403652e8e1564593e" translate="yes" xml:space="preserve">
          <source>Function plugs are plugged by passing the function name as an atom. To try the Plug out, go back to your browser and fetch &quot;http://localhost:4000&quot;. You should see something like this printed in your terminal:</source>
          <target state="translated">함수 플러그는 함수 이름을 원자로 전달하여 연결됩니다. 플러그 아웃을 시도하려면 브라우저로 돌아가 &quot;http : // localhost : 4000&quot;을 가져옵니다. 다음과 같은 내용이 터미널에 인쇄되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c52ba62be465c21dfd3bd9843b5875f996364af7" translate="yes" xml:space="preserve">
          <source>Functional Web Development with Elixir, OTP, and Phoenix Rethink the Modern Web App (by Lance Halvorsen - 2017)</source>
          <target state="translated">Elixir, OTP 및 Phoenix를 사용한 기능적 웹 개발은 최신 웹 앱을 재고합니다 (작성자 : Lance Halvorsen-2017)</target>
        </trans-unit>
        <trans-unit id="8578c4e152b3c9315bc17a094d58da8a5fe7bd6e" translate="yes" xml:space="preserve">
          <source>Functionality for providing Basic HTTP authentication.</source>
          <target state="translated">기본 HTTP 인증을 제공하는 기능.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1442301406adda1b4f88b555bb39bb4cb9e30ff1" translate="yes" xml:space="preserve">
          <source>Furthermore an array type can also be given if it is supported by your database, although it requires the type of the underlying array element to be given too:</source>
          <target state="translated">또한 기본 배열 요소의 유형도 제공해야하지만 데이터베이스에서 지원하는 경우 배열 유형을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c1f2b55dcf3303d32f38fbac65ddded9bd404b" translate="yes" xml:space="preserve">
          <source>Furthermore, both &lt;code&gt;__struct__&lt;/code&gt; and &lt;code&gt;__changeset__&lt;/code&gt; functions are defined so structs and changeset functionalities are available.</source>
          <target state="translated">또한 &lt;code&gt;__struct__&lt;/code&gt; 및 &lt;code&gt;__changeset__&lt;/code&gt; 함수가 모두 정의되므로 구조체 및 변경 집합 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc4cf7a9112b1823e7922465dba21cf009cbc323" translate="yes" xml:space="preserve">
          <source>Furthermore, it is very important to not access the same parameters on both &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. For example, do NOT do this:</source>
          <target state="translated">또한 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt; 모두에서 동일한 매개 변수에 액세스하지 않는 것이 매우 중요합니다 . 예를 들어 다음과 같이하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5d2ace48935ec9ca13c146a4d739dd039753a23f" translate="yes" xml:space="preserve">
          <source>Furthermore, it sets the following defaults:</source>
          <target state="translated">또한 다음 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9c9cc3e69d5248baac17979dd85069ab7aa035bd" translate="yes" xml:space="preserve">
          <source>Furthermore, since the tag information is given as structs read directly from the database, Ecto will treat the data as correct and only do the minimum necessary to guarantee that posts and tags are associated, without trying to update or diff any of the fields in the tag struct.</source>
          <target state="translated">또한 태그 정보는 데이터베이스에서 직접 읽은 구조체로 제공되므로 Ecto는 데이터를 올바른 것으로 취급하고 필드의 필드를 업데이트하거나 비교하지 않고 게시물과 태그가 연결되도록 보장하는 데 필요한 최소한의 작업 만 수행합니다. 태그 구조체.</target>
        </trans-unit>
        <trans-unit id="c338ceb5b7adaaa50f38c347f2349c53389ff49c" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;before_send&lt;/code&gt; field stores callbacks that are invoked before the connection is sent. Callbacks are invoked in the reverse order they are registered (callbacks registered first are invoked last) in order to reproduce a pipeline ordering.</source>
          <target state="translated">또한 &lt;code&gt;before_send&lt;/code&gt; 필드는 연결이 전송되기 전에 호출되는 콜백을 저장합니다. 파이프 라인 순서를 재현하기 위해 콜백은 등록 된 역순으로 호출됩니다 (먼저 등록 된 콜백이 마지막으로 호출 됨).</target>
        </trans-unit>
        <trans-unit id="70e2803f5997f8434e1e14d79b67bf417331f761" translate="yes" xml:space="preserve">
          <source>Furthermore, this protocol relies on iodata, which provides better performance when sending or streaming data to the client.</source>
          <target state="translated">또한이 프로토콜은 iodata를 사용하여 클라이언트로 데이터를 보내거나 스트리밍 할 때 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="98281856e51de8bb0669d3ab3f5d42120b606d43" translate="yes" xml:space="preserve">
          <source>GET requests are not protected, as they should not have any side-effect or change your application state. JavaScript requests are an exception: by using a script tag, external websites can embed server-side generated JavaScript, which can leak information. For this reason, this plug also forbids any GET JavaScript request that is not XHR (or AJAX).</source>
          <target state="translated">GET 요청은 부작용이 없거나 애플리케이션 상태를 변경하지 않아야하므로 보호되지 않습니다. JavaScript 요청은 예외입니다. 스크립트 태그를 사용하면 외부 웹 사이트가 서버 측에서 생성 된 JavaScript를 포함하여 정보가 유출 될 수 있습니다. 이러한 이유로이 플러그는 XHR (또는 AJAX)이 아닌 GET JavaScript 요청도 금지합니다.</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="a96be0a4f608d9678cf95140fc6762e7fff0a137" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="18fd8d6947881e76a9476c5cc3ade9f03cb51e63" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information.</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="81d73279e9d50f0e75f19715870b45b2edcc66d2" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">일반 : &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff7162efc456a290918a3e5ee7fb1cdec59b3096" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#as/1&quot;&gt;&lt;code&gt;as/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parent_as/1&quot;&gt;&lt;code&gt;parent_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">일반 : &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#as/1&quot;&gt; &lt;code&gt;as/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parent_as/1&quot;&gt; &lt;code&gt;parent_as/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89915973deb8400c76aef3230f3bef302eb16934" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;strong&gt;data loading should never happen inside the template&lt;/strong&gt;, regardless if you are using LiveView or not. The difference is that LiveView enforces this best practice.</source>
          <target state="translated">일반적으로 &lt;strong&gt;데이터로드는&lt;/strong&gt; LiveView 사용 여부에 관계없이 &lt;strong&gt;템플릿 내에서 발생해서는 안됩니다&lt;/strong&gt; . 차이점은 LiveView가이 모범 사례를 적용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14a9eeb3344bae3449699429e539fd4fa8761f40" translate="yes" xml:space="preserve">
          <source>Generally speaking, avoid accessing variables inside LiveViews. This also applies to the &lt;code&gt;assigns&lt;/code&gt; variable, except when rendering another &lt;code&gt;.leex&lt;/code&gt; template. In such cases, it is ok to pass the whole assigns, as LiveView will continue to perform change tracking in the called template:</source>
          <target state="translated">일반적으로 LiveView 내부의 변수에 액세스하지 마십시오. 이것은 다른 &lt;code&gt;.leex&lt;/code&gt; 템플릿을 렌더링 할 때를 제외하고 는 &lt;code&gt;assigns&lt;/code&gt; 변수 에도 적용됩니다 . 이러한 경우 LiveView가 호출 된 템플릿에서 변경 내용 추적을 계속 수행하므로 전체 할당을 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a3bcf392d6ffb2ecf8e6673b16608e3a7f45a1a5" translate="yes" xml:space="preserve">
          <source>Generally speaking, once all assigns are configured, we invoke the View layer. The View layer then renders &quot;show.html&quot; alongside the layout and a response is sent back to the browser.</source>
          <target state="translated">일반적으로 모든 할당이 구성되면 View 레이어를 호출합니다. 그런 다음 뷰 레이어는 레이아웃과 함께 &quot;show.html&quot;을 렌더링하고 응답이 브라우저로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c6326d5e8e870450f20952d282dad90d36072ad9" translate="yes" xml:space="preserve">
          <source>Generally speaking, the simplest and safest approach is to perform authorization whenever there is an action. For example, imagine that you have a LiveView for a &quot;Blog&quot;, and only editors can edit posts. Therefore, it is best to validate the user is an editor on mount and on every event:</source>
          <target state="translated">일반적으로 가장 간단하고 안전한 접근 방식은 작업이있을 때마다 권한 부여를 수행하는 것입니다. 예를 들어 &quot;블로그&quot;에 대한 LiveView가 있고 편집자 만 게시물을 편집 할 수 있다고 가정합니다. 따라서 마운트 및 모든 이벤트에서 사용자가 편집자인지 확인하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="02048f2e9cef3e709a6a4f29484a15537a595bf8" translate="yes" xml:space="preserve">
          <source>Generally speaking, you want to avoid both the parent LiveView and the LiveComponent working on two different copies of the state. Instead, you should assume only one of them to be the source of truth. Let's discuss the two different approaches in detail.</source>
          <target state="translated">일반적으로 부모 LiveView와 LiveComponent가 서로 다른 두 개의 상태 복사본에서 작동하지 않도록해야합니다. 대신 그들 중 하나만 진실의 근원이라고 가정해야합니다. 두 가지 다른 접근 방식에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="dbf039f3463a6192dcedbf378221d86ccce25ca4" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form</source>
          <target state="translated">지정된 매개 변수에 대해 새 양식 빌더를 양식으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="2809e45ea67772c9b7701d8d849d6d2e451fe427" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식의 지정된 매개 변수에 대한 새 양식 작성기를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="15e52a102d3768bc19eacc2abb7f4194a20be07e" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form.</source>
          <target state="translated">지정된 매개 변수에 대해 새 양식 빌더를 양식으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc292ee42a9b81099735fa47e66e355172cc4c20" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema&amp;rsquo;s primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">생성 된 마이그레이션은 스키마의 기본 키에 &lt;code&gt;binary_id&lt;/code&gt; 를 사용 하고 &lt;code&gt;--binary-id&lt;/code&gt; 옵션과 함께 해당 참조를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de509ead052a1d21c5bec58e9e137546f9fbc245" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema's primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">생성 된 마이그레이션은 &lt;code&gt;--binary-id&lt;/code&gt; 옵션을 사용 하여 스키마의 기본 키 및 참조에 &lt;code&gt;binary_id&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f64a5913edebccd654a6fcbe563ded9895c73182" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields</source>
          <target state="translated">&lt;code&gt;:inserted_at&lt;/code&gt; 및 &lt;code&gt;:updated_at&lt;/code&gt; 타임 스탬프 필드 생성</target>
        </trans-unit>
        <trans-unit id="6e6bf2fc4b7fa7784ba0393c92ca08b83b688b33" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields.</source>
          <target state="translated">&lt;code&gt;:inserted_at&lt;/code&gt; 및 &lt;code&gt;:updated_at&lt;/code&gt; 시간 소인 필드를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f543054b72a2d883e856cf6feb6ce5419c2d27c6" translate="yes" xml:space="preserve">
          <source>Generates LiveView, templates, and context for a resource.</source>
          <target state="translated">리소스에 대한 LiveView, 템플릿 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="46ec673256a5e76ef7c069fc676e2f5aef51009e" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply</source>
          <target state="translated">비동기 응답에 대한 &lt;code&gt;socket_ref&lt;/code&gt; 를 생성합니다</target>
        </trans-unit>
        <trans-unit id="89363898c56d89d0dc4865b93a5f0b41e2cb4d20" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply.</source>
          <target state="translated">비동기 응답에 대한 &lt;code&gt;socket_ref&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7254b9e30fd4dcd56334ce2310a46519a11db327" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix channel.</source>
          <target state="translated">피닉스 채널을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dbbfe88a5e9c28bee33e4a7709d25c7578b13712" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix resource.</source>
          <target state="translated">Phoenix 리소스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="396e5bd6ba3cdeb590c49ec0bbf4116674cec309" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker for your application.</source>
          <target state="translated">응용 프로그램에 대한 현재 상태 추적기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e050d4cb2d11258492bf32d26abe466db5793c12" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker.</source>
          <target state="translated">현재 상태 추적기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5b57a23b25adcd3dfb1b05de10692fcac4b0c0a7" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL</source>
          <target state="translated">주어진 URL에 제출하기 위해 일반 HTML 양식을 사용하는 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6dc6b7e0d06c3c7fac4214ca839f28cb452a6270" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL.</source>
          <target state="translated">주어진 URL에 제출하기 위해 일반 HTML 양식을 사용하는 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="64561f910e36802f2f2af6c0eeef79ae9959a53a" translate="yes" xml:space="preserve">
          <source>Generates a checkbox</source>
          <target state="translated">확인란을 생성합니다</target>
        </trans-unit>
        <trans-unit id="9c402930c245037de584689931bc5f98cb925246" translate="yes" xml:space="preserve">
          <source>Generates a checkbox.</source>
          <target state="translated">확인란을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e758b3646d387941fe43bb7c638a89c7ddd9d4c8" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree</source>
          <target state="translated">감독 트리에서 사용할 childspec을 생성합니다</target>
        </trans-unit>
        <trans-unit id="084a356e3603b2d7d3058ec01dbce1827e553b3a" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree.</source>
          <target state="translated">감독 트리에서 사용할 childspec을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c63422f792595ace635012713e2e3ec5fdcfe7c7" translate="yes" xml:space="preserve">
          <source>Generates a color input</source>
          <target state="translated">색상 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="45606cc48a2c148438a5b2a691378a779e9d8307" translate="yes" xml:space="preserve">
          <source>Generates a color input.</source>
          <target state="translated">색상 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f79dfad3ee4eee79404d483203748cd197bfb509" translate="yes" xml:space="preserve">
          <source>Generates a context with functions around an Ecto schema.</source>
          <target state="translated">Ecto 스키마를 중심으로 함수가 포함 된 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="171627640dc242b4213e2f665007e56c741ce2ff" translate="yes" xml:space="preserve">
          <source>Generates a date input</source>
          <target state="translated">날짜 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="1fcc6c8cae144832ffc98dcd40c8eac478e1a7da" translate="yes" xml:space="preserve">
          <source>Generates a date input.</source>
          <target state="translated">날짜 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67502aa3ceeeceb276d924590c8fa7dd9b0a9b11" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input</source>
          <target state="translated">날짜 / 시간 로컬 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="ef3ed161bccd6158e836dadcf99ca1633c739273" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input.</source>
          <target state="translated">날짜 / 시간 로컬 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9e84d239e416d559f3c0bccab74b22cff072a5a3" translate="yes" xml:space="preserve">
          <source>Generates a file input</source>
          <target state="translated">파일 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="39fb04074dabbb624cbc620ccf147d69b2a45061" translate="yes" xml:space="preserve">
          <source>Generates a file input.</source>
          <target state="translated">파일 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ab3c6b9191c757e18e68646ddc1874ca970de62b" translate="yes" xml:space="preserve">
          <source>Generates a form tag</source>
          <target state="translated">양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b412e1f99156deb9e91f69f6b5ac9155bb03b9cf" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder</source>
          <target state="translated">양식 작성기를 사용하여 양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="15171feee1ac42a2cb8b455685e4d0d0b906602c" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식 작성기로 양식 태그를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b83bd97bb3e9ba2d575b33b43cdc2a09ecc53c26" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; options or an anonymous function.</source>
          <target state="translated">옵션 또는 익명 함수 &lt;strong&gt;없이&lt;/strong&gt; 양식 작성기로 양식 태그를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e62cb449bf1bc7de104a5c6a894843c62b8273" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder and an anonymous function.</source>
          <target state="translated">양식 작성기 및 익명 함수를 사용하여 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5867e479588e031d9af73f4e26e2f4bb755d993f" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder.</source>
          <target state="translated">양식 작성기를 사용하여 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1fcf6d502cbed8c6774cbd71cd67cb0475fb8d97" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents</source>
          <target state="translated">주어진 내용으로 양식 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="73a7ae0251a3209970edcca52c92641cb83828a7" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents.</source>
          <target state="translated">주어진 내용으로 양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6fb768c7b9543e92cc3420ccd02e97e5655cfdc3" translate="yes" xml:space="preserve">
          <source>Generates a form tag.</source>
          <target state="translated">양식 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20996193071a0905fdf25cb5c613758dc8b93878" translate="yes" xml:space="preserve">
          <source>Generates a hidden input</source>
          <target state="translated">숨겨진 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="5b13e8707f3e8f0d576e0f2751dda4df911730a0" translate="yes" xml:space="preserve">
          <source>Generates a hidden input.</source>
          <target state="translated">숨겨진 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="abfeb23072c3a06d67ccfbf879bf2eeab96d5b0f" translate="yes" xml:space="preserve">
          <source>Generates a label tag</source>
          <target state="translated">라벨 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="ce9ab90073232b80839e14e4bbe7f7a803a34eae" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field</source>
          <target state="translated">주어진 필드에 대한 레이블 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="ab3ca2bbbbcd12eb651c2e27c2a279e192ff3c15" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field.</source>
          <target state="translated">주어진 필드에 대한 레이블 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28a6fc00166a8c669fa44ea65f62685493aa2310" translate="yes" xml:space="preserve">
          <source>Generates a label tag.</source>
          <target state="translated">라벨 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ba5c47606513e6f4c9932f97cff5edb31a7e4352" translate="yes" xml:space="preserve">
          <source>Generates a link that will patch the current LiveView.</source>
          <target state="translated">현재 LiveView를 패치 할 링크를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="64cb73e3623bbaa3ca07f4ea3ebd7ddcfb72cbbe" translate="yes" xml:space="preserve">
          <source>Generates a link that will redirect to a new LiveView.</source>
          <target state="translated">새 LiveView로 리디렉션되는 링크를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a50123897c2b44bec513e431ba7cb02309189fef" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL</source>
          <target state="translated">주어진 URL에 대한 링크를 생성합니다</target>
        </trans-unit>
        <trans-unit id="c1f404e8a3f775cd18f3aa5b04a6353a8bd3eb26" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL.</source>
          <target state="translated">주어진 URL에 대한 링크를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6ea02c48fa1a1a43ce66c3cf13791ad70aa1639c" translate="yes" xml:space="preserve">
          <source>Generates a loaded version of the data.</source>
          <target state="translated">로드 된 데이터 버전을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dbc6ea3e0e5e175a0282431e58e112038aaa09c9" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information</source>
          <target state="translated">CSRF 정보로 메타 태그 생성</target>
        </trans-unit>
        <trans-unit id="2219f0cedebbcfc4a9097edd34a767a497cb1274" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information.</source>
          <target state="translated">CSRF 정보로 메타 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3aee4fdfd218c8ef8af1764ebe197ddee57e21b5" translate="yes" xml:space="preserve">
          <source>Generates a new file, &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt;, where &lt;code&gt;my_presence&lt;/code&gt; is the snake-cased version of the provided module name.</source>
          <target state="translated">새 파일 &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt; 를 생성합니다 . 여기서 &lt;code&gt;my_presence&lt;/code&gt; 는 제공된 모듈 이름의 스네이크 케이스 버전입니다.</target>
        </trans-unit>
        <trans-unit id="02411617ad03187efe4d79ddc98c3934f98cab53" translate="yes" xml:space="preserve">
          <source>Generates a new repository.</source>
          <target state="translated">새로운 저장소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ec4e73c7a7527a111588dbb3ab99814034f1ef6f" translate="yes" xml:space="preserve">
          <source>Generates a number input</source>
          <target state="translated">숫자 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="11f48eeb86c1ee3d50fe2a5731642a36708b06b0" translate="yes" xml:space="preserve">
          <source>Generates a number input.</source>
          <target state="translated">숫자 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="47709e3ef4238d15f86dbf2ee76f58d705224d78" translate="yes" xml:space="preserve">
          <source>Generates a password input</source>
          <target state="translated">비밀번호 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6d0d9edbf1971f56f1a0efb9364b266914f7db45" translate="yes" xml:space="preserve">
          <source>Generates a password input.</source>
          <target state="translated">비밀번호 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3f4172380d2e87d78dec42dfbd35c80f932ab725" translate="yes" xml:space="preserve">
          <source>Generates a radio button</source>
          <target state="translated">라디오 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="54d925054bfa8df9816df148a94806ed340b7d20" translate="yes" xml:space="preserve">
          <source>Generates a radio button.</source>
          <target state="translated">라디오 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4211b9345387b675b9be0fc4617dcd0837432193" translate="yes" xml:space="preserve">
          <source>Generates a range input</source>
          <target state="translated">범위 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="f1d665b37d2ee2aaaf57abb73a773d37fb5632a4" translate="yes" xml:space="preserve">
          <source>Generates a range input.</source>
          <target state="translated">범위 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="42b02a853b6591ae8dcaaf9e2b0f271bae8897d8" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state</source>
          <target state="translated">모든 양식 필드를 원래 상태로 재설정하기위한 재설정 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5f9c5b5c3c6b4005d0ded69c44513c4c93741343" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state.</source>
          <target state="translated">모든 양식 필드를 원래 상태로 재설정하기 위해 재설정 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c9376cf87944d2c7638464200c033426a186aa76" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method</source>
          <target state="translated">임의의 HTTP 메소드를 기반으로 경로 일치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cc5394e9f36a89d2ae9bb46e099d38573bd6b481" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method.</source>
          <target state="translated">임의의 HTTP 메소드를 기반으로 경로 일치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="897983719926fe4ff3d98b2bae0351ca40ad6096" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 에서 정적 파일에 대한 경로를 생성합니다</target>
        </trans-unit>
        <trans-unit id="bf0351ad82e221297ee7764e10c9555e6b0f6dea" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 에있는 정적 파일에 대한 경로를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="894b7547e38d381fd5440a4e9164d424f886e4e7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path</source>
          <target state="translated">주어진 경로에 대한 연결 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="574b4ca741e3f439c47b28cd49adf25fd2f68c1b" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path.</source>
          <target state="translated">주어진 경로에 대한 연결 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="378f585ff9da2c90adf66dd182b6c07d40c0b410" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path</source>
          <target state="translated">지정된 경로에 대한 삭제 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e5a45bd26b667751489c9867bc4ac2e1ad5f415" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path.</source>
          <target state="translated">지정된 경로에 대한 삭제 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9b7eea3e2812a3a9f1485a0bf4b06ac9322cb592" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path</source>
          <target state="translated">주어진 경로에 대한 get 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="57d3a2a07eedb652e1be011b09d407612fa940d1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path.</source>
          <target state="translated">주어진 경로에 대한 get 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ad76b05490559045cdfdb8bde3bf7f1fbb5c58a4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path</source>
          <target state="translated">주어진 경로에 대한 헤드 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90093949144eba1a5fb435edb853256751817dc8" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path.</source>
          <target state="translated">주어진 경로에 대한 헤드 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e24375171478c89552863fcfeadc3ce58f2e5bca" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path</source>
          <target state="translated">주어진 경로에 대한 옵션 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77c88cce859e3f038ecdbff85d2d730cb2bf13d0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path.</source>
          <target state="translated">주어진 경로에 대한 옵션 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="80ed50be25df94aebc7db8a8ad0804d3342708c1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path</source>
          <target state="translated">주어진 경로에 대한 패치 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cca725a12cd24948f36b9ede692ae61a76c694e0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path.</source>
          <target state="translated">주어진 경로에 대한 패치 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1ac815ff5f9cdaae6a2df79818543d53e1f2f23f" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path</source>
          <target state="translated">지정된 경로에 대한 게시 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6fd5d431492f5f17891de85401d2c1290f388443" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path.</source>
          <target state="translated">지정된 경로에 대한 게시 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d46c0f90d8dd7ffb2914e6f3104c626432be2" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path</source>
          <target state="translated">주어진 경로에 대한 넣기 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f9ffc6392b8fbd3db7cb9e0d3dc9186949c8f8b7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path.</source>
          <target state="translated">주어진 경로에 대한 넣기 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e0b014c7fd0d0d1d83b5a70fa8d6fe074e0f3052" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path</source>
          <target state="translated">주어진 경로에 대한 추적 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="221bae031a3004d5c2045808e65d68d8c217bcd4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path.</source>
          <target state="translated">주어진 경로에 대한 추적 요청을 처리하기위한 경로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a62a15cee984de5f9b1d155a86ae8b908ee45da6" translate="yes" xml:space="preserve">
          <source>Generates a search input</source>
          <target state="translated">검색 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="9a485964d5b7b8267fbecbe17ff5ca372d19bb8a" translate="yes" xml:space="preserve">
          <source>Generates a search input.</source>
          <target state="translated">검색 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e8a0342fc5c68fc8986011bb012bd0c39bcd4083" translate="yes" xml:space="preserve">
          <source>Generates a secret and prints it to the terminal.</source>
          <target state="translated">비밀을 생성하여 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="67e63e20fe6b5c241bb9891340bbc4e7f9f2e977" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;options&lt;/code&gt; 으로 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="8387b222b8a18961d9656292381976a0bb723ec4" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;options&lt;/code&gt; 으로 선택 태그를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2eb9a468a2e248674c486507b7bdb6b1eceae235" translate="yes" xml:space="preserve">
          <source>Generates a self-signed certificate for HTTPS testing.</source>
          <target state="translated">HTTPS 테스트를 위해 자체 서명 된 인증서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="af0d06afeae9859b4f3fd6e9e412d3a718e92c81" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name</source>
          <target state="translated">템플릿 이름에서 상태 메시지를 생성합니다</target>
        </trans-unit>
        <trans-unit id="7454d06c3dd95214098294a1b0310dac0b7a4878" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name.</source>
          <target state="translated">템플릿 이름에서 상태 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="067fc3be22bab148f6c9165e5da91f0df3fa5da9" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form</source>
          <target state="translated">양식을 보내기 위해 제출 버튼을 생성합니다</target>
        </trans-unit>
        <trans-unit id="312f705dccca8c086547117e4724c8592db5695d" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form.</source>
          <target state="translated">양식을 보낼 제출 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f4ea648663e608eaa4d4758ecd78961c842e565e" translate="yes" xml:space="preserve">
          <source>Generates a telephone input</source>
          <target state="translated">전화 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="912392aacff0f7188b964ec552a88e06572c1c85" translate="yes" xml:space="preserve">
          <source>Generates a telephone input.</source>
          <target state="translated">전화 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="54aa2d4862224e6c0fb69837326cc7b97ce5c66a" translate="yes" xml:space="preserve">
          <source>Generates a text input</source>
          <target state="translated">텍스트 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="73f0bd438fee7c9707ed766a9afb23c407583846" translate="yes" xml:space="preserve">
          <source>Generates a text input.</source>
          <target state="translated">텍스트 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="45397941ecf32426955313a201964be41c43f1da" translate="yes" xml:space="preserve">
          <source>Generates a textarea input</source>
          <target state="translated">텍스트 영역 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="126b50f201a72f4c020abacab8f934f9f30a6581" translate="yes" xml:space="preserve">
          <source>Generates a textarea input.</source>
          <target state="translated">텍스트 영역 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="eceb224d2682e883c41b426e06844bbc0bb1dbfb" translate="yes" xml:space="preserve">
          <source>Generates a time input</source>
          <target state="translated">시간 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6248af3237dc2fb4fd35ad1108d254199730ac1e" translate="yes" xml:space="preserve">
          <source>Generates a time input.</source>
          <target state="translated">시간 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ae030fe064e790de454fd16af4f1f68f22484a3" translate="yes" xml:space="preserve">
          <source>Generates a token and stores it in the process dictionary if one does not exist.</source>
          <target state="translated">토큰을 생성하고 존재하지 않는 경우 프로세스 사전에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e9144aebe51b655f2f4bb9bb809ff17899371d44" translate="yes" xml:space="preserve">
          <source>Generates a two item tuple containing the &lt;code&gt;static_path&lt;/code&gt; and &lt;code&gt;static_integrity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_path&lt;/code&gt; 및 &lt;code&gt;static_integrity&lt;/code&gt; 를 포함하는 두 항목 튜플을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e07857e5bb53d01eb1dafeb1352fa46eae3a116c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID</source>
          <target state="translated">버전 4 (임의) UUID를 생성합니다</target>
        </trans-unit>
        <trans-unit id="21e2aa08f9efa85d22010347be63b109be8c5a02" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format</source>
          <target state="translated">이진 형식으로 버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0e42f792fb874b4044bce2c20dbf1af12c49012" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format.</source>
          <target state="translated">이진 형식으로 버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0f3d3d0bf68951efc2ef0156a57ac19451a2154c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID.</source>
          <target state="translated">버전 4 (임의) UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f629d614bd57112e09d421f86237a37bc2fa9a5" translate="yes" xml:space="preserve">
          <source>Generates an Ecto model in your Phoenix application.</source>
          <target state="translated">Phoenix 애플리케이션에서 Ecto 모델을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="192881be6736fea74c466100ba43922580a0b06b" translate="yes" xml:space="preserve">
          <source>Generates an Ecto schema and migration.</source>
          <target state="translated">Ecto 스키마 및 마이그레이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3c003e1e5dc81ee91cde965669c00912afc2b27c" translate="yes" xml:space="preserve">
          <source>Generates an email input</source>
          <target state="translated">이메일 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="c7bd255992aaeef9602f0be4b666b7be9fe3a2ba" translate="yes" xml:space="preserve">
          <source>Generates an email input.</source>
          <target state="translated">이메일 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6504cdfcb718565b5576fc2158cd57efe4825bb4" translate="yes" xml:space="preserve">
          <source>Generates an embedded Ecto schema for casting/validating data outside the DB.</source>
          <target state="translated">DB 외부에서 데이터를 캐스트 / 검증하기위한 내장 Ecto 스키마를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2cad790430badca14ec8c02cc664082faed9f493" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src</source>
          <target state="translated">src로 img 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="9b6859233f63365d7a32da180d650f35004ce39e" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src.</source>
          <target state="translated">src를 사용하여 img 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31a11500f500d76442b5a7660ff34e1c46e8aaa8" translate="yes" xml:space="preserve">
          <source>Generates an integrity hash to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;priv/static&lt;/code&gt; 의 정적 파일에 대한 무결성 해시를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="94584e370048710080737b7da1191363a53d9074" translate="yes" xml:space="preserve">
          <source>Generates an url input</source>
          <target state="translated">URL 입력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="41f536102076cb368a63c9729925c85b108feb67" translate="yes" xml:space="preserve">
          <source>Generates an url input.</source>
          <target state="translated">URL 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3eaee8e36f647786a53b9f964255fe72cc821f1a" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for a JSON resource.</source>
          <target state="translated">JSON 리소스에 대한 컨트롤러,보기 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="822515dec0a67435114ec101cc230428d2840774" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an HTML resource.</source>
          <target state="translated">HTML 리소스에 대한 컨트롤러,보기 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="be50e5d315403c8a6e5ed901af8b36c1c04a5c95" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an JSON resource.</source>
          <target state="translated">JSON 리소스에 대한 컨트롤러, 뷰 및 컨텍스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e78eb34839e1acd728f57541f822721b2b3ba7cc" translate="yes" xml:space="preserve">
          <source>Generates hidden inputs for the given form.</source>
          <target state="translated">주어진 양식에 대해 숨겨진 입력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8b426df53681f88f2110c30af8bf84dbae2dbb1" translate="yes" xml:space="preserve">
          <source>Generates select tags for date</source>
          <target state="translated">날짜에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="900feb5d8076251ce1c88b1c50c88ed36d4df204" translate="yes" xml:space="preserve">
          <source>Generates select tags for date.</source>
          <target state="translated">날짜에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="33944458ee24e52c6f57b54406929743c95d1e0f" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime</source>
          <target state="translated">날짜 시간에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b91c0777babdf510129bdd926e272571b56c507a" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime.</source>
          <target state="translated">날짜 / 시간에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2989d503428e011977ec7d2d26ea57f0cd501ff1" translate="yes" xml:space="preserve">
          <source>Generates select tags for time</source>
          <target state="translated">시간에 대한 선택 태그를 생성합니다</target>
        </trans-unit>
        <trans-unit id="44c3290708cfe98a895d3932d31b3028cf656029" translate="yes" xml:space="preserve">
          <source>Generates select tags for time.</source>
          <target state="translated">시간에 대한 선택 태그를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="06abc3fc049f6aeb29e4374ef7a511dc801188d0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information</source>
          <target state="translated">경로 정보없이 엔드 포인트 기본 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c54d53d2a725dae194fd5931fc6e94b42a7bafb" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information.</source>
          <target state="translated">경로 정보없이 엔드 포인트 기본 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="566783b0db0c0900209be301c7fb5794061562a0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct</source>
          <target state="translated">엔드 포인트 기본 URL을 생성하지만 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 구조체로 생성</target>
        </trans-unit>
        <trans-unit id="a457480f3b7970598a96e97a308a2c57be1d9d62" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">엔드 포인트 기본 URL을 생성하지만 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 구조체 로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="a56e0e8f6c89e5bcd6f332dfe4a7f18f1d712206" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint</source>
          <target state="translated">이 엔드 포인트로 라우팅 할 때 경로 정보를 생성합니다</target>
        </trans-unit>
        <trans-unit id="9de6c6bdf8366eaa60f44b75556d6710e9111768" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint.</source>
          <target state="translated">이 엔드 포인트로 라우팅 할 때 경로 정보를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92831dcf10942016c97191fd271c8140a6105d73" translate="yes" xml:space="preserve">
          <source>Generates the static URL without any path information.</source>
          <target state="translated">경로 정보없이 정적 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d336eb35990be39ada49eb89ccf7bc531bbf8d59" translate="yes" xml:space="preserve">
          <source>Generating typespecs for schemas is out of the scope of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스키마에 대한 typespec 생성은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 범위를 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="c7afc8fed6ae07096bcda43b2c180de120f70394" translate="yes" xml:space="preserve">
          <source>Generating without a schema</source>
          <target state="translated">스키마없이 생성</target>
        </trans-unit>
        <trans-unit id="3b22374ca8da32cfe346b6ca99bea860d67b2484" translate="yes" xml:space="preserve">
          <source>Generating without a schema or context file</source>
          <target state="translated">스키마 또는 컨텍스트 파일없이 생성</target>
        </trans-unit>
        <trans-unit id="24e7830f821b426f5a51f69a462e899b6faff3ad" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value</source>
          <target state="translated">변경을 가져 오거나 기본값을 반환</target>
        </trans-unit>
        <trans-unit id="20c69fc2d13ee5ae1e5c766de8168c5e86eac703" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value.</source>
          <target state="translated">변경을 가져 오거나 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae896285359a3676cf6a8e84fe64f02a1009d1d3" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data</source>
          <target state="translated">변경 또는 데이터에서 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bd5eebfdc41b8efa306222262683e1e2cb53f629" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data.</source>
          <target state="translated">변경 또는 데이터에서 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f0ad8554cfab9a4c20a7b61ea4176e67168e383d" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path</source>
          <target state="translated">응용 프로그램 경로와 관련된 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="54e09b22dc0bfd8c0d4977361cbe415e92fbad7a" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path.</source>
          <target state="translated">응용 프로그램 경로와 관련된 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="988d679daebf10d001e25c095b5b9e286e6bc11c" translate="yes" xml:space="preserve">
          <source>Gets how the type is treated inside embeds for the given format.</source>
          <target state="translated">주어진 형식에 대한 임베드 내부에서 유형이 처리되는 방법을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="df3ff2dbf500da7f3bca6907ee8045b12c112c08" translate="yes" xml:space="preserve">
          <source>Gets or generates a CSRF token.</source>
          <target state="translated">CSRF 토큰을 가져 오거나 생성합니다.</target>
        </trans-unit>
        <trans-unit id="997af9359b0274152d5976f8e8ca9230b5813c54" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair</source>
          <target state="translated">주어진 주제와 키 페어에서 현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="48f0745d124d4e83473eebb47a6d31ab2415d144" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair.</source>
          <target state="translated">주어진 주제와 키 페어에서 현재 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="97e4290574c5ed51caafb10b2de1e172c163410b" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token</source>
          <target state="translated">CSRF 토큰을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="08349fa609238bb75520280fb127235024b0eb68" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct)</source>
          <target state="translated">연결된 URL에 대한 CSRF 토큰을 가져옵니다 (문자열 또는 URI 구조체로).</target>
        </trans-unit>
        <trans-unit id="ff08f49db7e1265b7a0948738482fffe83f058a7" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct).</source>
          <target state="translated">연결된 URL의 CSRF 토큰 (문자열 또는 URI 구조체)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8d4fe3f1095bcbf480568f707f0f32660bfed495" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token.</source>
          <target state="translated">CSRF 토큰을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cacf574b487bbebb0a08dffbbbde22c3caa9dd7c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage</source>
          <target state="translated">플래시 스토리지에서 지정된 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="39a3c0f8225971cc340f65e20abcd3cfd296785c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage.</source>
          <target state="translated">플래시 스토리지에서 지정된 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="96a62524d2bf17765eab415eae3c27d04f1cdf6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field</source>
          <target state="translated">주어진 필드에 대한 입력 유형을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="66f52ba2db0eb578cab960fd32bdb155e164ce6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field.</source>
          <target state="translated">주어진 필드의 입력 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b27071d61374355defa4f7ba87856a1483070f41" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct</source>
          <target state="translated">주어진 구조체에서 메타 데이터를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="678baa7f889b181e04ecd1461201171108459f0b" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct.</source>
          <target state="translated">주어진 구조체에서 메타 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3304a8905eb384bf8c92d54b81cce4e1c7c19f8b" translate="yes" xml:space="preserve">
          <source>Gets the nested LiveView child by &lt;code&gt;child_id&lt;/code&gt; from the &lt;code&gt;parent&lt;/code&gt; LiveView.</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; LiveView 에서 &lt;code&gt;child_id&lt;/code&gt; 로 중첩 된 LiveView 자식을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4aa65e24dc6d0d5c51eaeaf4bdd4b579ff2fe71c" translate="yes" xml:space="preserve">
          <source>Gets the store name from an atom or a module.</source>
          <target state="translated">원자 또는 모듈에서 저장소 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1baad63621d111aecd80381a2421d2b880bc0a22" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage</source>
          <target state="translated">전체 플래시 스토리지를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="64814fa71bd4c722ebaa70f584d80370c84fe56a" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage.</source>
          <target state="translated">전체 플래시 저장소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="6e3f22a652c385048db92eec4f86769df4e6a06f" translate="yes" xml:space="preserve">
          <source>Getting Started with Phoenix (by Pluralsight - 2017)</source>
          <target state="translated">Phoenix 시작하기 (by Pluralsight-2017)</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="c058929c7d291e4d62d960baf0a6197123595989" translate="yes" xml:space="preserve">
          <source>Give the Erlang/OTP runtime (that is, the BEAM VM executable) permission to bind to privileged ports using 'setcap', e.g. &lt;code&gt;sudo setcap 'cap_net_bind_service=+ep' /usr/lib/erlang/erts-10.1/bin/beam.smp&lt;/code&gt;; update the path as necessary, and remember to run the command again after Erlang upgrades</source>
          <target state="translated">Erlang / OTP 런타임 (즉, BEAM VM 실행 파일)에 'setcap'을 사용하여 권한있는 포트에 바인딩 할 수있는 권한을 부여합니다 (예 : &lt;code&gt;sudo setcap 'cap_net_bind_service=+ep' /usr/lib/erlang/erts-10.1/bin/beam.smp&lt;/code&gt; ; 필요에 따라 경로를 업데이트하고 Erlang을 업그레이드 한 후 명령을 다시 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f8730e43ab24e7c728fed006e4af4c853f6327c" translate="yes" xml:space="preserve">
          <source>Given almost all &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; actions in your application will have to perform these exact steps, we recommend creating a function called &lt;code&gt;assign_defaults/2&lt;/code&gt; or similar, putting it in a new module like &lt;code&gt;MyAppWeb.LiveHelpers&lt;/code&gt;, and modifying &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; so all LiveViews automatically import it:</source>
          <target state="translated">거의 모든 감안할 때 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 응용 프로그램의 행동은 우리가라는 함수 만드는 것이 좋습니다 이러한 정확한 단계를 수행해야합니다 &lt;code&gt;assign_defaults/2&lt;/code&gt; , 또는 유사한 같은 새 모듈에 넣어 &lt;code&gt;MyAppWeb.LiveHelpers&lt;/code&gt; , 및 수정 &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; 그래서 모든 LiveView는 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a4181efd0f5aa1fb39a060e1a478e56b7d07cbd" translate="yes" xml:space="preserve">
          <source>Given components compartmentalize markup on the server, they are also rendered in isolation on the client, which provides great performance benefits on the client too.</source>
          <target state="translated">구성 요소가 서버에서 마크 업을 구획화하면 클라이언트에서도 격리 된 상태로 렌더링되므로 클라이언트에서도 뛰어난 성능 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47b0c7375e98f73f52e1b737eb418a247d1da8fd" translate="yes" xml:space="preserve">
          <source>Given that a LiveView runs on its own process, it is an excellent tool for creating completely isolated UI elements, but it is a slightly expensive abstraction if all you want is to compartmentalize markup and events. For example, if you are showing a table with all users in the system, and you want to compartmentalize this logic, rendering a separate &lt;code&gt;LiveView&lt;/code&gt; for each user, then using a process per user would likely be too expensive. For these cases, LiveView provides &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt;, which are rendered using &lt;code&gt;live_component/3&lt;/code&gt;:</source>
          <target state="translated">LiveView가 자체 프로세스에서 실행된다는 점을 감안할 때 완전히 격리 된 UI 요소를 생성하기위한 훌륭한 도구이지만 마크 업과 이벤트를 구분하는 것이라면 약간의 비용이 많이 드는 추상화입니다. 예를 들어 시스템의 모든 사용자가 포함 된 테이블을 표시하고이 논리를 구분 하여 각 사용자에 대해 별도의 &lt;code&gt;LiveView&lt;/code&gt; 를 렌더링하려는 경우 사용자 당 프로세스를 사용하는 데 너무 많은 비용이들 수 있습니다. 이런 경우, 라이브 뷰가 제공 &lt;a href=&quot;phoenix.livecomponent&quot;&gt; &lt;code&gt;Phoenix.LiveComponent&lt;/code&gt; &lt;/a&gt; 사용하여 렌더링, &lt;code&gt;live_component/3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b50f484d78e3b110b11618fae5e4f8de3a3ef714" translate="yes" xml:space="preserve">
          <source>Given the button does not appear in the UI, triggering the &quot;leave&quot; when the organization has now only one member is an unexpected scenario. This means we can probably rewrite the code above to:</source>
          <target state="translated">버튼이 UI에 표시되지 않는 경우 조직에 이제 한 명의 구성원 만있을 때 &quot;탈퇴&quot;가 트리거되는 것은 예상치 못한 시나리오입니다. 이는 위의 코드를 다음과 같이 다시 작성할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eaafd2714d8805ff67c29755c6b072c4bffa71a8" translate="yes" xml:space="preserve">
          <source>Given the code on mount runs both on the initial disconnected render and the connected render, an exception on mount will trigger the following events:</source>
          <target state="translated">마운트시 코드가 연결이 끊긴 초기 렌더와 연결된 렌더 모두에서 실행되는 경우 마운트시 예외가 다음 이벤트를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="f418c387ce0535243c1ffc04f850d20578d8ccef" translate="yes" xml:space="preserve">
          <source>Globs can match segments partially too. The difference is the whole segment is captured along with the trailing segments.</source>
          <target state="translated">Glob은 세그먼트도 부분적으로 일치시킬 수 있습니다. 차이점은 전체 세그먼트가 후행 세그먼트와 함께 캡처된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a88c991df04bd6fcf2fb3f005a3c9207b89cc95" translate="yes" xml:space="preserve">
          <source>Go to &quot;&lt;a href=&quot;http://localhost:4000/%22&quot;&gt;http://localhost:4000/&quot;&lt;/a&gt; and you should see the locale exhibited. Visit &quot;&lt;a href=&quot;http://localhost:4000/?locale=fr%22&quot;&gt;http://localhost:4000/?locale=fr&quot;&lt;/a&gt; and you should see the assign changed to &quot;fr&quot;. Someone can use this information alongside &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;Gettext&lt;/a&gt; to provide a fully internationalized web application.</source>
          <target state="translated">&quot; &lt;a href=&quot;http://localhost:4000/%22&quot;&gt;http : // localhost : 4000 /&quot;&lt;/a&gt; 로 이동하면 표시된 로케일을 볼 수 있습니다. &quot; &lt;a href=&quot;http://localhost:4000/?locale=fr%22&quot;&gt;http : // localhost : 4000 /? locale = fr&quot;&lt;/a&gt; 을 방문하면 할당이 &quot;fr&quot;로 변경된 것을 볼 수 있습니다. 누군가는이 정보를 &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;Gettext&lt;/a&gt; 와 함께 사용 하여 완전히 국제화 된 웹 응용 프로그램을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="085bd772dd72f1ee66df662034a18b6fef587590" translate="yes" xml:space="preserve">
          <source>Good work!</source>
          <target state="translated">잘 했어!</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="eef0115acb31caa0fbd5afc01384c4545e7d44b5" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas</source>
          <target state="translated">모든 복제본에 permdown을 브로드 캐스트하여 정상적으로 종료</target>
        </trans-unit>
        <trans-unit id="37401107a71883efc56c3d07974d72873ad8f857" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas.</source>
          <target state="translated">모든 복제본에 permdown을 브로드 캐스트하여 정상적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="96c55d61787ebd67d87c36f604142bfa3949dd6e" translate="yes" xml:space="preserve">
          <source>Great, so we have this &lt;code&gt;template_not_found/2&lt;/code&gt; function that takes a template and an &lt;code&gt;assigns&lt;/code&gt; map, which we ignore. The &lt;code&gt;template_not_found/2&lt;/code&gt; is invoked whenever a Phoenix.View attempts to render a template but no template is found.</source>
          <target state="translated">좋습니다. 우리 는 템플릿과 &lt;code&gt;assigns&lt;/code&gt; 맵을받는 이 &lt;code&gt;template_not_found/2&lt;/code&gt; 함수를 가지고 있습니다. 우리는 이것을 무시합니다. &lt;code&gt;template_not_found/2&lt;/code&gt; Phoenix.View 시도 템플릿을 렌더링 할 때마다 호출하지만 템플릿을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b2bb758deee9a18063c4c798fcdec3e64196126" translate="yes" xml:space="preserve">
          <source>Groups are also supported:</source>
          <target state="translated">그룹도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d16fde456fa6a9274b8f28cf87784f0670263c64" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &quot;groups&quot; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">주어진 필드에 동일한 값을 가진 스키마의 행을 그룹화합니다. 사용 &lt;code&gt;group_by&lt;/code&gt; 쿼리가 그것에게 다른 의미를 부여 &quot;그룹&quot;을 &lt;code&gt;select&lt;/code&gt; 표현식입니다. 쿼리가 그룹화되면 &lt;code&gt;group_by&lt;/code&gt; 에서 참조 된 필드 만 &lt;code&gt;select&lt;/code&gt; 에서 또는 필드가 집계 함수에 대한 인수로 제공되는 경우 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="573359f98da0f46d93ce375944dfc230b3eb131f" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &amp;ldquo;groups&amp;rdquo; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">주어진 필드에서 동일한 값을 가진 스키마의 행을 그룹화합니다. &lt;code&gt;group_by&lt;/code&gt; 를 사용 하여 쿼리를&amp;ldquo;그룹화&amp;rdquo;하면 &lt;code&gt;select&lt;/code&gt; 표현식 에 다른 의미를 부여합니다 . 쿼리가 그룹화되어 있으면에서 참조 된 필드 만 &lt;code&gt;group_by&lt;/code&gt; 에서 사용할 수있는 &lt;code&gt;select&lt;/code&gt; 하거나 필드가 집계 함수에 인수로 주어진다면.</target>
        </trans-unit>
        <trans-unit id="0d28e5466fe7edf9be0a19b777c6efbf4fc0f1b9" translate="yes" xml:space="preserve">
          <source>Groxio LiveView: Self Study Program (by Bruce Tate - 2020)</source>
          <target state="translated">Groxio LiveView :자가 학습 프로그램 (작성자 : Bruce Tate-2020)</target>
        </trans-unit>
        <trans-unit id="9de813d4a22ea43705b2409ca317c4ad7be16554" translate="yes" xml:space="preserve">
          <source>Guaranteed to be safe</source>
          <target state="translated">안전 보장</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="d7240b32bd4fb13ad180c29bf544480d25f32149" translate="yes" xml:space="preserve">
          <source>Guides - in-depth guides covering the main components in Phoenix and Phoenix applications</source>
          <target state="translated">가이드-Phoenix 및 Phoenix 애플리케이션의 주요 구성 요소를 다루는 심층 가이드</target>
        </trans-unit>
        <trans-unit id="43ec996853ae990b117722b3dedca88ce5b8b0cb" translate="yes" xml:space="preserve">
          <source>HTML Safe</source>
          <target state="translated">HTML 안전</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HSTS (HTTP Strict Transport Security)</target>
        </trans-unit>
        <trans-unit id="c41e81014d243f2d8875ff68c15a184a372a6901" translate="yes" xml:space="preserve">
          <source>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the &lt;code&gt;content-length&lt;/code&gt; header has been set before calling &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2는 청킹을 지원하지 않으며 대신 전송 인코딩없이 응답을 스트리밍합니다. HTTP / 1.1을 사용할 때 카우보이 어댑터는 &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;content-length&lt;/code&gt; 헤더가 설정된 경우 청크를 방출하는 대신 응답을 스트리밍합니다 .</target>
        </trans-unit>
        <trans-unit id="f52698c28f0d2036450e02a85451ee4f5be02442" translate="yes" xml:space="preserve">
          <source>HTTPS</source>
          <target state="translated">HTTPS</target>
        </trans-unit>
        <trans-unit id="657152afda0bee08d931b261408d17d0b6e96e52" translate="yes" xml:space="preserve">
          <source>Halting a plug pipeline</source>
          <target state="translated">플러그 파이프 라인 정지</target>
        </trans-unit>
        <trans-unit id="1da643070952e956d86d49f8c58821c92fb71c6e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 관련&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9755cdf0347f99433eabcbc87b332485d5af95e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline.</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ccd69770e67bfc169e02509f802dfa9b974fafd" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 정지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; 관련&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb6de5553592ef40a29a33d8a4f534ccdca762c0" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline.</source>
          <target state="translated">추가 플러그 다운 스트림이 호출되지 않도록하여 플러그 파이프 라인을 정지시킵니다. 플러그 파이프 라인 중지에 대한 자세한 내용 은 &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1179f95ead9bf0b9717da1e2ecfd57e128a47608" translate="yes" xml:space="preserve">
          <source>Handle channel joins by &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; 채널 조인을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="c751925f47985ead2c5d331b34495a279ea3f7ba" translate="yes" xml:space="preserve">
          <source>Handle incoming &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">들어오는 &lt;code&gt;event&lt;/code&gt; 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="82f1e20c501a3974e2888a65dd307415f027f8bd" translate="yes" xml:space="preserve">
          <source>Handle regular Elixir process messages.</source>
          <target state="translated">정기적 인 Elixir 프로세스 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="34e4b67d91a6a5a47ead00c473556ef12172e644" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer call messages.</source>
          <target state="translated">일반 GenServer 호출 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0bdffc90c861d354d82cfba6f42150171080724c" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer cast messages.</source>
          <target state="translated">일반 GenServer 캐스트 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f294e1b14ab763746b32a9cdc98d993760a810d1" translate="yes" xml:space="preserve">
          <source>Handles incoming control frames.</source>
          <target state="translated">들어오는 제어 프레임을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7d31dbed02487ad3b79dcccdca1c4517c3e304c7" translate="yes" xml:space="preserve">
          <source>Handles incoming socket messages.</source>
          <target state="translated">들어오는 소켓 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0ad1d4d7277dfbcb95f451d9d6d7bfc9124cb930" translate="yes" xml:space="preserve">
          <source>Handles info messages.</source>
          <target state="translated">정보 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5af19f504ed390f3616fe54d71be3c982a36fb0f" translate="yes" xml:space="preserve">
          <source>Handles the socket connection</source>
          <target state="translated">소켓 연결 처리</target>
        </trans-unit>
        <trans-unit id="5b3b8d6bf0e0ed4f6147a59b927ffe862e49bdc4" translate="yes" xml:space="preserve">
          <source>Handles the socket connection.</source>
          <target state="translated">소켓 연결을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="58514a1474cd3c04b6d7d45448e942f451571bf2" translate="yes" xml:space="preserve">
          <source>Handling of incoming messages</source>
          <target state="translated">수신 메시지 처리</target>
        </trans-unit>
        <trans-unit id="2b9f4508a5e4fc2c2b5ef7294940c248c8c75fd4" translate="yes" xml:space="preserve">
          <source>Handling of outgoing messages</source>
          <target state="translated">발신 메시지 처리</target>
        </trans-unit>
        <trans-unit id="5827156e9f14bdd8a3697b80209b3e3c181665d5" translate="yes" xml:space="preserve">
          <source>Handling of user interaction and inputs, buttons, and forms - such as input validation, dynamic forms, autocomplete, etc;</source>
          <target state="translated">입력 유효성 검사, 동적 양식, 자동 완성 등과 같은 사용자 상호 작용 및 입력, 버튼 및 양식 처리</target>
        </trans-unit>
        <trans-unit id="791b3d718f251049300fc903f9b075211bce25f5" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;../plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">처리 요청 데이터는 &lt;a href=&quot;../plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 플러그를 통해 수행 할 수 있습니다 . URL로 인코딩 된, 양식 데이터 및 JSON 데이터를 구문 분석하고 다른 구문 분석기가 채택 할 수있는 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5824e50c0788d6515b063060ac394cb11876c16" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">처리 요청 데이터는 &lt;a href=&quot;plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 플러그를 통해 수행 할 수 있습니다 . URL로 인코딩 된, 양식 데이터 및 JSON 데이터를 구문 분석하고 다른 구문 분석기가 채택 할 수있는 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c698c3591147b68316110c515f5214cf7d5b3183" translate="yes" xml:space="preserve">
          <source>Having different precisions allows developers to choose a type that will be compatible with the database and your project's precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">다른 정밀도를 사용하면 개발자가 데이터베이스 및 프로젝트의 정밀도 요구 사항과 호환되는 유형을 선택할 수 있습니다. 예를 들어, 일부 이전 버전의 MySQL은 datetime 필드에서 마이크로 초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87609125a9917f1d1304583fa33c13ec60b69a2f" translate="yes" xml:space="preserve">
          <source>Having these different types allows developers to choose a type that will be compatible with the database and your project&amp;rsquo;s precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">이러한 다른 유형을 사용하면 개발자는 데이터베이스 및 프로젝트의 정밀 요구 사항과 호환되는 유형을 선택할 수 있습니다. 예를 들어, 일부 이전 버전의 MySQL은 날짜 시간 필드에서 마이크로 초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="2a35b8be1233091ad5332bbf56f5dc2f7b98ac70" translate="yes" xml:space="preserve">
          <source>Helpers are automatically generated based on the controller name. For example, the route:</source>
          <target state="translated">헬퍼는 컨트롤러 이름에 따라 자동으로 생성됩니다. 예를 들어 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea3deafd82332a10202987c8c0e45b4f54638c37" translate="yes" xml:space="preserve">
          <source>Helpers for working with HTML strings and templates.</source>
          <target state="translated">HTML 문자열 및 템플릿 작업을위한 도우미입니다.</target>
        </trans-unit>
        <trans-unit id="42e29e501e0e0abe2c6edb0ec3f800ed7c669e6a" translate="yes" xml:space="preserve">
          <source>Helpers related to formatting text.</source>
          <target state="translated">텍스트 서식과 관련된 도우미.</target>
        </trans-unit>
        <trans-unit id="0d4c3aa7d2de3e04c2fa70e9a23a0cc750641d4a" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML forms.</source>
          <target state="translated">HTML 양식 생성과 관련된 도우미</target>
        </trans-unit>
        <trans-unit id="8d3f6ca83c967080b0bd89bc34ea0c0450fad6f1" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML tags within templates.</source>
          <target state="translated">템플릿 내에서 HTML 태그 생성과 관련된 도우미.</target>
        </trans-unit>
        <trans-unit id="1ae61dee0e45488052c0b40f12b8925406d54456" translate="yes" xml:space="preserve">
          <source>Here is a quick introduction into Phoenix templates terms:</source>
          <target state="translated">다음은 Phoenix 템플릿 용어에 대한 간략한 소개입니다.</target>
        </trans-unit>
        <trans-unit id="c1764c5d537b9f3a319ae1d976d0b1ca9635f544" translate="yes" xml:space="preserve">
          <source>Here is a simple echo socket implementation:</source>
          <target state="translated">다음은 간단한 에코 소켓 구현입니다.</target>
        </trans-unit>
        <trans-unit id="9a0608a11c75facb6614fa80af338062303f83e9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">다음은 POST 요청의 JSON 인코딩 본문을 구문 분석하기 위해 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; 라우터 에서 사용할 수있는 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="9cdd2430bc9221c06b037fdb8209b829394de4f3" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;plug.router#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">다음의 예 &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; 는&lt;/a&gt; (A)에 사용될 수 &lt;a href=&quot;plug.router#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; 의&lt;/a&gt; POST 요청의 JSON 인코딩 체를 파싱 라우터 :</target>
        </trans-unit>
        <trans-unit id="4bb01d7dff1af36b16e25ff091cce99986ce848e" translate="yes" xml:space="preserve">
          <source>Here is an example of a Telemetry event executed by Ecto when an Ecto repository starts:</source>
          <target state="translated">다음은 Ecto 저장소가 시작될 때 Ecto가 실행하는 Telemetry 이벤트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f1d2656a4085eae8f685d5ef408efb43bf4ea75b" translate="yes" xml:space="preserve">
          <source>Here is an example of a simple GenServer that emits telemetry events. Create this file in your app at &lt;code&gt;lib/my_app/my_server.ex&lt;/code&gt;:</source>
          <target state="translated">다음은 원격 측정 이벤트를 생성하는 간단한 GenServer의 예입니다. 앱의 &lt;code&gt;lib/my_app/my_server.ex&lt;/code&gt; 에서이 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7f637f171cd30b36c18ce6cc1ef0b78a381b7d5b" translate="yes" xml:space="preserve">
          <source>Here is an example of an event from your endpoint:</source>
          <target state="translated">다음은 엔드 포인트의 이벤트 예입니다.</target>
        </trans-unit>
        <trans-unit id="cf8a0f224b439f3a7c58360fbb55ef423905c7d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how both modules could be used in an application:</source>
          <target state="translated">다음은 응용 프로그램에서 두 모듈을 모두 사용하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="514a051b8ea91a8358dacf4b2fa3b9efa3ab46e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a function plug:</source>
          <target state="translated">다음은 함수 플러그의 예입니다.</target>
        </trans-unit>
        <trans-unit id="afa6cca227f184cb839f4bb2a488e237e45cbd46" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a module plug:</source>
          <target state="translated">다음은 모듈 플러그의 예입니다.</target>
        </trans-unit>
        <trans-unit id="294bc9dc3de330e00af0c679783e2c3ab4b482ed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">다음 은 한 클라이언트에서 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 이벤트를 수신 하여이 소켓의 모든 주제 구독자에게 메시지를 브로드 캐스트하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2010f6be3cd1e0728d571d7959a93b42f107f411" translate="yes" xml:space="preserve">
          <source>Here's an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">다음 은 한 클라이언트로부터 수신 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 이벤트를 수신 하고이 소켓의 모든 토픽 구독자에게 메시지를 브로드 캐스팅 하는 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="fc198632123680a802368b24b34a90c40b9cc3b8" translate="yes" xml:space="preserve">
          <source>Here's another example with two scopes that have different pipelines:</source>
          <target state="translated">다음은 파이프 라인이 서로 다른 두 범위가있는 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="293f9c83de18b696d985a3e2757964adfcf31355" translate="yes" xml:space="preserve">
          <source>Here's another look at the router from a newly generated Phoenix application, this time with the api scope uncommented back in and a route added.</source>
          <target state="translated">다음은 새로 생성 된 Phoenix 애플리케이션의 라우터에 대한 또 다른 모습입니다. 이번에는 api 범위가 다시 주석 처리되지 않고 경로가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a396acbc7494836afa8330130078d54d9f2ca540" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;User&lt;/code&gt; schema that Phoenix generated for us.</source>
          <target state="translated">다음 은 Phoenix가 우리를 위해 생성 한 &lt;code&gt;User&lt;/code&gt; 스키마입니다.</target>
        </trans-unit>
        <trans-unit id="3e18ca3472a7c2b730d0f1353c2a5e4284080d21" translate="yes" xml:space="preserve">
          <source>Here's the command to install Hex (If you have Hex already installed, it will upgrade Hex to the latest version):</source>
          <target state="translated">다음은 Hex를 설치하는 명령입니다 (Hex가 이미 설치되어있는 경우 Hex를 최신 버전으로 업그레이드합니다).</target>
        </trans-unit>
        <trans-unit id="292aca9f06e84483c4664a721bd0d8e611812da1" translate="yes" xml:space="preserve">
          <source>Here's what &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt; tells us:</source>
          <target state="translated">&lt;a href=&quot;mix.tasks.phx.routes&quot;&gt; &lt;code&gt;mix phx.routes&lt;/code&gt; 가&lt;/a&gt; 알려주는 내용은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="433ad4cccaa6f7157e6164318c9efb4b55c0cd17" translate="yes" xml:space="preserve">
          <source>Here's what it looks like in action.</source>
          <target state="translated">다음은 실제 작동 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f0b2af54aadfd78a646e888ac25a3cea0e36a97c" translate="yes" xml:space="preserve">
          <source>Here's what the &lt;code&gt;schema_migrations&lt;/code&gt; table looks like.</source>
          <target state="translated">여기에 무엇 &lt;code&gt;schema_migrations&lt;/code&gt; 의 테이블 모습이 좋아.</target>
        </trans-unit>
        <trans-unit id="172de218d867931358663fe72b49811c80d28ce7" translate="yes" xml:space="preserve">
          <source>Here, a request to &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; will be forwarded to the &lt;code&gt;FooPlug&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; will be set to &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; 에 대한 요청 은 &lt;code&gt;FooPlug&lt;/code&gt; 플러그 로 전달되며, FooPlug 플러그는 &lt;code&gt;/&lt;/code&gt; 에 대한 요청으로 표시되는 것을 수신 하고 &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; 는 &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="47a188e1572f453ec9eb4d25af8bec31919581b6" translate="yes" xml:space="preserve">
          <source>Here, we have our &lt;code&gt;show/2&lt;/code&gt; and &lt;code&gt;index/2&lt;/code&gt; actions returning static page data. Instead of passing in &lt;code&gt;&quot;show.html&quot;&lt;/code&gt; to &lt;code&gt;render/3&lt;/code&gt; as the template name, we pass &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;. This way, we can have views that are responsible for rendering HTML as well as JSON by pattern matching on different file types.</source>
          <target state="translated">여기에는 정적 페이지 데이터를 반환하는 &lt;code&gt;show/2&lt;/code&gt; 및 &lt;code&gt;index/2&lt;/code&gt; 작업이 있습니다. 템플릿 이름으로 &lt;code&gt;render/3&lt;/code&gt; 에 &lt;code&gt;&quot;show.html&quot;&lt;/code&gt; 을 전달하는 대신 &lt;code&gt;&quot;show.json&quot;&lt;/code&gt; 을 전달 합니다. 이렇게하면 서로 다른 파일 형식에 대한 패턴 일치를 통해 JSON뿐만 아니라 HTML을 렌더링하는 뷰를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04c8c2a15da73762b448647b48304e5984318bb6" translate="yes" xml:space="preserve">
          <source>Here, we start by using the familiar &lt;a href=&quot;../phoenix/phoenix.conntest&quot;&gt;&lt;code&gt;Phoenix.ConnTest&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;get/2&lt;/code&gt; to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, &lt;a href=&quot;#live/1&quot;&gt;&lt;code&gt;live/1&lt;/code&gt;&lt;/a&gt; is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</source>
          <target state="translated">여기서는 익숙한 &lt;a href=&quot;../phoenix/phoenix.conntest&quot;&gt; &lt;code&gt;Phoenix.ConnTest&lt;/code&gt; &lt;/a&gt; 함수 인 &lt;code&gt;get/2&lt;/code&gt; 를 사용하여 연결이 끊긴 소켓으로 마운트를 호출하는 일반 HTTP GET 요청을 테스트합니다. 다음으로, 연결된 상태에서 뷰를 마운트하기 위해 전송 된 연결로 &lt;a href=&quot;#live/1&quot;&gt; &lt;code&gt;live/1&lt;/code&gt; &lt;/a&gt; 이 호출되어 상태 저장 LiveView 프로세스가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e78f354796364ef7c67c1020994e22a118885793" translate="yes" xml:space="preserve">
          <source>Hibernation</source>
          <target state="translated">Hibernation</target>
        </trans-unit>
        <trans-unit id="5b3268c27e7d59601c440ed37c24688618bcf6ca" translate="yes" xml:space="preserve">
          <source>Hidden fields</source>
          <target state="translated">숨겨진 필드</target>
        </trans-unit>
        <trans-unit id="5d18d2a7d4a536a77cc5f61568a124ea48c4b54e" translate="yes" xml:space="preserve">
          <source>Higher level usage of Basic HTTP auth.</source>
          <target state="translated">기본 HTTP 인증의 상위 수준 사용.</target>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="82b440b8be7666b0f091da72ba57b990af92adad" translate="yes" xml:space="preserve">
          <source>Hitting &lt;code&gt;/hello/Frank&lt;/code&gt; now renders the HTML string we defined in the &lt;code&gt;show&lt;/code&gt; action. Note that what we wrote in the action is not an &lt;code&gt;eex&lt;/code&gt; template. It's a multi-line string, so we interpolate the &lt;code&gt;messenger&lt;/code&gt; variable like this &lt;code&gt;#{Plug.HTML.html_escape(messenger)}&lt;/code&gt;, instead of this &lt;code&gt;&amp;lt;%= messenger %&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">타격은 &lt;code&gt;/hello/Frank&lt;/code&gt; 지금 우리는 정의 된 HTML 문자열 렌더링 &lt;code&gt;show&lt;/code&gt; 조치를. 액션에서 작성한 내용은 &lt;code&gt;eex&lt;/code&gt; 템플릿 이 아닙니다 . 여러 줄로 된 문자열 &lt;code&gt;#{Plug.HTML.html_escape(messenger)}&lt;/code&gt; &lt;code&gt;&amp;lt;%= messenger %&amp;gt;&lt;/code&gt; 대신 # {Plug.HTML.html_escape (messenger)} 와 같은 &lt;code&gt;messenger&lt;/code&gt; 변수를 보간합니다 .</target>
        </trans-unit>
        <trans-unit id="18c930f4814c253272b3742e31b9b46cf3f29406" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you some inspiration on how to use the &lt;code&gt;:tag_values&lt;/code&gt; option. Just remember to keep this function fast since it is called on every event.</source>
          <target state="translated">바라건대, 이것은 &lt;code&gt;:tag_values&lt;/code&gt; 옵션 을 사용하는 방법에 대한 영감을 줄 것입니다. 이 함수는 모든 이벤트에서 호출되므로 빠르게 유지하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7da670a6c868ee6474dd213010439fdc6c17c884" translate="yes" xml:space="preserve">
          <source>How to read this guide: Using the context generators is a great way for beginners and intermediate Elixir programmers alike to get up and running quickly while thoughtfully designing their applications. This guide focuses on those readers. On the other hand, experienced developers may get more mileage from nuanced discussions around application design. For those readers, we include a frequently asked questions (FAQ) section at the end of the guide which brings different perspectives to some design decisions made throughout the guide. Beginners can safely skip the FAQ sections and return later when they're ready to dig deeper.</source>
          <target state="translated">이 가이드를 읽는 방법 : 컨텍스트 생성기를 사용하는 것은 초보자와 중급 Elixir 프로그래머 모두가 응용 프로그램을 신중하게 설계하면서 빠르게 시작하고 실행할 수있는 좋은 방법입니다. 이 가이드는 이러한 독자에 초점을 맞 춥니 다. 반면에 숙련 된 개발자는 애플리케이션 디자인에 대한 미묘한 논의를 통해 더 많은 마일리지를 얻을 수 있습니다. 이러한 독자를 위해 가이드 끝 부분에 자주 묻는 질문 (FAQ) 섹션을 포함하여 가이드 전체에서 내린 일부 디자인 결정에 대해 다른 관점을 제공합니다. 초보자는 안전하게 FAQ 섹션을 건너 뛰고 더 깊이 파고들 준비가되었을 때 나중에 돌아올 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c9bd403a4e9a302e8f2ed9f94925a54db8a68b9f" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won&amp;rsquo;t be set by Ecto:</source>
          <target state="translated">마이그레이션을 구성하는 방법은 &lt;code&gt;:join_through&lt;/code&gt; 에 전달하는 값에 따라 다릅니다 . 경우 &lt;code&gt;:join_through&lt;/code&gt; 테이블을 나타내는, 단순히 문자열, 당신은 기본 키가없는 테이블을 정의 할 수 있으며, 그 값이 체외로 설정되지 않습니다 당신은 더 열을 포함하지 않아야합니다 :</target>
        </trans-unit>
        <trans-unit id="e772dd16864f540c21adae4eff7d05aac5466700" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won't be set by Ecto:</source>
          <target state="translated">마이그레이션을 구성하는 방법은 전달하는 값에 따라 다릅니다 . &lt;code&gt;:join_through&lt;/code&gt; . 경우 &lt;code&gt;:join_through&lt;/code&gt; 테이블을 나타내는, 단순히 문자열, 당신은 기본 키가없는 테이블을 정의 할 수 있으며, 그 값이 체외로 설정되지 않습니다 당신은 더 열을 포함하지 않아야합니다 :</target>
        </trans-unit>
        <trans-unit id="758c04f8f966638d8323796933d71c2022e6d322" translate="yes" xml:space="preserve">
          <source>How-to's - a collection of articles on how to achieve certain things with Phoenix</source>
          <target state="translated">방법-Phoenix로 특정 작업을 수행하는 방법에 대한 기사 모음</target>
        </trans-unit>
        <trans-unit id="fde9c228238451fde38808e6b71a5f4e8db27470" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &quot;?vsn=&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 버전이 지정된 쿼리 문자열을 사용하여 직접 캐시 제어도 지원합니다. 요청 쿼리 문자열이 &quot;? vsn =&quot;로 시작하는 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 애플리케이션이 버전 관리 자산이라고 가정하고 &lt;code&gt;ETag&lt;/code&gt; 헤더를 설정하지 않습니다 . 즉, 캐시 동작은 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 구성에 의해서만 지정 되며 기본값은 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca34d2ca00362f79bd18266ad0ec21713be1edf" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &amp;ldquo;?vsn=&amp;rdquo;, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 버전이 지정된 쿼리 문자열을 사용하여 직접 캐시 제어를 지원합니다. 요청 쿼리 문자열이 &quot;? vsn =&quot;으로 시작하는 경우 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 응용 프로그램이 버전 자산이며 &lt;code&gt;ETag&lt;/code&gt; 헤더를 설정하지 않는다고 가정합니다 . 즉, 캐시 동작은 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 구성에 의해서만 지정 되며 기본값은 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3c783df751e11e9f0f2d6bc647f8e24682a2b66" translate="yes" xml:space="preserve">
          <source>However, any component can be made stateful by passing an &lt;code&gt;:id&lt;/code&gt; assign.</source>
          <target state="translated">그러나 &lt;code&gt;:id&lt;/code&gt; 할당 을 전달하여 모든 구성 요소를 상태 저장으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92b6ba6983e86cfb8b7f8a1c8aa387837993e78b" translate="yes" xml:space="preserve">
          <source>However, because constraints are only checked if all validations succeed, this function can be used as an early check to provide early feedback to users, since most conflicting data will have been inserted prior to the current validation phase.</source>
          <target state="translated">그러나 모든 유효성 검사가 성공한 경우에만 제약 조건을 검사하므로이 기능은 대부분의 충돌하는 데이터가 현재 유효성 검사 단계 이전에 삽입되었으므로 사용자에게 조기 피드백을 제공하기위한 조기 검사로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c576a7810279fa0ef0181e729be5d3e33896301c" translate="yes" xml:space="preserve">
          <source>However, because the rendering of live templates can be dynamic in itself, it is important to distinguish which &lt;code&gt;.leex&lt;/code&gt; template was rendered. For example, imagine this code:</source>
          <target state="translated">그러나 라이브 템플릿의 렌더링은 그 자체로 동적 일 수 있으므로 어떤 &lt;code&gt;.leex&lt;/code&gt; 템플릿이 렌더링 되었는지 구별하는 것이 중요합니다 . 예를 들어 다음 코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e8b56ea8eef111a454a3af358d1c8df493c3834e" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &quot;regular&quot; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">그러나 변경 집합은 데이터 및 해당 유형과 함께 튜플을 전달하여 &quot;일반&quot;구조체에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d4b9ddb4851e5cb9caec7c806e9ed043982b19" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &amp;ldquo;regular&amp;rdquo; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">그러나 변경 세트는 데이터 및 해당 유형과 함께 튜플을 전달하여 &quot;일반&quot;구조체와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c75a911a92357bb55a72a4f5cda6890aa2fa06e" translate="yes" xml:space="preserve">
          <source>However, developers can use the preload functionality in queries to automatically pre-populate the field:</source>
          <target state="translated">그러나 개발자는 쿼리에서 사전로드 기능을 사용하여 필드를 자동으로 미리 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e072c9f502e82c76107b9c680016ea26f2459bff" translate="yes" xml:space="preserve">
          <source>However, for convenience, this protocol can also be derivable. For example:</source>
          <target state="translated">그러나 편의상이 프로토콜을 파생 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2e281662c4868a83f42fe2d3a37e4b42a7ba94d" translate="yes" xml:space="preserve">
          <source>However, if the client had sent an expired or otherwise invalid token &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; would have returned an error instead:</source>
          <target state="translated">그러나 클라이언트가 만료되었거나 유효하지 않은 토큰을 보낸 경우 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 는 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efbb0f8348e6d519f60b96367c6b25b0ab58981a" translate="yes" xml:space="preserve">
          <source>However, if you are just getting started with Phoenix, we recommend you to install PostgreSQL and make sure it is running. The PostgreSQL wiki has &lt;a href=&quot;https://wiki.postgresql.org/wiki/Detailed_installation_guides&quot;&gt;installation guides&lt;/a&gt; for a number of different systems.</source>
          <target state="translated">그러나 Phoenix를 막 시작하는 경우 PostgreSQL을 설치하고 실행 중인지 확인하는 것이 좋습니다. PostgreSQL 위키에는 다양한 시스템에 대한 &lt;a href=&quot;https://wiki.postgresql.org/wiki/Detailed_installation_guides&quot;&gt;설치 가이드&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e4154438c600a0964d2ae325cad0bcb77711e5" translate="yes" xml:space="preserve">
          <source>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</source>
          <target state="translated">그러나 위의 구조체를 유지하려고 시도하면 Ecto가 유형을 어댑터 / 데이터베이스로 보낼 때 유형을 확인하므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6beb14dbb92a9c5566dff520724cf6035e375bf3" translate="yes" xml:space="preserve">
          <source>However, if you want all generated URLs to always have a certain schema, host, etc, you may use &lt;a href=&quot;#put_router_url/2&quot;&gt;&lt;code&gt;put_router_url/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 생성 된 모든 URL이 항상 특정 스키마, 호스트 등을 &lt;a href=&quot;#put_router_url/2&quot;&gt; &lt;code&gt;put_router_url/2&lt;/code&gt; &lt;/a&gt; 하려면 put_router_url / 2를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5f38c3f3c2dea225784564c84cad08b3961c4cb" translate="yes" xml:space="preserve">
          <source>However, if you're adding &lt;code&gt;phoenix_live_view&lt;/code&gt; to an umbrella project, the dependency paths should be modified appropriately:</source>
          <target state="translated">그러나 우산 프로젝트에 &lt;code&gt;phoenix_live_view&lt;/code&gt; 를 추가하는 경우 종속성 경로를 적절하게 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="92a0deea3d522aed6c2af612ee37d11179610223" translate="yes" xml:space="preserve">
          <source>However, if your &lt;code&gt;:join_through&lt;/code&gt; is a schema, like &lt;code&gt;MyApp.PostTag&lt;/code&gt;, your join table may be structured as any other table in your codebase, including timestamps:</source>
          <target state="translated">귀하의 경우, &lt;code&gt;:join_through&lt;/code&gt; 이 같은 스키마입니다 &lt;code&gt;MyApp.PostTag&lt;/code&gt; 가 , 당신의 가입 테이블은 타임 스탬프를 포함하여 코드베이스의 다른 테이블로 구성 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="61c4ba54704b1e88b02567334a74ea38f7fe843d" translate="yes" xml:space="preserve">
          <source>However, implementing the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol by hand can be convenient in certain occasions, such as when providing Actionable ERrors.</source>
          <target state="translated">그러나 수동으로 &lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현하는 것은 실행 가능한 ERror를 제공 할 때와 같은 특정 상황에서 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5054280086d854890f69bc24ac26fee32ed61037" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won&amp;rsquo;t be removed, leading to a query that won&amp;rsquo;t compile.</source>
          <target state="translated">그러나 조인이 제거되고 바인딩이 다른 곳에서 참조 된 경우 바인딩이 제거되지 않아 쿼리가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c145dbff75201402ee148458f35b3b4df8ec98" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won't be removed, leading to a query that won't compile.</source>
          <target state="translated">그러나 조인이 제거되고 해당 바인딩이 다른 곳에서 참조 된 경우 바인딩이 제거되지 않아 쿼리가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="418e05e8a16e7c15648cf7bdddb205991c4f4a14" translate="yes" xml:space="preserve">
          <source>However, most commonly, structs are cast, validated and manipulated with the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">그러나 가장 일반적으로 구조체는 &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 캐스팅, 유효성 검사 및 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4a5fc9cf571b09944b8a527ce63cf79c0416fc0" translate="yes" xml:space="preserve">
          <source>However, note that components do not have a &lt;code&gt;handle_info/2&lt;/code&gt; callback. Therefore, if you want to track distributed changes on a card, you must have the parent LiveView receive those events and redirect them to the appropriate card. For example, assuming card updates are sent to the &quot;board:ID&quot; topic, and that the board LiveView is subscribed to said topic, one could do:</source>
          <target state="translated">그러나 구성 요소에는 &lt;code&gt;handle_info/2&lt;/code&gt; 콜백 이 없습니다 . 따라서 카드에서 분산 된 변경 사항을 추적하려면 상위 LiveView가 해당 이벤트를 수신하고 적절한 카드로 리디렉션하도록해야합니다. 예를 들어 카드 업데이트가 &quot;board : ID&quot;토픽으로 전송되고 보드 LiveView가 해당 토픽을 구독한다고 가정하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c15cb8377f6937f642e813f984385d51f7b4176e" translate="yes" xml:space="preserve">
          <source>However, note that defining a window is not necessary, as the window definition can be given as the second argument to &lt;code&gt;over&lt;/code&gt;:</source>
          <target state="translated">그러나 window 정의는 &lt;code&gt;over&lt;/code&gt; 에 대한 두 번째 인수로 제공 될 수 있으므로 window 정의는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="089510bf5810bca9d96388384533d0538018252e" translate="yes" xml:space="preserve">
          <source>However, once the repository is started, you can't directly interact with it, since all operations in &lt;code&gt;MyApp.Repo&lt;/code&gt; are sent by default to the repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;. You can change the default repo at compile time with:</source>
          <target state="translated">그러나 일단 저장소가 시작되면 &lt;code&gt;MyApp.Repo&lt;/code&gt; 의 모든 작업 이 기본적으로 &lt;code&gt;MyApp.Repo&lt;/code&gt; 라는 저장소로 전송되므로 저장소 와 직접 상호 작용할 수 없습니다 . 컴파일 시간에 다음을 사용하여 기본 저장소를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fcb1b6a8bd9d33f8942cfd45c40fa04ca503d0c" translate="yes" xml:space="preserve">
          <source>However, one may argue that, if the last member of an organization cannot leave it, it may be better to not even show the &quot;Leave&quot; button in the UI when the organization has only one member.</source>
          <target state="translated">그러나 조직의 마지막 구성원이 탈퇴 할 수없는 경우 조직에 구성원이 한 명 뿐인 경우 UI에 &quot;탈퇴&quot;버튼을 표시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c85984fa1288966d45078f191d19bcd6b0fa6962" translate="yes" xml:space="preserve">
          <source>However, parameterized types are also more complex. Therefore, if everything you need to achieve can be done with basic types, they should be preferred to parameterized ones.</source>
          <target state="translated">그러나 매개 변수화 된 유형도 더 복잡합니다. 따라서 달성해야하는 모든 것을 기본 유형으로 수행 할 수 있다면 매개 변수화 된 유형보다 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="80b14f53aaf9b70f512fe7b2db28dcdb79978b4a" translate="yes" xml:space="preserve">
          <source>However, the issue with said approach is that, if you are rendering multiple user components in the same page, you have a N+1 query problem. The &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; callback helps address this problem as it is invoked with a list of assigns for all components of the same type. For example, instead of implementing &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; as above, one could implement:</source>
          <target state="translated">그러나 앞서 언급 한 접근 방식의 문제는 동일한 페이지에서 여러 사용자 구성 요소를 렌더링하는 경우 N + 1 쿼리 문제가 있다는 것입니다. &lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt; 콜백이 동일한 유형의 모든 구성 요소에 대한 양수인의 목록이 호출로이 문제를 해결하는 데 도움이됩니다. 예를 들어, 위와 같이 &lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt; 를 구현하는 대신 다음을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94de3aba560958a631f7ce9430b591344ccd7fee" translate="yes" xml:space="preserve">
          <source>However, we don't advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="translated">그러나 다른 엔드 포인트로 전달하는 것은 권장하지 않습니다. 그 이유는 앱과 전달 된 엔드 포인트에서 정의한 플러그가 두 번 호출되어 오류가 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7cabde0cd7b6db0d68f058c5459d05317cac58e4" translate="yes" xml:space="preserve">
          <source>However, what will happen with a LiveView in case of exceptions? Let's talk about unexpected scenarios.</source>
          <target state="translated">그러나 예외의 경우 LiveView는 어떻게됩니까? 예상치 못한 시나리오에 대해 이야기합시다.</target>
        </trans-unit>
        <trans-unit id="5fc8ebeaefd55fb22bf6d7071b4fcd39b701a518" translate="yes" xml:space="preserve">
          <source>However, when rendering components on the client, the client needs to choose the mime type of the component contents, which defaults to HTML. This is the best default but in some cases it may lead to unexpected results.</source>
          <target state="translated">그러나 클라이언트에서 구성 요소를 렌더링 할 때 클라이언트는 구성 요소 콘텐츠의 MIME 유형을 선택해야하며 기본값은 HTML입니다. 이것이 최선의 기본값이지만 경우에 따라 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9669e5305e15cb7f2d41b7ba261dd4a25e92989e" translate="yes" xml:space="preserve">
          <source>However, when rendering these metrics in LiveDashboard, the value label is output as &lt;code&gt;&quot;Elixir.Phoenix.LiveDashboard.MetricsLive true&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 LiveDashboard에서 이러한 메트릭을 렌더링 할 때 값 레이블은 &lt;code&gt;&quot;Elixir.Phoenix.LiveDashboard.MetricsLive true&quot;&lt;/code&gt; 로 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="404d7e0f0a82ca0536563d8523263ae188890052" translate="yes" xml:space="preserve">
          <source>Identifies the Phoenix.Socket for a LiveView client.</source>
          <target state="translated">LiveView 클라이언트에 대한 Phoenix.Socket을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="69818f21f7d2e8e3d4c95d045561623815bfdb97" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection</source>
          <target state="translated">소켓 연결을 식별합니다</target>
        </trans-unit>
        <trans-unit id="a1248f63e6d463c737ae4f281ae99a7acd6c280d" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection.</source>
          <target state="translated">소켓 연결을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c2b9e9831550c1277fc0f8c66e430ed4b934322f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:transaction/2&quot;&gt;&lt;code&gt;transaction/2&lt;/code&gt;&lt;/a&gt; is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:transaction/2&quot;&gt; &lt;code&gt;transaction/2&lt;/code&gt; &lt;/a&gt; 다른 트랜잭션 내에서 호출되는 함수는 단순히 어떤 방식으로 새로운 트랜잭션 호출을 포장하지 않고 실행됩니다. 내부 트랜잭션에 오류가 있고 오류가 복구되거나 내부 트랜잭션이 롤백되면 전체 외부 트랜잭션이 오염 된 것으로 표시되어 커밋 된 것이 없음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="48bb3facdf6a618d730a68a131d48750e21adc3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:init_opts&lt;/code&gt; is undefined, then all remaining options are passed to the target plug.</source>
          <target state="translated">&lt;code&gt;:init_opts&lt;/code&gt; 가 정의되지 않은 경우 나머지 모든 옵션이 대상 플러그로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b518d769ddb0e8a385ef70577decbd4185956c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:select_merge&lt;/code&gt; is called and there is no value selected previously, it will default to the source, &lt;code&gt;p&lt;/code&gt; in the example above.</source>
          <target state="translated">경우 &lt;code&gt;:select_merge&lt;/code&gt; 가 전화해서 이전에 선택한 값이없는, 그것은 소스로 기본 설정됩니다 &lt;code&gt;p&lt;/code&gt; 위의 예이다.</target>
        </trans-unit>
        <trans-unit id="39bb4cb75be5b52a2198bb0576f54f0e0ede32c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won&amp;rsquo;t specify a charset.</source>
          <target state="translated">경우 &lt;code&gt;charset&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,의 값 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 응답 헤더는 문자 집합을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0675b7cae7347e027b29d7d61cb63f9f1413731c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won't specify a charset.</source>
          <target state="translated">경우 &lt;code&gt;charset&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,의 값 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 응답 헤더는 문자 집합을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c771220878c1cca3211d6dc54b16db5f2b01acdb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; fails and returns &lt;code&gt;false&lt;/code&gt;, an exception is raised. It is common for Elixir developers to use exceptions for unexpected scenarios in their Phoenix applications.</source>
          <target state="translated">경우 &lt;code&gt;leave&lt;/code&gt; 실패하고 돌아 &lt;code&gt;false&lt;/code&gt; , 예외가 발생합니다. Elixir 개발자는 Phoenix 애플리케이션에서 예상치 못한 시나리오에 예외를 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="5b63bc1203c3dac71786c2dfe06d19a828803701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; returns false by any chance, it will just raise. Or you can even provide a &lt;code&gt;leave!&lt;/code&gt; function that raises a specific exception:</source>
          <target state="translated">만일 &lt;code&gt;leave&lt;/code&gt; 가 거짓을 반환하면 그냥 인상됩니다. 또는 &lt;code&gt;leave!&lt;/code&gt; 제공 할 수도 있습니다 ! 특정 예외를 발생시키는 함수 :</target>
        </trans-unit>
        <trans-unit id="a05c265ccb7acfd4d24ba0e20a24a92a6ce9889f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;limit&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">경우 &lt;code&gt;limit&lt;/code&gt; 두 번 주어, 그것은 이전의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e957bc885302ec7685e98cd24a82719aa373a888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is used more than once, the last one used takes precedence.</source>
          <target state="translated">경우 &lt;code&gt;lock&lt;/code&gt; 두 번 이상 사용되며, 마지막으로 사용한 사람은 우선합니다.</target>
        </trans-unit>
        <trans-unit id="90da74aa2f941149e52e2553f73747df1e9ff078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nil&lt;/code&gt; is given as id, a new session id should be generated and returned.</source>
          <target state="translated">경우 &lt;code&gt;nil&lt;/code&gt; ID로 주어진 새로운 세션 ID를 생성하여 반환한다.</target>
        </trans-unit>
        <trans-unit id="7d493634e419d6aa39da5fc4a5f636e40e36f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;offset&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">경우 &lt;code&gt;offset&lt;/code&gt; 두 번 주어, 그것은 이전의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="972e323b8fae502f4935411636b7be015afc29ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is map or keyword list where the first element is a string, atom or integer and the second element is a list or a map, it is assumed the key will be wrapped in an &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; and the value will be used to generate &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; nested under the group.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 첫 번째 요소는 문자열 원자 또는 정수 번째 요소 맵 또는 키워드 목록은 목록 또는 맵이다이를 키 래핑한다 상정되는 &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; 상기 값 생성하는데 사용될 &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; 은 그룹 아래에 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="a3421dda344b70b936418fb88ce89a791460b02d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_action&lt;/code&gt; is a string, it is considered to be the request path and stored as so in the connection. If an atom, it is assumed to be an action and the connection is dispatched to the given action.</source>
          <target state="translated">경우 &lt;code&gt;path_or_action&lt;/code&gt; 은 문자열입니다, 요청 경로로 간주하고 연결에 있도록 저장됩니다. 원자 인 경우, 조치 인 것으로 가정하고 연결이 지정된 조치로 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="b9c8f702bb6c0810a48712a7631f4ec240983313" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is &lt;code&gt;:closed&lt;/code&gt;, it means the client closed the socket. This is considered a &lt;code&gt;:normal&lt;/code&gt; exit signal, so linked process will not automatically exit. See &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt;&lt;code&gt;Process.exit/2&lt;/code&gt;&lt;/a&gt; for more details on exit signals.</source>
          <target state="translated">경우에는 &lt;code&gt;reason&lt;/code&gt; 있다 &lt;code&gt;:closed&lt;/code&gt; , 그것은 클라이언트가 소켓을 닫을 것을 의미한다. 이것은 &lt;code&gt;:normal&lt;/code&gt; 종료 신호 로 간주 되므로 연결된 프로세스가 자동으로 종료되지 않습니다. 종료 신호에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt; &lt;code&gt;Process.exit/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11e582e3374d4e382af5d6f29d1086454023de04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the header is checked against &lt;code&gt;:host&lt;/code&gt; in &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt;. If &lt;code&gt;false&lt;/code&gt;, your app is vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. Only use in development, when the host is truly unknown or when serving clients that do not send the &lt;code&gt;origin&lt;/code&gt; header, such as mobile apps. You can also specify a list of explicitly allowed origins. Wildcards are supported.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 헤더에 대해 확인 &lt;code&gt;:host&lt;/code&gt; 에 &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt; . 경우 &lt;code&gt;false&lt;/code&gt; 앱은 크로스 사이트 웹 소켓 하이재킹 (CSWSH) 공격에 취약합니다. 호스트가 실제로 알려지지 않은 경우 또는 모바일 앱과 같이 &lt;code&gt;origin&lt;/code&gt; 헤더를 전송하지 않는 클라이언트를 제공 할 때만 개발에 사용 합니다. 명시 적으로 허용 된 출처 목록을 지정할 수도 있습니다. 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="abf67ea57ee4ce23434afd8c43be52701544068b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; is given, it means the query can be cached and it must be cached by calling the &lt;code&gt;cache_function&lt;/code&gt; function with the cache entry of your choice. Once &lt;code&gt;cache_function&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cached&lt;/code&gt; tuple.</source>
          <target state="translated">만약 &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; 주어집니다, 그것은 쿼리가 캐시 될 수 있음을 의미하고이 호출에 의해 캐시해야 &lt;code&gt;cache_function&lt;/code&gt; 의 선택의 캐시 항목과 기능을. &lt;code&gt;cache_function&lt;/code&gt; 이 호출 되면 다음에 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; 에&lt;/a&gt; 동일한 쿼리가 제공 될 때 &lt;code&gt;:cached&lt;/code&gt; 튜플을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="1309c121da20f5187a51a6961ffb575f0b7cff39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; is given, it means the query has been cached. You may call &lt;code&gt;update_function/1&lt;/code&gt; if you want to update the cached result. Or you may call &lt;code&gt;reset_function/1&lt;/code&gt;, with a new prepared query, to force the query to be cached again. If &lt;code&gt;reset_function/1&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cache&lt;/code&gt; tuple.</source>
          <target state="translated">경우 &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; 주어집니다, 그것은 쿼리 캐시되었음을 의미합니다. 캐시 된 결과를 업데이트하려면 &lt;code&gt;update_function/1&lt;/code&gt; 을 호출 할 수 있습니다. 또는 새로 준비된 쿼리와 함께 &lt;code&gt;reset_function/1&lt;/code&gt; 을 호출 하여 쿼리를 다시 캐시하도록 할 수 있습니다. 경우 &lt;code&gt;reset_function/1&lt;/code&gt; 라고하며, 다음 번에이 같은 쿼리를 위해 주어진다 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt; , 그것은받을 &lt;code&gt;:cache&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="e417833516d635fb72f5c63c1ffab31f552e12db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:nocache, prepared}&lt;/code&gt; is given, it means the query was not and cannot be cached. The &lt;code&gt;prepared&lt;/code&gt; value is the value returned by &lt;a href=&quot;#c:prepare/2&quot;&gt;&lt;code&gt;prepare/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{:nocache, prepared}&lt;/code&gt; 주어, 그것은 쿼리가 아니었고 캐시 할 수 없음을 의미합니다. &lt;code&gt;prepared&lt;/code&gt; 값에 의해 리턴 된 값 &lt;a href=&quot;#c:prepare/2&quot;&gt; &lt;code&gt;prepare/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98796a5ac95043dc0bbdaf9869321de0caf5c9b9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">경우 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 의 환경 변수가 설정되어, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; 는&lt;/a&gt; 텍스트 편집기에 대한 링크를 생성하는 데 사용합니다. 변수는 올바르게 대체 될 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 자리 표시 자로 설정되어야합니다 . 예 ( &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; 편집기 사용) :</target>
        </trans-unit>
        <trans-unit id="3917143de35bdf1d2e86820a8a552e7dc5784eb2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">경우 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 의 환경 변수가 설정되어, &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; 는&lt;/a&gt; 텍스트 편집기에 대한 링크를 생성하는 데 사용합니다. 변수는 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 자리 표시 자로 설정해야 하며 올바르게 대체됩니다. 예를 들어 ( &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; 편집기 사용) :</target>
        </trans-unit>
        <trans-unit id="b8438373db0bb704311f615a6503d58ee84b3d61" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;path&lt;/code&gt; is given, then a regular &lt;code&gt;get(conn, path)&lt;/code&gt; is done and the page is upgraded to a &lt;code&gt;LiveView&lt;/code&gt;. If no path is given, it assumes a previously rendered &lt;code&gt;%Plug.Conn{}&lt;/code&gt; is given, which will be converted to a &lt;code&gt;LiveView&lt;/code&gt; immediately.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 지정되고있는 경우, 일반 &lt;code&gt;get(conn, path)&lt;/code&gt; 수행하고 페이지가 업그레이드되어 &lt;code&gt;LiveView&lt;/code&gt; . 경로가 지정되지 않은 경우 이전에 렌더링 된 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 이 제공된 것으로 간주하여 즉시 &lt;code&gt;LiveView&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f871e965d2407597bc5715cea4f0ab94f714d6e5" translate="yes" xml:space="preserve">
          <source>If a control frame doesn't have a payload, then the payload value will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">제어 프레임에 페이로드가없는 경우 페이로드 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb554a564dd3cf44251ab909d1682e6cddc415a6" translate="yes" xml:space="preserve">
          <source>If a cookie is invalid, it is automatically discarded from the result.</source>
          <target state="translated">쿠키가 유효하지 않으면 결과에서 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3710000536ae0ecb682a86fbf651cc12761ba83e" translate="yes" xml:space="preserve">
          <source>If a field is given to &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; but it has not been passed as parameter during &lt;a href=&quot;#cast/3&quot;&gt;&lt;code&gt;cast/3&lt;/code&gt;&lt;/a&gt; (i.e. it has not been changed), then &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; will check for its current value in the data. If the data contains an non-empty value for the field, then no error is added. This allows developers to use &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; to perform partial updates. For example, on &lt;code&gt;insert&lt;/code&gt; all fields would be required, because their default values on the data are all &lt;code&gt;nil&lt;/code&gt;, but on &lt;code&gt;update&lt;/code&gt;, if you don't want to change a field that has been previously set, you are not required to pass it as a paramater, since &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; won't add an error for missing changes as long as the value in the data given to the &lt;code&gt;changeset&lt;/code&gt; is not empty.</source>
          <target state="translated">필드가 &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; 에 제공&lt;/a&gt; 되었지만 &lt;a href=&quot;#cast/3&quot;&gt; &lt;code&gt;cast/3&lt;/code&gt; &lt;/a&gt; 중에 매개 변수로 전달되지 않은 경우 (즉, 변경되지 않은 경우) &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 는 데이터에서 현재 값을 확인합니다. 데이터에 비어 있지 않은 필드 값이 포함되어 있으면 오류가 추가되지 않습니다. 이를 통해 개발자는 &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 부분 업데이트를 수행 할 수 있습니다. 예를 들어, 데이터의 기본값이 모두 &lt;code&gt;nil&lt;/code&gt; 이기 때문에 &lt;code&gt;insert&lt;/code&gt; 모든 필드가 필요 하지만 &lt;code&gt;update&lt;/code&gt; 이전에 설정된 필드를 변경하지 않으려면 다음과 같이 전달할 필요가 없습니다. &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; 이후 매개 변수변경 세트에 제공된 데이터의 값 이 비어 있지 않은 한 &lt;code&gt;changeset&lt;/code&gt; 사항 누락에 대한 오류를 추가 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bd4733e62d747fd2dc1933eb4482e62fe11f653" translate="yes" xml:space="preserve">
          <source>If a field is unchanged and &lt;code&gt;.leex&lt;/code&gt; believes a dynamic expression no longer needs to be computed, its value in the &lt;code&gt;dynamic&lt;/code&gt; list will be &lt;code&gt;nil&lt;/code&gt;. This information can be leveraged to avoid sending data to the client.</source>
          <target state="translated">필드가 변경되지 않고 &lt;code&gt;.leex&lt;/code&gt; 가 동적 표현식을 더 이상 계산할 필요가 없다고 생각하는 경우 &lt;code&gt;dynamic&lt;/code&gt; 목록 의 값은 &lt;code&gt;nil&lt;/code&gt; 이 됩니다. 이 정보는 데이터를 클라이언트로 보내는 것을 방지하기 위해 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5748e7fd13f50e04ab4f92ee369e7bef4e0182" translate="yes" xml:space="preserve">
          <source>If a file is uploaded via any of the parsers, Plug will stream the uploaded contents to a file in a temporary directory in order to avoid loading the whole file into memory. For such, the &lt;code&gt;:plug&lt;/code&gt; application needs to be started in order for file uploads to work. More details on how the uploaded file is handled can be found in the documentation for &lt;a href=&quot;plug.upload&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파서를 사용하여 파일을 업로드하는 경우 Plug는 전체 파일을 메모리로로드하지 않도록 업로드 된 내용을 임시 디렉토리의 파일로 스트리밍합니다. 파일 업로드가 작동 하려면 &lt;code&gt;:plug&lt;/code&gt; 응용 프로그램을 시작해야합니다. 업로드 된 파일을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;plug.upload&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9a66f3d4a76267cf3daa797fca21dffb2926bba" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &quot;x-request-id&quot; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">요청 ID가 &quot;x-request-id&quot;HTTP 요청 헤더로 이미 존재하는 경우 해당 값은 20 자에서 200 자 사이라고 가정하여 사용됩니다. 그렇지 않은 경우 새 요청 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4d7c53872729839a77bd5a96d38cb274491289" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &amp;ldquo;x-request-id&amp;rdquo; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">요청 ID가 이미 &quot;x-request-id&quot;HTTP 요청 헤더로 존재하는 경우 해당 값은 20 자에서 200 자 사이 인 것으로 가정하여 사용됩니다. 그렇지 않은 경우 새 요청 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0a43716c3aaf07a4683f32a558be906bc63cdf44" translate="yes" xml:space="preserve">
          <source>If a source is given, without a schema module, the given fields are passed as is to the adapter.</source>
          <target state="translated">스키마 모듈없이 소스가 제공되면 제공된 필드는 그대로 어댑터에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e0fcc0fd0de1b3c59c0bc9f15d6ba587aeb25386" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">정적 자산을 찾을 수없는 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; 은 연결을 나머지 파이프 라인으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="43529dcc9122748af804be0c58edc57e0c307b24" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">정적 자산을 찾을 수없는 경우 &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; 은&lt;/a&gt; 단순히 연결을 나머지 파이프 라인으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5ad05d6344b5d56c40d9d05868bbe0fc447a1ebc" translate="yes" xml:space="preserve">
          <source>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; and wrapped in the &lt;a href=&quot;ecto.subquery&quot;&gt;&lt;code&gt;Ecto.SubQuery&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">하위 쿼리가 제공되면 하위 쿼리 자체를 반환합니다. 다른 값이 제공되면 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; 을&lt;/a&gt; 통해 쿼리로 변환되어 &lt;a href=&quot;ecto.subquery&quot;&gt; &lt;code&gt;Ecto.SubQuery&lt;/code&gt; &lt;/a&gt; 구조체에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="d48ba6ea6ec7ffa263a8d1a43b7dcdf2efa2753d" translate="yes" xml:space="preserve">
          <source>If a token exists, it is returned, otherwise it is generated and stored in the process dictionary.</source>
          <target state="translated">토큰이 존재하면 반환되고, 그렇지 않으면 생성되어 프로세스 사전에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9b893693b1726f40ddda25b9dd0c70ab3cfa2216" translate="yes" xml:space="preserve">
          <source>If a value is given more than once, the last value takes precedence:</source>
          <target state="translated">값이 두 번 이상 제공되면 마지막 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="c72db962fcdc4941c8aba4d0408a0a707016fe8b" translate="yes" xml:space="preserve">
          <source>If a view is provided, the entire LiveView is rendered. If an element is provided, only that element is rendered.</source>
          <target state="translated">뷰가 제공되면 전체 LiveView가 렌더링됩니다. 요소가 제공되면 해당 요소 만 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="eaddcc5aa1077f7a26eab071fe7684352cdb0d24" translate="yes" xml:space="preserve">
          <source>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling &lt;a href=&quot;#c:rollback/1&quot;&gt;&lt;code&gt;rollback/1&lt;/code&gt;&lt;/a&gt;, this will immediately leave the function and return the value given to &lt;code&gt;rollback&lt;/code&gt; as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">처리되지 않은 오류가 발생하면 트랜잭션이 롤백되고 트랜잭션 기능에서 오류가 발생합니다. 오류가 발생하지 않으면 함수가 리턴 될 때 트랜잭션이 커미트됩니다. &lt;a href=&quot;#c:rollback/1&quot;&gt; &lt;code&gt;rollback/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 트랜잭션을 명시 적으로 롤백 할 수 있습니다 .이 함수는 즉시 함수를 그대로두고 &lt;code&gt;rollback&lt;/code&gt; 제공된 값 을 &lt;code&gt;{:error, value}&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="153b8768ac116a6059a08945ee6b26d18eec128a" translate="yes" xml:space="preserve">
          <source>If any of the callbacks return a &lt;code&gt;:stop&lt;/code&gt; tuple, it will also trigger terminate with the reason given in the tuple.</source>
          <target state="translated">콜백 중 하나가 &lt;code&gt;:stop&lt;/code&gt; 튜플을 반환하면 튜플에 주어진 이유로 종료를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a8b20d463cde7b903560b17334ed7d36242c5f45" translate="yes" xml:space="preserve">
          <source>If available, the file is sent directly over the socket using the operating system &lt;code&gt;sendfile&lt;/code&gt; operation.</source>
          <target state="translated">사용 가능한 경우 운영 체제 &lt;code&gt;sendfile&lt;/code&gt; 조작을 사용하여 파일이 소켓을 통해 직접 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="82f8819da3536b2ff1e621e91a5108e31f33c3f5" translate="yes" xml:space="preserve">
          <source>If casting of all fields is successful, the changeset is returned as valid.</source>
          <target state="translated">모든 필드를 성공적으로 캐스팅하면 변경 집합이 유효한 것으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8943a6555280626edd3a71e646c2c513ffe092f9" translate="yes" xml:space="preserve">
          <source>If changing the JSON library, remember to recompile the adapter afterwards by cleaning the current build:</source>
          <target state="translated">JSON 라이브러리를 변경하는 경우 현재 빌드를 정리하여 어댑터를 나중에 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9d661e3bc80c3727f4d8b3225ce99bc171f66095" translate="yes" xml:space="preserve">
          <source>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</source>
          <target state="translated">어떤 이유로 데이터베이스에서 대소 문자를 구분하지 않는 열을 지원하지 않는 경우 값을 삽입 / 업데이트하기 전에 명시 적으로 소문자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14be184c345c7f9dea111444b78e1f2cb754b1fe" translate="yes" xml:space="preserve">
          <source>If installing from Hex, use the latest version from there:</source>
          <target state="translated">Hex에서 설치하는 경우 여기에서 최신 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="95a9f7927001d081a57717076667b9d7a6f459c0" translate="yes" xml:space="preserve">
          <source>If interpolating keyword lists, the keyword list entries are combined using ANDs and joined to any existing expression with an OR:</source>
          <target state="translated">키워드 목록을 보간하는 경우 AND를 사용하여 키워드 목록 항목을 결합하고 OR을 사용하여 기존 표현식에 조인합니다.</target>
        </trans-unit>
        <trans-unit id="76cef5435664170ccd219b3f7c9c0adfb90f5be5" translate="yes" xml:space="preserve">
          <source>If it is a keyword query the first argument must be either an &lt;code&gt;in&lt;/code&gt; expression, or a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. If the query needs a reference to the data source in any other part of the expression, then an &lt;code&gt;in&lt;/code&gt; must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</source>
          <target state="translated">키워드 쿼리 인 경우 첫 번째 인수는 &lt;code&gt;in&lt;/code&gt; 식이거나 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 값 이어야 합니다. 쿼리에서 표현식의 다른 부분에서 데이터 소스에 대한 참조가 필요한 경우 &lt;code&gt;in&lt;/code&gt; 을 사용하여 참조 변수를 작성해야합니다. 두 번째 인수는 키가 표현식 유형이고 값이 표현식 인 키워드 쿼리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e167dc3c73586f0621a46fd98ad4b4b1f1bc7e6b" translate="yes" xml:space="preserve">
          <source>If it is a query expression the first argument must be a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol and the second argument the expression.</source>
          <target state="translated">쿼리 식인 경우 첫 번째 인수는 &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 값이어야 하고 두 번째 인수는 식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c6ade3c42f4b46404eaab263d289e45dd9fd2097" translate="yes" xml:space="preserve">
          <source>If it is your first time with Phoenix, you don't need to worry about the details right now. For now, suffice it to say our application starts a database repository, a pubsub system for sharing messages across processes and nodes, and the application endpoint, which effectively serves HTTP requests. These services are started in the order they are defined and, whenever shutting down your application, they are stopped in the reverse order.</source>
          <target state="translated">Phoenix를 처음 사용하는 경우 지금 당장 세부 사항에 대해 걱정할 필요가 없습니다. 지금은 애플리케이션이 데이터베이스 저장소, 프로세스 및 노드간에 메시지를 공유하기위한 pubsub 시스템, HTTP 요청을 효과적으로 제공하는 애플리케이션 엔드 포인트를 시작한다고 말하기 만하면됩니다. 이러한 서비스는 정의 된 순서대로 시작되며 애플리케이션을 종료 할 때마다 역순으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f2004e501e574e9ee412f8a4a483f6b11c68baa6" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won&amp;rsquo;t even be started and the error will be immediately returned.</source>
          <target state="translated">multi에 변경 세트를 받아들이는 오퍼레이션 ( &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; 등&lt;/a&gt; )이 포함 된 경우 트랜잭션을 시작하기 전에 확인됩니다. 변경 세트에 오류가 있으면 트랜잭션이 시작되지 않고 오류가 즉시 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="63d39ee63729141787866693d23e5982b3dfbe19" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won't even be started and the error will be immediately returned.</source>
          <target state="translated">multi에 변경 집합을 허용하는 작업 (예 : &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt; )이 포함 된 경우 트랜잭션을 시작하기 전에 확인됩니다. 변경 세트에 오류가 있으면 트랜잭션이 시작되지 않고 오류가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="636fecfc6c19833110f980b78af43a7ddc1683cf" translate="yes" xml:space="preserve">
          <source>If no action has been applied to the changeset or action was set to &lt;code&gt;:ignore&lt;/code&gt;, no errors are shown on the form object even if the changeset has a non-empty &lt;code&gt;:errors&lt;/code&gt; value.</source>
          <target state="translated">변경 세트에 조치가 적용되지 않았거나 조치가 &lt;code&gt;:ignore&lt;/code&gt; 로 설정된 경우, 변경 세트에 비어 있지 않은 &lt;code&gt;:errors&lt;/code&gt; 값 이 있어도 양식 오브젝트에 오류가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cf26fadc638285a0643bc477b2beb4a0a2ba425c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket&amp;rsquo;s handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">채널 모듈이 제공되지 않으면 소켓의 핸들러는 주어진 주제에 맞는 채널을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a628119141d05e629bf0a8766bdd3134096279c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket's handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">채널 모듈이 제공되지 않으면 소켓의 핸들러를 사용하여 주어진 주제에 대해 일치하는 채널을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="b2947103d7b79f0495b72a656cc81700719a03f4" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang&amp;rsquo;s &lt;code&gt;ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit &amp;lsquo;group 14&amp;rsquo; from RFC 3526.</source>
          <target state="translated">사용자 지정 매개 변수를 지정하지 않으면 Erlang의 &lt;code&gt;ssl&lt;/code&gt; 은 기본 제공 기본값을 사용합니다. OTP 19 이후 이것은 RFC 3526의 2048 비트 '그룹 14'입니다.</target>
        </trans-unit>
        <trans-unit id="ff06cd66143c9798bef49db90969d1d02260d4a5" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang's &lt;code&gt;:ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit 'group 14' from RFC3526.</source>
          <target state="translated">사용자 지정 매개 변수가 지정되지 않은 경우 Erlang의 &lt;code&gt;:ssl&lt;/code&gt; 은 기본 제공 기본값을 사용합니다. OTP 19 이후 이것은 RFC3526의 2048 비트 '그룹 14'였습니다.</target>
        </trans-unit>
        <trans-unit id="030bd22aca683fa25d2f90bbb7143785a15622d3" translate="yes" xml:space="preserve">
          <source>If no data type is given, it defaults to a string.</source>
          <target state="translated">데이터 유형이 제공되지 않으면 기본값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ad19118a3e502181cda3b94015f8e221a2d0b2b8" translate="yes" xml:space="preserve">
          <source>If no path is given, it will use &lt;code&gt;priv/static&lt;/code&gt; as the input and output path.</source>
          <target state="translated">경로를 지정하지 않으면 입력 / 출력 경로로 &lt;code&gt;priv/static&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="8d9d3c05f3dd12de1de5d07c7780f6542cae6c1f" translate="yes" xml:space="preserve">
          <source>If no repo option is given, it is retrieved from the application environment.</source>
          <target state="translated">저장소 옵션이 제공되지 않으면 응용 프로그램 환경에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee5c6147c3838216862db0b62414741e83ebcaf" translate="yes" xml:space="preserve">
          <source>If no route matches, no pipeline is invoked and a 404 error is raised.</source>
          <target state="translated">일치하는 경로가 없으면 파이프 라인이 호출되지 않고 404 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d0b5d32c7f6f93cc1778a67587e008602e3131c" translate="yes" xml:space="preserve">
          <source>If no text filter is given, then the query selector itself must return a single element.</source>
          <target state="translated">텍스트 필터가 제공되지 않으면 쿼리 선택기 자체가 단일 요소를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3a1b6ad904f99f371f35324f835d274f96ca690" translate="yes" xml:space="preserve">
          <source>If none of the rendering options above quite fits our needs, we can compose our own using some of the functions that Plug gives us. Let's say we want to send a response with a status of &quot;201&quot; and no body whatsoever. We can easily do that with the &lt;a href=&quot;../plug/plug.conn#send_resp/3&quot;&gt;&lt;code&gt;Plug.Conn.send_resp/3&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">위의 렌더링 옵션 중 어느 것도 우리의 필요에 맞지 않으면 Plug가 제공하는 일부 기능을 사용하여 직접 구성 할 수 있습니다. 상태가 &quot;201&quot;이고 본문이 전혀없는 응답을 보내려고한다고 가정 해 보겠습니다. &lt;a href=&quot;../plug/plug.conn#send_resp/3&quot;&gt; &lt;code&gt;Plug.Conn.send_resp/3&lt;/code&gt; &lt;/a&gt; 함수로 쉽게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6adbbb0c65b31d1f51c0020589f3eb9907222ef9" translate="yes" xml:space="preserve">
          <source>If one of the goals of our context is to encapsulate Ecto Repo access, why does &lt;code&gt;create_user/1&lt;/code&gt; return an &lt;code&gt;Ecto.Changeset&lt;/code&gt; struct when we fail to create a user?</source>
          <target state="translated">컨텍스트의 목표 중 하나가 Ecto Repo 액세스를 캡슐화 하는 &lt;code&gt;Ecto.Changeset&lt;/code&gt; 왜 &lt;code&gt;create_user/1&lt;/code&gt; 이 사용자 생성에 실패했을 때 Ecto.Changeset 구조체를 반환 합니까?</target>
        </trans-unit>
        <trans-unit id="ac423aab6755d9973153fe985b209449ba726adf" translate="yes" xml:space="preserve">
          <source>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, &lt;code&gt;distinct&lt;/code&gt; accepts exactly the same expressions as &lt;code&gt;order_by&lt;/code&gt; and any &lt;code&gt;distinct&lt;/code&gt; expression will be automatically prepended to the &lt;code&gt;order_by&lt;/code&gt; expressions in case there is any &lt;code&gt;order_by&lt;/code&gt; expression.</source>
          <target state="translated">데이터베이스에서 지원하는 경우 쿼리 표현식을 고유하게 전달할 수 있으며 DISTINCT ON을 사용하여 쿼리를 생성합니다. 이러한 경우, &lt;code&gt;distinct&lt;/code&gt; 정확히 같은 표현을 허용 &lt;code&gt;order_by&lt;/code&gt; 하고 &lt;code&gt;distinct&lt;/code&gt; 표현이 자동으로 붙을 &lt;code&gt;order_by&lt;/code&gt; 의 모든이 경우에 표현 &lt;code&gt;order_by&lt;/code&gt; 의 식입니다.</target>
        </trans-unit>
        <trans-unit id="0223af7ed3699eca63dea1d94efb960cd2c51cb2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to create a database, we'll get this error.</source>
          <target state="translated">&quot;postgres&quot;역할에 데이터베이스 생성 권한이없는 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ce73e85073d9175d4905b8efcee9aa421bd12fc3" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to log in to the application, we'll get this error.</source>
          <target state="translated">&quot;postgres&quot;역할에 응용 프로그램에 로그인 할 수있는 권한이없는 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="de209264f46473a4d55a8d354b626de4aafb07b2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role is using a password different from the default &quot;postgres&quot;, we'll get this error.</source>
          <target state="translated">&quot;postgres&quot;역할이 기본 &quot;postgres&quot;와 다른 암호를 사용하는 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="70216b8d4897b8cf4c5ab39916317d1da5fb0d73" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback is implemented in the repository, it will be invoked with the first argument set to &lt;code&gt;:runtime&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 콜백이 저장소에 구현되어, 그것은에 첫 번째 인수 세트로 호출됩니다 &lt;code&gt;:runtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbad62ac0f0e10ca6a55f7468a042cab7daca496" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:sign&lt;/code&gt; or &lt;code&gt;:encrypt&lt;/code&gt; flag are given, then the cookie value can be any term.</source>
          <target state="translated">경우 &lt;code&gt;:sign&lt;/code&gt; 나 &lt;code&gt;:encrypt&lt;/code&gt; 플래그가 지정되어, 다음 쿠키 값은 용어가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda9d4cb892d2093b03ae139bdc1a11671af1389" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@title&lt;/code&gt; assign changes, then LiveView will execute &lt;code&gt;expand_title(@title)&lt;/code&gt; and send the new content. If &lt;code&gt;@title&lt;/code&gt; is the same, nothing is executed and nothing is sent.</source>
          <target state="translated">는 IF &lt;code&gt;@title&lt;/code&gt; 할당 변경 후 라이브 뷰가 실행됩니다 &lt;code&gt;expand_title(@title)&lt;/code&gt; 하고, 새로운 내용을 보낼 수 있습니다. 경우 &lt;code&gt;@title&lt;/code&gt; 가 동일, 아무것도 실행되지 않고 아무것도 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3de200e7c0ff094d2c2c6dcf0b8963fe5d0947ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@user.name&lt;/code&gt; changes but &lt;code&gt;@user.id&lt;/code&gt; doesn't, then LiveView will re-render only &lt;code&gt;@user.name&lt;/code&gt; and it will not execute or resend &lt;code&gt;@user.id&lt;/code&gt; at all.</source>
          <target state="translated">는 IF &lt;code&gt;@user.name&lt;/code&gt; 변화가 있지만 &lt;code&gt;@user.id&lt;/code&gt; 한 후 라이브 뷰는 다시 렌더링하지 않습니다 &lt;code&gt;@user.name&lt;/code&gt; 그것은 또는 재전송 실행되지 않습니다 &lt;code&gt;@user.id&lt;/code&gt; 전혀.</target>
        </trans-unit>
        <trans-unit id="20375713da5b5d68c5268d482ffb338724366ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;phx-value-&lt;/code&gt; prefix is used, the server payload will also contain a &lt;code&gt;&quot;value&quot;&lt;/code&gt; if the element's value attribute exists.</source>
          <target state="translated">경우 &lt;code&gt;phx-value-&lt;/code&gt; 접두사를 사용하는 경우, 서버 페이로드도 포함됩니다 &lt;code&gt;&quot;value&quot;&lt;/code&gt; 요소의 값 속성이 존재하는 경우.</target>
        </trans-unit>
        <trans-unit id="9712dc6b620700aa8412aa4754ed6dd3e600a162" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;required_key&lt;/code&gt; is not present, it will raise &lt;a href=&quot;phoenix.missingparamerror&quot;&gt;&lt;code&gt;Phoenix.MissingParamError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;required_key&lt;/code&gt; 이 존재하지 않는, 그것은 올릴 것이다 &lt;a href=&quot;phoenix.missingparamerror&quot;&gt; &lt;code&gt;Phoenix.MissingParamError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd227aadd17ccc0cdbbbf544e1a39ccbddc874c" translate="yes" xml:space="preserve">
          <source>If the LiveView is the source of truth, it will be responsible for fetching all of the cards in a board. Then it will call &lt;code&gt;live_component/3&lt;/code&gt; for each card, passing the card struct as argument to CardComponent:</source>
          <target state="translated">LiveView가 진실의 소스 인 경우 보드의 모든 카드를 가져 오는 책임이 있습니다. 그런 다음 각 카드에 대해 &lt;code&gt;live_component/3&lt;/code&gt; 를 호출 하여 카드 구조체를 CardComponent에 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b677401fc03b5a40d9088383358e9a2bc2639670" translate="yes" xml:space="preserve">
          <source>If the LiveView redirects with a live redirect, this macro returns &lt;code&gt;{:ok, live_view, disconnected_html}&lt;/code&gt; with the content of the new LiveView, the same as the &lt;code&gt;live/3&lt;/code&gt; macro. If the LiveView redirects with a regular redirect, this macro returns &lt;code&gt;{:ok, conn}&lt;/code&gt; with the rendered redirected page. In any other case, this macro raises.</source>
          <target state="translated">LiveView가 라이브 리디렉션으로 리디렉션되는 경우이 매크로는 &lt;code&gt;live/3&lt;/code&gt; 매크로 와 동일한 새 LiveView의 콘텐츠와 함께 &lt;code&gt;{:ok, live_view, disconnected_html}&lt;/code&gt; 을 반환합니다 . LiveView가 일반 리디렉션으로 리디렉션되는 경우이 매크로는 렌더링 된 리디렉션 된 페이지와 함께 &lt;code&gt;{:ok, conn}&lt;/code&gt; 을 반환 합니다. 다른 경우에는이 매크로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="774625820d7d0ec4e795fa8c9c6c08379f522851" translate="yes" xml:space="preserve">
          <source>If the URL has a host, a CSRF token that is tied to that host will be generated. If it is a relative path URL, a simple token emitted with &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">URL에 호스트가 있으면 해당 호스트에 연결된 CSRF 토큰이 생성됩니다. 상대 경로 URL 인 경우 &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; 으로 생성 된 간단한 토큰 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e46e2e7ec4df9676257eca653e07b09f347fb52" translate="yes" xml:space="preserve">
          <source>If the adapter does not provide a pool, just calling the passed function and returning its result are enough.</source>
          <target state="translated">어댑터가 풀을 제공하지 않는 경우 전달 된 함수를 호출하고 그 결과를 반환하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c467ebfb28c3769c0f60d1ed5192b127c4f129d1" translate="yes" xml:space="preserve">
          <source>If the adapter does not support inform, then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">어댑터가 정보를 지원하지 않으면 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b83fa861079f61f5349df999d4ab77d5e9dd2d46" translate="yes" xml:space="preserve">
          <source>If the adapter does not support informational responses then this is a noop.</source>
          <target state="translated">어댑터가 정보 응답을 지원하지 않는 경우 이는 noop입니다.</target>
        </trans-unit>
        <trans-unit id="abd9faa09d21bdad382cd8d73f3c1cd6edf98fe0" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">어댑터가 서버 푸시를 지원하지 않으면 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="03a7adb38fe4fd08405bbe2e59b1dc64945ce1ee" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then this is a noop.</source>
          <target state="translated">어댑터가 서버 푸시를 지원하지 않는 경우 이것은 noop입니다.</target>
        </trans-unit>
        <trans-unit id="e1ab595daecbe8219ab31d6ce1dc0b9d4bd3ff2d" translate="yes" xml:space="preserve">
          <source>If the adapter provides a pool, it is supposed to &quot;check out&quot; one of the pool connections for the duration of the function call. Which connection is checked out is not passed to the calling function, so it should be done using a stateful method like using the current process' dictionary, process tracking, or some kind of other lookup method. Make sure that this stored connection is then used in the other callbacks implementations, such as &lt;a href=&quot;ecto.adapter.queryable&quot;&gt;&lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.adapter.schema&quot;&gt;&lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어댑터가 풀을 제공하는 경우 함수 호출 기간 동안 풀 연결 중 하나를 &quot;체크 아웃&quot;해야합니다. 체크 아웃 된 연결은 호출 함수로 전달되지 않으므로 현재 프로세스의 사전, 프로세스 추적 또는 기타 검색 방법을 사용하는 것과 같은 상태 저장 방법을 사용하여 수행해야합니다. 이 저장된 연결이 &lt;a href=&quot;ecto.adapter.queryable&quot;&gt; &lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.adapter.schema&quot;&gt; &lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt; &lt;/a&gt; 와 같은 다른 콜백 구현에서 사용되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="67e30f305c8d388d84dacb2f22a8db0505392601" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;:select_merge&lt;/code&gt; is a constructed struct (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;) or map (&lt;code&gt;map/2&lt;/code&gt;) where the source to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;map/2&lt;/code&gt; may be a &lt;code&gt;nil&lt;/code&gt; value (as in an outer join), the source will be returned unmodified.</source>
          <target state="translated">의 인수 경우 &lt;code&gt;:select_merge&lt;/code&gt; 가 구축 된 구조체 (인 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; ) 또는지도 ( &lt;code&gt;map/2&lt;/code&gt; 원본) &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;map/2&lt;/code&gt; 수있다 &lt;code&gt;nil&lt;/code&gt; (외측 가입에서와 같이) 값을 상기 소스 것 수정되지 않은 상태로 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1c015b3bdb8e3e97eeb9a475ec46483a71e9b1c" translate="yes" xml:space="preserve">
          <source>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not any of values below, it will raise.</source>
          <target state="translated">연결에 변경 사항이 없으면 건너 뜁니다. 연결이 유효하지 않으면 변경 세트가 유효하지 않은 것으로 표시됩니다. 주어진 값이 아래 값 중 하나가 아니면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="6943cbcbf6b1af61a1ee6167ddcf2f6551e4192a" translate="yes" xml:space="preserve">
          <source>If the body of the action needs access to the full map of parameters bound to the params variable in addition to the bound messenger variable, we could define &lt;code&gt;show/2&lt;/code&gt; like this:</source>
          <target state="translated">액션의 본문이 바인딩 된 메신저 변수 외에 params 변수에 바인딩 된 매개 변수의 전체 맵에 액세스해야하는 경우 다음 과 같이 &lt;code&gt;show/2&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f7bac3c27469f7d4914ccb40eab78a149fc9bfe" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value.</source>
          <target state="translated">변경 사항이 이미 존재하면 새 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a698e1cab1f6f678660aa4dfb67045d6928daa" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value. If the change has the same value as in the changeset data, it is not added to the list of changes.</source>
          <target state="translated">변경 사항이 이미 존재하면 새 값으로 대체됩니다. 변경 사항이 변경 세트 데이터와 동일한 값을 갖는 경우 변경 사항 목록에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d643dc985a9051bacd04e1a9f62548fd0e65c8a1" translate="yes" xml:space="preserve">
          <source>If the changes are valid, all changes are applied to the changeset data. If the changes are invalid, no changes are applied, and an error tuple is returned with the changeset containing the action that was attempted to be applied.</source>
          <target state="translated">변경 사항이 유효하면 모든 변경 사항이 변경 세트 데이터에 적용됩니다. 변경 사항이 유효하지 않은 경우, 변경 사항이 적용되지 않으며 적용하려고 시도한 조치가 포함 된 변경 세트와 함께 오류 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2757319b7d7f37a81751b87f0ba7d4b5be8070c7" translate="yes" xml:space="preserve">
          <source>If the changeset given to the repository is valid, the function given to &lt;a href=&quot;#prepare_changes/2&quot;&gt;&lt;code&gt;prepare_changes/2&lt;/code&gt;&lt;/a&gt; will be called with the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands. The repository itself can be accessed inside the function under the &lt;code&gt;repo&lt;/code&gt; field in the changeset. If the changeset given to the repository is invalid, the function will not be invoked.</source>
          <target state="translated">저장소에 제공된 변경 세트가 유효하면 &lt;a href=&quot;#prepare_changes/2&quot;&gt; &lt;code&gt;prepare_changes/2&lt;/code&gt; 에&lt;/a&gt; 제공된 함수 가 변경 세트와 함께 호출되고 변경 세트를 리턴해야 개발자가 변경 세트를 최종 조정하거나 데이터 일관성 명령을 실행할 수 있습니다. 저장소 자체는 변경 집합 의 &lt;code&gt;repo&lt;/code&gt; 필드 아래 함수 내에서 액세스 할 수 있습니다 . 저장소에 제공된 변경 집합이 유효하지 않은 경우 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdfa9dbe95ded2efddb01ada6c9e4b572e2c816b" translate="yes" xml:space="preserve">
          <source>If the component is the source of truth, then the LiveView must no longer fetch all of the cards structs from the database. Instead, the view must only fetch all of the card ids and render the component only by passing the IDs:</source>
          <target state="translated">구성 요소가 진실의 소스 인 경우 LiveView는 더 이상 데이터베이스에서 모든 카드 구조를 가져 오지 않아야합니다. 대신 뷰는 모든 카드 ID를 가져오고 ID를 전달하는 방식으로 만 구성 요소를 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="67aa5ebe70fe8f05417258db1eb3c5975b93dd2a" translate="yes" xml:space="preserve">
          <source>If the component uses the &lt;code&gt;@myself&lt;/code&gt; assigns, then an &lt;code&gt;id&lt;/code&gt; must be given to it is marked as stateful.</source>
          <target state="translated">구성 요소가 &lt;code&gt;@myself&lt;/code&gt; 할당을 사용하는 경우 &lt;code&gt;id&lt;/code&gt; 해야 상태 저장으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="344cb03738b4c3ad68a22abc027e74afa335c15c" translate="yes" xml:space="preserve">
          <source>If the connection is accepted, the transport can move the connection to another process, if so desires, or keep using the same process. The process responsible for managing the socket should then call &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결이 수락되면 전송은 원하는 경우 연결을 다른 프로세스로 이동하거나 동일한 프로세스를 계속 사용할 수 있습니다. 소켓 관리를 담당하는 프로세스는 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d577ab6f6374c6d9db1620ec48bb72e49c4e5c2" translate="yes" xml:space="preserve">
          <source>If the connection was successful, generates &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic from the &lt;code&gt;id/1&lt;/code&gt; callback.</source>
          <target state="translated">연결에 성공 하면 &lt;code&gt;id/1&lt;/code&gt; 콜백 에서 &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; 주제를 생성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="14c0b3c8ee8241e593e8ad60d75f84e2457bdc6b" translate="yes" xml:space="preserve">
          <source>If the cookie is not signed nor encrypted, then the value must be a binary. Note the value is not automatically escaped. Therefore if you want to store values with non-alphanumeric characters, you must either sign or encrypt the cookie or consider explicitly escaping the cookie value by using a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. It is important for padding to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">쿠키가 서명되거나 암호화되지 않은 경우 값은 2 진이어야합니다. 값은 자동으로 이스케이프되지 않습니다. 따라서 영숫자가 아닌 문자로 값을 저장하려면 쿠키에 서명 또는 암호화하거나 작성시 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 및 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 와 같은 함수를 사용하여 쿠키 값을 명시 적으로 이스케이프하는 것을 고려해야합니다 . (인코딩 됨, 패딩 : false) 쿠키를 읽을 때. &lt;code&gt;=&lt;/code&gt; 는 쿠키 값에서 유효한 문자가 아니기 때문에 패딩을 비활성화하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="864bd00ea3a957445c805b9ef45d85dcecd562f1" translate="yes" xml:space="preserve">
          <source>If the element is does not have a &lt;code&gt;phx-click&lt;/code&gt; attribute but it is a link (the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag), the link will be followed accordingly:</source>
          <target state="translated">요소에 &lt;code&gt;phx-click&lt;/code&gt; 속성이 없지만 링크 ( &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그) 인 경우 그에 따라 링크가 이어집니다.</target>
        </trans-unit>
        <trans-unit id="3a5834bc3acf73c8335beda9b2b7bbaf51ee3a6e" translate="yes" xml:space="preserve">
          <source>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid.</source>
          <target state="translated">퍼가기 변경 사항이 없으면 건너 뜁니다. 임베드가 유효하지 않은 경우 변경 세트가 유효하지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="077370f1bc31b993e443236f4c6f4806ca2f3eaa" translate="yes" xml:space="preserve">
          <source>If the error happens during an event, the LiveView process will crash. The client will notice the error and remount the LiveView - without reloading the page. This is enough to update the page and show the user the latest information.</source>
          <target state="translated">이벤트 중에 오류가 발생하면 LiveView 프로세스가 중단됩니다. 클라이언트는 페이지를 다시로드하지 않고 오류를 인식하고 LiveView를 다시 마운트합니다. 이것은 페이지를 업데이트하고 사용자에게 최신 정보를 표시하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="100887b9de3b56af079f0a72491a4382d1396bb0" translate="yes" xml:space="preserve">
          <source>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</source>
          <target state="translated">왼쪽의 맵이 구조체 인 경우 Ecto는 병합하기 전에 오른쪽에있는 모든 필드가 왼쪽에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="67cfc2cb3e12875af3e1ba6a2973b3dbd4bbf5ad" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is an associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with the existing struct and become an update operation</source>
          <target state="translated">매개 변수에 ID가 포함되어 있고 해당 ID와 연관된 하위가있는 경우 매개 변수 데이터는 기존 구조와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달 되고 업데이트 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="5b235bb233a3f3d355503c030abb877188e1fb03" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is no associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">매개 변수에 ID가 있고 해당 ID와 연관된 하위가없는 경우 매개 변수 데이터는 새 구조체와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달 되고 삽입 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2858b55ac4015434edf3d00d6d984a1e7af01d" translate="yes" xml:space="preserve">
          <source>If the parameter does not contain an ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">매개 변수에 ID가 포함되어 있지 않으면 매개 변수 데이터가 새 구조체와 함께 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 로 전달되어 삽입 작업이됩니다.</target>
        </trans-unit>
        <trans-unit id="78ee41955dbd956392d43e790282ee7ecabd02d3" translate="yes" xml:space="preserve">
          <source>If the parameterized type is also a composite type, the inner type can be cast by calling &lt;a href=&quot;ecto.type#cast/2&quot;&gt;&lt;code&gt;Ecto.Type.cast/2&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">매개 변수가있는 형식도 복합 형식이면 &lt;a href=&quot;ecto.type#cast/2&quot;&gt; &lt;code&gt;Ecto.Type.cast/2&lt;/code&gt; 를&lt;/a&gt; 직접 호출하여 내부 형식을 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;:pop&lt;/code&gt; 을 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{value, new_data}&lt;/code&gt; 여야합니다. 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래 값 이거나 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; 이고 &lt;code&gt;new_data&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 없는 &lt;code&gt;data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 를 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{get_value, new_data}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2143e7239fbfa87b876c6cf2de6756de08ffc64" translate="yes" xml:space="preserve">
          <source>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</source>
          <target state="translated">쿼리에 제한, 오프셋 또는 고유 집합이 있으면 적절한 결과를 반환하기 위해 하위 쿼리에 자동으로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2bddb6cc8d18143b43f8bbafcae7867ac58bcf" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the key is set in the given struct, the key will automatically be set in the built association:</source>
          <target state="translated">관계가 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 이고 키가 주어진 구조체에서 설정되면 키는 자동으로 빌드 된 연관에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8c910d7e1f4a7ca500d332206b3b56b62dcdd3" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the primary key is set in the parent struct, the key will automatically be set in the built association:</source>
          <target state="translated">관계가 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 이고 기본 키가 부모 구조체에 설정된 경우 키는 빌드 된 연결에 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ab972c154c21dacb18a792e2b9de9b778294e4" translate="yes" xml:space="preserve">
          <source>If the request contains a &quot;_format&quot; parameter, it is considered to be the format desired by the client. If no &quot;_format&quot; parameter is available, this function will parse the &quot;accept&quot; header and find a matching format accordingly.</source>
          <target state="translated">요청에 &quot;_format&quot;매개 변수가 포함 된 경우 클라이언트가 원하는 형식으로 간주됩니다. &quot;_format&quot;매개 변수를 사용할 수없는 경우이 함수는 &quot;accept&quot;헤더를 구문 분석하고 그에 따라 일치하는 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="589c270364db1b0108ce43960e91be264009debe" translate="yes" xml:space="preserve">
          <source>If the request contains a &amp;ldquo;_format&amp;rdquo; parameter, it is considered to be the format desired by the client. If no &amp;ldquo;_format&amp;rdquo; parameter is available, this function will parse the &amp;ldquo;accept&amp;rdquo; header and find a matching format accordingly.</source>
          <target state="translated">요청에&amp;ldquo;_format&amp;rdquo;매개 변수가 포함되어 있으면 클라이언트가 원하는 형식으로 간주됩니다. &quot;_format&quot;매개 변수를 사용할 수 없으면이 함수는 &quot;accept&quot;헤더를 구문 분석하고 이에 따라 일치하는 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c173a238b103f05715b98fa0448f517f74ccec4e" translate="yes" xml:space="preserve">
          <source>If the request has method &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt;, the adapter should not send the response to the client.</source>
          <target state="translated">요청에 &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; 메소드가 있으면 어댑터는 클라이언트에 응답을 보내지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d45df81e2caa272cbf84dfebf38c8aa28609010e" translate="yes" xml:space="preserve">
          <source>If the route contains glob-like patterns, parameters for those have to be given as list:</source>
          <target state="translated">경로에 glob-like 패턴이 포함 된 경우 해당 매개 변수를 목록으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bf5da11b58dcf3690804466cd69ea5e5e4dca07" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;map&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">동일한 소스를 &lt;code&gt;map&lt;/code&gt; 으로 여러 번 선택한 경우 데이터베이스에서 여러 사본을 가져 오지 않도록 필드가 병합됩니다. 즉, 아래 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="652e9d42a43e2b8d5dcd0218df8782089064b141" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;struct&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 로 동일한 소스를 여러 번 선택한 경우 데이터베이스에서 여러 사본을 가져 오지 않도록 필드가 병합됩니다. 즉, 아래 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52eb3cdb7cd07fea24cf8899ccfeee45fa44e2fe" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 기본적으로 HTTP Strict Transport Security를 ​​활성화하기 위해 엄격한 전송 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="564b33d47ddc46edcbbb5f1d39d5ab6ae21f5998" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가하여 HTTP Strict Transport Security를 ​​활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8ce0178df9065e1071126bd4051a90d7aa5fa061" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it'll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">요청 체계가 &lt;code&gt;https&lt;/code&gt; 인 경우 &lt;code&gt;strict-transport-security&lt;/code&gt; 헤더를 추가하여 기본적으로 HTTP Strict Transport Security를 ​​활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1e40997d2cab9139afd7b3e62e6c58a9b6923fe9" translate="yes" xml:space="preserve">
          <source>If the session has already been initialized, the new contents will be merged with the previous ones.</source>
          <target state="translated">세션이 이미 초기화 된 경우 새 내용이 이전 내용과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="187932693c763b03306b32e57e7c13cda06351fc" translate="yes" xml:space="preserve">
          <source>If the struct cannot be found, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체를 찾을 수 없으면 &lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62ac87da8864e486a5dadb087a7c2632f82b5234" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체에 기본 키가 없으면 &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8767938851ade63a15afc91119604f0839e7344" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised. If the struct has been removed from db prior to call, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">구조체에 기본 키가 없으면 &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 호출하기 전에 구조체가 db에서 제거 된 경우 &lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e5578acf03166a21322dd600d9a66efef5d73e58" translate="yes" xml:space="preserve">
          <source>If the underlying input type is a &lt;code&gt;:text_field&lt;/code&gt;, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</source>
          <target state="translated">기본 입력 유형이 &lt;code&gt;:text_field&lt;/code&gt; 인 경우, 필드 이름만을 기반으로 입력 유형을 추가로 반영하기 위해 맵핑이 제공 될 수 있습니다. 기본 매핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a1e50f02aaf223bea1728ac3e4f595a0d0fbc9" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset&amp;rsquo;s changes, and an error is added. Note the error won&amp;rsquo;t be added though if the field already has an error.</source>
          <target state="translated">필드 값이 &lt;code&gt;nil&lt;/code&gt; 이거나 공백으로 만 구성된 문자열 인 경우 변경 세트가 유효하지 않은 것으로 표시되고 필드가 변경 세트의 변경 사항에서 제거되고 오류가 추가됩니다. 필드에 이미 오류가있는 경우 오류가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b51a8cfa4d0487afe8257855e71b56a122faf53b" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset's changes, and an error is added. An error won't be added if the field already has an error.</source>
          <target state="translated">필드의 값이 &lt;code&gt;nil&lt;/code&gt; 이거나 공백으로 만 이루어진 문자열이면 변경 집합이 유효하지 않은 것으로 표시되고 해당 필드가 변경 집합의 변경에서 제거되고 오류가 추가됩니다. 필드에 이미 오류가있는 경우 오류가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccfc8db638f1f1620ef7b8abebc9015b4310b64a" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &quot;On replace&quot; section on the module documentation)</source>
          <target state="translated">ID와 연관된 하위가 있고 ID가 매개 변수로 제공되지 않은 경우 해당 연관에 대한 &lt;code&gt;:on_replace&lt;/code&gt; 콜백이 호출됩니다 (모듈 문서의 &quot;대체시&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="5bc5b56a27b8e1d0d4212e390ddd5e71de7e4d2d" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &amp;ldquo;On replace&amp;rdquo; section on the module documentation)</source>
          <target state="translated">ID가있는 관련 자식이 있고 해당 ID가 매개 변수로 제공되지 않으면 해당 연결에 대한 &lt;code&gt;:on_replace&lt;/code&gt; 콜백이 호출됩니다 (모듈 설명서의 &quot;교체시&quot;섹션 참조)</target>
        </trans-unit>
        <trans-unit id="3027f8dce56af2e1b89a3dcdf3f1ecf46fe576f2" translate="yes" xml:space="preserve">
          <source>If there is no English translation for the post, the untranslated post &lt;code&gt;title&lt;/code&gt; will be returned and &lt;code&gt;summary&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt;. If there is, both &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; will be the value from &lt;code&gt;Post.Translation&lt;/code&gt;.</source>
          <target state="translated">게시물에 대한 영어 번역이없는 경우 번역되지 않은 게시물 &lt;code&gt;title&lt;/code&gt; 이 반환되고 &lt;code&gt;summary&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 됩니다. 있는 경우 &lt;code&gt;title&lt;/code&gt; 과 &lt;code&gt;summary&lt;/code&gt; 모두 &lt;code&gt;Post.Translation&lt;/code&gt; 의 값이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a1a377354e3a0de11df4acec5746a31c120d5d3" translate="yes" xml:space="preserve">
          <source>If there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">그러한 행이 없으면 대신 기본값을 반환합니다 (값과 동일한 유형이어야 함). 오프셋과 기본값은 모두 현재 행을 기준으로 평가됩니다. 생략하면 offset 기본값은 1이고 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71d83351b5a78845c987b433bc2606bd08dbd349" translate="yes" xml:space="preserve">
          <source>If we again visit &lt;code&gt;/hello/Frank&lt;/code&gt; in the browser, we should see a block of JSON with the key &lt;code&gt;id&lt;/code&gt; mapped to the string &lt;code&gt;&quot;Frank&quot;&lt;/code&gt;.</source>
          <target state="translated">브라우저에서 &lt;code&gt;/hello/Frank&lt;/code&gt; 를 다시 방문 하면 키 &lt;code&gt;id&lt;/code&gt; &lt;code&gt;&quot;Frank&quot;&lt;/code&gt; 문자열에 매핑 된 JSON 블록이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="a55899f5bba3bae6ddb4b8c3a53a4536e1c0110c" translate="yes" xml:space="preserve">
          <source>If we also have a requirement for the maximum length that a bio can have, we can simply add another validation.</source>
          <target state="translated">바이오가 가질 수있는 최대 길이에 대한 요구 사항도있는 경우 간단히 다른 유효성 검사를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43f96c979a225b950bb4dfa9a208756fcb9cd93" translate="yes" xml:space="preserve">
          <source>If we are about to create a new application, configuring our application to use MySQL is easy. We can simply pass the &lt;code&gt;--database mysql&lt;/code&gt; flag to &lt;code&gt;phx.new&lt;/code&gt; and everything will be configured correctly.</source>
          <target state="translated">새 애플리케이션을 만들려는 경우 MySQL을 사용하도록 애플리케이션을 구성하는 것은 쉽습니다. &lt;code&gt;--database mysql&lt;/code&gt; 플래그를 &lt;code&gt;phx.new&lt;/code&gt; 에 전달하면 모든 것이 올바르게 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fcbca676064b2672228b8d404db61ea01e7b418d" translate="yes" xml:space="preserve">
          <source>If we are terminating because the client left, the reason will be &lt;code&gt;{:shutdown, :left}&lt;/code&gt;. Similarly, if we are terminating because the client connection was closed, the reason will be &lt;code&gt;{:shutdown, :closed}&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 떠나서 종료하는 경우 이유는 &lt;code&gt;{:shutdown, :left}&lt;/code&gt; 입니다. 마찬가지로 클라이언트 연결이 종료되어 종료하는 경우 이유는 &lt;code&gt;{:shutdown, :closed}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f294c1cc2eca5e08e950254d2b15770ecc60ce6" translate="yes" xml:space="preserve">
          <source>If we care to, we can open up our developer tools, click on the network tab, and visit our root route again. We see two main requests for this page - a get to &lt;code&gt;/&lt;/code&gt; with a status of &lt;code&gt;302&lt;/code&gt;, and a get to &lt;code&gt;/redirect_test&lt;/code&gt; with a status of &lt;code&gt;200&lt;/code&gt;.</source>
          <target state="translated">관심이 있다면 개발자 도구를 열고 네트워크 탭을 클릭 한 다음 루트 경로를 다시 방문 할 수 있습니다. 에 GET - 우리는 두 가지 주요 페이지에 대한 요청 참조 &lt;code&gt;/&lt;/code&gt; 의 상태 &lt;code&gt;302&lt;/code&gt; , 및에 GET &lt;code&gt;/redirect_test&lt;/code&gt; 의 상태 &lt;code&gt;200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef5847801c77dfd9829f943c4a44ef415cbf4af" translate="yes" xml:space="preserve">
          <source>If we choose not to have Phoenix install our dependencies when we generate a new application, the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; task will prompt us to take the necessary steps when we do want to install them.</source>
          <target state="translated">새 응용 프로그램을 생성 할 때 Phoenix가 종속성을 설치하지 않도록 선택하면 &lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt; 작업이 설치를 원할 때 필요한 단계를 수행하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="083bd2611232c5afdab8b58c40dae911b3992cc4" translate="yes" xml:space="preserve">
          <source>If we do duplicate a route, we'll get this familiar warning.</source>
          <target state="translated">경로를 복제하면이 익숙한 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="18c2a428049c971561e33683903cb91fda071a38" translate="yes" xml:space="preserve">
          <source>If we don't feel that we need all of these routes, we can be selective using the &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options to filter certain actions.</source>
          <target state="translated">이러한 경로가 모두 필요하지 않다고 생각되면 &lt;code&gt;:only&lt;/code&gt; 및 &lt;code&gt;:except&lt;/code&gt; 옵션을 사용하여 특정 작업을 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b148b617e87c3d7cf1bf0c454fb60e53b8088cca" translate="yes" xml:space="preserve">
          <source>If we don't have any static assets, or we want to use another build tool, we can pass the &lt;code&gt;--no-webpack&lt;/code&gt; flag when creating a new application and node won't be required at all.</source>
          <target state="translated">정적 자산이 없거나 다른 빌드 도구를 사용하려는 경우 새 애플리케이션을 만들 때 &lt;code&gt;--no-webpack&lt;/code&gt; 플래그를 전달할 수 있으며 노드가 전혀 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ce90215702773251bdd42373866333197e1b5cb" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and are not interested in generating or altering a context we can use the &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; task. It will generate a schema, and a migration.</source>
          <target state="translated">완전한 HTML / JSON 리소스가 필요하지 않고 컨텍스트를 생성하거나 변경하는 데 관심이 &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt; 작업을 사용할 수 있습니다 . 스키마와 마이그레이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="391120460ffbf26e5eb0e6249f59b60800a1272f" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and instead are only interested in a context, we can use the &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; task. It will generate a context, a schema, a migration and a test case.</source>
          <target state="translated">완전한 HTML / JSON 리소스가 필요하지 않고 컨텍스트에만 관심이있는 경우 &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt; 작업을 사용할 수 있습니다 . 컨텍스트, 스키마, 마이그레이션 및 테스트 케이스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0325343ecff8ab2b1c281d1f5eb03e5e5a1f542c" translate="yes" xml:space="preserve">
          <source>If we don't specify a router for this task, it will default to the router Phoenix generated for us.</source>
          <target state="translated">이 작업에 대해 라우터를 지정하지 않으면 기본적으로 Phoenix가 생성 한 라우터가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bbc243df3c98e3ec94e3d2cceb1fad20c911551" translate="yes" xml:space="preserve">
          <source>If we don't want to create a context or schema for our resource we can use the &lt;code&gt;--no-context&lt;/code&gt; flag. Note that this still requires a context module name as a parameter.</source>
          <target state="translated">리소스에 대한 컨텍스트 또는 스키마를 생성하지 않으려면 &lt;code&gt;--no-context&lt;/code&gt; 플래그를 사용할 수 있습니다 . 여전히 매개 변수로 컨텍스트 모듈 이름이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="202b483bde361859fe3d989c4fc41024ae857693" translate="yes" xml:space="preserve">
          <source>If we follow the &quot;Back&quot; link, we get a list of all users, which should contain the one we just created. Likewise, we can update this record or delete it. Now that we've seen how it works in the browser, it's time to take a look at the generated code.</source>
          <target state="translated">&quot;뒤로&quot;링크를 따라 가면 방금 만든 사용자를 포함해야하는 모든 사용자 목록이 표시됩니다. 마찬가지로이 레코드를 업데이트하거나 삭제할 수 있습니다. 이제 브라우저에서 어떻게 작동하는지 살펴 보았으므로 생성 된 코드를 살펴볼 차례입니다.</target>
        </trans-unit>
        <trans-unit id="e8cdc4c30930a9f92ef3229c041981125e1295ee" translate="yes" xml:space="preserve">
          <source>If we go to &lt;a href=&quot;http://localhost:4000/?_format=text&quot;&gt;&lt;code&gt;http://localhost:4000/?_format=text&lt;/code&gt;&lt;/a&gt;, we will see &quot;OMG, this is actually some text.&quot;.</source>
          <target state="translated">우리가 가면 &lt;a href=&quot;http://localhost:4000/?_format=text&quot;&gt; &lt;code&gt;http://localhost:4000/?_format=text&lt;/code&gt; &lt;/a&gt; , 우리가 볼 것 &quot;OMG, 이것은 실제로 일부 텍스트입니다.&quot;.</target>
        </trans-unit>
        <trans-unit id="3cbeea3cdf6c8b4aae44fc28787ce47be0b89ac2" translate="yes" xml:space="preserve">
          <source>If we had aliased the &lt;code&gt;Helpers&lt;/code&gt; module as before (it is only automatically aliased for views, templates and controllers, in this case, since we're inside &lt;code&gt;iex&lt;/code&gt; we need to do it ourselves), we could instead do:</source>
          <target state="translated">이전과 같이 &lt;code&gt;Helpers&lt;/code&gt; 모듈에 별칭을 지정했다면 (뷰, 템플릿 및 컨트롤러에 대해서만 자동으로 별칭이 지정됩니다.이 경우에는 &lt;code&gt;iex&lt;/code&gt; 내부에 있으므로 직접 수행해야합니다) 대신 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd17028a95f476ab737ed8720e1d0211a3a7561" translate="yes" xml:space="preserve">
          <source>If we happen to have another repo that we want to drop the database for, we can specify it with the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">데이터베이스를 삭제하려는 다른 저장소가있는 경우 &lt;code&gt;-r&lt;/code&gt; 플래그로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e7e68839f0a87f7d3b692b54aa39ae82f91218c" translate="yes" xml:space="preserve">
          <source>If we have an existing application, all we need to do is switch adapters and make some small configuration changes.</source>
          <target state="translated">기존 애플리케이션이있는 경우 어댑터를 전환하고 약간의 구성을 변경하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="658d3ae57e71f3341641eb3949711018592d2d1b" translate="yes" xml:space="preserve">
          <source>If we have an existing configuration block for our &lt;code&gt;HelloPhoenix.Repo&lt;/code&gt;, we can simply change the values to match our new ones. You also need to configure the correct values in the &lt;code&gt;config/test.exs&lt;/code&gt; and &lt;code&gt;config/prod.secret.exs&lt;/code&gt; files as well.</source>
          <target state="translated">&lt;code&gt;HelloPhoenix.Repo&lt;/code&gt; 에 대한 기존 구성 블록이있는 경우 새 값과 일치하도록 값을 간단히 변경할 수 있습니다. 또한 &lt;code&gt;config/test.exs&lt;/code&gt; 및 &lt;code&gt;config/prod.secret.exs&lt;/code&gt; 파일에서도 올바른 값을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="963fb6aba8a7d7a559054bec03ba9d17da20b6ff" translate="yes" xml:space="preserve">
          <source>If we have just installed Elixir for the first time, we will need to install the Hex package manager as well. Hex is necessary to get a Phoenix app running (by installing dependencies) and to install any extra dependencies we might need along the way.</source>
          <target state="translated">Elixir를 처음 설치했다면 Hex 패키지 관리자도 설치해야합니다. Hex는 Phoenix 앱을 실행 (종속성 설치)하고 필요한 추가 종속성을 설치하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5daa84ed51f538f1246f7583c53daad14892bab5" translate="yes" xml:space="preserve">
          <source>If we log in to our database server, and connect to our &lt;code&gt;hello_dev&lt;/code&gt; database, we should see our &lt;code&gt;users&lt;/code&gt; table. Ecto assumes that we want an integer column called &lt;code&gt;id&lt;/code&gt; as our primary key, so we should see a sequence generated for that as well.</source>
          <target state="translated">데이터베이스 서버에 로그인하고 &lt;code&gt;hello_dev&lt;/code&gt; 데이터베이스에 연결하면 &lt;code&gt;users&lt;/code&gt; 테이블이 표시됩니다. Ecto는 &lt;code&gt;id&lt;/code&gt; 라는 정수 열을 기본 키로 원한다고 가정 하므로 이에 대해 생성 된 시퀀스도 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ad55a2d89bb2b694326401b2e1b3ac0d3a25512" translate="yes" xml:space="preserve">
          <source>If we name our repo &lt;code&gt;OurCustom.Repo&lt;/code&gt;, this task will create it here &lt;code&gt;lib/our_custom/repo.ex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OurCustom.Repo&lt;/code&gt; 이름을 OurCustom.Repo로 지정 하면이 태스크가 여기에 &lt;code&gt;lib/our_custom/repo.ex&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="410aa46a3f58fdfb55c933dc63ac4ff7560f52cf" translate="yes" xml:space="preserve">
          <source>If we need only the rendered string, without the whole tuple, we can use &lt;code&gt;render_to_string/3&lt;/code&gt;.</source>
          <target state="translated">전체 튜플없이 렌더링 된 문자열 만 필요하면 &lt;code&gt;render_to_string/3&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c67cebfdb55f59c0c40bdafd0841173e71de24d6" translate="yes" xml:space="preserve">
          <source>If we need to pass values into the template when using &lt;code&gt;render&lt;/code&gt;, that's easy. We can pass a keyword like we've seen with &lt;code&gt;messenger: messenger&lt;/code&gt;, or we can use &lt;a href=&quot;../plug/plug.conn#assign/3&quot;&gt;&lt;code&gt;Plug.Conn.assign/3&lt;/code&gt;&lt;/a&gt;, which conveniently returns &lt;code&gt;conn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 를 사용할 때 템플릿에 값을 전달해야한다면 쉽습니다. &lt;code&gt;messenger: messenger&lt;/code&gt; 에서 본 것과 같은 키워드를 전달 하거나 &lt;code&gt;conn&lt;/code&gt; 을 편리하게 반환하는 &lt;a href=&quot;../plug/plug.conn#assign/3&quot;&gt; &lt;code&gt;Plug.Conn.assign/3&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a0c2ddb5903057e2b6c4bf63e6d7df23b45687f" translate="yes" xml:space="preserve">
          <source>If we open up the &lt;code&gt;User&lt;/code&gt; schema in &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt;, it will look immediately familiar:</source>
          <target state="translated">&lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt; 에서 &lt;code&gt;User&lt;/code&gt; 스키마를 열면 즉시 익숙해 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c00f799ed099e309e29da91ee4bd50186d484b2" translate="yes" xml:space="preserve">
          <source>If we require a &lt;code&gt;CMS.Author&lt;/code&gt; to exist every time an &lt;code&gt;Accounts.User&lt;/code&gt; is created, we have to think carefully where to place this dependency. We know our &lt;code&gt;CMS&lt;/code&gt; context depends on the &lt;code&gt;Accounts&lt;/code&gt; context, but it's important to avoid cyclic dependencies across our contexts. For example, imagine we changed our &lt;code&gt;Accounts.create_user&lt;/code&gt; function to:</source>
          <target state="translated">&lt;code&gt;Accounts.User&lt;/code&gt; 가 생성 될 때마다 &lt;code&gt;CMS.Author&lt;/code&gt; 가 존재 해야한다면 이 종속성을 어디에 둘지 신중하게 생각해야합니다. 우리는 &lt;code&gt;CMS&lt;/code&gt; 컨텍스트가 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트 에 의존한다는 것을 알고 있지만 컨텍스트 전반에 걸쳐 주기적 종속성을 피하는 것이 중요합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들어 &lt;code&gt;Accounts.create_user&lt;/code&gt; 함수를 다음과 같이 변경 했다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="cccbba4146b36292bb913e1fd8ea1a975c343691" translate="yes" xml:space="preserve">
          <source>If we take a look at the migration generated by &lt;code&gt;phx.gen.schema&lt;/code&gt; in &lt;code&gt;priv/repo/migrations&lt;/code&gt;, we'll see that it will add the columns we specified. It will also add timestamp columns for &lt;code&gt;inserted_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; which come from the &lt;code&gt;timestamps/0&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;priv/repo/migrations&lt;/code&gt; 에서 &lt;code&gt;phx.gen.schema&lt;/code&gt; 에 의해 생성 된 마이그레이션을 살펴보면 지정한 열이 추가된다는 것을 알 수 있습니다. 또한 대한 열을 타임 스탬프를 추가합니다 &lt;code&gt;inserted_at&lt;/code&gt; 과 &lt;code&gt;updated_at&lt;/code&gt; 으로부터 제공하는 &lt;code&gt;timestamps/0&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="fed57a6e9786d7b1c5f997cd519a04906343aa29" translate="yes" xml:space="preserve">
          <source>If we try to cast a user with an email of &quot;example.com&quot;, we should see an error message like the following.</source>
          <target state="translated">&quot;example.com&quot;이메일로 사용자를 전송하려고하면 다음과 같은 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1ffce6ccf0c01a85d91a8e6ee8f35c6af010a9b1" translate="yes" xml:space="preserve">
          <source>If we wanted to render an xml version of our &lt;code&gt;index&lt;/code&gt; action, we might implement the action like this in &lt;code&gt;lib/hello_web/page_controller.ex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 작업 의 xml 버전을 렌더링하려면 &lt;code&gt;lib/hello_web/page_controller.ex&lt;/code&gt; 에서 이와 같은 작업을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="091f04a57770ee0cadc0f3ebc7f970845f788a49" translate="yes" xml:space="preserve">
          <source>If we wanted to return some actions for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; we would implement &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; 에 대한 일부 작업을 반환 &lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; &lt;/a&gt; 과 같이 Plug.Exception 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="e3edc855d2066cbc7b5c91623476090fb897ebf1" translate="yes" xml:space="preserve">
          <source>If we wanted to supply a status of 404 for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt;, we could do it by defining an implementation for the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol like this:</source>
          <target state="translated">&lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; 에 대해 404 상태를 제공 하려면 &lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; &lt;/a&gt; 과 같이 Plug.Exception 프로토콜에 대한 구현을 정의하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87783d963f44ae589c50340ce6d86a8678d3af09" translate="yes" xml:space="preserve">
          <source>If we would like to be really specific about the content type, we can use &lt;code&gt;put_resp_content_type/2&lt;/code&gt; in conjunction with &lt;code&gt;send_resp/3&lt;/code&gt;.</source>
          <target state="translated">콘텐츠 유형에 대해 구체적 으로 &lt;code&gt;send_resp/3&lt;/code&gt; 와 함께 put_resp_content_type / &lt;code&gt;put_resp_content_type/2&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f54692a2228f2c183323a64714165cbc33696b0" translate="yes" xml:space="preserve">
          <source>If we would like to start our application and also have an &lt;code&gt;iex&lt;/code&gt; session open to it, we can run the mix task within &lt;code&gt;iex&lt;/code&gt; like this, &lt;code&gt;iex -S mix phx.server&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램을 시작하고 &lt;code&gt;iex&lt;/code&gt; 세션을 열고 &lt;code&gt;iex -S mix phx.server&lt;/code&gt; 와 같이 &lt;code&gt;iex&lt;/code&gt; 내에서 mix 작업을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f56a37255e0b43c2392f533494036f18e8e066b4" translate="yes" xml:space="preserve">
          <source>If you access these fields before fetching them, they will be returned as &lt;a href=&quot;plug.conn.unfetched&quot;&gt;&lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt;&lt;/a&gt; structs.</source>
          <target state="translated">가져 오기 전에 이러한 필드에 액세스하면 &lt;a href=&quot;plug.conn.unfetched&quot;&gt; &lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt; &lt;/a&gt; 구조체 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b68cb6ad948ac353881b8951cfd579c0c0ee1df4" translate="yes" xml:space="preserve">
          <source>If you already have a model, the generated model can be skipped with &lt;code&gt;--no-model&lt;/code&gt;. Read the documentation for &lt;code&gt;phoenix.gen.model&lt;/code&gt; for more information on attributes and namespaced resources.</source>
          <target state="translated">이미 모델이있는 경우 &lt;code&gt;--no-model&lt;/code&gt; 을 사용하여 생성 된 모델을 건너 뛸 수 있습니다 . 속성 및 네임 스페이스 리소스에 대한 자세한 내용 은 &lt;code&gt;phoenix.gen.model&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff739bec2c4393b5a6029990ea9ff518a68f23c" translate="yes" xml:space="preserve">
          <source>If you also want to send the response, use &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt; after this or use &lt;a href=&quot;#send_resp/3&quot;&gt;&lt;code&gt;send_resp/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답을 보내려면 이 후에 &lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt; 을 사용하거나 &lt;a href=&quot;#send_resp/3&quot;&gt; &lt;code&gt;send_resp/3&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="87f449e6752144346e8d0a47354146bcb5ebd1b4" translate="yes" xml:space="preserve">
          <source>If you are already familiar with Elixir, great! If not, there are a number of places to learn. The &lt;a href=&quot;https://elixir-lang.org/getting-started/introduction.html&quot;&gt;Elixir guides&lt;/a&gt; and the &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;Elixir learning resources page&lt;/a&gt; are two great places to start.</source>
          <target state="translated">이미 Elixir에 익숙하다면 좋습니다! 그렇지 않다면 배울 곳이 많이 있습니다. &lt;a href=&quot;https://elixir-lang.org/getting-started/introduction.html&quot;&gt;엘릭서 가이드&lt;/a&gt; 와 &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;비약 학습 자원 페이지는&lt;/a&gt; 시작이 개 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="a15c68af7f32e113d1ad81becc24e17ccf8d3c73" translate="yes" xml:space="preserve">
          <source>If you are coming from an older version of Phoenix, install the &lt;code&gt;:telemetry_metrics&lt;/code&gt; and &lt;code&gt;:telemetry_poller&lt;/code&gt; packages:</source>
          <target state="translated">이전 버전의 Phoenix에서 오는 경우 &lt;code&gt;:telemetry_metrics&lt;/code&gt; 및 &lt;code&gt;:telemetry_poller&lt;/code&gt; 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="195b289a7ef348736fb993f011aeccf45570b4ce" translate="yes" xml:space="preserve">
          <source>If you are comparing the username and password with existing strings, do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt;&lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">사용자 이름과 비밀번호를 기존 문자열과 비교하는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; 를&lt;/a&gt; 사용하지 마십시오 . 대신 &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt; &lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="660ef0380c716ac22c9348212079d101dfdf7227" translate="yes" xml:space="preserve">
          <source>If you are pushing events from a hook to a component, then you must pass an &lt;code&gt;element&lt;/code&gt;, created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt;, as first argument and it must point to a single element on the page with a &lt;code&gt;phx-target&lt;/code&gt; attribute in it:</source>
          <target state="translated">당신이 구성 요소에 후크에서 이벤트를 추진하는 경우에, 당신은 통과해야 &lt;code&gt;element&lt;/code&gt; 로 생성, &lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt; 첫 번째 인수로, 그리고 그것은있는 페이지에 하나의 요소를 지정해야합니다 &lt;code&gt;phx-target&lt;/code&gt; 그것에 속성 :</target>
        </trans-unit>
        <trans-unit id="c1445ed0a8505a52f1fc2ab343b225750d1c7d54" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should check if you are listing the desired formats in your &lt;code&gt;:accepts&lt;/code&gt; plug or if you are setting the proper accept header in the client. The exception contains the acceptable mime types in the &lt;code&gt;accepts&lt;/code&gt; field.</source>
          <target state="translated">이 오류가 표시되면 &lt;code&gt;:accepts&lt;/code&gt; 플러그 에 원하는 형식을 나열 하는지 또는 클라이언트에서 올바른 승인 헤더를 설정하고 있는지 확인해야합니다. 예외는 &lt;code&gt;accepts&lt;/code&gt; 필드 에 허용 가능한 MIME 유형을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="8befb119931680b815f371783bc72db7f010ea28" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should handle the error and surface it to the end user. It means that there is a parameter missing from the request.</source>
          <target state="translated">이 오류가 표시되면 오류를 처리하여 최종 사용자에게 표시해야합니다. 요청에서 누락 된 매개 변수가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8281d3b702b25fc319af701ce0fe42f100d16669" translate="yes" xml:space="preserve">
          <source>If you are sending data to a full URI, such as &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; or &lt;code&gt;//external.com/path&lt;/code&gt;, instead of a simple path such as &lt;code&gt;/path&lt;/code&gt;, you may want to consider using &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt;, as that will encode the host in the CSRF token. Once received, Plug will only consider the CSRF token to be valid if the &lt;code&gt;host&lt;/code&gt; encoded in the token is the same as the one in &lt;code&gt;conn.host&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/path&lt;/code&gt; 와 같은 간단한 경로 대신 &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; 또는 &lt;code&gt;//external.com/path&lt;/code&gt; 와 같은 전체 URI로 데이터를 전송하는 경우 &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 . CSRF 토큰으로 호스트를 인코딩합니다. 일단 수신되면 플러그는 토큰으로 인코딩 된 &lt;code&gt;host&lt;/code&gt; 가 &lt;code&gt;conn.host&lt;/code&gt; 의 호스트 와 동일한 경우에만 CSRF 토큰이 유효한 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="2860b8a98014af24457d97de2b8635d54397f121" translate="yes" xml:space="preserve">
          <source>If you are trying to debug transaction-related code while using &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt;, it may be more helpful to configure the database to log all statements and consult those logs.</source>
          <target state="translated">&lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; 를 사용하는 동안 트랜잭션 관련 코드를 디버깅하려는 경우 모든 명령문을 로그하고 해당 로그를 참조하도록 데이터베이스를 구성하는 것이 더 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57bf68c621982c91acd9cc4e5332c480370b66a" translate="yes" xml:space="preserve">
          <source>If you are using Phoenix v1.5, the layout is automatically set when generating apps with the &lt;code&gt;mix phx.new --live&lt;/code&gt; flag.</source>
          <target state="translated">Phoenix v1.5를 사용하는 경우 &lt;code&gt;mix phx.new --live&lt;/code&gt; 플래그를 사용하여 앱을 생성 할 때 레이아웃이 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d8aab708f551e6ce45eaa04e632f244694f2e5f" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; in tests, note that even though each test is inside a transaction, &lt;code&gt;in_transaction?/0&lt;/code&gt; will only return true inside transactions explicitly created with &lt;code&gt;transaction/2&lt;/code&gt;. This is done so the test environment mimics dev and prod.</source>
          <target state="translated">테스트 에서 &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; 를 사용하는 경우 각 테스트가 트랜잭션 내부에 &lt;code&gt;in_transaction?/0&lt;/code&gt; 은 &lt;code&gt;transaction/2&lt;/code&gt; 로 명시 적으로 작성된 트랜잭션 내에서만 true를 리턴합니다 . 이것은 테스트 환경이 dev와 prod를 모방하도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="942638ba1572b805045a6efb9c529e7e1a50d20b" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &quot;posts_tags&quot; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">당신이 관련된 제거하려고하면 &lt;code&gt;many_to_many&lt;/code&gt; 데이터를 &lt;strong&gt;(가) 스키마에 가입하고 목표 협회에서 결코에서 체외 항상 데이터를 제거합니다&lt;/strong&gt; 설정하여 수 없습니다 &lt;code&gt;:on_replace&lt;/code&gt; 을 에 &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:on_delete&lt;/code&gt; 에 &lt;code&gt;:delete_all&lt;/code&gt; 나 같은 변경 집합 기능을 사용하여 &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt; . 예를 들어, &lt;code&gt;Post&lt;/code&gt; 가 &lt;code&gt;Tag&lt;/code&gt; 와 다 대다 관계를 가지고있는 경우 &lt;code&gt;:on_delete&lt;/code&gt; 를 &lt;code&gt;:delete_all&lt;/code&gt; 로 설정 하면 &lt;code&gt;Post&lt;/code&gt; 가 삭제 된 경우 &quot;posts_tags&quot;테이블에서 항목 만 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3cbaa656dba938c685add2656722d0e125f277" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &amp;ldquo;posts_tags&amp;rdquo; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">당신이 관련된 제거하려고하면 &lt;code&gt;many_to_many&lt;/code&gt; 데이터를 &lt;strong&gt;(가) 스키마에 가입하고 목표 협회에서 결코에서 체외 항상 데이터를 제거합니다&lt;/strong&gt; 설정하여 수 없습니다 &lt;code&gt;:on_replace&lt;/code&gt; 을 에 &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:on_delete&lt;/code&gt; 에 &lt;code&gt;:delete_all&lt;/code&gt; 나 같은 변경 집합 기능을 사용하여 &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt; . 예를 들어 &lt;code&gt;Post&lt;/code&gt; 가 &lt;code&gt;Tag&lt;/code&gt; 와 다 대다 관계인 경우 &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; 을 설정 하면 &lt;code&gt;Post&lt;/code&gt; 가 삭제 된 경우&amp;ldquo;posts_tags&amp;rdquo;테이블에서 항목 만 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="33aeade4ec4114f6d64f05c0e4ded54c69c06049" translate="yes" xml:space="preserve">
          <source>If you attempt to write it as &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt;, Ecto won&amp;rsquo;t accept such query. However, the subquery above can be written as a JOIN, which is supported by Ecto. The final Ecto query will look like this:</source>
          <target state="translated">&lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt; 과 같이 쓰려고하면 Ecto는 그러한 쿼리를 허용하지 않습니다. 그러나 위의 하위 쿼리는 Ecto에서 지원하는 JOIN으로 작성할 수 있습니다. 최종 Ecto 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8aa7e8b7dfaa8e37915423085e7692433a23800a" translate="yes" xml:space="preserve">
          <source>If you decide to include the live-reload websocket, you should disable it when building for production.</source>
          <target state="translated">라이브 리로드 웹 소켓을 포함하기로 결정한 경우 프로덕션 용으로 빌드 할 때 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="de03b9d15dfe67c307158582293c4bcac372860e" translate="yes" xml:space="preserve">
          <source>If you do that, because &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is called once and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; multiple times, the &quot;post_id&quot; read on mount can get out of sync with the one in &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. So once a parameter is read on mount, it should not be read elsewhere. Instead, do this:</source>
          <target state="translated">그렇게하면 &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 이 한 번 호출되고 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; 이&lt;/a&gt; 여러 번 호출 되기 때문에 마운트시 읽은 &quot;post_id&quot;가 &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; 의 것과&lt;/a&gt; 동기화되지 않을 수 있습니다 . 따라서 마운트시 매개 변수를 읽은 후에는 다른 곳에서 읽어서는 안됩니다. 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="09cb3a84985c7f8fa4e8edcaba166f48f945bf96" translate="yes" xml:space="preserve">
          <source>If you don't have any Ecto schema pointing to the CTE table, you can pass a tuple with the CTE table name as first element and an Ecto schema as second element. This will cast the result rows to Ecto structs as long as the Ecto schema maps to the same fields in the CTE table:</source>
          <target state="translated">CTE 테이블을 가리키는 Ecto 스키마가없는 경우 첫 번째 요소로 CTE 테이블 이름을 사용하고 두 번째 요소로 Ecto 스키마를 사용하여 튜플을 전달할 수 있습니다. 이것은 Ecto 스키마가 CTE 테이블의 동일한 필드에 매핑되는 한 결과 행을 Ecto 구조체로 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="ae9c05c4fa4c6e476b09d8bdf327b4c5f082461f" translate="yes" xml:space="preserve">
          <source>If you find yourself in similar situations where you feel your use case is requiring you to create circular dependencies across contexts, it's a sign you need a new context in the system to handle these application requirements. In our case, what we really want is an interface that handles all requirements when a user is created or registers in our application. To handle this, we could create a &lt;code&gt;UserRegistration&lt;/code&gt; context, which calls into both the &lt;code&gt;Accounts&lt;/code&gt; and &lt;code&gt;CMS&lt;/code&gt; APIs to create a user, then associate a CMS author. Not only would this allow our Accounts to remain as isolated as possible, it gives us a clear, obvious API to handle &lt;code&gt;UserRegistration&lt;/code&gt; needs in the system. If you take this approach, you can also use tools like &lt;code&gt;Ecto.Multi&lt;/code&gt; to handle transactions across different context operations without deeply coupling the internal database calls. Part of our &lt;code&gt;UserRegistration&lt;/code&gt; API could look something like this:</source>
          <target state="translated">사용 사례가 컨텍스트 전반에 걸쳐 순환 종속성을 생성해야한다고 생각하는 유사한 상황에 처해 있다면 이러한 애플리케이션 요구 사항을 처리하기 위해 시스템에 새로운 컨텍스트가 필요하다는 신호입니다. 우리의 경우 우리가 정말로 원하는 것은 사용자가 생성되거나 애플리케이션에 등록 될 때 모든 요구 사항을 처리하는 인터페이스입니다. 이를 처리하기 위해 &lt;code&gt;Accounts&lt;/code&gt; 및 &lt;code&gt;CMS&lt;/code&gt; API를 모두 호출 하여 사용자를 생성 한 다음 CMS 작성자를 연결하는 &lt;code&gt;UserRegistration&lt;/code&gt; 컨텍스트를 생성 할 수 있습니다 . 이렇게하면 계정이 가능한 한 격리 된 상태로 유지 될뿐만 아니라 시스템에서 &lt;code&gt;UserRegistration&lt;/code&gt; 요구 사항 을 처리 할 수있는 명확하고 명확한 API가 제공 됩니다. 이 방법을 사용하면 다음과 같은 도구를 사용할 수도 있습니다. &lt;code&gt;Ecto.Multi&lt;/code&gt; 는 내부 데이터베이스 호출을 깊이 결합하지 않고 다양한 컨텍스트 작업에서 트랜잭션을 처리합니다. &lt;code&gt;UserRegistration&lt;/code&gt; API의 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6574eccc770115f525bad9e622976b6b343b2538" translate="yes" xml:space="preserve">
          <source>If you followed the &lt;a href=&quot;installation&quot;&gt;Installation Guide&lt;/a&gt; and opted to add &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; to your mix.exs, go ahead and do that now and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;installation&quot;&gt;설치 가이드&lt;/a&gt; 를 따르고 mix.exs 에 &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; 을 추가하기로 결정했다면 지금 수행하고 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; 을&lt;/a&gt; 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a9d40fe35c9851f255cc70728d792053cc95002" translate="yes" xml:space="preserve">
          <source>If you had previously installed &lt;code&gt;phoenix_live_view&lt;/code&gt; and want to get the latest javascript, then force an install with:</source>
          <target state="translated">이전에 &lt;code&gt;phoenix_live_view&lt;/code&gt; 를 설치 했고 최신 javascript를 얻으려면 다음을 사용하여 강제로 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="415aa01085c0f6d5805f0753fe7636a79914ccaf" translate="yes" xml:space="preserve">
          <source>If you have a session but the CSRF state was not loaded into the current process, you can dump the state from the session:</source>
          <target state="translated">세션이 있지만 CSRF 상태가 현재 프로세스에로드되지 않은 경우 세션에서 상태를 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e22a5ad3894018fe1345caf74da853417ec2369" translate="yes" xml:space="preserve">
          <source>If you have a single username and password, you can use the &lt;a href=&quot;#basic_auth/2&quot;&gt;&lt;code&gt;basic_auth/2&lt;/code&gt;&lt;/a&gt; plug:</source>
          <target state="translated">단일 사용자 이름과 비밀번호가있는 경우 &lt;a href=&quot;#basic_auth/2&quot;&gt; &lt;code&gt;basic_auth/2&lt;/code&gt; &lt;/a&gt; 플러그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cce78534925c37d789d5976c765183ee7b5d0b56" translate="yes" xml:space="preserve">
          <source>If you keep components mostly as an application concern with only the necessary assigns, it is unlikely you will run into issues related to stateful components.</source>
          <target state="translated">필요한 할당만으로 구성 요소를 응용 프로그램 문제로 유지하는 경우 상태 저장 구성 요소와 관련된 문제가 발생할 가능성이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0fdbca7cff696f9dab2f2e658e9f4fc49ebd8" translate="yes" xml:space="preserve">
          <source>If you need an escape hatch, Ecto provides fragments (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) to inject SQL (and non-SQL) fragments into queries.</source>
          <target state="translated">이스케이프 해치가 필요한 경우 Ecto는 조각 ( &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt; 참조 )을 제공하여 SQL (및 비 SQL) 조각을 쿼리에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="cf93aee615b214a79ea7379cb001c9b4d45fa541" translate="yes" xml:space="preserve">
          <source>If you need custom metrics and instrumentation in your application, you can utilize the &lt;code&gt;:telemetry&lt;/code&gt; package (&lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;https://hexdocs.pm/telemetry&lt;/a&gt;) just like your favorite frameworks and libraries.</source>
          <target state="translated">애플리케이션에 사용자 지정 메트릭 및 계측이 필요한 경우 즐겨 찾는 프레임 워크 및 라이브러리와 마찬가지로 &lt;code&gt;:telemetry&lt;/code&gt; 패키지 ( &lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;https://hexdocs.pm/telemetry&lt;/a&gt; )를 활용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43ecb1e3f8dbc11e08115c78cf6e2d60dbd4aefe" translate="yes" xml:space="preserve">
          <source>If you need custom options on the underlying field, you can define the field explicitly and then pass &lt;code&gt;define_field: false&lt;/code&gt; to &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">기본 필드에 사용자 정의 옵션이 필요한 경우 필드를 명시 적으로 정의한 다음 &lt;code&gt;define_field: false&lt;/code&gt; 를 &lt;code&gt;belongs_to&lt;/code&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd51ff6183de690e100505fa4969b12d1551fa2a" translate="yes" xml:space="preserve">
          <source>If you need to dynamically configure how &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt;&lt;/a&gt; behave, for example, based on the connection or another system parameter, one option is to create your own parser that wraps it:</source>
          <target state="translated">예를 들어 연결 또는 다른 시스템 매개 변수를 기반으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt; 의&lt;/a&gt; 작동 방식을 동적으로 구성해야하는 경우 한 가지 옵션은이를 래핑하는 자체 파서를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="109f5082f2f1b912050b16bb98f4693eba354f1f" translate="yes" xml:space="preserve">
          <source>If you need to guarantee the data in the returned struct mirrors the database, you have three options:</source>
          <target state="translated">리턴 된 구조체의 데이터가 데이터베이스를 미러링하도록 보장해야하는 경우 세 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2431436833d547a4e531dda09290f8abafed68" translate="yes" xml:space="preserve">
          <source>If you need to pass any extra values or metadata, such as the &quot;_target&quot; parameter, you can do so by giving a map under the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&quot;_target&quot;매개 변수와 같은 추가 값이나 메타 데이터를 전달해야하는 경우 &lt;code&gt;value&lt;/code&gt; 인수 아래에 맵을 제공하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e668d17ae58bad2b61910c084478c158d0fe3170" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also send a JavaScript script that immediately reloads the page.</source>
          <target state="translated">원하는 경우 페이지를 즉시 다시로드하는 JavaScript 스크립트를 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afadb98b6e75520436d2c696ca1b6f38804339a" translate="yes" xml:space="preserve">
          <source>If you visit the Welcome page, you should see the message from the layout.</source>
          <target state="translated">시작 페이지를 방문하면 레이아웃의 메시지가 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6194c95c25393c1533f24ca690885ddce3de29a4" translate="yes" xml:space="preserve">
          <source>If you want a map with only the selected fields to be returned. For more information, read the docs for &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt;&lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.query.api#map/2&quot;&gt;&lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택한 필드 만있는 맵을 반환하려는 경우. 자세한 정보는 &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt; &lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.query.api#map/2&quot;&gt; &lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt; 에&lt;/a&gt; 대한 문서를 읽으십시오. .</target>
        </trans-unit>
        <trans-unit id="b56c7f334ac00fd6eb86d51a4d425fe63a22845f" translate="yes" xml:space="preserve">
          <source>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</source>
          <target state="translated">부울 속성을 그대로 보내려면이를 명시 적으로 문자열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8b342259d40c75d399fa621d7ba14972e56c66" translate="yes" xml:space="preserve">
          <source>If you want the latest features, install from GitHub:</source>
          <target state="translated">최신 기능을 원하면 GitHub에서 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="71958648bc2ee1d3c516f077771f912b56470ab5" translate="yes" xml:space="preserve">
          <source>If you want to configure the years range:</source>
          <target state="translated">연도 범위를 구성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="eaaf4a6e48637b0f1ace60064563e26ec60604dd" translate="yes" xml:space="preserve">
          <source>If you want to do so in a case-by-case basis, you can define a custom function that gets the endpoint URI configuration and changes it accordingly. For example, to get the current URL always in HTTPS format:</source>
          <target state="translated">사례별로 그렇게하려면 끝점 URI 구성을 가져와 그에 따라 변경하는 사용자 지정 함수를 정의 할 수 있습니다. 예를 들어 현재 URL을 항상 HTTPS 형식으로 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="3267ec97b69bd134a5f100a8b20b7af9c4d6bdb9" translate="yes" xml:space="preserve">
          <source>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of &lt;code&gt;use Phoenix.Controller&lt;/code&gt;.</source>
          <target state="translated">컨트롤러를 완전히 구현하지 않고 연결을 조작하는 기능을 &lt;code&gt;use Phoenix.Controller&lt;/code&gt; 대신 두 모듈을 직접 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e505240a0d781b16ebb52afdcfed3cf74a91017d" translate="yes" xml:space="preserve">
          <source>If you want to include the seconds field (hidden by default), pass &lt;code&gt;second: []&lt;/code&gt;:</source>
          <target state="translated">초 필드를 포함하려면 (기본적으로 숨겨 짐) 초를 전달하십시오 &lt;code&gt;second: []&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebd7ac9e06dec198b102f467e0d5a2146add7ac" translate="yes" xml:space="preserve">
          <source>If you want to instrument a piece of code, but the endpoint that should instrument it (the one that contains the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro you want to use) is not known at compile time, only at runtime, you can use the &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt;&lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt;&lt;/a&gt; macro. Refer to its documentation for more information.</source>
          <target state="translated">코드를 계측하려고하지만이를 계측해야하는 엔드 포인트 ( 사용하려는 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로 가 포함 된 엔드 포인트 )를 컴파일 타임에 알 수없는 경우 런타임에만 &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt; &lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다. . 악기 / 4 매크로. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49cb9f6ec274ce3774fca3bdf01b6ff3edaab5ff" translate="yes" xml:space="preserve">
          <source>If you want to make your new mix task to use your application's infrastructure, you need to make sure the application is started when mix task is being executed. This is particularly useful if you need to access your database from within the mix task. Thankfully, mix makes it really easy for us:</source>
          <target state="translated">애플리케이션의 인프라를 사용하기 위해 새 혼합 태스크를 만들려면 혼합 태스크가 실행될 때 애플리케이션이 시작되는지 확인해야합니다. 이것은 혼합 작업 내에서 데이터베이스에 액세스해야하는 경우 특히 유용합니다. 고맙게도 mix는 우리에게 정말 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f18f35976119bb4fe304e144acc1ed9a4b56600a" translate="yes" xml:space="preserve">
          <source>If you want to provide your own authentication logic on top of Basic HTTP auth, you can use the low-level functions. As an example, we define &lt;code&gt;:auth&lt;/code&gt; plug that extracts username and password from the request headers, compares them against the database, and either assigns a &lt;code&gt;:current_user&lt;/code&gt; on success or responds with an error on failure.</source>
          <target state="translated">기본 HTTP 인증 위에 고유 한 인증 로직을 제공하려는 경우 하위 수준 기능을 사용할 수 있습니다. 예를 들어, 요청 헤더에서 사용자 이름과 비밀번호를 추출하여 데이터베이스와 비교하고 성공시 &lt;code&gt;:current_user&lt;/code&gt; 를 할당 하거나 실패시 오류로 응답 하는 &lt;code&gt;:auth&lt;/code&gt; 플러그를 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ec5f40c77fd66ea84bc6ba36f0c2a7c3fe56b0a" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application.</source>
          <target state="translated">Ecto를 사용하여 샘플 애플리케이션을 빠르게 확인하려면 &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;시작 안내서&lt;/a&gt; 및 함께 제공되는 샘플 애플리케이션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c4123984bcd758a7753f404a92fb713daeb010c8" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto's README&lt;/a&gt; also links to other resources.</source>
          <target state="translated">Ecto를 사용하여 샘플 애플리케이션을 빠르게 확인하려면 &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;시작 안내서&lt;/a&gt; 와 함께 제공되는 샘플 애플리케이션을 확인하십시오. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto의 README&lt;/a&gt; 는 다른 리소스에도 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="5268cb204fe6237fdb4702e54e332bbb4778e707" translate="yes" xml:space="preserve">
          <source>If you want to render a template within the same view, you can skip the view name, and simply call &lt;code&gt;render(&quot;test.html&quot;, message: &quot;Hello from sibling template!&quot;)&lt;/code&gt; instead. For example, open up &lt;code&gt;lib/hello_web/templates/page/index.html.eex&lt;/code&gt; and add this at the top:</source>
          <target state="translated">동일한 뷰 내에서 템플릿을 렌더링하려면 뷰 이름을 건너 뛰고 대신 &lt;code&gt;render(&quot;test.html&quot;, message: &quot;Hello from sibling template!&quot;)&lt;/code&gt; 호출하면 됩니다. 예를 들어 &lt;code&gt;lib/hello_web/templates/page/index.html.eex&lt;/code&gt; 를 열고 맨 위에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="78c050fecd9ef681ce1f0f4d13cfe35bf4a562b4" translate="yes" xml:space="preserve">
          <source>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</source>
          <target state="translated">주어진 프로젝트의 관리자와 같이 데이터베이스에서 제공되는 옵션을 선택하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="752842436fbd52f5e0a837820a12e2cf6d06f8ef" translate="yes" xml:space="preserve">
          <source>If you want to show a progress bar as users perform live actions, we recommend using &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt;&lt;code&gt;nprogress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자가 실시간 작업을 수행 할 때 진행률 표시 줄을 표시하려면 &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt; &lt;code&gt;nprogress&lt;/code&gt; 를&lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="da18100304362b3e3927019df152258ff3ba53bb" translate="yes" xml:space="preserve">
          <source>If you want to start a separate LiveView from within a LiveView, then you can call &lt;code&gt;live_render/3&lt;/code&gt; instead of &lt;code&gt;render/3&lt;/code&gt;. This child LiveView runs in a separate process than the parent, with its own &lt;code&gt;mount&lt;/code&gt; and &lt;code&gt;handle_event&lt;/code&gt; callbacks. If a child LiveView crashes, it won't affect the parent. If the parent crashes, all children are terminated.</source>
          <target state="translated">당신은 라이브 뷰 내에서 별도의 라이브 뷰를 시작하려면, 당신은 호출 할 수있는 &lt;code&gt;live_render/3&lt;/code&gt; 대신 &lt;code&gt;render/3&lt;/code&gt; . 이 하위 LiveView는 자체 &lt;code&gt;mount&lt;/code&gt; 및 &lt;code&gt;handle_event&lt;/code&gt; 콜백을 사용하여 상위와 별도의 프로세스에서 실행됩니다 . 하위 LiveView가 충돌하더라도 상위에 영향을주지 않습니다. 부모가 충돌하면 모든 자식이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e2240497996f5c5fe18575f06718f0c34d8a4556" translate="yes" xml:space="preserve">
          <source>If you want to support a given engine only on a certain template, you can pass it as an option on &lt;code&gt;use Phoenix.Template&lt;/code&gt;:</source>
          <target state="translated">특정 템플릿에서만 주어진 엔진을 지원 &lt;code&gt;use Phoenix.Template&lt;/code&gt; 옵션으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cdb64fa51ca4fb8866fc361686b367dbcbe98f6" translate="yes" xml:space="preserve">
          <source>If you want to target another component, you can also pass an ID or a class selector to any element inside the targeted component. For example, if there is a &lt;code&gt;UserComponent&lt;/code&gt; with the DOM ID of &lt;code&gt;user-13&lt;/code&gt;, using a query selector, we can send an event to it with:</source>
          <target state="translated">다른 구성 요소를 대상으로 지정하려는 경우 대상 구성 요소 내의 모든 요소에 ID 또는 클래스 선택기를 전달할 수도 있습니다. 예를 들어 DOM ID가 &lt;code&gt;user-13&lt;/code&gt; 인 &lt;code&gt;UserComponent&lt;/code&gt; 가있는 경우 쿼리 선택기를 사용하여 다음과 같이 이벤트를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e59309dd05a76fcd32896400f87305ec18e206" translate="yes" xml:space="preserve">
          <source>If you want to test how components are mounted by a LiveView and interact with DOM events, you can use the regular &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt; macro to build the LiveView with the component and then scope events by passing the view and a &lt;strong&gt;DOM selector&lt;/strong&gt; in a list:</source>
          <target state="translated">구성 요소가 LiveView에 의해 마운트되고 DOM 이벤트와 상호 작용하는 방법을 테스트하려면 일반 &lt;a href=&quot;#live/2&quot;&gt; &lt;code&gt;live/2&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 구성 요소로 LiveView를 빌드 한 다음 목록에서 보기 및 &lt;strong&gt;DOM 선택기&lt;/strong&gt; 를 전달하여 이벤트 범위를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0f98f30cf1d08e9178e85581a80a56cb8d7d157" translate="yes" xml:space="preserve">
          <source>If you would prefer to read these guides as an EPUB &lt;a href=&quot;phoenix.epub&quot;&gt;click here!&lt;/a&gt;</source>
          <target state="translated">이 가이드를 EPUB로 읽고 싶다면 &lt;a href=&quot;phoenix.epub&quot;&gt;여기를 클릭하세요!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6906d4bf644df48b3f0c419b3abf27f44bf197a2" translate="yes" xml:space="preserve">
          <source>If you would prefer to simply merge two multis together, see &lt;a href=&quot;#append/2&quot;&gt;&lt;code&gt;append/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#prepend/2&quot;&gt;&lt;code&gt;prepend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단순히 두 개의 멀티를 합치려면 &lt;a href=&quot;#append/2&quot;&gt; &lt;code&gt;append/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#prepend/2&quot;&gt; &lt;code&gt;prepend/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2467d576cbf855c8ae9348c4a47fdcb13145270e" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header.</source>
          <target state="translated">Plug 애플리케이션이 HTTPS를 처리하는 프록시 뒤에있는 경우 Plug에 &lt;code&gt;x-forwarded-*&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 지시해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="906016b8afe13d5670e52576993026f7d29c208a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">Plug 애플리케이션이 HTTPS를 처리하는 프록시 뒤에있는 경우 Plug에 &lt;code&gt;x-forwarded-*&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 지시해야 할 수 있습니다 . &lt;code&gt;:rewrite_on&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffa6a80acbf97635e0ac507b93d5063cd5b0d16a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you will need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-proto&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">플러그 응용 프로그램이 HTTPS를 처리하는 프록시 뒤에있는 경우 플러그가 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 지시해야합니다 . &lt;code&gt;:rewrite_on&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 옵션을 .</target>
        </trans-unit>
        <trans-unit id="4ee22e439b0d72c012e013a54bdd332f454b15e8" translate="yes" xml:space="preserve">
          <source>If your adapter is only able to respond to one or a couple of the query functions, add custom implementations of those functions directly to the Repo by using &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt;&lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">어댑터가 쿼리 함수 중 하나 또는 두 개에만 응답 할 수있는 경우 대신 &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt; &lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 해당 함수의 사용자 지정 구현을 Repo에 직접 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ea11ef400e8f5b84f516d039032b014e672598" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application's supervisor:</source>
          <target state="translated">애플리케이션이 감독자와 함께 생성 된 경우 ( &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt; 를 전달 하여) 감독자를 정의하고 시작하는 애플리케이션 시작 콜백이 포함 된 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 파일이 생성됩니다. 애플리케이션의 감독자에서 감독자로 저장소를 시작 하려면 &lt;code&gt;start/2&lt;/code&gt; 함수 를 편집하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e64da7625aab0af6dfae19c9bbd8cef653814d79" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application&amp;rsquo;s supervisor:</source>
          <target state="translated">응용 프로그램이 수퍼바이저로 생성 된 경우 ( &lt;code&gt;--sup&lt;/code&gt; 을 &lt;code&gt;mix new&lt;/code&gt; 로 혼합 하여 전달 ) 수퍼바이저를 정의하고 시작하는 응용 프로그램 시작 콜백이 포함 된 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 파일이 있습니다. 응용 프로그램의 수퍼바이저에서 repo를 수퍼바이저로 시작 하려면 &lt;code&gt;start/2&lt;/code&gt; 기능 만 편집하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="9963b98e0a632c06b03f38938368cd7af1095618" translate="yes" xml:space="preserve">
          <source>If your data layer supports embedding or nested associations, you can use &lt;code&gt;inputs_for&lt;/code&gt; to attach nested data to the form.</source>
          <target state="translated">데이터 계층에서 임베드 또는 중첩 연관을 지원하는 경우 &lt;code&gt;inputs_for&lt;/code&gt; 를 사용 하여 중첩 된 데이터를 양식에 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3f651a489e53e22ef5bfd5ad5ccb20a85f41ce" translate="yes" xml:space="preserve">
          <source>If your primary key is not named &amp;ldquo;id&amp;rdquo; (e.g. if you are working with a legacy database), you can use the &lt;code&gt;@primary_key&lt;/code&gt; attribute to configure your key name using the &lt;code&gt;source&lt;/code&gt; option. For example, the following attribute defines an integer primary key named &lt;code&gt;legacy_id&lt;/code&gt; which is automatically incremented by the database:</source>
          <target state="translated">기본 키의 이름이 &quot;id&quot;가 아닌 경우 (예 : 레거시 데이터베이스로 작업하는 경우) &lt;code&gt;@primary_key&lt;/code&gt; 속성을 사용하여 &lt;code&gt;source&lt;/code&gt; 옵션을 사용하여 키 이름을 구성 할 수 있습니다 . 예를 들어 다음 속성은 &lt;code&gt;legacy_id&lt;/code&gt; 라는 정수 기본 키를 정의합니다. 데이터베이스에 의해 자동으로 증가하는 합니다.</target>
        </trans-unit>
        <trans-unit id="f30aa9bbf518465faa2ed1f37bfe76b59f3c62b2" translate="yes" xml:space="preserve">
          <source>If your screen looks like the image above, congratulations! You now have a working Phoenix application. In case you can't see the page above, try accessing it via &lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt; and later make sure your OS has defined &quot;localhost&quot; as &quot;127.0.0.1&quot;.</source>
          <target state="translated">화면이 위의 이미지와 같으면 축하합니다! 이제 작동하는 Phoenix 응용 프로그램이 있습니다. 위의 페이지를 볼 수없는 경우 &lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt; 을 통해 액세스 하고 나중에 OS가 &quot;localhost&quot;를 &quot;127.0.0.1&quot;로 정의했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c262a06dde1c92c1b642e458f52da921424c961b" translate="yes" xml:space="preserve">
          <source>If your socket is implemented using &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, you can also pass to each transport above all options accepted on &lt;code&gt;use Phoenix.Socket&lt;/code&gt;. An option given here will override the value in &lt;code&gt;use Phoenix.Socket&lt;/code&gt;.</source>
          <target state="translated">소켓이 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현 된 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 허용되는 모든 옵션보다 각 전송에 전달할 수도 있습니다 . 여기에 제공된 옵션은 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a7f718c136252a6132fe7a1aa2ed7beedb600c13" translate="yes" xml:space="preserve">
          <source>If your table is partitioned, then your unique index might look different per partition, e.g. Postgres adds p&amp;lt;number&amp;gt; to the middle of your key, like:</source>
          <target state="translated">테이블이 분할 된 경우 고유 인덱스가 파티션마다 다르게 보일 수 있습니다. 예를 들어 Postgres는 다음과 같이 키 중간에 p &amp;lt;number&amp;gt;를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a69fedcf99422ab483c859e4efba05a441aa355" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unecessarily complex. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Post에 많은 주석이 있고 기존 게시물에 새 주석을 추가하려는 관계를 상상해보십시오. 이를 위해 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용할 수는 있지만 불필요하게 복잡합니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="b9e00b21da4725e0255aeee1974fcbd6702ec96c" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unnecessarily complex. Let's see an example.</source>
          <target state="translated">게시물에 많은 댓글이 있고 기존 게시물에 새 댓글을 추가하려는 관계를 상상해보십시오. 이를 위해 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있지만 불필요하게 복잡합니다. 예를 봅시다.</target>
        </trans-unit>
        <trans-unit id="eab9f45cd5235d2ab5cef0f88fd7c2ff360cc9db" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where LiveView represents a board with each card in it as a separate component. Each card has a form that allows to update its title directly in the component. We will see how to organize the data flow keeping either the view or the component as the source of truth.</source>
          <target state="translated">LiveView가 각 카드가 별도의 구성 요소로 포함 된 보드를 나타내는 시나리오를 상상해보십시오. 각 카드에는 구성 요소에서 직접 제목을 업데이트 할 수있는 양식이 있습니다. 뷰 또는 구성 요소를 진실의 소스로 유지하면서 데이터 흐름을 구성하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a9a80fa7e20b6ec638558d87fd5e8f1b2c820f57" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;handle_in/3&lt;/code&gt; inside a channel:</source>
          <target state="translated">채널 내부에 다음 &lt;code&gt;handle_in/3&lt;/code&gt; 을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="d7eaef0786d3c2d56724df9325bdf3c6d03a3696" translate="yes" xml:space="preserve">
          <source>Imagine the following Ecto schemas:</source>
          <target state="translated">다음 Ecto 스키마를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="69ed1238c0e40ec582e839a9be87906ea6d1bb56" translate="yes" xml:space="preserve">
          <source>Imagine the following plug:</source>
          <target state="translated">다음 플러그를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="6ca34da07d3e254b51321106a99af217f3cef8f8" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let&amp;rsquo;s imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">게시물에 연결하려는 태그 세트를 수신한다고 가정하십시오. 이러한 태그가 선결제로 존재하며 모두 데이터베이스에 유지된다고 가정 해 봅시다. 이 형식으로 데이터를 얻는다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="07174bed3e1206960783f2a30e60773792599d44" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let's imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">게시물에 연결하려는 일련의 태그를 받고 있다고 상상해보십시오. 이러한 태그가 사전에 존재하고 모두 데이터베이스에 유지된다고 가정 해 보겠습니다. 다음 형식으로 데이터를 얻는다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="626b97593e67500eea59fda38eaa3e41d970c5ff" translate="yes" xml:space="preserve">
          <source>Imagine you have a LiveView that redirects on a &lt;code&gt;render_click&lt;/code&gt; event. You can make it sure it immediately redirects after the &lt;code&gt;render_click&lt;/code&gt; action by calling &lt;a href=&quot;#follow_redirect/3&quot;&gt;&lt;code&gt;follow_redirect/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;render_click&lt;/code&gt; 이벤트 를 리디렉션하는 LiveView가 있다고 가정 해보십시오 . &lt;a href=&quot;#follow_redirect/3&quot;&gt; &lt;code&gt;follow_redirect/3&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;render_click&lt;/code&gt; 작업 후 즉시 리디렉션되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="224f74e1875d15da71996dc37aae640fe78641d1" translate="yes" xml:space="preserve">
          <source>Imagine you have a schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">&lt;code&gt;has_many :comments&lt;/code&gt; 연관 이있는 스키마 &lt;code&gt;Post&lt;/code&gt; 가 있고 다음 쿼리를 실행 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="37ae5ef9b11c014505c58d928130e9d937a57895" translate="yes" xml:space="preserve">
          <source>Imagine you have an schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">&lt;code&gt;has_many :comments&lt;/code&gt; 연관 이있는 스키마 &lt;code&gt;Post&lt;/code&gt; 가 있고 다음 쿼리를 실행 한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="911d5cbc4bd74830db2cf2e8c805fa896d8b4ab3" translate="yes" xml:space="preserve">
          <source>Imagine you have the following action in your controller:</source>
          <target state="translated">컨트롤러에 다음과 같은 동작이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c3bcbecb37fb60e6f6b4d98aea0398cac118f78f" translate="yes" xml:space="preserve">
          <source>Imagine you want to encode the ID so they cannot enumerate the content in your application. An Ecto type could handle the conversion between the encoded version of the id and its representation in the database. For the sake of simplicity we'll use base64 encoding in this example:</source>
          <target state="translated">애플리케이션의 콘텐츠를 열거 할 수 없도록 ID를 인코딩한다고 가정 해보십시오. Ecto 유형은 ID의 인코딩 된 버전과 데이터베이스의 해당 표현 간의 변환을 처리 할 수 ​​있습니다. 간단하게하기 위해이 예제에서는 base64 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d1656f1d578045bfea05e6c6a2237b5d6e0a2f9f" translate="yes" xml:space="preserve">
          <source>Imagine you want to implement a chat application with LiveView. You could render each message like this:</source>
          <target state="translated">LiveView를 사용하여 채팅 응용 프로그램을 구현한다고 가정 해보십시오. 다음과 같이 각 메시지를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15e74fb2e9144b4fc1c6e2f7edb9692fba7939fe" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn&amp;rsquo;t an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">URL 단축 서비스에서 스키마의 일부로 URI 구조체를 저장한다고 가정합니다. 런타임시 해당 값을 지원하기위한 Ecto 필드 유형이 없으므로 사용자 정의 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="172eb5a1f40be1a000419ab4add75a6dc3be204b" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn't an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">URL 단축 서비스에서 스키마의 일부로 URI 구조체를 저장한다고 가정 해보십시오. 런타임에 해당 값을 지원하는 Ecto 필드 유형이 없으므로 사용자 지정 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1e1dad2bc8d9075bbf5f98838633808ebc9eb469" translate="yes" xml:space="preserve">
          <source>Imagine your application is configured to run on &quot;example.com&quot; but after the user signs in, you want all links to use &quot;some_user.example.com&quot;. You can do so by setting the proper router url configuration:</source>
          <target state="translated">애플리케이션이 &quot;example.com&quot;에서 실행되도록 구성되어 있지만 사용자가 로그인 한 후 모든 링크가 &quot;some_user.example.com&quot;을 사용하도록한다고 가정 해보십시오. 적절한 라우터 URL 구성을 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dd83f3829baa0b9a2d40da3d590f7c9d0db3a5ca" translate="yes" xml:space="preserve">
          <source>Implementing a Tracker</source>
          <target state="translated">트래커 구현</target>
        </trans-unit>
        <trans-unit id="3d6c2a38d322d3d763e854f7651b3495dd090632" translate="yes" xml:space="preserve">
          <source>Implementing the transport behaviour</source>
          <target state="translated">전송 동작 구현</target>
        </trans-unit>
        <trans-unit id="058fd7ed1c45697b86ef3cd0718d7bbfbe7580e9" translate="yes" xml:space="preserve">
          <source>Implementing your own adapter</source>
          <target state="translated">자신의 어댑터 구현</target>
        </trans-unit>
        <trans-unit id="eeaf0d0aa80addf9bcd22d809311b4d22bbca34c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we will see the following warnings in our logs, and our application will error when trying to execute the function.</source>
          <target state="translated">중요 :이 작업을 수행하지 않으면 로그에 다음 경고가 표시되고 함수를 실행하려고 할 때 응용 프로그램에서 오류가 발생합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="0de9ddaf0c21afc63217f2c5ffe75bfdc4b6cd3c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we'll get the following warning in our logs and the application will error when attempting to load the page:</source>
          <target state="translated">중요 : 이렇게하지 않으면 로그에 다음 경고가 표시되고 페이지를로드하려고 할 때 애플리케이션에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0c929d75f4d94fd8fe1c260cbfd2b081155e7fe" translate="yes" xml:space="preserve">
          <source>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</source>
          <target state="translated">Ecto에서는이 문제를 해결하는 세 가지 방법이 있습니다. 가장 간단한 방법은 주석 스키마에서 각 연관마다 하나씩 여러 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2da5549fe6372ba474a6b84ff8f0aa9b971f280a" translate="yes" xml:space="preserve">
          <source>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</source>
          <target state="translated">LiveView 테스트에서는 브라우저 대신 프로세스 통신을 통해 뷰와 상호 작용합니다. 브라우저와 마찬가지로 테스트 프로세스는 LiveView와 그 자식의 수명주기와 동작을 테스트하기 위해 어설 션 할 수있는 뷰에서 렌더링 된 업데이트에 대한 메시지를받습니다.</target>
        </trans-unit>
        <trans-unit id="382006685c4bc65202ab7101130f82fd90eb1bb5" translate="yes" xml:space="preserve">
          <source>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</source>
          <target state="translated">SQL에서 COALESCE는 여러 인수를 사용하지만 ecto에서는 두 개만 필요하므로 동일한 효과를 얻으려면 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae8d00a4f35aea9b1e600a76e95f40be1762a98" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;code&gt;builder_opts()&lt;/code&gt; allows us to pass the options given when initializing the router to a &lt;code&gt;dispatch&lt;/code&gt;.</source>
          <target state="translated">간단히 말해서 &lt;code&gt;builder_opts()&lt;/code&gt; 는 라우터를 초기화 할 때 주어진 옵션을 &lt;code&gt;dispatch&lt;/code&gt; 에 전달할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="b09256d570841fbfb45d7851451305f20a0625cb" translate="yes" xml:space="preserve">
          <source>In addition to a certificate, an HTTPS server needs a secure TLS protocol configuration. &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; always sets the following options:</source>
          <target state="translated">인증서 외에도 HTTPS 서버에는 보안 TLS 프로토콜 구성이 필요합니다. &lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; 은&lt;/a&gt; 항상 다음 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0a6f8049b39704e81ebed2652617e08d77f57235" translate="yes" xml:space="preserve">
          <source>In addition to inserts, we can also perform updates and deletes with &lt;code&gt;Repo.update/1&lt;/code&gt; and &lt;code&gt;Repo.delete/1&lt;/code&gt; to update or delete a single schema. Ecto also supports bulk persistence with the &lt;code&gt;Repo.insert_all&lt;/code&gt;, &lt;code&gt;Repo.update_all&lt;/code&gt;, and &lt;code&gt;Repo.delete_all&lt;/code&gt; functions.</source>
          <target state="translated">삽입 외에도 &lt;code&gt;Repo.update/1&lt;/code&gt; 및 &lt;code&gt;Repo.delete/1&lt;/code&gt; 을 사용하여 업데이트 및 삭제를 수행하여 단일 스키마를 업데이트하거나 삭제할 수 있습니다. Ecto는 &lt;code&gt;Repo.insert_all&lt;/code&gt; , &lt;code&gt;Repo.update_all&lt;/code&gt; 및 &lt;code&gt;Repo.delete_all&lt;/code&gt; 함수를 사용하여 대량 지속성을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="9ac9085e5b012c8583c70779624f050d5eb103a2" translate="yes" xml:space="preserve">
          <source>In addition to pushing messages out when you receive a &lt;code&gt;handle_in&lt;/code&gt; event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</source>
          <target state="translated">&lt;code&gt;handle_in&lt;/code&gt; 이벤트 를 수신 할 때 메시지를 푸시하는 것 외에도 요청 / 응답 스타일 메시징을 위해 클라이언트 이벤트에 직접 응답 할 수도 있습니다. 클라이언트가 작업 결과를 알아야하거나 단순히 메시지를 ack해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a42c2c570e4795fcc36b32e73f177e0d5b29e6e2" translate="yes" xml:space="preserve">
          <source>In addition to selecting a group of ciphers, selecting a cipher suite will also disable client renegotiation and force the client to honor the server specified cipher order.</source>
          <target state="translated">암호 그룹을 선택하는 것 외에도 암호 그룹을 선택하면 클라이언트 재협상이 비활성화되고 클라이언트가 서버에서 지정한 암호 순서를 따르도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="01ea8672f27177207c552fb1a1c80ac011412a23" translate="yes" xml:space="preserve">
          <source>In addition, both profiles:</source>
          <target state="translated">또한 두 프로필은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14f7eb8892415ea0c1aacaa32e064c3934506b5b" translate="yes" xml:space="preserve">
          <source>In all cases, each assign in the template will be accessible as &lt;code&gt;@assign&lt;/code&gt;. You can learn more about &lt;a href=&quot;assigns-eex&quot;&gt;assigns and LiveEEx templates in their own guide&lt;/a&gt;.</source>
          <target state="translated">모든 경우에 템플릿의 각 할당은 &lt;code&gt;@assign&lt;/code&gt; 로 액세스 할 수 있습니다 . &lt;a href=&quot;assigns-eex&quot;&gt;자신의 가이드에서 할당 및 LiveEEx 템플릿에&lt;/a&gt; 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e048396b52227039210be32cd7f7739a9bd6e4a9" translate="yes" xml:space="preserve">
          <source>In all examples so far we have used the &lt;strong&gt;keywords query syntax&lt;/strong&gt; to create a query:</source>
          <target state="translated">지금까지 모든 예제에서 &lt;strong&gt;키워드 query 구문&lt;/strong&gt; 을 사용하여 쿼리를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="39c6142f3ef45ee877e9c272f4bb4ce3244f2b98" translate="yes" xml:space="preserve">
          <source>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</source>
          <target state="translated">어쨌든 스키마의 제공 여부에 관계없이 Ecto 쿼리는 바인딩 시스템 덕분에 항상 컴포지션 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a15d51ecf5a44207426a5880570278383d07dd49" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; will be called with the &quot;say_hello&quot; event. When &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; is called for a component, only the diff of the component is sent to the client, making them extremely efficient.</source>
          <target state="translated">두 경우 모두 &quot;say_hello&quot;이벤트와 함께 &lt;a href=&quot;#c:handle_event/3&quot;&gt; &lt;code&gt;handle_event/3&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 때 &lt;a href=&quot;#c:handle_event/3&quot;&gt; &lt;code&gt;handle_event/3&lt;/code&gt; &lt;/a&gt; 구성 요소에 대한 호출 구성 요소 만은 diff는 그들을 매우 효율적 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d5f38f557b90ac2d42e6a751598f4d8bbba9025c" translate="yes" xml:space="preserve">
          <source>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the &lt;code&gt;:id&lt;/code&gt; type with &lt;code&gt;:autogenerate&lt;/code&gt;, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</source>
          <target state="translated">두 경우 모두, 두 유형 모두 기본 어댑터 / 데이터베이스에 의해 지정된 의미를 갖습니다. 당신이 사용하는 경우 &lt;code&gt;:id&lt;/code&gt; 와 유형 &lt;code&gt;:autogenerate&lt;/code&gt; , 데이터베이스가 ID의 자동 생성에 대한 책임을 의미합니다. 자동 증분되는 관계형 데이터베이스의 기본 키의 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e64dc292736835c5a534ec38dce0f0304db068" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &quot;callback&quot;, but may be configured with the callback option.</source>
          <target state="translated">JSON 응답이 반환되는 경우 콜백 필드가 쿼리 문자열에있는 한 JSONP로 변환됩니다. 콜백 필드 자체의 기본값은 &quot;콜백&quot;이지만 콜백 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82af51d52f0d5e198a5e7d698f02d79e495b27b9" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &amp;ldquo;callback&amp;rdquo;, but may be configured with the callback option.</source>
          <target state="translated">JSON 응답이 반환되는 경우 콜백 필드가 쿼리 문자열에있는 한 JSONP로 변환됩니다. 콜백 필드 자체의 기본값은 &quot;콜백&quot;이지만 콜백 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce9be04157216a7cdb190a3b918523e8aca6731" translate="yes" xml:space="preserve">
          <source>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</source>
          <target state="translated">변경 세트가 제공되는 경우 변경 세트의 변경 사항이 구조체 필드와 병합되고 모든 변경 사항이 데이터베이스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="83a2e40171803838a9ad2e6d9d64ac8dc619d36d" translate="yes" xml:space="preserve">
          <source>In case a previous layout is set, &lt;code&gt;put_root_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">이전 레이아웃이 설정된 경우 &lt;code&gt;put_root_layout&lt;/code&gt; 은 문자열 또는 원자로 제공되는 레이아웃 이름도 허용합니다. 문자열 인 경우 형식을 포함해야합니다. atom을 전달하면 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 의 템플릿과 유사한 렌더링 시간에 레이아웃 형식이 발견됩니다 . &lt;code&gt;false&lt;/code&gt; 로 설정할 수도 있습니다 . 이 경우 레이아웃이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e804f9ad9af0ffc381cba4d6aa6307ec8f5528fa" translate="yes" xml:space="preserve">
          <source>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</source>
          <target state="translated">구조체가 제공되는 경우 구조체는 변경이 아닌 모든 필드를 변경 세트의 일부로 변경 세트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c3cb35e3a5542760b8bd73c40248a0ad353cdacc" translate="yes" xml:space="preserve">
          <source>In case an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; given as any of the field values by the user, it will be sent to the adapter as a tuple with in the shape of &lt;code&gt;{query, params}&lt;/code&gt;.</source>
          <target state="translated">사용자가 필드 값으로 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 를&lt;/a&gt; 제공 한 경우 &lt;code&gt;{query, params}&lt;/code&gt; 형태의 튜플 형태로 어댑터에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="24b15538982d59e2053fe7e9d8eaeadd4eb2e39f" translate="yes" xml:space="preserve">
          <source>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</source>
          <target state="translated">속성에 부울 값이 포함 된 경우 HTML에서 예상 한대로 키가 true 일 때 키가 반복되거나 false 인 경우 속성이 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8e575af2759774fa079f44025ceaa854182a1885" translate="yes" xml:space="preserve">
          <source>In case something goes wrong in a request, the router by default will crash, without returning any response to the client. This behaviour can be configured in two ways, by using two different modules:</source>
          <target state="translated">요청에서 문제가 발생하면 클라이언트에 대한 응답을 반환하지 않고 라우터가 기본적으로 중단됩니다. 이 동작은 두 가지 다른 모듈을 사용하여 두 가지 방법으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df0afcd7e029ed4180d102a2ae98dc593f2ffcd" translate="yes" xml:space="preserve">
          <source>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; repository callback:</source>
          <target state="translated">예를 들어 시스템 환경 변수를 읽어 URL을 동적으로 구성해야하는 경우 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 저장소 콜백을 통해 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c933f8035c349bb985fc09533544e811593ba38d" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection, which might improve performance by for instance allowing multiple related calls to the datastore to share cache information:</source>
          <target state="translated">어댑터가 풀을 제공하는 경우 지정된 &lt;code&gt;fun&lt;/code&gt; 내부의 모든 코드 가 동일한 연결에 대해 실행 되도록 보장합니다. 예를 들어 캐시 정보를 공유하기 위해 데이터 저장소에 대한 여러 관련 호출을 허용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bf9e264bce9cb321b7053883e7d31f611e7f05" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection.</source>
          <target state="translated">어댑터가 풀을 제공하는 경우, 주어진 &lt;code&gt;fun&lt;/code&gt; 내의 모든 코드 가 동일한 연결에 대해 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff857d8a1955260dd298b9e239a24e36bf3592fa" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won&amp;rsquo;t attempt to reload it.</source>
          <target state="translated">연결이 이미로드 된 경우 사전로드는 다시로드를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cafa8aa062d6ef4942117b66127dc03a39128b32" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won't attempt to reload it.</source>
          <target state="translated">연결이 이미로드 된 경우 사전로드는 연결을 다시로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9be12295c8a6d2df07eacd1bb351f53d2c1496b9" translate="yes" xml:space="preserve">
          <source>In case the database could not be created, see the guides for the &lt;a href=&quot;mix_tasks#mix-ecto-create&quot;&gt;&lt;code&gt;mix ecto.create&lt;/code&gt;&lt;/a&gt; for general trouble-shooting.</source>
          <target state="translated">데이터베이스를 생성 할 수없는 경우 일반적인 문제 해결을 위해 &lt;a href=&quot;mix_tasks#mix-ecto-create&quot;&gt; &lt;code&gt;mix ecto.create&lt;/code&gt; 에&lt;/a&gt; 대한 가이드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="606100f3e421118140c48c97a79e6b2bfcdaf803" translate="yes" xml:space="preserve">
          <source>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</source>
          <target state="translated">콜백이 없거나 응답이 JSON 형식으로 인코딩되지 않은 경우에는 응답이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a4c0d85054f4f0cfaba6ef317dc6eb61be6e95d" translate="yes" xml:space="preserve">
          <source>In case there&amp;rsquo;s at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">오류가 하나 이상있는 경우 변경 목록의 &lt;code&gt;:errors&lt;/code&gt; 필드와 &lt;code&gt;:valid?&lt;/code&gt; 에 오류 목록이 추가됩니다 . 플래그는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8802f9aee3cd3d44f383509389bf5a3ee709a5f4" translate="yes" xml:space="preserve">
          <source>In case there's at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 오류가있는 경우 오류 목록이 변경 집합 의 &lt;code&gt;:errors&lt;/code&gt; 필드와 &lt;code&gt;:valid?&lt;/code&gt; 플래그는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d961c79d7700abcfdd8ac118b7d6649979a32d5" translate="yes" xml:space="preserve">
          <source>In case you want to use only a subset of the functionality provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Presence&lt;/code&gt;&lt;/a&gt;, such as tracking processes but without broadcasting updates, we recommend that you look at the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; functionality from the &lt;code&gt;phoenix_pubsub&lt;/code&gt; project.</source>
          <target state="translated">추적 프로세스와 같이 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Presence&lt;/code&gt; &lt;/a&gt; 에서 제공하는 기능 중 일부만 사용하고 업데이트를 브로드 캐스팅하지 않으려 는 경우 &lt;code&gt;phoenix_pubsub&lt;/code&gt; 프로젝트 에서 &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 기능 을 살펴 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e55c4e4ce95987e0fe79dc9dcc20ddcd0ebdbe7f" translate="yes" xml:space="preserve">
          <source>In cases like above, when you want to work only on a single entry, it is much easier to simply work on the associated directly. For example, we could instead set the &lt;code&gt;post&lt;/code&gt; association in the comment:</source>
          <target state="translated">위와 같은 경우 단일 항목에 대해서만 작업하려는 경우 관련 작업을 직접 수행하는 것이 훨씬 쉽습니다. 예를 들어 주석에서 &lt;code&gt;post&lt;/code&gt; 연결을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a433a57ec454997093ca88ba782e60cd40611d5" translate="yes" xml:space="preserve">
          <source>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</source>
          <target state="translated">채널 테스트에서 프로세스 커뮤니케이션, 메시지 송수신을 통해 채널과 상호 작용합니다. 또한 채널이 구독하는 것과 동일한 주제를 구독하여 특정 메시지가 브로드 캐스트되었는지 여부를 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d0afdb19d32b80bba27b9edef3ebd1dd1cf2d1d" translate="yes" xml:space="preserve">
          <source>In complex cases, instead of relying on name inference, it may be best to set the constraint name explicitly:</source>
          <target state="translated">복잡한 경우에는 이름 추론에 의존하는 대신 제약 조건 이름을 명시 적으로 설정하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="77c8d6fd181489a2dd77e9ab68ac22f7bd4b22c2" translate="yes" xml:space="preserve">
          <source>In fact, given &lt;code&gt;:through&lt;/code&gt; associations are read-only, &lt;strong&gt;using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; format is the preferred mechanism for working with through associations&lt;/strong&gt;. Use the schema-based one only if you need to store the through data alongside of the parent struct, in specific cases such as preloading.</source>
          <target state="translated">실제로, 주어진 &lt;code&gt;:through&lt;/code&gt; 연관은 읽기 전용이며 &lt;strong&gt;, &lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt; 형식을 사용하는 것이 연관을 통한 작업에 선호되는 메커니즘입니다.&lt;/strong&gt; . 프리로드와 같은 특정 경우에 스루 데이터를 부모 구조체와 함께 저장해야하는 경우에만 스키마 기반 스키마를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e209e8446b46f8896bce3d2476eaddc91e35939f" translate="yes" xml:space="preserve">
          <source>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</source>
          <target state="translated">실제로이 매크로를 호출하면 외래 키 이름을 가진 필드가 스키마에 자동으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c7989d85bf0c7a46c11c45022e7b193d7c4745ef" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;camelize&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;underscore&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;camelize&lt;/code&gt; 는 &lt;code&gt;underscore&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;underscore&lt;/code&gt; 은 &lt;code&gt;camelize&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7a08909ab028a2dad7ca28f19e7788d3cd3e512" translate="yes" xml:space="preserve">
          <source>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt;, which performs the &lt;code&gt;get&lt;/code&gt; step for us:</source>
          <target state="translated">일반적으로 상태 비 저장 HTTP 렌더링의 결과가 필요하지 않은 경우 한 단계로 뷰 탑재를 테스트하는 것이 더 편리합니다. 이것은 우리를 위해 &lt;code&gt;get&lt;/code&gt; 단계를 수행하는 &lt;a href=&quot;#live/2&quot;&gt; &lt;code&gt;live/2&lt;/code&gt; 에&lt;/a&gt; 대한 단일 호출로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="364f40e20dd4114a4cbee3580c6cbdd7d7379b01" translate="yes" xml:space="preserve">
          <source>In general, the scoping rules for pipelines behave as you might expect. In this example, all routes will pipe through the &lt;code&gt;:browser&lt;/code&gt; pipeline. However, only the &lt;code&gt;reviews&lt;/code&gt; resources routes will pipe through the &lt;code&gt;:review_checks&lt;/code&gt; pipeline. Since we declared both pipes &lt;code&gt;pipe_through [:browser, :review_checks]&lt;/code&gt; in a list of pipelines, Phoenix will &lt;code&gt;pipe_through&lt;/code&gt; each of them as it invokes them in order.</source>
          <target state="translated">일반적으로 파이프 라인의 범위 지정 규칙은 예상대로 작동합니다. 이 예에서 모든 경로는 &lt;code&gt;:browser&lt;/code&gt; 파이프 라인을 통해 파이프됩니다. 그러나 &lt;code&gt;reviews&lt;/code&gt; 리소스 경로 만 &lt;code&gt;:review_checks&lt;/code&gt; 파이프 라인을 통해 파이프됩니다. 파이프 라인 목록에서 두 파이프 모두 &lt;code&gt;pipe_through [:browser, :review_checks]&lt;/code&gt; 를 선언 했으므로 Phoenix는 순서대로 호출 할 때 파이프를 각각 &lt;code&gt;pipe_through&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dc684728adbd2c911a4a018ef11d85bc94e422b3" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</source>
          <target state="translated">대부분의 경우 요청에 따라 템플릿 형식을 동적으로 설정하고자 할 수 있습니다. 이렇게하려면 템플릿 이름을 아톰으로 확장명없이 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b97ae63daf6461e1b56637fd89a1f07f62a49cf" translate="yes" xml:space="preserve">
          <source>In order for the &lt;code&gt;render/3&lt;/code&gt; function to work correctly, the controller and view must have the same root name, which must also have the same root name as the template directory where the &lt;code&gt;show.html.eex&lt;/code&gt; template lives. In other words, the &lt;code&gt;HelloController&lt;/code&gt; requires &lt;code&gt;HelloView&lt;/code&gt;, and &lt;code&gt;HelloView&lt;/code&gt; requires the existence of the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory, which must contain the &lt;code&gt;show.html.eex&lt;/code&gt; template.</source>
          <target state="translated">위해서는 &lt;code&gt;render/3&lt;/code&gt; 제대로 작동하려면 기능 컨트롤러와 뷰는 템플릿 디렉토리와 동일한 루트 이름을 가져야합니다 동일한 루트 이름이 있어야합니다 &lt;code&gt;show.html.eex&lt;/code&gt; 의 템플릿 삶을. 즉, &lt;code&gt;HelloController&lt;/code&gt; 에는 &lt;code&gt;HelloView&lt;/code&gt; 가 필요 하고 &lt;code&gt;HelloView&lt;/code&gt; 에는 &lt;code&gt;show.html.eex&lt;/code&gt; 템플릿을 포함 &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; 디렉터리가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e42e4abc355dbe4c074a8c669e3ce458db628eaf" translate="yes" xml:space="preserve">
          <source>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</source>
          <target state="translated">위의 예제가 작동하려면 렌더링 전에 accepts 플러그를 사용하여 컨텐츠 협상을 수행해야합니다. 파이프 라인 (라우터)에 다음을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="85a3f7a925a56f5571d26cd839de4ab3fe0a021b" translate="yes" xml:space="preserve">
          <source>In order to act as a Plug, a function needs to accept a connection struct (&lt;code&gt;%Plug.Conn{}&lt;/code&gt;) and options. It also needs to return a connection struct. Any function that meets those criteria will do. Here's an example.</source>
          <target state="translated">플러그 역할을하려면 함수가 연결 구조체 ( &lt;code&gt;%Plug.Conn{}&lt;/code&gt; )와 옵션 을 받아 들여야합니다 . 또한 연결 구조체를 반환해야합니다. 이러한 기준을 충족하는 모든 기능이 수행됩니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 여기에 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a19ac64c369cd3aa389e69a402bc23919589b6" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes&amp;rsquo; names and values as the first element in the tag&amp;rsquo;s attributes keyword list:</source>
          <target state="translated">사용자 정의 데이터 속성을 추가하려면 : data atom 및 태그의 속성 키워드 목록에서 첫 번째 요소로 데이터 속성의 이름과 값이 포함 된 키워드 목록이 포함 된 튜플을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac088c628be1832c3337855895315bec677904de" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes' names and values as the first element in the tag's attributes keyword list:</source>
          <target state="translated">사용자 정의 데이터 속성을 추가하려면 태그의 속성 키워드 목록의 첫 번째 요소로 데이터 속성의 이름과 값이있는 키워드 목록과 : data 원자를 포함하는 튜플을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="4945c44b05e04ace755224f66c5d74d324ac27b2" translate="yes" xml:space="preserve">
          <source>In order to be able to use types such as &lt;code&gt;User.t()&lt;/code&gt;, &lt;code&gt;t/0&lt;/code&gt; has to be defined manually:</source>
          <target state="translated">같은 종류 사용할 수 있도록하기 위해 &lt;code&gt;User.t()&lt;/code&gt; , &lt;code&gt;t/0&lt;/code&gt; 는 직접 정의한다 :</target>
        </trans-unit>
        <trans-unit id="4fb780465e4f134e43bf1e5f6d0a97198b166675" translate="yes" xml:space="preserve">
          <source>In order to build a Phoenix application, we will need a few dependencies installed in our Operating System:</source>
          <target state="translated">Phoenix 애플리케이션을 구축하려면 운영 체제에 몇 가지 종속성이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3606aa169919759c5ce830a7a86020dbd731405c" translate="yes" xml:space="preserve">
          <source>In order to create a custom exception, we need to define a new module. Conventionally this will have &quot;Error&quot; in the name. Inside of that module, we need to define a new exception with &lt;code&gt;defexception&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 예외를 생성하려면 새 모듈을 정의해야합니다. 일반적으로 이름에 &quot;오류&quot;가 있습니다. 해당 모듈 내에서 &lt;code&gt;defexception&lt;/code&gt; 으로 새 예외를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4270d5af79d57d387989112f1ca66b128244614" translate="yes" xml:space="preserve">
          <source>In order to customize the parameter for any struct, one can simply implement this protocol.</source>
          <target state="translated">모든 구조체의 매개 변수를 사용자 정의하기 위해이 프로토콜을 간단히 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cea46f6957dacee9307e778c55b234fb7f0b614" translate="yes" xml:space="preserve">
          <source>In order to make it easier to recognize the current &quot;action&quot; your LiveView is on, you can pass the action option when defining LiveViews too:</source>
          <target state="translated">LiveView가 켜져있는 현재 &quot;작업&quot;을 더 쉽게 인식 할 수 있도록 LiveView를 정의 할 때 작업 옵션을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb086d6d7d0263ec8c536ef5b195313198d32a9" translate="yes" xml:space="preserve">
          <source>In order to promote HTML safety, Phoenix templates do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt; to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</source>
          <target state="translated">HTML 안전성을 높이기 위해 Phoenix 템플릿은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; 을 사용 하여 데이터 형식을 템플릿의 문자열로 변환 하지 않습니다 . 대신 Phoenix는이 프로토콜을 사용하여 데이터 구조로 구현해야하며 HTML 안전 표현이 반환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9ca8acf13c91e783afefe3396f6e1d2849afbe0" translate="yes" xml:space="preserve">
          <source>In order to provide better security, this function also enables &lt;code&gt;:reuse_sessions&lt;/code&gt; and &lt;code&gt;:secure_renegotiate&lt;/code&gt; by default, to instruct clients to reuse sessions and enforce secure renegotiation according to RFC 5746 respectively</source>
          <target state="translated">더 나은 보안을 제공하기 위해이 기능은 또한 &lt;code&gt;:reuse_sessions&lt;/code&gt; 및 &lt;code&gt;:secure_renegotiate&lt;/code&gt; 를 활성화합니다 . 기본적으로 를 하여 RFC 5746에 따라 클라이언트가 세션을 재사용하고 보안 재협상을 시행하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e5e3499f6e463ee690fd83cb4842e911f3133362" translate="yes" xml:space="preserve">
          <source>In order to run the context generators, we need to come up with a module name that groups the related functionality that we're building. In the &lt;a href=&quot;ecto&quot;&gt;Ecto guide&lt;/a&gt;, we saw how we can use Changesets and Repos to validate and persist user schemas, but we didn't integrate this with our application at large. In fact, we didn't think about where a &quot;user&quot; in our application should live at all. Let's take a step back and think about the different parts of our system. We know that we'll have users of our product. Along with users comes things like account login credentials and user registration. An &lt;code&gt;Accounts&lt;/code&gt; context in our system is a natural place for our user functionality to live.</source>
          <target state="translated">컨텍스트 생성기를 실행하려면 빌드중인 관련 기능을 그룹화하는 모듈 이름을 찾아야합니다. 에서 &lt;a href=&quot;ecto&quot;&gt;체외 가이드&lt;/a&gt; , 우리는 우리가 확인하려면 체인지와 레 포스를 사용하여 사용자 스키마를 지속, 그러나 우리는 큰에서 우리의 응용 프로그램이 통합되지 않은 방법을 보았다. 사실, 우리는 애플리케이션에서 &quot;사용자&quot;가 어디에 있어야하는지 전혀 생각하지 않았습니다. 한 발 뒤로 물러나 우리 시스템의 다른 부분에 대해 생각해 봅시다. 우리는 우리 제품의 사용자가 있다는 것을 알고 있습니다. 사용자와 함께 계정 로그인 자격 증명 및 사용자 등록과 같은 것이 제공됩니다. 시스템 의 &lt;code&gt;Accounts&lt;/code&gt; 컨텍스트는 사용자 기능이 살기위한 자연스러운 장소입니다.</target>
        </trans-unit>
        <trans-unit id="e1a30ed29655614d78d7122594af4684bbed32e0" translate="yes" xml:space="preserve">
          <source>In order to see our flash messages, we need to be able to retrieve them and display them in a template/layout. One way to do the first part is with &lt;code&gt;get_flash/2&lt;/code&gt; which takes &lt;code&gt;conn&lt;/code&gt; and the key we care about. It then returns the value for that key.</source>
          <target state="translated">플래시 메시지를보기 위해 우리는 그것들을 검색하고 템플릿 / 레이아웃에 표시 할 수 있어야합니다. 첫 번째 부분을 수행하는 한 가지 방법 은 &lt;code&gt;conn&lt;/code&gt; 과 우리가 신경 쓰는 키 를 취하는 &lt;code&gt;get_flash/2&lt;/code&gt; 를 사용 하는 것입니다. 그런 다음 해당 키의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2acba69363e13d3b2d19cde17064bc6e54ca91a5" translate="yes" xml:space="preserve">
          <source>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</source>
          <target state="translated">MongoDB와 같은 문자열 기반 쿼리가없는 데이터베이스를 지원하기 위해 조각을 사용하여 키워드를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62935c8ccc784ab4effb4cd884f492638a038713" translate="yes" xml:space="preserve">
          <source>In order to support links where &lt;code&gt;:method&lt;/code&gt; is not &lt;code&gt;:get&lt;/code&gt; or use the above data attributes, &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; relies on JavaScript. You can load &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; into your build tool.</source>
          <target state="translated">&lt;code&gt;:method&lt;/code&gt; 가 &lt;code&gt;:get&lt;/code&gt; 이 아닌 위의 데이터 속성을 사용하는 링크를 지원하기 위해 &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 은 JavaScript를 사용합니다. &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; 를 빌드 도구에 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac2a23cefe6dc405ba7cba0e86c91036507b2c2a" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MSSQL, on the other hand, does not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">지도를 지원하기 위해 서로 다른 데이터베이스에서 서로 다른 기술을 사용할 수 있습니다. 예를 들어 PostgreSQL은 이러한 값을 jsonb 필드에 저장하므로 일부만 쿼리 할 수 ​​있습니다. 반면 MSSQL은 아직 JSON 유형을 제공하지 않으므로 값은 텍스트 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0cfbb9e0b757e4a7c387f1a89548e61c769c0468" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">맵을 지원하기 위해, 다른 데이터베이스는 다른 기술을 사용할 수 있습니다. 예를 들어 PostgreSQL은 해당 값을 jsonb 필드에 저장하므로 그 일부만 쿼리 할 수 ​​있습니다. 반면에 MySQL 및 MSSQL은 아직 JSON 유형을 제공하지 않으므로 값이 텍스트 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9cc67ce09af6e2cd4c1b2d88a0add79d7ebdcbc4" translate="yes" xml:space="preserve">
          <source>In order to talk to databases, Phoenix applications use another Elixir package, called &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto&lt;/a&gt;. If you don't plan to use databases in your application, you can pass the &lt;code&gt;--no-ecto&lt;/code&gt; flag.</source>
          <target state="translated">데이터베이스와 통신하기 위해 Phoenix 애플리케이션은 &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto&lt;/a&gt; 라는 또 다른 Elixir 패키지를 사용 합니다. 애플리케이션에서 데이터베이스를 사용하지 않으려는 경우 &lt;code&gt;--no-ecto&lt;/code&gt; 플래그를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58a4eecdb1cbcbbac6d6309d8353c385746bf41f" translate="yes" xml:space="preserve">
          <source>In order to try out &lt;code&gt;redirect/2&lt;/code&gt;, let's create a new route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redirect/2&lt;/code&gt; 를 사용해보기 위해 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 에 새 경로를 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="52e29e7cb4d222c076586aa6d2efe1e067b45ad8" translate="yes" xml:space="preserve">
          <source>In order to use the check constraint, the first step is to define the check constraint in a migration:</source>
          <target state="translated">검사 제약 조건을 사용하기위한 첫 번째 단계는 마이그레이션에서 검사 제약 조건을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="631c78b05b032bf7a4bc9563b17081acddc1f9da" translate="yes" xml:space="preserve">
          <source>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</source>
          <target state="translated">외래 키 제약 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 외래 키를 정의하는 것입니다. 이것은 종종 참조로 수행됩니다. 예를 들어 게시물에 속하는 주석 테이블을 작성한다고 가정하십시오. 하나는 :</target>
        </trans-unit>
        <trans-unit id="b25785fbeb7db9f5fe5792dc95bd9802bce1df6e" translate="yes" xml:space="preserve">
          <source>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</source>
          <target state="translated">고유성 제한 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 고유 색인을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d32962e066707989deb6579a1bef99dfb02fd652" translate="yes" xml:space="preserve">
          <source>In order to, for instance, support slower clients you can tune the &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options. These specify how much time should be allowed to pass for each read from the underlying socket.</source>
          <target state="translated">예를 들어 느린 클라이언트를 지원하기 위해 &lt;code&gt;:read_length&lt;/code&gt; 및 &lt;code&gt;:read_timeout&lt;/code&gt; 옵션을 조정할 수 있습니다. 이것들은 기본 소켓에서 읽을 때마다 통과해야하는 시간을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f369074781af4e45339cc323b1a66a51339ef0e7" translate="yes" xml:space="preserve">
          <source>In order words, to provide custom error pages, we could simply define a the proper &lt;code&gt;render/2&lt;/code&gt; function clause in &lt;code&gt;HelloWeb.ErrorView&lt;/code&gt;.</source>
          <target state="translated">즉, 사용자 지정 오류 페이지를 제공하기 위해 &lt;code&gt;HelloWeb.ErrorView&lt;/code&gt; 에 적절한 &lt;code&gt;render/2&lt;/code&gt; 함수 절을 간단히 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ee12c14d9ca00e6cf48da215974e95f0c7e5650" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;...&lt;/code&gt; will include all the binding between the first and the last, which may be no binding at all, one or many.</source>
          <target state="translated">다시 말해, &lt;code&gt;...&lt;/code&gt; 는 첫 번째와 마지막 사이의 모든 바인딩을 포함하며, 하나 또는 여러 개의 바인딩이 전혀 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e53d1f0b2def4882c8f42cb4dd37f4b59fc07c1" translate="yes" xml:space="preserve">
          <source>In other words, LiveView will reload the page in case of errors, making it fail as if LiveView was not involved in the rendering in the first place.</source>
          <target state="translated">즉, LiveView는 오류 발생시 페이지를 다시로드하여 처음에 LiveView가 렌더링에 관여하지 않은 것처럼 실패하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e51f1325a0c1718983754df036a306b6fd8fe04b" translate="yes" xml:space="preserve">
          <source>In other words, the inner template is placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign. You can also find which module and template where used to render the inner content by introspecting the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assigns.</source>
          <target state="translated">즉, 내부 템플릿은 &lt;code&gt;@inner_content&lt;/code&gt; 할당에 배치됩니다 . &lt;code&gt;@view_module&lt;/code&gt; 및 &lt;code&gt;@view_template&lt;/code&gt; 할당 을 검사하여 내부 콘텐츠를 렌더링하는 데 사용 된 모듈과 템플릿을 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d505d82f389daac5da4c66b35201ad586113ff0" translate="yes" xml:space="preserve">
          <source>In other words, when you find yourself wanting to work only with a subset of the data, then using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is most likely unnecessary. Instead, you want to work on the other side of the association.</source>
          <target state="translated">다시 말해, 자신이 데이터의 서브셋으로 만 작업하기를 원할 경우 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 불필요 할 가능성이 높습니다. 대신, 당신은 협회의 다른 쪽에서 일하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="9c973e733faa5d3147a98906879b3bd69d7b92ef" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;contexts&quot;&gt;context guide&lt;/a&gt;, we'll find out how to wrap up our Ecto access and business logic behind modules that group related functionality. We'll see how Phoenix helps us design maintainable applications, and we'll find out about other neat Ecto features along the way.</source>
          <target state="translated">우리에서 &lt;a href=&quot;contexts&quot;&gt;상황에 맞는 가이드&lt;/a&gt; , 우리는 모듈 뒤에 우리의 체외 액세스 및 비즈니스 로직 해당 그룹 관련 기능을 래핑하는 방법에 대해 알아 보겠습니다. Phoenix가 유지 관리 가능한 응용 프로그램을 설계하는 데 어떻게 도움이되는지 살펴보고 그 과정에서 다른 깔끔한 Ecto 기능에 대해서도 알아볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="6bbbdd02796e8c750180d95d224e10d5ba7f72ee" translate="yes" xml:space="preserve">
          <source>In our example, a &lt;code&gt;User&lt;/code&gt; has and belongs to many &lt;code&gt;Organization&lt;/code&gt;s:</source>
          <target state="translated">이 예에서 &lt;code&gt;User&lt;/code&gt; 는 다음과 같은 여러 &lt;code&gt;Organization&lt;/code&gt; 속합니다 .</target>
        </trans-unit>
        <trans-unit id="41ab6ab1980a050c36b66959ba9f3fe938f26932" translate="yes" xml:space="preserve">
          <source>In our example, a User has and belongs to many Organizations</source>
          <target state="translated">이 예에서 사용자는 많은 조직을 보유하고 있으며</target>
        </trans-unit>
        <trans-unit id="0fbfe06d33d66e813a10defbfd79ae7b1d15c17b" translate="yes" xml:space="preserve">
          <source>In particular, controller plugs provide a feature that allows us to execute plugs only within certain actions. For example, you can do:</source>
          <target state="translated">특히 컨트롤러 플러그는 특정 작업 내에서만 플러그를 실행할 수있는 기능을 제공합니다. 예를 들어 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b939b666f3565b6620c702bbdd16fc9969fa1e4b" translate="yes" xml:space="preserve">
          <source>In practice, developers rarely use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; directly. Instead they use &lt;a href=&quot;phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; which wraps the template functionality and adds some extra conveniences.</source>
          <target state="translated">실제로 개발자는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; 을&lt;/a&gt; 직접 사용하는 경우는 거의 없습니다 . 대신 템플릿 기능을 래핑하고 추가 편의를 추가 하는 &lt;a href=&quot;phoenix.view&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="24a1a86627169c9301c553095fe386a37b9ae377" translate="yes" xml:space="preserve">
          <source>In practice, we recommend you to create your own helper with your default builder:</source>
          <target state="translated">실제로 기본 빌더를 사용하여 자체 헬퍼를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e23fb277659a1ad68bfb10ebf634617c8f5908ca" translate="yes" xml:space="preserve">
          <source>In some cases - often in &lt;code&gt;index&lt;/code&gt; actions, for instance - we don't care about parameters because our behavior doesn't depend on them. In those cases, we don't use the incoming params, and simply prepend the variable name with an underscore, &lt;code&gt;_params&lt;/code&gt;. This will keep the compiler from complaining about the unused variable while still keeping the correct arity.</source>
          <target state="translated">어떤 경우에는-종종 &lt;code&gt;index&lt;/code&gt; 작업에서-우리의 행동이 매개 변수에 의존하지 않기 때문에 우리는 매개 변수를 신경 쓰지 않습니다. 이 경우 들어오는 매개 변수를 사용하지 않고 변수 이름 앞에 밑줄 &lt;code&gt;_params&lt;/code&gt; 를 추가하기 만하면 됩니다. 이렇게하면 컴파일러가 사용되지 않는 변수에 대해 불평하지 않고 올바른 arity를 ​​유지합니다.</target>
        </trans-unit>
        <trans-unit id="993fe331f8eff395e53c329f899a97ba23a0a92b" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to boostrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">경우에 따라 컨텍스트 모듈 및 테스트를 강화하고 컨텍스트 및 스키마의 내부 구현을 자신에게 맡길 수 있습니다. 이를 수행 하려면 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd22eb2e0cd9838b3868b47d0fdae86fdaf59c8" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, LiveViews, and tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">경우에 따라 HTML 템플릿, LiveView 및 테스트를 부트 스트랩하고 컨텍스트 또는 스키마의 내부 구현을 자신에게 맡기고 싶을 수 있습니다. 파일 생성 제어를 위해 &lt;code&gt;--no-context&lt;/code&gt; 및 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35ee16ec6c8361255e6bb80285b427eaac9246a7" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">경우에 따라 HTML 템플릿, 컨트롤러 및 컨트롤러 테스트를 부트 스트랩하되 컨텍스트 또는 스키마의 내부 구현을 자신에게 맡기고 싶을 수 있습니다. 파일 생성 제어를 위해 &lt;code&gt;--no-context&lt;/code&gt; 및 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ade3a11fcd46e0424822bf48a04573731b62fbef" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap JSON views, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">경우에 따라 JSON보기, 컨트롤러 및 컨트롤러 테스트를 부트 스트랩하고 컨텍스트 또는 스키마의 내부 구현을 자신에게 맡길 수 있습니다. 파일 생성 제어를 위해 &lt;code&gt;--no-context&lt;/code&gt; 및 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f55011b0377dd613950bd33fc87827f221a7e3b5" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">어떤 경우에는 컨텍스트 모듈과 테스트를 부트 스트랩하되 컨텍스트와 스키마의 내부 구현을 자신에게 맡기고 싶을 수 있습니다. 이를 수행 하려면 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24c4866aacf268fba081667d7687cebfe5f62ff4" translate="yes" xml:space="preserve">
          <source>In some cases, you might need to render based on the template. For these cases, &lt;code&gt;@view_template&lt;/code&gt; can pair with &lt;a href=&quot;#render_existing/3&quot;&gt;&lt;code&gt;render_existing/3&lt;/code&gt;&lt;/a&gt; for per-template based content, ie:</source>
          <target state="translated">경우에 따라 템플릿을 기반으로 렌더링해야 할 수도 있습니다. 이러한 경우 &lt;code&gt;@view_template&lt;/code&gt; 은 템플릿 기반 콘텐츠에 대해 &lt;a href=&quot;#render_existing/3&quot;&gt; &lt;code&gt;render_existing/3&lt;/code&gt; &lt;/a&gt; 과 쌍을 이룰 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b384998377753d90d4408512efaa31439cf25f8" translate="yes" xml:space="preserve">
          <source>In some cases, you will want to broadcast messages without the context of a &lt;code&gt;socket&lt;/code&gt;. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</source>
          <target state="translated">경우에 따라 &lt;code&gt;socket&lt;/code&gt; 컨텍스트없이 메시지를 브로드 캐스트하려는 경우가 있습니다 . 이는 채널 내에서 외부 주제로 브로드 캐스트하거나 애플리케이션의 다른 곳에서 컨트롤러 또는 다른 프로세스와 같은 브로드 캐스트를위한 것일 수 있습니다. 엔드 포인트를 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556542b6153a0a9877d7ad7e8e95684ac07433c4" translate="yes" xml:space="preserve">
          <source>In some cases, you&amp;rsquo;ll need to generate a request&amp;rsquo;s URL, but using a different scheme, different host, etc. This can be accomplished by concatentating the request path with a custom built URL from your Router helpers, another Endpoint, mix config, or a hand-built string.</source>
          <target state="translated">경우에 따라 요청의 URL을 생성해야하지만 다른 구성표, 다른 호스트 등을 사용해야합니다. 이는 라우터 도우미, 다른 엔드 포인트, 믹스 구성, 또는 손으로 만든 끈.</target>
        </trans-unit>
        <trans-unit id="5d135b52253ea1f76dc118e79a5ba5024dc31ed9" translate="yes" xml:space="preserve">
          <source>In some cases, you'll need to generate a request's URL, but using a different scheme, different host, etc. This can be accomplished in two ways.</source>
          <target state="translated">경우에 따라 요청의 URL을 생성해야하지만 다른 스키마, 다른 호스트 등을 사용합니다. 이는 두 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925f7c8aaf0732c9cba3eed658f8290b2a10f60a" translate="yes" xml:space="preserve">
          <source>In stateful components, &lt;a href=&quot;#c:mount/1&quot;&gt;&lt;code&gt;mount/1&lt;/code&gt;&lt;/a&gt; is called only once, when the component is first rendered. For each rendering, the optional &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; callbacks are called before &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상태 저장 구성 요소에서 &lt;a href=&quot;#c:mount/1&quot;&gt; &lt;code&gt;mount/1&lt;/code&gt; &lt;/a&gt; 은 구성 요소가 처음 렌더링 될 때 한 번만 호출됩니다. 각 렌더링에 대해 선택적인 &lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt; 콜백이 &lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt; 전에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac3f1efde90130546f23b2c2f904814fe3e8fcab" translate="yes" xml:space="preserve">
          <source>In such cases it is possible to pass the private key directly, using the &lt;code&gt;:key&lt;/code&gt; parameter. For example, assuming an RSA private key is available in the PRIVKEY environment variable in Base64 encoded DER format, the key may be set as follows:</source>
          <target state="translated">이러한 경우 &lt;code&gt;:key&lt;/code&gt; 매개 변수를 사용하여 개인 키를 직접 전달할 수 있습니다 . 예를 들어 RSA 개인 키가 Base64로 인코딩 된 DER 형식의 PRIVKEY 환경 변수에서 사용 가능하다고 가정하면 키는 다음과 같이 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68280495d51817872c43fe92d60a5737a8f25c18" translate="yes" xml:space="preserve">
          <source>In that example we have a user&amp;rsquo;s id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">이 예에서는 사용자의 ID가 있으며 토큰을 생성하고 주어진 &lt;code&gt;endpoint&lt;/code&gt; 구성된 비밀 키베이스를 사용하여 토큰을 확인 합니다 . 최대 연령 (권장)을 설정하여 토큰이 하루 동안 만 유효 함을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1f41f3118259de0c9215a6b06e0067217d596aea" translate="yes" xml:space="preserve">
          <source>In that example we have a user's id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">이 예에서는 사용자 ID가 있고 토큰을 생성하고 지정된 &lt;code&gt;endpoint&lt;/code&gt; 구성된 비밀 키베이스를 사용하여이를 확인 합니다 . 최대 연령을 설정하여 토큰이 하루 동안 만 유효 함을 보장합니다 (권장).</target>
        </trans-unit>
        <trans-unit id="fd49de9316bf15faaf745aa97193e59f4c5ce77a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;changeset/2&lt;/code&gt; function above, we define three validations. They check that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</source>
          <target state="translated">위의 &lt;code&gt;changeset/2&lt;/code&gt; 함수에서는 세 가지 유효성 검사를 정의합니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;email&lt;/code&gt; 필드가 변경 세트에 있는지 , 전자 메일이 지정된 형식이며, 전자 메일 필드의 고유 한 제한 조건과 함께 전자 메일이 18에서 100 사이인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2beaddf1dc1af0a0afed02b2665a4c614e8c9fe1" translate="yes" xml:space="preserve">
          <source>In the CTE query itself use the same table name to leverage recursion that has been passed to the &lt;code&gt;name&lt;/code&gt; argument. Make sure to write a stop condition to avoid infinite recursion loop. Generally speaking, you should only use CTEs in Ecto for writing recursive queries.</source>
          <target state="translated">CTE 쿼리 자체에서 동일한 테이블 이름을 사용하여 &lt;code&gt;name&lt;/code&gt; 인수에 전달 된 재귀를 활용 합니다. 무한 재귀 루프를 피하기 위해 중지 조건을 작성해야합니다. 일반적으로 Ecto에서는 재귀 쿼리를 작성하기 위해 CTE 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ea091611015f8ec7cc9dd9fea5d96ed83e209c4" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these data structures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">위의 예에서 &lt;code&gt;with&lt;/code&gt; 는 성공적인 post fetch와 일치하는 데 사용되며 현재 사용자에 대한 유효한 권한이 뒤 따릅니다. 둘 중 하나가 일치 하지 않는 경우 &lt;code&gt;with&lt;/code&gt; 는 렌더 블록을 호출하지 않고 대신 일치 하지 않는 값을 반환합니다. 이 경우 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환 했거나 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 반환 했다고 상상해보세요 . 이러한 데이터 구조가 도메인의 여러 경계에서 반환 값으로 사용되는 경우 단일 대체 모듈을 사용하여 값을 유효한 응답으로 변환 할 수 있습니다. 예를 들어 위의 값을 처리하기 위해 다음 폴백 컨트롤러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5795255717d6356ac87649a6472e670f2673298a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these datastructures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">위의 예에서 &lt;code&gt;with&lt;/code&gt; 는 성공적인 포스트 페치에만 일치하고 현재 사용자에 대한 유효한 권한 부여와 일치하는 데 사용됩니다. 중 이들의 경우, 일치 실패 &lt;code&gt;with&lt;/code&gt; 블록을 렌더링 대신 타의 추종을 불허하는 값을 반환하지 않습니다 호출합니다. 이 경우 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 리턴 하거나 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 리턴 했다고 가정하십시오 . 이러한 데이터 구조가 도메인의 여러 경계에서 반환 값으로 사용되는 경우 단일 폴백 모듈을 사용하여 값을 유효한 응답으로 변환 할 수 있습니다. 예를 들어 위의 값을 처리하기 위해 다음 폴백 컨트롤러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1b0c0a37a5ad734fd8c9a63cf167f822b9d6d7" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 응답되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="687f064f0b397a245fd7efdac2c169e020ea3fe3" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 전송되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ed97cc0df14884c8ffa3bce15edcee614a81a95" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 응답되는 한 전송되는 데이터에 대해 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfd5bb81c813b68dd4c64063dd42225fe58dd0c8" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 전송되는 한 전송되는 데이터에 대해 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7dbfb137b25284ebef7ca3ab66b80ac42b70e667" translate="yes" xml:space="preserve">
          <source>In the case of an &lt;code&gt;&quot;element&quot;&lt;/code&gt; page loading event, the info will contain a &lt;code&gt;&quot;target&quot;&lt;/code&gt; key containing the DOM element which triggered the page loading state.</source>
          <target state="translated">의 경우 &lt;code&gt;&quot;element&quot;&lt;/code&gt; 페이지 로딩 이벤트의 정보가 포함됩니다 &lt;code&gt;&quot;target&quot;&lt;/code&gt; 페이지 로딩 상태를 실행 한 DOM 요소를 포함하는 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="5f28e9a6e41b204ed7eb1de0dc4ea78da2108aed" translate="yes" xml:space="preserve">
          <source>In the case of forms, when a &lt;code&gt;phx-change&lt;/code&gt; is sent to the server, the input element which emitted the change receives the &lt;code&gt;phx-change-loading&lt;/code&gt; class, along with the parent form tag. The following events receive css loading classes:</source>
          <target state="translated">양식의 경우 &lt;code&gt;phx-change&lt;/code&gt; 가 서버로 전송되면 변경 을 내 보낸 입력 요소가 부모 양식 태그와 함께 &lt;code&gt;phx-change-loading&lt;/code&gt; 클래스를 받습니다 . 다음 이벤트는 CSS 로딩 클래스를받습니다.</target>
        </trans-unit>
        <trans-unit id="19c0702d49a6fa9644c129eb1cbc189ec43c7c1d" translate="yes" xml:space="preserve">
          <source>In the case of our &lt;code&gt;create&lt;/code&gt; action, when we successfully create a user, we use &lt;a href=&quot;phoenix.controller#put_flash/3&quot;&gt;&lt;code&gt;Phoenix.Controller.put_flash/3&lt;/code&gt;&lt;/a&gt; to show a success message, and then we redirect to the &lt;code&gt;user_path&lt;/code&gt;'s show page. Conversely, if &lt;code&gt;Accounts.create_user/1&lt;/code&gt; fails, we render our &lt;code&gt;&quot;new.html&quot;&lt;/code&gt; template and pass along the Ecto changeset for the template to lift error messages from.</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; 작업 의 경우 사용자를 성공적으로 생성 하면 &lt;code&gt;user_path&lt;/code&gt; &lt;a href=&quot;phoenix.controller#put_flash/3&quot;&gt; &lt;code&gt;Phoenix.Controller.put_flash/3&lt;/code&gt; &lt;/a&gt; 를 사용 하여 성공 메시지를 표시 한 다음 user_path 의 쇼 페이지로 리디렉션 합니다. 반대로 &lt;code&gt;Accounts.create_user/1&lt;/code&gt; 이 실패하면 &lt;code&gt;&quot;new.html&quot;&lt;/code&gt; 템플릿을 렌더링하고 템플릿이 오류 메시지를 해제 할 Ecto 변경 집합을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6084cacdb41ec7942b3031f9f8713fcd0287545b" translate="yes" xml:space="preserve">
          <source>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct defined by an Ecto schema, such as the &lt;code&gt;%User{}&lt;/code&gt; struct defined by the &lt;code&gt;User&lt;/code&gt; module.</source>
          <target state="translated">지금까지 변경 세트 예제에서, 변경 세트를 사용 하여 &lt;code&gt;User&lt;/code&gt; 모듈에 의해 정의 된 &lt;code&gt;%User{}&lt;/code&gt; 구조체 와 같이 Ecto 스키마에 의해 정의 된 구조체에 포함 된 데이터의 유효성을 검증하고 캐스트했습니다 .</target>
        </trans-unit>
        <trans-unit id="6967baeb41fe4aaf65135be1a86f7b7f51cb74b8" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; implementation, the metadata expects the following keys:</source>
          <target state="translated">기본 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt; 구현에서 메타 데이터에는 다음 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de678a4f657d9a0b14e4ad6c02a818dd6a2f267d" translate="yes" xml:space="preserve">
          <source>In the documentation below, we will explain how it works internally. For user-facing documentation, see &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 문서에서 내부적으로 어떻게 작동하는지 설명합니다. 사용자 용 문서는 &lt;a href=&quot;phoenix.liveview&quot;&gt; &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c05024d1d5f114eed84c10173ddb5b0423ed6df3" translate="yes" xml:space="preserve">
          <source>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</source>
          <target state="translated">위의 예에서는 스키마를 사용했지만 테이블 이름을 문자열로 지정하여 테이블에 대해 직접 쿼리를 수행 할 수도 있습니다. 이러한 경우 가져올 데이터는 명시 적으로 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="77e215827ec3fbaaba50e0c67d6aa3a380c28048" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6980dcf932f4756073eec7951985832bf4ffdbc2" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;ecto#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;ecto#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0efaf4e38ac06de9330c96ca3071c0aa49d7d17" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; will be available to all plugs invoked after &lt;code&gt;:match&lt;/code&gt;. Such plugs can read from &lt;code&gt;conn.assigns&lt;/code&gt; (or &lt;code&gt;conn.private&lt;/code&gt;) to configure their behaviour based on the matched route.</source>
          <target state="translated">위의 예에서 &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; 은 &lt;code&gt;:match&lt;/code&gt; 이후에 호출 된 모든 플러그에서 사용할 수 있습니다 . 이러한 플러그는 &lt;code&gt;conn.assigns&lt;/code&gt; (또는 &lt;code&gt;conn.private&lt;/code&gt; ) 에서 읽어 일치 경로를 기반으로 동작을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b582e24c785d7e528d91beeaeb2094948f8201" translate="yes" xml:space="preserve">
          <source>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, &lt;a href=&quot;ecto.query.casterror&quot;&gt;&lt;code&gt;Ecto.Query.CastError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">위의 예에서 Ecto는 나이를 정수 유형으로 캐스팅합니다. 값을 캐스트 할 수 없으면 &lt;a href=&quot;ecto.query.casterror&quot;&gt; &lt;code&gt;Ecto.Query.CastError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="952705a8404ece781d990a44fb37e80f3335cc68" translate="yes" xml:space="preserve">
          <source>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its &lt;code&gt;phx-target&lt;/code&gt;. If &lt;code&gt;phx-target&lt;/code&gt; points to a component, that will be the component used, otherwise it will fallback to the view.</source>
          <target state="translated">위의 예에서 LiveView는 ID = user-13 인 요소를 조회하고 &lt;code&gt;phx-target&lt;/code&gt; 을 검색합니다 . 경우 &lt;code&gt;phx-target&lt;/code&gt; 컴포넌트 포인트, 즉, 그렇지 않으면보기에 폴백 것, 성분이 사용된다.</target>
        </trans-unit>
        <trans-unit id="38da296833b2b1ef41965ac27af71cead65925f5" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &quot;/hello&quot;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 요청은 &lt;code&gt;GET&lt;/code&gt; 요청이고 경로가 &quot;/ hello&quot;인 경우에만 일치 합니다. 지원되는 HTTP 메소드는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a6032006ee3190bfba008183ef22c7724958741" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &amp;ldquo;/hello&amp;rdquo;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 요청은 &lt;code&gt;GET&lt;/code&gt; 요청이고 경로가 &quot;/ hello&quot;인 경우에만 일치 합니다. 지원되는 HTTP 메소드는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb4d85bfa68b487dba755bf14be4d94f034f1c7" translate="yes" xml:space="preserve">
          <source>In the example above, both &lt;code&gt;at_least_four(:doors)&lt;/code&gt; and &lt;code&gt;at_least_four(:tires)&lt;/code&gt; would be valid calls as the field is dynamically generated.</source>
          <target state="translated">위의 예에서 &lt;code&gt;at_least_four(:doors)&lt;/code&gt; 및 &lt;code&gt;at_least_four(:tires)&lt;/code&gt; 는 필드가 동적으로 생성되므로 유효한 호출이됩니다.</target>
        </trans-unit>
        <trans-unit id="f151d0619adc353362eafc28e0ed90d66415139d" translate="yes" xml:space="preserve">
          <source>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; results, like a &lt;code&gt;join&lt;/code&gt; would, it returns only posts with the &lt;code&gt;comments&lt;/code&gt; fields properly filled in.</source>
          <target state="translated">위의 예에서 주석을 가져 오기 위해 별도의 쿼리를 발행하는 대신 Ecto는 단일 쿼리에서 게시물과 주석을 가져오고 각 주석을 상위 게시물에 연결하는 별도의 패스를 수행합니다. 따라서 &lt;code&gt;join&lt;/code&gt; 처럼 &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; 결과 를 반환하는 대신 &lt;code&gt;comments&lt;/code&gt; 필드가 올바르게 채워진 게시물 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b8024bb268a6b569b23e03a0cc2bbfe6ea4b6c5f" translate="yes" xml:space="preserve">
          <source>In the example above, the Blog context receives the user on both &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; operations, and always validates accordingly that the user has access, raising an error otherwise.</source>
          <target state="translated">위의 예에서 블로그 컨텍스트는 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 작업 모두에서 사용자를 수신하고 이에 따라 항상 사용자가 액세스 권한을 가지고 있는지 확인하고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c4efbfdb8b81848fa5c5be65d29714905c426ad1" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket&amp;rsquo;s topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel&amp;rsquo;s process as a presence for the socket&amp;rsquo;s user ID, with a map of metadata.</source>
          <target state="translated">위의 예에서 소켓 주제에 대한 현재 상태 정보는 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 이벤트 로 클라이언트에 푸시됩니다 . 다음으로 &lt;code&gt;Presence.track&lt;/code&gt; 은이 채널의 프로세스를 메타 데이터 맵과 함께 소켓 사용자 ID의 존재로 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b04f9b48d20bfebf57013a4e3bc857f160f52" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket's topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel's process as a presence for the socket's user ID, with a map of metadata.</source>
          <target state="translated">위의 예에서 소켓 주제에 대한 현재 상태 정보는 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 이벤트 로 클라이언트에 푸시됩니다 . 다음으로 &lt;code&gt;Presence.track&lt;/code&gt; 은이 채널의 프로세스를 메타 데이터 맵과 함께 소켓의 사용자 ID에 대한 존재로 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c5fb7697f09cc5ff0d4a520eb43540e86b99510" translate="yes" xml:space="preserve">
          <source>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</source>
          <target state="translated">위의 예에서 쿼리는 최종 맵에 병합하여 조금씩 작성됩니다. 위의 두 조건이 모두 해당되는 경우 최종 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d450f61126463b7084c0897c03bca594be4602a6" translate="yes" xml:space="preserve">
          <source>In the example above, two events will be emitted:</source>
          <target state="translated">위의 예에서는 두 개의 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d58aedac2b16ebd09d651ee588fbf1ba5cf17edd" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &quot;users&quot; table from the database.</source>
          <target state="translated">위의 예에서는 데이터베이스에서 &quot;users&quot;테이블을 직접 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="925feb16ac76c5d3be11e92f48d4338c9def7879" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &amp;ldquo;users&amp;rdquo; table from the database.</source>
          <target state="translated">위의 예에서는 데이터베이스에서 &quot;users&quot;테이블을 직접 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="0bdcc56455db35f7ec8e6aad2349adff0d37f04a" translate="yes" xml:space="preserve">
          <source>In the example above, we are using the lower procedure in the database to downcase the title column.</source>
          <target state="translated">위의 예에서 데이터베이스의 하위 프로 시저를 사용하여 제목 열을 다운 케이스합니다.</target>
        </trans-unit>
        <trans-unit id="6d69428195f2828f8a6f3b10d5d7bcaad49a7a54" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt; is the window function.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt; 은 창 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e6d3d727bce6283546ba164b37335f9c8037c441" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;code&gt;avg/1&lt;/code&gt; is the window function. For more information on windows functions, see &lt;a href=&quot;ecto.query.windowapi&quot;&gt;&lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;code&gt;avg/1&lt;/code&gt; 은 창 함수입니다. windows 함수에 대한 자세한 정보는 &lt;a href=&quot;ecto.query.windowapi&quot;&gt; &lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b237c8ca61ef3e508aa687be188e40ca4adf22f" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a &lt;code&gt;has_many :through&lt;/code&gt; association named &lt;code&gt;:comments_authors&lt;/code&gt;. A &lt;code&gt;:through&lt;/code&gt; association always expects a list and the first element of the list must be a previously defined association in the current module. For example, &lt;code&gt;:comments_authors&lt;/code&gt; first points to &lt;code&gt;:comments&lt;/code&gt; in the same module (Post), which then points to &lt;code&gt;:author&lt;/code&gt; in the next schema, &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;:comments_authors&lt;/code&gt; 라는 &lt;code&gt;has_many :through&lt;/code&gt; 연관을 정의했습니다 . A는 &lt;code&gt;:through&lt;/code&gt; 연관 항상리스트와리스트의 첫 번째 요소는 현재 모듈에서 사전에 정의 된 연관 있어야 기대한다. 예를 들어 &lt;code&gt;:comments_authors&lt;/code&gt; 는 먼저 동일한 모듈 (Post)에서 &lt;code&gt;:comments&lt;/code&gt; 를 가리키고 다음 스키마 인 &lt;code&gt;Comment&lt;/code&gt; 에서 &lt;code&gt;:author&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="85ec2ea6c6ded12b6166febab5316f612414d722" translate="yes" xml:space="preserve">
          <source>In the example above, we used &lt;a href=&quot;#datetime_add/3&quot;&gt;&lt;code&gt;datetime_add/3&lt;/code&gt;&lt;/a&gt; to subtract one month from the current datetime and compared it with the &lt;code&gt;p.published_at&lt;/code&gt;. If you want to perform operations on date, &lt;a href=&quot;#date_add/3&quot;&gt;&lt;code&gt;date_add/3&lt;/code&gt;&lt;/a&gt; could be used.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#datetime_add/3&quot;&gt; &lt;code&gt;datetime_add/3&lt;/code&gt; &lt;/a&gt; 을 사용 하여 현재 날짜 시간에서 한 달을 빼고 &lt;code&gt;p.published_at&lt;/code&gt; 과 비교했습니다 . 날짜에 작업을 수행하려는 경우 &lt;a href=&quot;#date_add/3&quot;&gt; &lt;code&gt;date_add/3&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a77b1f6b12d8b7d6c0db0b804a8d03a2387d7fc2" translate="yes" xml:space="preserve">
          <source>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once inside the query.</source>
          <target state="translated">위의 예에서 우리는 서로 다른 바인딩을 사용하여 쿼리 식을 비트 단위로 빌드 한 다음 쿼리 내부에서 한 번에 보간 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="b3cc98d911ffe36e25f191353a2c3e1efd5e9454" translate="yes" xml:space="preserve">
          <source>In the example below, we get all comments associated to the given post:</source>
          <target state="translated">아래 예에서는 지정된 게시물과 관련된 모든 의견을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="113fef9616300cb9b03a9842f0b9a69b0c3665e7" translate="yes" xml:space="preserve">
          <source>In the examples above, even though it returned &lt;code&gt;:ok&lt;/code&gt;, we do not know if we inserted new data or if we updated only the &lt;code&gt;:on_conflict&lt;/code&gt; fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as &lt;code&gt;inserted_at&lt;/code&gt; will point to now rather than the time the struct was actually inserted.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;:ok&lt;/code&gt; 반환했지만 새 데이터를 삽입했는지 또는 &lt;code&gt;:on_conflict&lt;/code&gt; 필드 만 업데이트했는지는 알 수 없습니다 . 업데이트가 발생한 경우, 구조체의 데이터가 데이터베이스의 데이터와 일치하지 않을 가능성이 높습니다. 예를 들어, 같은 자동 생성 필드 &lt;code&gt;inserted_at&lt;/code&gt; 은 오히려 구조체가 실제로 삽입 된 시간보다 지금 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2930af812f0bb54659d607398b6c6757367b573d" translate="yes" xml:space="preserve">
          <source>In the examples above, we have placed the template directly inside the LiveView:</source>
          <target state="translated">위의 예에서는 템플릿을 LiveView 내부에 직접 배치했습니다.</target>
        </trans-unit>
        <trans-unit id="2f37c0e9a5a67e4ea92ceac140f3ed765f58b555" translate="yes" xml:space="preserve">
          <source>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</source>
          <target state="translated">In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</target>
        </trans-unit>
        <trans-unit id="05a430899144f4642991576f8481a69501d20d42" translate="yes" xml:space="preserve">
          <source>In the form, you now can:</source>
          <target state="translated">양식에서 이제 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94cd064e93fa734125c2fd704a901c1c0fcb707" translate="yes" xml:space="preserve">
          <source>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</source>
          <target state="translated">키워드 쿼리 구문에서 이러한 옵션은 조인 직후에 제공되어야합니다. 표현식 구문에서 옵션은 다섯 번째 인수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e90e585267bb28783e5461ed42cba84a357ddee0" translate="yes" xml:space="preserve">
          <source>In the middle of the endpoint, there is also a conditional block:</source>
          <target state="translated">끝점 중간에 조건부 블록도 있습니다.</target>
        </trans-unit>
        <trans-unit id="925384cf40775541bef0fdb371ddd4f6902ee2ec" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here&amp;rsquo;s a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">이전 섹션에서는 엔드 포인트에서 자동으로 생성 된 &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; 기능을 사용했습니다 . 다음은 엔드 포인트에서 자동으로 정의 된 모든 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f3c7ddaf3d4a8950203ba5460188209b699de98" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here's a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">이전 섹션에서는 엔드 포인트에서 자동으로 생성되는 &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; 함수를 사용했습니다 . 다음은 엔드 포인트에서 자동으로 정의되는 모든 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4db5d6dd9e9298f5fcdd31235b789e1443c4ca39" translate="yes" xml:space="preserve">
          <source>In the router, we can declare plugs inside pipelines:</source>
          <target state="translated">라우터에서 파이프 라인 내부에 플러그를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a8e520a230c0312a84d780ae929ea961272701" translate="yes" xml:space="preserve">
          <source>In the same &lt;code&gt;lib/hello&lt;/code&gt; directory, we will find a &lt;code&gt;lib/hello/repo.ex&lt;/code&gt;. It defines a &lt;code&gt;Hello.Repo&lt;/code&gt; module which is our main interface to the database. If you are using Postgres (the default), you will see something like this:</source>
          <target state="translated">동일한 &lt;code&gt;lib/hello&lt;/code&gt; 디렉토리에서 &lt;code&gt;lib/hello/repo.ex&lt;/code&gt; 를 찾을 수 있습니다. 데이터베이스에 대한 기본 인터페이스 인 &lt;code&gt;Hello.Repo&lt;/code&gt; 모듈을 정의 합니다. Postgres (기본값)를 사용하는 경우 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e4a55cc79b6410f0afe6d205affc7d1b1d385b5c" translate="yes" xml:space="preserve">
          <source>In the second case, the &lt;code&gt;form_for&lt;/code&gt; emits only the opening of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag, which then needs to be closed explicitly in HTML. Since the anonymous function has been removed, &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is able to optimize forms too. Although outside of live views, we recommend using the first construct.</source>
          <target state="translated">두 번째 경우, &lt;code&gt;form_for&lt;/code&gt; 는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 의 열기 만 내 보냅니다. 그런 다음 HTML에서 명시 적으로 닫아야합니다. 익명 기능이 제거되었으므로 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 도 양식을 최적화 할 수 있습니다. 라이브 뷰 외부에 있지만 첫 번째 구성을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="610bcbb3b9e32217be658737635c218a337cd80c" translate="yes" xml:space="preserve">
          <source>In the template, we want to wrap all of the messages in a container and tag this content with &lt;code&gt;phx-update&lt;/code&gt;. Remember, we must add an ID to the container as well as to each child:</source>
          <target state="translated">템플릿에서 모든 메시지를 컨테이너에 래핑하고이 콘텐츠에 &lt;code&gt;phx-update&lt;/code&gt; 태그를 지정 하려고 합니다. 컨테이너와 각 하위 항목에 ID를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5900cdb36ee6d103dd2e36b10be0e4e6213e6863" translate="yes" xml:space="preserve">
          <source>In the view we see our &lt;code&gt;render/2&lt;/code&gt; function pattern matching on &lt;code&gt;&quot;index.json&quot;&lt;/code&gt;, &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;, and &lt;code&gt;&quot;page.json&quot;&lt;/code&gt;. The &quot;index.json&quot; and &quot;show.json&quot; are the ones requested directly from the controller. They also match on the assigns sent by the controller. &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; will respond with JSON like this:</source>
          <target state="translated">뷰 에서 &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; , &lt;code&gt;&quot;show.json&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;page.json&quot;&lt;/code&gt; 에 일치하는 &lt;code&gt;render/2&lt;/code&gt; 함수 패턴을 볼 수 있습니다 . &quot;index.json&quot;및 &quot;show.json&quot;은 컨트롤러에서 직접 요청한 것입니다. 그들은 또한 컨트롤러가 보낸 할당과 일치합니다. &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; 은 다음과 같이 JSON으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="7e2c6811152e546fda2c29bf344f22b16249e04d" translate="yes" xml:space="preserve">
          <source>In this case you can use the name and suffix options together to match on these dynamic indexes, like:</source>
          <target state="translated">이 경우 이름과 접미사 옵션을 함께 사용하여 다음과 같은 동적 색인에서 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b521e7acb6fef7a8f7e4316ef4bab85906fb67cf" translate="yes" xml:space="preserve">
          <source>In this case, the solution is to not use &lt;code&gt;content_tag&lt;/code&gt; and rely on LiveEEx to build the markup.</source>
          <target state="translated">이 경우 해결책은 &lt;code&gt;content_tag&lt;/code&gt; 를 사용하지 않고 LiveEEx를 사용하여 마크 업을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c678eccca5ec57c1ed60e620ac17c9a5a18d705b" translate="yes" xml:space="preserve">
          <source>In this case, we haven&amp;rsquo;t checked the unique constraint in the e-mail field because the data did not validate. Let&amp;rsquo;s fix the age and assume, however, that the e-mail already exists in the database:</source>
          <target state="translated">이 경우 데이터의 유효성이 검사되지 않았기 때문에 전자 메일 필드에서 고유 제약 조건을 확인하지 않았습니다. 그러나 연령을 수정하고 전자 메일이 데이터베이스에 이미 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="50bf56697ce917a335edfd2bed8c62011c485096" translate="yes" xml:space="preserve">
          <source>In this case, we haven't checked the unique constraint in the e-mail field because the data did not validate. Let's fix the age and the name, and assume that the e-mail already exists in the database:</source>
          <target state="translated">이 경우 데이터의 유효성을 검사하지 않았기 때문에 전자 메일 필드의 고유 제약 조건을 확인하지 않았습니다. 나이와 이름을 수정하고 전자 메일이 이미 데이터베이스에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f94f214e683bc0e00a7e39c7767a3430885c51b2" translate="yes" xml:space="preserve">
          <source>In this example, the phoenix.js client will send the token in the &lt;code&gt;connect&lt;/code&gt; command which is then validated by the server.</source>
          <target state="translated">이 예제에서 phoenix.js 클라이언트는 &lt;code&gt;connect&lt;/code&gt; 명령으로 토큰을 전송 한 다음 서버에서 확인합니다.</target>
        </trans-unit>
        <trans-unit id="84d8d37df15e10105e708f89127c2b3fd59110cd" translate="yes" xml:space="preserve">
          <source>In this example, the stop event's &lt;code&gt;duration&lt;/code&gt; includes the time it takes to parse the request, dispatch it to the correct handler, and execute the handler. The events are not emitted for requests not matching any handlers, since the plug is placed after the match plug.</source>
          <target state="translated">이 예제에서 stop 이벤트의 &lt;code&gt;duration&lt;/code&gt; 에는 요청을 구문 분석하고 올바른 핸들러로 전달하고 핸들러를 실행하는 데 걸리는 시간이 포함됩니다. 플러그가 일치 플러그 뒤에 배치되므로 핸들러와 일치하지 않는 요청에 대해서는 이벤트가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c87280301ac2f9d889847d9370825348892494" translate="yes" xml:space="preserve">
          <source>In this example, we know the client sent a valid token because &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; returned a tuple of type &lt;code&gt;{:ok, user_id}&lt;/code&gt;. The server can now proceed with the request.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, user_id}&lt;/code&gt; 유형의 튜플을 반환 했기 때문에 클라이언트가 유효한 토큰을 보냈습니다 . 서버는 이제 요청을 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71e6a35d1eff7b2aab276040bac56ef6b66ab6ad" translate="yes" xml:space="preserve">
          <source>In this example, we prepend the new comment to the list of existing comments. Ecto will diff the list of comments currently in &lt;code&gt;post&lt;/code&gt; with the list of comments given, and correctly insert the new comment to the database. Note, however, Ecto is doing a lot of work just to figure out something we knew since the beginning, which is that there is only one new comment.</source>
          <target state="translated">이 예에서는 기존 주석 목록에 새 주석을 추가합니다. Ecto는 현재 &lt;code&gt;post&lt;/code&gt; 주석 목록을 제공된 주석 목록과 비교하여 새 주석을 데이터베이스에 올바르게 삽입합니다. 그러나 Ecto는 처음부터 우리가 알고있는 것을 알아 내기 위해 많은 노력을 기울이고 있습니다. 즉, 새로운 의견은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="705c5880cd57ceb565562d6750a24d58f8d72145" translate="yes" xml:space="preserve">
          <source>In this guide, we will show you how to instrument and report on &lt;code&gt;:telemetry&lt;/code&gt; events in your Phoenix application.</source>
          <target state="translated">이 가이드에서는 Phoenix 애플리케이션에서 &lt;code&gt;:telemetry&lt;/code&gt; 이벤트 를 계측하고보고하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="41b71b3e3675710388f0fdbf100ae1a0951ac128" translate="yes" xml:space="preserve">
          <source>In this particular case, this can be addressed by using the &lt;code&gt;form_for&lt;/code&gt; variant without anonymous functions:</source>
          <target state="translated">이 특별한 경우에는 익명 함수없이 &lt;code&gt;form_for&lt;/code&gt; 변형 을 사용하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="094b03b8c08ae8f0aca1e1b64e1f6fdead91e39c" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. (See &lt;a href=&quot;phoenix.token#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.)</source>
          <target state="translated">이 시나리오에서는 토큰을 생성하고 서명 한 다음 클라이언트 응용 프로그램에 제공합니다. 그러면 클라이언트는이 토큰을 사용하여 서버의 리소스 요청을 인증합니다. 토큰 생성에 대한 자세한 내용은 &lt;a href=&quot;phoenix.token#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; 요약을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d2ca7cf6666758e66d70fb72bd2c17d8cc12775" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. See &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.</source>
          <target state="translated">이 시나리오에서는 토큰을 만들고 서명 한 다음 클라이언트 응용 프로그램에 제공합니다. 그런 다음 클라이언트는이 토큰을 사용하여 서버의 리소스 요청을 인증합니다. 토큰 생성에 대한 자세한 내용은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; 요약을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e2b36f6be4273c12b1bf0870e80c1f54e8ebe01" translate="yes" xml:space="preserve">
          <source>In this section, we will talk about error cases that you expect to happen within your application. For example, a user filling in a form with invalid data is expected. In a LiveView, we typically handle those cases by storing a change in the LiveView state, which causes the LiveView to be re-rendered with the error message.</source>
          <target state="translated">이 섹션에서는 애플리케이션 내에서 발생할 것으로 예상되는 오류 사례에 대해 설명합니다. 예를 들어, 잘못된 데이터로 양식을 채우는 사용자가 예상됩니다. LiveView에서 우리는 일반적으로 LiveView 상태에 변경 사항을 저장하여 이러한 경우를 처리합니다. 그러면 LiveView가 오류 메시지와 함께 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="534f0da6f14534e0120bbc0f42df3e9cafe2ef69" translate="yes" xml:space="preserve">
          <source>In your posts and tasks:</source>
          <target state="translated">게시물과 작업에서 :</target>
        </trans-unit>
        <trans-unit id="c3b933e481b11d1bde53fbfb5da0612030cd36c5" translate="yes" xml:space="preserve">
          <source>In your test, you can assert that the close happened by:</source>
          <target state="translated">테스트에서 다음과 같이 종료가 발생했다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b483120f0deedef678421bd74a9a810fadf217f8" translate="yes" xml:space="preserve">
          <source>In-context Relationships</source>
          <target state="translated">컨텍스트 내 관계</target>
        </trans-unit>
        <trans-unit id="2145377aa10484f7a6a7e6838ef07513b94b08f3" translate="yes" xml:space="preserve">
          <source>Inclusion operator: &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">포함 연산자 : &lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fb63493844a1ddd4abed4ae031ad06a61ed43a" translate="yes" xml:space="preserve">
          <source>Incoming Events</source>
          <target state="translated">들어오는 이벤트</target>
        </trans-unit>
        <trans-unit id="f330c4ccc52c7952a156d5b90f9e2cb96c8ebbb4" translate="yes" xml:space="preserve">
          <source>Incoming messages</source>
          <target state="translated">수신 메시지</target>
        </trans-unit>
        <trans-unit id="615a09426a8930c611cc2c8dba4ed06391710162" translate="yes" xml:space="preserve">
          <source>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; before being forwarded to a channel.</source>
          <target state="translated">들어오는 메시지는 전송자가 선택하는 방식에 따라 인코딩됩니다. 이러한 메시지는 채널로 전달되기 전에 전송에서 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 로 디코딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1020e5877fce98955e2ab68a32a4bcc5456449fd" translate="yes" xml:space="preserve">
          <source>Indeed it does.</source>
          <target state="translated">실제로 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="2668d897f3e5655c92b0200386d6b654d95aaf3e" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema</source>
          <target state="translated">다른 스키마와 다 대다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6aedb251e3f9159172c6827ec8ede269c15554c5" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema.</source>
          <target state="translated">다른 스키마와의 다 대다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="135ecd7103630379591db4bff96d8d8045c40ee5" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema</source>
          <target state="translated">다른 스키마와 일대 다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13d6cb61c10dc318568f2defc7bea984f223dba4" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema.</source>
          <target state="translated">다른 스키마와 일대 다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1708cc604ed2771df21bc2d718401a60ab2cc1f0" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ae09be75f38bd6a2f7c1a338f1fea359b869e83" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c438499b0af025a1043798095c70140d1dfd657" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3745614dbe3129d4f977d563860dba9c8231878f" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aba2438ae1e81b9920197c224065413b7671c158" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema</source>
          <target state="translated">스키마 임베딩을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b12568554ff04c1842f8599807aa79f64173a10b" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema.</source>
          <target state="translated">스키마의 포함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0754ccd3beda4c7eb864f57ffbfc33fd61e455d7" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99fc922b999b45aabf4ebb20cd1ef3dfc6c0a01f" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas.</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d6143e57414f523ba3e39d5fe528429bec73741" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration</source>
          <target state="translated">엔드 포인트 구성 초기화</target>
        </trans-unit>
        <trans-unit id="5feacf6897a98bceba39f5f4a774ab74aa83f3be" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration.</source>
          <target state="translated">엔드 포인트 구성을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3397476eb797456dd549685d4d13875789ff5bea" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c798c674e519bc2029ac452c4e9259668434c74d" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata.</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2a5ae207d4c7ad36e0e12a08bb38366c31c50683" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="3e313d7032fb8b49aa12e688ee30e31dff8431ca" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents.</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="869617ee9409bb26ae162b9333128e6d4f2497b3" translate="yes" xml:space="preserve">
          <source>Initializes the socket state.</source>
          <target state="translated">소켓 상태를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="fc723255ce4cbc0ec464d52fcc972a1cff32563d" translate="yes" xml:space="preserve">
          <source>Initializes the store</source>
          <target state="translated">상점을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="1948daa5ef81efb1f6ec1462ab9c9c66bafc872e" translate="yes" xml:space="preserve">
          <source>Initializes the store.</source>
          <target state="translated">상점을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0a32892f65c6f195d4bdaf7f60b3ed037aaaf563" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다</target>
        </trans-unit>
        <trans-unit id="aa4d0a4055c28858395d1bfeafcca50d2acb136f" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler.</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6966f2c2b0c652d66d13404f26dd54080032e919" translate="yes" xml:space="preserve">
          <source>Inits a session used exclusively for testing.</source>
          <target state="translated">테스트 전용으로 사용되는 세션을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="da5d892e49eb5ac8b64c4d52c39e57d5d2b08b77" translate="yes" xml:space="preserve">
          <source>Inline embedded schema</source>
          <target state="translated">인라인 임베디드 스키마</target>
        </trans-unit>
        <trans-unit id="569dafe164ae502c9b87c69bc2eeb16d3ac20cb7" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store</source>
          <target state="translated">데이터 저장소에 하나의 새로운 구조체를 삽입합니다</target>
        </trans-unit>
        <trans-unit id="3a1317498687c5894a20801ea9661a9689ed2d87" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store.</source>
          <target state="translated">데이터 저장소에 단일 새 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="86c1d2240ae2916c99327d1f3c4590ec880385b2" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a079a1b2f8984d465d9779ce849f02a429912d56" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset.</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="2181d458ad9deb4e6f83faf70ff675628bae0f26" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository</source>
          <target state="translated">모든 항목을 저장소에 삽입</target>
        </trans-unit>
        <trans-unit id="bc00e3feeb02479984623c1097211a4ee34ffd3d" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository.</source>
          <target state="translated">모든 항목을 저장소에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="9a37ef1a0e51e4ac96d292248e7c141eccd65b5f" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="45c0d55451df6034857c16938433e2842f295184" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store.</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a7003a167a94b7bd8fae5279ac09697a6145d12e" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="dcd7179acaea39cd9930239b8c9b516c75b3f0b6" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not.</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9eeac09af2f2cedab574e42a13a327495bc47759" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not</source>
          <target state="translated">구조체가 유지되는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="518a7ab088e5ce8ed019df775d78816d42febbe1" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not.</source>
          <target state="translated">구조체의 유지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c6d1a59fa5a20ec26ebff17adad30561c03cb5fa" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;select&lt;/code&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; can also be used to cast fragments:</source>
          <target state="translated">내부 &lt;code&gt;select&lt;/code&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 또한 주조 조각에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1a47e2355f236a87370793356f456cedb8eb6e91" translate="yes" xml:space="preserve">
          <source>Inside our existing IEx shell, let's create a &lt;code&gt;params&lt;/code&gt; map with valid values plus an extra &lt;code&gt;random_key: &quot;random value&quot;&lt;/code&gt;.</source>
          <target state="translated">기존 IEx 셸 내 에서 유효한 값과 추가 &lt;code&gt;random_key: &quot;random value&quot;&lt;/code&gt; 있는 &lt;code&gt;params&lt;/code&gt; 맵을 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="bd5d902a671eb6810031f5357cbe6027ed13c2f5" translate="yes" xml:space="preserve">
          <source>Inside select: &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; and literals (map, tuples, lists, etc)</source>
          <target state="translated">내부 선택 : &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; 및 리터럴 (지도, 튜플, 목록 등)</target>
        </trans-unit>
        <trans-unit id="0bcbada89fa45431c089dbafc4a9e45958d6ebde" translate="yes" xml:space="preserve">
          <source>Inside that directory, let's create a new file, &lt;code&gt;hello.greeting.ex&lt;/code&gt;, that looks like this.</source>
          <target state="translated">그 디렉토리 안에 다음과 같은 새 파일 &lt;code&gt;hello.greeting.ex&lt;/code&gt; 를 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="54208a58823ef0a76c1b1a086d542dde6d472630" translate="yes" xml:space="preserve">
          <source>Inside the scope block, however, we have our first actual route:</source>
          <target state="translated">그러나 스코프 블록 안에 첫 번째 실제 경로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5017ef1ca24c2a0d39b26c970ff7ebac50e027e8" translate="yes" xml:space="preserve">
          <source>Instead do this:</source>
          <target state="translated">대신 이것을하십시오 :</target>
        </trans-unit>
        <trans-unit id="82733e655d9772ce9cd06c72fcb7075dc4b7fc14" translate="yes" xml:space="preserve">
          <source>Instead explicitly precompute the assign in your LiveView, outside of render:</source>
          <target state="translated">대신 렌더링 외부에서 LiveView에서 할당을 명시 적으로 미리 계산합니다.</target>
        </trans-unit>
        <trans-unit id="17c3011cfb0b3891c2ccfb6fb06de6931b311efd" translate="yes" xml:space="preserve">
          <source>Instead of rendering all points with both static and dynamic parts, it returns a &lt;a href=&quot;phoenix.liveview.comprehension&quot;&gt;&lt;code&gt;Phoenix.LiveView.Comprehension&lt;/code&gt;&lt;/a&gt; struct with the static parts, that are shared across all points, and a list of dynamics to be interpolated inside the static parts. If &lt;code&gt;@points&lt;/code&gt; is a list with &lt;code&gt;%{x: 1, y: 2}&lt;/code&gt; and &lt;code&gt;%{x: 3, y: 4}&lt;/code&gt;, the above expression would return:</source>
          <target state="translated">정적 부품과 동적 부품을 모두 사용하여 모든 포인트를 렌더링하는 대신 모든 포인트에서 공유되는 정적 부품과 정적 부품 내부에서 보간 할 역학 목록이 포함 된 &lt;a href=&quot;phoenix.liveview.comprehension&quot;&gt; &lt;code&gt;Phoenix.LiveView.Comprehension&lt;/code&gt; &lt;/a&gt; 구조체를 반환합니다 . 경우 &lt;code&gt;@points&lt;/code&gt; 가 함께 목록 &lt;code&gt;%{x: 1, y: 2}&lt;/code&gt; 및 &lt;code&gt;%{x: 3, y: 4}&lt;/code&gt; 상기 식은 반환 :</target>
        </trans-unit>
        <trans-unit id="53f49b4a03d02b3492955bbf412c1bec4c46145a" translate="yes" xml:space="preserve">
          <source>Instead of setting the action manually, you may use &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; that emulates operations such as &lt;code&gt;Repo.insert&lt;/code&gt;. &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;{:ok, changes}&lt;/code&gt; if the changeset is valid or &lt;code&gt;{:error, changeset}&lt;/code&gt;, with the given &lt;code&gt;action&lt;/code&gt; set in the changeset in case of errors.</source>
          <target state="translated">대신 수동으로 작업을 설정, 당신은 사용할 수 있습니다 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 그와 같은 에뮬레이션 작업 &lt;code&gt;Repo.insert&lt;/code&gt; 가 . 변경 세트가 유효한 경우 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, changes}&lt;/code&gt; 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 를 리턴 하며, 오류가 발생하면 변경 세트에 지정된 &lt;code&gt;action&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dc625090b0eb339994af40957b6fb0d89ad3361f" translate="yes" xml:space="preserve">
          <source>Instead pass only the keys that you need:</source>
          <target state="translated">대신 필요한 키만 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7be3c09bff9978d92d18ecc6c00bb68ff1fa61" translate="yes" xml:space="preserve">
          <source>Instead we can define a Module Plug which knows how to handle these error cases specifically. Since controllers are Module Plugs, let's define our Plug as a controller:</source>
          <target state="translated">대신 이러한 오류 사례를 구체적으로 처리하는 방법을 아는 모듈 플러그를 정의 할 수 있습니다. 컨트롤러는 모듈 플러그이므로 플러그를 컨트롤러로 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="39b20dbf47e354f9fd0db114ae3112acc37f568e" translate="yes" xml:space="preserve">
          <source>Instead, it is much simpler to create a function:</source>
          <target state="translated">대신 함수를 만드는 것이 훨씬 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="3849a580f55e6b3b71f03e8f33c8ec65f16bcdd1" translate="yes" xml:space="preserve">
          <source>Instead, use a function:</source>
          <target state="translated">대신 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4ab4eded4494d51c420236d3c9dde1cb217c024c" translate="yes" xml:space="preserve">
          <source>Instead, you can see the valid options for ciphers in the Erlang SSL documentation: http://erlang.org/doc/man/ssl.html</source>
          <target state="translated">대신 Erlang SSL 문서에서 유효한 암호 옵션을 확인할 수 있습니다. http://erlang.org/doc/man/ssl.html</target>
        </trans-unit>
        <trans-unit id="cb49b30bf89c4f1a8a29b63caa0a66ed1c9abce4" translate="yes" xml:space="preserve">
          <source>Instrumentation</source>
          <target state="translated">Instrumentation</target>
        </trans-unit>
        <trans-unit id="e963ac54f9b90e504ad8b5131dedaa40800f87bf" translate="yes" xml:space="preserve">
          <source>Instrumenter to handle logging of various instrumentation events.</source>
          <target state="translated">다양한 계측 이벤트의 로깅을 처리하는 계측기</target>
        </trans-unit>
        <trans-unit id="0a977fa7c155d5db26b9805f1ed5ecb306366925" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint</source>
          <target state="translated">주어진 엔드 포인트가 제공하는 계측을 사용하여 주어진 기능을 계측</target>
        </trans-unit>
        <trans-unit id="040ea1fc514e828951fb8bd3d4e6583bf2dab63c" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint.</source>
          <target state="translated">주어진 엔드 포인트에서 제공하는 계측을 사용하여 지정된 기능을 계측합니다.</target>
        </trans-unit>
        <trans-unit id="a4c71d7db6768276e995bf083955f4cf532a2661" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">정수 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cf4a624177d7b6a2189975011d8cf1553a6ea" translate="yes" xml:space="preserve">
          <source>Intercepting Outgoing Events</source>
          <target state="translated">발신 이벤트 차단</target>
        </trans-unit>
        <trans-unit id="e70cfbd4ab25034bd13454c2505b73098457ac1c" translate="yes" xml:space="preserve">
          <source>Intercepts outgoing &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">나가는 &lt;code&gt;event&lt;/code&gt; 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="280e1b21a8fbf76997de6dc3b8694bbd51187d4e" translate="yes" xml:space="preserve">
          <source>Interestingly, we can use multiple scopes with the same path as long as we are careful not to duplicate routes. This router is perfectly fine with two scopes defined for the same path.</source>
          <target state="translated">흥미롭게도 경로가 중복되지 않도록주의하는 한 동일한 경로로 여러 범위를 사용할 수 있습니다. 이 라우터는 동일한 경로에 대해 정의 된 두 가지 범위로 완벽합니다.</target>
        </trans-unit>
        <trans-unit id="352256d32ca814a08dd6fb42ea6e24113694d807" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="eb704a4d49662206b6263bee9e3a6a682a47856e" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas.</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="60fcb5d998d297a0c11dd2b6af2c754859e11297" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 동작을 구현하는데 , 이는 &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 함수가 모두 정의 되어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd342be42586a26dea11e10d4f2f734d1e7b515" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 동작을 구현합니다. 즉, &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 함수가 모두 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="9e19e8e52d010a3380d2cbbab62c90af63b8d211" translate="yes" xml:space="preserve">
          <source>Interpolation and casting</source>
          <target state="translated">보간 및 주조</target>
        </trans-unit>
        <trans-unit id="28f682fd32feb69dea4dd4ff7adfaeaa1d1cf34e" translate="yes" xml:space="preserve">
          <source>Intersect expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the intersection of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#intersect_all/2&quot;&gt;&lt;code&gt;intersect_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">교차 표현식은 각 쿼리가 고유 한 결과를 반환 한 것처럼 고유 한 행만 반환합니다. 성능이 저하 될 수 있습니다. 중복 행을 제거하지 않고 여러 결과 세트의 교차점을 가져와야하는 경우 &lt;a href=&quot;#intersect_all/2&quot;&gt; &lt;code&gt;intersect_all/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="99267cc8937fb84d59bd60cc8326f8d752393db1" translate="yes" xml:space="preserve">
          <source>Intervals</source>
          <target state="translated">Intervals</target>
        </trans-unit>
        <trans-unit id="39fc639ab5236d70b6020dbbd7562331428b523c" translate="yes" xml:space="preserve">
          <source>Introduction - the guides you are currently reading. They will cover how to get your first application up and running</source>
          <target state="translated">소개-현재 읽고있는 가이드입니다. 첫 번째 애플리케이션을 시작하고 실행하는 방법을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="8f4f328eabc744329e26e1140102953b7cc0083e" translate="yes" xml:space="preserve">
          <source>Intuitively, you would assume the following events:</source>
          <target state="translated">직관적으로 다음과 같은 이벤트를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f5ee41c074ac477895b057c2f41a57f16a778949" translate="yes" xml:space="preserve">
          <source>Invoke this function for each possible value you want to be sent to the server.</source>
          <target state="translated">서버로 보내려는 각 가능한 값에 대해이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="619c9c50996959b8e8f2beefe6dce08a85ac4c47" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;</source>
          <target state="translated">주어진 기간 &lt;code&gt;term&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">주어진 용어 &lt;code&gt;term&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3cf9b446c97f792217c895b34619fd73d2391b8" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="36dca7d832107fe8c35259472cc9700cfe1e2dbf" translate="yes" xml:space="preserve">
          <source>Invoked on termination.</source>
          <target state="translated">종료시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="733a4970520b6a464600ddd46a5ea64dba2a7375" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래에있는 값을 &quot;팝&quot;하기 위해 호출</target>
        </trans-unit>
        <trans-unit id="742607736cb1addcde99f49aeedd51a191858b29" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값을 &quot;팝핑&quot;하도록 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f35bf2a44d8213b1a251a0c82fa8bd2d26bc1736" translate="yes" xml:space="preserve">
          <source>Invoked when the channel process is about to exit.</source>
          <target state="translated">채널 프로세스가 종료 되려고 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="61f50a5fe51f51ed7bfe665e624200109386cacc" translate="yes" xml:space="preserve">
          <source>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</source>
          <target state="translated">엔드 포인트 감독자가 시작될 때 호출되며 시스템 환경 또는 기타 런타임 소스에서 엔드 포인트를 동적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dadda151ad04d6534ebf813dc99705a1a1d25aa9" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="fe65c1df5bce54718f5a6ea6e98b5d9c1a779a60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0516c7f6572d24052272cc4f229ec6f77d29e2" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="092a9376001bb69648a2c2cf84aeeda23d64be60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0c22586bb54f63849624411c842f2723bc94a4ec" translate="yes" xml:space="preserve">
          <source>It accepts an expression representing the path and many options allowing the match to be configured.</source>
          <target state="translated">경로를 나타내는 표현식과 일치를 구성 할 수있는 많은 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e9e7a6e5fc7e8d490f61f816d70fa682574386e8" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#read_body/2&quot;&gt;&lt;code&gt;read_body/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#read_body/2&quot;&gt; &lt;code&gt;read_body/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="09ea74617913e32e5cdeb3c90a896c1320876968" translate="yes" xml:space="preserve">
          <source>It also supports custom adapter configuration:</source>
          <target state="translated">또한 사용자 정의 어댑터 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bed9aed2b3feb53ce6e2576687d31f3c4e20815c" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;:ok&lt;/code&gt;. To assert on the flash message, you can assert on the result of the rendered LiveView.</source>
          <target state="translated">항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 플래시 메시지에 대해 어설 션하려면 렌더링 된 LiveView의 결과에 대해 어설 션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595822e1d20d7f428a3ef05e5d7b881101ea3807" translate="yes" xml:space="preserve">
          <source>It begins by configuring our &lt;code&gt;otp_app&lt;/code&gt; name and repo module. Then it sets the adapter &amp;ndash; Postgres, in our case. It also sets our login credentials. Of course, you can change these to match your actual credentials if they are different.</source>
          <target state="translated">&lt;code&gt;otp_app&lt;/code&gt; 이름과 repo 모듈 을 구성하는 것으로 시작 합니다. 그런 다음 어댑터 (이 경우 Postgres)를 설정합니다. 또한 로그인 자격 증명을 설정합니다. 물론, 다른 경우 실제 자격 증명과 일치하도록 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="726bf51434f75d8acf5e951711360513b2a0f6e9" translate="yes" xml:space="preserve">
          <source>It builds a new &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, invokes the handler &lt;code&gt;connect/2&lt;/code&gt; callback and returns the result.</source>
          <target state="translated">새 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; 을&lt;/a&gt; 빌드 하고 핸들러 &lt;code&gt;connect/2&lt;/code&gt; 콜백을 호출하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a2cee1f656545c050d15a435216908ba321f2198" translate="yes" xml:space="preserve">
          <source>It can be mounted in your endpoint like any other socket:</source>
          <target state="translated">다른 소켓처럼 엔드 포인트에 마운트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b86f00ae4f81180f207fb516f99df0d0c9b931" translate="yes" xml:space="preserve">
          <source>It can be used to derive a number of keys for various purposes from a given secret. This lets applications have a single secure secret, but avoid reusing that key in multiple incompatible contexts.</source>
          <target state="translated">주어진 비밀에서 다양한 목적으로 여러 키를 파생시키는 데 사용될 수 있습니다. 이를 통해 응용 프로그램은 단일 보안 암호를 가질 수 있지만 호환되지 않는 여러 컨텍스트에서 해당 키를 재사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="23758d8b77b97b076e10f03ba6b30fb6fdbbbd09" translate="yes" xml:space="preserve">
          <source>It can either be a keyword query or a query expression.</source>
          <target state="translated">키워드 쿼리 또는 쿼리 식일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186c38e14a6722baf34f425fa70665e109fc23a0" translate="yes" xml:space="preserve">
          <source>It can reset many fields except the query source (&lt;code&gt;from&lt;/code&gt;). When excluding a &lt;code&gt;:join&lt;/code&gt;, it will remove &lt;em&gt;all&lt;/em&gt; types of joins. If you prefer to remove a single type of join, please see paragraph below.</source>
          <target state="translated">쿼리 소스 ( &lt;code&gt;from&lt;/code&gt; )를 제외한 많은 필드를 재설정 할 수 있습니다 . &lt;code&gt;:join&lt;/code&gt; 을 제외하면 &lt;em&gt;모든&lt;/em&gt; 유형의 조인 이 제거 &lt;em&gt;됩니다&lt;/em&gt; . 단일 유형의 조인을 제거하려면 아래 단락을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19ab39633586fe70e0d92fb43a531d87dd58c9ee" translate="yes" xml:space="preserve">
          <source>It defaults to 5_000.</source>
          <target state="translated">기본값은 5_000입니다.</target>
        </trans-unit>
        <trans-unit id="dc3f06b0deaf4213087d2af935c667afca3512ce" translate="yes" xml:space="preserve">
          <source>It escapes quotes (double and single), double backslashes and others.</source>
          <target state="translated">따옴표 (이중 및 단일), 이중 백 슬래시 등을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="452abe794374c8a4220fd3958f7c982cbc75a77b" translate="yes" xml:space="preserve">
          <source>It expects &lt;code&gt;{:safe, body}&lt;/code&gt; as a safe response or body as a string which will be HTML escaped.</source>
          <target state="translated">그것은 예상 &lt;code&gt;{:safe, body}&lt;/code&gt; HTML 이스케이프됩니다 문자열로 안전 응답이나 신체 등을.</target>
        </trans-unit>
        <trans-unit id="8540fa79ebeeb04321b6937468baa86cf4bdc0a6" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="acabec8dab50a30917f688b209245a29971cc577" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise, raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;. After &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt; is called, chunks can be sent to the client via the &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; 함수 를 통해 청크를 클라이언트로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c8ac9c1aa8ddc9982ee763c945c57e9b9465d7" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:file&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 그 후 상태를 &lt;code&gt;:file&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1fe68caa8735b3dcb8f4a5c0b34b1b868f77311e" translate="yes" xml:space="preserve">
          <source>It expects a connection with state &lt;code&gt;:chunked&lt;/code&gt; as set by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;. It returns &lt;code&gt;{:ok, conn}&lt;/code&gt; in case of success, otherwise &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 상태 &lt;code&gt;:chunked&lt;/code&gt; 와의 연결이 필요 합니다. 그것은 반환 &lt;code&gt;{:ok, conn}&lt;/code&gt; 그렇지 않으면 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a89874718d53663a7182056d1005a29e9ce37ec6" translate="yes" xml:space="preserve">
          <source>It expects a name or a PID representing a repo.</source>
          <target state="translated">리포를 나타내는 이름 또는 PID가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="acb7e336ed29d294c4566b6d952ca3d23d9cfb62" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</source>
          <target state="translated">첫 번째 인수로 스키마 모듈 ( &lt;code&gt;MyApp.User&lt;/code&gt; ) 또는 소스 ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) 또는 둘 다 ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; )가 필요합니다. 두 번째 인수는 키워드 목록 또는 맵으로 삽입 할 항목 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e373615ede0cb68b0ddc4b7d19e01255f7ceb5ec" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; that returns a single entry with a single value.</source>
          <target state="translated">스키마 모듈 ( &lt;code&gt;MyApp.User&lt;/code&gt; )이나 소스 ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) 또는 둘 다 ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; )가 첫 번째 인수로 예상 됩니다. 두 번째 인수는 키워드 목록 또는 맵으로 삽입 할 항목 목록입니다. 항목의 키는 원자로서의 필드 이름이고 값은 필드 유형에 대한 각각의 값이거나 선택적 으로 단일 값이있는 단일 항목을 리턴 하는 &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; 여야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="833cf1288bb8a29f6137f917618b60a72a57a732" translate="yes" xml:space="preserve">
          <source>It expects the connection state to be &lt;code&gt;:set&lt;/code&gt;, otherwise raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; for &lt;code&gt;:unset&lt;/code&gt; connections or a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; for already &lt;code&gt;:sent&lt;/code&gt; connections.</source>
          <target state="translated">연결 상태는 &lt;code&gt;:set&lt;/code&gt; 이어야하고 , 그렇지 않으면 &lt;code&gt;:unset&lt;/code&gt; 연결에 대해 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 를 발생 시키거나 이미 &lt;code&gt;:sent&lt;/code&gt; 연결에 대해 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="0a5b52d3a097156da96dfb9a0fc91d7fc8826359" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and a text filter.</source>
          <target state="translated">현재 LiveView, 쿼리 선택기 및 텍스트 필터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eeb5bf8f84e63e5c41f8e19268de1412b7da7891" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</source>
          <target state="translated">현재 LiveView, 쿼리 선택기 및 양식 데이터가 필요합니다. 쿼리 선택기는 단일 요소를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="13049f4b2fe95fa18841a16d72fe416ecdcdc085" translate="yes" xml:space="preserve">
          <source>It expects the name of the otp app as the first argument and for the command to be run inside your umbrella application's apps directory:</source>
          <target state="translated">첫 번째 인수로 otp 앱의 이름을 예상하고 우산 애플리케이션의 앱 디렉터리 내에서 명령이 실행될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="6924324cbc62c482292289a444954ec7291d8685" translate="yes" xml:space="preserve">
          <source>It expects the name of the project as an argument.</source>
          <target state="translated">프로젝트 이름을 인수로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="4fca821bf0466e51b6ba5d79e2a1aa5f069282af" translate="yes" xml:space="preserve">
          <source>It expects the path of the project as an argument.</source>
          <target state="translated">프로젝트의 경로를 인수로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="08038ecbe054a873bb08a6b11a9614856a8f9ff2" translate="yes" xml:space="preserve">
          <source>It expects the value of &lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if there is no state in the session.</source>
          <target state="translated">&lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt; 의 값을 예상합니다 . 세션에 상태가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66c2fa1bb2a3b72c645dc3842e1b860a47918db6" translate="yes" xml:space="preserve">
          <source>It expects the view module, the template as a string, and a set of assigns.</source>
          <target state="translated">뷰 모듈, 문자열로 된 템플릿 및 할당 집합이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="31903f698d3d42eef26a2983ba701e0cade71b54" translate="yes" xml:space="preserve">
          <source>It expects three parameters:</source>
          <target state="translated">세 가지 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7f16d994b67422cffaafcda9f7a4a44b5dac9b6a" translate="yes" xml:space="preserve">
          <source>It has to return a supervisor child specification.</source>
          <target state="translated">감독자 자식 사양을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b418dc1717675b2c364bf1025422ff35a375736" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;a href=&quot;#child_spec/3&quot;&gt;&lt;code&gt;child_spec/3&lt;/code&gt;&lt;/a&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">필요한 &lt;a href=&quot;#child_spec/3&quot;&gt; &lt;code&gt;child_spec/3&lt;/code&gt; &lt;/a&gt; 함수와 WebSocket 전송 핸들러를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7050d3a8bafe3360f1738cb2135b721856f7ed7b" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;code&gt;child_spec/3&lt;/code&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">WebSocket 전송을위한 핸들러뿐만 아니라 필수 &lt;code&gt;child_spec/3&lt;/code&gt; 함수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="078983c5e35a9c8a686a6ae53ccec194f56ab546" translate="yes" xml:space="preserve">
          <source>It invokes the &lt;code&gt;validator&lt;/code&gt; function to perform the validation only if a change for the given &lt;code&gt;field&lt;/code&gt; exists and the change value is not &lt;code&gt;nil&lt;/code&gt;. The function must return a list of errors (with an empty list meaning no errors).</source>
          <target state="translated">주어진 &lt;code&gt;field&lt;/code&gt; 대한 변경이 존재하고 변경 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 유효성 검증을 수행하기 위해 &lt;code&gt;validator&lt;/code&gt; 함수를 호출합니다 . 이 함수는 오류 목록을 리턴해야합니다 (빈 목록은 오류가 없음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="b32bb8330646b67711708edabee82d77ea1330ee" translate="yes" xml:space="preserve">
          <source>It is advised to do as little work as possible when handling errors and avoid accessing data like parameters and session, as the parsing of those is what could have led the error to trigger in the first place.</source>
          <target state="translated">오류를 처리 할 때 가능한 한 적은 작업을 수행하고 매개 변수 및 세션과 같은 데이터에 액세스하는 것을 피하는 것이 좋습니다.이를 분석하면 오류가 처음에 트리거 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a9bfb318603777a6353f70162343fdb59351cda5" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; 를 혼동하지 않는 것도 중요 합니다. 전자는 연결을 예상하고 콘텐츠 협상에 의존하는 반면 후자는 연결에 구애받지 않고 일반적으로 뷰에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c2327b2734d4abd79bc9e71baaac2419dacff235" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;phoenix.controller#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; 를 혼동하지 않는 것도 중요 합니다. 전자는 연결을 기대하고 콘텐츠 협상에 의존하지만 후자는 연결에 무관하며 일반적으로 사용자의 관점에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a11a5417c769069994d2708a4c685591dad9818" translate="yes" xml:space="preserve">
          <source>It is also important to keep in mind that LiveViews are stateful. Therefore, if you load any data on &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and the data itself changes, the data won't be automatically propagated to the LiveView, unless you broadcast those events with &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">LiveView가 상태 저장이라는 점을 기억하는 것도 중요합니다. 당신의 모든 데이터를로드하는 경우 따라서, &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt; 하고 자체는 변경 데이터를 당신과 함께 해당 이벤트 방송하지 않는 한, 데이터는 자동으로 라이브 뷰에 전파되지 않습니다 &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a635280fb829c46f3ffad5a5d1753b1e733763d" translate="yes" xml:space="preserve">
          <source>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</source>
          <target state="translated">처리기를 먼저 지정하는 것도 중요합니다. 그렇지 않으면 Phoenix는 처리기가 처리기에 도달하기 전에 요청을 가로 챌 것입니다.</target>
        </trans-unit>
        <trans-unit id="30055e2131468401399af6d6f093161c25f60030" translate="yes" xml:space="preserve">
          <source>It is also not possible to use &lt;code&gt;insert_all&lt;/code&gt; to insert across multiple tables, therefore associations are not supported.</source>
          <target state="translated">&lt;code&gt;insert_all&lt;/code&gt; 을 사용 하여 여러 테이블에 삽입 할 수도 없으므로 연관이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5881689e685ad3746b2176daf7ae680c41d23de2" translate="yes" xml:space="preserve">
          <source>It is also possible to assign data to the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; that will be available to any plug invoked after the &lt;code&gt;:match&lt;/code&gt; plug. This is very useful if you want a matched route to customize how later plugs will behave.</source>
          <target state="translated">또한 &lt;code&gt;:match&lt;/code&gt; 플러그 이후에 호출 된 모든 플러그에서 사용할 수 있는 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; 에&lt;/a&gt; 데이터를 할당 할 수도 있습니다 . 이는 나중에 플러그가 작동하는 방식을 사용자 정의하기 위해 일치하는 경로를 원하는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a8b8d8d53d8d8d7bd2e2cb61ea0c656280b0dd19" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate an Ecto query on the right side of &lt;code&gt;in&lt;/code&gt;. For example, the query above can also be written as:</source>
          <target state="translated">그것의 오른쪽 측의 체외 쿼리를 보간하는 것도 가능하다 &lt;code&gt;in&lt;/code&gt; . 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21ad6a95ad909158ac71de812586e3b7701491a" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</source>
          <target state="translated">전체 키워드 목록을 보간하여 소스를 동적으로 필터링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a3ef7d36b21828db375bf831fd19d83692ffc6" translate="yes" xml:space="preserve">
          <source>It is also possible to nest resources in a Phoenix router. Let's say we also have a &lt;code&gt;posts&lt;/code&gt; resource which has a many-to-one relationship with &lt;code&gt;users&lt;/code&gt;. That is to say, a user can create many posts, and an individual post belongs to only one user. We can represent that by adding a nested route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; like this:</source>
          <target state="translated">Phoenix 라우터에 리소스를 중첩 할 수도 있습니다. &lt;code&gt;users&lt;/code&gt; 와 다 대일 관계를 갖는 &lt;code&gt;posts&lt;/code&gt; 리소스 도 있다고 가정 해 보겠습니다 . 즉, 사용자는 여러 개의 게시물을 작성할 수 있으며 개별 게시물은 한 명의 사용자에게만 속합니다. 다음 과 같이 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 에 중첩 된 경로를 추가하여이를 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="767bbb26545ab7a71781118c61665b361ea9b2c7" translate="yes" xml:space="preserve">
          <source>It is also possible to pass additional session information to the LiveView through a session parameter:</source>
          <target state="translated">세션 매개 변수를 통해 추가 세션 정보를 LiveView에 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5529f115beed361dd6ff5307741dbc9a975d8d" translate="yes" xml:space="preserve">
          <source>It is also possible to say the type must match the same of a column:</source>
          <target state="translated">유형이 동일한 열과 일치해야한다고 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="731c24ca319f444e53ad6c345b4820aa7c05979b" translate="yes" xml:space="preserve">
          <source>It is also possible to select a struct and limit the returned fields at the same time:</source>
          <target state="translated">구조체를 선택하고 반환 된 필드를 동시에 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a7d66c051591aae4846e19708e277358bb5702" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; directly or even run your own pubsub backends outside of an Endpoint.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 를&lt;/a&gt; 직접 사용 하거나 엔드 포인트 외부에서 고유 한 pubsub 백엔드를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80ee5c83f90af2cbd062b219e7dd0adf9de15c1" translate="yes" xml:space="preserve">
          <source>It is common for a LiveView to have multiple states and multiple URLs. For example, you can have a single LiveView that lists all articles on your web app. For each article there is an &quot;Edit&quot; button which, when pressed, opens up a modal on the same page to edit the article. It is a best practice to use live navigation in those cases, so when you click edit, the URL changes to &quot;/articles/1/edit&quot;, even though you are still within the same LiveView. Similarly, you may also want to show a &quot;New&quot; button, which opens up the modal to create new entries, and you want this to be reflected in the URL as &quot;/articles/new&quot;.</source>
          <target state="translated">LiveView에 여러 상태와 여러 URL이있는 것이 일반적입니다. 예를 들어 웹 앱의 모든 아티클을 나열하는 단일 LiveView를 가질 수 있습니다. 각 기사에 대해 &quot;편집&quot;버튼을 누르면 동일한 페이지에서 기사를 편집 할 수있는 모달이 열립니다. 이러한 경우 라이브 내비게이션을 사용하는 것이 가장 좋습니다. 따라서 편집을 클릭하면 동일한 LiveView 내에 있더라도 URL이 &quot;/ articles / 1 / edit&quot;로 변경됩니다. 마찬가지로 새 항목을 만들기위한 모달을 여는 &quot;새로 만들기&quot;버튼을 표시하고이를 URL에 &quot;/ articles / new&quot;로 반영 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a719d875929b73a5f638e46b11bc306d0aaee72" translate="yes" xml:space="preserve">
          <source>It is compiled to:</source>
          <target state="translated">다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="5f416c91fdafe72dbbea13ab378ff98cfdfba3e1" translate="yes" xml:space="preserve">
          <source>It is composed of the following fields:</source>
          <target state="translated">다음과 같은 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92a07cde7a7c28b24072256a01215dba443d5ba7" translate="yes" xml:space="preserve">
          <source>It is important that &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; is placed before the &lt;code&gt;:dispatch&lt;/code&gt; plug in the pipeline, otherwise the matched clause route will not receive the parsed body in its &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; argument when dispatched.</source>
          <target state="translated">&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 는 파이프 라인에서 &lt;code&gt;:dispatch&lt;/code&gt; 플러그 앞에 배치 하는 것이 중요 합니다 . 그렇지 않으면 일치하는 절 경로가 디스패치 될 때 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 인수 에서 구문 분석 된 본문을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a2e2246bf2f06464052843a1b73d10ceadd7820b" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &quot;html&quot; format whenever:</source>
          <target state="translated">브라우저가 역사적으로 잘못된 수락 헤더를 보냈다는 사실을 알아 두는 것이 중요합니다. 이러한 이유로이 함수는 다음과 같은 경우 &quot;html&quot;형식으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d959bc56d3f9eacdf442d02254dff9bed2d3a24c" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &amp;ldquo;html&amp;rdquo; format whenever:</source>
          <target state="translated">브라우저는 역사적으로 잘못된 수락 헤더를 보냈습니다. 이러한 이유로이 기능은 다음과 같은 경우 항상 &quot;html&quot;형식으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="afc85cab7e33f056d309bd20e21206dd571d1b09" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and want to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">HSTS는 SSL 용 포트가 443 일 것으로 예상하기 때문에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 에서 포트를 직접 구성 할 수 없습니다 . HSTS를 사용하지 않고 다른 포트에서 HTTPS로 리디렉션하려는 경우 호스트와 함께 숨길 수 있습니다 (예 : &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8df7a21de3fad9373d1e80d0a68fb9c2af463623" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;plug.ssl#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and wants to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">HSTS는 포트가 SSL에 대해 443이 될 것으로 예상하므로 &lt;a href=&quot;plug.ssl#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 에서 포트를 직접 구성 할 수 없습니다 . HSTS를 사용하지 않고 다른 포트에서 HTTPS로 경로 재 지정하려는 경우 호스트와 함께 몰래 이동할 수 있습니다 (예 : &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb866ba422c5f8373a8e029337285f653ad8d5ad" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto&amp;rsquo;s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Ecto의 쿼리 구문을 사용하여 가능한 모든 데이터베이스 쿼리를 나타내는 것은 불가능합니다. 필요한 경우 조각을 사용하여 데이터베이스에 표현식을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ce5ae4e3f70bf7bcfc04fd5cadb18e0b1c097f" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto's query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Ecto의 쿼리 구문을 사용하여 가능한 모든 데이터베이스 쿼리를 표현하는 것은 불가능합니다. 필요한 경우 조각을 사용하여 모든 표현식을 데이터베이스에 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f6c0d9ff724f7de2dd203438fa29365111d1aa" translate="yes" xml:space="preserve">
          <source>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">Phoenix 애플리케이션에 사용자 정의 미디어 유형을 추가 할 수 있습니다. 첫 번째 단계는 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 새로운 미디어 유형에 대해 플러그를 가르치는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aa42a2a034d292f94558a8e07cc5079c64f6d273" translate="yes" xml:space="preserve">
          <source>It is possible to bundle the certificate files with the application, possibly for packaging into a release. In this case the files must be stored under the application's 'priv' directory. The &lt;code&gt;otp_app&lt;/code&gt; option must be set to the name of the OTP application that contains the files, in order to correctly resolve the relative paths:</source>
          <target state="translated">릴리스로 패키징하기 위해 애플리케이션과 함께 인증서 파일을 번들로 묶을 수 있습니다. 이 경우 파일은 애플리케이션의 'priv'디렉토리에 저장되어야합니다. &lt;code&gt;otp_app&lt;/code&gt; 의 옵션이 올바르게 상대 경로를 해결하기 위해, 파일이 들어있는 OTP 응용 프로그램의 이름으로 설정해야합니다 :</target>
        </trans-unit>
        <trans-unit id="c6fa08a29b74dfb5f5b32afcba99b61a22649c51" translate="yes" xml:space="preserve">
          <source>It is possible to include variables in the path, these will be available in the &lt;code&gt;params&lt;/code&gt; that are passed to the socket.</source>
          <target state="translated">경로에 변수를 포함 할 수 있으며 소켓으로 전달 되는 &lt;code&gt;params&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2d8626fbe4ef6e2589dce4fc2dd6762fe2a1b8" translate="yes" xml:space="preserve">
          <source>It is possible to make use of PostgreSQL&amp;rsquo;s JSON/JSONB data type with fragments, as well:</source>
          <target state="translated">PostgreSQL의 JSON / JSONB 데이터 유형을 조각과 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef6e9ed5dbdf5b36ce6e79f0b64c7e18c4f11c1" translate="yes" xml:space="preserve">
          <source>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</source>
          <target state="translated">쿼리의 접두사를 설정할 수 있습니다. Postgres 사용자의 경우 테이블이있는 스키마를 지정하고 MySQL 사용자의 경우 테이블이있는 데이터베이스를 지정합니다. 접두사가 설정되지 않으면 Postgres 쿼리는 퍼블릭 스키마에있는 것으로 가정하고 MySQL 쿼리는 리포지토리의 구성에 설정된 데이터베이스에있는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="700c0f421fd3cd0dfcac1f7b125e6e262daac824" translate="yes" xml:space="preserve">
          <source>It is possible to set:</source>
          <target state="translated">다음을 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="90c2522cafce21dec34e2ada4a5ef033ed999c16" translate="yes" xml:space="preserve">
          <source>It is possible to specify a &lt;code&gt;:where&lt;/code&gt; option that will filter the records returned by the association. Querying, joining or preloading the association will use the given conditions as shown next:</source>
          <target state="translated">연결에 의해 반환 된 레코드를 필터링 하는 &lt;code&gt;:where&lt;/code&gt; 옵션 을 지정할 수 있습니다 . 연결 쿼리, 조인 또는 사전로드는 다음과 같이 주어진 조건을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="29ec728a65755ba3d79cf56f0945ca98b6fece30" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lower-case, to avoid sending duplicate keys in a request. As a convenience, this is validated during testing which raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header key is not lowercase.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상, 이것은 헤더 키가 소문자가 아닌 경우 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를&lt;/a&gt; 발생시키는 테스트 중에 검증 됩니다.</target>
        </trans-unit>
        <trans-unit id="b406934b6940f484ccb4f4e12d7de52338c19b17" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 지정하는 것이 좋습니다. 또한 HTTP / 2를 통해 제공되는 대소 문자 혼합 헤더가있는 응답은 일반 클라이언트에서 유효하지 않은 것으로 간주되어 응답이 삭제됩니다. 편의상 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 어댑터를 사용할 때 소문자가 아닌 헤더는 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40511b3383ca8f06336921afea27344c64c63c88" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren&amp;rsquo;t lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 어댑터를 사용할 때 소문자가 아닌 헤더는 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e835d630e658a66295e09f0cfb72bb2ca5635f8b" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; and a default of &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (although Ecto will also automatically translate &lt;code&gt;nil&lt;/code&gt; values from the database into empty lists).</source>
          <target state="translated">형식 &lt;code&gt;:map&lt;/code&gt; 및 기본값 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 필드 를 선언하는 것이 좋습니다 (Ecto는 데이터베이스의 &lt;code&gt;nil&lt;/code&gt; 값 도 자동 으로 빈 목록 으로 변환하지만 ).</target>
        </trans-unit>
        <trans-unit id="06eb543ba97430c42676fb74fc38e6d03236b950" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; in your migrations, instead of using &lt;code&gt;{:array, :map}&lt;/code&gt;. Ecto can work with both maps and arrays as the container for embeds (and in most databases map are represented as JSON which allows Ecto to choose what works best).</source>
          <target state="translated">&lt;code&gt;{:array, :map}&lt;/code&gt; 을 사용하는 대신 마이그레이션에서 &lt;code&gt;:map&lt;/code&gt; 유형으로 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 필드 를 선언하는 것이 좋습니다 . Ecto는 임베딩을위한 컨테이너로 맵과 배열 모두에서 작동 할 수 있습니다 (대부분의 데이터베이스 맵은 JSON으로 표시되어 Ecto가 가장 잘 작동하는 것을 선택할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9795c1abaf982033b2c0ed19994a9b57e226ca48" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &amp;lsquo;dhparam.pem&amp;rsquo; file:</source>
          <target state="translated">DHE 키 교환에 사용될 Diffie Hellman 매개 변수의 사용자 정의 세트를 생성하는 것이 좋습니다. 다음 OpenSSL CLI 명령을 사용하여 'dhparam.pem'파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b6125fd22c0937a1706898816d0d97050f844cc0" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie-Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &lt;code&gt;dhparam.pem&lt;/code&gt; file:</source>
          <target state="translated">DHE 키 교환에 사용할 사용자 지정 Diffie-Hellman 매개 변수 집합을 생성하는 것이 좋습니다. 다음 OpenSSL CLI 명령을 사용하여 &lt;code&gt;dhparam.pem&lt;/code&gt; 파일 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="1ed21c543268df4242ce9c821e6a091cd15a3cd4" translate="yes" xml:space="preserve">
          <source>It is recommended to include this metadata configuration in your production configuration file.</source>
          <target state="translated">프로덕션 구성 파일에이 메타 데이터 구성을 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ee450f18792f77e7f28caa695a4e8a21ae132da1" translate="yes" xml:space="preserve">
          <source>It is recommended to only use this module in production if SSL is enabled and enforced. See &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">SSL이 활성화되고 적용되는 경우에만 프로덕션에서이 모듈을 사용하는 것이 좋습니다. 자세한 정보는 &lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21f5e912f003026e9540afe4bf51bf871b3398c0" translate="yes" xml:space="preserve">
          <source>It is rendered in the error page as a collection of buttons and follows the format of: &lt;code&gt;[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]&lt;/code&gt;.</source>
          <target state="translated">오류 페이지에서 버튼 모음으로 렌더링되며 다음 형식을 따릅니다. &lt;code&gt;[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce90e2d8912f1f2f7b4ea1417a8fb3575961cda" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#media_type/1&quot;&gt;&lt;code&gt;media_type/1&lt;/code&gt;&lt;/a&gt; except wildcards are not accepted in the type nor in the subtype.</source>
          <target state="translated">와일드 카드는 유형이나 하위 유형으로 허용되지 않는다는 점을 제외하면 &lt;a href=&quot;#media_type/1&quot;&gt; &lt;code&gt;media_type/1&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ed4b71fb3d52453bbf4aa28da6905ada01f52ccb" translate="yes" xml:space="preserve">
          <source>It is used on &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt;&lt;code&gt;Ecto.Repo.all/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt;. If returns a tuple, saying if this query can be cached or not, and the &lt;code&gt;prepared&lt;/code&gt; query. The &lt;code&gt;prepared&lt;/code&gt; query is any term that will be passed to the adapter's &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 사용되는 &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt; &lt;code&gt;Ecto.Repo.all/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt; &lt;/a&gt; . If이 쿼리를 캐시 할 수 있는지 여부와 &lt;code&gt;prepared&lt;/code&gt; 쿼리를 나타내는 튜플을 반환 합니다. &lt;code&gt;prepared&lt;/code&gt; 쿼리는 어댑터로 전달의됩니다 어떤 용어 &lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d8b235293c3fd441987efade8483fcf5a50bbd4" translate="yes" xml:space="preserve">
          <source>It is very common in Phoenix applications to namespace all of your routes under the application scope:</source>
          <target state="translated">응용 프로그램 범위에서 모든 경로를 네임 스페이스로 만드는 것은 Phoenix 응용 프로그램에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="511755381ec8f835711d51bfe3c71d347d8afc8e" translate="yes" xml:space="preserve">
          <source>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; function to give Ecto some hints:</source>
          <target state="translated">Ecto는 프래그먼트를 사용할 때 위에서 설명한 유형 캐스팅을 수행 할 수 없다는 점을 명심해야합니다. 그러나 &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Ecto에 힌트를 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03eb895c6aaf845d553a17cb55cfa9b526d9cdd9" translate="yes" xml:space="preserve">
          <source>It is worth noting that the &lt;code&gt;text/2&lt;/code&gt;, &lt;code&gt;json/2&lt;/code&gt;, and &lt;code&gt;html/2&lt;/code&gt; functions require neither a Phoenix view, nor a template to render.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;code&gt;text/2&lt;/code&gt; , &lt;code&gt;json/2&lt;/code&gt; , 및 &lt;code&gt;html/2&lt;/code&gt; 기능은 피닉스보기도 렌더링 할 수있는 템플릿도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c89a89c57953342eddacd89ee3ae33933dbb8c2" translate="yes" xml:space="preserve">
          <source>It is worth noting that the cipher lists and TLS protocol versions selected by the profiles are whitelists. If a new Erlang/OTP release introduces new TLS protocol versions or ciphers that are not included in the profile definition, they would have to be enabled explicitly by overriding the &lt;code&gt;:ciphers&lt;/code&gt; and/or &lt;code&gt;:versions&lt;/code&gt; options, until such time as they are added to the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; profiles.</source>
          <target state="translated">프로필에서 선택한 암호 목록 및 TLS 프로토콜 버전이 허용 목록이라는 점은 주목할 가치가 있습니다. 새 Erlang / OTP 릴리스가 프로필 정의에 포함되지 않은 새 TLS 프로토콜 버전 또는 암호를 도입하는 경우 추가 될 때까지 &lt;code&gt;:ciphers&lt;/code&gt; 및 / 또는 &lt;code&gt;:versions&lt;/code&gt; 옵션 을 재정 의하여 명시 적으로 활성화해야합니다 . &lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; 의&lt;/a&gt; 프로필.</target>
        </trans-unit>
        <trans-unit id="3f8bd155fb3b264871458601bfe98b34947ef8af" translate="yes" xml:space="preserve">
          <source>It must be a map and Ecto itself will always inject two keys into the meta:</source>
          <target state="translated">맵이어야하며 Ecto 자체는 항상 메타에 두 개의 키를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="d812a176eca481ceed3aeedcb084d96bdf1cfa9d" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The entries in the actual list will depend on what has been selected by the query. The result set may also be &lt;code&gt;nil&lt;/code&gt;, if no value is being selected.</source>
          <target state="translated">항목 수와 결과 집합을 목록 목록으로 포함하는 튜플을 반환해야합니다. 실제 목록의 항목은 쿼리에서 선택한 항목에 따라 다릅니다. 값이 선택되지 않은 경우 결과 집합은 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c7bf550d2dd91e3eb7f4d8ba8c5d8e72098cb71" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be &lt;code&gt;nil&lt;/code&gt; if a particular operation does not support them.</source>
          <target state="translated">항목 수와 결과 집합이 포함 된 튜플을 목록 목록으로 반환해야합니다. 특정 작업에서 지원하지 않는 경우 결과 집합이 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64d6ad431d01d7158a8dd5f4441d9f4c19873287" translate="yes" xml:space="preserve">
          <source>It must return either &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, socket, options}&lt;/code&gt;, where &lt;code&gt;options&lt;/code&gt; is one of:</source>
          <target state="translated">&lt;code&gt;{:ok, socket}&lt;/code&gt; 또는 &lt;code&gt;{:ok, socket, options}&lt;/code&gt; 를 반환해야합니다 . 여기서 &lt;code&gt;options&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="c372464cefb3e13bb0538ac72ed0e91a45083451" translate="yes" xml:space="preserve">
          <source>It parses the key and stores the value into the current accumulator. The keys and values are not assumed to be encoded in &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">키를 구문 분석하고 값을 현재 누산기에 저장합니다. 키와 값은 &quot;x-www-form-urlencoded&quot;로 인코딩 된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="314f1d4137cff9c77fcca4b6566e917e92565ed8" translate="yes" xml:space="preserve">
          <source>It prints some connection information to the terminal</source>
          <target state="translated">일부 연결 정보를 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f49388dc41541c5a93c112295bb0bf75921390c9" translate="yes" xml:space="preserve">
          <source>It provides a set of macros to generate routes. For example:</source>
          <target state="translated">라우트를 생성하는 매크로 세트를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c755bbbfc1da5a9d523689127fd834eafd36c41a" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;dumper&lt;/code&gt; function in case the parameterized type is also a composite type. In order to dump the inner type, the &lt;code&gt;dumper&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="translated">매개 변수화 된 유형이 복합 유형 인 경우 &lt;code&gt;dumper&lt;/code&gt; 함수를 수신합니다 . 내부 유형을 덤프하려면 내부 유형과 내부 값을 인수로 사용 하여 &lt;code&gt;dumper&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f17d561fdc66ef79304d69e078c0e5c0312c23e" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;loader&lt;/code&gt; function in case the parameterized type is also a composite type. In order to load the inner type, the &lt;code&gt;loader&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="translated">매개 변수화 된 유형이 복합 유형 인 경우 &lt;code&gt;loader&lt;/code&gt; 기능을 수신합니다 . 내부 유형을로드하려면 내부 유형과 내부 값을 인수로 사용 하여 &lt;code&gt;loader&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="328d30d44e29c2cd6e3dd38f65d5cb32fb69e161" translate="yes" xml:space="preserve">
          <source>It receives a connection and options (that we do not use)</source>
          <target state="translated">연결 및 옵션 (우리가 사용하지 않는)을받습니다.</target>
        </trans-unit>
        <trans-unit id="aeb6380d88e1271819dcb40ba83ee9babe0b5d5c" translate="yes" xml:space="preserve">
          <source>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</source>
          <target state="translated">서버가 렌더링 할 수있는 형식 목록 인 연결을 수신 한 다음 요청 정보를 기반으로 컨텐츠 협상을 진행합니다. 클라이언트가 주어진 형식 중 하나를 승인하면 요청이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="a632a124b740ee3ecfe4c66cfbe50a9b8a5330c6" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 처음에 주어진 유형의 덤퍼 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5336dd4112321d4cfb426214c2399ecd75a7e8c" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 끝에 주어진 유형의 로더 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8d567de13218d83676c9bf848a612d0dcb63a942" translate="yes" xml:space="preserve">
          <source>It receives the socket options from the endpoint, for example:</source>
          <target state="translated">끝점에서 소켓 옵션을받습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eead6f123b731bd151755a8d6351651f60a5cb89" translate="yes" xml:space="preserve">
          <source>It requires the given form to be configured with &lt;code&gt;multipart: true&lt;/code&gt; when invoking &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt;, otherwise it fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 주어진 양식을 &lt;code&gt;multipart: true&lt;/code&gt; 로 구성 해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="b444a758782f3e5a243723f32117b04bcd1193d7" translate="yes" xml:space="preserve">
          <source>It requires two options:</source>
          <target state="translated">두 가지 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c368117d80fc577cffd447c6b5a5ef62cbb74d54" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, headers, conn}&lt;/code&gt; with the headers or &lt;code&gt;{:done, conn}&lt;/code&gt; if there are no more parts.</source>
          <target state="translated">&lt;code&gt;{:ok, headers, conn}&lt;/code&gt; 와 함께 {: ok, headers, conn} 을 반환 하거나 더 이상 부품이 없으면 &lt;code&gt;{:done, conn}&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625a8c24b534dfa374e922372c9b8979bedc267b" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 또는 &lt;code&gt;{:error, reply}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="056c105e63679c152071fae62b19b0a4e30832f1" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully deleted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삭제 된 경우 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="662e3be55825a0906e817964327528ec203f0e24" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully inserted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삽입되거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="ebff193a925e1e6c88a5aaae59a0f61ddce1cce8" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully updated or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 업데이트하거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="0de4905b00b9de98c7609ccd5172409bb3e98d86" translate="yes" xml:space="preserve">
          <source>It returns a stream of values.</source>
          <target state="translated">값의 스트림을 리턴합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
