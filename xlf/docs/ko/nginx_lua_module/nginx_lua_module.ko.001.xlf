<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nginx_lua_module">
    <body>
      <group id="nginx_lua_module">
        <trans-unit id="0776eab0e9d0f01c57a726b39f51c0f67e1ea474" translate="yes" xml:space="preserve">
          <source>&quot;Light threads&quot; are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</source>
          <target state="translated">&quot;가벼운 스레드&quot;는 ngx_lua 모듈에 의해 예약 된 특별한 종류의 Lua 코 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="f8d5300899a95a6a1a6deaa3e9a32a1082261afa" translate="yes" xml:space="preserve">
          <source>&quot;Light threads&quot; are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; that can work with all the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt;. The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (similar to Facebook's BigPipe model):</source>
          <target state="translated">&quot;가벼운 스레드&quot;는 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua 용&lt;/a&gt; 모든 Nginx API 와 작동 할 수 있는 일반화 된 버전의 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 와 매우 유사한 단일 Nginx 요청 핸들러에서 동시 업스트림 요청을 작성하는 데 주로 유용합니다 . 다음 예제는 단일 Lua 핸들러에서 MySQL, Memcached 및 업스트림 HTTP 서비스에 대한 병렬 요청을 보여주고 실제로 리턴하는 순서대로 결과를 출력합니다 (Facebook의 BigPipe 모델과 유사 함).</target>
        </trans-unit>
        <trans-unit id="7ae047dd7457f994786b238f319ddfbb7e626636" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2017 Xiaozhe Wang (chaoslawful)</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2017 Xiaozhe Wang (혼돈)</target>
        </trans-unit>
        <trans-unit id="a9200a21ce9744bc6e0630c30c1e8675277278ca" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Yichun &quot;agentzh&quot; Zhang (章亦春), OpenResty Inc.</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2018 Yichun &quot;agentzh&quot;Zhang (章 亦 春), OpenResty Inc.</target>
        </trans-unit>
        <trans-unit id="9856017d8a5440c6f814f05c8e1f3bb4025346fb" translate="yes" xml:space="preserve">
          <source>1.10.x</source>
          <target state="translated">1.10.x</target>
        </trans-unit>
        <trans-unit id="690c631e6cda34be404f415b4dd75bb598db7169" translate="yes" xml:space="preserve">
          <source>1.11.x (last tested: 1.11.2)</source>
          <target state="translated">1.11.x (최종 테스트 : 1.11.2)</target>
        </trans-unit>
        <trans-unit id="44f6cd4d06a21c34068d9d365200b748937bf8dc" translate="yes" xml:space="preserve">
          <source>1.12.x</source>
          <target state="translated">1.12.x</target>
        </trans-unit>
        <trans-unit id="2c5f46dd90db75a26b290c0f7f04ed9148ec58f5" translate="yes" xml:space="preserve">
          <source>1.13.x (last tested: 1.13.6)</source>
          <target state="translated">1.13.x (최종 테스트 : 1.13.6)</target>
        </trans-unit>
        <trans-unit id="c547245d08ac55419baf6bdbc03da9196c55e45c" translate="yes" xml:space="preserve">
          <source>1.6.x</source>
          <target state="translated">1.6.x</target>
        </trans-unit>
        <trans-unit id="f08d7423628faabb5445f5fdced26849df29811d" translate="yes" xml:space="preserve">
          <source>1.7.x (last tested: 1.7.10)</source>
          <target state="translated">1.7.x (최종 테스트 : 1.7.10)</target>
        </trans-unit>
        <trans-unit id="b28ab85ad05e3b632943081b56c292bde1c5dcb7" translate="yes" xml:space="preserve">
          <source>1.8.x</source>
          <target state="translated">1.8.x</target>
        </trans-unit>
        <trans-unit id="6f14872b6da159dd0a7e84367a904052b54d0aa0" translate="yes" xml:space="preserve">
          <source>1.9.x (last tested: 1.9.15)</source>
          <target state="translated">1.9.x (최종 테스트 : 1.9.15)</target>
        </trans-unit>
        <trans-unit id="aec056bf0ad251b4e0986bb4084c8875ec9aa146" translate="yes" xml:space="preserve">
          <source>3rd-party Lua libraries:</source>
          <target state="translated">타사 Lua 라이브러리 :</target>
        </trans-unit>
        <trans-unit id="503a11ed76700de2094cf34ae5dd5f3410167160" translate="yes" xml:space="preserve">
          <source>400 (Bad Request)</source>
          <target state="translated">400 잘못된 요청)</target>
        </trans-unit>
        <trans-unit id="c84440c052a21c702f1adcf0892d5247f44935ef" translate="yes" xml:space="preserve">
          <source>405 (Not Allowed)</source>
          <target state="translated">405 (허용되지 않음)</target>
        </trans-unit>
        <trans-unit id="c42281e56f0ab290ad9ce9a93695464566cbdb95" translate="yes" xml:space="preserve">
          <source>408 (Request Timeout)</source>
          <target state="translated">408 (요청 시간 초과)</target>
        </trans-unit>
        <trans-unit id="c5767398e05097f2ffbac609dde4263b011ffebf" translate="yes" xml:space="preserve">
          <source>413 (Request Entity Too Large)</source>
          <target state="translated">413 요청 엔티티가 너무 큼)</target>
        </trans-unit>
        <trans-unit id="98ce288198119333122096d76ee1db36cc0180ca" translate="yes" xml:space="preserve">
          <source>414 (Request URI Too Large)</source>
          <target state="translated">414 (요청 URI가 너무 큼)</target>
        </trans-unit>
        <trans-unit id="9198279132d9113a13468193bfe0dde9653eaeba" translate="yes" xml:space="preserve">
          <source>494 (Request Headers Too Large)</source>
          <target state="translated">494 (요청 헤더가 너무 큼)</target>
        </trans-unit>
        <trans-unit id="bbdf877267accb1b067c3a866ba5bffe0733de4c" translate="yes" xml:space="preserve">
          <source>499 (Client Closed Request)</source>
          <target state="translated">499 (클라이언트 종료 요청)</target>
        </trans-unit>
        <trans-unit id="ffbf39a10b9aa165ac2d010205f182831ad27a69" translate="yes" xml:space="preserve">
          <source>500 (Internal Server Error)</source>
          <target state="translated">500 내부 서버 오류)</target>
        </trans-unit>
        <trans-unit id="a25fd04426741c3db80aff8da303aef1b4a5b990" translate="yes" xml:space="preserve">
          <source>501 (Not Implemented)</source>
          <target state="translated">501 (구현되지 않음)</target>
        </trans-unit>
        <trans-unit id="8184add052ee55f00e07d52ab50f0b38222f9ebd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz&quot;&gt;ngx_auth_request&lt;/a&gt; (this is not needed if you're using Nginx 1.5.4+.</source>
          <target state="translated">&lt;a href=&quot;http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz&quot;&gt;ngx_auth_request&lt;/a&gt; (Nginx 1.5.4 이상을 사용하는 경우 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1de3e814d4e9a343c5d027cb6a7db4a6f3dcaa13" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cloudflare/lua-resty-cookie&quot;&gt;lua-resty-cookie&lt;/a&gt; library for HTTP cookie manipulation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cloudflare/lua-resty-cookie&quot;&gt;&lt;/a&gt;HTTP 쿠키 조작을위한 lua-resty-cookie 라이브러리.</target>
        </trans-unit>
        <trans-unit id="a759ed1bd737f1daa7583d22dfc7550b7429f63b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-dns&quot;&gt;lua-resty-dns&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-dns&quot;&gt;&lt;/a&gt;ngx_lua 코 소켓을 기반으로하는 lua-resty-dns 라이브러리</target>
        </trans-unit>
        <trans-unit id="1a8882a5265dbdde339d5bc52b1d4ad0135321a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-lock&quot;&gt;lua-resty-lock&lt;/a&gt; library for a nonblocking simple lock API.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-lock&quot;&gt;&lt;/a&gt;비 차단 단순 잠금 API를위한 lua-resty-lock 라이브러리.</target>
        </trans-unit>
        <trans-unit id="64a96bbbeb83988a836c62539f753f9c0325304f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-memcached&quot;&gt;lua-resty-memcached&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-memcached&quot;&gt;&lt;/a&gt;ngx_lua 코 소켓을 기반으로하는 lua-resty-memcached 라이브러리</target>
        </trans-unit>
        <trans-unit id="1a6e1d7364481c25a627bf65cc582bf65839a442" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-mysql&quot;&gt;lua-resty-mysql&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-mysql&quot;&gt;&lt;/a&gt;ngx_lua 코 소켓 기반의 lua-resty-mysql 라이브러리.</target>
        </trans-unit>
        <trans-unit id="979a69517ee58c0ea3d1530a7ac876e132a781b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-redis&quot;&gt;lua-resty-redis&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-redis&quot;&gt;&lt;/a&gt;ngx_lua 코 소켓을 기반으로하는 lua-resty-redis 라이브러리</target>
        </trans-unit>
        <trans-unit id="4f7ba41e5bf14c88df52c04c8737e59852222b3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-string&quot;&gt;lua-resty-string&lt;/a&gt; library based on &lt;a href=&quot;http://luajit.org/ext_ffi.html&quot;&gt;LuaJIT FFI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-string&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://luajit.org/ext_ffi.html&quot;&gt;LuaJIT FFI&lt;/a&gt; 기반의 lua-resty-string 라이브러리 .</target>
        </trans-unit>
        <trans-unit id="2384de042df3dfbcd9932422632ef841bfb46511" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-string&quot;&gt;lua-resty-string&lt;/a&gt; library based on &lt;a href=&quot;https://luajit.org/ext_ffi.html&quot;&gt;LuaJIT FFI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee443d0ee86721182108a4f79ec93db95b12b502" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-upload&quot;&gt;lua-resty-upload&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-upload&quot;&gt;&lt;/a&gt;ngx_lua 코 소켓을 기반으로하는 lua-resty-upload 라이브러리</target>
        </trans-unit>
        <trans-unit id="8ce5d69528cd157f7b16afca42c34aaa66ae0572" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;lua-resty-websocket&lt;/a&gt; library for both WebSocket server and client, based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;ngx_lua 코&lt;/a&gt; 소켓을 기반으로하는 WebSocket 서버 및 클라이언트 용 lua-resty-websocket 라이브러리.</target>
        </trans-unit>
        <trans-unit id="219d9037bdbfee60172efae3069b496f39a895d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua_module&lt;/a&gt; for an official port of this module for the NGINX &quot;stream&quot; subsystem (doing generic downstream TCP communications).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngIN_stream_lua_module&lt;/a&gt; NGINX &quot;스트림&quot;서브 시스템 (일반 다운 스트림 TCP 통신 수행)에 대한이 모듈의 공식 포트.</target>
        </trans-unit>
        <trans-unit id="508fc71a7ad99447f77b5e5b6ef1b2c60e8de526" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'*a'&lt;/code&gt;: reads from the socket until the connection is closed. No end-of-line translation is performed;</source>
          <target state="translated">&lt;code&gt;'*a'&lt;/code&gt; : 연결이 닫힐 때까지 소켓에서 읽습니다. 라인 끝 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79ab258a62a13886c264a9c0df336bc423c30ec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'*l'&lt;/code&gt;: reads a line of text from the socket. The line is terminated by a &lt;code&gt;Line Feed&lt;/code&gt; (LF) character (ASCII 10), optionally preceded by a &lt;code&gt;Carriage Return&lt;/code&gt; (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.</source>
          <target state="translated">&lt;code&gt;'*l'&lt;/code&gt; : 소켓에서 한 줄의 텍스트를 읽습니다. 행은 LF ( &lt;code&gt;Line Feed&lt;/code&gt; ) 문자 (ASCII 10) 로 끝나고 선택적으로 &lt;code&gt;Carriage Return&lt;/code&gt; (CR) 문자 (ASCII 13)가 옵니다 . CR 및 LF 문자는 반환 된 행에 포함되지 않습니다. 실제로 모든 CR 문자는 패턴에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="08a8a9724c4adca7536e467df0eaf5cb2cdd6c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;302&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;302&lt;/code&gt; (디폴트 값)</target>
        </trans-unit>
        <trans-unit id="27afa4b9cc43722a437ec9f0962712c37c0b218f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GET /foo/file.php?a=hello&lt;/code&gt; will return &quot;hello&quot; and not &quot;goodbye&quot; in the example below</source>
          <target state="translated">&lt;code&gt;GET /foo/file.php?a=hello&lt;/code&gt; 는 아래 예에서 &quot;안녕&quot;이 아니라 &quot;hello&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae7c59e21565373072ec878151dbd7dc60b56dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_ABORT_AT_PANIC&lt;/code&gt; When the Lua/LuaJIT VM panics, ngx_lua will instruct the current nginx worker process to quit gracefully by default. By specifying this C macro, ngx_lua will abort the current nginx worker process (which usually result in a core dump file) immediately. This option is useful for debugging VM panics. This option was first introduced in the &lt;code&gt;v0.9.8&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_ABORT_AT_PANIC&lt;/code&gt; Lua / LuaJIT VM 패닉이 발생하면 ngx_lua는 현재 nginx 작업자 프로세스가 기본적으로 정상적으로 종료되도록 지시합니다. 이 C 매크로를 지정하면 ngx_lua는 현재 nginx 작업자 프로세스 (일반적으로 코어 덤프 파일이 생성됨)를 즉시 중단합니다. 이 옵션은 VM 패닉 디버깅에 유용합니다. 이 옵션은 &lt;code&gt;v0.9.8&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ad1c0290dfbe7c5aa56a90497b7680f76efcc0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_NO_FFI_API&lt;/code&gt; Excludes pure C API functions for FFI-based Lua API for NGINX (as required by &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt;, for example). Enabling this macro can make the resulting binary code size smaller.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_NO_FFI_API&lt;/code&gt; NGINX 용 FFI 기반 Lua API에 대한 순수 C API 함수를 제외합니다 (예 : &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt; 에 필요). 이 매크로를 사용하면 이진 코드 크기가 더 작아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f59f3b6f8cae6d05405d9c24ad7258993e46c5bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_USE_ASSERT&lt;/code&gt; When defined, will enable assertions in the ngx_lua C code base. Recommended for debugging or testing builds. It can introduce some (small) runtime overhead when enabled. This macro was first introduced in the &lt;code&gt;v0.9.10&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_USE_ASSERT&lt;/code&gt; 정의되면 ngx_lua C 코드베이스에서 어설 션을 활성화합니다. 빌드 디버깅 또는 테스트에 권장됩니다. 활성화되면 약간의 (작은) 런타임 오버 헤드가 발생할 수 있습니다. 이 매크로는 &lt;code&gt;v0.9.10&lt;/code&gt; 릴리스 에서 처음 소개 되었습니다.</target>
        </trans-unit>
        <trans-unit id="522765e013c72ae07785141c5d3077fad39001af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; for the context of &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 의 맥락에 대한 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="958538b1e59cc24cdfa26de5d7f60cf97a0ff23c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always_forward_body&lt;/code&gt; when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the &lt;code&gt;body&lt;/code&gt; option is not specified. The request body read by either &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body()&lt;/a&gt; or &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body on&lt;/a&gt; will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is &lt;code&gt;false&lt;/code&gt; and when the &lt;code&gt;body&lt;/code&gt; option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; request method.</source>
          <target state="translated">&lt;code&gt;always_forward_body&lt;/code&gt; 를 true로 설정하면 &lt;code&gt;body&lt;/code&gt; 옵션이 지정되지 않은 경우 현재 (부모) 요청의 요청 본문이 항상 작성중인 하위 요청으로 전달 됩니다. 요청 체 중 판독 &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body ()&lt;/a&gt; 또는 &lt;a href=&quot;#lua_need_request_body&quot;&gt;에 lua_need_request_body&lt;/a&gt; 작성할 때 모든 요청 본문 데이터를 복사하지 않고 직접 subrequest 전달 될 subrequest (NO 요청 본문 데이터는 메모리 버퍼 또는 임시 파일에 버퍼링되는 중요하거나) . 기본적으로이 옵션은 &lt;code&gt;false&lt;/code&gt; 이며 &lt;code&gt;body&lt;/code&gt; 옵션을 지정하지 않으면 하위 요청이 &lt;code&gt;PUT&lt;/code&gt; 또는 &lt;code&gt;POST&lt;/code&gt; 를 수행 할 때만 현재 (부모) 요청의 요청 본문이 전달됩니다. 요청 방법.</target>
        </trans-unit>
        <trans-unit id="76d1cdb53abfa67c6805bfb2abb40c1ebd5bbb55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; specify the subrequest's URI query arguments (both string value and Lua tables are accepted)</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 하위 요청의 URI 쿼리 인수를 지정합니다 (문자열 값과 Lua 테이블 모두 허용됨).</target>
        </trans-unit>
        <trans-unit id="57014b5b7b33d6764ad668d2e40d747934a6eee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;balancer&lt;/code&gt; for the context of &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;balancer&lt;/code&gt; _by_lua&lt;a href=&quot;#balancer_by_lua_block&quot;&gt;*&lt;/a&gt; 의 컨텍스트에 대한 밸런서 .</target>
        </trans-unit>
        <trans-unit id="e2b1a35b0acebb658c271baf5f030a851716b9a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;body&lt;/code&gt; specify the subrequest's request body (string value only).</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 는 하위 요청의 요청 본문을 지정합니다 (문자열 값만).</target>
        </trans-unit>
        <trans-unit id="065be0724a61f8e94c12ae8619c6110d33c10dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;body_filter&lt;/code&gt; for the context of &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;body_filter&lt;/code&gt; 의 문맥 &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="feca8ce2366f88c6dc2854e6fe77a3a151cb8366" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; for the context of &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua *&lt;/a&gt; 의 컨텍스트에 대한 컨텐츠 .</target>
        </trans-unit>
        <trans-unit id="63b00c35a068bb9b7b378c5b153b7fb9aa798cfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_all_vars&lt;/code&gt; specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;copy_all_vars&lt;/code&gt; 는 현재 요청의 모든 Nginx 변수 값을 해당 하위 요청에 복사할지 여부를 지정합니다. 하위 요청에서 nginx 변수의 수정은 현재 (부모) 요청에 영향을 미치지 않습니다. 이 옵션은 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="705e4c7a821ca3af4ca4fb7e8b6b7b07d3015b4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctx&lt;/code&gt; specify a Lua table to be the &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table for the subrequest. It can be the current request's &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the &lt;code&gt;v0.3.1rc25&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 는 Lua 테이블을 하위 요청에 대한 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; 테이블로 지정합니다. 현재 요청의 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; 테이블 일 수 있으며 , 이는 부모와 하위 요청이 효과적으로 동일한 컨텍스트 테이블을 공유하도록합니다. 이 옵션은 &lt;code&gt;v0.3.1rc25&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b6e08620ef3bf3c45bccddced2acc462ee1a0c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; be zero,</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; &lt;em&gt;은&lt;/em&gt; 0이 될 &lt;em&gt;수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="282b23132d559bf8057bf7a864954d5b948039d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;err&lt;/code&gt;: textual error message, can be &lt;code&gt;&quot;no memory&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;err&lt;/code&gt; : 텍스트 오류 메시지 . &lt;code&gt;&quot;no memory&quot;&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8025d119550e6438b08b3dd395c435c21ac39ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forcible&lt;/code&gt;: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</source>
          <target state="translated">&lt;code&gt;forcible&lt;/code&gt; : 공유 메모리 영역의 스토리지에서 다른 유효한 항목이 강제로 제거되었는지 여부를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfce20f09ecda9e7892f4befe4299678e93db290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;header_filter&lt;/code&gt; for the context of &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;header_filter&lt;/code&gt; _by_lua&lt;a href=&quot;#header_filter_by_lua&quot;&gt;*&lt;/a&gt; 의 컨텍스트에 대한 header_filter .</target>
        </trans-unit>
        <trans-unit id="d6675123e313ac05987a5cb661fc584229acc294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&lt;/code&gt; for the context of &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt; 의 컨텍스트에 대해 init .</target>
        </trans-unit>
        <trans-unit id="05d735bf97f11016f776aad440b27ab557e4df4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_worker&lt;/code&gt; for the context of &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_worker&lt;/code&gt; 의 문맥 &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c44559cc796c043585373733a5bad604d5103184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log&lt;/code&gt; for the context of &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;log&lt;/code&gt; &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua *&lt;/a&gt; 의 컨텍스트에 대해 로그 하십시오 .</target>
        </trans-unit>
        <trans-unit id="68ee4757918c95c0f30e48bb7d7801e19ce341ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method&lt;/code&gt; specify the subrequest's request method, which only accepts constants like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 는 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 와 같은 상수 만 허용하는 하위 요청의 요청 메소드를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e8b3e02468193ca3dd65662326579146c891580e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ngx.flush&lt;/code&gt; accepts an optional boolean &lt;code&gt;wait&lt;/code&gt; argument (Default: &lt;code&gt;false&lt;/code&gt;) first introduced in the &lt;code&gt;v0.3.1rc34&lt;/code&gt; release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the &lt;code&gt;wait&lt;/code&gt; argument set to &lt;code&gt;true&lt;/code&gt; switches to synchronous mode.</source>
          <target state="translated">&lt;code&gt;ngx.flush&lt;/code&gt; 는 &lt;code&gt;v0.3.1rc34&lt;/code&gt; 릴리스 에서 처음 도입 된 선택적 부울 &lt;code&gt;wait&lt;/code&gt; 인수 (기본값 : &lt;code&gt;false&lt;/code&gt; )를 허용합니다 . 기본 인수와 함께 호출되면 비동기 호출을 발행합니다 (출력 데이터가 시스템 송신 버퍼에 기록 될 때까지 기다리지 않고 즉시 리턴 함). &lt;code&gt;wait&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 로 설정된 상태 에서 함수를 호출하면 동기 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="b98b5d464bd147124c56885e7d249a2e7a462036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool&lt;/code&gt; specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template &lt;code&gt;&quot;&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;lt;unix-socket-path&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pool&lt;/code&gt; 사용중인 연결 풀에 대한 사용자 정의 이름을 지정하십시오. 생략하면 연결 풀 이름이 문자열 템플리트 &lt;code&gt;&quot;&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;lt;unix-socket-path&amp;gt;&quot;&lt;/code&gt; 에서 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="0bbb837ccdf2fabeb7b9281e6b9a713127e0289a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.body&lt;/code&gt; holds the subrequest's response body data, which might be truncated. You always need to check the &lt;code&gt;res.truncated&lt;/code&gt; boolean flag to see if &lt;code&gt;res.body&lt;/code&gt; contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</source>
          <target state="translated">&lt;code&gt;res.body&lt;/code&gt; 는 하위 요청의 응답 본문 데이터를 보유하며 잘릴 수 있습니다. &lt;code&gt;res.body&lt;/code&gt; 에 잘린 데이터가 포함되어 있는지 확인하려면 항상 &lt;code&gt;res.truncated&lt;/code&gt; 부울 플래그를 확인해야 합니다. 여기에서 데이터 잘림은 원격 엔드가 응답 본문 데이터 스트림 중간에 연결을 조기에 중단하거나 하위 요청이 응답 본문 데이터를 수신 할 때 읽기 시간 초과가 발생하는 경우와 같이 하위 요청에서 복구 할 수없는 오류로 인해 발생할 수 있습니다. 원격.</target>
        </trans-unit>
        <trans-unit id="81d4c90c5bc308385866f2fbc63b948f6cee13be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.header&lt;/code&gt; holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</source>
          <target state="translated">&lt;code&gt;res.header&lt;/code&gt; 는 하위 요청의 모든 응답 헤더를 보유하며 일반 Lua 테이블입니다. 다중 값 응답 헤더의 경우 값은 모든 값을 표시된 순서대로 보유하는 Lua (배열) 테이블입니다. 예를 들어 하위 요청 응답 헤더에 다음 줄이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="bfaea47beff9d3fe1af84c27e8d42ce95706660d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.status&lt;/code&gt; holds the response status code for the subrequest response.</source>
          <target state="translated">&lt;code&gt;res.status&lt;/code&gt; 는 하위 요청 응답에 대한 응답 상태 코드를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f6b59aa955a4da16d0484da7aac3161750f3059a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite&lt;/code&gt; for the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rewrite&lt;/code&gt; &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 의 컨텍스트에 대해 다시 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f293c9d2d7a61cb62272a2d322e03b0f0e6108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; for the context of &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua *&lt;/a&gt; 의 컨텍스트에 대해 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="12d49e969d4bb023e2704b23b17b42319d017a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share_all_vars&lt;/code&gt; specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</source>
          <target state="translated">&lt;code&gt;share_all_vars&lt;/code&gt; 는 하위 요청의 모든 Nginx 변수를 현재 (상위) 요청과 공유할지 여부를 지정합니다. 하위 요청에서 Nginx 변수를 수정하면 현재 (부모) 요청에 영향을 미칩니다. 이 옵션을 활성화하면 나쁜 부작용으로 인해 디버그하기 어려운 문제가 발생할 수 있으며 나쁘고 유해한 것으로 간주됩니다. 수행중인 작업을 완전히 알고있는 경우에만이 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f7a6cd62d4b634857ddd10377960e288289637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_cert&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_cert&lt;/code&gt; 의 문맥 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e755abeadb3357ee393f1228432e6e195ba1ecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_session_fetch&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_session_fetch&lt;/code&gt; 의 문맥 &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6ce610bfefa97c2ed7877a70c3a9dcb304e727c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_session_store&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_session_store&lt;/code&gt; 의 문맥 &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02488ce9cf358d30330fdae00832e64fa9469134" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;: boolean value to indicate whether the key-value pair is stored or not.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; : 키-값 쌍의 저장 여부를 나타내는 부울 값.</target>
        </trans-unit>
        <trans-unit id="686f6cfb1a878b598134c576a8c9e342f64538ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; for the context of user callback functions for &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer. *에&lt;/a&gt; 대한 사용자 콜백 함수 컨텍스트 타이머 .</target>
        </trans-unit>
        <trans-unit id="0944b43533c57e58503856103f29970cd6451c83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; 는 하위 요청에서 지정된 Nginx 변수를이 옵션의 값으로 설정하기 위해 값을 보유하는 Lua 테이블을 사용합니다. 이 옵션은 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ddd0f12337823ae1f8c185bf24b6f656c74c211b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This module is not distributed with the Nginx source.&lt;/em&gt; See &lt;a href=&quot;#installation&quot;&gt;the installation instructions&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이 모듈은 Nginx 소스와 함께 배포되지 않습니다. &lt;/em&gt;&lt;a href=&quot;#installation&quot;&gt;설치 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9523bb257a2f80fd98cc2a7d0984a287fc3c6082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION&lt;/strong&gt; Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.</source>
          <target state="translated">&lt;strong&gt;주의&lt;/strong&gt; 많은 수의 키가있는 사전에서이 메소드를 호출하지 마십시오. 사전을 잠그고 사전에 액세스하려는 Nginx 작업자 프로세스를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab7beb3a867533343368e69adaa8b8743b792ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION&lt;/strong&gt; When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</source>
          <target state="translated">&lt;strong&gt;주의&lt;/strong&gt; Nginx 변수에서 읽을 때 Nginx는 요청 당 해제 된 요청 당 메모리 풀에 메모리를 할당합니다. 따라서 Lua 코드에서 Nginx 변수를 반복해서 읽어야하는 경우 Nginx 변수 값을 자신의 Lua 변수에 캐시하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="602e025568eedb314baeb44f195d18984c499a3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Following the &lt;code&gt;v0.9.17&lt;/code&gt; release, this pitfall can be avoided by using the &lt;code&gt;*_by_lua_block {}&lt;/code&gt; configuration directives.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 구성 지시문 을 사용하여 이러한 위험을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3108af88dfd491a7bba3b432c50ee09b400ac1d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#access_by_lua_block&quot;&gt;access_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#access_by_lua_block&quot;&gt;access_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4ef937cbe86ba9e3441a2d68b6a72f87345d335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#body_filter_by_lua_block&quot;&gt;body_filter_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#body_filter_by_lua_block&quot;&gt;body_filter_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2e31102dc9d65ccfb16a549a2962de95c2982f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#content_by_lua_block&quot;&gt;content_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . &lt;a href=&quot;#content_by_lua_block&quot;&gt;content_by_lua_block&lt;/a&gt; 지시문을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7721503d012f5536aa9042c9912c0af156f0130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#header_filter_by_lua_block&quot;&gt;header_filter_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#header_filter_by_lua_block&quot;&gt;header_filter_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="91796efdd991e0d365183bd6ca9d738dd0242f9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#init_by_lua_block&quot;&gt;init_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#init_by_lua_block&quot;&gt;init_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="20706430ed50fd7b6a1c40b3abca6e512f2e4428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#init_worker_by_lua_block&quot;&gt;init_worker_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#init_worker_by_lua_block&quot;&gt;init_worker_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="abcd3257ca367fb8c3d7969f330073dcda2812e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#log_by_lua_block&quot;&gt;log_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#log_by_lua_block&quot;&gt;log_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3c114a19a8433907e937d1d4eeabfd0800bff20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#rewrite_by_lua_block&quot;&gt;rewrite_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#rewrite_by_lua_block&quot;&gt;rewrite_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab94299b790e69ff42606adcb9be7b03a977d353" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#set_by_lua_block&quot;&gt;set_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;참고 &lt;/strong&gt; &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에는 이 지시문을 사용 &lt;em&gt;하지 않는 것이 좋습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#set_by_lua_block&quot;&gt;set_by_lua_block&lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc8f66632154dfb1ecf82cf255aba8773e1af3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, ..., 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; ngx.shared.DICT의 메모리는 데이터 크기 범위가 ~ 8, 9 ~ 16, 17 ~ 32, ..., 1025 ~ 2048, 2048 ~ 바이트와 같은 각 슬롯이있는 nginx 슬랩 할당자를 통해 할당됩니다. 슬롯에 이미 할당 된 페이지에 공간이 없으면 페이지가 슬롯에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="9df395781dd6a73237a385096934c8f2d4bb5466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method requires the &lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt; modules from the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 방법에는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 라이브러리 의 &lt;code&gt;resty.core.shdict&lt;/code&gt; 또는 &lt;code&gt;resty.core&lt;/code&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c117a8e1655c8859296d9e7457e88e2c16fd85be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Usage of the &lt;code&gt;init_ttl&lt;/code&gt; argument requires the &lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt; modules from the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library. Example:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 의 사용 &lt;code&gt;init_ttl&lt;/code&gt; 의 인수는 필요 &lt;code&gt;resty.core.shdict&lt;/code&gt; 또는 &lt;code&gt;resty.core&lt;/code&gt; 로부터 모듈 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;루아 - resty 코어&lt;/a&gt; 라이브러리를. 예:</target>
        </trans-unit>
        <trans-unit id="ade52cca976b6c0125e4bf226b4f5193058c1c92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;http, 서버, 위치, 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ec5ccc6ede865ad6de431eb20b93681afd54d9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location, location-if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;http, 서버, 위치, 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28fde770cd23cbf2148c8964569ce69fb61dc2a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;http, 서버, 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4ddd24271a21df0d75b8bfd4babaf47247c1d19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30d80c1c0066cb0df691dcd35ba04fb68cbb198" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;배경 : &lt;/strong&gt;&lt;em&gt;init_by_lua * init_worker_by_lua * set_by_lua * rewrite_by_lua *를 access_by_lua * content_by_lua * header_filter_by_lua * body_filter_by_lua * log_by_lua * ngx.timer * balancer_by_lua *를 ssl_certificate_by_lua * ssl_session_fetch_by_lua * * ssl_session_store_by_lua.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fc6b5ea1b381bc8f84ab22a660a4514187d00db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문맥 : &lt;/strong&gt;&lt;em&gt;init_by_lua *, init_worker_by_lua *, set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="662ad0d242d37d96b7bd1b2fd12e6c75ff5591d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;init_by_lua *, set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, * log_by_lua *, ngx.timer. *, balancer_by_luby *, s_sl_lua *, s_sl_slaate&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135796c7a443365dcf5e0cd08a617f380088b3d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;init_by_lua *, set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, balancer_bybylua *, ssl_fetchaate, ssl_fetchaate,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b4720d53688b0fdc2cfcc8cb6ae7d4575baa6aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;init_worker_by_lua *, set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, balancer_by_lua *, ssl_by_sla *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80ab129a27a8fd7550cc8884ffae5be356f5c5ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;init_worker_by_lua *, set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f781471ea9531245da6333d25380cbfa3709c912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문맥 : &lt;/strong&gt;&lt;em&gt;위치, 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad64e8d91d0fd4d8a4474031534c12c736b93f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1247c485ce41eea2b57c759449c6dd87e0fde3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, ngx.timer. *, balancer_by_lua *, ssl_certificate_by_lua *, ssl_session_fetch_by_lua *, ssl_session_store_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="580d93183f00557c35f3b281031132b63fd72ed1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, init_by_lua *, ngx.timer. *, header_filter_by_lua *, body_filter_by_lua *, ssl_certificate_by_lua *, ssl_session_fetch_by_lua *, ssl_certa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bbdc05b583cdcdb1aeca3508613275d8eb2ced3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a68914357ccc15e9764ade7b1aa36b6f76b2d3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, ngx.timer. *, ssl_certificate_by_lua *, ssl_session_fetch_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fda2feb781f539372163fd85f7c63276f714cca3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *, ngx.timer. *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c73314d53be1d6921bef852af274c59d44a3f270" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua *, access_by_lua *, content_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1732b80c3ef85c27f0ce2b06c429b66367eef0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server, server if, location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;서버, 서버, 위치, 위치&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfe5964f15f2d19fccd2e112d8ba541c4df839af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1822323b78d80942ba412c0ffa55d7c1d5dc80d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, body_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, body_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfe9eed0aa40292fedb79de2498235ed4e3043c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74a887e8cb2a29fcde327aded6c93d66e5440831" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7bb913e6dffd88e78f03baffcd5c8c80de01e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, balancer_by_lua *, ssl_luby_by_s_lu_session_bys_lua *, ssl_certificate_by_lu_ *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa641c80e555fb25f43684bde663e69ea7a8d6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, balancer_by_lua *, ssl_certificate_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f58340cd6038da611e6233091a829704d9e75ec5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, init_by_lua *, init_worker_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a19577126c833bf9495ddda33b5e2b35d7fb625e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, init_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="36483684be27fc578980ed7aac12a50e06c74e1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *, ngx.timer. *, init_worker_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2a738257d2663b0f10b6d1aea039752fc3a8464" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *, log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a0ce59a205d0d717544734b467fdec23d0a2ee9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *, body_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4cd7b666d763feebe102a043988a98dee382e6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *, header_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="515953e6011d7b7b57299fbb5e789a211be892eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트 : &lt;/strong&gt;&lt;em&gt;set_by_lua *, rewrite_by_lua *, access_by_lua *, content_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="596d2715f990420e738aeaf6e6b2acbffd3720af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;upstream&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;upstream&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c222f2bc340b6acdddcfc1f6f935d370e581f44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;The content of LUA_CPATH environment variable or Lua's compiled-in defaults.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;LUA_CPATH 환경 변수 또는 Lua의 컴파일 된 기본값의 내용.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="15b2935ec0184cd3b7418733f8be3612550a58db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;The content of LUA_PATH environment variable or Lua's compiled-in defaults.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;LUA_PATH 환경 변수 또는 Lua의 컴파일 된 기본값의 내용.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e7b05c7ed3f14eb1d4d6945d8ff52dafaf92dc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1ec09bcf1767735e59fa31d077e735f3ebaae8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_check_client_abort off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_check_client_abort off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05e66421217274c64c41d35e4bfb0fb7d234af66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_code_cache on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_code_cache on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f4289fc26463fde7d174ae3cc94655d7dccb3e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;디폴트 : &lt;/strong&gt;&lt;em&gt;lua_http10_buffering on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f04d0f16c41d1659e533f7ffdf3b4e31e19076e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_malloc_trim 1000&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_malloc_trim 1000&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e92023a488ce5de52a1eb15828bd656513ff9931" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers 1024&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_max_pending_timers 1024&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bbee947eedb365efd22faba04914108113192227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_max_running_timers 256&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_max_running_timers 256&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50f68fe09e85a64408fbac412964754d3feef240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a2b9dabb511e0f1e05b328e9c63540b50283b29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit 0&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_regex_match_limit 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e6b25eba49eec1840a2249e12e1e22aa1bf22d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size 4k/8k&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;디폴트 : &lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size 4k / 8k&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="856b6db73b5936ed8354c52a8f09eca344f0bea4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout 60 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="460245fa3724c36e2ec1143f2d45ef6a620512bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout 60 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="593c2760a0e70a9e4f4660af041aaa2412cb9a55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f32637daa3ba2242c3c64cac6b6addb1561e01f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size 30&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_pool_size 30&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b90bb1634aa22092b9492d088f2dee42352bfa35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout 60 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9752a467f619e314332eb3020626755dd28c81b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat 0&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eb80a4a5ad69b1d36f249f4f25a5741f297ff36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout 60 초&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2985b7f2c4f6db303cdf3b9c49c34a49409fa4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers DEFAULT&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers DEFAULT&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f6c96e4b0f4a2cb024bbc976dc25e11c39d0a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="469817314aceb9b664e63456976be7dc276b8085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth 1&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth 1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50004caa57dd0220f49ded7e44c082acbe2fbd44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77fbcaae2d4adf350abcd3cae3d61480e0428f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_use_default_type on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;lua_use_default_type on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec7f1dba0da5e143d8c13bd8df264204e96114e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;no&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;no&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9c54024b8806eb61b4cb4e5f5600245bfddb1e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;none&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;none&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="221ab2e3f7ad7e98888c8e7756c198ce44f4429d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04c93fb18e655e87951123dd83aaea8584a88910" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기본값 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8f9afc5f8a35a4ec179b0ca7f3b48be9f6dd777" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;optional requirement:&lt;/strong&gt;&lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;선택적 요구 사항 : &lt;/strong&gt; &lt;code&gt;resty.core.shdict&lt;/code&gt; 또는 &lt;code&gt;resty.core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b65dea68ad285d43162873715a960528e517e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;access tail&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;단계 : &lt;/strong&gt;&lt;em&gt;접근 꼬리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11cf2f4f5ce7c7f355e9b6063e445fe4fac2f7ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;content&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b4e84c8fdee3f00da0fbd96e152b662a3d3e817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;depends on usage&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;단계 : &lt;/strong&gt;&lt;em&gt;사용법에 달려 있습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf825d2a1c1749e60096a40099f87b7b1d3272ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;loading-config&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;loading-config&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ecaaf91c1fb035e3a4b395a08c1a574ac59988d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d418a6df0cafbdd2ce578a3294ae9f2d405aa78e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-body-filter&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-body-filter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="459860cf873bc87e2aaaa543ce2607db51f858f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-header-filter&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-header-filter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9232d7df1b0797bbd2ba00ae60d3e9083730d1d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite tail&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;단계 : &lt;/strong&gt;&lt;em&gt;꼬리 다시 쓰기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5535de0c6c0cfac9db50d15bde28da2bd88abb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60696083b06222a6ce52341c8f3e1de18f287a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-after-SSL-handshake&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-after-SSL-handshake&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39caa09c1338c9267193cce4b738b432477da7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-before-SSL-handshake&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-before-SSL-handshake&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b398522805602ec8e8aab0a670c55fb75da31829" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;starting-worker&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;starting-worker&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cf398d1ecf94338ae834af7fdfe39672f10c717" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requires:&lt;/strong&gt;&lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt; &lt;code&gt;resty.core.shdict&lt;/code&gt; 또는 &lt;code&gt;resty.core&lt;/code&gt; &lt;strong&gt;가 필요합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89336c9ea14910b3e81260a5964784a5504f1481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;... = coroutine.yield(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;... = coroutine.yield (...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71e16786b9a5bc4913e74cd81d5994beb767ff20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;access_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d1a7c90b913fcba94965f8eb5a565c66358e7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;access_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="053963ef10137a03820c7a2e3c645fdbebfffa8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;access_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d2fa6e568ca6365808529bde15f48a6cad570e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8321cf9678815762027405a0fe406ce5138264a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_post_args(max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_post_args (max_args?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37edd68dab54d0bc6e7d2fa1b36ac96d7a1feed3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_uri_args(max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_uri_args (max_args?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="934567ae15c08064a627e94cc9a333ff045bb5a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;balancer_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;balancer_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="161e97059192d9ff2678f1f3b8f1694e36b17156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;balancer_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;balancer_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fb78eb4c0958e9a86f59ce698840b93c7fc75da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;body_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b49b3ec39e1948942595e2d91b91e9b7dcd9906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_block { lua-script-str }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;body_filter_by_lua_block {lua-script-str}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17922540aef96060779a2fd7d897b1e21e84c111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;body_filter_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a99e2dba095475612fb450722fee0f60212d6c85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;bytes, err = tcpsock:send(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;바이트, err = tcpsock : send (data)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5a44dc474c2f5fa70462528050afab3cf2d0689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;capacity_bytes = ngx.shared.DICT:capacity()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;capacity_bytes = ngx.shared.DICT : capacity ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee7da351687fc07189da4a88723199a118239368" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;캡처, err = ngx.re.match (제목, 정규식, 옵션?, ctx ?, res_table?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e01cb6d5c8c311904c7d8663fcd2fd0b7dd7a5a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.create(f)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;co = coroutine.create (f)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b4252b1ae3b9b4d633b513d2bc75c56559b0fbc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.running()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;co = coroutine.running ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8091a86ad45f624d801265f23ab92977221209e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.wrap(f)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;co = coroutine.wrap (f)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f9823bfeae10df941f50497209cdf018da9a598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = ngx.thread.spawn(func, arg1, arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;co = ngx.thread.spawn (func, arg1, arg2, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b61349bd4007492cb88b98b3fa733c20bef45ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;content_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c6e66a39884fedd38e76e390a2c5be0b8819edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;content_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96c462c68cc7f5fde2df4978937197685a19467b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;content_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3a34d5c8d8ce7d19f3cbb197489a40b887a74f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.timer.pending_count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;count = ngx.timer.pending_count ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b5c6334856fab2681989b4b281ebc79517e97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.timer.running_count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;count = ngx.timer.running_count ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8794918bf50a605db35c8287d37270a0d0d6f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.worker.count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;count = ngx.worker.count ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd42f5003fe32214356b090a1c1434cc72803d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.worker.id()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;count = ngx.worker.id ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07d49202784cc9fb9bf6fbe6fc366642e4a93d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count, err = tcpsock:getreusedtimes()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;count, err = tcpsock : getreusedtimes ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b96b81313a0f31768908e5e8b122acaa821b2c9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data = ngx.req.get_body_data()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;data = ngx.req.get_body_data ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aadddad5374ba27030c7c1dce86f6090b09def6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err = udpsock:receive(size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;data, err = udpsock : receive (size?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70930490ee56ed61169c84fd365452957883c7f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock:receive(pattern?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock : receive (pattern?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="348b7abec0e99eadcc3ed9fac19f6747af72a08d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock:receive(size)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock : receive (size)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3e83ed30baf89c73d43e775b4cf8d32d26430f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;debug = ngx.config.debug&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;debug = ngx.config.debug&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="538d31a0d239e5960a5e8dca13ff6f1ae806bd01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;dict = ngx.shared.DICT&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;dict = ngx.shared.DICT&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a35a5bb269e68613feca27edad56704044beee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;dict = ngx.shared[name_var]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;dict = ngx.shared [name_var]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6aa8fd891c7e0c063aeca8b1fec3ae27e92dc9b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.hmac_sha1(secret_key, str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;digest = ngx.hmac_sha1 (secret_key, str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dec30231fbdcbf82629a560d63c8a5caf48fc7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.md5(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;digest = ngx.md5 (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56b7a8a45d40b4a0cf71e61489d1f6c8dfb87cd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.md5_bin(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;digest = ngx.md5_bin (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a31ade5f450bd7d701d0a2e707b8272135ddd9c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.sha1_bin(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;digest = ngx.sha1_bin (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ffe6d239811dda77da6cb4f68db9c04ae7217c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;exiting = ngx.worker.exiting()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;exiting = ngx.worker.exiting ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98152ac6430ef583287736fbc997c053d496e982" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;file_name = ngx.req.get_body_file()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;file_name = ngx.req.get_body_file ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31718b7c6a175d7a78a37ddc8c201038a0db2d92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;flushed = ngx.shared.DICT:flush_expired(max_count?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;flushed = ngx.shared.DICT : flush_expired (max_count?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad0710db35301ab2f52fdf045a0b861b29846175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;free_page_bytes = ngx.shared.DICT:free_space()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;free_page_bytes = ngx.shared.DICT : free_space ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8723a3a39d9ff0f21c3a7c617db7f85fcf02e16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;from, to, err = ngx.re.find (제목, 정규식, 옵션?, ctx ?, nth?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebcefeed4197f0542d3d7ffc4a896a326925b933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.at (지연, 콜백, user_arg1, user_arg2, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e1c12873f350e082f71a28f41d75cf3fe0c3d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.every (지연, 콜백, user_arg1, user_arg2, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0da7fe0767eefe76f1883b028ac59183db7132b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;header_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fa43f046b2bfd53024dc3cea6e3648d7f7ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;header_filter_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99d30246fa4e7bc18d86ea7dddb9ecd8da9f25a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;header_filter_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40c80a9f382fd40f70061006844db8001b51178e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;headers, err = ngx.req.get_headers(max_headers?, raw?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;헤더, 오류 = ngx.req.get_headers (max_headers ?, raw?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12383d8f82fc9dc937aea19500ada0cc383a8f61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;headers, err = ngx.resp.get_headers(max_headers?, raw?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;헤더, err = ngx.resp.get_headers (max_headers ?, raw?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fb8a0024307ed226ce2841a8c0e217ac132c6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d468d5914725f11ef5d08766009f28f36ad2a16e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46a16b848eb59a908f1a2e485b744058087ebf7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="946f849d75ec091253b02bf1f6a7f8a016c561e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_worker_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="102066d617540c69c287e49bc5c12d6a4f896de9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_worker_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75541bb0decd4b5b964219586941bfd57724bf48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_file &amp;lt;lua-file-path&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;init_worker_by_lua_file &amp;lt;lua-file-path&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76354a7b491b26b1ca014d1988b7bb21494397c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_long(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_long (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b8c19dab98c178fe725fa746464391568dd6772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_short(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_short (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d15efd3265d0912c3fafdf9b41d26cde62211556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;is_internal = ngx.req.is_internal()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;is_internal = ngx.req.is_internal ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6a694978e1a4cb3e23afa64edcbb781b2507484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;iterator = tcpsock:receiveuntil(pattern, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;iterator = tcpsock : receiveuntil (패턴, 옵션?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0997ce24d7d66ffb6ee1831b32e5402c39168abd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;iterator, err = ngx.re.gmatch(subject, regex, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;iterator, err = ngx.re.gmatch (제목, 정규식, 옵션?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8de9e763a6bc10cc039f71f6a4e4beff2dfb268f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;keys = ngx.shared.DICT:get_keys(max_count?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;keys = ngx.shared.DICT : get_keys (max_count?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d543126a61d915f8fc05caf2aba3c2845ed5e64a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;len, err = ngx.shared.DICT:llen(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;len, err = ngx.shared.DICT : llen (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="738652545909d9aa66dd899349c579fdabbaf199" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;length, err = ngx.shared.DICT:lpush(key, value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;길이, 오류 = ngx.shared. DICT : lpush (키, 값)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca7971b801bdae68548897db911e27a251de5cb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;length, err = ngx.shared.DICT:rpush(key, value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;길이, 오류 = ngx.shared.DICT : rpush (키, 값)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb469e83e6895b2249a5ec69be57d992d0321030" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local balancer = require &quot;ngx.balancer&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;로컬 밸런서 = &quot;ngx.balancer&quot;필요&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f361dd93db187d963ea9be7aef93ad0f54e191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local ocsp = require &quot;ngx.ocsp&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;local ocsp = &quot;ngx.ocsp&quot;필요&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ef500cdff0f3a38871b8a51f573418b9c139859" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local semaphore = require &quot;ngx.semaphore&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;로컬 세마포어 = &quot;ngx.semaphore&quot;필요&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5271eb94f2fba51c9745c182fdac4c0ffb3d94c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local ssl = require &quot;ngx.ssl&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;local ssl = &quot;ngx.ssl&quot;필요&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6cf2327f2c8cda7e51f1fcfd7b9ed5e0113338bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;log_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0150bbc390b0e0a2c90fcbc021d7e355be74422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;log_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9b176450264ccd7ffdc3ebf6d76bd9477e868c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;log_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0838a78e4cfec32332195218890c705e3bb0ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_capture_error_log size&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_capture_error_log 크기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3db508b492f9fba14efd4e8972d7af4b2f095164" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_check_client_abort on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_check_client_abort on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="415ddc56ec14bb8936b9b7dcf619dc7acde0d88f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_code_cache on | off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_code_cache on | 떨어져서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c58c456860940b5a7caacbb81fa121f680787f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_http10_buffering on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fcb2dc8fe3f1657e6f68eef219740ced95cd2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_malloc_trim &amp;lt;request-count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_malloc_trim &amp;lt;요청 횟수&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6cae8cb0d45cf9b8d2432d3836885957ec4a1cf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers &amp;lt;count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_max_pending_timers &amp;lt;count&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d35bd977d83cb7c01b8c4477c9360db40c5bf765" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_max_running_timers &amp;lt;count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_max_running_timers &amp;lt;count&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31e3549fe454cf0ba75e50a4ef9df34989c23438" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_need_request_body &amp;lt;on|off&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_need_request_body &amp;lt;on | off&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1ad67dd913ba6b8e5b22dd3b8b3d104cd68411b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_package_cpath &amp;lt;lua-style-cpath-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_package_cpath &amp;lt;lua-style-cpath-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a528a6ac20f7e61b551eb0f19c5d40a9793b651" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_package_path &amp;lt;lua-style-path-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_package_path &amp;lt;lua-style-path-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba0c94cb931415312543c0744a71eff0a3edec67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de3e7858300ee666e2bd910711c863a6eed83916" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit &amp;lt;num&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_regex_match_limit &amp;lt;num&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec7c5a843ea69dc5df93c40cfabfe5f49d48ad30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_shared_dict &amp;lt;name&amp;gt; &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_shared_dict &amp;lt;이름&amp;gt; &amp;lt;크기&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9e846b22026f8daa75441c1649993c416213c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size &amp;lt;size&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="615cec3143066ee39549862d4e3fdaf53b0908e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c8bc2d24361c9ad6f1b5b16f73beb1f4644d6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout &amp;lt;시간&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069d6b011c593b0f0256b6992eade73d873efdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="928223239bd32fa1353360f04fe155b2cfe8e5d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_pool_size &amp;lt;size&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="898dd2d4c0a9ccd57ecaa7ada134e6539590fdc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout &amp;lt;시간&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0f4ebe8765aaf9d120be47046af731110bec688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat &amp;lt;size&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfeddf7172d4dde1d787bdb9ca625a39b65db91e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="786d2d5819ae65e56731913bc41d7eaec35ccad8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers &amp;lt;ciphers&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers &amp;lt;암호&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="702773f5ad14212e2ca2c027236f453b2adeae4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_crl &amp;lt;file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_ssl_crl &amp;lt;파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5774e90b70107528b765073131d8ffc5a7218f3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b825b61932e753287f9c84763b8e288057b1d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_trusted_certificate &amp;lt;file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_ssl_trusted_certificate &amp;lt;파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26ea391a9b43840b9bc947bc176df4392ca6031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth &amp;lt;number&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth &amp;lt;숫자&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ee4b4000c1e27ae583edd2da9773cb6c1dca804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84069949522e73f8f7ac15047c8f4878647e3e7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_use_default_type on | off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;lua_use_default_type on | 떨어져서&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f26eea2f0eb865778708bada6c031413d2631bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;method_name = ngx.req.get_method()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;method_name = ngx.req.get_method ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df6188d6c02724386896b35df3c9057a7da6097d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.decode_base64(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr = ngx.decode_base64 (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a69f2d1bd9cdba59c93eb41a985469a432f1973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.encode_base64(str, no_padding?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr = ngx.encode_base64 (str, no_padding?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0804797e9e313ada49166b4acbdc632ba2918580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.escape_uri(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr = ngx.escape_uri (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e02eef545e81bba4743fc51bb69f62c90be1db2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.unescape_uri(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr = ngx.unescape_uri (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79242463735d27ddb1e70ae599e2a48462d1ca7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.gsub (제목, 정규식, 바꾸기, 옵션?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0879df9a3b0144c6450985a024657d097255b81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.sub(subject, regex, replace, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.sub (제목, 정규식, 바꾸기, 옵션?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6709d5d4e3e841df6d9bce11683fd07f920d5987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;newval, err, forcible? = ngx.shared.DICT : incr (키, 값, init ?, init_ttl?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="656572c2da85684d98e82197441467f5f663f218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exec(uri, args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.exec (uri, args?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b4c818f2aae94226b6c30951e21451b314cde9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exit(status)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exit(status)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09cf38887f26c8077887c5a6b5efe1a697e50c8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.header.HEADER = VALUE&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.header.HEADER = VALUE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e4e1a3a1671d2e2088184cfa3e5c9d2fb46b1a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.log(log_level, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.log (log_level, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f4f95956b9b70b4d528ba7bef3d94ba3bd9e16f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.redirect(uri, status?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.redirect (uri, status?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de5b4553b3a6d7796fa6a79c8a90febb556f85f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.append_body(data_chunk)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.append_body(data_chunk)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f57e8645d36d28eacc551a6e0b9b0e9f7e0a6692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.clear_header(header_name)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.clear_header(header_name)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb403f6ccf56b4cf748b73bfdf0e5ae1d2fbafc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.discard_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.discard_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd191fa33b2810a98e7800f3ec1261bd9b775da0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.finish_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.finish_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7be07cc9678b99dca79822e47e59f5e3783b5b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.init_body(buffer_size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.init_body(buffer_size?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ccb7d325fd974da097b7f1b7e3314f9fb703f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.read_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.read_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a971f2ee416f4516de2272f6c308cd98d848359b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_data(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_data(data)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ba4ec27c18c16c578a275bcdec4cbb15d337d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_file(file_name, auto_clean?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.req.set_body_file (file_name, auto_clean?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce116da7e8085ccf372353e2a07a203d90046db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_header(header_name, header_value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.req.set_header (header_name, header_value)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6eb5e5815a774f26ea20fd9dfeced392f5cdec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_method(method_id)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_method(method_id)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55d623d5981fb21fe70c915384a9f436e6140073" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri(uri, jump?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ngx.req.set_uri (uri, jump?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="699f3ed673166bcf8ba0bfe3d2816dbb7651438a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri_args(args)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri_args(args)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="421c31783da2b711ceb8133324ebaa09419f94f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:delete(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:delete(key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03b8da6eab1d6d0b0c62baabfa84f24622e3c682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:flush_all()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:flush_all()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfb03139fe18e9188001832ec0ad58baa185fca4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.sleep(seconds)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.sleep(seconds)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f516fe12ef31a04a5bc712fd6f1b0304c285a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.update_time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.update_time()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a401cbf88fc40e958899ddfb571a55f206fb414" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.var.VAR_NAME&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.var.VAR_NAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec1d81451f78083635c2827766229d78a476fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;num = ngx.req.http_version()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;num = ngx.req.http_version ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69a0a8385cf20701ddd22e392b290559b49e2104" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, ... = coroutine.resume(co, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, ... = coroutine.resume (co, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d7b3484e1f731530976798eb1942caa031e6bc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.eof()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.eof ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0781d407266aab8057194f8a8537664a23745ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.flush(wait?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.flush (wait?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="516fc9cc9eab3d466d30c9b02a976e8f20995f7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.on_abort(callback)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.on_abort (callback)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5790dbcc726a749d7acece3afa1393ecd761a0ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.print(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.print (...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04ba7a41f97269eaa3a332bab704ed2cebbb1716" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.say(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.say (...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6213ca173ad10602b6279e4c163e0d752f9ba4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.send_headers()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.send_headers ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c4555df965505df5f91a172aa71a7c6b6c88bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT : safe_add (key, value, exptime ?, flags?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="45263483f736355a4cfc4653982b2b4a96f04830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT : safe_set (key, value, exptime ?, flags?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d726127cae183389d91e023af0b318c99e03d2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.thread.kill(thread)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = ngx.thread.kill (thread)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a0418088703e203e060bc23bdb2c57d3183da55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:close()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = tcpsock : close ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fac3ce74b8b28a9c2c674882d716ed67eb1035" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:connect(&quot;unix:/path/to/unix-domain.socket&quot;, options_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = tcpsock : connect ( &quot;unix : /path/to/unix-domain.socket&quot;, options_table?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="517148cfe9987746f48fb4a36bde3aa028635c37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:connect(host, port, options_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = tcpsock : connect (host, port, options_table?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d5473573e14f37d77de9dc9373c1cf53123b2d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:setkeepalive(timeout?, size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = tcpsock : setkeepalive (timeout ?, size?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="713bce89356d9d3d043064f74bc5c9ece4a60f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:close()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;문법 : &lt;/strong&gt;&lt;em&gt;ok, err = udpsock : close ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0bedfbafbe6f722124660d4fe2131d0bd7dcf09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:send(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = udpsock : send (data)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd8ca7c19f86044a09629e4e0bcfb5641b729272" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:setpeername(&quot;unix:/path/to/unix-domain.socket&quot;)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = udpsock : setpeername ( &quot;unix : /path/to/unix-domain.socket&quot;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03972164e623cc0459f13c12a467ecf97000d484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:setpeername(host, port)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, err = udpsock : setpeername (호스트, 포트)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d26a92d0c26d8be8f3dc2411806dec6ecfd910" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ok, res1, res2, ... = ngx.thread.wait (thread1, thread2, ...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd6511cc7039449861e0eb17135051aaac513659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;pid = ngx.worker.pid()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;pid = ngx.worker.pid ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44b4b785663ca4f7c8de7d34ccc71fcd9d4a1d2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;prefix = ngx.config.prefix()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;prefix = ngx.config.prefix ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d614b9b9c2166061e09f70c098ed9df5e0fd431c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;print(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;print(...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="098ffa578ece7aa97c276d49979d0fb9b618a3e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;quoted_value = ngx.quote_sql_str(raw_value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;quoted_value = ngx.quote_sql_str (raw_value)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81926f009beba04b70aca991b8583cadff57f49e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res = ndk.set_var.DIRECTIVE_NAME&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;res = ndk.set_var.DIRECTIVE_NAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8a6de09143ae7c083512a6692fdea574983958c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res = ngx.location.capture(uri, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;res = ngx.location.capture (uri, 옵션?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51b259795845768504502d498872a65f0d0ec241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;res1, res2, ... = ngx.location.capture_multi ({{uri, options?}, {uri, options?}, ...})&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eb0da703db84e61c8d3a5817d521869b6273936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3b71bf71c6a34f1a8e8089cabc99de10757dc43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cfc34addebdb0698754c5506cdbc7e117845f1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua_file &amp;lt;경로-루아 스크립트 파일&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="470ca90ed4ec829e69ed8d114261b401522e7b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30777f12f3e026b837a3ceb836e7a45cee1b8ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;sec = ngx.parse_http_time(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;sec = ngx.parse_http_time (str)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234d42469ae72176234c7133f20a44a36bbc7aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.now()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;secs = ngx.now ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="871ff0f2fba70b719e9e2b3a2108cbc0eecb4539" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.req.start_time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;secs = ngx.req.start_time ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72c0624bb0c50b26a305c6a75ca22fb8220914f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;초 = ngx.time ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31f5779a2e6769595dd2153bdb012db7ba20cdf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;session, err = tcpsock : sslhandshake (reused_session ?, server_name ?, ssl_verify ?, send_status_req?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf57f39999890e4f19f975385aa2fae1005b525d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua $res &amp;lt;lua-script-str&amp;gt; [$arg1 $arg2 ...]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;set_by_lua $ res &amp;lt;lua-script-str&amp;gt; [$ arg1 $ arg2 ...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dbde975b17d8bed0954475edf7e35f0abf1d6d6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua_block $res { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;set_by_lua_block $ res {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d673f592354ad6f1005658a1ec56c619a55a9dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua_file $res &amp;lt;path-to-lua-script-file&amp;gt; [$arg1 $arg2 ...]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;set_by_lua_file $ res &amp;lt;경로-루아 스크립트 파일&amp;gt; [$ arg1 $ arg2 ...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30cc281e5bca589d48b9af54ed7f30515be92da6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13f8dabd88f81b9fdeb79fdd381ea3d1f3968a82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="384ec341de463656d237822940c3c6a53cf28905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5d318c7946f3c59e0303a0bfbfa1cedb4fd9c24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="109446da89da8719e18e032b0f0b730e10ee387b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5e3548b6b93ec9212b780889e06dc3a5568f48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8bf35a68aa8712848dd28b1904dc0275d050b36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;status = coroutine.status(co)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;status = coroutine.status (co)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4564bcee5bb7e39c7baa259d1b4f9f3972ba5471" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.config.nginx_configure()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.config.nginx_configure ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cf436ee466c8985f347bdfacbcb403650628a34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.cookie_time(sec)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.cookie_time (sec)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79f9c3172cc79ef810333dc665a7d13dd2cc4117" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.encode_args(table)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.encode_args (table)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b490d332d8cd93dd83c595879f384a0ea15d4828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.get_phase()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.get_phase ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d401ad75414af1135ba414378cf0a32da9feb67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.http_time(sec)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.http_time (sec)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e5aad2546f4ab1c92763ada5616364867b207a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.localtime()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.localtime ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="801974afc171f8bc64e7db9658c97c8d9035b57c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.req.raw_header(no_request_line?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.req.raw_header (no_request_line?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4c7bff297eef1406d9a0cb27ce6f85b611a3b9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.today()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.today ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8331b49a88af2d488a7fde3ae639e4b019482982" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.utctime()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;str = ngx.utctime ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b2288727830f3608303762dc5b05df58f9ea28b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;subsystem = ngx.config.subsystem&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;서브 시스템 = ngx.config.subsystem&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b3363c928c45731160ae3d34bcb16b559a7e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err = ngx.shared.DICT:expire(key, exptime)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;성공, 오류 = ngx.shared.DICT : expire (key, exptime)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9a4bff44b8db05d77da1eead709432d22b6efe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;성공, 오류, 강제성 = ngx.shared.DICT : add (key, value, exptime ?, flags?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bce16780705a9be10e688709ea30dff9af864c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;성공, 오류, 강제 = ngx.shared.DICT : replace (키, 값, exptime ?, 플래그?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4517a4ff32d0dd0f3bdd6ea337a2ef885053b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;성공, 오류, 강제성 = ngx.shared.DICT : set (key, value, exptime ?, flags?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6317165d713a600da732b897a64252fdff3350f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;table, err = ngx.decode_args(str, max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;table, err = ngx.decode_args (str, max_args?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60ea8ae44b324aaeb92365a377dbaf508cfa8053" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock = ngx.socket.tcp()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock = ngx.socket.tcp ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d882d2b59c9250c0d027d211a1134da8f386b11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86b777ba829769605f7ece8c4c6fc01c78428ec9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket(raw)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket (raw)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="696ec2c885d2415e562a0437a6a9dc48561477a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect(&quot;unix:/path/to/unix-domain.socket&quot;)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect ( &quot;unix : /path/to/unix-domain.socket&quot;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0bb7008a24b94b79fb900a52b7a3ebc61794124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect(host, port)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect (호스트, 포트)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab2c204579074fa176a45a286724cb7a288926e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:setoption(option, value?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock : setoption (옵션, 값?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9370c0db28e002272a5cd13ed13cb22fda4d986c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeout(time)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeout(time)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56c5bd1c6a8b8e99e046eb18e5017530dd0fed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;tcpsock : settimeouts (connect_timeout, send_timeout, read_timeout)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43a077e1fd4cba809e10d317c525daaad238d81b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ttl, err = ngx.shared.DICT:ttl(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ttl, err = ngx.shared.DICT : ttl (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1be5c605fc210797c706afbbb0ae86c09b6c7e65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock = ngx.socket.udp()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;udpsock = ngx.socket.udp ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40cff8a96c5f71aec02f169d2378050064ebc1ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock:settimeout(time)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock:settimeout(time)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c76604d99a9999391953615a0696da1ef73b70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val = ngx.arg[index]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;val = ngx.arg [index]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b8bb134273c5f01dd7644e86b90b9fee18fa568" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT:lpop(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT : lpop (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea200478d6c3a657028e2446209a977d5bb54a94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT:rpop(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT : rpop (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4522fa27bd74d4d7fc25b78f5443b9569a20a254" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.header.HEADER&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;value = ngx.header.HEADER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdc1c5bd4d315dff6510507c4c45aa25c6d6fcad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.headers_sent&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;value = ngx.headers_sent&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="685e94753d2365c4a0fd5efadfcdcd835db1a181" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.is_subrequest&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;value = ngx.is_subrequest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac69e75077b26e2af8380c73746f628669f61fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value, flags = ngx.shared.DICT:get(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;값, 플래그 = ngx.shared.DICT : get (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69f53a5fc4dace9c7a300bf24c6c66d6c8ce77d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value, flags, stale = ngx.shared.DICT:get_stale(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;value, flags, stale = ngx.shared.DICT : get_stale (key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec31a19ad9a38299b13ea166cb44e6d44388bdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ver = ngx.config.nginx_version&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ver = ngx.config.nginx_version&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c394acdfffb47130b77d9d88803c21fb11c372d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ver = ngx.config.ngx_lua_version&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : &lt;/strong&gt;&lt;em&gt;ver = ngx.config.ngx_lua_version&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2f9d7e62aa20926b6ce6275e83b38213722def" translate="yes" xml:space="preserve">
          <source>A better way to do background jobs is to use the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API.</source>
          <target state="translated">백그라운드 작업을 수행하는 더 좋은 방법은 &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="44d05ea5a9ecfd859e268f3f79d3cd7f1ec56f2f" translate="yes" xml:space="preserve">
          <source>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets (&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; and &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;), shared memory dictionaries (&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;), user coroutines (&lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine.*&lt;/a&gt;), user &quot;light threads&quot; (&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.*&lt;/a&gt;), &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, &lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt;/&lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;, &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt;/&lt;a href=&quot;#ngxsha1_bin&quot;&gt;ngx.sha1_bin&lt;/a&gt;, are all allowed. But the subrequest API (like &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;), the &lt;a href=&quot;#ngxreqstart_time&quot;&gt;ngx.req.*&lt;/a&gt; API, the downstream output API (like &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;, &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;, and &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt;) are explicitly disabled in this context.</source>
          <target state="translated">스트림 / 데이터 그램 코 소켓 ( &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; 및 &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt; ), 공유 메모리 사전 ( &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; ), 사용자 코 루틴 과 같은 타이머 콜백 컨텍스트에서 Nginx 용 Lua API가 많이 활성화되었습니다. ( &lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine. *&lt;/a&gt; ), 사용자 &quot;light threads&quot;( &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread. *&lt;/a&gt; ), &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; , &lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt; / &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt; , &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt; / &lt;a href=&quot;#ngxsha1_bin&quot;&gt;ngx.sha1_bin&lt;/a&gt; 모두 허용됩니다. 그러나 하위 요청 API (예 : &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; ), &lt;a href=&quot;#ngxreqstart_time&quot;&gt;ngx.req. *&lt;/a&gt; API, 다운 스트림 출력 API (예 : &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; , &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 및 &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush)&lt;/a&gt;)는이 문맥에서 명시 적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19dbdb1f31e7869c1065d49847db502f487a4b94" translate="yes" xml:space="preserve">
          <source>A more sophisticated example involving regex substitutions is as follows</source>
          <target state="translated">정규식 대체와 관련된보다 복잡한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2f90081479faabde78e4be938ea12e0074bda6d" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;/lua&lt;/code&gt; will yield the output</source>
          <target state="translated">&lt;code&gt;/lua&lt;/code&gt; 에 접근 하면 출력이 나옵니다</target>
        </trans-unit>
        <trans-unit id="8994d334d874e1a7ba313de7714dfc9ef766f3cf" translate="yes" xml:space="preserve">
          <source>Accessing location &lt;code&gt;/lua&lt;/code&gt; gives</source>
          <target state="translated">위치 액세스 &lt;code&gt;/lua&lt;/code&gt; 제공</target>
        </trans-unit>
        <trans-unit id="736021de18ac533b1900b238c3f33e77ec77ca85" translate="yes" xml:space="preserve">
          <source>According to the current implementation, each &quot;running timer&quot; will take one (fake) connection record from the global connection record list configured by the standard &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;. So ensure that the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; directive).</source>
          <target state="translated">현재 구현에 따르면, 각각의 &quot;실행 타이머&quot;는 &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;nginx.conf&lt;/a&gt; 의 표준 worker_connections 지시문으로 구성된 글로벌 연결 레코드 목록에서 하나의 (가짜) 연결 레코드를 가져 &lt;code&gt;nginx.conf&lt;/code&gt; . 따라서 &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; 지시문은 타이머 콜백에 필요한 실제 연결과 가짜 연결 ( &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; 지시문에 의해 제한됨)을 모두 고려할만큼 충분히 큰 값으로 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ba7b60e5283f7cdae36f90cd4038d93871d89bc" translate="yes" xml:space="preserve">
          <source>According to the current implementation, each &quot;running timer&quot; will take one (fake) connection record from the global connection record list configured by the standard &lt;a href=&quot;https://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;. So ensure that the &lt;a href=&quot;https://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; directive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36df347778ebed9addba2dc65ea73cee56a56f08" translate="yes" xml:space="preserve">
          <source>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;, then ngx_lua will neither stop all the running &quot;light threads&quot; nor call the user callback (if &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt; has been called). Instead, the reading operation on &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; will just return the error message &quot;client aborted&quot; as the second return value (the first return value is surely &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">그러나 현재 구현에 따르면 Lua 코드가 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket을&lt;/a&gt; 통해 요청 본문 데이터 읽기를 완료하기 전에 클라이언트가 연결 을 닫으면 ngx_lua는 실행중인 모든 &quot;라이트 스레드&quot;를 중지하거나 사용자 콜백을 호출하지 않습니다 ( &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt; 가 호출되었습니다). 대신, &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 에 대한 읽기 작업 은 오류 메시지 &quot;client aborted&quot;를 두 번째 반환 값으로 반환합니다 (첫 번째 반환 값은 반드시 &lt;code&gt;nil&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="ff2eed6c4ed83cfc3a5f2bf7341c235edc945945" translate="yes" xml:space="preserve">
          <source>According to the current implementation, only the parent coroutine (or &quot;light thread&quot;) can kill a thread. Also, a running &quot;light thread&quot; with pending NGINX subrequests (initiated by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; for example) cannot be killed due to a limitation in the NGINX core.</source>
          <target state="translated">현재 구현에 따르면, 부모 코 루틴 (또는 &quot;가벼운 스레드&quot;)만이 스레드를 죽일 수 있습니다. 또한 NGINX 하위 요청이 보류중인 ( 예 : &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 로 시작) 실행중인 &quot;경량 스레드&quot; 는 NGINX 코어의 제한으로 인해 종료 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5485d527dcfe94cf83beda31fd899da662f891e3" translate="yes" xml:space="preserve">
          <source>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message &quot;duplicate call&quot;.</source>
          <target state="translated">현재 구현에 따르면이 함수는 단일 요청 핸들러에서 한 번만 호출 할 수 있습니다. 후속 호출은 &quot;중복 호출&quot;오류 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a82446112292bfd78094871077664e48ccc200ac" translate="yes" xml:space="preserve">
          <source>Acts as a &quot;content handler&quot; and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">&quot;컨텐츠 핸들러&quot;로 작동하고 모든 요청에 ​​대해 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 Lua 코드 문자열을 실행합니다 . 루아 코드는 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API 호출을&lt;/a&gt; 할 수 있으며 독립적 인 글로벌 환경 (즉, 샌드 박스)에서 새로 생성 된 코 루틴으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ab78ec3cb23500dc84ad57ebac431b0cc3322da5" translate="yes" xml:space="preserve">
          <source>Acts as a rewrite phase handler and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">다시 쓰기 단계 처리기 역할을하며 모든 요청에 ​​대해 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 Lua 코드 문자열을 실행합니다 . 루아 코드는 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API 호출을&lt;/a&gt; 할 수 있으며 독립적 인 글로벌 환경 (즉, 샌드 박스)에서 새로 생성 된 코 루틴으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="edab06aa80d252e0400fc7d719ad4028532320ba" translate="yes" xml:space="preserve">
          <source>Acts as an access phase handler and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">액세스 단계 처리기 역할을하며 모든 요청에 ​​대해 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 Lua 코드 문자열을 실행합니다 . 루아 코드는 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API 호출을&lt;/a&gt; 할 수 있으며 독립적 인 글로벌 환경 (즉, 샌드 박스)에서 새로 생성 된 코 루틴으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3ea021f2718dd67493fea783e7d50b3aee73fb" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the newly-created &quot;light thread&quot; will keep running asynchronously usually at various I/O events.</source>
          <target state="translated">&lt;code&gt;ngx.thread.spawn&lt;/code&gt; 이 반환 된 후 새로 작성된 &quot;light thread&quot;는 일반적으로 다양한 I / O 이벤트에서 비동기 적으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3639ec0f50b0f9a9a60809dc558a8b5d72fef67b" translate="yes" xml:space="preserve">
          <source>All rights reserved.</source>
          <target state="translated">판권 소유.</target>
        </trans-unit>
        <trans-unit id="18a4b322a141062be4a3ae201c02ab8ab5f13f32" translate="yes" xml:space="preserve">
          <source>All the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; can be used in the callback function because the function is run in a special &quot;light thread&quot;, just as those &quot;light threads&quot; created by &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;.</source>
          <target state="translated">함수가 &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn에&lt;/a&gt; 의해 생성 된 &quot;가벼운 스레드&quot;처럼 특수한 &quot;가벼운 스레드&quot;에서 실행되기 때문에 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua 용 Nginx API를&lt;/a&gt; 모두 콜백 함수에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b242e7045d7735db34c901ce4469ebd0013b2c7" translate="yes" xml:space="preserve">
          <source>All the Lua code chunks running by &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, and &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; are in a boilerplate &quot;light thread&quot; created automatically by ngx_lua. Such boilerplate &quot;light thread&quot; are also called &quot;entry threads&quot;.</source>
          <target state="translated">&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; , &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; 및 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 가 실행하는 모든 Lua 코드 청크 는 ngx_lua에 의해 자동으로 생성 된 상용구 &quot;라이트 스레드&quot;에 있습니다. 이러한 상용구 &quot;경사&quot;는 &quot;입사&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="c336d94d3cc7119e4d2b17c7136a5111c2379aab" translate="yes" xml:space="preserve">
          <source>All these methods are &lt;em&gt;atomic&lt;/em&gt; operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same &lt;code&gt;lua_shared_dict&lt;/code&gt; zone.</source>
          <target state="translated">이러한 모든 방법은 &lt;em&gt;원 자성&lt;/em&gt; 작업입니다. 즉, 동일한 &lt;code&gt;lua_shared_dict&lt;/code&gt; 영역에 대한 여러 nginx 작업자 프로세스의 동시 액세스로부터 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="13cff4d565255817db29011fa2c62a28b04b8ff3" translate="yes" xml:space="preserve">
          <source>Almost all the Nginx modules can be used with this ngx_lua module by means of &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; or &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; but it is recommended to use those &lt;code&gt;lua-resty-*&lt;/code&gt; libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 또는 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 를 통해 거의 모든 Nginx 모듈을이 ngx_lua 모듈과 함께 사용할 수 있지만 Nginx 업스트림 모듈에 액세스하기 위해 하위 요청을 작성하는 대신 &lt;code&gt;lua-resty-*&lt;/code&gt; 라이브러리 를 사용하는 것이 좋습니다. 전자는 일반적으로 훨씬 유연하고 메모리 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b0fb71d001792f849f1256bf414a7bf2500e3b8e" translate="yes" xml:space="preserve">
          <source>Also note that subrequests just mimic the HTTP interface but there is &lt;em&gt;no&lt;/em&gt; extra HTTP/TCP traffic &lt;em&gt;nor&lt;/em&gt; IPC involved. Everything works internally, efficiently, on the C level.</source>
          <target state="translated">또한 하위 요청은 HTTP 인터페이스를 모방하지만 추가 HTTP / TCP 트래픽 &lt;em&gt;이나&lt;/em&gt; IPC 는 &lt;em&gt;없습니다&lt;/em&gt; . 모든 것이 C 수준에서 내부적으로 효율적으로 작동합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca35fa7e36908a396a0901b9c466db8554c04d4e" translate="yes" xml:space="preserve">
          <source>Also note that this method call terminates the processing of the current request and that it &lt;em&gt;must&lt;/em&gt; be called before &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or explicit response body outputs by either &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;.</source>
          <target state="translated">또한이 메소드 호출은 현재 요청의 처리를 종료하며 &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; 또는 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 또는 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say에&lt;/a&gt; 의한 명시 적 응답 본문 출력 전에 호출 &lt;em&gt;되어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe41a6752e86903d1dbb6173fc8c7aad6cb2317b" translate="yes" xml:space="preserve">
          <source>Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.exit(...)&lt;/code&gt; be used to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">또한이 메소드 호출은 현재 요청의 처리를 종료 &lt;code&gt;return ngx.exit(...)&lt;/code&gt; 메소드 호출을 &lt;code&gt;return&lt;/code&gt; 명령문 과 결합하는 코딩 스타일 ( 예 : return ngx.exit (...)) 을 사용하여 다음과 같은 사실을 강화하는 것이 좋습니다. 요청 처리가 종료되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="df525509004bff82313034478f794813c159141a" translate="yes" xml:space="preserve">
          <source>Also, by default, an &lt;code&gt;__index&lt;/code&gt; metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header &lt;code&gt;My-Foo-Header&lt;/code&gt; is present, then the following invocations will all pick up the value of this header correctly:</source>
          <target state="translated">또한 기본적으로 &lt;code&gt;__index&lt;/code&gt; 메타 메소드는 결과 Lua 테이블에 추가되며 조회 누락의 경우 모든 밑줄을 대시로 변환하여 키를 순수한 소문자 형식으로 정규화합니다. 예를 들어, 요청 헤더 &lt;code&gt;My-Foo-Header&lt;/code&gt; 가있는 경우 다음 호출은 모두이 헤더의 값을 올바르게 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e79f20788c9b831a084b8454905c3f8ad5ba2da4" translate="yes" xml:space="preserve">
          <source>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive. Just ensure that the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive is used &lt;em&gt;after&lt;/em&gt; this &lt;code&gt;balancer_by_lua_block&lt;/code&gt; directive in a single &lt;code&gt;upstream {}&lt;/code&gt; configuration block.</source>
          <target state="translated">또한 Lua로드 밸런서는 표준 업스트림 연결 풀 메커니즘, 즉 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; 지시문 과 함께 작동 할 수 있습니다 . 단일 &lt;code&gt;upstream {}&lt;/code&gt; 구성 블록 에서이 &lt;code&gt;balancer_by_lua_block&lt;/code&gt; 지시문 &lt;em&gt;뒤에 &lt;/em&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; 지시문이 사용 되도록하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da35d1658d3edf63fcb2e71dc1e08e69a47c746" translate="yes" xml:space="preserve">
          <source>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive. Just ensure that the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive is used &lt;em&gt;after&lt;/em&gt; this &lt;code&gt;balancer_by_lua_block&lt;/code&gt; directive in a single &lt;code&gt;upstream {}&lt;/code&gt; configuration block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bfd0d3bc10f0b0f49a46364458a52787db0dffb" translate="yes" xml:space="preserve">
          <source>Also, the bytecode files generated by LuaJIT 2.1 is &lt;em&gt;not&lt;/em&gt; compatible with LuaJIT 2.0, and vice versa. The support for LuaJIT 2.1 bytecode was first added in ngx_lua v0.9.3.</source>
          <target state="translated">또한 LuaJIT 2.1에서 생성 된 바이트 코드 파일은 LuaJIT 2.0과 호환 &lt;em&gt;되지 않으며&lt;/em&gt; 그 반대도 마찬가지입니다. LuaJIT 2.1 바이트 코드에 대한 지원은 ngx_lua v0.9.3에서 처음 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="eea7425baea660c6b1d7aaf496f812b5548dc2ef" translate="yes" xml:space="preserve">
          <source>Alternatively, a Lua table can be passed for the &lt;code&gt;args&lt;/code&gt; argument for ngx_lua to carry out URI escaping and string concatenation.</source>
          <target state="translated">또는 ngx_lua 의 &lt;code&gt;args&lt;/code&gt; 인수에 Lua 테이블 을 전달하여 URI 이스케이프 및 문자열 연결을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87506029fa64e54229dd009ec11b44f73fb5d7e8" translate="yes" xml:space="preserve">
          <source>Alternatively, ngx_lua can be manually compiled into Nginx:</source>
          <target state="translated">또는 ngx_lua를 Nginx로 수동 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07511376cfb7b769595317205037f74e003f07c6" translate="yes" xml:space="preserve">
          <source>Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in &quot;long brackets&quot;, &lt;code&gt;[[...]]&lt;/code&gt;, in which case backslashes have to only be escaped once for the Nginx config file parser.</source>
          <target state="translated">또는 정규식 패턴은 &quot;긴 괄호&quot; &lt;code&gt;[[...]]&lt;/code&gt; 로 묶어 대괄호로 묶인 Lua 문자열 리터럴로 표시 할 수 있습니다 .이 경우 Nginx 구성 파일 구문 분석기에 대해 백 슬래시를 한 번만 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e93113cac1ceb4de1792e2692ac12fee3835591" translate="yes" xml:space="preserve">
          <source>An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various &lt;code&gt;*_by_lua_file&lt;/code&gt; directives. With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.</source>
          <target state="translated">PCRE 시퀀스를 빠져 나가는 대체 방법은 Lua 코드가 외부 스크립트 파일에 배치되고 다양한 &lt;code&gt;*_by_lua_file&lt;/code&gt; 지시문을 사용하여 실행되도록하는 것 입니다. 이 방법을 사용하면 백 슬래시는 Lua 언어 파서 만 제거하므로 한 번만 이스케이프하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8ddebaa272efa6d97a34dc782d200f40e02b5a95" translate="yes" xml:space="preserve">
          <source>An optional Lua table can be specified as the last argument to this method to specify various connect options:</source>
          <target state="translated">다양한 연결 옵션을 지정하기 위해이 메소드의 마지막 인수로 선택적 Lua 테이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f08ce6a7318c4d35a087f8fa725c16025cb3e2a6" translate="yes" xml:space="preserve">
          <source>An optional option table can be fed as the second argument, which supports the options:</source>
          <target state="translated">옵션 옵션 테이블은 옵션을 지원하는 두 번째 인수로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ed61c282220a519aaaa4b55d1c3198b477d8fd3" translate="yes" xml:space="preserve">
          <source>And below is an example demonstrating the &quot;wait any&quot; model:</source>
          <target state="translated">아래는 &quot;wait any&quot;모델을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="e368f3680374a8553f5d58ef35767a50f2bf718e" translate="yes" xml:space="preserve">
          <source>And it will generate the following output:</source>
          <target state="translated">그리고 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="765b18203e6db16ef8da296f5a808e316ab9dde2" translate="yes" xml:space="preserve">
          <source>And then we compile this &lt;code&gt;.lua&lt;/code&gt; file to &lt;code&gt;foo.o&lt;/code&gt; file:</source>
          <target state="translated">그리고이 &lt;code&gt;.lua&lt;/code&gt; 파일을 &lt;code&gt;foo.o&lt;/code&gt; 파일로 컴파일 합니다 :</target>
        </trans-unit>
        <trans-unit id="6d14c4deb748a8614c8de8753b138c5367736ffd" translate="yes" xml:space="preserve">
          <source>And this piece of code no longer depends on the external &lt;code&gt;foo.lua&lt;/code&gt; file any more because it has already been compiled into the &lt;code&gt;nginx&lt;/code&gt; executable.</source>
          <target state="translated">그리고이 코드 조각은 더 이상 외부에 의존하지 &lt;code&gt;foo.lua&lt;/code&gt; 의 가 이미 컴파일되어 있기 때문에 더 이상 파일 &lt;code&gt;nginx&lt;/code&gt; 를 실행.</target>
        </trans-unit>
        <trans-unit id="73682d133f06993eecf52633d25512f776b2d6c6" translate="yes" xml:space="preserve">
          <source>Another typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the &lt;a href=&quot;https://github.com/openresty/lua-resty-limit-traffic&quot;&gt;lua-resty-limit-traffic#readme&lt;/a&gt; library, for example.</source>
          <target state="translated">또 다른 일반적인 사용 사례는 &lt;a href=&quot;https://github.com/openresty/lua-resty-limit-traffic&quot;&gt;lua-resty-limit-traffic # readme&lt;/a&gt; 라이브러리 를 사용하여 SSL 핸드 셰이크 트래픽 제어를이 컨텍스트에서 비차 단적으로 수행하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7b66d7f631019205433228901f3bf8085dd73028" translate="yes" xml:space="preserve">
          <source>Append new data chunk specified by the &lt;code&gt;data_chunk&lt;/code&gt; argument onto the existing request body created by the &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; call.</source>
          <target state="translated">&lt;code&gt;data_chunk&lt;/code&gt; 인수로 지정된 새 데이터 청크를 &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; 호출로 작성된 기존 요청 본문에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="39511a77e2946857096d3c599882f4429646e6fc" translate="yes" xml:space="preserve">
          <source>Applications:</source>
          <target state="translated">Applications:</target>
        </trans-unit>
        <trans-unit id="b8afb2b558ed07935d5e9d319352159a30910324" translate="yes" xml:space="preserve">
          <source>Arbitrary data values, including Lua closures and nested tables, can be inserted into this &quot;magic&quot; table. It also allows the registration of custom meta methods.</source>
          <target state="translated">Lua 클로저 및 중첩 테이블을 포함한 임의의 데이터 값을이 &quot;매직&quot;테이블에 삽입 할 수 있습니다. 또한 사용자 정의 메타 메소드를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377cf7f1669cd80da0965a2ddbd03febc6edbf01" translate="yes" xml:space="preserve">
          <source>Arguments without the &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; parts are treated as boolean arguments. &lt;code&gt;GET /test?foo&amp;amp;bar&lt;/code&gt; will yield:</source>
          <target state="translated">포함하지 않는 인자 &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 부를 부울 인수로 처리된다. &lt;code&gt;GET /test?foo&amp;amp;bar&lt;/code&gt; 는 다음을 산출합니다 :</target>
        </trans-unit>
        <trans-unit id="b769f9a3141fd6f4566f46a81d75cff265f32bdd" translate="yes" xml:space="preserve">
          <source>Arguments without the &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; parts are treated as boolean arguments. &lt;code&gt;POST /test&lt;/code&gt; with the request body &lt;code&gt;foo&amp;amp;bar&lt;/code&gt; will yield:</source>
          <target state="translated">포함하지 않는 인자 &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 부를 부울 인수로 처리된다. 요청 본문 &lt;code&gt;foo&amp;amp;bar&lt;/code&gt; 사용한 &lt;code&gt;POST /test&lt;/code&gt; 는 다음 을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="74d1bff5631e418204d6a1e47283ea7d3223128b" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</source>
          <target state="translated">일반적으로 4KB 버퍼는 일반적으로 약 20 개의 일반적인 오류 로그 메시지를 보유 할 수 있습니다. 수학도 마찬가지입니다!</target>
        </trans-unit>
        <trans-unit id="4817bba79ca65e7d2af7671dfc8e87bf9464986c" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, Nginx variable interpolation is disabled in the &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; argument of this directive and therefore, the dollar sign character (&lt;code&gt;$&lt;/code&gt;) can be used directly.</source>
          <target state="translated">로부터으로 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 의 릴리스, Nginx에 변수 보간이 비활성화되어 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 이 지침의 인수 따라서, 달러 기호 문자 ( &lt;code&gt;$&lt;/code&gt; )에 직접 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ac52a04d1597fb373b1a2a66f85c16131ec5c36" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, the special notation &lt;code&gt;$prefix&lt;/code&gt; or &lt;code&gt;${prefix}&lt;/code&gt; can be used in the search path string to indicate the path of the &lt;code&gt;server prefix&lt;/code&gt; usually determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</source>
          <target state="translated">로부터으로 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 의 릴리스, 특별한 표기법 &lt;code&gt;$prefix&lt;/code&gt; 또는 &lt;code&gt;${prefix}&lt;/code&gt; 의 경로를 표시하기 위해 검색 경로 문자열에 사용할 수있는 &lt;code&gt;server prefix&lt;/code&gt; 보통에 의해 결정 &lt;code&gt;-p PATH&lt;/code&gt; 의 Nginx를 시작하는 동안 명령 줄 옵션을 섬기는 사람.</target>
        </trans-unit>
        <trans-unit id="59ac593cfece82b9cf1be4e70bfce741f9160ce3" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, all &lt;code&gt;*_by_lua_file&lt;/code&gt; configure directives (such as &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;) support loading Lua 5.1 and LuaJIT 2.0/2.1 raw bytecode files directly.</source>
          <target state="translated">로부터으로 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 릴리스, 모든 &lt;code&gt;*_by_lua_file&lt;/code&gt; 의 (예 : 구성 지침 &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt; 2.0 / 2.1 원시 바이트 코드 파일을 직접 지원 로딩 루아 5.1 LuaJIT).</target>
        </trans-unit>
        <trans-unit id="142cc5af18b62b921c724aa0bf9695a771687501" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.1&lt;/code&gt; release, this method also takes an optional &lt;code&gt;options&lt;/code&gt; table argument to control the behavior. The following options are supported:</source>
          <target state="translated">&lt;code&gt;v0.5.1&lt;/code&gt; 릴리스 에서와 마찬가지로이 메소드는 선택적 &lt;code&gt;options&lt;/code&gt; 테이블 인수를 사용하여 동작을 제어합니다. 다음과 같은 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6a814c35d562709f7d7e66211cc53c65df14f53e" translate="yes" xml:space="preserve">
          <source>As noted earlier, PCRE sequences presented within &lt;code&gt;*_by_lua_block {}&lt;/code&gt; directives (available following the &lt;code&gt;v0.9.17&lt;/code&gt; release) do not require modification.</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 지시문 ( &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 이후에 사용 가능)에 제시된 PCRE 시퀀스는 수정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02a250b80a6e00f49e90c9493ca850eb76dddf19" translate="yes" xml:space="preserve">
          <source>As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;, &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, and &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; cannot be used within the context of a Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-pcall&quot;&gt;pcall()&lt;/a&gt; or &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-xpcall&quot;&gt;xpcall()&lt;/a&gt; or even the first line of the &lt;code&gt;for ... in ...&lt;/code&gt; statement when the standard Lua 5.1 interpreter is used and the &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; error will be produced. Please use LuaJIT 2.x, which supports a fully resumable VM, to avoid this.</source>
          <target state="translated">표준 Lua 5.1 인터프리터의 VM을 완전히 &lt;a href=&quot;#ngxexit&quot;&gt;다시 시작할&lt;/a&gt; 수 없으므로 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; , &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; , &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; , &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; 및 ngx.exit 메소드 는 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-pcall&quot;&gt;pcall ()&lt;/a&gt; 컨텍스트 내에서 사용할 수 없습니다 또는 표준 Lua 5.1 인터프리터가 사용될 때 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-xpcall&quot;&gt;xpcall ()&lt;/a&gt; 또는 &lt;code&gt;for ... in ...&lt;/code&gt; 문의 첫 번째 행 &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; 오류 를 생성하려는 시도 가 생성됩니다. 이를 방지하려면 완전히 재개 가능한 VM을 지원하는 LuaJIT 2.x를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31209a87e9cff0e1996365a52545238151b8a744" translate="yes" xml:space="preserve">
          <source>As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;, &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, and &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; cannot be used within the context of a Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-pcall&quot;&gt;pcall()&lt;/a&gt; or &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-xpcall&quot;&gt;xpcall()&lt;/a&gt; or even the first line of the &lt;code&gt;for ... in ...&lt;/code&gt; statement when the standard Lua 5.1 interpreter is used and the &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; error will be produced. Please use LuaJIT 2.x, which supports a fully resumable VM, to avoid this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee79b73c99a603b36a28f4da8c38f526195ee3d" translate="yes" xml:space="preserve">
          <source>As with other access phase handlers, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; run in subrequests.</source>
          <target state="translated">다른 액세스 단계 핸들러와 &lt;a href=&quot;#access_by_lua&quot;&gt;마찬가지로 access_by_lua&lt;/a&gt; 는 하위 요청에서 실행 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ff647d09b1fc120edc207e7745e7fae020e5a668" translate="yes" xml:space="preserve">
          <source>Asks the underlying &lt;code&gt;libc&lt;/code&gt; runtime library to release its cached free memory back to the operating system every &lt;code&gt;N&lt;/code&gt; requests processed by the NGINX core. By default, &lt;code&gt;N&lt;/code&gt; is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.</source>
          <target state="translated">기본 &lt;code&gt;libc&lt;/code&gt; 런타임 라이브러리에 캐시 된 여유 메모리를 NGINX 코어에서 처리 한 &lt;code&gt;N&lt;/code&gt; 개의 요청 마다 운영 체제에 다시 해제하도록 요청합니다. 기본적으로 &lt;code&gt;N&lt;/code&gt; 은 1000입니다. 고유 번호를 사용하여 요청 수를 구성 할 수 있습니다. 숫자가 작을수록 더 빈번한 릴리스를 의미하므로 CPU 시간이 많이 소비되고 메모리 공간이 적을수록 일반적으로 CPU 시간이 적게 걸리고 메모리 공간이 상대적으로 커집니다. 자신의 사용 사례에 맞게 숫자를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="e9c872802dede2829e1efc68a335c2e837d0871a" translate="yes" xml:space="preserve">
          <source>At least the following API functions are currently disabled within the context of &lt;code&gt;set_by_lua&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;set_by_lua&lt;/code&gt; 컨텍스트 내에서 최소한 다음 API 함수가 현재 비활성화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52269ff0fdd51a17c65d8330fbb4d84c845dbca6" translate="yes" xml:space="preserve">
          <source>At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:</source>
          <target state="translated">이 ngx_lua 모듈과 함께 다음 Lua 라이브러리 및 Nginx 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d32f4a63defca3d4330f586d59cada672d86fffb" translate="yes" xml:space="preserve">
          <source>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</source>
          <target state="translated">차단하지 않고 TCP 소켓 객체를 원격 서버 또는 스트림 유닉스 도메인 소켓 파일에 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="5c2fdf03e3bcb8a9023c50548184c7a5dc1d93d7" translate="yes" xml:space="preserve">
          <source>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a &quot;connection&quot;, but only just set the name of the remote peer for subsequent read/write operations.</source>
          <target state="translated">UDP 소켓 오브젝트를 원격 서버 또는 데이터 그램 유닉스 도메인 소켓 파일에 연결하려고합니다. 데이터 그램 프로토콜은 실제로는 연결이 없기 때문에이 방법은 실제로 &quot;연결&quot;을 설정하는 것이 아니라 후속 읽기 / 쓰기 작업을 위해 원격 피어의 이름 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2298af62748ddc8565e6916c92f295142f7d2617" translate="yes" xml:space="preserve">
          <source>Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0/2.1 or vice versa, will result in an error message, such as that below, being logged into the Nginx &lt;code&gt;error.log&lt;/code&gt; file:</source>
          <target state="translated">표준 Lua 5.1 바이트 코드 파일을 LuaJIT 2.0 / 2.1에 연결된 ngx_lua 인스턴스에로드하거나 그 반대로로드하려고하면 Nginx &lt;code&gt;error.log&lt;/code&gt; 파일에 다음 과 같은 오류 메시지가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="5cc6e7a370a6ae461ad4867e179276ccfbd9f17a" translate="yes" xml:space="preserve">
          <source>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.</source>
          <target state="translated">기본적으로 서버를 시작하는 동안 마스터 프로세스를 차단하면이 컨텍스트에서 I / O를 차단하는 Lua 라이브러리를 안전하게 사용할 수 있습니다. Nginx 코어조차도 구성 로딩 단계에서 I / O를 차단합니다 (적어도 업스트림 호스트 이름 확인시).</target>
        </trans-unit>
        <trans-unit id="6fec49ca638189d7ef0e8ba025f476ac935f4924" translate="yes" xml:space="preserve">
          <source>Basically you use the &lt;code&gt;luajit&lt;/code&gt; executable to compile &lt;code&gt;.lua&lt;/code&gt; Lua module files to &lt;code&gt;.o&lt;/code&gt; object files containing the exported bytecode data, and then link the &lt;code&gt;.o&lt;/code&gt; files directly in your Nginx build.</source>
          <target state="translated">기본적으로 당신은 사용 &lt;code&gt;luajit&lt;/code&gt; 의 컴파일을 실행 &lt;code&gt;.lua&lt;/code&gt; 에 루아 모듈 파일을 &lt;code&gt;.o&lt;/code&gt; 를 보낸 바이트 코드 데이터를 포함하는 오브젝트 파일, 다음 링크 &lt;code&gt;.o&lt;/code&gt; 인 당신의 Nginx의 빌드에서 직접 파일을.</target>
        </trans-unit>
        <trans-unit id="a3e3dcf699574118a54b2f7517b617508eb38064" translate="yes" xml:space="preserve">
          <source>Because Lua's &lt;code&gt;dofile&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; builtins are currently implemented as C functions in both Lua 5.1 and LuaJIT 2.0/2.1, if the Lua file being loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; invokes &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture*&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, or other API functions requiring yielding in the &lt;em&gt;top-level&lt;/em&gt; scope of the Lua file, then the Lua error &quot;attempt to yield across C-call boundary&quot; will be raised. To avoid this, put these calls requiring yielding into your own Lua functions in the Lua file instead of the top-level scope of the file.</source>
          <target state="translated">루아의 때문에 &lt;code&gt;dofile&lt;/code&gt; 와이 &lt;code&gt;require&lt;/code&gt; 내장 명령은 현재 루아 파일에 의해로드되는 경우, 모두 루아 5.1 및 LuaJIT 2.0 / 2.1에서 C 함수로 구현됩니다 &lt;code&gt;dofile&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 를 발동이 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture *&lt;/a&gt; , &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; , &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; , 또는 다른 Lua 파일 의 &lt;em&gt;최상위 레벨&lt;/em&gt; 에서 양보해야하는 API 함수 , &quot;C-call 경계를 가로 질러 양보하려고 시도&quot;오류가 발생합니다. 이를 피하려면 파일의 최상위 범위 대신 Lua 파일의 자체 Lua 함수에 항복이 필요한 이러한 호출을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="28388ab663976d5bd8791cf32f69d11e930b9177" translate="yes" xml:space="preserve">
          <source>Because of the metamethod magic, never &quot;local&quot; the &lt;code&gt;ngx.ctx&lt;/code&gt; table outside your Lua function scope on the Lua module level due to &lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;worker-level data sharing&lt;/a&gt;. For example, the following is bad:</source>
          <target state="translated">메타 메소드 마술 때문에 &lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;작업자 수준의 데이터 공유&lt;/a&gt; 로 인해 Lua 모듈 수준에서 Lua 함수 범위 밖의 &lt;code&gt;ngx.ctx&lt;/code&gt; 테이블을 &quot;로컬&quot;하지 마십시오 . 예를 들어 다음은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc085d42cb3c86bf7992490ce09f48337af2ea11" translate="yes" xml:space="preserve">
          <source>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;Copy-on-write (COW)&lt;/a&gt; feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</source>
          <target state="translated">이 컨텍스트에서 Lua 코드는 Nginx가 작업자 프로세스 (있는 경우)를 포크하기 전에 실행되므로 여기에로드 된 데이터 또는 코드는 모든 작업자 프로세스 중 많은 운영 체제에서 제공하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;COW (Copy-On-Write)&lt;/a&gt; 기능 을 즐기 므로 많은 메모리.</target>
        </trans-unit>
        <trans-unit id="0beae072640b4acb91c9d7ef2e9effec9cd12e1c" translate="yes" xml:space="preserve">
          <source>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;Copy-on-write (COW)&lt;/a&gt; feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5605db73db672c4d88b10182faf4547b8c0ffd3" translate="yes" xml:space="preserve">
          <source>Because this API function does not create new Lua strings nor new Lua tables, it is much faster than &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;. It should be used wherever possible.</source>
          <target state="translated">이 API 함수는 새로운 Lua 문자열이나 새로운 Lua 테이블을 생성하지 않기 때문에 &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 보다 훨씬 빠릅니다 . 가능하면 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cdb737f889537d826ebf12f06995869afc269f6" translate="yes" xml:space="preserve">
          <source>Because timer callbacks run in the background and their running time will not add to any client request's response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of &quot;pending timers&quot; and the number of &quot;running timers&quot; in an Nginx worker process. The &quot;pending timers&quot; here mean timers that have not yet been expired and &quot;running timers&quot; are those whose user callbacks are currently running.</source>
          <target state="translated">타이머 콜백은 백그라운드에서 실행되며 실행 시간은 클라이언트 요청의 응답 시간에 추가되지 않으므로 Lua 프로그래밍 실수 또는 너무 많은 클라이언트 트래픽으로 인해 서버에 쉽게 누적되고 시스템 리소스를 소모 할 수 있습니다. Nginx 서버 충돌과 같은 극단적 인 결과를 방지하기 위해 Nginx 작업자 프로세스의 &quot;보류중인 타이머&quot;수와 &quot;실행 타이머&quot;수에 대한 제한이 내장되어 있습니다. 여기서 &quot;보류중인 타이머&quot;는 아직 만료되지 않은 타이머를 의미하고 &quot;실행 타이머&quot;는 사용자 콜백이 현재 실행중인 타이머를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7aa9a2875ef4c81f88c80d771a97469ef5422797" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the &lt;code&gt;func&lt;/code&gt; will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; (like &lt;a href=&quot;#tcpsockreceive&quot;&gt;tcpsock:receive&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ngx.thread.spawn&lt;/code&gt; 이 반환 되기 전에 &lt;code&gt;func&lt;/code&gt; 은 반환 될 때까지 옵션 인수와 함께 호출되며, 오류가 발생하거나 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua 용 Nginx API&lt;/a&gt; ( &lt;a href=&quot;#tcpsockreceive&quot;&gt;tcpsock : receive&lt;/a&gt; 와 같은) 를 통한 I / O 작업으로 인해 생성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5245d4cddd8bd64eda850eb993c419e25a8d8726" translate="yes" xml:space="preserve">
          <source>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the &lt;a href=&quot;#ngxsocketconnect&quot;&gt;ngx.socket.connect&lt;/a&gt; function).</source>
          <target state="translated">실제로 호스트 이름을 확인하고 원격 백엔드에 연결하기 전에이 메소드는 항상이 메소드의 이전 호출 (또는 &lt;a href=&quot;#ngxsocketconnect&quot;&gt;ngx.socket.connect&lt;/a&gt; 함수)에 의해 작성된 일치하는 유휴 연결에 대한 연결 풀을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="9b1ccfb282b9e36abe3e540f74d2b68d1c7be274" translate="yes" xml:space="preserve">
          <source>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_long&lt;/code&gt; function defined in the Nginx core.</source>
          <target state="translated">배후에는 Nginx 코어에 정의 된 &lt;code&gt;ngx_crc32_long&lt;/code&gt; 함수 주위의 얇은 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="fb8e1b77b26209826931f5e18788890e539e2f52" translate="yes" xml:space="preserve">
          <source>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_short&lt;/code&gt; function defined in the Nginx core.</source>
          <target state="translated">배후에는 Nginx 코어에 정의 된 &lt;code&gt;ngx_crc32_short&lt;/code&gt; 함수 주위의 얇은 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="3935a12ca0db1eedc35357022379e99b8a802bac" translate="yes" xml:space="preserve">
          <source>Behind the scene, the &quot;eof&quot; flag is just the &lt;code&gt;last_buf&lt;/code&gt; (for main requests) or &lt;code&gt;last_in_chain&lt;/code&gt; (for subrequests) flag of the Nginx chain link buffers. (Before the &lt;code&gt;v0.7.14&lt;/code&gt; release, the &quot;eof&quot; flag does not work at all in subrequests.)</source>
          <target state="translated">이면에서 &quot;eof&quot;플래그는 Nginx 체인 링크 버퍼 의 &lt;code&gt;last_buf&lt;/code&gt; (주요 요청) 또는 &lt;code&gt;last_in_chain&lt;/code&gt; (하위 요청) 플래그입니다. ( &lt;code&gt;v0.7.14&lt;/code&gt; 릴리스 이전에는 &quot;eof&quot;플래그가 하위 요청에서 전혀 작동하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="d579ee4c5c8c892e1012408f2840320a50fc6fd6" translate="yes" xml:space="preserve">
          <source>Behind the scene, this method makes use of the Nginx timers.</source>
          <target state="translated">뒤에서이 방법은 Nginx 타이머를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="74784fcd147a7425449e502fe60db7f32d2485eb" translate="yes" xml:space="preserve">
          <source>Below is a trivial example to demonstrate this. Consider that we have the following &lt;code&gt;.lua&lt;/code&gt; file named &lt;code&gt;foo.lua&lt;/code&gt;:</source>
          <target state="translated">아래는 이것을 보여주는 간단한 예입니다. 우리는 다음이 있음을 고려 &lt;code&gt;.lua&lt;/code&gt; 라는 이름의 파일 &lt;code&gt;foo.lua&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="d2cf1e8afa6c4fa7f0608ac88cf472e1af3f8214" translate="yes" xml:space="preserve">
          <source>Below is a trivial example using the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; module at the same time:</source>
          <target state="translated">아래는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; 모듈을 동시에 사용하는 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="translated">아래는 예입니다.</target>
        </trans-unit>
        <trans-unit id="a6ee5b336df565b5a2920bfca52bbec159414950" translate="yes" xml:space="preserve">
          <source>Boolean argument values are also supported, for instance,</source>
          <target state="translated">부울 인수 값도 지원됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="2c4013170b059320690d73b1cea3c90718747378" translate="yes" xml:space="preserve">
          <source>Both IP addresses and domain names can be specified as the &lt;code&gt;host&lt;/code&gt; argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver&quot;&gt;resolver&lt;/a&gt; directive in the &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="translated">IP 주소와 도메인 이름을 모두 &lt;code&gt;host&lt;/code&gt; 인수 로 지정할 수 있습니다 . 도메인 이름의 경우이 방법은 Nginx 코어의 동적 리졸버를 사용하여 차단하지 않고 도메인 이름을 구문 분석 하며 &lt;code&gt;nginx.conf&lt;/code&gt; 파일에서 다음과 같이 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver&quot;&gt;리졸버&lt;/a&gt; 지시문 을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="369a8e09f8461b013ea816bc31c7a3bb6fae7bc7" translate="yes" xml:space="preserve">
          <source>Both IP addresses and domain names can be specified as the &lt;code&gt;host&lt;/code&gt; argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#resolver&quot;&gt;resolver&lt;/a&gt; directive in the &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b010286216cbc849fdecb1ec167816122fac8fa" translate="yes" xml:space="preserve">
          <source>Bugs and Patches</source>
          <target state="translated">버그와 패치</target>
        </trans-unit>
        <trans-unit id="e289b213785e349d7804f94803f1f350cd03409d" translate="yes" xml:space="preserve">
          <source>Build the source with this module:</source>
          <target state="translated">이 모듈로 소스를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="777afebeea44fcd442afa109dfa8ae4ad6acff9f" translate="yes" xml:space="preserve">
          <source>Building as a dynamic module</source>
          <target state="translated">동적 모듈로 구축</target>
        </trans-unit>
        <trans-unit id="ef1c0d7fe324eb83fec61b3fd56030d2a57bfc05" translate="yes" xml:space="preserve">
          <source>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</source>
          <target state="translated">그러나 악의적 인 사용자 입력에 매우주의하고 항상 사용자 제공 경로 구성 요소를 신중하게 확인하거나 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="13f3f8d695fb47e63f2879e1a140ffe7be2a9095" translate="yes" xml:space="preserve">
          <source>But do not forget to comment this line out before publishing your site to the world.</source>
          <target state="translated">그러나 사이트를 전세계에 게시하기 전에이 줄을 주석 처리하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="76de2c4f5adeff8aa8d422f168e13846bb716a34" translate="yes" xml:space="preserve">
          <source>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort&quot;&gt;proxy_ignore_client_abort&lt;/a&gt; directive in your location block configured by &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt;:</source>
          <target state="translated">그러나 Nginx 업스트림 모듈로 구성된 다른 위치에 액세스하기 위해 하위 요청을 작성하는 경우 기본적으로 그렇지 않은 경우 클라이언트 업그레이드 중단을 무시하도록 해당 업스트림 모듈을 구성해야합니다. 예를 들어, 기본적으로 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; 은 클라이언트가 연결을 닫는 즉시 하위 요청과 기본 요청을 모두 종료하므로 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort&quot;&gt;ngx_http_proxy_module로&lt;/a&gt; 구성된 위치 블록에서 proxy_ignore_client_abort 지시문을 설정하는 것이 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;중요합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a43ef5c84b9487d185c00cd5d067a5465c95f27" translate="yes" xml:space="preserve">
          <source>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort&quot;&gt;proxy_ignore_client_abort&lt;/a&gt; directive in your location block configured by &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8605cdbf72dbe7967a34c8860108a861c33718" translate="yes" xml:space="preserve">
          <source>But note that, the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt;'s shm storage will not be cleared through a config reload (via the &lt;code&gt;HUP&lt;/code&gt; signal, for example). So if you do &lt;em&gt;not&lt;/em&gt; want to re-initialize the shm storage in your &lt;code&gt;init_by_lua&lt;/code&gt; code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your &lt;code&gt;init_by_lua&lt;/code&gt; code.</source>
          <target state="translated">그러나 &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; 의 shm 스토리지는 구성 다시로드를 통해 ( 예 : &lt;code&gt;HUP&lt;/code&gt; 신호 를 통해) 지워지지 않습니다 . 따라서이 경우 &lt;code&gt;init_by_lua&lt;/code&gt; 코드에서 shm 스토리지를 다시 초기화 하지 &lt;em&gt;않으&lt;/em&gt; 려면 shm 스토리지에서 사용자 정의 플래그를 설정하고 항상 &lt;code&gt;init_by_lua&lt;/code&gt; 코드 에서 플래그를 확인하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="025b165153131ffb429543ba496b3d5978d7e140" translate="yes" xml:space="preserve">
          <source>By default, all the subrequests subsequently initiated by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; will inherit the new header.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 및 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi에&lt;/a&gt; 의해 이후에 시작된 모든 하위 요청 은 새 헤더를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="9cbb14b03c0cef3dfcea3433cf63f6dd828947dd" translate="yes" xml:space="preserve">
          <source>By default, only the first 1024 keys (if any) are returned. When the &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; argument is given the value &lt;code&gt;0&lt;/code&gt;, then all the keys will be returned even there is more than 1024 keys in the dictionary.</source>
          <target state="translated">기본적으로 처음 1024 개의 키 (있는 경우) 만 반환됩니다. 때 &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; 인수가 값 주어진다 &lt;code&gt;0&lt;/code&gt; 을 , 모든 키도 사전에 1024 개 이상의 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="38e01d9bc32ddfaf4bfb653b20d7a358a1bfbf95" translate="yes" xml:space="preserve">
          <source>By default, the corresponding Nginx handler (e.g., &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler) will not terminate until</source>
          <target state="translated">기본적으로 해당 Nginx 핸들러 (예 : &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 핸들러)는 종료 될 때까지 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e934f7015591f2ded843d4d03c8339134b1608c7" translate="yes" xml:space="preserve">
          <source>By default, the request line and trailing &lt;code&gt;CR LF&lt;/code&gt; terminator will also be included. For example,</source>
          <target state="translated">기본적으로 요청 라인과 후행 &lt;code&gt;CR LF&lt;/code&gt; 터미네이터도 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a77d4a1e4cb25b53cee3c37fcae44e5e96e80bbd" translate="yes" xml:space="preserve">
          <source>C Macro Configurations</source>
          <target state="translated">C 매크로 구성</target>
        </trans-unit>
        <trans-unit id="fab120f4ade6616bdd48020953a15b3b89454c04" translate="yes" xml:space="preserve">
          <source>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인수에 대한 CRC-32 (Cyclic Redundancy Code) 다이제스트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d4d7cb46ad6aade1ccd55675f7840010137217ca" translate="yes" xml:space="preserve">
          <source>Calling this method on an already connected socket object will cause the original connection to be closed first.</source>
          <target state="translated">이미 연결된 소켓 객체에서이 메소드를 호출하면 원래 연결이 먼저 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a18622848f8695e4af301660d065221500bd5f67" translate="yes" xml:space="preserve">
          <source>Care must be taken when importing modules and this form should be used:</source>
          <target state="translated">모듈을 가져올 때는주의를 기울여야하며이 양식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bec7eedab840089a1f91f66aade81eb04c294518" translate="yes" xml:space="preserve">
          <source>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, or &lt;code&gt;copy_all_vars&lt;/code&gt; options are generally preferable instead.</source>
          <target state="translated">변수 범위 공유에 예기치 않은 부작용이있을 수 있으므로이 옵션을 사용할 때는주의를 기울여야합니다. &lt;code&gt;args&lt;/code&gt; , &lt;code&gt;vars&lt;/code&gt; , 또는 &lt;code&gt;copy_all_vars&lt;/code&gt; 의 옵션 대신에 일반적으로 바람직하다.</target>
        </trans-unit>
        <trans-unit id="205635e2d30f61579e630e686c4ab2986ac6e9ef" translate="yes" xml:space="preserve">
          <source>Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;.</source>
          <target state="translated">에서 제공하는 특정 루아 API는 아직 Nginx에의 SPDY 모드에서 작업을 할 ngx_lua : &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; , &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="fa82f055bd9a8bd0bf293a05642b0f0c2c27fc2e" translate="yes" xml:space="preserve">
          <source>Chinese Mailing List</source>
          <target state="translated">중국 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="5adc3a0b1fa84612c05e854d94a26ce7445bce67" translate="yes" xml:space="preserve">
          <source>Clears the current request's request header named &lt;code&gt;header_name&lt;/code&gt;. None of the current request's existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.</source>
          <target state="translated">&lt;code&gt;header_name&lt;/code&gt; 이라는 현재 요청의 요청 헤더를 지 웁니다 . 현재 요청의 기존 하위 요청은 영향을받지 않지만 이후에 시작된 하위 요청은 기본적으로 변경 사항을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="d490d21fceeea922082c55d291fb819a2aa1ef2d" translate="yes" xml:space="preserve">
          <source>Closes the current TCP or stream unix domain socket. It returns the &lt;code&gt;1&lt;/code&gt; in case of success and returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error otherwise.</source>
          <target state="translated">현재 TCP 또는 스트림 유닉스 도메인 소켓을 닫습니다. 성공 하면 &lt;code&gt;1&lt;/code&gt; 을 반환하고 그렇지 않으면 오류를 설명하는 문자열과 함께 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4fc1e8fa8bef29b7f64e2a84406b14acb2bd6091" translate="yes" xml:space="preserve">
          <source>Closes the current UDP or datagram unix domain socket. It returns the &lt;code&gt;1&lt;/code&gt; in case of success and returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error otherwise.</source>
          <target state="translated">현재 UDP 또는 데이터 그램 유닉스 도메인 소켓을 닫습니다. 성공 하면 &lt;code&gt;1&lt;/code&gt; 을 반환하고 그렇지 않으면 오류를 설명하는 문자열과 함께 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6d1aa7d812b27d79c0c1208eec7bebf471596c94" translate="yes" xml:space="preserve">
          <source>Code Repository</source>
          <target state="translated">코드 리포지토리</target>
        </trans-unit>
        <trans-unit id="bfd58ee3a270f3a931009900e1008d549bbd7453" translate="yes" xml:space="preserve">
          <source>Community</source>
          <target state="translated">Community</target>
        </trans-unit>
        <trans-unit id="5faed13d1b9ec66ea4dd42b28f9aeb3e8291a197" translate="yes" xml:space="preserve">
          <source>Completes the construction process of the new request body created by the &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; 호출로 작성된 새 요청 본문의 구성 프로세스를 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="1ffdd76c61bd2bc1c63d37327c812517458b60a1" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;http://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC-SHA1&lt;/a&gt; digest of the argument &lt;code&gt;str&lt;/code&gt; and turns the result using the secret key &lt;code&gt;&amp;lt;secret_key&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;str&lt;/code&gt; 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC-SHA1&lt;/a&gt; 다이제스트를 계산하고 비밀 키 &lt;code&gt;&amp;lt;secret_key&amp;gt;&lt;/code&gt; 를 사용하여 결과를 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="17d6b7e58a666666af99165c4d729a31104d8dd2" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC-SHA1&lt;/a&gt; digest of the argument &lt;code&gt;str&lt;/code&gt; and turns the result using the secret key &lt;code&gt;&amp;lt;secret_key&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f96250746eda72a409d432d944a3717e9602df" translate="yes" xml:space="preserve">
          <source>Configuring the argument to &lt;code&gt;0&lt;/code&gt; essentially turns off the periodical memory trimming altogether.</source>
          <target state="translated">인수를 &lt;code&gt;0&lt;/code&gt; 으로 구성하면 주기적 메모리 트리밍이 완전히 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="6446cd7e96cba73b9293c41aefb78a2216327d7f" translate="yes" xml:space="preserve">
          <source>Connecting to a Unix Domain Socket file is also possible:</source>
          <target state="translated">유닉스 도메인 소켓 파일에 연결하는 것도 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ceca46f95767076b3e03327e09595cd0ff021e8e" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; and &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;)</source>
          <target state="translated">제어 API 기능 (예 : &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; 및 &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f5c8417c95d29bf32371feee6f028188847b7242" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;)</source>
          <target state="translated">제어 API 기능 (예 : &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a1aa985f5ba4298ca1ce081f6731fa62ac3235cd" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; and &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;)</source>
          <target state="translated">제어 API 기능 (예 : &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; 및 &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="5a129bc7ab81f3252b4dd4d835f81ccec26e010e" translate="yes" xml:space="preserve">
          <source>Controls the &lt;code&gt;lowat&lt;/code&gt; (low water) value for the cosocket send buffer.</source>
          <target state="translated">코 소켓 송신 버퍼 의 &lt;code&gt;lowat&lt;/code&gt; (낮은 물) 값을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="365bf88c43a7210eedc24410a257ae7e616dd607" translate="yes" xml:space="preserve">
          <source>Controls the default timeout value used in TCP/unix-domain socket object's &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; method and can be overridden by the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; or &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; methods.</source>
          <target state="translated">TCP / unix-domain 소켓 오브젝트의 &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; 메소드에 사용되는 기본 시간 종료 값을 제어하며 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 또는 &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; 메소드 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="397940f42488c4420013f4dab2b05106c28a473e" translate="yes" xml:space="preserve">
          <source>Controls the maximum number of &quot;running timers&quot; allowed.</source>
          <target state="translated">허용되는 최대 &quot;실행 타이머&quot;수를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="56fefe02667d54aa2d72d50889f821605bae34a0" translate="yes" xml:space="preserve">
          <source>Controls the maximum number of pending timers allowed.</source>
          <target state="translated">허용되는 최대 보류 타이머 수를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="135abb501ad1b78711e51df9da32f441943c3cb2" translate="yes" xml:space="preserve">
          <source>Controls whether or not to disable postponing &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt; directives to run at the end of the &lt;code&gt;access&lt;/code&gt; request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;access&lt;/code&gt; phase.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 요청 처리 단계 가 끝날 때 연기 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; 지시문 을 비활성화할지 여부를 제어합니다 . 기본적으로이 지정 문은 해제되어 있으며 Lua 코드는 &lt;code&gt;access&lt;/code&gt; 단계 가 끝날 때 실행되도록 연기됩니다 .</target>
        </trans-unit>
        <trans-unit id="d12a174326acbcfde0787b3b61f0b2d216c533db" translate="yes" xml:space="preserve">
          <source>Controls whether or not to disable postponing &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; directives to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; phase.</source>
          <target state="translated">&lt;code&gt;rewrite&lt;/code&gt; 요청 처리 단계 의 끝에서 실행 연기 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 지시문 을 비활성화할지 여부를 제어합니다 . 기본적으로이 지시문은 해제되어 있으며 Lua 코드는 &lt;code&gt;rewrite&lt;/code&gt; 단계 의 끝에서 실행되도록 연기됩니다 .</target>
        </trans-unit>
        <trans-unit id="909a9c3bd668cff95f6fcd8735560f894a264f73" translate="yes" xml:space="preserve">
          <source>Controls whether to transform underscores (&lt;code&gt;_&lt;/code&gt;) in the response header names specified in the &lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt; API to hypens (&lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt; API에 지정된 응답 헤더 이름의 밑줄 ( &lt;code&gt;_&lt;/code&gt; )을 하이픈 ( &lt;code&gt;-&lt;/code&gt; ) 으로 변환할지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="85d1e3919eeba35b19183dcfaaaef7a57a658492" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2009-2017, by Xiaozhe Wang (chaoslawful) &lt;a href=&quot;mailto:chaoslawful@gmail.com&quot;&gt;chaoslawful@gmail.com&lt;/a&gt;.</source>
          <target state="translated">Xiaozhe Wang (chaoslawful) &lt;a href=&quot;mailto:chaoslawful@gmail.com&quot;&gt;chaoslawful@gmail.com의&lt;/a&gt; 저작권 (C) 2009-2017 .</target>
        </trans-unit>
        <trans-unit id="a0ea5fb647bf6a547d5714554cf0d8359944d733" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2009-2018, by Yichun &quot;agentzh&quot; Zhang (章亦春) &lt;a href=&quot;mailto:agentzh@gmail.com&quot;&gt;agentzh@gmail.com&lt;/a&gt;, OpenResty Inc.</source>
          <target state="translated">Copyright (C) 2009-2018, Yichun &quot;agentzh&quot;Zhang (章 亦 春) &lt;a href=&quot;mailto:agentzh@gmail.com&quot;&gt;agentzh@gmail.com&lt;/a&gt; , OpenResty Inc.</target>
        </trans-unit>
        <trans-unit id="4fc24471116f3e2d97602dd028f800b05cacef1a" translate="yes" xml:space="preserve">
          <source>Copyright and License</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="70b3bb876101904c3c0515924008e365a5c27cf9" translate="yes" xml:space="preserve">
          <source>Core constants</source>
          <target state="translated">핵심 상수</target>
        </trans-unit>
        <trans-unit id="4c48657a691e01318c2ec61c9823282bd50d9aad" translate="yes" xml:space="preserve">
          <source>Cosocket API functions (e.g., &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;).</source>
          <target state="translated">코 소켓 API 함수 (예 : &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b400cfa6df4811fdd8291d2c4ab1dcddfb366e50" translate="yes" xml:space="preserve">
          <source>Cosockets Not Available Everywhere</source>
          <target state="translated">모든 지역에서 사용할 수없는 코 소켓</target>
        </trans-unit>
        <trans-unit id="c9a411eb35af3886593d4fc7e9a4ec3d74be3ad1" translate="yes" xml:space="preserve">
          <source>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; APIs.</source>
          <target state="translated">현재 요청에 대해 새 공백 요청 본문을 작성하고 &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; API 를 통해 이후 요청 본문 데이터 쓰기를 위해 버퍼를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="f07632b66a22d40c20cd39dc95c453c672dd5728" translate="yes" xml:space="preserve">
          <source>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</source>
          <target state="translated">Lua 함수를 사용하여 사용자 Lua 코 루틴을 작성하고 코 루틴 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d862e7bf0f690ca3f94b0070e00fa39e7dfbb38" translate="yes" xml:space="preserve">
          <source>Creates an Nginx timer with a user callback function as well as optional user arguments.</source>
          <target state="translated">사용자 콜백 함수 및 선택적 사용자 인수를 사용하여 Nginx 타이머를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9ee4e559744243aec9e77c98e2242a78d443708d" translate="yes" xml:space="preserve">
          <source>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects). The following methods are supported on this object:</source>
          <target state="translated">TCP 또는 스트림 지향 유닉스 도메인 소켓 객체 ( &quot;코 소켓&quot;객체의 한 유형이라고도 함)를 만들고 반환합니다. 이 객체에서 지원되는 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbfe979fefa10cf7f6544c9214d1014badfe97fa" translate="yes" xml:space="preserve">
          <source>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects). The following methods are supported on this object:</source>
          <target state="translated">UDP 또는 데이터 그램 지향 유닉스 도메인 소켓 객체 ( &quot;코 소켓&quot;객체의 한 유형이라고도 함)를 만들고 반환합니다. 이 객체에서 지원되는 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb53329a3a7669fa398d8bf780e0c78fc936abd9" translate="yes" xml:space="preserve">
          <source>Curly braces can also be used to disambiguate variable names from the background string literals:</source>
          <target state="translated">중괄호는 배경 문자열 리터럴에서 변수 이름을 명확하게하기 위해 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04fd81c5d27700a16cec223326b0820188887b4" translate="yes" xml:space="preserve">
          <source>Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns &lt;code&gt;nil&lt;/code&gt; for unrecognized values.</source>
          <target state="translated">현재 가능한 값은 2.0, 1.0, 1.1 및 0.9입니다. 인식 할 수없는 값에 대해서는 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1e55515195eb8a3e12ad16f0e25bf71c8e1b1993" translate="yes" xml:space="preserve">
          <source>Data Sharing within an Nginx Worker</source>
          <target state="translated">Nginx 작업자 내 데이터 공유</target>
        </trans-unit>
        <trans-unit id="09515d7ad679c206e461a48757870b58e578ce09" translate="yes" xml:space="preserve">
          <source>Declares a shared memory zone, &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, to serve as storage for the shm based Lua dictionary &lt;code&gt;ngx.shared.&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">공유 메모리 영역 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 선언 하여 shm 기반 Lua 사전 &lt;code&gt;ngx.shared.&amp;lt;name&amp;gt;&lt;/code&gt; 의 저장소로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f3b02d295dd6a6c2076e175a4a9e4a5e942f0e" translate="yes" xml:space="preserve">
          <source>Decodes a URI encoded query-string into a Lua table. This is the inverse function of &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt;.</source>
          <target state="translated">URI로 인코딩 된 쿼리 문자열을 Lua 테이블로 디코딩합니다. 이것은 &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt; 의 역함수 입니다.</target>
        </trans-unit>
        <trans-unit id="e0109e1f34e2fab3bc07f52b8ae7f809bcde0a42" translate="yes" xml:space="preserve">
          <source>Decodes the &lt;code&gt;str&lt;/code&gt; argument as a base64 digest to the raw form. Returns &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well formed.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인수를 base64 다이제스트로 원시 형식으로 디코드합니다 . 반환 &lt;code&gt;nil&lt;/code&gt; 을 경우 &lt;code&gt;str&lt;/code&gt; 잘 형성되지 않는다.</target>
        </trans-unit>
        <trans-unit id="83626d3b06b38d1cc87af089e736d3f7b2b833af" translate="yes" xml:space="preserve">
          <source>Default to 30 connections for every pool.</source>
          <target state="translated">모든 풀에 대해 기본값은 30입니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="54750baa0787dc7ff0ee984d90855802e7c8be14" translate="yes" xml:space="preserve">
          <source>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned &lt;code&gt;on&lt;/code&gt; or the &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; function should be called within the Lua code.</source>
          <target state="translated">rewrite / access / access_by_lua *를 실행하기 전에 요청 본문 데이터를 강제로 읽을 지 여부를 결정합니다. Nginx 코어는 기본적으로 클라이언트 요청 본문을 읽지 않으며 요청 본문 데이터가 필요한 경우이 지시문을 &lt;code&gt;on&lt;/code&gt; 하거나 Lua 코드 내에서 &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="c59ab2b723662b2de5a29bff24948bebf43dad1d" translate="yes" xml:space="preserve">
          <source>Disabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a &quot;hello world&quot; Lua example can drop by an order of magnitude after disabling the Lua code cache.</source>
          <target state="translated">Lua 코드 캐시를 비활성화하면 프로덕션 용도로 사용하지 않는 것이 좋으며 전체 성능에 중대한 부정적인 영향을 미치므로 개발 중에 만 사용해야합니다. 예를 들어 &quot;hello world&quot;Lua 예제의 성능은 Lua 코드 캐시를 비활성화 한 후 몇 배나 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="226be261389d03c098224fbb551ea625e21c9f90" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the &lt;a href=&quot;#lua-variable-scope&quot;&gt;Lua Variable Scope&lt;/a&gt; section for more details). The recommended way is to use proper &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#5.3&quot;&gt;Lua module&lt;/a&gt; files (but do not use the standard Lua function &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-module&quot;&gt;module()&lt;/a&gt; to define Lua modules because it pollutes the global namespace as well) and call &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; to load your own module files in &lt;code&gt;init_by_lua&lt;/code&gt; or other contexts (&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; does cache the loaded Lua modules in the global &lt;code&gt;package.loaded&lt;/code&gt; table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</source>
          <target state="translated">수행 &lt;em&gt;하지&lt;/em&gt; 루아 전역 변수의 사용은 성능 저하가 글로벌 네임 스페이스 오염으로 이어질합니다 (볼 수 있기 때문에 이러한 맥락에서 자신의 루아 전역 변수를 초기화 &lt;a href=&quot;#lua-variable-scope&quot;&gt;루아 변수 범위&lt;/a&gt; 자세한 내용은 섹션). 권장되는 방법은 적절한 사용하는 것입니다 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#5.3&quot;&gt;루아 모듈&lt;/a&gt; 파일을 (그러나 표준 루아 함수를 사용하지 않는 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-module&quot;&gt;모듈을 ()&lt;/a&gt; 그것뿐만 아니라 글로벌 네임 스페이스를 오염 때문에 루아 모듈을 정의) 및 호출 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;) (필요&lt;/a&gt; 에 자신의 모듈 파일을로드 할 &lt;code&gt;init_by_lua&lt;/code&gt; 또는 기타 contexts ( &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require ()&lt;/a&gt; 는로드 된 Lua 모듈을 전역 &lt;code&gt;package.loaded&lt;/code&gt; 에 캐시합니다. 모듈이 전체 Lua VM 인스턴스에 대해 한 번만로드됩니다).</target>
        </trans-unit>
        <trans-unit id="ee1a6fac1e434d5da3ae43b5925a008daea6b3e1" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the &lt;a href=&quot;#lua-variable-scope&quot;&gt;Lua Variable Scope&lt;/a&gt; section for more details). The recommended way is to use proper &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#5.3&quot;&gt;Lua module&lt;/a&gt; files (but do not use the standard Lua function &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-module&quot;&gt;module()&lt;/a&gt; to define Lua modules because it pollutes the global namespace as well) and call &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; to load your own module files in &lt;code&gt;init_by_lua&lt;/code&gt; or other contexts (&lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; does cache the loaded Lua modules in the global &lt;code&gt;package.loaded&lt;/code&gt; table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df34d24999db01b1b2d79ab927d026249fdac918" translate="yes" xml:space="preserve">
          <source>Do not activate the &lt;code&gt;o&lt;/code&gt; option for regular expressions (and/or &lt;code&gt;replace&lt;/code&gt; string arguments for &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt; and &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub&lt;/a&gt;) that are generated &lt;em&gt;on the fly&lt;/em&gt; and give rise to infinite variations to avoid hitting the specified limit.</source>
          <target state="translated">활성화하지 마십시오 &lt;code&gt;o&lt;/code&gt; &lt;em&gt;즉시&lt;/em&gt; 생성 &lt;em&gt;되는&lt;/em&gt; 정규식 (및 / 또는 &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt; 및 &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub의&lt;/a&gt; 문자열 인수 &lt;code&gt;replace&lt;/code&gt; 대해 o 옵션을 지정된 한계에 도달하지 않도록 무한한 변형을 유발하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87b53087c3f604e47b786a680f2de8abdf1bf277" translate="yes" xml:space="preserve">
          <source>Do not use backlashes to escape dollar signs; it will not work as expected.</source>
          <target state="translated">달러 기호를 피하기 위해 백래시를 사용하지 마십시오. 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27fe54bb9fec7379d6ad43f2de7fdce9fb0149ae" translate="yes" xml:space="preserve">
          <source>Do not use this directive and other content handler directives in the same location. For example, this directive and the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; directive should not be used in the same location.</source>
          <target state="translated">이 지시문과 다른 컨텐츠 핸들러 지시문을 같은 위치에 사용하지 마십시오. 예를 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&quot;&gt;들어이&lt;/a&gt; 지시문과 proxy_pass 지시문을 같은 위치에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="278ac53e5ea9702607ab7ddc6bd516089815cea1" translate="yes" xml:space="preserve">
          <source>Do not use this directive and other content handler directives in the same location. For example, this directive and the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; directive should not be used in the same location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf0613f0197b9bbdd423e70af9e75fdaedae896" translate="yes" xml:space="preserve">
          <source>Does SSL/TLS handshake on the currently established connection.</source>
          <target state="translated">현재 설정된 연결에서 SSL / TLS 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4fd7855f0a481f9ca860dd0c55ade18fa1c6fe55" translate="yes" xml:space="preserve">
          <source>Does an internal redirect to &lt;code&gt;uri&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt; and is similar to the &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_exec&quot;&gt;echo_exec&lt;/a&gt; directive of the &lt;a href=&quot;http://github.com/openresty/echo-nginx-module&quot;&gt;echo-nginx-module&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 로 내부 리디렉션 &lt;code&gt;args&lt;/code&gt; 로 하고 &lt;a href=&quot;http://github.com/openresty/echo-nginx-module&quot;&gt;echo-nginx-module&lt;/a&gt; 의 &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_exec&quot;&gt;echo_exec&lt;/a&gt; 지시문 과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="8fa1167b598e656f9bc1d177e2743016f56c9ca5" translate="yes" xml:space="preserve">
          <source>Does an internal redirect to &lt;code&gt;uri&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt; and is similar to the &lt;a href=&quot;https://github.com/openresty/echo-nginx-module#echo_exec&quot;&gt;echo_exec&lt;/a&gt; directive of the &lt;a href=&quot;https://github.com/openresty/echo-nginx-module&quot;&gt;echo-nginx-module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045d83da712ca79a4c6422d852804b994e647f90" translate="yes" xml:space="preserve">
          <source>Download the latest version of Nginx &lt;a href=&quot;http://nginx.org/&quot;&gt;HERE&lt;/a&gt; (See &lt;a href=&quot;#nginx-compatibility&quot;&gt;Nginx Compatibility&lt;/a&gt;)</source>
          <target state="translated">최신 버전의 Nginx &lt;a href=&quot;http://nginx.org/&quot;&gt;HERE&lt;/a&gt; 다운로드 ( &lt;a href=&quot;#nginx-compatibility&quot;&gt;Nginx 호환성&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d84120022bff0f8056098f851d2f4c8e8fa357c5" translate="yes" xml:space="preserve">
          <source>Download the latest version of Nginx &lt;a href=&quot;https://nginx.org/&quot;&gt;HERE&lt;/a&gt; (See &lt;a href=&quot;#nginx-compatibility&quot;&gt;Nginx Compatibility&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d40ecb5ccbedf533d02f870ffdd9ea9baf019eb" translate="yes" xml:space="preserve">
          <source>Download the latest version of ngx_lua &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;HERE&lt;/a&gt;.</source>
          <target state="translated">ngx_lua &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;HERE&lt;/a&gt; 최신 버전을 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="0318d120477b77f197c8861318b9d222ce4f59d1" translate="yes" xml:space="preserve">
          <source>Download the latest version of the ngx_devel_kit (NDK) module &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit/tags&quot;&gt;HERE&lt;/a&gt;.</source>
          <target state="translated">최신 버전의 ngx_devel_kit (NDK) 모듈을 &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit/tags&quot;&gt;여기&lt;/a&gt; 에서 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c7f631291d7ba5f151c641b1207915b8dd977fc" translate="yes" xml:space="preserve">
          <source>Due to internal limitations in the nginx core, the cosocket API is disabled in the following contexts: &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua*&lt;/a&gt;, &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua*&lt;/a&gt;, &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;, and &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;.</source>
          <target state="translated">nginx 코어의 내부 제한으로 인해 코 소켓 API는 다음 컨텍스트에서 사용 불가능합니다. &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua *&lt;/a&gt; , &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua *&lt;/a&gt; , &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt; 및 &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ad1ffff9a35f09f7908bd0a6d2f9d7f052bacc" translate="yes" xml:space="preserve">
          <source>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running &quot;light thread&quot; that is pending on one ore more Nginx subrequests. You must call &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt; to wait for those &quot;light thread&quot; to terminate before quitting the &quot;world&quot;. A notable exception here is that you can abort pending subrequests by calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with and only with the status code &lt;code&gt;ngx.ERROR&lt;/code&gt; (-1), &lt;code&gt;408&lt;/code&gt;, &lt;code&gt;444&lt;/code&gt;, or &lt;code&gt;499&lt;/code&gt;.</source>
          <target state="translated">Nginx 하위 요청 모델의 제한으로 인해 실행중인 Nginx 하위 요청을 일반적으로 중단 할 수 없습니다. 따라서 하나 이상의 Nginx 하위 요청에서 보류중인 실행중인 &quot;가벼운 스레드&quot;를 중단하는 것도 금지됩니다. &quot;world&quot;를 종료하기 전에 &quot;light thread&quot;가 종료 될 때까지 &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt; 를 호출해야합니다 . 여기서 주목할만한 예외는 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; 를 상태 코드 &lt;code&gt;ngx.ERROR&lt;/code&gt; (-1), &lt;code&gt;408&lt;/code&gt; , &lt;code&gt;444&lt;/code&gt; 또는 &lt;code&gt;499&lt;/code&gt; 로만 호출하여 보류중인 하위 요청을 중단 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="29236bdfab72d0d4652e5f127c1abb6088f7a723" translate="yes" xml:space="preserve">
          <source>Dynamic Routing Based on Redis and Lua</source>
          <target state="translated">Redis 및 Lua 기반 동적 라우팅</target>
        </trans-unit>
        <trans-unit id="7a54f388572d656cf23a248ceb8957e858d23f7a" translate="yes" xml:space="preserve">
          <source>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.</source>
          <target state="translated">HTTP 클라이언트에 연결된 인수를 응답 본문으로 생성합니다. 응답 헤더가 전송되지 않은 경우이 함수는 먼저 헤더를 전송 한 다음 본문 데이터를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="848bd1d7829f4a2891e7ad23e5a3a735760ac53c" translate="yes" xml:space="preserve">
          <source>Empty key arguments are discarded. &lt;code&gt;GET /test?=hello&amp;amp;=world&lt;/code&gt; will yield an empty output for instance.</source>
          <target state="translated">빈 키 인수는 무시됩니다. &lt;code&gt;GET /test?=hello&amp;amp;=world&lt;/code&gt; 는 예를 들어 빈 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="29a4c565d886e2f1088c2bf4c92e2ae9ac98cb46" translate="yes" xml:space="preserve">
          <source>Empty key arguments are discarded. &lt;code&gt;POST /test&lt;/code&gt; with body &lt;code&gt;=hello&amp;amp;=world&lt;/code&gt; will yield empty outputs for instance.</source>
          <target state="translated">빈 키 인수는 무시됩니다. body &lt;code&gt;=hello&amp;amp;=world&lt;/code&gt; 사용한 &lt;code&gt;POST /test&lt;/code&gt; 는 빈 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cc419b0b69c9aa6c694814bab7e2aebe8ddf6212" translate="yes" xml:space="preserve">
          <source>Enables a buffer of the specified &lt;code&gt;size&lt;/code&gt; for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.</source>
          <target state="translated">파일 또는 디스크를 건드리지 않고 모든 nginx 오류 로그 메시지 데이터 (이 모듈 또는 nginx http 하위 시스템에서 생성 된 데이터뿐만 아니라 모든 것)를 캡처하기 위해 지정된 &lt;code&gt;size&lt;/code&gt; 의 버퍼를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="5ca6b0f5c877b9e145b7d6521d38ce1c27401939" translate="yes" xml:space="preserve">
          <source>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper &lt;code&gt;Content-Length&lt;/code&gt; response header.</source>
          <target state="translated">HTTP 1.0 (또는 이전) 요청에 대한 자동 응답 버퍼링을 사용하거나 사용하지 않습니다. 이 버퍼링 메커니즘은 주로 HTTP 1.0 연결 유지에 사용되며 적절한 &lt;code&gt;Content-Length&lt;/code&gt; 응답 헤더를 .</target>
        </trans-unit>
        <trans-unit id="d47e73453f9316d717aba75922430ed16aa911aa" translate="yes" xml:space="preserve">
          <source>Enables or disables the Lua code cache for Lua code in &lt;code&gt;*_by_lua_file&lt;/code&gt; directives (like &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt; and &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;) and Lua modules.</source>
          <target state="translated">&lt;code&gt;*_by_lua_file&lt;/code&gt; 지시문 에서 &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt; 및 &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt; 과 같은 Lua 코드에 대한 Lua 코드 캐시를 활성화하거나 비활성화합니다. ) 및 Lua 모듈 .</target>
        </trans-unit>
        <trans-unit id="4c965a9d008aee66f1903b81d52961dab4d946de" translate="yes" xml:space="preserve">
          <source>Enables the specified protocols for requests to a SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock : sslhandshake&lt;/a&gt; 에서 SSL / TLS 서버에 대한 요청에 지정된 프로토콜을 사용합니다 . 메소드 .</target>
        </trans-unit>
        <trans-unit id="0ca81a117829498e1df5519357caffe2c9733474" translate="yes" xml:space="preserve">
          <source>Encode the Lua table to a query args string according to the URI encoded rules.</source>
          <target state="translated">URI 인코딩 규칙에 따라 Lua 테이블을 쿼리 인수 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="bca5e541da234316491f694f5205241ef47dc529" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;str&lt;/code&gt; to a base64 digest.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인코딩 을 base64 다이제스트로 .</target>
        </trans-unit>
        <trans-unit id="672deddd0ee057c0155b582ac943883e4a7afb83" translate="yes" xml:space="preserve">
          <source>English Mailing List</source>
          <target state="translated">영어 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="e441252616b6eb66b814c7ba77392af14981d806" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">상당 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua는&lt;/a&gt; , 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt; 루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="9823cebe38e894116a468c6035b7a854d221774f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua_block&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="601357c81b16cf532123ea4076e8b528852a928d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="dfb2f6ec767b197b70fe3640a9c169a98fd98341" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="c11377b90e93b1905c50d4ece1c707a1cf5072b9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 루아 코드를 포함하거나, 발 등 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드&lt;/a&gt; 가 실행되는 .</target>
        </trans-unit>
        <trans-unit id="fe6f4eee3b9f2e690c5d93a592edf2eb5ce11212" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code or &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 루아 코드 또는 포함 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행하도록한다.</target>
        </trans-unit>
        <trans-unit id="0ff2a3bed582cc2fe25c77e9b21ef2539db0486f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="c9d7398a9b03b4863f098b37e65ea4a3677324c8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="b0575e053d64ca1c9ae92204cb31794bfa0be159" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="7d1b305ee0951eb364c7af57db15fc447008035e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua_block&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 로부터 같이 루아 코드를 포함하거나 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 의 방출은 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="2a4e104cd121a98a1337911f916013f47e095811" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or rather, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 에 의해 지정된 파일 에 Lua 코드 또는 실행되는 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT 바이트 코드&lt;/a&gt; 가 포함되어 있다는 점을 제외하고 &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua_block&lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bdefe071dc6b790d2f2bcf9b7e02dbafc7c6f305" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or rather, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">동등 &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; 의해 지정된 파일 것 이외에는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 루아 코드를 포함하거나, 오히려 &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;루아 / LuaJIT 바이트 코드를&lt;/a&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="5c7718395e7fc56a6b0a753777273c639adf8883" translate="yes" xml:space="preserve">
          <source>Escape &lt;code&gt;str&lt;/code&gt; as a URI component.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 탈출 을 URI 컴포넌트로 .</target>
        </trans-unit>
        <trans-unit id="1341ef48de08929843ab769ae8f7e6539554fd80" translate="yes" xml:space="preserve">
          <source>Even when the code cache is enabled, Lua files which are loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;loadfile&lt;/code&gt; in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; or &lt;a href=&quot;#init-by_lua_file&quot;&gt;init_by_lua_file&lt;/a&gt; directives to load all such files or just make these Lua files true Lua modules and load them via &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">코드 캐시가 활성화 된 경우에도 * _by_lua_file의 &lt;code&gt;dofile&lt;/code&gt; 또는 &lt;code&gt;loadfile&lt;/code&gt; 에 의해로드 된 Lua 파일은 캐시 할 수 없습니다 (결과를 직접 캐시하지 않는 한). 일반적으로 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; 또는 &lt;a href=&quot;#init-by_lua_file&quot;&gt;init_by_lua_file&lt;/a&gt; 지시문을 사용하여 이러한 모든 파일을로드하거나 이러한 Lua 파일을 진정한 Lua 모듈로 만들고 &lt;code&gt;require&lt;/code&gt; 를 통해로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="174c4d77c963e9180bc79b90152f3deb03e7eede" translate="yes" xml:space="preserve">
          <source>Every request, including subrequests, has its own copy of the table. For example:</source>
          <target state="translated">하위 요청을 포함한 모든 요청에는 자체 테이블 사본이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4aedda1f12219002fc466d8e5f18bfe9175f41e0" translate="yes" xml:space="preserve">
          <source>Everything should be installed correctly, except for one small tweak.</source>
          <target state="translated">한 번의 미세 조정을 제외하고 모든 것이 올바르게 설치되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3992fa3b93a6b5051f434706f88bed97617920b6" translate="yes" xml:space="preserve">
          <source>Executes code specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; with optional input arguments &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, and returns string output to &lt;code&gt;$res&lt;/code&gt;. The code in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; can make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and can retrieve input arguments from the &lt;code&gt;ngx.arg&lt;/code&gt; table (index starts from &lt;code&gt;1&lt;/code&gt; and increases sequentially).</source>
          <target state="translated">선택적 입력 인수 &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt; 와 함께 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 코드를 실행 하고 문자열 출력을 &lt;code&gt;$res&lt;/code&gt; 반환합니다 . 의 코드 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 할 수 있습니다 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API 호출&lt;/a&gt; 과의 입력 인수를 검색 할 수 있습니다 &lt;code&gt;ngx.arg&lt;/code&gt; 의 (에서 인덱스 시작 테이블을 &lt;code&gt;1&lt;/code&gt; 순차적으로 증가).</target>
        </trans-unit>
        <trans-unit id="1c12206113d2b57037d91f6489e2bbed1041dc1b" translate="yes" xml:space="preserve">
          <source>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).</source>
          <target state="translated">요청 본문을 명시 적으로 버립니다. 즉, 연결에서 데이터를 읽고 즉시 요청 본문을 사용하지 않고 즉시 버립니다.</target>
        </trans-unit>
        <trans-unit id="f5814c9c7e3273369d1d62d8c845f804b67326ad" translate="yes" xml:space="preserve">
          <source>Explicitly send out the response headers.</source>
          <target state="translated">응답 헤더를 명시 적으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ca507048e6f0b797564f110900294aafce027666" translate="yes" xml:space="preserve">
          <source>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the &quot;last chunk&quot;.</source>
          <target state="translated">응답 출력 스트림의 끝을 명시 적으로 지정하십시오. HTTP 1.1 청크 인코딩 된 출력의 경우 &quot;최근 청크&quot;를 보내도록 Nginx 코어를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="ab25e95ad23e40f6eb866bcbae94c86cf8068d65" translate="yes" xml:space="preserve">
          <source>Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt; on a closed connection, you will get the &quot;closed&quot; error.</source>
          <target state="translated">항상 자동으로 종료 cosocket 운영에 치명적인 오류 (읽기 시간 초과 오류가 심각하지 않은 유일한 오류는 것을 주) 현재 연결, 당신은 호출하는 경우 &lt;a href=&quot;#tcpsockclose&quot;&gt;가까운&lt;/a&gt; 클로즈 된 접속에, 당신은 &quot;폐쇄&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="835aa7ce5d740e606fa00ee0f91bc5cae8e84da8" translate="yes" xml:space="preserve">
          <source>Fetch a list of the keys from the dictionary, up to &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">사전에서 최대 &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; 까지 키 목록을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ca997ba8650e8c2256c2941489e33c4f66ae673f" translate="yes" xml:space="preserve">
          <source>Fetching the shm-based Lua dictionary object for the shared memory zone named &lt;code&gt;DICT&lt;/code&gt; defined by the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; 지시문으로 정의 된 &lt;code&gt;DICT&lt;/code&gt; 라는 공유 메모리 영역에 대한 shm 기반 Lua 사전 오브젝트를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d8efc283a60693ed74a3a3630cbf66e47031c184" translate="yes" xml:space="preserve">
          <source>Finally, you can just do the following in any Lua code run by ngx_lua:</source>
          <target state="translated">마지막으로 ngx_lua가 실행하는 Lua 코드에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a882477906a72a016763aaaedd8099e67a2ab03" translate="yes" xml:space="preserve">
          <source>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</source>
          <target state="translated">사전의 모든 항목을 비 웁니다. 이 방법은 실제로 사전의 모든 메모리 블록을 비우는 것이 아니라 기존의 모든 항목을 만료 된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3cc5eaad08c83373710debed7ee00745f4f8d182" translate="yes" xml:space="preserve">
          <source>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional &lt;code&gt;max_count&lt;/code&gt; argument. When the &lt;code&gt;max_count&lt;/code&gt; argument is given &lt;code&gt;0&lt;/code&gt; or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.</source>
          <target state="translated">선택적인 &lt;code&gt;max_count&lt;/code&gt; 인수로 지정된 최대 값까지 사전에서 만료 된 항목을 플러시합니다 . 때 &lt;code&gt;max_count&lt;/code&gt; 인수가 주어진다 &lt;code&gt;0&lt;/code&gt; 또는 전혀 부여하지, 그것은 무제한을 의미합니다. 실제로 플러시 된 항목 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="129c1618975020c172306ba179594d500de058eb" translate="yes" xml:space="preserve">
          <source>Flushes response output to the client.</source>
          <target state="translated">클라이언트에 응답 출력을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="ec477f5bbf501d0b66178f3d4176a18efda8be4f" translate="yes" xml:space="preserve">
          <source>For connections that have already done SSL/TLS handshake, this method returns immediately.</source>
          <target state="translated">이미 SSL / TLS 핸드 셰이크를 수행 한 연결의 경우이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2038276fd97f85926c5a4b23ed50e50cf5439fe3" translate="yes" xml:space="preserve">
          <source>For every cosocket object's underlying connection, if you do not explicitly close it (via &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt;) or put it back to the connection pool (via &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt;), then it is automatically closed when one of the following two events happens:</source>
          <target state="translated">모든 코 소켓 객체의 기본 연결에 대해 명시 적으로 닫거나 ( &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt; 를 통해 ) 연결 풀 ( &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; 를 통해 )에 다시 연결 하지 않으면 다음 두 이벤트 중 하나가 발생하면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="132e22aaa89e3c51181cf591152b21565afcd701" translate="yes" xml:space="preserve">
          <source>For example, on Linux, you can configure the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot;&gt;listen&lt;/a&gt; directive in your &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="translated">예를 들어, Linux에서는 다음 과 같이 &lt;code&gt;nginx.conf&lt;/code&gt; 파일 에서 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot;&gt;청취&lt;/a&gt; 지시문을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f77cdda8bc7d70f4463a815f4d6cfab8ffa5be9d" translate="yes" xml:space="preserve">
          <source>For example, on Linux, you can configure the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot;&gt;listen&lt;/a&gt; directive in your &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524deba8612f94c182a1072d829569a8b92cae95" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt; directives can be invoked this way:</source>
          <target state="translated">예를 들어, 다음과 같은 &lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt; 지시문을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0305dd31462049a72e323e1ddbf8db3ce9e6d22" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;a href=&quot;https://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt; directives can be invoked this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888ee1307c04ff5268bdb5c014c373a9f9e022d8" translate="yes" xml:space="preserve">
          <source>For example, the following nginx config snippet</source>
          <target state="translated">예를 들어, 다음 nginx 구성 스 니펫</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="2243254b8d3334f140c01ed0f2fd04fdebc01c62" translate="yes" xml:space="preserve">
          <source>For large streaming output responses, it is important to disable the &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; directive to minimise memory usage.</source>
          <target state="translated">큰 스트리밍 출력 응답의 경우 메모리 사용을 최소화하기 위해 &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; 지시문을 비활성화하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="5fa9bd6ca8ef2a9e5afbb12db75cbc330f4e7d25" translate="yes" xml:space="preserve">
          <source>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers</source>
          <target state="translated">다중 값 헤더의 경우 모든 헤더 값이 순서대로 수집되어 Lua 테이블로 반환됩니다. 예를 들어 응답 헤더</target>
        </trans-unit>
        <trans-unit id="6b0305ec674b59e78fc78e9236b3cecc277de5be" translate="yes" xml:space="preserve">
          <source>For multiple instances of request headers such as:</source>
          <target state="translated">다음과 같은 요청 헤더의 여러 인스턴스 :</target>
        </trans-unit>
        <trans-unit id="a8b105e8a12da61107b0becbd1ea70e4e5b14dbe" translate="yes" xml:space="preserve">
          <source>For reading &lt;em&gt;request&lt;/em&gt; headers, use the &lt;a href=&quot;#ngxreqget_headers&quot;&gt;ngx.req.get_headers&lt;/a&gt; function instead.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 헤더 를 읽으 &lt;a href=&quot;#ngxreqget_headers&quot;&gt;려면&lt;/a&gt; 대신 ngx.req.get_headers 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a4f898bb94fc02ef73f3690a54a97ee3d308065" translate="yes" xml:space="preserve">
          <source>For the first two cases, the &quot;light thread&quot; will usually be resumed later by the ngx_lua scheduler unless a &quot;stop-the-world&quot; event happens.</source>
          <target state="translated">처음 두 경우의 경우, &quot;light thread&quot;는 &quot;world-stop&quot;이벤트가 발생하지 않는 한 ngx_lua 스케줄러에 의해 나중에 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3308122160bc2877fdfdfcca4d2ab3689cd0648d" translate="yes" xml:space="preserve">
          <source>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.</source>
          <target state="translated">Nginx 현재 시간 캐시를 강제로 업데이트합니다. 이 호출에는 syscall이 포함되므로 약간의 오버 헤드가 있으므로 남용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c0a2d356e0e0d4d90067bb911e726f3eac7fdee9" translate="yes" xml:space="preserve">
          <source>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</source>
          <target state="translated">또한이 지시문이 작동하려면 OpenSSL 1.0.2e 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="834ae9e99b8b6a9826d729d0634f4fc5ab14acf9" translate="yes" xml:space="preserve">
          <source>HTTP 1.0 support</source>
          <target state="translated">HTTP 1.0 지원</target>
        </trans-unit>
        <trans-unit id="1a4622e797b7743912ca2b88796464b6dcbe5f56" translate="yes" xml:space="preserve">
          <source>HTTP method constants</source>
          <target state="translated">HTTP 메소드 상수</target>
        </trans-unit>
        <trans-unit id="28a0a7164e0b1418f1c3394ff78f4b046de17a3c" translate="yes" xml:space="preserve">
          <source>HTTP status constants</source>
          <target state="translated">HTTP 상태 상수</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5727a1a012063f5d7f39cedf7dee4fa6e5d6fb4" translate="yes" xml:space="preserve">
          <source>Here is a complete small example:</source>
          <target state="translated">다음은 완전한 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="abf108a8df4414aaa34a5af0676733fd9f64d978" translate="yes" xml:space="preserve">
          <source>Here is a small example to demonstrate its basic usage:</source>
          <target state="translated">다음은 기본 사용법을 보여주는 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="translated">여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="7190b51d3af3f50398f760626d41f747c681ec72" translate="yes" xml:space="preserve">
          <source>Here is an example assuming the current server name is &lt;code&gt;localhost&lt;/code&gt; and that it is listening on port 1984:</source>
          <target state="translated">다음은 현재 서버 이름이 &lt;code&gt;localhost&lt;/code&gt; 이고 포트 1984에서 수신 대기 중이라고 가정하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="7ff1f55dc6eea9cf983ecb9a2754252e40f57471" translate="yes" xml:space="preserve">
          <source>Here is an example for connecting to a TCP server:</source>
          <target state="translated">다음은 TCP 서버에 연결하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="16df324258cb4611dbfd62a6b207f20190f5f6c0" translate="yes" xml:space="preserve">
          <source>Here is an example for connecting to a UDP (memcached) server:</source>
          <target state="translated">다음은 UDP (memcached) 서버에 연결하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f4d22bdb4926576e6cb8442a48189a490820cdff" translate="yes" xml:space="preserve">
          <source>Here is an example for using this method to read a data stream with the boundary sequence &lt;code&gt;--abcedhb&lt;/code&gt;:</source>
          <target state="translated">다음은이 방법을 사용하여 경계 시퀀스 &lt;code&gt;--abcedhb&lt;/code&gt; 로 데이터 스트림을 읽는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c06a9ee44a8aa1338a5f7412b1b34c328337dda4" translate="yes" xml:space="preserve">
          <source>Here is an example of gathering average data for &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time&quot;&gt;$upstream_response_time&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time&quot;&gt;$ upstream_response_time에&lt;/a&gt; 대한 평균 데이터를 수집하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c764ee4b998c9952e81d78aaa8367bf67d520b97" translate="yes" xml:space="preserve">
          <source>Here is an example of gathering average data for &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time&quot;&gt;$upstream_response_time&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064f9b0b02634e2215035a4195d5910c0f16b45e" translate="yes" xml:space="preserve">
          <source>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</source>
          <target state="translated">다음은 Lua 헤더 필터에서 응답 헤더를 재정의하거나 부재 헤더를 추가하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="936eca4f242cdd82a38de414d305e2f31309d2fe" translate="yes" xml:space="preserve">
          <source>Here is an example of setting the &lt;code&gt;Content-Type&lt;/code&gt; header:</source>
          <target state="translated">다음은 &lt;code&gt;Content-Type&lt;/code&gt; 헤더 를 설정하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6a11e9ba4fb83ee0ba0a48dfdf440be493f4277" translate="yes" xml:space="preserve">
          <source>Here is some examples:</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="efaa732972663f1b7912dc2fce9e739444767f66" translate="yes" xml:space="preserve">
          <source>Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the &lt;code&gt;require()&lt;/code&gt; built-in in the &lt;code&gt;package.loaded&lt;/code&gt; table for later reference, and the &lt;code&gt;module()&lt;/code&gt; builtin used by some Lua modules has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler, and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">이유는 다음과 같습니다. 전역 환경의 수명은 Nginx 요청 처리기와 정확히 동일한 수명입니다. 각 요청 핸들러에는 고유 한 Lua 전역 변수 세트가 있으며 이는 요청 격리라는 개념입니다. Lua 모듈은 실제로 첫 번째 Nginx 요청 핸들러에 의해로드되며 나중에 참조 할 수 있도록 &lt;code&gt;package.loaded&lt;/code&gt; 테이블 의 &lt;code&gt;require()&lt;/code&gt; 내장에 의해 캐시 되며 일부 Lua 모듈에 의해 사용되는 &lt;code&gt;module()&lt;/code&gt; 내장은 설정의 부작용이 있습니다 로드 된 모듈 테이블에 대한 전역 변수 그러나이 전역 변수는 요청 핸들러의 끝에서 지워지며 이후의 모든 요청 핸들러에는 모두 고유 한 (깨끗한) 글로벌 환경이 있습니다. 따라서 &lt;code&gt;nil&lt;/code&gt; 값 에 액세스하면 Lua 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7bcce11f878e044ead7760922e294b0ede073fe7" translate="yes" xml:space="preserve">
          <source>Here it essentially implements the &quot;wait all&quot; model.</source>
          <target state="translated">여기서는 기본적으로 &quot;모두 대기&quot;모델을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f1319e81e84e6849c3f7a1e3a92eadfc193fc96a" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;args&lt;/code&gt; table will always look like</source>
          <target state="translated">여기서 &lt;code&gt;args&lt;/code&gt; 테이블은 항상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29fdd15f63d70dbdabc5fe387002bf8a40de4916" translate="yes" xml:space="preserve">
          <source>Here the Lua code &lt;code&gt;ngx.exit(503)&lt;/code&gt; will never run. This will be the case if &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; is used as this will similarly initiate an internal redirection. If the &lt;code&gt;break&lt;/code&gt; modifier is used instead, there will be no internal redirection and the &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will be executed.</source>
          <target state="translated">루아 코드 &lt;code&gt;ngx.exit(503)&lt;/code&gt; 는 절대로 실행되지 않습니다. 경우가 이에 해당합니다 &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; 이 유사하게 내부 리디렉션을 시작합니다으로 사용됩니다. 경우 &lt;code&gt;break&lt;/code&gt; 수정이 대신 사용됩니다, 거기에는 내부 리디렉션 수 없습니다와 &lt;code&gt;rewrite_by_lua&lt;/code&gt; 의 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2a710c1c09c5bf83d52ca5927cfb832b53442915" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;[[\\d+]]&lt;/code&gt; is stripped down to &lt;code&gt;[[\d+]]&lt;/code&gt; by the Nginx config file parser and this is processed correctly.</source>
          <target state="translated">여기서 Nginx 설정 파일 파서에 의해 &lt;code&gt;[[\\d+]]&lt;/code&gt; 가 &lt;code&gt;[[\d+]]&lt;/code&gt; 되고 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d61d4f7c09eb6c109c3aecddb78bb107b4d4978d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;\\\\d+&lt;/code&gt; is stripped down to &lt;code&gt;\\d+&lt;/code&gt; by the Nginx config file parser and this is further stripped down to &lt;code&gt;\d+&lt;/code&gt; by the Lua language parser before running.</source>
          <target state="translated">여기서, &lt;code&gt;\\\\d+&lt;/code&gt; 는 Nginx 설정 파일 파서에 의해 &lt;code&gt;\\d+&lt;/code&gt; 로 제거 되고 실행하기 전에 Lua 언어 파서에 의해 &lt;code&gt;\d+&lt;/code&gt; 로 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="71e81a8c8ac4d5dbc873062e1734124d97de4de3" translate="yes" xml:space="preserve">
          <source>Here, modification of the &lt;code&gt;ngx.ctx.blah&lt;/code&gt; entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of &lt;code&gt;ngx.ctx.blah&lt;/code&gt;.</source>
          <target state="translated">여기서 하위 요청 의 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 항목 수정은 상위 요청의 항목에 영향을 미치지 않습니다. 두 가지 버전의 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 가 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="9368bf706794ea693cb396265db206b3a85cb6f2" translate="yes" xml:space="preserve">
          <source>However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation.</source>
          <target state="translated">그러나 나중에 코 소켓 오브젝트 조작 시도가 실패하고 실패한 연결 조작으로 생성 된 실제 오류 상태 메시지를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="64b36a44792e92b2e62e16303bdc04165d6592a9" translate="yes" xml:space="preserve">
          <source>However, the optional &lt;code&gt;max_args&lt;/code&gt; function argument can be used to override this limit:</source>
          <target state="translated">그러나 선택적 &lt;code&gt;max_args&lt;/code&gt; 함수 인수를 사용하여이 한계를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16476ba0f6439993e2a5cf1a2b564ff32097adee" translate="yes" xml:space="preserve">
          <source>However, the optional &lt;code&gt;max_headers&lt;/code&gt; function argument can be used to override this limit:</source>
          <target state="translated">그러나 선택적 &lt;code&gt;max_headers&lt;/code&gt; 함수 인수를 사용하여이 한계를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ca6682d96c11b2020f980cec3aefafbee8d44a" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running&quot;&gt;coroutine.running&lt;/a&gt; API.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running&quot;&gt;coroutine.running&lt;/a&gt; API와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="baf73d9226c36ff807951a9eb684fd387d53fbf7" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status&quot;&gt;coroutine.status&lt;/a&gt; API.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status&quot;&gt;coroutine.status&lt;/a&gt; API와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c605f34924b33894668023a12dda2efe1463826b" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running&quot;&gt;coroutine.running&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74edc0ad52ffe240716233be22b2d1a7fd0aacaf" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status&quot;&gt;coroutine.status&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6878ecfb6c510244611be91a3cc9a15d0bebd1a8" translate="yes" xml:space="preserve">
          <source>Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.</source>
          <target state="translated">풀의 유휴 연결은 연결 중단 또는 회선의 예기치 않은 수신 데이터와 같은 예외적 인 이벤트가 있는지 모니터링합니다.이 경우 해당 연결이 닫히고 풀에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="40004bde4984f6de44357af2d2fabc4c36bff1ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as an empty list before performing the push operation. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 푸시 작업을 수행하기 전에 빈 목록으로 작성됩니다. 때 &lt;code&gt;key&lt;/code&gt; 이미 목록에없는 값을가집니다, 그것은 반환 &lt;code&gt;nil&lt;/code&gt; 와 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4505017ca3bde826de93b98e585f21f59b46d7f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, it will return &lt;code&gt;nil&lt;/code&gt;. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 반환 &lt;code&gt;nil&lt;/code&gt; . 때 &lt;code&gt;key&lt;/code&gt; 이미 목록에없는 값을가집니다, 그것은 반환 &lt;code&gt;nil&lt;/code&gt; 와 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a07772c34e8634d235bf9a4601943be99c7077" translate="yes" xml:space="preserve">
          <source>If a non-number-like string argument is specified, then it is interpreted as a &quot;pattern&quot;. The following patterns are supported:</source>
          <target state="translated">숫자가 아닌 문자열 인수가 지정되면 &quot;패턴&quot;으로 해석됩니다. 다음과 같은 패턴이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ea09aa6fff45ed8b081a30d931e1a055abcbaaf0" translate="yes" xml:space="preserve">
          <source>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.</source>
          <target state="translated">숫자와 같은 인수가 지정되면 (숫자처럼 보이는 문자열 포함) 크기로 해석됩니다. 이 메서드는이 크기의 데이터를 정확하게 읽거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3562f4805f70337df0a3c1836f25652eefd8dc3e" translate="yes" xml:space="preserve">
          <source>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.</source>
          <target state="translated">요청 본문 데이터를 Nginx 코어 요청 헤더 버퍼로 미리 읽은 경우 결과 코 소켓 객체는 이러한 미리 읽기로 인한 잠재적 인 데이터 손실을 피하기 위해이를 처리합니다. 청크 요청 본문은이 API에서 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd3c3c79067b9e123a81f5493d5d75fbc01c9539" translate="yes" xml:space="preserve">
          <source>If key does not exist, it is interpreted as an empty list and 0 is returned. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">키가 존재하지 않으면 빈 목록으로 해석되어 0이 리턴됩니다. 때 &lt;code&gt;key&lt;/code&gt; 이미 목록에없는 값을가집니다, 그것은 반환 &lt;code&gt;nil&lt;/code&gt; 와 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ab7b9d1442f540c5aef9b2bd1d333ecffad992" translate="yes" xml:space="preserve">
          <source>If no argument is specified, then it is assumed to be the pattern &lt;code&gt;'*l'&lt;/code&gt;, that is, the line reading pattern.</source>
          <target state="translated">인수가 지정되지 않은 경우 패턴 &lt;code&gt;'*l'&lt;/code&gt; , 즉 행 판독 패턴 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="68ced9540eb5b96bf29e30c367fb2fdd6167c1ff" translate="yes" xml:space="preserve">
          <source>If no argument is specified, then the maximal buffer size, &lt;code&gt;8192&lt;/code&gt; is assumed.</source>
          <target state="translated">인수를 지정하지 않으면 최대 버퍼 크기 인 &lt;code&gt;8192&lt;/code&gt; 가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc8985aa0e3ff420acceccfa0058e60b662d30b" translate="yes" xml:space="preserve">
          <source>If no match is found, this function just returns a &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">일치하는 것이 없으면이 함수는 &lt;code&gt;nil&lt;/code&gt; 값만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="75ca869a7146bac3959a49050799e3f56b4e42f6" translate="yes" xml:space="preserve">
          <source>If server-wide data sharing is required, then use one or more of the following approaches:</source>
          <target state="translated">서버 전체의 데이터 공유가 필요한 경우 다음 방법 중 하나 이상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c0194760970731892880cca8ce9b02572fd4250" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive is used to change the URI and initiate location re-lookups (internal redirections), then any &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; or &lt;a href=&quot;#rewrite_by_lua_file&quot;&gt;rewrite_by_lua_file&lt;/a&gt; code sequences within the current location will not be executed. For example,</source>
          <target state="translated">경우] &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; 의 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;재기록&lt;/a&gt; 지시자는 URI를 변경하는데 사용 위치 다시 조회 (내부 리디렉션)를 개시하고, 그 다음 어느 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 또는 &lt;a href=&quot;#rewrite_by_lua_file&quot;&gt;rewrite_by_lua_file의&lt;/a&gt; 현재 위치 내의 코드 시퀀스는 실행되지 않는다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="195b2b529191b33e53991a0c90b5cd5c9bdd0d08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive is used to change the URI and initiate location re-lookups (internal redirections), then any &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; or &lt;a href=&quot;#rewrite_by_lua_file&quot;&gt;rewrite_by_lua_file&lt;/a&gt; code sequences within the current location will not be executed. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fdab53986200d577625b93f4ba51c258927eea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer_size&lt;/code&gt; argument is specified, then its value will be used for the size of the memory buffer for body writing with &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;. If the argument is omitted, then the value specified by the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; directive will be used instead.</source>
          <target state="translated">경우] &lt;code&gt;buffer_size&lt;/code&gt; 인수가 지정되며, 그 값은 바디 기입하기위한 메모리 버퍼의 사이즈에 사용될 &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; . 인수가 생략되면 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; 지시문으로 지정된 값 이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e028e968df9e5a8cf99eb7746b37e805cf599f53" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer_size&lt;/code&gt; argument is specified, then its value will be used for the size of the memory buffer for body writing with &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;. If the argument is omitted, then the value specified by the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; directive will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ddceaa2265c38bb2f1c03973ee7b4ef7796a07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; argument already exists in the dictionary (and not expired for sure), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;exists&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;key&lt;/code&gt; 인수가 이미 사전에 존재하는 (그리고 확실히 만료)에 &lt;code&gt;success&lt;/code&gt; 반환 값이됩니다 &lt;code&gt;false&lt;/code&gt; 과 &lt;code&gt;err&lt;/code&gt; 반환 값이 될 것 &lt;code&gt;&quot;exists&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d363db88d3feab37e9126b2db9778728b54bae1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; argument does &lt;em&gt;not&lt;/em&gt; exist in the dictionary (or expired already), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;key&lt;/code&gt; 인수가 않습니다 &lt;em&gt;하지&lt;/em&gt; (또는 이미 만료) 사전에 존재의 &lt;code&gt;success&lt;/code&gt; 반환 값이됩니다 &lt;code&gt;false&lt;/code&gt; 과 &lt;code&gt;err&lt;/code&gt; 반환 값이 될 것 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a55d02bbbc8e5fba7b4193e0585e5299372dec63" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than &lt;code&gt;8192&lt;/code&gt;, then &lt;code&gt;8192&lt;/code&gt; will be used instead.</source>
          <target state="translated">상기 중간 &lt;code&gt;size&lt;/code&gt; 인수 지정된 크기 수신 버퍼로서,이 메소드는이 크기를 사용한다. 이 크기보다 큰 경우 그러나 &lt;code&gt;8192&lt;/code&gt; 후 &lt;code&gt;8192&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6238363d95a46a4c1f2816d246d0693b655148e6" translate="yes" xml:space="preserve">
          <source>If the Lua code explicitly sets a &lt;code&gt;Content-Length&lt;/code&gt; response header before sending the headers (either explicitly via &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or implicitly via the first &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; or &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</source>
          <target state="translated">Lua 코드가 헤더를 보내기 전에 ( &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; 를 통해 명시 적으로 또는 첫 번째 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; 또는 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 호출을 통해 암시 적으로) &lt;code&gt;Content-Length&lt;/code&gt; 응답 헤더를 명시 적으로 설정 하면 HTTP 1.0 응답 버퍼링이 비활성화 된 경우에도 비활성화됩니다. 지시문이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cb3127687c1005e26ecf791e808f7f643f73a3" translate="yes" xml:space="preserve">
          <source>If the argument value is &lt;code&gt;false&lt;/code&gt;, then the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">인수 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 효과는 &lt;code&gt;nil&lt;/code&gt; 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9b6f09e61b081cbbea6b29a4a58173f21294051c" translate="yes" xml:space="preserve">
          <source>If the current connection does not come from the built-in connection pool, then this method always returns &lt;code&gt;0&lt;/code&gt;, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.</source>
          <target state="translated">현재 연결이 내장 연결 풀에서 나오지 않으면이 메소드는 항상 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 . 즉, 연결이 재사용되지 않았습니다 (아직). 연결이 연결 풀에서 오는 경우 반환 값은 항상 0이 아닙니다. 따라서이 방법을 사용하여 현재 연결이 풀에서 온 것인지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22c6214b6890e522f9e10b060ae7a18d2a1c2af3" translate="yes" xml:space="preserve">
          <source>If the current location includes &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; directives, then the request body will be read just before the &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; code is run (and also at the &lt;code&gt;rewrite&lt;/code&gt; phase). Similarly, if only &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; is specified, the request body will not be read until the content handler's Lua code is about to run (i.e., the request body will be read during the content phase).</source>
          <target state="translated">현재 위치에 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 지시문이 포함 된 경우 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 코드가 실행 되기 직전 (및 &lt;code&gt;rewrite&lt;/code&gt; 단계에서) 요청 본문을 읽습니다 . 마찬가지로 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 만 지정하면 컨텐츠 핸들러의 Lua 코드가 실행될 때까지 요청 본문을 읽지 않습니다 (즉, 요청 본문을 컨텐츠 단계 중에 읽습니다).</target>
        </trans-unit>
        <trans-unit id="90a8db7ecd2a387c69e72d8b63de9464e33e6d21" translate="yes" xml:space="preserve">
          <source>If the current request is an Nginx subrequest, then the subrequest's method name will be returned.</source>
          <target state="translated">현재 요청이 Nginx 하위 요청 인 경우 하위 요청의 메소드 이름이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1d2bc47f1d70b793560dea0ab5b18dfc9a509348" translate="yes" xml:space="preserve">
          <source>If the current request is an Nginx subrequest, then the subrequest's method will be overridden.</source>
          <target state="translated">현재 요청이 Nginx 하위 요청 인 경우 하위 요청의 메소드가 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="389bee51266f11f959c19401f8517d13b4ec2d15" translate="yes" xml:space="preserve">
          <source>If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.</source>
          <target state="translated">현재 요청의 요청 본문을 읽지 않은 경우 올바르게 삭제됩니다. 현재 요청의 요청 본문을 메모리로 읽거나 디스크 파일로 버퍼링하면 이전 요청 본문의 메모리가 해제되거나 디스크 파일이 각각 즉시 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8075ac8b97eaf72670a104d032ac2af234a37b" translate="yes" xml:space="preserve">
          <source>If the key does not exist (or has already expired), this method will return &lt;code&gt;nil&lt;/code&gt; and the error string &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">키가 존재하지 않거나 이미 만료 된 경우이 메소드는 &lt;code&gt;nil&lt;/code&gt; 및 오류 문자열 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d0aa3ffd3930bc3f8c8298f3e8f6d91ab8402c96" translate="yes" xml:space="preserve">
          <source>If the key does not exist, this method will return &lt;code&gt;nil&lt;/code&gt; and the error string &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">키가 존재하지 않으면이 메소드는 &lt;code&gt;nil&lt;/code&gt; 및 오류 문자열 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="53d1584e9e515132cb0a50bece60b7082877307f" translate="yes" xml:space="preserve">
          <source>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</source>
          <target state="translated">이름 서버가 호스트 이름에 대해 여러 개의 IP 주소를 반환하면이 방법은 하나를 임의로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f1806418371b6bf35324e34770835effa4399e6c" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;auto_clean&lt;/code&gt; argument is given a &lt;code&gt;true&lt;/code&gt; value, then this file will be removed at request completion or the next time this function or &lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt; are called in the same request. The &lt;code&gt;auto_clean&lt;/code&gt; is default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;auto_clean&lt;/code&gt; 인수에 &lt;code&gt;true&lt;/code&gt; 값이 제공되면 요청이 완료되거나 &lt;a href=&quot;#ngxreqset_body_data&quot;&gt;다음에이&lt;/a&gt; 함수 또는 ngx.req.set_body_data 가 동일한 요청에서 호출 될 때이 파일이 제거됩니다 . &lt;code&gt;auto_clean&lt;/code&gt; 은 기본적입니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f843b5eb5551c8d5b0b6a364ae48099b903a876" translate="yes" xml:space="preserve">
          <source>If the original value is not a valid Lua number in the dictionary, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;not a number&quot;&lt;/code&gt;.</source>
          <target state="translated">원래 값이 사전에서 유효한 Lua 숫자가 아닌 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 하고 &lt;code&gt;&quot;not a number&quot;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="41cd58297b437ffe1b41752cc5797fa381384854" translate="yes" xml:space="preserve">
          <source>If the request body has already been explicitly discarded, either by the &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; function or other modules, this function does not run and returns immediately.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; 함수 나 다른 모듈에 의해 요청 본문이 이미 명시 적으로 삭제 된 경우이 함수는 실행되지 않고 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="008094ed8775cabe126ed59c6b85fe7fea9bd202" translate="yes" xml:space="preserve">
          <source>If the request body has already been read, this function does nothing and returns immediately.</source>
          <target state="translated">요청 본문을 이미 읽은 경우이 함수는 아무 작업도 수행하지 않고 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="080d7f425676880165858290513bc1fee0805a4a" translate="yes" xml:space="preserve">
          <source>If the request body has been read into disk files, try calling the &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt; function instead.</source>
          <target state="translated">요청 본문을 디스크 파일로 읽은 경우 대신 &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="70ed23cec5f5e4594e5266bd4b7c88ae67c0fee6" translate="yes" xml:space="preserve">
          <source>If the request body has been read into memory, try calling the &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt; function instead.</source>
          <target state="translated">요청 본문을 메모리로 읽은 경우 대신 &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="edf28929152836d41cbf327c9c32c942d0499fd1" translate="yes" xml:space="preserve">
          <source>If the request body has not been read yet, call &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; first (or turned on &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; to force this module to read the request body. This is not recommended however).</source>
          <target state="translated">요청 본문을 아직 읽지 않은 경우 &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body를&lt;/a&gt; 먼저 호출 하거나이 모듈이 요청 본문을 읽도록 &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; 를 설정하십시오 (그러나 권장되지는 않음).</target>
        </trans-unit>
        <trans-unit id="243f6d81ad0886073f9f6e7649f5a33edc435aed" translate="yes" xml:space="preserve">
          <source>If the request body is already read previously by turning on &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; or by using other modules, then this function does not run and returns immediately.</source>
          <target state="translated">&lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; 를 켜 거나 다른 모듈을 사용하여 요청 본문을 이미 읽은 경우이 함수가 실행되지 않고 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74498ce72b5020070467319d96628f81d1a50624" translate="yes" xml:space="preserve">
          <source>If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:</source>
          <target state="translated">그러나 표준 Lua 5.1 인터프리터가 필요한 경우 다음 명령을 실행하여 Ubuntu 저장소에서 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6b51b136869786e28e01758f4b32aa0c95de0467" translate="yes" xml:space="preserve">
          <source>If the user flags is &lt;code&gt;0&lt;/code&gt; (the default), then no flags value will be returned.</source>
          <target state="translated">사용자 플래그가 &lt;code&gt;0&lt;/code&gt; (기본값)이면 플래그 값이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53d587529d756db1aef53e849e4b4d97a387d2f8" translate="yes" xml:space="preserve">
          <source>If the value table is empty and the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">값 테이블이 비어 있고 효과가 &lt;code&gt;nil&lt;/code&gt; 값 과 동일한 경우</target>
        </trans-unit>
        <trans-unit id="cb6e47c07094c55368bff941d5a16f4932ecb094" translate="yes" xml:space="preserve">
          <source>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the &lt;code&gt;forcible&lt;/code&gt; return value will be &lt;code&gt;true&lt;/code&gt;. If it stores the item without forcibly removing other valid items, then the return value &lt;code&gt;forcible&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 아직 LRU를 통해 아직 만료되지 않은 다른 항목을 사전에서 제거하여 현재 항목을 저장하는 데 성공하면 &lt;code&gt;forcible&lt;/code&gt; 리턴 값은 &lt;code&gt;true&lt;/code&gt; 입니다. 그것은 강제로 다른 유효한 항목을 제거하지 않고 항목을 저장하는 경우, 반환 값의 &lt;code&gt;forcible&lt;/code&gt; 될 것입니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbf81d43a2561a052178a78b671cb486cb42a995" translate="yes" xml:space="preserve">
          <source>If you are not using the NGINX core shipped with &lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 or later, then you need to apply the following patch to the standard NGINX core 1.11.2 or later:</source>
          <target state="translated">&lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 이상 과 함께 제공된 NGINX 코어를 사용하지 않는 경우 표준 NGINX 코어 1.11.2 이상에 다음 패치를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="27fb3820ddb4d9d480e974c0e4e6536ea39bc288" translate="yes" xml:space="preserve">
          <source>If you are using OpenSSL libraries not provided by &lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt;, then you need to apply the following patch for OpenSSL 1.0.2h or later:</source>
          <target state="translated">&lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt; 에서 제공하지 않은 OpenSSL 라이브러리를 사용하는 경우 OpenSSL 1.0.2h 이상에 다음 패치를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="413302d3c499d48d75063214c7b670f193f771a0" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;http://openresty.org/en/linux-packages.html&quot;&gt;official pre-built packages&lt;/a&gt; for &lt;a href=&quot;https://openresty.org/&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 or later, then everything should work out of the box.</source>
          <target state="translated">&lt;a href=&quot;https://openresty.org/&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 이상의 &lt;a href=&quot;http://openresty.org/en/linux-packages.html&quot;&gt;공식 사전 빌드 패키지&lt;/a&gt; 를 사용하는 경우 모든 것이 즉시 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0069d9a0bcf3c8a161d910efd6bd83655f4f59c9" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;https://openresty.org/en/linux-packages.html&quot;&gt;official pre-built packages&lt;/a&gt; for &lt;a href=&quot;https://openresty.org/&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 or later, then everything should work out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d4ab64171ccd6fcfa24ef69863eb5f4231d67c" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;ngx.re.*&lt;/code&gt; implementation of &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; by loading the &lt;code&gt;resty.core.regex&lt;/code&gt; module (or just the &lt;code&gt;resty.core&lt;/code&gt; module), then an LRU cache is used for the regex cache being used here.</source>
          <target state="translated">&lt;code&gt;resty.core.regex&lt;/code&gt; 모듈 (또는 &lt;code&gt;resty.core&lt;/code&gt; 모듈) 을로드하여 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 의 &lt;code&gt;ngx.re.*&lt;/code&gt; 구현을 사용하는 경우 여기에서 사용되는 정규식 캐시에 LRU 캐시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f27497c767e134254218418d2eba69f16df5b04a" translate="yes" xml:space="preserve">
          <source>If you have just too many &lt;code&gt;.o&lt;/code&gt; files, then it might not be feasible to name them all in a single command. In this case, you can build a static library (or archive) for your &lt;code&gt;.o&lt;/code&gt; files, as in</source>
          <target state="translated">&lt;code&gt;.o&lt;/code&gt; 파일이 너무 많으면 단일 명령으로 파일 이름을 모두 지정하는 것이 불가능할 수 있습니다. 이 경우 &lt;code&gt;.o&lt;/code&gt; 파일에 대한 정적 라이브러리 (또는 아카이브)를 다음 과 같이 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f048479ab0021ca0341874e956da0fd566de45f" translate="yes" xml:space="preserve">
          <source>If you want to access the system environment variable, say, &lt;code&gt;foo&lt;/code&gt;, in Lua via the standard Lua API &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.getenv&quot;&gt;os.getenv&lt;/a&gt;, then you should also list this environment variable name in your &lt;code&gt;nginx.conf&lt;/code&gt; file via the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#env&quot;&gt;env directive&lt;/a&gt;. For example,</source>
          <target state="translated">표준 Lua API &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.getenv&quot;&gt;os.getenv&lt;/a&gt; 를 통해 Lua에서 시스템 환경 변수 (예 : &lt;code&gt;foo&lt;/code&gt; )에 액세스 하려면 &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#env&quot;&gt;env 지시문을&lt;/a&gt; 통해 &lt;code&gt;nginx.conf&lt;/code&gt; 파일 에이 환경 변수 이름을 나열해야 합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="874d54012593ea6ca8b981ab5fce40f47e132468" translate="yes" xml:space="preserve">
          <source>If you want to access the system environment variable, say, &lt;code&gt;foo&lt;/code&gt;, in Lua via the standard Lua API &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-os.getenv&quot;&gt;os.getenv&lt;/a&gt;, then you should also list this environment variable name in your &lt;code&gt;nginx.conf&lt;/code&gt; file via the &lt;a href=&quot;https://nginx.org/en/docs/ngx_core_module.html#env&quot;&gt;env directive&lt;/a&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3345fe0380d28ca31796be10a97afe321dd4927" translate="yes" xml:space="preserve">
          <source>If you want to use dot in the Lua module name when calling &lt;code&gt;require&lt;/code&gt;, as in</source>
          <target state="translated">다음 과 같이 &lt;code&gt;require&lt;/code&gt; 를 호출 할 때 Lua 모듈 이름에 도트를 사용 하려면</target>
        </trans-unit>
        <trans-unit id="a4d6b0ca63702450444cb702c9b56c73fe4d67b0" translate="yes" xml:space="preserve">
          <source>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the &lt;code&gt;vars&lt;/code&gt; option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</source>
          <target state="translated">위의 두 가지 설정 외에도 &lt;code&gt;vars&lt;/code&gt; 옵션을 사용하여 하위 요청의 변수 값을 지정할 수 있습니다. 이러한 변수는 변수의 공유 또는 복사가 평가 된 후에 설정되며, URL 인수로 인코딩하고 Nginx 구성 파일에서 이스케이프를 해제하는 것보다 특정 값을 하위 요청에 전달하는보다 효율적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d2ba848e28f8c57af8d105a0bc48a32b2b9b450" translate="yes" xml:space="preserve">
          <source>In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt; interface.</source>
          <target state="translated">또한이 지시어는 한 번에 하나의 Nginx 변수에만 값을 쓸 수 있습니다. 그러나 &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt; 인터페이스를 사용하여 해결 방법이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0968ba8d73bccfff8b9ca559c1f62f79a152c4" translate="yes" xml:space="preserve">
          <source>In case of any connection errors, this method always automatically closes the current connection.</source>
          <target state="translated">연결 오류가 발생하면이 방법은 항상 현재 연결을 자동으로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="311c4afeb45d698793bf7dc7ccc7ca9b2783980d" translate="yes" xml:space="preserve">
          <source>In case of error, &lt;code&gt;nil&lt;/code&gt; will be returned as well as a string describing the error.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7393a8162db596df32803dcb6345a6ac55c34a0b" translate="yes" xml:space="preserve">
          <source>In case of error, the iterator function will return &lt;code&gt;nil&lt;/code&gt; along with a string describing the error and the partial data bytes that have been read so far.</source>
          <target state="translated">에러의 경우, 반복자 함수는 에러를 설명하는 문자열과 지금까지 읽은 부분 데이터 바이트와 함께 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b0925789327ff6ba9c9418ce55d54b02e1c29600" translate="yes" xml:space="preserve">
          <source>In case of error, the method returns &lt;code&gt;nil&lt;/code&gt; followed by a string describing the error. In case of success, the method returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하면이 메서드는 &lt;code&gt;nil&lt;/code&gt; 을 반환하고 그 뒤에 오류를 설명하는 문자열이 반환 됩니다. 성공하면이 메서드는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2134316a504c9aca49cc29645047815fb404fa7" translate="yes" xml:space="preserve">
          <source>In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two &lt;code&gt;nil&lt;/code&gt; values followed by a string describing the error.</source>
          <target state="translated">잘못된 정규 표현식이나 PCRE 런타임 오류와 같은 오류의 경우이 API 함수는 두 개의 &lt;code&gt;nil&lt;/code&gt; 값과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1e76a49880543d9a2f3cfd64cc5b568bb19dea50" translate="yes" xml:space="preserve">
          <source>In case of errors, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6821a30dddcaffd6871e483b4247616b17dd93e2" translate="yes" xml:space="preserve">
          <source>In case of errors, like seeing an ill-formed regular expression, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">잘못된 형식의 정규식을 보는 것과 같이 오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 및 오류를 설명하는 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4141e5771983ca2351d0b1c34393a563d7181c" translate="yes" xml:space="preserve">
          <source>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception &lt;em&gt;or&lt;/em&gt; terminate the current request with a 500 status code immediately.</source>
          <target state="translated">데이터를 읽는 동안 연결 오류와 같은 오류가 발생하면이 메서드는 Lua 예외를 발생 &lt;em&gt;시키거나&lt;/em&gt; 500 상태 코드로 즉시 현재 요청을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0fe8c65efa85d898d964be287431d845c13e5813" translate="yes" xml:space="preserve">
          <source>In case of success, it returns &lt;code&gt;1&lt;/code&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">성공하면 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7742db78c2a593b5d719bcf5993594e82b9fbe46" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error and the partial data received so far.</source>
          <target state="translated">성공하면 수신 된 데이터를 반환합니다. 에러의 경우, 에러를 설명하는 문자열과 지금까지 수신 한 부분 데이터와 함께 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="218ee506c35c3bc4c45279ef98625a498d0cfc99" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error.</source>
          <target state="translated">성공하면 수신 된 데이터를 반환합니다. 오류가 발생 하면 오류를 설명하는 문자열과 함께 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d127ab022b361338f8c136b692b125e7c48c1cd8" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">성공하면 전송 된 총 바이트 수를 반환합니다. 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="38ce78a1746b2febc95c4da1a98a0d3f76ad1b67" translate="yes" xml:space="preserve">
          <source>In case of success, this method returns &lt;code&gt;1&lt;/code&gt;; otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">성공하면이 메소드는 &lt;code&gt;1&lt;/code&gt; 을 리턴합니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a7bce528c3904e1a460cb8fe08ff26a51f56807a" translate="yes" xml:space="preserve">
          <source>In cases where current request may have a request body and the request body data is not required, The &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</source>
          <target state="translated">현재 요청에 요청 본문이 있고 요청 본문 데이터가 필요하지 않은 경우 &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; 함수를 사용하여 HTTP 1.1 keepalive 또는 HTTP 1.1 파이프 라이닝에서 항목이 손상되지 않도록 요청 본문을 명시 적으로 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a73185e2f3a4040127d36d48b929d80df8bfaf2" translate="yes" xml:space="preserve">
          <source>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout&quot;&gt;send_timeout&lt;/a&gt; setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</source>
          <target state="translated">동기 모드에서는 모든 출력 데이터가 시스템 송신 버퍼에 기록되거나 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout&quot;&gt;send_timeout&lt;/a&gt; 설정이 만료 될 때까지 함수가 리턴되지 않습니다 . Lua 코 루틴 메커니즘을 사용하면이 기능이 동기 모드에서도 Nginx 이벤트 루프를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cee67f1067bfbb1d1b6fbc0b0dc39b62383885ef" translate="yes" xml:space="preserve">
          <source>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout&quot;&gt;send_timeout&lt;/a&gt; setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802426cce4f3045aa39317d15827a3ba9e7c29b0" translate="yes" xml:space="preserve">
          <source>Increments the (numerical) value for &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; by the step value &lt;code&gt;value&lt;/code&gt;. Returns the new resulting number if the operation is successfully completed or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; 의 (숫자) 값을 단계 값 &lt;code&gt;value&lt;/code&gt; 만큼 증가 시킵니다 . 반환 새로운 결과 작업이 성공적으로 완료되면 번호 또는 &lt;code&gt;nil&lt;/code&gt; 하고, 그렇지 않으면 오류 메시지.</target>
        </trans-unit>
        <trans-unit id="2fc2ad07eee1733026be591bbeedcad26b5b39bb" translate="yes" xml:space="preserve">
          <source>Inserts the specified (numerical or string) &lt;code&gt;value&lt;/code&gt; at the head of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns the number of elements in the list after the push operation.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; 라는 이름의 목록 헤드에 지정된 (숫자 또는 문자열) &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . 푸시 작업 후 목록의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="590b0cababa8662b5343717a1ba8909d9c98efc2" translate="yes" xml:space="preserve">
          <source>Install LuaJIT 2.0 or 2.1 (recommended) or Lua 5.1 (Lua 5.2 is &lt;em&gt;not&lt;/em&gt; supported yet). LuaJIT can be downloaded from the &lt;a href=&quot;http://luajit.org/download.html&quot;&gt;LuaJIT project website&lt;/a&gt; and Lua 5.1, from the &lt;a href=&quot;http://www.lua.org/&quot;&gt;Lua project website&lt;/a&gt;. Some distribution package managers also distribute LuaJIT and/or Lua.</source>
          <target state="translated">설치 LuaJIT 2.0 이상 (권장) 2.1 루아 5.1 (루아 5.2입니다 &lt;em&gt;하지&lt;/em&gt; 아직 지원). LuaJIT은에서 다운로드 할 수 있습니다 &lt;a href=&quot;http://luajit.org/download.html&quot;&gt;LuaJIT 프로젝트 웹 사이트&lt;/a&gt; 로부터, 루아 5.1 &lt;a href=&quot;http://www.lua.org/&quot;&gt;루아 프로젝트 웹 사이트&lt;/a&gt; . 일부 배포 패키지 관리자는 LuaJIT 및 / 또는 Lua도 배포합니다.</target>
        </trans-unit>
        <trans-unit id="c841f44436c78941c4d9eff3f25e70056a421dea" translate="yes" xml:space="preserve">
          <source>Install LuaJIT 2.0 or 2.1 (recommended) or Lua 5.1 (Lua 5.2 is &lt;em&gt;not&lt;/em&gt; supported yet). LuaJIT can be downloaded from the &lt;a href=&quot;https://luajit.org/download.html&quot;&gt;LuaJIT project website&lt;/a&gt; and Lua 5.1, from the &lt;a href=&quot;https://www.lua.org/&quot;&gt;Lua project website&lt;/a&gt;. Some distribution package managers also distribute LuaJIT and/or Lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="2cde7a2555a654be3a162ceea7abb83796dbd083" translate="yes" xml:space="preserve">
          <source>Installation on Ubuntu 11.10</source>
          <target state="translated">우분투 11.10에 설치</target>
        </trans-unit>
        <trans-unit id="73952aabeb57ac87f4bba98bee5c27606429ace4" translate="yes" xml:space="preserve">
          <source>Internal redirection will destroy the original request &lt;code&gt;ngx.ctx&lt;/code&gt; data (if any) and the new request will have an empty &lt;code&gt;ngx.ctx&lt;/code&gt; table. For instance,</source>
          <target state="translated">내부 리디렉션은 원래 요청 &lt;code&gt;ngx.ctx&lt;/code&gt; 데이터 (있는 경우)를 삭제하고 새 요청에는 빈 &lt;code&gt;ngx.ctx&lt;/code&gt; 테이블이 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="4dce3d43238a392c1241cdb3c7a5962b78297cc2" translate="yes" xml:space="preserve">
          <source>Introduction to ngx_lua</source>
          <target state="translated">ngx_lua 소개</target>
        </trans-unit>
        <trans-unit id="5b1afcf1dbf33195a09d5aafc7fa07255aa44bbb" translate="yes" xml:space="preserve">
          <source>Issue an &lt;code&gt;HTTP 301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; redirection to &lt;code&gt;uri&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 로 &lt;code&gt;HTTP 301&lt;/code&gt; 또는 &lt;code&gt;302&lt;/code&gt; 리디렉션을 발행하십시오 .</target>
        </trans-unit>
        <trans-unit id="91ce8a01d926166c5706fe0776bc2a11b40147e2" translate="yes" xml:space="preserve">
          <source>Issues a synchronous but still non-blocking &lt;em&gt;Nginx Subrequest&lt;/em&gt; using &lt;code&gt;uri&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 를 사용하여 동 기적이지만 여전히 블로킹되지 않는 &lt;em&gt;Nginx 하위 요청&lt;/em&gt; 을 &lt;em&gt;발행&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0760872ba23d0cde13af33b5304ba1d4cae4fe3c" translate="yes" xml:space="preserve">
          <source>Issuing a POST subrequest, for example, can be done as follows</source>
          <target state="translated">예를 들어 POST 하위 요청을 발행하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afc974545a490e483360ca2134cd7b6c71270ae0" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) by default.</source>
          <target state="translated">그것은이다 &lt;code&gt;302&lt;/code&gt; ( &lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt; 기본적으로).</target>
        </trans-unit>
        <trans-unit id="4980218dbb51a70cacc02d4763a046d96c95cdfb" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;highly&lt;/em&gt; recommended to use &lt;a href=&quot;http://openresty.org&quot;&gt;OpenResty releases&lt;/a&gt; which integrate Nginx, ngx_lua, LuaJIT 2.1, as well as other powerful companion Nginx modules and Lua libraries. It is discouraged to build this module with nginx yourself since it is tricky to set up exactly right. Also, the stock nginx cores have various limitations and long standing bugs that can make some of this modules' features become disabled, not work properly, or run slower. The same applies to LuaJIT as well. OpenResty includes its own version of LuaJIT which gets specifically optimized and enhanced for the OpenResty environment.</source>
          <target state="translated">되어 &lt;em&gt;매우&lt;/em&gt; 사용하는 것이 좋습니다 &lt;a href=&quot;http://openresty.org&quot;&gt;OpenResty 출시&lt;/a&gt; Nginx에, ngx_lua, LuaJIT 2.1을 통합뿐만 아니라 다른 강력한 동반자 Nginx의 모듈 및 루아 라이브러리를. 정확하게 설정하기가 까다롭기 때문에 nginx 로이 모듈을 직접 작성하지 않는 것이 좋습니다. 또한, 주식 nginx 코어에는 다양한 제한 사항과 오랜 버그가 있어이 모듈의 기능 중 일부가 비활성화되거나 올바르게 작동하지 않거나 느리게 실행될 수 있습니다. LuaJIT도 마찬가지입니다. OpenResty에는 OpenResty 환경에 맞게 특별히 최적화되고 향상된 LuaJIT 자체 버전이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84af29f7e1a02a9705188628a1572247ba9bb84" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;highly&lt;/em&gt; recommended to use &lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty releases&lt;/a&gt; which integrate Nginx, ngx_lua, LuaJIT 2.1, as well as other powerful companion Nginx modules and Lua libraries. It is discouraged to build this module with nginx yourself since it is tricky to set up exactly right. Also, the stock nginx cores have various limitations and long standing bugs that can make some of this modules' features become disabled, not work properly, or run slower. The same applies to LuaJIT as well. OpenResty includes its own version of LuaJIT which gets specifically optimized and enhanced for the OpenResty environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182b3d046d25f95d8271b373f8b64c013f197a36" translate="yes" xml:space="preserve">
          <source>It is also possible to directly require the packages in external Lua modules:</source>
          <target state="translated">외부 Lua 모듈에 패키지를 직접 요구할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea33926547830174fc18b5c412ab6934e6d74ce1" translate="yes" xml:space="preserve">
          <source>It is also possible to use this &lt;code&gt;ctx&lt;/code&gt; option to share the same &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table between the current (parent) request and the subrequest:</source>
          <target state="translated">이 &lt;code&gt;ctx&lt;/code&gt; 옵션 을 사용 하여 현재 (부모) 요청과 하위 요청간에 동일한 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; 테이블 을 공유 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26cb0deebc5382597abfb9cef263ffa1378ccce5" translate="yes" xml:space="preserve">
          <source>It is equivalent to</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="82da831557ca01d8af65fa32b24d5cef10269f05" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed65ff252528d5d5a0ee3292105232c05ec7e35" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling the iterator function (note that the &lt;code&gt;receiveuntil&lt;/code&gt; call is irrelevant here).</source>
          <target state="translated">전화를 여기서 중요한 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;의 setTimeout&lt;/a&gt; 방법을 &lt;em&gt;전&lt;/em&gt; 합니다 (참고 반복자 함수를 호출 &lt;code&gt;receiveuntil&lt;/code&gt; 전화가 여기에 무관하다).</target>
        </trans-unit>
        <trans-unit id="9747f557e27f2eeadb0651c707b695837e6bc2f3" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling this method.</source>
          <target state="translated">이 메소드 &lt;em&gt;를&lt;/em&gt; 호출 &lt;em&gt;하기 전에 &lt;/em&gt;&lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 메소드 를 호출하는 것이 중요합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98d87dbeb06eca884ff458d86f3dfea33440e5c1" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#udpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling this method.</source>
          <target state="translated">이 메소드 &lt;em&gt;를&lt;/em&gt; 호출 &lt;em&gt;하기 전에 &lt;/em&gt;&lt;a href=&quot;#udpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 메소드 를 호출하는 것이 중요합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9be5000189cee7a41f7d06b037f34d000ee14673" translate="yes" xml:space="preserve">
          <source>It is important to always call the &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; after all the data has been appended onto the current request body.</source>
          <target state="translated">모든 데이터가 현재 요청 본문에 추가 된 후에 는 항상 &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body를&lt;/a&gt; 호출하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="eb343e80808a2e43fa0534dd1e7f387ed22bed82" translate="yes" xml:space="preserve">
          <source>It is important to always call the &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; after all the data has been appended onto the current request body. Also, when this function is used together with &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;, it is required to call &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;&lt;em&gt;before&lt;/em&gt; this function, or you will get the &quot;request body already exists&quot; error message.</source>
          <target state="translated">모든 데이터가 현재 요청 본문에 추가 된 후에 는 항상 &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body를&lt;/a&gt; 호출하는 것이 중요합니다 . 또한이 함수를 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 과 함께 사용하는 경우이 함수 &lt;em&gt;전에 &lt;/em&gt;&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 을 호출 &lt;em&gt;해야&lt;/em&gt; 합니다. 그렇지 않으면 &quot;요청 본문이 이미 있습니다&quot;오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="831a93a9266cbbd5c64b1570abbd0b8ed8dbf185" translate="yes" xml:space="preserve">
          <source>It is important to use exactly the same version of LuaJIT when compiling &lt;code&gt;.lua&lt;/code&gt; files to &lt;code&gt;.o&lt;/code&gt; files as building nginx + ngx_lua. This is because the LuaJIT bytecode format may be incompatible between different LuaJIT versions. When the bytecode format is incompatible, you will see a Lua runtime error saying that the Lua module is not found.</source>
          <target state="translated">nginx + ngx_lua를 빌드 할 때 &lt;code&gt;.lua&lt;/code&gt; 파일을 &lt;code&gt;.o&lt;/code&gt; 파일로 컴파일 할 때 정확히 동일한 버전의 LuaJIT를 사용해야 합니다 . LuaJIT 바이트 코드 형식이 다른 LuaJIT 버전간에 호환되지 않을 수 있기 때문입니다. 바이트 코드 형식이 호환되지 않으면 Lua 모듈을 찾을 수 없다는 Lua 런타임 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdeb4bb34c25239880d1f550257b58c8335625e" translate="yes" xml:space="preserve">
          <source>It is intended to be compatible with the TCP API of the &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt;LuaSocket&lt;/a&gt; library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.</source>
          <target state="translated">&lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt;LuaSocket&lt;/a&gt; 라이브러리 의 TCP API와 호환되도록 설계 되었지만 100 % 비 차단 적입니다. 또한 더 많은 기능을 제공하는 몇 가지 새로운 API를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="392c1c7a70ba0e823bfe21f074df2e0a8645d048" translate="yes" xml:space="preserve">
          <source>It is intended to be compatible with the UDP API of the &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/udp.html&quot;&gt;LuaSocket&lt;/a&gt; library but is 100% nonblocking out of the box.</source>
          <target state="translated">&lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/udp.html&quot;&gt;LuaSocket&lt;/a&gt; 라이브러리 의 UDP API와 호환되도록 설계 되었지만 기본적 으로 100 % 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f45e79b4c09d0ee14cdf200b012847db6d0932b1" translate="yes" xml:space="preserve">
          <source>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosocket&lt;/a&gt; API). And one can also do per-request OCSP stapling handling in pure Lua here as well.</source>
          <target state="translated">SSL 인증서 체인과 해당 개인 키를 요청별로 설정하는 데 특히 유용합니다. 원격에서 이러한 핸드 셰이크 구성을 &lt;a href=&quot;#ngxsockettcp&quot;&gt;비차 단적으로&lt;/a&gt; 로드하는 것도 유용합니다 (예 : 코 소켓 API 사용). 또한 순수 Lua에서도 요청 당 OCSP 스테이플 링 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc0b2e52141616964fdb445ff870fd2fd41fc1b" translate="yes" xml:space="preserve">
          <source>It is recommended however, to use the &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; functions for finer control over the request body reading process instead.</source>
          <target state="translated">그러나 요청 본문 읽기 프로세스를보다 세밀하게 제어 하려면 &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="271a83c7208d1b70559136d61431826dfba3afd3" translate="yes" xml:space="preserve">
          <source>It is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.exec(...)&lt;/code&gt; be adopted when this method call is used in contexts other than &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt; to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">이 메소드 호출을 &lt;code&gt;return&lt;/code&gt; 문과 결합하는 코딩 스타일 &lt;code&gt;return ngx.exec(...)&lt;/code&gt; 예 : return ngx.exec (...))을 사용 하여 요청 처리의 사실을 강화하기 위해 &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt; 이외의 컨텍스트에서이 메소드 호출을 사용할 때 채택하는 것이 좋습니다. 종료 중입니다.</target>
        </trans-unit>
        <trans-unit id="46536b06dafcf43a3332b8c34efe513e8a9f6966" translate="yes" xml:space="preserve">
          <source>It is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.redirect(...)&lt;/code&gt; be adopted when this method call is used in contexts other than &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt; to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">이 메소드 호출을 &lt;code&gt;return&lt;/code&gt; 문과 결합하는 코딩 스타일 &lt;code&gt;return ngx.redirect(...)&lt;/code&gt; 예 : return ngx.redirect (...))을 사용 하여 요청 처리의 사실을 강화하기 위해 &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt; 이외의 컨텍스트에서이 메소드 호출을 사용할 때 채택하는 것이 좋습니다. 종료 중입니다.</target>
        </trans-unit>
        <trans-unit id="1cfd652745464233964e6dbe816a6658c1decc26" translate="yes" xml:space="preserve">
          <source>It is recommended, however, to use the &lt;a href=&quot;#ngxtimerevery&quot;&gt;ngx.timer.every&lt;/a&gt; API function instead for creating recurring timers since it is more robust.</source>
          <target state="translated">그러나 &lt;a href=&quot;#ngxtimerevery&quot;&gt;ngx.timer.every&lt;/a&gt; API 함수 를 사용하는 것이 더 강력하기 때문에 반복 타이머를 만드는 대신 ngx.timer.every API 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d4b48ac00161f1a8ce8bce14130fe772170862b4" translate="yes" xml:space="preserve">
          <source>It is therefore &lt;em&gt;highly&lt;/em&gt; recommended to always declare such within an appropriate local scope instead.</source>
          <target state="translated">따라서 항상 대신 적절한 지역 범위 내에서 선언 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a146a425155dd2f1668bfb8dfa2d9ace4014d015" translate="yes" xml:space="preserve">
          <source>It is usually recommended to share read-only data this way. You can also share changeable data among all the concurrent requests of each nginx worker process as long as there is &lt;em&gt;no&lt;/em&gt; nonblocking I/O operations (including &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;) in the middle of your calculations. As long as you do not give the control back to the nginx event loop and ngx_lua's light thread scheduler (even implicitly), there can never be any race conditions in between. For this reason, always be very careful when you want to share changeable data on the worker level. Buggy optimizations can easily lead to hard-to-debug race conditions under load.</source>
          <target state="translated">일반적으로이 방법으로 읽기 전용 데이터를 공유하는 것이 좋습니다. 계산 중에 비 차단 I / O 작업 ( &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; 포함 ) 이 &lt;em&gt;없는 한&lt;/em&gt; 각 nginx 작업자 프로세스의 모든 동시 요청간에 변경 가능한 데이터를 공유 할 수도 있습니다 . nginx 이벤트 루프와 ngx_lua의 가벼운 스레드 스케줄러에 제어를 다시 제공하지 않는 한 (암시 적으로도) 그 사이에 경쟁 조건이있을 수 없습니다. 따라서 작업자 수준에서 변경 가능한 데이터를 공유하려는 경우 항상 매우주의하십시오. 버기 최적화는로드 상태에서 디버그하기 어려운 경쟁 조건으로 쉽게 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16406cede08a97c4ef51e625cc1932ecc9368323" translate="yes" xml:space="preserve">
          <source>It is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the &lt;code&gt;./configure&lt;/code&gt; option &lt;code&gt;--with-debug&lt;/code&gt;. And enabling debugging logs is strongly discouraged in production builds due to high overhead.</source>
          <target state="translated">&lt;code&gt;./configure&lt;/code&gt; 옵션 &lt;code&gt;--with-debug&lt;/code&gt; 로 OpenResty 또는 NGINX를 빌드하지 않고 디버깅 로그를 캡처 할 수있는 방법이 없다는 점은 주목할 가치가 있습니다. 또한 오버 헤드가 높아 프로덕션 빌드에서는 디버깅 로그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="caba899dc7d941617513a9ffa8c28f13127e69b3" translate="yes" xml:space="preserve">
          <source>It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">공유 메모리 영역의 스토리지가 부족할 때 상점에서 만료되지 않은 (최근에 사용한) 항목을 대체하지 않습니다. 이 경우 즉시 &lt;code&gt;nil&lt;/code&gt; 과 문자열 &quot;no memory&quot;를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="abd2c9284683a341513f7145950e2da46ebf49db" translate="yes" xml:space="preserve">
          <source>Just an alias to &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;. If the stream-typed cosocket may also connect to a unix domain socket, then this API name is preferred.</source>
          <target state="translated">&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; 의 별칭 입니다. 스트림 유형 코 소켓이 유닉스 도메인 소켓에 연결될 수 있으면이 API 이름이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c885172911e8a34f2d9bb7b542fd8f94a013a962" translate="yes" xml:space="preserve">
          <source>Just as &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; but also emit a trailing newline.</source>
          <target state="translated">&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 와 마찬가지로 후행 줄 바꿈을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dad4e3c58c739716522706aa61d6008291203ebd" translate="yes" xml:space="preserve">
          <source>Just as any other rewrite phase handlers, &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; also runs in subrequests.</source>
          <target state="translated">다른 재 작성 단계 처리기와 마찬가지로 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 도 하위 요청에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5dec50ed5fba57c0c048b75bed03e02c0ec53065" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, but supports multiple subrequests running in parallel.</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 와 마찬가지로 병렬로 실행되는 여러 하위 요청을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="30330751c517ec0c78031f290391df8628d2b9b0" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;, but does global substitution.</source>
          <target state="translated">&lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt; 와 동일 하지만 전역 대체를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fdcab698e53e300d46deb56ea934f502da8f9b33" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but only stores the key-value pair into the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; if the key &lt;em&gt;does&lt;/em&gt; exist.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; 메소드 와 마찬가지로 키 &lt;em&gt;가&lt;/em&gt; 존재하는 경우 키-값 쌍만 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT에&lt;/a&gt; 저장 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="208d172e22547ea6e5aeed2c6c4048d80cf6fb7f" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but only stores the key-value pair into the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; if the key does &lt;em&gt;not&lt;/em&gt; exist.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; 메소드 와 마찬가지로 키가 &lt;em&gt;없으면&lt;/em&gt; 키-값 쌍만 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT에&lt;/a&gt; 저장 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46a9daf8b26cf767246d05313a9e4defbe39056f" translate="yes" xml:space="preserve">
          <source>Just to name a few:</source>
          <target state="translated">몇가지 말하자면:</target>
        </trans-unit>
        <trans-unit id="7477a64f443c7e43a1cbca4c5ae06e44734b4be7" translate="yes" xml:space="preserve">
          <source>Keys and values are unescaped according to URI escaping rules. In the settings above, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; will yield:</source>
          <target state="translated">URI 이스케이프 규칙에 따라 키와 값이 이스케이프 처리되지 않습니다. 위의 설정에서 &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; 는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="787c0b6e20b6e8a04cba597e45d7f65b3384a7e4" translate="yes" xml:space="preserve">
          <source>Keys and values will be unescaped according to URI escaping rules.</source>
          <target state="translated">URI 이스케이프 규칙에 따라 키와 값이 이스케이프 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f191bcbd3d4b3d0a53fe1f096b1b92a3bb6d7ce" translate="yes" xml:space="preserve">
          <source>Kills a running &quot;light thread&quot; created by &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;. Returns a true value when successful or &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn에&lt;/a&gt; 의해 생성 된 &quot;가벼운 스레드&quot;를 종료 합니다. 성공 또는 &lt;code&gt;nil&lt;/code&gt; 일 경우 true 값 을, 그렇지 않으면 오류를 설명하는 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="9c0c0eecbdf8b8609b462711b4681e4c821d7607" translate="yes" xml:space="preserve">
          <source>Let us test it:</source>
          <target state="translated">테스트 해 보자.</target>
        </trans-unit>
        <trans-unit id="4da26479770dfe12cd77c3a29e0d80eb1fb85bb5" translate="yes" xml:space="preserve">
          <source>Library name &lt;code&gt;liblua.so&lt;/code&gt; has been changed in liblua5.1 package, it only comes with &lt;code&gt;liblua5.1.so&lt;/code&gt;, which needs to be symlinked to &lt;code&gt;/usr/lib&lt;/code&gt; so it could be found during the configuration process.</source>
          <target state="translated">도서관 이름 &lt;code&gt;liblua.so&lt;/code&gt; liblua5.1 패키지로 변경되었습니다, 그것은 단지와 함께 제공 &lt;code&gt;liblua5.1.so&lt;/code&gt; 할 필요가 심볼릭 링크로 &lt;code&gt;/usr/lib&lt;/code&gt; 가 구성 과정에서 볼 수 있도록.</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSD 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="66b752ee483f366c956fca803594910b1246a48f" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; method, it also overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; 메소드 와 마찬가지로 공유 메모리 영역의 스토리지가 부족할 때 상점에서 (최근에 사용 된) 만료되지 않은 항목을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="19a1d43944747a80761f7b71a7248d3bad465a35" translate="yes" xml:space="preserve">
          <source>Likewise, new &quot;eof&quot; flag can also be specified by setting a boolean value to &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt;[2]. For example,</source>
          <target state="translated">마찬가지로 부울 값을 &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt; [2] 로 설정하여 새 &quot;eof&quot;플래그를 지정할 수도 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="62af63e4d50059ec446993ac54d11cb7137d41e2" translate="yes" xml:space="preserve">
          <source>Literal dollar sign characters (&lt;code&gt;$&lt;/code&gt;) in the &lt;code&gt;replace&lt;/code&gt; string argument can be escaped by another dollar sign, for instance,</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 문자열 인수의 리터럴 달러 기호 문자 ( &lt;code&gt;$&lt;/code&gt; )는 다른 달러 기호로 이스케이프 할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="50116a0653683b8c0e1ea1052615ecf727848962" translate="yes" xml:space="preserve">
          <source>Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.</source>
          <target state="translated">로드 된 Lua 모듈은 nginx 작업자 프로세스 수준에서 유지되므로로드가 많은 경우에도 Lua의 메모리 사용량이 적습니다.</target>
        </trans-unit>
        <trans-unit id="32da440e124def30c99af4c314587020578f50c2" translate="yes" xml:space="preserve">
          <source>Loading bytecode files via the Lua primitives like &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;dofile&lt;/code&gt; should always work as expected.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;dofile&lt;/code&gt; 과 같은 Lua 프리미티브를 통해 바이트 코드 파일을로드 하면 항상 예상대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3b51e0cda2aacfcfca4096cfa8d50ae4d02f9e9" translate="yes" xml:space="preserve">
          <source>Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the &lt;code&gt;jump&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt; or absent altogether.</source>
          <target state="translated">그렇지 않으면 위치 이동이 트리거되지 않으며 현재 요청의 URI 만 수정되며 이는 기본 동작이기도합니다. 이 함수는 &lt;code&gt;jump&lt;/code&gt; 인수가 &lt;code&gt;false&lt;/code&gt; 이거나 모두 없을 때 반환 된 값없이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="fda8d60fb2838d1c5982f5cf20041deaa96b0093" translate="yes" xml:space="preserve">
          <source>Locations Configured by Subrequest Directives of Other Modules</source>
          <target state="translated">다른 모듈의 하위 요청 지시문으로 구성된 위치</target>
        </trans-unit>
        <trans-unit id="703509601a9cf02923c4011f7de08efd66a2ee1f" translate="yes" xml:space="preserve">
          <source>Log arguments concatenated to error.log with the given logging level.</source>
          <target state="translated">주어진 로깅 레벨을 가진 log.log에 연결된 로그 인수.</target>
        </trans-unit>
        <trans-unit id="e0b2ee17ddb47b55f2f15406fd718bcfbf2c67bf" translate="yes" xml:space="preserve">
          <source>Logging APIs: &lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt; and &lt;a href=&quot;#print&quot;&gt;print&lt;/a&gt;,</source>
          <target state="translated">API를 로깅 : &lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt; 및 &lt;a href=&quot;#print&quot;&gt;인쇄&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="62970aa98bcedc00e3c3d93365f65032997c5d59" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; string while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; string outputs. And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 인수가 허용되고 리터럴 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 문자열이 발생하는 반면 Lua booleans는 리터럴 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 문자열 출력이됩니다. 그리고 &lt;code&gt;ngx.null&lt;/code&gt; 상수는 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 문자열 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67078b84e84353b0e7692388c85577550cb18243" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; strings. And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 인수는 허용되며 리터럴 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 문자열이되지만 Lua 부울은 리터럴 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 문자열이됩니다. 그리고 &lt;code&gt;ngx.null&lt;/code&gt; 상수는 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 문자열 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8a1a9f38e0a87f169c792988f824847e1f230d2e" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; values will output &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings and Lua boolean values will output &lt;code&gt;&quot;true&quot;&lt;/code&gt; and &lt;code&gt;&quot;false&quot;&lt;/code&gt; literal strings respectively.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 값은 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 문자열을 출력 하고 Lua 부울 값은 각각 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 리터럴 문자열 을 출력 합니다 .</target>
        </trans-unit>
        <trans-unit id="5be9d100b21ac9e5ad3be58666a59cb29059ad31" translate="yes" xml:space="preserve">
          <source>Lua APIs that may yield, like &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; and &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;, are &lt;em&gt;disabled&lt;/em&gt; in this context. You can still, however, use the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API to create 0-delay timers to save the SSL session data asynchronously to external services (like &lt;code&gt;redis&lt;/code&gt; or &lt;code&gt;memcached&lt;/code&gt;).</source>
          <target state="translated">같이 얻을 수 루아 API를 &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; 및 &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets은&lt;/a&gt; ,하는 &lt;em&gt;비활성화&lt;/em&gt; 이러한 맥락에서. 그러나 &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API를 사용하여 0 지연 타이머를 만들어 SSL 세션 데이터를 외부 서비스 (예 : &lt;code&gt;redis&lt;/code&gt; 또는 &lt;code&gt;memcached&lt;/code&gt; )에 비동기 적으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b270537918fe3aefea5a6943042ccf7e5d6576ca" translate="yes" xml:space="preserve">
          <source>Lua APIs that may yield, like &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; and &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;, are enabled in this context.</source>
          <target state="translated">&lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; 및 &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt; 와 같이 생성 할 수있는 Lua API 는이 컨텍스트에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="16ec669f47cb0d73aa2c12fd87ac3f87572c77ac" translate="yes" xml:space="preserve">
          <source>Lua Coroutine Yielding/Resuming</source>
          <target state="translated">루아 코 루틴 수율 / 재개</target>
        </trans-unit>
        <trans-unit id="81be7ce438613a3e191edba2c0d0599ee9eb054c" translate="yes" xml:space="preserve">
          <source>Lua Variable Scope</source>
          <target state="translated">루아 변수 범위</target>
        </trans-unit>
        <trans-unit id="e239727dc78b43ea15c5eea7446c445e7d0cdde7" translate="yes" xml:space="preserve">
          <source>Lua global variables require Lua table look-ups in the global environment which is computationally expensive, and</source>
          <target state="translated">Lua 전역 변수에는 계산 상 비싼 글로벌 환경에서 Lua 테이블 조회가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="286a435a10004ebd882bdfc7a438ddce793d606e" translate="yes" xml:space="preserve">
          <source>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</source>
          <target state="translated">Lua 테이블은 발행 할 서브 요청의 수가 미리 알려지지 않은 경우 요청과 응답 모두에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aecdc7f39461eecbcde3605cc25e0fe71f75fa30" translate="yes" xml:space="preserve">
          <source>Lua/LuaJIT bytecode support</source>
          <target state="translated">Lua / LuaJIT 바이트 코드 지원</target>
        </trans-unit>
        <trans-unit id="0a73d1d05563574cdd9ff18b0b15597fe3f10c4a" translate="yes" xml:space="preserve">
          <source>Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,</source>
          <target state="translated">Lua의 다양한 nginx 업스트림 출력 (프록시, 이슬비, postgres, redis, memcached 등)의 매쉬업 및 처리 출력</target>
        </trans-unit>
        <trans-unit id="2162b9943b7dc9b3ffa9618b2fb845143de0408f" translate="yes" xml:space="preserve">
          <source>Matches the &lt;code&gt;subject&lt;/code&gt; string using the Perl compatible regular expression &lt;code&gt;regex&lt;/code&gt; with the optional &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">일치하는 &lt;code&gt;subject&lt;/code&gt; 펄 호환 정규 표현식 사용 문자열 &lt;code&gt;regex&lt;/code&gt; 옵션과 &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2c32444cd5e0e45ed666bc5343b57e8c606391" translate="yes" xml:space="preserve">
          <source>Missing data on short circuited requests</source>
          <target state="translated">단락 된 요청에서 누락 된 데이터</target>
        </trans-unit>
        <trans-unit id="314067c9b9abc3268632b142ade808b25762775d" translate="yes" xml:space="preserve">
          <source>Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.</source>
          <target state="translated">동일한 Nginx 요청에서 SSI를 ngx_lua와 혼합하는 것은 전혀 지원되지 않습니다. ngx_lua를 독점적으로 사용하십시오. SSI로 할 수있는 모든 작업은 ngx_lua 위에서 수행 할 수 있으며 ngx_lua를 사용할 때 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566a0866953c9cddc989560c5d345ce6531f7d08" translate="yes" xml:space="preserve">
          <source>Mixing with SSI Not Supported</source>
          <target state="translated">지원되지 않는 SSI와 혼합</target>
        </trans-unit>
        <trans-unit id="c238a082f51e69752f561d49c312243da839a0ec" translate="yes" xml:space="preserve">
          <source>More Nginx APIs for Lua may be supported in this context upon future user requests.</source>
          <target state="translated">향후 사용자 요청시이 컨텍스트에서 Lua 용 더 많은 Nginx API가 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ddc3c92f0eba23a04309fc859c257c19673cfb8" translate="yes" xml:space="preserve">
          <source>More often we just put it into a Lua loop:</source>
          <target state="translated">더 자주 우리는 그것을 Lua 루프에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="e0e944fbcb6eb23af4ead2148e02e0e2c1695714" translate="yes" xml:space="preserve">
          <source>Multi-value arguments are also supported:</source>
          <target state="translated">다중 값 인수도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="761e950673c01398f954cd38f95ae8c0a505a249" translate="yes" xml:space="preserve">
          <source>Multi-value headers can be set this way:</source>
          <target state="translated">다중 값 헤더는 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6ffce17d2ad4b08e9301597531afaa98399d5c" translate="yes" xml:space="preserve">
          <source>Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:</source>
          <target state="translated">다중 값 쿼리 인수도 지원됩니다. 인수 값으로 Lua 테이블을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c49929b484ac09004059a5befdbfef8a976e9b4" translate="yes" xml:space="preserve">
          <source>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</source>
          <target state="translated">인수 키가 여러 번 발생하면 해당 키의 모든 값을 순서대로 보유하는 테이블 값이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c57ca820ec571b3f6f7283896edc3a2e96c75d" translate="yes" xml:space="preserve">
          <source>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</source>
          <target state="translated">인수 키가 여러 번 발생하면 해당 키의 모든 값을 순서대로 보유하는 테이블 값이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="81492ccffc0c23f6f157946685e7833258341724" translate="yes" xml:space="preserve">
          <source>Named captures are also supported since the &lt;code&gt;v0.7.14&lt;/code&gt; release and are returned in the same Lua table as key-value pairs as the numbered captures.</source>
          <target state="translated">&lt;code&gt;v0.7.14&lt;/code&gt; 릴리스 이후에도 명명 된 캡처가 지원 되며 번호가 지정된 캡처와 키-값 쌍과 동일한 Lua 테이블에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="62de1a443da7c8e663e63ccebadf81592d861745" translate="yes" xml:space="preserve">
          <source>Named locations are also supported but the second &lt;code&gt;args&lt;/code&gt; argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).</source>
          <target state="translated">명명 된 위치도 지원되지만 존재하는 경우 두 번째 &lt;code&gt;args&lt;/code&gt; 인수는 무시되고 새 대상의 쿼리 문자열이 참조 위치 (있는 경우)에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="94c3812059e329f482def2ab66bae02b3d4467e1" translate="yes" xml:space="preserve">
          <source>Named locations like &lt;code&gt;@foo&lt;/code&gt; are not allowed due to a limitation in the nginx core. Use normal locations combined with the &lt;code&gt;internal&lt;/code&gt; directive to prepare internal-only locations.</source>
          <target state="translated">&lt;code&gt;@foo&lt;/code&gt; 과 같은 이름이 지정된 위치 는 nginx 코어의 제한으로 인해 허용되지 않습니다. &lt;code&gt;internal&lt;/code&gt; 지시문 과 결합 된 일반 위치를 사용하여 내부 전용 위치를 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="670d65a340c943c43ab1ba03ab60f2b91b18fa01" translate="yes" xml:space="preserve">
          <source>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</source>
          <target state="translated">문자열의 중첩 배열이 허용되며 배열의 요소가 하나씩 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="645ac1cdcc687fb8ac947381b144262dcb18101b" translate="yes" xml:space="preserve">
          <source>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua &lt;code&gt;io&lt;/code&gt; library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; method and similar) is strongly recommended for maximum performance.</source>
          <target state="translated">Nginx 이벤트 루프가 차단되고 그렇지 않으면 성능이 크게 저하 될 수 있으므로 사용자 코드의 네트워크 I / O 작업은 Nginx Lua API 호출을 통해서만 수행해야합니다. 표준 Lua &lt;code&gt;io&lt;/code&gt; 라이브러리를 사용하여 상대적으로 적은 양의 데이터를 사용하는 디스크 작업을 수행 할 수 있지만 Nginx 프로세스를 크게 차단할 수 있으므로 가능한 한 큰 파일 읽기 및 쓰기를 피해야합니다. 최대 성능을 위해서는 모든 네트워크 및 디스크 I / O 작업을 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 방법을 통해 Nginx의 하위 요청에 위임 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff87d2b81b31ddc05f55235bd37ea427809edf09" translate="yes" xml:space="preserve">
          <source>Nginx API for Lua</source>
          <target state="translated">Lua 용 Nginx API</target>
        </trans-unit>
        <trans-unit id="18bf38898491eb7a8dc300b724c0146a117e0ecc" translate="yes" xml:space="preserve">
          <source>Nginx Compatibility</source>
          <target state="translated">Nginx 호환성</target>
        </trans-unit>
        <trans-unit id="58853061cae7a64d47f884b33352fca46eaa4ea0" translate="yes" xml:space="preserve">
          <source>Nginx Systemtap Toolkit</source>
          <target state="translated">Nginx Systemtap 툴킷</target>
        </trans-unit>
        <trans-unit id="5bfddbee998421d882a511ef6ed379a3be09af5f" translate="yes" xml:space="preserve">
          <source>Nginx cores older than 1.6.0 (exclusive) are &lt;em&gt;not&lt;/em&gt; supported.</source>
          <target state="translated">1.6.0보다 오래된 Nginx 코어 (독점)는 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2c044d64faf3fdaff856b1b8d1e2a9d7b446fa15" translate="yes" xml:space="preserve">
          <source>Nginx log level constants</source>
          <target state="translated">Nginx 로그 레벨 상수</target>
        </trans-unit>
        <trans-unit id="1d7996ffe9ebf877225187ed06879c2611106f0d" translate="yes" xml:space="preserve">
          <source>Nginx may terminate a request early with (at least):</source>
          <target state="translated">Nginx는 (최소한) 다음과 같이 초기에 요청을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12ff7d8d02509bfbf56621f86570af5d0807db49" translate="yes" xml:space="preserve">
          <source>Nginx modules:</source>
          <target state="translated">Nginx 모듈 :</target>
        </trans-unit>
        <trans-unit id="7793c73465a179275ad7b572a7e5ef161e8fb423" translate="yes" xml:space="preserve">
          <source>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</source>
          <target state="translated">응답 본문이 청크로 전달 될 수 있기 때문에 Nginx 출력 필터는 단일 요청에 대해 여러 번 호출 될 수 있습니다. 따라서이 지시문에 지정된 Lua 코드는 단일 HTTP 요청 수명 동안 여러 번 실행될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0661826d885b9e38cd745eed85fac0d5393384" translate="yes" xml:space="preserve">
          <source>Nginx regex group capturing variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, and etc, can be read by this interface as well, by writing &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, and etc.</source>
          <target state="translated">&lt;code&gt;ngx.var[1]&lt;/code&gt; , &lt;code&gt;ngx.var[2]&lt;/code&gt; , &lt;code&gt;ngx.var[3]&lt;/code&gt; 등 을 작성 하여 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등을 캡처하는 Nginx 정규식 그룹을 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78155f49d1f7984ef7b57dfbb47e79250361d3ee" translate="yes" xml:space="preserve">
          <source>Nginx variable interpolation is supported in the &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; argument string of this directive. But special care must be taken for injection attacks.</source>
          <target state="translated">Nginx 변수 보간은 이 지시문 의 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 인수 문자열에서 지원됩니다. 그러나 주입 공격에는 특별한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1caafcf196b99784ba3ca84ab5ee64b17de29a1a" translate="yes" xml:space="preserve">
          <source>Nginx variables are supported in the file path for dynamic dispatch just as in &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;.</source>
          <target state="translated">Nginx 변수는 다음과 같이 동적 디스패치의 파일 경로에서 지원됩니다. &lt;a href=&quot;#content_by_lua_file&quot;&gt; content_by_lua_file&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ede519ce7605a8c3b10b9d7f082bae2ab2007258" translate="yes" xml:space="preserve">
          <source>Nginx variables are supported in the file path for dynamic dispatch, for example:</source>
          <target state="translated">Nginx 변수는 동적 디스패치의 파일 경로에서 지원됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="54da8a18babb64a1603661d18049641b3125b5a3" translate="yes" xml:space="preserve">
          <source>Nginx variables can be used in the &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; string to provide flexibility. This however carries some risks and is not ordinarily recommended.</source>
          <target state="translated">Nginx 변수는 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 에서 사용할 수 있습니다 문자열에서 사용되어 유연성을 제공 할 수 있습니다. 그러나 이것은 약간의 위험을 수반하며 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e021461a65c61b50a18410dc40afc21d29a0fe89" translate="yes" xml:space="preserve">
          <source>Nginx version &amp;gt;= 1.4.2</source>
          <target state="translated">Nginx 버전&amp;gt; = 1.4.2</target>
        </trans-unit>
        <trans-unit id="4579aaf52efd267504193696c6698c7f2b3ed5d2" translate="yes" xml:space="preserve">
          <source>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or &lt;em&gt;any&lt;/em&gt; other nginx C modules like &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;, &lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, and even ngx_lua itself and etc etc etc.</source>
          <target state="translated">Nginx에의 하위 요청은 디스크 파일 디렉토리 또는로 구성된 다른 위치로 내부 요청 비 차단 할 수있는 강력한 방법 제공 &lt;em&gt;어떤&lt;/em&gt; 같은 다른의 nginx의 C 모듈 &lt;code&gt;ngx_proxy&lt;/code&gt; , &lt;code&gt;ngx_fastcgi&lt;/code&gt; 을 , &lt;code&gt;ngx_memc&lt;/code&gt; , &lt;code&gt;ngx_postgres&lt;/code&gt; , &lt;code&gt;ngx_drizzle&lt;/code&gt; 을 , 심지어 자체 ngx_lua 등 등 등</target>
        </trans-unit>
        <trans-unit id="dbd4da4a070097cf2fd2d4f074d3afd98a10bde0" translate="yes" xml:space="preserve">
          <source>No special escaping is required in the Lua code block.</source>
          <target state="translated">Lua 코드 블록에는 특별한 이스케이프가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb083169fb38c81a7e2fb297296142c5ff9f1dc8" translate="yes" xml:space="preserve">
          <source>Non-array table arguments will cause a Lua exception to be thrown.</source>
          <target state="translated">배열이 아닌 테이블 인수는 Lua 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e58802370b668ce81057f1ec639917482fcd7eff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ngx.flush&lt;/code&gt; is not functional when in the HTTP 1.0 output buffering mode. See &lt;a href=&quot;#http-10-support&quot;&gt;HTTP 1.0 support&lt;/a&gt;.</source>
          <target state="translated">HTTP 1.0 출력 버퍼링 모드 에서는 &lt;code&gt;ngx.flush&lt;/code&gt; 가 작동하지 않습니다. &lt;a href=&quot;#http-10-support&quot;&gt;HTTP 1.0 지원&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="534783e94de387675860b571358edbdbb109c57a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ngx.header&lt;/code&gt; is not a normal Lua table and as such, it is not possible to iterate through it using the Lua &lt;code&gt;ipairs&lt;/code&gt; function.</source>
          <target state="translated">참고 &lt;code&gt;ngx.header&lt;/code&gt; 가 정상 루아 테이블 아니며 이와 같이,이 루아 사용하여 반복 할 수 없다 &lt;code&gt;ipairs&lt;/code&gt; 을 기능.</target>
        </trans-unit>
        <trans-unit id="2e4856374a13cb6810b0551ea7f077e8f7fd6b7c" translate="yes" xml:space="preserve">
          <source>Note that a longer from of the long bracket, &lt;code&gt;[=[...]=]&lt;/code&gt;, may be required if the regex pattern contains &lt;code&gt;[...]&lt;/code&gt; sequences. The &lt;code&gt;[=[...]=]&lt;/code&gt; form may be used as the default form if desired.</source>
          <target state="translated">정규식 패턴에 &lt;code&gt;[...]&lt;/code&gt; 시퀀스 가 포함 된 경우 긴 괄호 &lt;code&gt;[=[...]=]&lt;/code&gt; 중 더 긴 것이 필요할 수 있습니다 . &lt;code&gt;[=[...]=]&lt;/code&gt; 원한다면 형태는 기본 형태로 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="f1b3fc0ccb535b1e8cf3fa364dae16dbf32623f6" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 최대 100 개의 요청 인수가 동일한 이름을 가진 요청을 포함하여 구문 분석되며 추가 요청 인수는 잠재적 인 서비스 거부 공격으로부터 보호하기 위해 자동으로 삭제됩니다. &lt;code&gt;v0.10.13&lt;/code&gt; 부터 한계가 초과되면 문자열 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 인 두 번째 값을 리턴합니다. .</target>
        </trans-unit>
        <trans-unit id="1008f2001aa2b7e1c7c9ef9a907321575998aec8" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 최대 100 개의 요청 헤더가 구문 분석되고 (이름이 같은 헤더 포함) 추가 요청 헤더는 자동으로 삭제되어 잠재적 인 서비스 거부 공격을 방지합니다. &lt;code&gt;v0.10.13&lt;/code&gt; 부터 한계가 초과되면 문자열 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 인 두 번째 값을 리턴합니다. .</target>
        </trans-unit>
        <trans-unit id="b35dc90413e383baa5920e4c6256188f294278e9" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 최대 100 개의 응답 헤더가 구문 분석되고 (이름이 같은 헤더 포함) 추가 응답 헤더는 자동으로 삭제되어 잠재적 인 서비스 거부 공격을 방지합니다. &lt;code&gt;v0.10.13&lt;/code&gt; 부터 한계가 초과되면 문자열 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 인 두 번째 값을 리턴합니다. .</target>
        </trans-unit>
        <trans-unit id="743168dca492c48d217f45aed738ce0c167c1930" translate="yes" xml:space="preserve">
          <source>Note that calling this function instead of using &lt;code&gt;ngx.var.request_body&lt;/code&gt; or &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; is more efficient because it can save one dynamic memory allocation and one data copy.</source>
          <target state="translated">&lt;code&gt;ngx.var.request_body&lt;/code&gt; 또는 &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; 를 사용하는 대신이 함수를 호출하십시오. 하면 하나의 동적 메모리 할당과 하나의 데이터 사본을 저장할 수 있으므로보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ffc114cd7564144dd44fa220318a670bed172c5f" translate="yes" xml:space="preserve">
          <source>Note that common HTTP benchmark tools such as &lt;code&gt;ab&lt;/code&gt; and &lt;code&gt;http_load&lt;/code&gt; issue HTTP 1.0 requests by default. To force &lt;code&gt;curl&lt;/code&gt; to send HTTP 1.0 requests, use the &lt;code&gt;-0&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;ab&lt;/code&gt; 및 &lt;code&gt;http_load&lt;/code&gt; 와 같은 일반적인 HTTP 벤치 마크 도구 는 기본적으로 HTTP 1.0 요청을 발행합니다. &lt;code&gt;curl&lt;/code&gt; 이 HTTP 1.0 요청을 보내도록 하려면 &lt;code&gt;-0&lt;/code&gt; 을 사용하십시오. 옵션을 .</target>
        </trans-unit>
        <trans-unit id="0f5af5cc042d914dbd336c6f815b1937ebedae81" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;share_all_vars&lt;/code&gt; and &lt;code&gt;copy_all_vars&lt;/code&gt; are set to true, then &lt;code&gt;share_all_vars&lt;/code&gt; takes precedence.</source>
          <target state="translated">&lt;code&gt;share_all_vars&lt;/code&gt; 및 &lt;code&gt;copy_all_vars&lt;/code&gt; 가 모두 true로 설정되면 &lt;code&gt;share_all_vars&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="48099a61abc289fffe618c332f51e8f6de3f885a" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use this interface to rewrite URI arguments and that &lt;a href=&quot;#ngxreqset_uri_args&quot;&gt;ngx.req.set_uri_args&lt;/a&gt; should be used for this instead. For instance, Nginx config</source>
          <target state="translated">이 인터페이스를 사용하여 URI 인수를 다시 쓸 수 &lt;a href=&quot;#ngxreqset_uri_args&quot;&gt;없으며&lt;/a&gt; 대신 ngx.req.set_uri_args를 사용해야합니다. 예를 들어 Nginx 설정</target>
        </trans-unit>
        <trans-unit id="635706fb9785de0c24d1ba53fd8772141c4b840d" translate="yes" xml:space="preserve">
          <source>Note that it is recommended to use LuaJIT 2.0 or LuaJIT 2.1 instead of the standard Lua 5.1 interpreter wherever possible.</source>
          <target state="translated">가능하면 표준 Lua 5.1 인터프리터 대신 LuaJIT 2.0 또는 LuaJIT 2.1을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="edb15788554d45256eb17bf97302880ace5c4bfc" translate="yes" xml:space="preserve">
          <source>Note that only already defined nginx variables can be written to. For example:</source>
          <target state="translated">이미 정의 된 nginx 변수 만 쓸 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f873d4ff7e9d38bf403e125e01129f4d718d49a3" translate="yes" xml:space="preserve">
          <source>Note that only three of these constants are utilized by the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; (i.e., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; accepts &lt;code&gt;ngx.OK&lt;/code&gt;, &lt;code&gt;ngx.ERROR&lt;/code&gt;, and &lt;code&gt;ngx.DECLINED&lt;/code&gt; as input).</source>
          <target state="translated">이러한 상수 중 3 개만 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua 용 Nginx API에서&lt;/a&gt; 사용됩니다 (즉, &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; 는 &lt;code&gt;ngx.OK&lt;/code&gt; , &lt;code&gt;ngx.ERROR&lt;/code&gt; 및 &lt;code&gt;ngx.DECLINED&lt;/code&gt; 를 허용 함 ) 를 입력으로 허용 함).</target>
        </trans-unit>
        <trans-unit id="7ee6f9a462fef43240ba5fd87754796ab92b8973" translate="yes" xml:space="preserve">
          <source>Note that subrequests issued by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses. For example, when using the standard &lt;code&gt;ngx_proxy&lt;/code&gt; module to serve subrequests, an &quot;Accept-Encoding: gzip&quot; header in the main request may result in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers&quot;&gt;proxy_pass_request_headers&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; in subrequest locations.</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture에서&lt;/a&gt; 발행 한 하위 요청은 기본적으로 현재 요청의 모든 요청 헤더를 상속하므로 하위 요청 응답에 예기치 않은 부작용이있을 수 있습니다. 예를 들어, 하위 요청을 제공하기 위해 표준 &lt;code&gt;ngx_proxy&lt;/code&gt; 모듈을 사용하는 경우 기본 요청의 &quot;Accept-Encoding : gzip&quot;헤더로 인해 루아 코드에서 제대로 처리 할 수없는 응답이 생길 수 있습니다. 서브 요청 위치에서 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers&quot;&gt;proxy_pass_request_headers&lt;/a&gt; 를 &lt;code&gt;off&lt;/code&gt; 로 설정하여 원래 요청 헤더를 무시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="18a5aecb3c6f3b305e355957cd6fd4141e621cf7" translate="yes" xml:space="preserve">
          <source>Note that subrequests issued by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses. For example, when using the standard &lt;code&gt;ngx_proxy&lt;/code&gt; module to serve subrequests, an &quot;Accept-Encoding: gzip&quot; header in the main request may result in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers&quot;&gt;proxy_pass_request_headers&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; in subrequest locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79df2901fb5d3ee02055928105ad97a59018aae1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.HEADER&lt;/a&gt; API call, which uses core &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_&quot;&gt;$http_HEADER&lt;/a&gt; variables, may be more preferable for reading individual request headers.</source>
          <target state="translated">개별 요청 헤더를 읽는 데 핵심 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_&quot;&gt;$ http_HEADER&lt;/a&gt; 변수 를 사용 하는 &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.HEADER&lt;/a&gt; API 호출 이 더 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e67141029d9b6f4230c3ed230683614e3f726ff" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.HEADER&lt;/a&gt; API call, which uses core &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_&quot;&gt;$http_HEADER&lt;/a&gt; variables, may be more preferable for reading individual request headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a51ca95a947300c8f414535f67f2618e187c4f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://mdounin.ru/hg/ngx_http_auth_request_module/&quot;&gt;ngx_auth_request&lt;/a&gt; module can be approximated by using &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;:</source>
          <target state="translated">있습니다 &lt;a href=&quot;http://mdounin.ru/hg/ngx_http_auth_request_module/&quot;&gt;ngx_auth_request&lt;/a&gt; 모듈을 사용하여 근사 할 수있다 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5b65537e7401c6365e05d755fe499666e9509068" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://www.grid.net.ru/nginx/eval.en.html&quot;&gt;ngx_eval&lt;/a&gt; module can be approximated by using &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;. For example,</source>
          <target state="translated">있습니다 &lt;a href=&quot;http://www.grid.net.ru/nginx/eval.en.html&quot;&gt;ngx_eval&lt;/a&gt; 모듈을 사용하여 근사 할 수있다 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua을&lt;/a&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="2bef02be7814d9387fe72d8350e88075e429ca7c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;ngx.exec&lt;/code&gt; method is different from &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; in that it is purely an internal redirect and that no new external HTTP traffic is involved.</source>
          <target state="translated">있습니다 &lt;code&gt;ngx.exec&lt;/code&gt; 방법은 다른 &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; 은 순수하게 내부 리디렉션입니다에 있고 새로운 외부 HTTP 트래픽이 포함되지 않도록.</target>
        </trans-unit>
        <trans-unit id="62cffba727436c20ac21ca7a9a3735f739d1c34e" translate="yes" xml:space="preserve">
          <source>Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.</source>
          <target state="translated">코 소켓 연결 풀은 Nginx 서버 인스턴스가 아닌 Nginx 작업자 프로세스 당이므로 여기에 지정된 크기 제한은 모든 단일 Nginx 작업자 프로세스에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="241f427b409acf1de61d88e8f8a697694cb2704a" translate="yes" xml:space="preserve">
          <source>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</source>
          <target state="translated">코 소켓 연결 풀은 nginx 서버 인스턴스가 아닌 nginx 작업자 프로세스 당이므로 여기에 지정된 크기 제한은 모든 단일 nginx 작업자 프로세스에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="78f079835cc1b6190832ff2a709eb3b927795aaf" translate="yes" xml:space="preserve">
          <source>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter's current implementation:</source>
          <target state="translated">NGINX 출력 필터의 현재 구현의 한계로 인해이 컨텍스트에서 현재 다음 API 기능이 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c26daf5ee962e61ee82a6ed2f28e3983ef768b61" translate="yes" xml:space="preserve">
          <source>Note that the following API functions are currently disabled within this context:</source>
          <target state="translated">이 컨텍스트에서는 현재 다음 API 기능이 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd38306081c80b27c7dc753adcf3b7baf9df370b" translate="yes" xml:space="preserve">
          <source>Note that the log level specified in the standard &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive &lt;em&gt;does&lt;/em&gt; have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level&quot;&gt;errlog.set_filter_level&lt;/a&gt;. So it is more flexible than the static &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive.</source>
          <target state="translated">로그 레벨이 표준에서 지정한주의 &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;의 error_log의&lt;/a&gt; 지시어는 &lt;em&gt;않습니다&lt;/em&gt; 이 캡처 기능에 영향을 미칩니다. &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; 지시문 에서 지정된 로그 수준보다 낮은 수준의 로그 메시지 만 캡처 합니다. 사용자는 Lua API 함수 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level&quot;&gt;errlog.set_filter_level을&lt;/a&gt; 통해 더 높은 필터링 로그 수준을 즉시 설정할 수 있습니다 . 따라서 정적 &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; 지시문 보다 유연 합니다.</target>
        </trans-unit>
        <trans-unit id="1e0f716ef06d1a22aed8ffeacd3a97e5c3b502c0" translate="yes" xml:space="preserve">
          <source>Note that the log level specified in the standard &lt;a href=&quot;https://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive &lt;em&gt;does&lt;/em&gt; have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the &lt;a href=&quot;https://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level&quot;&gt;errlog.set_filter_level&lt;/a&gt;. So it is more flexible than the static &lt;a href=&quot;https://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3ecbd1bc71a20a034bc8a316195134d0cfd59f" translate="yes" xml:space="preserve">
          <source>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</source>
          <target state="translated">만료 된 키의 값을 사용할 수 있다고 보장되지 않으므로 만료 된 항목의 가용성에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9c17d3ae2ae57cfed67fdbf3944b81b4b2ea38e9" translate="yes" xml:space="preserve">
          <source>Note that there is no need to call this method on socket objects that have invoked the &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; method because the socket object is already closed (and the current connection is saved into the built-in connection pool).</source>
          <target state="translated">소켓 오브젝트가 이미 닫혀 있고 현재 연결이 내장 된 연결 풀에 저장되므로 &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; 메소드를 호출 한 소켓 오브젝트에서이 메소드를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6fc8a3217ccf3d63047159121f3295c5a66de28" translate="yes" xml:space="preserve">
          <source>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; or &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or when &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua*&lt;/a&gt; exits normally.</source>
          <target state="translated">ngx_lua는 내용이 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; 또는 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print로&lt;/a&gt; 출력되기 전에 또는 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua *가&lt;/a&gt; 정상적으로 종료 될 때 자동으로 헤더를 전송하므로 응답 헤더를 수동으로 보낼 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="65940a3ec594d1ac2ed9e614e82f55bdc446b125" translate="yes" xml:space="preserve">
          <source>Note that this data sharing is on a &lt;em&gt;per-worker&lt;/em&gt; basis and not on a &lt;em&gt;per-server&lt;/em&gt; basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.</source>
          <target state="translated">이 데이터 공유는 &lt;em&gt;서버&lt;/em&gt; 별로가 아니라 &lt;em&gt;작업자&lt;/em&gt; 별로 이루어집니다. 즉, Nginx 마스터 아래에 여러 nginx 작업자 프로세스가있는 경우 데이터 공유는 이러한 작업자 간의 프로세스 경계를 ​​넘을 수 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aea3e11a46abc5a4d3ded826776d9811dc5282ca" translate="yes" xml:space="preserve">
          <source>Note that this directive does &lt;em&gt;not&lt;/em&gt; affect the memory allocated by LuaJIT's own allocator based on the &lt;code&gt;mmap&lt;/code&gt; system call.</source>
          <target state="translated">이 지시문은 &lt;code&gt;mmap&lt;/code&gt; 시스템 호출을 기반으로 LuaJIT 자체 할당자가 할당 한 메모리에 영향을 미치지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5378198c8f75c3dea99f65b1c6ccf69ba63ca45e" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_access_module.html&quot;&gt;ngx_http_access_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="translated">이 핸들러는 항상 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_access_module.html&quot;&gt;ngx_http_access_module &lt;/a&gt;&lt;em&gt;이후&lt;/em&gt; 에 실행됩니다 . 따라서 다음과 같이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e3d5c6d6e30193a16dcba5b440dd21fac4f6d95" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="translated">이 핸들러는 항상 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module &lt;/a&gt;&lt;em&gt;이후&lt;/em&gt; 에 실행됩니다 . 따라서 다음과 같이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d54f8b5ccd59dfd260cfdc04906a30d7003e27f1" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_access_module.html&quot;&gt;ngx_http_access_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0ec4deaac17da168250c24cbfe1e36a48b0ab7" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3114da95df93d38fa2f4849cd93af3ba3cc641" translate="yes" xml:space="preserve">
          <source>Note that this method call terminates the processing of the current request and that it &lt;em&gt;must&lt;/em&gt; be called before &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or explicit response body outputs by either &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;.</source>
          <target state="translated">이 메소드 호출은 현재 요청의 처리를 종료하며 &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; 또는 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 또는 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say에&lt;/a&gt; 의한 명시 적 응답 본문 출력 전에 호출 &lt;em&gt;되어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="efa22a6c439c29f9ac4721c5a272772493fbc244" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; affect the &lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt; setting; the &lt;code&gt;timeout&lt;/code&gt; argument to the &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; method should be used for this purpose instead.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt; 설정에 영향을 미치지 &lt;em&gt;않습니다&lt;/em&gt; . 대신 &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; 메소드에 대한 &lt;code&gt;timeout&lt;/code&gt; 인수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d1a32d310451fff398026007327c7ca625d74fc" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; handler, calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with status &amp;gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &amp;lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</source>
          <target state="translated">&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; 핸들러 내에서 &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; 호출 할 때 nginx 요청 처리 제어 플로우는 여전히 컨텐츠 핸들러로 계속 진행됩니다. 내에서 현재 요청 종료하도록 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua의&lt;/a&gt; 호출 핸들러 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit를&lt;/a&gt; 상태&amp;gt; = 200 ( &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; ) 상태 &amp;lt;300 ( &lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt; 성공적으로 종료되고 대) &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (또는 친구 실패).</target>
        </trans-unit>
        <trans-unit id="fb9ed874675b6a917baaa4e4da878aea8074b2c7" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler, calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with status &amp;gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &amp;lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</source>
          <target state="translated">&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 핸들러 내에서 &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; 호출 할 때 nginx 요청 처리 제어 플로우는 여전히 컨텐츠 핸들러로 계속 진행됩니다. 내에서 현재의 요구를 종료 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua의&lt;/a&gt; 호출 핸들러 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit를&lt;/a&gt; 상태&amp;gt; = 200 ( &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; ) 상태 &amp;lt;300 ( &lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt; 성공적으로 종료되고 대) &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (또는 친구 실패).</target>
        </trans-unit>
        <trans-unit id="ce920d31e7164c7c248a289220762794bc51e09f" translate="yes" xml:space="preserve">
          <source>Note that while this method accepts all &lt;a href=&quot;#http-status-constants&quot;&gt;HTTP status constants&lt;/a&gt; as input, it only accepts &lt;code&gt;ngx.OK&lt;/code&gt; and &lt;code&gt;ngx.ERROR&lt;/code&gt; of the &lt;a href=&quot;#core-constants&quot;&gt;core constants&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 모든 &lt;a href=&quot;#http-status-constants&quot;&gt;HTTP 상태 상수&lt;/a&gt; 를 입력으로 허용 &lt;code&gt;ngx.OK&lt;/code&gt; &lt;a href=&quot;#core-constants&quot;&gt;코어 상수&lt;/a&gt; 의 ngx.OK 및 &lt;code&gt;ngx.ERROR&lt;/code&gt; 만 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="0523483ad1b28cf5e24d2e5f78061cbcf3d05b1f" translate="yes" xml:space="preserve">
          <source>Note that, the &lt;code&gt;options&lt;/code&gt; argument is not optional when the &lt;code&gt;ctx&lt;/code&gt; argument is specified and that the empty Lua string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) must be used as placeholder for &lt;code&gt;options&lt;/code&gt; if no meaningful regex options are required.</source>
          <target state="translated">그것을 참고 &lt;code&gt;options&lt;/code&gt; 때 인수는 선택하지 &lt;code&gt;ctx&lt;/code&gt; 인수를 지정하고 빈 루아 문자열 (즉, &lt;code&gt;&quot;&quot;&lt;/code&gt; )에 대한 자리 표시 자로 사용되어야합니다 &lt;code&gt;options&lt;/code&gt; 의미있는 정규식 옵션이 필요하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="dac765fca3a6b7e61e41ecfa8ef82543c0da9567" translate="yes" xml:space="preserve">
          <source>Note that, the actual data returned &lt;em&gt;might&lt;/em&gt; be a little longer than the size limit specified by the &lt;code&gt;size&lt;/code&gt; argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</source>
          <target state="translated">경계 패턴에 스트리밍 파싱이 모호 할 경우 반환되는 실제 데이터 는 &lt;code&gt;size&lt;/code&gt; 인수로 지정된 크기 제한보다 약간 길 &lt;em&gt;수&lt;/em&gt; 있습니다 . 데이터 스트림의 경계 근처에서 실제로 반환 된 데이터 문자열은 크기 제한보다 짧을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53caa61884a392996df870c29b8b8899252f9961" translate="yes" xml:space="preserve">
          <source>Note that: this directive is only allowed to used in &lt;strong&gt;http context&lt;/strong&gt; from the &lt;code&gt;v0.10.7&lt;/code&gt; release (because SSL session resumption happens before server name dispatch).</source>
          <target state="translated">이 지시어 만에 사용이 허용되어 있습니다 &lt;strong&gt;HTTP 컨텍스트&lt;/strong&gt; 로부터 &lt;code&gt;v0.10.7&lt;/code&gt; 의 릴리스 (SSL 세션 재개 서버 이름을 파견하기 전에 발생하기 때문에).</target>
        </trans-unit>
        <trans-unit id="d86f91b6b98ea753d4b1937f9cffe9e00293a081" translate="yes" xml:space="preserve">
          <source>Note, however, you still need to configure the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot;&gt;ssl_certificate_key&lt;/a&gt; directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</source>
          <target state="translated">그러나이 정적 인증서와 개인 키를 전혀 사용하지 않더라도 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; 및 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot;&gt;ssl_certificate_key&lt;/a&gt; 지시문 을 구성해야 합니다. NGINX 코어의 모양이 필요하기 때문입니다. 그렇지 않으면 NGINX를 시작하는 동안 다음 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="429cbdb1e638ce27ed2755a0abfebc291e39c4ad" translate="yes" xml:space="preserve">
          <source>Note, however, you still need to configure the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; and &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot;&gt;ssl_certificate_key&lt;/a&gt; directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8fee789de2239f32252fc0ea860eb1196d61fb" translate="yes" xml:space="preserve">
          <source>Number literals can be used directly as the argument, for instance,</source>
          <target state="translated">예를 들어 숫자 리터럴을 인수로 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c03a182e232ebf3731354a8d3d8f0708ccebd13c" translate="yes" xml:space="preserve">
          <source>Obsolete Sections</source>
          <target state="translated">더 이상 사용되지 않는 섹션</target>
        </trans-unit>
        <trans-unit id="b0569934667f9535a3a8009c4f970f485c8b5046" translate="yes" xml:space="preserve">
          <source>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</source>
          <target state="translated">FreeBSD에서는 다음과 같이 TCP keepalive에 대한 시스템 전체 구성 만 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c0aa2318533eccb27e93afe825b16452d78401" translate="yes" xml:space="preserve">
          <source>On the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;forcible&lt;/code&gt; or non nil &lt;code&gt;err&lt;/code&gt; from the &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; method.</source>
          <target state="translated">슬롯에 이미 할당 된 페이지가 가득하고 새로운 키 값 쌍은 슬롯에 추가되고 여유 페이지가없는 경우 반면에, 당신은 얻을 수 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;forcible&lt;/code&gt; 또는 비 무기 호 &lt;code&gt;err&lt;/code&gt; 로부터 &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="2abb0e064654f62263371409fbb8f72bc052ed5f" translate="yes" xml:space="preserve">
          <source>On the other hand, the following will not work as expected:</source>
          <target state="translated">반면에 다음은 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71a17540ae1f85b28c2e4909c43012dcae705555" translate="yes" xml:space="preserve">
          <source>One can also create infinite re-occurring timers, for instance, a timer getting triggered every &lt;code&gt;5&lt;/code&gt; seconds, by calling &lt;code&gt;ngx.timer.at&lt;/code&gt; recursively in the timer callback function. Here is such an example,</source>
          <target state="translated">타이머 콜백 함수에서 &lt;code&gt;ngx.timer.at&lt;/code&gt; 를 재귀 적 으로 호출하여 &lt;code&gt;5&lt;/code&gt; 초 마다 타이머가 트리거되는 것과 같이 무한 재발생 타이머를 만들 수도 있습니다 . 다음은 그러한 예입니다.</target>
        </trans-unit>
        <trans-unit id="adb0046bb29bfa4db097a4bbcea9947356872d62" translate="yes" xml:space="preserve">
          <source>One can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.</source>
          <target state="translated">SSLv3 프로토콜을 사용하거나 선택적으로 아래에서 오래된 SSL 클라이언트를 거부하는 것과 같이 클라이언트 측의 SSL 핸드 셰이크 요청으로 흥미로운 작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e0bc2f5147549b7fd6ef6fb9de7ce90fcde69c" translate="yes" xml:space="preserve">
          <source>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as &lt;code&gt;Content-Type&lt;/code&gt; that only accept a single value).</source>
          <target state="translated">Lua 테이블 만 허용됩니다 (테이블의 마지막 요소 만 단일 값만 허용하는 &lt;code&gt;Content-Type&lt;/code&gt; 과 같은 표준 헤더에 적용됨 ).</target>
        </trans-unit>
        <trans-unit id="6d0aaaf98389c788f883363c37cfc85fd9be0746" translate="yes" xml:space="preserve">
          <source>Only a small set of the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; is supported in this context:</source>
          <target state="translated">이 컨텍스트 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;에서는 Lua 용 Nginx API&lt;/a&gt; 의 작은 세트 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c51ffee27fcb15fca9bd29d4b659569bedb8e46" translate="yes" xml:space="preserve">
          <source>Only the direct &quot;parent coroutine&quot; can wait on its child &quot;light thread&quot;, otherwise a Lua exception will be raised.</source>
          <target state="translated">직접적인 &quot;부모 코 루틴&quot;만이 자식 &quot;경사&quot;를 기다릴 수 있습니다. 그렇지 않으면 루아 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afd371453a7b8e55165edd57aa5ec9a58d8d4009" translate="yes" xml:space="preserve">
          <source>Only the first occurrence of the match is returned, or &lt;code&gt;nil&lt;/code&gt; if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">일치하는 첫 번째 항목 만 반환되거나 일치하는 항목이 없으면 &lt;code&gt;nil&lt;/code&gt; 이 반환 됩니다. 잘못된 정규식을 보거나 PCRE 스택 제한을 초과 하는 등의 오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 및 오류를 설명하는 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8f804668d49f20e57cd51e9ff3953ef79ca04072" translate="yes" xml:space="preserve">
          <source>Other scripting language implementations typically struggle to match this performance level.</source>
          <target state="translated">다른 스크립팅 언어 구현은 일반적으로이 성능 수준을 맞추는 데 어려움을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="08a88eb245e53d08d29d5aa1beb2ec1f73d677bc" translate="yes" xml:space="preserve">
          <source>Output API functions (e.g., &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; and &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;)</source>
          <target state="translated">출력 API 함수 (예 : &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; 및 &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b740866b81e1a9a29cde50a218d2c7a6c45abe3d" translate="yes" xml:space="preserve">
          <source>Overrides the current request's request method with the &lt;code&gt;method_id&lt;/code&gt; argument. Currently only numerical &lt;a href=&quot;#http-method-constants&quot;&gt;method constants&lt;/a&gt; are supported, like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; and &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method_id&lt;/code&gt; 인수로 현재 요청의 요청 메소드를 대체합니다 . 현재 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 및 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; 과 같은 숫자 &lt;a href=&quot;#http-method-constants&quot;&gt;메소드 상수&lt;/a&gt; 만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f4b6b0ff7de5f6cefd55273d83f8121d45cc214" translate="yes" xml:space="preserve">
          <source>Overriding &lt;code&gt;ngx.ctx&lt;/code&gt; with a new Lua table is also supported, for example,</source>
          <target state="translated">예를 들어, 새로운 Lua 테이블로 &lt;code&gt;ngx.ctx&lt;/code&gt; 를 재정의 하는 것도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5caee26e4647c4206c97dcd1b0ffadb41e52643b" translate="yes" xml:space="preserve">
          <source>PCRE sequences such as &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, require special attention because in string literals, the backslash character, &lt;code&gt;\&lt;/code&gt;, is stripped out by both the Lua language parser and by the nginx config file parser before processing if not within a &lt;code&gt;*_by_lua_block {}&lt;/code&gt; directive. So the following snippet will not work as expected:</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 또는 &lt;code&gt;\w&lt;/code&gt; 와 같은 PCRE 시퀀스 는 문자열 리터럴에서 백 슬래시 문자 &lt;code&gt;\&lt;/code&gt; 가 Lua 언어 파서와 nginx 구성 파일 파서 모두에 의해 제거 되기 때문에 특별한주의가 필요 합니다. &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 지시어. 따라서 다음 스 니펫은 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="145d85eb0a8f2d5fdeec50de4cacc59af1ecb86e" translate="yes" xml:space="preserve">
          <source>Parse the http time string (as returned by &lt;a href=&quot;#ngxhttp_time&quot;&gt;ngx.http_time&lt;/a&gt;) into seconds. Returns the seconds or &lt;code&gt;nil&lt;/code&gt; if the input string is in bad forms.</source>
          <target state="translated">http 시간 문자열 ( &lt;a href=&quot;#ngxhttp_time&quot;&gt;ngx.http_time에&lt;/a&gt; 의해 리턴 된 )을 초로 구문 분석하십시오 . 입력 문자열의 형식이 잘못된 경우 초 또는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="44488a589161a071542d6dfc49ee7be4801f80ee" translate="yes" xml:space="preserve">
          <source>Pending timers are those timers that have not expired yet.</source>
          <target state="translated">보류 타이머는 아직 만료되지 않은 타이머입니다.</target>
        </trans-unit>
        <trans-unit id="0c2bcb84eb711873a63a27d5efc0c52d05d8dc6c" translate="yes" xml:space="preserve">
          <source>Perl modules:</source>
          <target state="translated">펄 모듈 :</target>
        </trans-unit>
        <trans-unit id="dd4762faa58429d2699de300f151771d4835ea83" translate="yes" xml:space="preserve">
          <source>Please also refer to restrictions on capturing locations configured by &lt;a href=&quot;#locations-configured-by-subrequest-directives-of-other-modules&quot;&gt;subrequest directives of other modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#locations-configured-by-subrequest-directives-of-other-modules&quot;&gt;다른 모듈의 하위 요청 지시문으로&lt;/a&gt; 구성된 위치 캡처에 대한 제한 사항도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="340e202e8e171b13e6084a6a12dcef1b97f23950" translate="yes" xml:space="preserve">
          <source>Please ensure that the file specified by the &lt;code&gt;file_name&lt;/code&gt; argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</source>
          <target state="translated">&lt;code&gt;file_name&lt;/code&gt; 인수로 지정된 파일 이 존재하고 Lua 예외 오류를 피하기 위해 권한을 올바르게 설정하여 Nginx 작업자 프로세스가 읽을 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e1d68c7c6739205d9ccccbd54981cc2e70b86b7c" translate="yes" xml:space="preserve">
          <source>Please note however, that Lua code written inlined within nginx.conf such as those specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, and &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; will not be updated when you edit the inlined Lua code in your &lt;code&gt;nginx.conf&lt;/code&gt; file because only the Nginx config file parser can correctly parse the &lt;code&gt;nginx.conf&lt;/code&gt; file and the only way is to reload the config file by sending a &lt;code&gt;HUP&lt;/code&gt; signal or just to restart Nginx.</source>
          <target state="translated">그러나 &lt;code&gt;nginx.conf&lt;/code&gt; 파일 에서 인라인 된 Lua 코드를 편집 할 때 nginx.conf 파일 에서 인라인 된 Lua 코드를 편집 할 때 &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; , &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; , &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; 및 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 와 같이 nginx.conf 내에 인라인으로 작성된 Lua 코드 는 업데이트되지 않습니다. &lt;code&gt;nginx.conf&lt;/code&gt; 파일을 올바르게 구문 분석 할 수 있으며 유일한 방법은 &lt;code&gt;HUP&lt;/code&gt; 신호 를 보내 거나 Nginx를 다시 시작 하여 구성 파일을 다시로드하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e7f3cd3da37d895794bf195e08c98fa311f05c0b" translate="yes" xml:space="preserve">
          <source>Please note that TLS session tickets are very different and it is the clients' responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the &lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.</source>
          <target state="translated">TLS 세션 티켓은 매우 다르며 세션 티켓을 사용할 때 SSL 세션 상태를 캐시하는 것은 고객의 책임입니다. TLS 세션 티켓을 기반으로 한 SSL 세션 재개는이 후크 ( &lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; 후크)를 거치지 않고 자동으로 수행됩니다 . 이 후크는 주로 세션 ID별로 SSL 세션 만 수행 할 수있는 구식 또는 능력이 떨어지는 SSL 클라이언트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7bb48f3a05ad03ffd8763830dfbe62a10cc7d1c" translate="yes" xml:space="preserve">
          <source>Please note that both &lt;code&gt;ngx.print&lt;/code&gt; and &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</source>
          <target state="translated">제발 참고 모두 &lt;code&gt;ngx.print&lt;/code&gt; 및 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; 는 항상 비용이 많이 드는 작업입니다 전체 Nginx에 출력 몸 필터 체인, 호출. 따라서이 둘 중 하나를 긴밀하게 호출 할 때주의하십시오. 루아에서 데이터를 직접 버퍼링하고 호출을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="0c8bf268191391f7647d74d2390f01df4bd0687f" translate="yes" xml:space="preserve">
          <source>Please note that the bytecode format used by LuaJIT 2.0/2.1 is not compatible with that used by the standard Lua 5.1 interpreter. So if using LuaJIT 2.0/2.1 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:</source>
          <target state="translated">LuaJIT 2.0 / 2.1에서 사용하는 바이트 코드 형식은 표준 Lua 5.1 인터프리터에서 사용되는 형식과 호환되지 않습니다. 따라서 ngx_lua와 함께 LuaJIT 2.0 / 2.1을 사용하는 경우 다음과 같이 LuaJIT 호환 바이트 코드 파일을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5d0d29938a1c536ed7bb765fab62836d0f7dd78" translate="yes" xml:space="preserve">
          <source>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</source>
          <target state="translated">내부적으로 키-값 쌍이 원자 적으로 설정되어 있지만 원자 성은 메소드 호출 경계를 가로 지르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc530cb73bd8d9797bf30bbd113aac14efc1553a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.balancer&lt;/code&gt; Lua module in &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 에 있는 이 &lt;code&gt;ngx.balancer&lt;/code&gt; Lua 모듈 의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6abebe07286a395e1123395c2fd440d95c29156c" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.semaphore&lt;/code&gt; Lua module in &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 에 있는 이 &lt;code&gt;ngx.semaphore&lt;/code&gt; Lua 모듈 의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d2425efd73bfffeadac4d63c24fae712c0079586" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.ssl&lt;/code&gt; Lua module for more details.</source>
          <target state="translated">자세한 내용 은이 &lt;code&gt;ngx.ssl&lt;/code&gt; Lua 모듈 의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61e61058a69261424e63bdadb5cbe4bdfe896676" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/ocsp-cert-by-lua-2/lib/ngx/ocsp.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.ocsp&lt;/code&gt; Lua module for more details.</source>
          <target state="translated">자세한 내용 은이 &lt;code&gt;ngx.ocsp&lt;/code&gt; Lua 모듈 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/ocsp-cert-by-lua-2/lib/ngx/ocsp.md&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b515b4d9200087db251e87649d51d772e32c390e" translate="yes" xml:space="preserve">
          <source>Please refer to the official LuaJIT documentation on the &lt;code&gt;-b&lt;/code&gt; option for more details:</source>
          <target state="translated">자세한 내용은 &lt;code&gt;-b&lt;/code&gt; 옵션에 대한 공식 LuaJIT 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd86759f6786ef46bfdf18395bba2e0294daf7a9" translate="yes" xml:space="preserve">
          <source>Please submit bug reports, wishlists, or patches by</source>
          <target state="translated">버그 리포트, 위시리스트 또는 패치를 제출하십시오</target>
        </trans-unit>
        <trans-unit id="933d70a4e048fc906e493c7e911082827923d0ab" translate="yes" xml:space="preserve">
          <source>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the &lt;code&gt;HUP&lt;/code&gt; signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call &lt;code&gt;ngx.timer.at&lt;/code&gt; to create new timers with nonzero delays and in that case &lt;code&gt;ngx.timer.at&lt;/code&gt; will return a &quot;conditional false&quot; value and a string describing the error, that is, &quot;process exiting&quot;.</source>
          <target state="translated">&lt;code&gt;HUP&lt;/code&gt; 신호 에 의해 트리거 된 Nginx 구성 다시로드 또는 Nginx 서버 종료 와 같이 Nginx 작업자 프로세스가 종료 될 때 조기 타이머 만료가 발생 합니다. Nginx 작업자가 종료하려고 할 때 더 이상 &lt;code&gt;ngx.timer.at&lt;/code&gt; 를 호출 하여 지연이 0이 아닌 새 타이머를 만들 수 &lt;code&gt;ngx.timer.at&lt;/code&gt; 경우 ngx.timer.at 는 &quot;조건부 거짓&quot;값과 오류를 설명하는 문자열을 반환합니다 즉, &quot;프로세스 종료&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a60d227bf929aec03ac3bf943f60e0474d4fa406" translate="yes" xml:space="preserve">
          <source>Production ready.</source>
          <target state="translated">생산 준비 완료</target>
        </trans-unit>
        <trans-unit id="4c44e5defeed2c1ae1d8dea7ea2e3909a7df78f9" translate="yes" xml:space="preserve">
          <source>Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt; method calls request it or the associated maximal idle timeout is expired.</source>
          <target state="translated">현재 소켓의 연결을 즉시 코 소켓 내장 연결 풀에 넣고 다른 &lt;a href=&quot;#tcpsockconnect&quot;&gt;연결&lt;/a&gt; 메소드 호출이 요청하거나 연관된 최대 유휴 시간 종료가 만료 될 때까지 활성 상태로 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7f31d08350bf099aff6ac7d34cbcf0c253e933f" translate="yes" xml:space="preserve">
          <source>Read and write Nginx variable values.</source>
          <target state="translated">Nginx 변수 값을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="573a83dbb5f547b8987f2cc4b9db719dacd9afde" translate="yes" xml:space="preserve">
          <source>Read and write the current request's response status. This should be called before sending out the response headers.</source>
          <target state="translated">현재 요청의 응답 상태를 읽고 씁니다. 응답 헤더를 보내기 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bddbfc1f846f7b52db8ade30c873a48947a0a0c" translate="yes" xml:space="preserve">
          <source>Reading &lt;code&gt;ngx.header.HEADER&lt;/code&gt; will return the value of the response header named &lt;code&gt;HEADER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngx.header.HEADER&lt;/code&gt; 를 읽으면 이름이 &lt;code&gt;HEADER&lt;/code&gt; 인 응답 헤더의 값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a1fc527eb6c82235f90ab8a109c20257ccf6262" translate="yes" xml:space="preserve">
          <source>Reads the client request body synchronously without blocking the Nginx event loop.</source>
          <target state="translated">Nginx 이벤트 루프를 차단하지 않고 클라이언트 요청 본문을 동 기적으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="42eafdc210a32b28f9c42192440ad539ca7a709f" translate="yes" xml:space="preserve">
          <source>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">선택적 수신 버퍼 크기 인수 인 &lt;code&gt;size&lt;/code&gt; 를 사용하여 UDP 또는 데이터 그램 유닉스 도메인 소켓 객체에서 데이터를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="38cb92fdf6dc1e1147eceb575ed56e430a0dda05" translate="yes" xml:space="preserve">
          <source>Receives data from the connected socket according to the reading pattern or size.</source>
          <target state="translated">판독 패턴 또는 크기에 따라 연결된 소켓에서 데이터를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="2db05ac936e93ce2481f252c81c1066468260aab" translate="yes" xml:space="preserve">
          <source>Redirecting arbitrary external URLs is also supported, for example:</source>
          <target state="translated">다음과 같이 임의의 외부 URL 리디렉션도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되는 경우 수정하거나 수정하지 않고 소스 및 이진 형식으로 재배포 및 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">이진 형식으로 재배포 할 경우 위의 저작권 표시,이 조건 목록 및 배포와 함께 제공된 설명서 및 / 또는 기타 자료의 다음 면책 사항을 재현해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">소스 코드의 재배포에는 위의 저작권 표시,이 조건 목록 및 다음 면책 사항이 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f02f280a7b4a7b9556d91b7bfffc46c04aa2ac23" translate="yes" xml:space="preserve">
          <source>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</source>
          <target state="translated">클라이언트가 (다운 스트림) 연결을 조기에 닫을 때 자동으로 호출되는 콜백으로 사용자 Lua 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="645abd20936993e4360af8cbafe9c4dfb101c7d4" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; 라는 목록의 첫 번째 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e639e0fdda9a8bf2d699d2a3458180bd24767f06" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; 라는 목록의 마지막 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9322198eff9f5b29b649fbd4be1a09c203594807" translate="yes" xml:space="preserve">
          <source>Removing the &lt;code&gt;max_args&lt;/code&gt; cap is strongly discouraged.</source>
          <target state="translated">&lt;code&gt;max_args&lt;/code&gt; 캡을 제거 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ec5f70f91eaba1bcb60beb759e74c4d39b008102" translate="yes" xml:space="preserve">
          <source>Removing the &lt;code&gt;max_headers&lt;/code&gt; cap is strongly discouraged.</source>
          <target state="translated">&lt;code&gt;max_headers&lt;/code&gt; 캡을 제거 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="44e65159a919bfa802cca475e45694043e0148f9" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;GET /lua&lt;/code&gt; will give the output</source>
          <target state="translated">요청 &lt;code&gt;GET /lua&lt;/code&gt; 는 출력을 줄 것입니다</target>
        </trans-unit>
        <trans-unit id="47b2ef53d67f9bc264bedfe71ce571be12f57298" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;GET /lua&lt;/code&gt; yields the output</source>
          <target state="translated">요청 &lt;code&gt;GET /lua&lt;/code&gt; 는 출력을 산출합니다</target>
        </trans-unit>
        <trans-unit id="07b5fa881d6cec3c2b78e46cf58f385d740af4d9" translate="yes" xml:space="preserve">
          <source>Resumes the executation of a user Lua coroutine object previously yielded or just created.</source>
          <target state="translated">이전에 생성되었거나 방금 생성 된 사용자 Lua 코 루틴 오브젝트의 실행을 재개합니다.</target>
        </trans-unit>
        <trans-unit id="f2c7186cf75e46d961636abd704332b18f4b5607" translate="yes" xml:space="preserve">
          <source>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the &lt;a href=&quot;#ngxreqget_post_args&quot;&gt;ngx.req.get_post_args&lt;/a&gt; function instead if a Lua table is required.</source>
          <target state="translated">메모리 내 요청 본문 데이터를 검색합니다. 구문 분석 된 모든 쿼리 인수를 보유하는 Lua 테이블 대신 Lua 문자열을 반환합니다. Lua 테이블이 필요한 경우 &lt;a href=&quot;#ngxreqget_post_args&quot;&gt;ngx.req.get_post_args&lt;/a&gt; 함수를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb82e608b8ad2f96e9c17c4c7524e1a604c6d0bb" translate="yes" xml:space="preserve">
          <source>Retrieves the capacity in bytes for the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; declared with the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; 지시문으로 선언 된 shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 의 용량을 바이트 단위로 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="3155080229a1952b0f59cb46b6029006b7d5bb8d" translate="yes" xml:space="preserve">
          <source>Retrieves the current request's request method name. Strings like &lt;code&gt;&quot;GET&quot;&lt;/code&gt; and &lt;code&gt;&quot;POST&quot;&lt;/code&gt; are returned instead of numerical &lt;a href=&quot;#http-method-constants&quot;&gt;method constants&lt;/a&gt;.</source>
          <target state="translated">현재 요청의 요청 메소드 이름을 검색합니다. 숫자 &lt;a href=&quot;#http-method-constants&quot;&gt;메소드 상수&lt;/a&gt; 대신 &lt;code&gt;&quot;GET&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;POST&quot;&lt;/code&gt; &quot; 와 같은 문자열 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a3c9d4e7c427a314fdc9c33fd9b98e7bcb3e90b" translate="yes" xml:space="preserve">
          <source>Retrieves the current running phase name. Possible return values are</source>
          <target state="translated">현재 실행중인 위상 이름을 검색합니다. 가능한 반환 값은</target>
        </trans-unit>
        <trans-unit id="730c8ea87d224a4165bf8e40b347628e7dfd6e4d" translate="yes" xml:space="preserve">
          <source>Retrieves the file name for the in-file request body data. Returns &lt;code&gt;nil&lt;/code&gt; if the request body has not been read or has been read into memory.</source>
          <target state="translated">파일 내 요청 본문 데이터의 파일 이름을 검색합니다. 요청 본문을 읽지 않았거나 메모리로 읽은 경우 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="1a1d046c2d10111fd3dcb420150a4c9aa1892afd" translate="yes" xml:space="preserve">
          <source>Retrieves the free page size in bytes for the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT에&lt;/a&gt; 대한 사용 가능한 페이지 크기 (바이트)를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="4748acf2b96d8fbeee842ec92b0a3bfb12c12354" translate="yes" xml:space="preserve">
          <source>Retrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns the TTL as a number if the operation is successfully completed or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 키-값 쌍의 나머지 TTL (초 단위 시간)을 검색 합니다. 상기 작업이 성공적으로 완료되면 번호 또는 같은 TTL 반환 &lt;code&gt;nil&lt;/code&gt; 하고, 그렇지 않으면 오류 메시지가.</target>
        </trans-unit>
        <trans-unit id="2dad936367e92c213cc5faa3cafc18bade6e73b8" translate="yes" xml:space="preserve">
          <source>Retrieving the value in the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; for the key &lt;code&gt;key&lt;/code&gt;. If the key does not exist or has expired, then &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">사전의 값 가져 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 키에 대한 &lt;code&gt;key&lt;/code&gt; . 키가 없거나 만료 된 경우 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="57d33be9b599da6a4ad7e5c545b2ff2296c0fc73" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;1&lt;/code&gt; if the callback is registered successfully or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">반환 &lt;code&gt;1&lt;/code&gt; 콜백이 성공적으로 등록 또는 반환하는 경우 &lt;code&gt;nil&lt;/code&gt; 을 하고, 문자열, 그렇지 않으면 오류를 설명.</target>
        </trans-unit>
        <trans-unit id="f33772d172f452f5d2dfe5af149eaa76866095e5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the current request is an nginx subrequest, or &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 현재의 요청이의 nginx의 subrequest 경우, 또는 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="7861b0bd12f49ee1552b37269e5e3f175bb11c7d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the response headers have been sent (by ngx_lua), and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 응답 헤더 (ngx_lua로) 보내 된 경우 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e8c69cb5a487d7fd09b87f938cad9a16b7ba46f" translate="yes" xml:space="preserve">
          <source>Returns a 3rd value, &lt;code&gt;stale&lt;/code&gt;, indicating whether the key has expired or not.</source>
          <target state="translated">키가 만료되었는지 여부를 나타내는 세 번째 값인 &lt;code&gt;stale&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d54c5ba67c364a744f3eb637a7aa9cd27e3e3d8e" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request POST query arguments (of the MIME type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). Call &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; to read the request body first or turn on the &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; directive to avoid errors.</source>
          <target state="translated">모든 현재 요청 POST 쿼리 인수 (MIME 유형 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; )를 보유한 Lua 테이블을 반환합니다 . &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 를 호출 하여 요청 본문을 먼저 읽거나 &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; 지시문을 켜서 오류를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="cb56ac305c13907d5001e4ec467cba85986b47f1" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request URL query arguments.</source>
          <target state="translated">모든 현재 요청 URL 쿼리 인수가 포함 된 Lua 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81175830e221c07eb774ae775bf453a40d3636c9" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request headers.</source>
          <target state="translated">현재 요청 헤더를 모두 보유한 Lua 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efe5e76da41f853b8b991a7f282ad30a1267bc80" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current response headers for the current request.</source>
          <target state="translated">현재 요청에 대한 모든 현재 응답 헤더를 보유하는 Lua 테이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3c495800f8c2c1165426fab79e976b2df2ccd27c" translate="yes" xml:space="preserve">
          <source>Returns a Lua table with 4 slots: &lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;res.status&lt;/code&gt; , &lt;code&gt;res.header&lt;/code&gt; , &lt;code&gt;res.body&lt;/code&gt; 및 &lt;code&gt;res.truncated&lt;/code&gt; 슬롯이있는 Lua 테이블을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6489963c7f3c12c55cc2d6c157de70ae5f0443a3" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether the current request is an &quot;internal request&quot;, i.e., a request initiated from inside the current nginx server instead of from the client side.</source>
          <target state="translated">현재 요청이 &quot;내부 요청&quot;인지, 즉 클라이언트 측이 아닌 현재 nginx 서버 내부에서 시작된 요청인지 여부를 나타내는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b269c78c1b7cd6403009dda47553c12f28a2316d" translate="yes" xml:space="preserve">
          <source>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">nginx 캐시 된 시간에서 현재 시간 소인에 대한 에포크에서 경과 시간에 대한 부동 소수점 숫자 (초) (소수점으로 밀리 초 포함)를 리턴합니다 (Lua의 날짜 라이브러리와 다른 syscall은 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="970c0e3e93fcd5fa03630d541f0302420dd0c530" translate="yes" xml:space="preserve">
          <source>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</source>
          <target state="translated">현재 요청을 만들 때 타임 스탬프 (소수점으로 밀리 초 포함)를 나타내는 부동 소수점 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e939f9d1a13a6ec5c34638a095f34cae89b17fa" translate="yes" xml:space="preserve">
          <source>Returns a formated string can be used as the http header time (for example, being used in &lt;code&gt;Last-Modified&lt;/code&gt; header). The parameter &lt;code&gt;sec&lt;/code&gt; is the time stamp in seconds (like those returned from &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;).</source>
          <target state="translated">형식화 된 문자열을 http 헤더 시간으로 사용할 수 있습니다 (예 : &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에서 사용). &lt;code&gt;sec&lt;/code&gt; 매개 변수 는 초 단위의 시간 소인입니다 ( &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt; 에서 리턴 된 것과 유사 함 ).</target>
        </trans-unit>
        <trans-unit id="f8a21d801bbbff2c32a8c03686f7cc8440d63e9c" translate="yes" xml:space="preserve">
          <source>Returns a formatted string can be used as the cookie expiration time. The parameter &lt;code&gt;sec&lt;/code&gt; is the time stamp in seconds (like those returned from &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;).</source>
          <target state="translated">쿠키 만료 시간으로 형식화 된 문자열을 사용할 수 있습니다. &lt;code&gt;sec&lt;/code&gt; 매개 변수 는 초 단위의 시간 소인입니다 ( &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt; 에서 리턴 된 것과 유사 함 ).</target>
        </trans-unit>
        <trans-unit id="96edce0da8d313cad3e54cd11d07d7fddcd0d634" translate="yes" xml:space="preserve">
          <source>Returns a quoted SQL string literal according to the MySQL quoting rules.</source>
          <target state="translated">MySQL 인용 규칙에 따라 인용 된 SQL 문자열 리터럴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="89bd906aeb3e1de75d36961d1ad9926e97f384b6" translate="yes" xml:space="preserve">
          <source>Returns a read-only cosocket object that wraps the downstream connection. Only &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; and &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; methods are supported on this object.</source>
          <target state="translated">다운 스트림 연결을 래핑하는 읽기 전용 코 소켓 객체를 반환합니다. 이 객체 에서는 &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; 및 &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; 메소드 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7fcd636faf68faa820e159f2dc9f7bed74241fa4" translate="yes" xml:space="preserve">
          <source>Returns current date (in the format &lt;code&gt;yyyy-mm-dd&lt;/code&gt;) from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">nginx 캐시 시간 에서 현재 날짜 ( &lt;code&gt;yyyy-mm-dd&lt;/code&gt; 형식)를 반환합니다 ( Lua의 날짜 라이브러리와 다른 syscall은 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="42bb76558d8431074a7dbfb8670f6144e761b708" translate="yes" xml:space="preserve">
          <source>Returns the HTTP version number for the current request as a Lua number.</source>
          <target state="translated">현재 요청의 HTTP 버전 번호를 Lua 번호로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="403c8b2d5d9e7467eb6c86d98b0073260edc59c6" translate="yes" xml:space="preserve">
          <source>Returns the Nginx server &quot;prefix&quot; path, as determined by the &lt;code&gt;-p&lt;/code&gt; command-line option when running the nginx executable, or the path specified by the &lt;code&gt;--prefix&lt;/code&gt; command-line option when building Nginx with the &lt;code&gt;./configure&lt;/code&gt; script.</source>
          <target state="translated">nginx 실행 파일을 실행할 때 &lt;code&gt;-p&lt;/code&gt; 명령 줄 옵션 으로 결정된 Nginx 서버 &quot;접두사&quot;경로 또는 &lt;code&gt;./configure&lt;/code&gt; 스크립트를 사용하여 Nginx를 빌드 할 때 &lt;code&gt;--prefix&lt;/code&gt; 명령 줄 옵션으로 지정된 경로를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6a060a226052456afaf5c596a877b6748a20534f" translate="yes" xml:space="preserve">
          <source>Returns the binary form of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인수 의 MD5 다이제스트의 이진 형식을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8d80be59f107b4adb4580c9748de570c34b0608d" translate="yes" xml:space="preserve">
          <source>Returns the binary form of the SHA-1 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인수 의 SHA-1 다이제스트의 이진 형식을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="476a8bd45f0b6d8e25bbe845b583596e247e7ad3" translate="yes" xml:space="preserve">
          <source>Returns the current time stamp (in the format &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt;) of the nginx cached time (no syscall involved unlike Lua's &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.date&quot;&gt;os.date&lt;/a&gt; function).</source>
          <target state="translated">nginx 캐시 시간 의 현재 타임 스탬프 ( &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt; 형식)를 반환합니다 ( Lua의 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.date&quot;&gt;os.date&lt;/a&gt; 함수 와 달리 syscall은 포함되지 않음 ).</target>
        </trans-unit>
        <trans-unit id="5cba1b1ccdb8789a04440bda092f7751dbc7fa02" translate="yes" xml:space="preserve">
          <source>Returns the current time stamp (in the format &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt;) of the nginx cached time (no syscall involved unlike Lua's &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-os.date&quot;&gt;os.date&lt;/a&gt; function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157a2eb1202ffa160d25f94918b1c4a164d3b96f" translate="yes" xml:space="preserve">
          <source>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">nginx 캐시 된 시간에서 현재 시간 소인에 대한 에포크에서 경과 된 초를 리턴합니다 (Lua의 날짜 라이브러리와 다른 syscall은 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="545932a89b9ef8da6bf841005f9dc7cba8034004" translate="yes" xml:space="preserve">
          <source>Returns the hexadecimal representation of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 인수 의 MD5 다이제스트의 16 진 표현을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ed5caa1afd3047138513d6af2fb65ad6f0d51af7" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; 라는 목록의 요소 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="28a300dd1fdf9810700020eef8ca2c72efe0abcc" translate="yes" xml:space="preserve">
          <source>Returns the number of pending timers.</source>
          <target state="translated">보류 타이머 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fe28109030903092b18e45017b8f08d0c9ad10b" translate="yes" xml:space="preserve">
          <source>Returns the number of timers currently running.</source>
          <target state="translated">현재 실행중인 타이머 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f9d6b656b44c4a995683bdb751d649b7b013e6d" translate="yes" xml:space="preserve">
          <source>Returns the ordinal number of the current Nginx worker processes (starting from number 0).</source>
          <target state="translated">현재 Nginx 작업자 프로세스의 서수 (0부터 시작)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="beb66aad2eb5befae8267d63ce75ee603e07df27" translate="yes" xml:space="preserve">
          <source>Returns the original raw HTTP protocol header received by the Nginx server.</source>
          <target state="translated">Nginx 서버가받은 원래의 원시 HTTP 프로토콜 헤더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bc2bb362672c906aa0961a72569d5656909009f" translate="yes" xml:space="preserve">
          <source>Returns the total number of the Nginx worker processes (i.e., the value configured by the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot;&gt;worker_processes&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;).</source>
          <target state="translated">반환 Nginx의 작업자 프로세스 (즉,에 의해 구성된 값의 총 수 &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot;&gt;worker_processes이&lt;/a&gt; 지시문 &lt;code&gt;nginx.conf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="46867d7f3030f92e533b5e99d6444233321f15ab" translate="yes" xml:space="preserve">
          <source>Returns the total number of the Nginx worker processes (i.e., the value configured by the &lt;a href=&quot;https://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot;&gt;worker_processes&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa1ee19879e7de344e8f22603276950ed7e49c0" translate="yes" xml:space="preserve">
          <source>Rewrite the current request's (parsed) URI by the &lt;code&gt;uri&lt;/code&gt; argument. The &lt;code&gt;uri&lt;/code&gt; argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 인수로 현재 요청 (구문 분석 된) URI를 다시 작성하십시오 . &lt;code&gt;uri&lt;/code&gt; 인수는 루아 문자열이어야하고 길이가 0이 될 수 없습니다, 또는 루아 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39b17f0d374cfe5d72d4ff1b2ee43be76e7ca56c" translate="yes" xml:space="preserve">
          <source>Rewrite the current request's URI query arguments by the &lt;code&gt;args&lt;/code&gt; argument. The &lt;code&gt;args&lt;/code&gt; argument can be either a Lua string, as in</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 인수로 현재 요청의 URI 쿼리 인수를 다시 작성하십시오 . &lt;code&gt;args&lt;/code&gt; 인수는 같이 하나 루아 문자열이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5b587e23f197991b79042b02ce0b9d60ebb29395" translate="yes" xml:space="preserve">
          <source>Routing requests to different MySQL queries based on URI arguments</source>
          <target state="translated">URI 인수를 기반으로 다른 MySQL 쿼리로 요청 라우팅</target>
        </trans-unit>
        <trans-unit id="dd292a68064649a81389c8cea44291986d194658" translate="yes" xml:space="preserve">
          <source>Running timers are those timers whose user callback functions are still running.</source>
          <target state="translated">실행 타이머는 사용자 콜백 기능이 여전히 실행중인 타이머입니다.</target>
        </trans-unit>
        <trans-unit id="8df570188e1e9e7d32495c4425153a43e5ecce7a" translate="yes" xml:space="preserve">
          <source>Runs the Lua code specified by the argument &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</source>
          <target state="translated">Nginx 마스터 프로세스 (있는 경우)가 Nginx 구성 파일을로드 할 때 전역 Lua VM 레벨에서 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 인수로 지정된 Lua 코드를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="52bfa9ac70fafbe5e95cf2f3ca0adb75d43637ce" translate="yes" xml:space="preserve">
          <source>Runs the Lua source code inlined as the &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; at the &lt;code&gt;log&lt;/code&gt; request processing phase. This does not replace the current access logs, but runs before.</source>
          <target state="translated">&lt;code&gt;log&lt;/code&gt; 요청 처리 단계 에서 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 으로 인라인 된 Lua 소스 코드를 실행합니다 . 이것은 현재 액세스 로그를 대체하지 않지만 이전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="515e3ea1e714875e6451c14596d62cbe57ce2a49" translate="yes" xml:space="preserve">
          <source>Runs the specified Lua code upon every Nginx worker process's startup when the master process is enabled. When the master process is disabled, this hook will just run after &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt;.</source>
          <target state="translated">마스터 프로세스가 활성화 될 때 모든 Nginx 작업자 프로세스 시작시 지정된 Lua 코드를 실행합니다. 마스터 프로세스가 비활성화되면이 후크는 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt; 이후에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="0af2845c0ccfd1f36ef60c96c2fad57a92866e1a" translate="yes" xml:space="preserve">
          <source>SPDY Mode Not Fully Supported</source>
          <target state="translated">SPDY 모드가 완전히 지원되지 않음</target>
        </trans-unit>
        <trans-unit id="a3a47e36cf4694f35a4b7451fec0b46717814fb4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt; if the hexadecimal form of the MD5 digest is required.</source>
          <target state="translated">MD5 다이제스트의 16 진 형식이 필요한 경우 &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eef82d82f464f5a9fe30589ff1c94456bb039186" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxmd5_bin&quot;&gt;ngx.md5_bin&lt;/a&gt; if the raw binary MD5 digest is required.</source>
          <target state="translated">원시 바이너리 MD5 다이제스트가 필요한 경우 &lt;a href=&quot;#ngxmd5_bin&quot;&gt;ngx.md5_bin을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fae2903153d69841475f775001109f4bf560390" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="ec3543143cf938a72d8e6052db22e41b01131ab8" translate="yes" xml:space="preserve">
          <source>See HTTP method constants methods other than POST. The &lt;code&gt;method&lt;/code&gt; option is &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; by default.</source>
          <target state="translated">POST 이외의 HTTP 메소드 상수 메소드를 참조하십시오. &lt;code&gt;method&lt;/code&gt; 옵션은 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="e345d32569874cd7cd49f8f33fc8637285761c91" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ec3dc88d3806c090d67871fab327c3a6b2c7de8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79fef6aaf4b991d3e3aa4937d102c6f07b12922" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5eefa6fcf5ee5fd35ceffd7e7d975e40a2a7007" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt; and &lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt; 및 &lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3a3fe01b6cccd2e2c86c16be4a17959b6c2f555" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="934e46ccc7dccb7e5bbb4290efa4e99ca48a2796" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d88e616c712ce83343b401831b4b91a480cba10" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a73d3f34e603a6a8ac148ae45dcb9a278ab03c5a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_method&quot;&gt;ngx.req.get_method&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqget_method&quot;&gt;ngx.req.get_method&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c47171e0bb3dc918ff13173ddcbefb4e7bdf59c8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ccf86f490aaf3621ecd1e207f0d36160f655ede" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32163a097898c33d6ae51800b03dfa1cf332fcc0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f79f2058c20da3fc9b7cc4453c786aa9e53eb3c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_body_file&quot;&gt;ngx.req.set_body_file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqset_body_file&quot;&gt;ngx.req.set_body_file&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9576565dde43fb3241c120689c95894ffa624d74" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_method&quot;&gt;ngx.req.set_method&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqset_method&quot;&gt;ngx.req.set_method&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3945d36dd3f22526c9e8aee25d8265903858c74" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a6b362ef9870bf7e9ec536751e38ce7fc8cec7" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ea34ffb7fb4f19b4bde478f22596931a0fa56e8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;ngx.shared.DICT.flush_all&lt;/a&gt; and &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;ngx.shared.DICT.flush_all&lt;/a&gt; 및 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c05c95f357635fdc590dfa33ec4b7bbe2bde5258" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddictflush_expired&quot;&gt;ngx.shared.DICT.flush_expired&lt;/a&gt; and &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictflush_expired&quot;&gt;ngx.shared.DICT.flush_expired&lt;/a&gt; 및 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b271bcc6dc7b053378c7235950927663e242366" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a74c6b8991d5b35e6672fab1c27f924182eb4337" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1276a6aef3ae13e5500847888cf85e3be28188e" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxworkercount&quot;&gt;ngx.worker.count&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxworkercount&quot;&gt;ngx.worker.count&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0e9428321dad862d14c7e8ad23143add2401c83" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/blob/master/util/build.sh&quot;&gt;developer build script&lt;/a&gt; for more details on setting up the testing environment.</source>
          <target state="translated">테스트 환경 설정에 대한 자세한 내용 은 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/blob/master/util/build.sh&quot;&gt;개발자 빌드 스크립트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="692ad6aa11fd3b3b9e6517d7195b2a9d307acc98" translate="yes" xml:space="preserve">
          <source>See more complicated examples in the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; and &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; Lua modules' official documentation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; Lua 모듈의 공식 문서 에서 더 복잡한 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a83727ae0d0a7d9d54f2888b06e1142f19e5fb17" translate="yes" xml:space="preserve">
          <source>Sends data on the current UDP or datagram unix domain socket object.</source>
          <target state="translated">현재 UDP 또는 데이터 그램 유닉스 도메인 소켓 객체에서 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a85a7cc27a9d5c7ca3e22eb9352f9f6dd0c9c642" translate="yes" xml:space="preserve">
          <source>Sends data without blocking on the current TCP or Unix Domain Socket connection.</source>
          <target state="translated">현재 TCP 또는 Unix 도메인 소켓 연결을 차단하지 않고 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1c63d1469310416c5d60b8ab014836f11900c1a5" translate="yes" xml:space="preserve">
          <source>Set the current request's request body using the in-file data specified by the &lt;code&gt;file_name&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;file_name&lt;/code&gt; 인수로 지정된 파일 내 데이터를 사용하여 현재 요청의 요청 본문을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba87be315635af39fe5d5147fe5286585b9f004d" translate="yes" xml:space="preserve">
          <source>Set the current request's request body using the in-memory data specified by the &lt;code&gt;data&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 인수로 지정된 메모리 내 데이터를 사용하여 현재 요청의 요청 본문을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fd302d8c5b915c6d978c73a7b7ddf254c8cd2dc" translate="yes" xml:space="preserve">
          <source>Set the current request's request header named &lt;code&gt;header_name&lt;/code&gt; to value &lt;code&gt;header_value&lt;/code&gt;, overriding any existing ones.</source>
          <target state="translated">현재 요청의 요청 헤더 &lt;code&gt;header_name&lt;/code&gt; 을 value &lt;code&gt;header_value&lt;/code&gt; 로 설정하여 기존 요청을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="636c214144f38969dedd2ffc5984f1e66f891c5a" translate="yes" xml:space="preserve">
          <source>Set the timeout value in milliseconds for subsequent socket operations (&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, and iterators returned from &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;).</source>
          <target state="translated">후속 소켓 조작 ( &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt; , &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; 및 &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; 에서 리턴 된 반복자)에 대한 제한 시간 값을 밀리 초 단위로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="050807acbb87dbae3d4b4a4b61e052706ebb33f2" translate="yes" xml:space="preserve">
          <source>Set the timeout value in milliseconds for subsequent socket operations (like &lt;a href=&quot;#udpsockreceive&quot;&gt;receive&lt;/a&gt;).</source>
          <target state="translated">후속 소켓 조작 (예 : &lt;a href=&quot;#udpsockreceive&quot;&gt;receive&lt;/a&gt; )에 대한 시간 종료 값을 밀리 초 단위로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b47cf55d380702ebb107e003eb19235c4bb7f46e" translate="yes" xml:space="preserve">
          <source>Set, add to, or clear the current request's &lt;code&gt;HEADER&lt;/code&gt; response header that is to be sent.</source>
          <target state="translated">전송할 현재 요청의 &lt;code&gt;HEADER&lt;/code&gt; 응답 헤더를 설정, 추가 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="2f17b4c675aba6498a00ebdd768065cc262c8dae" translate="yes" xml:space="preserve">
          <source>Sets the Lua C-module search path used by scripts specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; and others. The cpath string is in standard Lua cpath form, and &lt;code&gt;;;&lt;/code&gt; can be used to stand for the original cpath.</source>
          <target state="translated">&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; , &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 등으로 지정된 스크립트가 사용하는 Lua C 모듈 검색 경로를 설정합니다 . cpath 문자열은 표준 Lua cpath 형식이며 &lt;code&gt;;;&lt;/code&gt; 원래 cpath를 나타내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65713b479cd4156889a979ede6dd60d9817fe4da" translate="yes" xml:space="preserve">
          <source>Sets the Lua module search path used by scripts specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; and others. The path string is in standard Lua path form, and &lt;code&gt;;;&lt;/code&gt; can be used to stand for the original search paths.</source>
          <target state="translated">&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; , &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 등으로 지정된 스크립트가 사용하는 Lua 모듈 검색 경로를 설정합니다 . 경로 문자열은 표준 Lua 경로 형식이며 &lt;code&gt;;;&lt;/code&gt; 원래 검색 경로를 나타내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a16dfe9c7ec23027f4f4bd2de82f7121596ba40" translate="yes" xml:space="preserve">
          <source>Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations (&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;, &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, and iterators returned from &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;).</source>
          <target state="translated">후속 소켓 작업 ( &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt; , &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; , &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; 및 &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; 에서 반환 된 반복자)에 대해 연결 시간 초과 임계 값, 전송 시간 초과 임계 값 및 읽기 시간 초과 임계 값을 밀리 초 단위로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="22a4dd0a7b6a7ae8197af61e0d710e42f59a2001" translate="yes" xml:space="preserve">
          <source>Sets the verification depth in the server certificates chain.</source>
          <target state="translated">서버 인증서 체인의 검증 깊이를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="aef77a28e560cf0675044563dd256ae04ef39ade" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.header.HEADER&lt;/code&gt; after sending out response headers (either explicitly with &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or implicitly with &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; and similar) will log an error message.</source>
          <target state="translated">설정 &lt;code&gt;ngx.header.HEADER&lt;/code&gt; 를 (명시 적으로 중 응답 헤더를 보낸 후 &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; 또는 암시 적으로 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 및 이와 유사한 것은) 오류 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="585e1dfd9fedfbc89bd4a642247594d8bd2af8df" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.status&lt;/code&gt; after the response header is sent out has no effect but leaving an error message in your nginx's error log file:</source>
          <target state="translated">설정 &lt;code&gt;ngx.status&lt;/code&gt; 응답 헤더가 발송 된 후에는 효과하지만 당신의 nginx의 오류 로그 파일에 오류 메시지를 남겨이 없습니다 :</target>
        </trans-unit>
        <trans-unit id="030efca69708d382204ed9b58dc59503f3c9f6da" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.var.Foo&lt;/code&gt; to a &lt;code&gt;nil&lt;/code&gt; value will unset the &lt;code&gt;$Foo&lt;/code&gt; Nginx variable.</source>
          <target state="translated">설정 &lt;code&gt;ngx.var.Foo&lt;/code&gt; 을 A와 &lt;code&gt;nil&lt;/code&gt; 값은 설정 해제됩니다 &lt;code&gt;$Foo&lt;/code&gt; Nginx에 변수를.</target>
        </trans-unit>
        <trans-unit id="136da51c35a70d22f5c9f2da1806b476b0e0637d" translate="yes" xml:space="preserve">
          <source>Setting a slot to &lt;code&gt;nil&lt;/code&gt; effectively removes it from the response headers:</source>
          <target state="translated">슬롯을 &lt;code&gt;nil&lt;/code&gt; 로 설정 하면 응답 헤더에서 효과적으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0474ce3665f81a13c0c0317c30a63299c88afa56" translate="yes" xml:space="preserve">
          <source>Settings done by this method takes priority over those config directives, i.e., &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt;, &lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt;, and &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;.</source>
          <target state="translated">이 방법으로 수행 된 설정은 해당 구성 지시어, 즉 &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt; , &lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt; 및 &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout보다 우선&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="af3ffc082840108afe2affe27bbfa4480aa1fbdb" translate="yes" xml:space="preserve">
          <source>Settings done by this method takes priority over those config directives, like &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;.</source>
          <target state="translated">이 방법으로 수행 된 설정은 &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; 과 같은 구성 지시문보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="33524ec2b1f90de10e615bf443fd29b98ed89e54" translate="yes" xml:space="preserve">
          <source>Shared Dictionary API: &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">공유 사전 API : &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="978370756c27086eefc8b044220e251e54341fe2" translate="yes" xml:space="preserve">
          <source>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</source>
          <target state="translated">공유 메모리 영역은 항상 현재 nginx 서버 인스턴스의 모든 nginx 작업자 프로세스에서 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c59523c52a912196171b23d4cad823b478a16a54" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt;, but accepts the file path to a Lua source file or Lua bytecode file.</source>
          <target state="translated">&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt; 와 유사 하지만 Lua 소스 파일 또는 Lua 바이트 코드 파일의 파일 경로를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7cb0d398e5b4c38a10c3d6949f67c9b285d8688c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; but only returns the beginning index (&lt;code&gt;from&lt;/code&gt;) and end index (&lt;code&gt;to&lt;/code&gt;) of the matched substring. The returned indexes are 1-based and can be fed directly into the &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-string.sub&quot;&gt;string.sub&lt;/a&gt; API function to obtain the matched substring.</source>
          <target state="translated">&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 와 유사 하지만 일치하는 하위 문자열 의 시작 색인 ( &lt;code&gt;from&lt;/code&gt; ) 및 종료 색인 ( &lt;code&gt;to&lt;/code&gt; ) 만 반환합니다 . 리턴 된 인덱스는 1 기반이며 일치하는 하위 문자열을 얻기 위해 &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-string.sub&quot;&gt;string.sub&lt;/a&gt; API 함수에 직접 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f106a3c684f7fc0ea95d1745f4122867a726669" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; but only returns the beginning index (&lt;code&gt;from&lt;/code&gt;) and end index (&lt;code&gt;to&lt;/code&gt;) of the matched substring. The returned indexes are 1-based and can be fed directly into the &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-string.sub&quot;&gt;string.sub&lt;/a&gt; API function to obtain the matched substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352a600c32c28300072d08110bbef4ac25e0a611" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;, but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the &lt;code&gt;&amp;lt;subject&amp;gt;&lt;/code&gt; string argument with the PCRE &lt;code&gt;regex&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 와 유사 하지만 대신 Lua 반복자를 반환하여 사용자 프로그래머 가 PCRE &lt;code&gt;regex&lt;/code&gt; 를 사용하여 &lt;code&gt;&amp;lt;subject&amp;gt;&lt;/code&gt; 문자열 인수에 대한 모든 일치 항목을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f23aa11625fd22fc42eb57660368c3d212c61e77" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">이 지시문이 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 는 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; 지시문과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="b9f9c8b7047281b88288552c8203c823d4cb95a8" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">&lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt; 지시문과 유사 하지만이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신에 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="da2af6a416ef6224c9dbeb9a5f048a3c91bed8d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; 지시문과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="1534b9f8e714c53e1c6552d9988831a5057ffcc0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt; 지시문과 유사 하지만이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신에 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6d0b1e19fad18cc093c0598a66b0ed44c3571a23" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">이 지시문이 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; 지시문과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="0f46807ac6663e79087fc054f4d06773e5b26953" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt; 지시문과 유사 하지만이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신에 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="d764510b028caf7dbb6236194ab485eb58d561d9" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">이 지시문이 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신에 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt; 지시문과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="4a11cf1071908be1221383ad564822cd5112a94e" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; 메소드 와 유사 하지만 공유 메모리 영역의 스토리지가 부족할 때 상점에서 (최근에 사용한) 만료되지 않은 항목을 대체하지 않습니다. 이 경우 즉시 &lt;code&gt;nil&lt;/code&gt; 과 문자열 &quot;no memory&quot;를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="24da4f86bb8bcf68219097c2b33b59976391a4e9" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt; method but returns the value even if the key has already expired.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt; 메소드 와 유사 하지만 키가 이미 만료 된 경우에도 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a3b8ec56fa3211c0ef45499f18c8bd4233344761" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictlpush&quot;&gt;lpush&lt;/a&gt; method, but inserts the specified (numerical or string) &lt;code&gt;value&lt;/code&gt; at the tail of the list named &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictlpush&quot;&gt;lpush&lt;/a&gt; 메소드 와 유사 하지만 &lt;code&gt;key&lt;/code&gt; 라는 목록 의 끝에 지정된 (숫자 또는 문자열) &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0f1dbca90508a765c7da8efb048130eaba083847" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; 메소드 와 유사 하지만 공유 메모리 영역의 스토리지가 부족할 때 상점에서 (최근에 사용한) 만료되지 않은 항목을 대체하지 않습니다. 이 경우 즉시 &lt;code&gt;nil&lt;/code&gt; 과 문자열 &quot;no memory&quot;를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="cffee42d93390d67edfdba089f1bb41c9b691ea0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API function, but</source>
          <target state="translated">&lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API 함수와 유사 하지만</target>
        </trans-unit>
        <trans-unit id="65ef3fa553ce62ea7392a739609026bb7ca06475" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신 중괄호 쌍 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인한다는 점을 제외하고 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 지시문과 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="0cb7d3acef2ccff8f98e4ce7fb079207bcab4918" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; directive except that</source>
          <target state="translated">&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; 지시문 과 비슷 하지만</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
