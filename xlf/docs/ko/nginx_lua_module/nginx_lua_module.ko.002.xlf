<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nginx_lua_module">
    <body>
      <group id="nginx_lua_module">
        <trans-unit id="fd19f212fee4e1f793bdebc71c579667c1d9ffed" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create&quot;&gt;coroutine.create&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create&quot;&gt;coroutine.create&lt;/a&gt; API 와 유사 하지만 ngx_lua가 생성 한 Lua coroutine의 컨텍스트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="abeec72461dbd86196a2df49e71ede29e7798178" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume&quot;&gt;coroutine.resume&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume&quot;&gt;coroutine.resume&lt;/a&gt; API 와 유사 하지만 ngx_lua가 생성 한 Lua coroutine의 컨텍스트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="78010ee7daa3e2bd4ab094d2de04942d6ebe347e" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap&quot;&gt;coroutine.wrap&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap&quot;&gt;coroutine.wrap&lt;/a&gt; API 와 유사 하지만 ngx_lua가 생성 한 Lua coroutine의 컨텍스트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="44cfb6fec7a73bbbf8e3dc21c4669043c1f4919f" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield&quot;&gt;coroutine.yield&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">표준 Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield&quot;&gt;coroutine.yield&lt;/a&gt; API 와 유사 하지만 ngx_lua가 생성 한 Lua coroutine의 컨텍스트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fc4126e82e27cfd0bd96321ca6f849e4231e037c" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create&quot;&gt;coroutine.create&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee04a485bcc8d95be627e6f021c09e47cd181d94" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume&quot;&gt;coroutine.resume&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90df8514c4044f6d3460aee3aa99a002bbb27a1" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap&quot;&gt;coroutine.wrap&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcfc1aa367440ec6b3eb5427a1ba3e3186ed6901" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield&quot;&gt;coroutine.yield&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07958eaee11a6c0bba997479f92fbd7e2e3f86a2" translate="yes" xml:space="preserve">
          <source>Similarly, Nginx config</source>
          <target state="translated">마찬가지로 Nginx 설정</target>
        </trans-unit>
        <trans-unit id="12e5f5cf12f71667ff3409c62673b043f11cab80" translate="yes" xml:space="preserve">
          <source>Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the &lt;code&gt;luac&lt;/code&gt; commandline utility as shown:</source>
          <target state="translated">마찬가지로 ngx_lua와 함께 표준 Lua 5.1 인터프리터를 사용하는 경우 &lt;code&gt;luac&lt;/code&gt; 과 같이 luac 명령 줄 유틸리티를 사용하여 Lua 호환 바이트 코드 파일을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a856e6846e8b4073e471221248e04de15e34b684" translate="yes" xml:space="preserve">
          <source>Similarly, the following directives provided by &lt;a href=&quot;http://github.com/openresty/encrypted-session-nginx-module&quot;&gt;encrypted-session-nginx-module&lt;/a&gt; can be invoked from within Lua too:</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;http://github.com/openresty/encrypted-session-nginx-module&quot;&gt;encrypted-session-nginx-module에서&lt;/a&gt; 제공하는 다음 지시문 도 Lua 내에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="001436b8f6e84636cfc99dc4006152501f5a96fc" translate="yes" xml:space="preserve">
          <source>Similarly, the following directives provided by &lt;a href=&quot;https://github.com/openresty/encrypted-session-nginx-module&quot;&gt;encrypted-session-nginx-module&lt;/a&gt; can be invoked from within Lua too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b248a256a7a9510bdb3499e5ff809ca2d82a4d6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v0.8.3&lt;/code&gt; this function returns &lt;code&gt;1&lt;/code&gt; on success, or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">이후 &lt;code&gt;v0.8.3&lt;/code&gt; 이 함수 리턴 &lt;code&gt;1&lt;/code&gt; 성공 또는 복귀 &lt;code&gt;nil&lt;/code&gt; 하고, 그렇지 않으면 오류를 기술하는 문자열.</target>
        </trans-unit>
        <trans-unit id="b18a9990f544a1d0b6d5c1397202597ea48e6a16" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.6.9&lt;/code&gt; release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;0.6.9&lt;/code&gt; 릴리스 이후로, &lt;code&gt;raw&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )로 설정되어 있지 않은 한, 반환 된 Lua 테이블의 모든 헤더 이름은 기본적으로 순수한 소문자 형식으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d69ce11201e400cd85895b093071d277aadae953" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.7.20&lt;/code&gt; release, The &lt;code&gt;0&lt;/code&gt; time argument can also be specified.</source>
          <target state="translated">&lt;code&gt;0.7.20&lt;/code&gt; 릴리스 부터 &lt;code&gt;0&lt;/code&gt; 시간 인수도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5502b62197033b6f4ce57f00533a3d35bb5eb77" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.9.16&lt;/code&gt; release, an optional boolean-typed &lt;code&gt;no_padding&lt;/code&gt; argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to &lt;code&gt;false&lt;/code&gt;, i.e., with padding enabled).</source>
          <target state="translated">&lt;code&gt;0.9.16&lt;/code&gt; 릴리스 이후, 선택적 boolean-typed &lt;code&gt;no_padding&lt;/code&gt; 인수를 지정하여 base64 패딩을 결과 다이제스트에 추가해야하는지 여부를 제어 할 수 있습니다 (기본값은 &lt;code&gt;false&lt;/code&gt; , 즉 패딩이 활성화 된 상태).</target>
        </trans-unit>
        <trans-unit id="070ee59a56a6ad95645e5072a7dcf4e41b4bb037" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.9.3&lt;/code&gt; release, an optional 5th argument, &lt;code&gt;nth&lt;/code&gt;, is supported to specify which (submatch) capture's indexes to return. When &lt;code&gt;nth&lt;/code&gt; is 0 (which is the default), the indexes for the whole matched substring is returned; when &lt;code&gt;nth&lt;/code&gt; is 1, then the 1st submatch capture's indexes are returned; when &lt;code&gt;nth&lt;/code&gt; is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two &lt;code&gt;nil&lt;/code&gt; values will be returned. Below is an example for this:</source>
          <target state="translated">&lt;code&gt;0.9.3&lt;/code&gt; 릴리스 이후, 선택적 (5 번째) 인수 인 &lt;code&gt;nth&lt;/code&gt; 가 지원되어 캡처 할 인덱스를 지정하기 위해 지원됩니다. 때 &lt;code&gt;nth&lt;/code&gt; (디폴트) 0 전체 일치하는 하위 문자열의 인덱스를 반환; 때 &lt;code&gt;nth&lt;/code&gt; 1, 다음 1 submatch 캡처의 인덱스가 반환됩니다; 때 &lt;code&gt;nth&lt;/code&gt; 2, 다음 2 submatch 캡처 반환 등이다. 지정된 부분 일치에 일치하는 항목이 없으면 두 개의 &lt;code&gt;nil&lt;/code&gt; 값이 반환됩니다. 아래는 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="61e4b5917b2fec2373b25326528f336425506795" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.7.18&lt;/code&gt; release, connecting to a datagram unix domain socket file is also possible on Linux:</source>
          <target state="translated">&lt;code&gt;v0.7.18&lt;/code&gt; 릴리스 부터 Linux에서 데이터 그램 유닉스 도메인 소켓 파일에 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="210812f589792cb707bcf4b21ae05cf8653b5483" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.8.8&lt;/code&gt; release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</source>
          <target state="translated">&lt;code&gt;v0.8.8&lt;/code&gt; 릴리스 이후 로이 메소드는 읽기 시간 종료 오류가 발생하면 더 이상 현재 연결을 자동으로 닫지 않습니다. 다른 연결 오류의 경우이 방법은 항상 자동으로 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="fa2ca56726c04febc5e980583e98a176acf7e5eb" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.9.0&lt;/code&gt; release, this function accepts an optional boolean &lt;code&gt;raw&lt;/code&gt; argument. When this argument is &lt;code&gt;true&lt;/code&gt;, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;, and &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; methods.</source>
          <target state="translated">이후 &lt;code&gt;v0.9.0&lt;/code&gt; 의 출시,이 기능은 선택적 부울 받아 &lt;code&gt;raw&lt;/code&gt; 인수를. 이 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 ,이 함수는 원시 다운 스트림 연결 소켓을 감싸는 전이중 코 소켓 객체를 반환하며,이를 통해 &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; , &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; 및 &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f58b124b53b6bcd71b3599b330c2fa8d10290482" translate="yes" xml:space="preserve">
          <source>Sleeping API function &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;.</source>
          <target state="translated">잠자는 API 함수 &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27359c4bc78ac00841adea22743e9d0c89171f7b" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</source>
          <target state="translated">차단하지 않고 지정된 초 동안 대기합니다. 최대 0.001 초 (즉, 1 밀리 초)의 시간 해상도를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcaea81dce16b1cf54b7811c26aa438c76e61061" translate="yes" xml:space="preserve">
          <source>So even if the return value of the &lt;code&gt;free_space&lt;/code&gt; method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;forcible&lt;/code&gt; or non nil &lt;code&gt;err&lt;/code&gt; from the &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt;.</source>
          <target state="translated">의 반환 값 그래서 경우에도 &lt;code&gt;free_space&lt;/code&gt; 방법이 제로가 성공적으로받지 않고 공유 DICT에 새로운 키 값 쌍을 설정할 수 있도록, 이미 할당 된 페이지의 여지가있을 수 있습니다 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;forcible&lt;/code&gt; 또는 비 무기 호 &lt;code&gt;err&lt;/code&gt; 으로부터 &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e92df4b1ec1954469ddb78f2bfe169443436c7e4" translate="yes" xml:space="preserve">
          <source>So if the total number of workers is &lt;code&gt;N&lt;/code&gt;, then this method may return a number between 0 and &lt;code&gt;N - 1&lt;/code&gt; (inclusive).</source>
          <target state="translated">따라서 총 워커 수가 &lt;code&gt;N&lt;/code&gt; 이면이 메소드는 0과 &lt;code&gt;N - 1&lt;/code&gt; 사이의 숫자를 리턴 할 수 있습니다 (포함).</target>
        </trans-unit>
        <trans-unit id="84efbedcec6f11d239871ca18a28099a361421bc" translate="yes" xml:space="preserve">
          <source>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</source>
          <target state="translated">이 메소드를 호출하지 않은 소켓 오브젝트 (및 연관된 연결)는 소켓 오브젝트가 Lua GC (Garbage Collector)에 의해 해제되거나 현재 클라이언트 HTTP 요청이 처리를 완료하면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="da9e7f8bbe4de19071db0a2c4e2d02421a8b6d82" translate="yes" xml:space="preserve">
          <source>Some special nginx variables like &lt;code&gt;$args&lt;/code&gt; and &lt;code&gt;$limit_rate&lt;/code&gt; can be assigned a value, many others are not, like &lt;code&gt;$query_string&lt;/code&gt;, &lt;code&gt;$arg_PARAMETER&lt;/code&gt;, and &lt;code&gt;$http_NAME&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$args&lt;/code&gt; 및 &lt;code&gt;$limit_rate&lt;/code&gt; 와 같은 일부 특수 nginx 변수 에 값을 할당 할 수 있지만, &lt;code&gt;$query_string&lt;/code&gt; , &lt;code&gt;$arg_PARAMETER&lt;/code&gt; 및 &lt;code&gt;$http_NAME&lt;/code&gt; 과 같은 다른 많은 nginx 변수 에 값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23bafa371fcfd7ad9f80116e1d8ac3329001abeb" translate="yes" xml:space="preserve">
          <source>Spawns a new user &quot;light thread&quot; with the Lua function &lt;code&gt;func&lt;/code&gt; as well as those optional arguments &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, and etc. Returns a Lua thread (or Lua coroutine) object represents this &quot;light thread&quot;.</source>
          <target state="translated">Lua 함수 &lt;code&gt;func&lt;/code&gt; 및 선택적 인수 &lt;code&gt;arg1&lt;/code&gt; , &lt;code&gt;arg2&lt;/code&gt; 등을 사용하여 새 사용자 &quot;light thread&quot;를 생성합니다 . Lua 스레드 (또는 Lua coroutine) 객체는이 &quot;light thread&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b26851b1e02485c8402ed45e82946b5e8b4e49f4" translate="yes" xml:space="preserve">
          <source>Special Escaping Sequences</source>
          <target state="translated">특수 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="5cb52b844506853e4a52ad9c6f20086d874f14dd" translate="yes" xml:space="preserve">
          <source>Special PCRE Sequences</source>
          <target state="translated">특수 PCRE 시퀀스</target>
        </trans-unit>
        <trans-unit id="87e4093eff26b9142f958fcee21b9d4f56a5d1a4" translate="yes" xml:space="preserve">
          <source>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock : sslhandshake&lt;/a&gt; 메소드 에서 SSL / TLS 서버의 인증서를 확인하는 데 사용되는 PEM 형식의 신뢰할 수있는 CA 인증서가있는 파일 경로를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c347c78b21148a184b1541a95d7738ad4d4964bb" translate="yes" xml:space="preserve">
          <source>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock : sslhandshake&lt;/a&gt; 메소드 에서 SSL / TLS 서버의 인증서를 확인하는 데 사용되는 PEM 형식의 해지 된 인증서 (CRL)가있는 파일을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f13e6d25b00a0894c6bf2e21f820b44a958897e7" translate="yes" xml:space="preserve">
          <source>Specifies the &quot;match limit&quot; used by the PCRE library when executing the &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API&lt;/a&gt;. To quote the PCRE manpage, &quot;the limit ... has the effect of limiting the amount of backtracking that can take place.&quot;</source>
          <target state="translated">&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API를&lt;/a&gt; 실행할 때 PCRE 라이브러리가 사용하는 &quot;일치 제한&quot;을 지정합니다 . PCRE 맨 페이지를 인용하자면, &quot;제한은 발생 가능한 역 추적의 양을 제한하는 효과가 있습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="06604fef4a9a0145840989ba5d3f572ef573fc4d" translate="yes" xml:space="preserve">
          <source>Specifies the buffer size used by cosocket reading operations.</source>
          <target state="translated">코 소켓 읽기 조작에 사용되는 버퍼 크기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="86f57a1ce0e0207ebdd37f76c124f3c3408b8d46" translate="yes" xml:space="preserve">
          <source>Specifies the enabled ciphers for requests to a SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method. The ciphers are specified in the format understood by the OpenSSL library.</source>
          <target state="translated">&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock : sslhandshake&lt;/a&gt; 메소드 에서 SSL / TLS 서버에 대한 요청에 사용 가능한 암호를 지정합니다 . 암호는 OpenSSL 라이브러리가 이해하는 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="40bf5d4700cdb8bb9cbbbf1f6fe23f6536bf9f48" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</source>
          <target state="translated">작업자 프로세스 수준 컴파일 된 정규식 캐시에 허용되는 최대 항목 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d63539570ca6ce5791e9cfd872d9cd907599e94" translate="yes" xml:space="preserve">
          <source>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</source>
          <target state="translated">모든 원격 서버와 연관된 모든 코 소켓 연결 풀 (예 : 호스트 포트 쌍 또는 유닉스 도메인 소켓 파일 경로로 식별)에 대한 크기 제한 (연결 수로 표시)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0b1ce80ed42032256c9f54372fef7910c76cd177" translate="yes" xml:space="preserve">
          <source>Specifies whether to use the MIME type specified by the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt; directive for the default value of the &lt;code&gt;Content-Type&lt;/code&gt; response header. Deactivate this directive if a default &lt;code&gt;Content-Type&lt;/code&gt; response header for Lua request handlers is not desired.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; 응답 헤더 의 기본값으로 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt; 지시문으로 지정된 MIME 유형을 사용할지 여부를 지정합니다 . Lua 요청 핸들러에 대한 기본 &lt;code&gt;Content-Type&lt;/code&gt; 응답 헤더가 필요하지 않은 경우이 지정 문을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="10cf417f497f1c05b72d514d6f810b39bc3fc81b" translate="yes" xml:space="preserve">
          <source>Specifies whether to use the MIME type specified by the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt; directive for the default value of the &lt;code&gt;Content-Type&lt;/code&gt; response header. Deactivate this directive if a default &lt;code&gt;Content-Type&lt;/code&gt; response header for Lua request handlers is not desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0959c81ee3e6fc80a3d3e5ab47968630562045fd" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;options&lt;/code&gt; to control how the match operation will be performed. The following option characters are supported:</source>
          <target state="translated">일치 작업 수행 방법을 제어하는 &lt;code&gt;options&lt;/code&gt; 을 지정하십시오 . 다음과 같은 옵션 문자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6d97a1abd47827fe6b7bb1892f23c3c510c5e353" translate="yes" xml:space="preserve">
          <source>Starting from NGINX 1.9.11, you can also compile this module as a dynamic module, by using the &lt;code&gt;--add-dynamic-module=PATH&lt;/code&gt; option instead of &lt;code&gt;--add-module=PATH&lt;/code&gt; on the &lt;code&gt;./configure&lt;/code&gt; command line above. And then you can explicitly load the module in your &lt;code&gt;nginx.conf&lt;/code&gt; via the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#load_module&quot;&gt;load_module&lt;/a&gt; directive, for example,</source>
          <target state="translated">NGINX 1.9.11부터 위 의 &lt;code&gt;./configure&lt;/code&gt; 명령 행 에서 &lt;code&gt;--add-module=PATH&lt;/code&gt; 대신 &lt;code&gt;--add-dynamic-module=PATH&lt;/code&gt; 옵션 을 사용하여이 모듈을 동적 모듈로 컴파일 할 수도 있습니다 . 그런 다음 &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#load_module&quot;&gt;load_module&lt;/a&gt; 지시문을 통해 &lt;code&gt;nginx.conf&lt;/code&gt; 에 모듈을 명시 적으로로드 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="96d90dc987ae882f61515e450d16a2c3a1f9b185" translate="yes" xml:space="preserve">
          <source>Starting from NGINX 1.9.11, you can also compile this module as a dynamic module, by using the &lt;code&gt;--add-dynamic-module=PATH&lt;/code&gt; option instead of &lt;code&gt;--add-module=PATH&lt;/code&gt; on the &lt;code&gt;./configure&lt;/code&gt; command line above. And then you can explicitly load the module in your &lt;code&gt;nginx.conf&lt;/code&gt; via the &lt;a href=&quot;https://nginx.org/en/docs/ngx_core_module.html#load_module&quot;&gt;load_module&lt;/a&gt; directive, for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd047172ef41316b0bac25a882f8035d82009cfc" translate="yes" xml:space="preserve">
          <source>Starting from the &lt;code&gt;0.9.4&lt;/code&gt; release, this function also accepts a 5th argument, &lt;code&gt;res_table&lt;/code&gt;, for letting the caller supply the Lua table used to hold all the capturing results. Starting from &lt;code&gt;0.9.6&lt;/code&gt;, it is the caller's responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.</source>
          <target state="translated">으로부터 시작 &lt;code&gt;0.9.4&lt;/code&gt; 릴리스,이 기능은 또한 5 인수 받아 &lt;code&gt;res_table&lt;/code&gt; 를 루아 테이블은 모든 캡처 결과를 보유하는 데 사용되는 발신자 공급 해줘서. 에서 시작 &lt;code&gt;0.9.6&lt;/code&gt; ,이 테이블이 비어 보장하는 호출자의 책임입니다. 이는 Lua 테이블을 재활용하고 GC 및 테이블 할당 오버 헤드를 절약하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8188f412359ca9aadcb16bd9ce5726504d5da177" translate="yes" xml:space="preserve">
          <source>Starting from the &lt;code&gt;0.9.9&lt;/code&gt; release, the cosocket object here is full-duplex, that is, a reader &quot;light thread&quot; and a writer &quot;light thread&quot; can operate on a single cosocket object simultaneously (both &quot;light threads&quot; must belong to the same Lua handler though, see reasons above). But you cannot have two &quot;light threads&quot; both reading (or writing or connecting) the same cosocket, otherwise you might get an error like &quot;socket busy reading&quot; when calling the methods of the cosocket object.</source>
          <target state="translated">&lt;code&gt;0.9.9&lt;/code&gt; 릴리스 부터 여기의 코 소켓 객체는 전이중입니다. 즉, 리더 &quot;light thread&quot;와 기록기 &quot;light thread&quot;는 단일 코 소켓 객체에서 동시에 작동 할 수 있습니다 ( &quot;light thread&quot;는 모두 동일한 루아 핸들러이지만 위의 이유를 참조하십시오). 그러나 동일한 코 소켓을 읽거나 쓰는 또는 연결하는 두 개의 &quot;가벼운 스레드&quot;를 가질 수는 없습니다. 그렇지 않으면 cosocket 오브젝트의 메소드를 호출 할 때 &quot;소켓 사용 중 읽기&quot;와 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3754b62dc11d04cbf2fb007d2860b9e46b74987b" translate="yes" xml:space="preserve">
          <source>Starting from the &lt;code&gt;v0.9.20&lt;/code&gt; release, you can use the &lt;a href=&quot;#access_by_lua_no_postpone&quot;&gt;access_by_lua_no_postpone&lt;/a&gt; directive to control when to run this handler inside the &quot;access&quot; request-processing phase of NGINX.</source>
          <target state="translated">&lt;code&gt;v0.9.20&lt;/code&gt; 릴리스 부터 &lt;a href=&quot;#access_by_lua_no_postpone&quot;&gt;access_by_lua_no_postpone&lt;/a&gt; 지시문을 사용하여 NGINX 의 &quot;access&quot;요청 처리 단계에서이 핸들러를 실행할시기를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d233fcff5bc1867bd9d5514a5dd9b82f8d0f470" translate="yes" xml:space="preserve">
          <source>Starting from the &lt;code&gt;v0.9.3&lt;/code&gt; release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.</source>
          <target state="translated">&lt;code&gt;v0.9.3&lt;/code&gt; 릴리스 부터는 Nginx 작업자 프로세스가 종료되기 시작하더라도 지연없는 타이머를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43325a86a3290343a7b6d2383ea8fc34a5c4fb5c" translate="yes" xml:space="preserve">
          <source>Statically Linking Pure Lua Modules</source>
          <target state="translated">Pure Lua 모듈을 정적으로 링크</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="b5c31820448a1cc654eb35adc849402604b926fd" translate="yes" xml:space="preserve">
          <source>Subrequest API functions (e.g., &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;)</source>
          <target state="translated">하위 요청 API 함수 (예 : &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 및 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0da95ef5b3e8cbe834405da7799c46e5c90af20f" translate="yes" xml:space="preserve">
          <source>Subrequests are all internal requests and so are requests after internal redirects.</source>
          <target state="translated">하위 요청은 모두 내부 요청이므로 내부 리디렉션 후 요청도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcf9a9cb9ce4859c5b4eaaf635c977bb2497c64" translate="yes" xml:space="preserve">
          <source>Subrequests are completely different from HTTP 301/302 redirection (via &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;) and internal redirection (via &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;).</source>
          <target state="translated">하위 요청은 HTTP 삼공 일 삼공이 재 지정 (를 통해 완전히 다른 &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; ) 및 내부 리디렉션 (를 통해 &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbfae1f89c006fe6a04d0de6c95337dfa35d7644" translate="yes" xml:space="preserve">
          <source>Substitutes the first match of the Perl compatible regular expression &lt;code&gt;regex&lt;/code&gt; on the &lt;code&gt;subject&lt;/code&gt; argument string with the string or function argument &lt;code&gt;replace&lt;/code&gt;. The optional &lt;code&gt;options&lt;/code&gt; argument has exactly the same meaning as in &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;.</source>
          <target state="translated">펄 호환 정규 표현식의 첫 번째 일치 대체 &lt;code&gt;regex&lt;/code&gt; 온 &lt;code&gt;subject&lt;/code&gt; 문자열 또는 함수 인수를 인수 문자열이 &lt;code&gt;replace&lt;/code&gt; . 선택적 &lt;code&gt;options&lt;/code&gt; 인수는 &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 와 정확히 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="19c1b54fc653f618f98d03381525319c3151ac7c" translate="yes" xml:space="preserve">
          <source>System Environment Variable Support</source>
          <target state="translated">시스템 환경 변수 지원</target>
        </trans-unit>
        <trans-unit id="2445d212dd8a165e440cc6272fb3d2014d678771" translate="yes" xml:space="preserve">
          <source>TCP socket connect operation issues</source>
          <target state="translated">TCP 소켓 연결 작업 문제</target>
        </trans-unit>
        <trans-unit id="4dcff10d1557d276c63c24add6ad5a5118d4e375" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">이 소프트웨어는 저작권 소유자 및 배포자에 의해 &quot;있는 그대로&quot;제공되며, 명시 적 또는 묵시적 보증을 포함하되 이에 국한되지는 않지만 상품성 및 특정 목적에의 적합성에 대한 묵시적 보증은 이에 제한되지 않습니다. 어떠한 경우에도 저작권 소유자 또는 제공자는 직접적, 간접적, 우발적, 특수 적, 간접적 또는 결과적 손해에 대해 책임을지지 않습니다 (대체 상품 또는 서비스의 제조, 데이터 손실, 사용 손실, 데이터 손실). 또는 비즈니스 중단) 계약, 엄격 책임 또는 불법 행위 (어떠한 태만 또는 기타 포함)에 관계없이 본 소프트웨어를 사용하지 않더라도 본 소프트웨어를 사용하지 않더라도 발생하는 책임 이론에 따라 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="5afaaf7fc8cf263d64f0d4b1181dc0a418e30923" translate="yes" xml:space="preserve">
          <source>Test Suite</source>
          <target state="translated">테스트 스위트</target>
        </trans-unit>
        <trans-unit id="435d4dc03c4fcc195eb1904ee0cf588ca79ba0eb" translate="yes" xml:space="preserve">
          <source>Test::Nginx: &lt;a href=&quot;https://github.com/openresty/test-nginx&quot;&gt;https://github.com/openresty/test-nginx&lt;/a&gt;</source>
          <target state="translated">테스트 : : Nginx : &lt;a href=&quot;https://github.com/openresty/test-nginx&quot;&gt;https://github.com/openresty/test-nginx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7bad68b72932112df5e9be8360037a493e4f094e" translate="yes" xml:space="preserve">
          <source>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;.</source>
          <target state="translated">즉, 클라이언트 IP 주소가 블랙리스트에 있으면 더 복잡한 인증을위한 MySQL 쿼리가 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua에&lt;/a&gt; 의해 실행되기 전에 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="e708f550a9148bbb2e6d9be6706841b4a4ca6e2f" translate="yes" xml:space="preserve">
          <source>That is, let the caller pass the &lt;code&gt;ctx&lt;/code&gt; table explicitly via a function argument.</source>
          <target state="translated">즉, 호출자 가 함수 인수를 통해 명시 적으로 &lt;code&gt;ctx&lt;/code&gt; 테이블을 전달하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="5493df2ae5f32fd9400dbae91089d020bf0fd927" translate="yes" xml:space="preserve">
          <source>That is, nginx variables cannot be created on-the-fly.</source>
          <target state="translated">즉, nginx 변수는 즉석에서 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8c646775cdbe741c7d0fa48f53c2af56fcebe12" translate="yes" xml:space="preserve">
          <source>That is, the &lt;code&gt;ngx.ctx.foo&lt;/code&gt; entry persists across the rewrite, access, and content phases of a request.</source>
          <target state="translated">즉, &lt;code&gt;ngx.ctx.foo&lt;/code&gt; 항목은 요청의 재 작성, 액세스 및 컨텐츠 단계에서 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="5e681db9aa3b3a123203188035ed51abac7ddcd4" translate="yes" xml:space="preserve">
          <source>That is, they will take Lua boolean values &lt;code&gt;true&lt;/code&gt;. However, they are different from arguments taking empty string values. &lt;code&gt;GET /test?foo=&amp;amp;bar=&lt;/code&gt; will give something like</source>
          <target state="translated">즉, Lua 부울 값을 &lt;code&gt;true&lt;/code&gt; 로 사용합니다 . 그러나 빈 문자열 값을 사용하는 인수와 다릅니다. &lt;code&gt;GET /test?foo=&amp;amp;bar=&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="73ce2573625f9f18760b9457c33f852d6b92195c" translate="yes" xml:space="preserve">
          <source>That is, they will take Lua boolean values &lt;code&gt;true&lt;/code&gt;. However, they are different from arguments taking empty string values. &lt;code&gt;POST /test&lt;/code&gt; with request body &lt;code&gt;foo=&amp;amp;bar=&lt;/code&gt; will return something like</source>
          <target state="translated">즉, Lua 부울 값을 &lt;code&gt;true&lt;/code&gt; 로 사용합니다 . 그러나 빈 문자열 값을 사용하는 인수와 다릅니다. &lt;code&gt;POST /test&lt;/code&gt; 요청 몸에 &lt;code&gt;foo=&amp;amp;bar=&lt;/code&gt; 같은를 반환합니다</target>
        </trans-unit>
        <trans-unit id="5bef08c1ba2460b80114090440c67a0cdab88e83" translate="yes" xml:space="preserve">
          <source>That is, when the body filter sees a chunk containing the word &quot;hello&quot;, then it will set the &quot;eof&quot; flag to true immediately, resulting in truncated but still valid responses.</source>
          <target state="translated">즉, 본문 필터에 &quot;hello&quot;라는 단어가 포함 된 청크가 있으면 &quot;eof&quot;플래그가 즉시 true로 설정되어 잘리지 만 여전히 유효한 응답이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ea935d39893850ddbceb419931f91f6a6d2dd309" translate="yes" xml:space="preserve">
          <source>The &quot;light threads&quot; are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A &quot;light thread&quot; will keep running exclusively on the CPU until</source>
          <target state="translated">&quot;가벼운 스레드&quot;는 선제 적으로 예약되지 않습니다. 즉, 자동으로 시간 분할이 수행되지 않습니다. &quot;가벼운 스레드&quot;는 CPU에서 독점적으로 계속 실행될 것입니다.</target>
        </trans-unit>
        <trans-unit id="493b2481a63d9217b544d8a7a168c58c50232740" translate="yes" xml:space="preserve">
          <source>The &quot;parent coroutine&quot; can call &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt; to wait on the termination of its child &quot;light thread&quot;.</source>
          <target state="translated">&quot;parent coroutine&quot;은 &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt; 를 호출 하여 자식 &quot;light thread&quot;의 종료를 기다릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce93b6e218087946ad570aa3fbcb3b98328dd976" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; directives cannot capture locations that include the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_before_body&quot;&gt;add_before_body&lt;/a&gt;, &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_after_body&quot;&gt;add_after_body&lt;/a&gt;, &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request&quot;&gt;auth_request&lt;/a&gt;, &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_location&quot;&gt;echo_location&lt;/a&gt;, &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_location_async&quot;&gt;echo_location_async&lt;/a&gt;, &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_subrequest&quot;&gt;echo_subrequest&lt;/a&gt;, or &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_subrequest_async&quot;&gt;echo_subrequest_async&lt;/a&gt; directives.</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 및 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 지시 할 수 없습니다 인클루드 캡처 위치 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_before_body&quot;&gt;add_before_body&lt;/a&gt; , &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_addition_module.html#add_after_body&quot;&gt;add_after_body&lt;/a&gt; , &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request&quot;&gt;auth_request&lt;/a&gt; , &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_location&quot;&gt;echo_location&lt;/a&gt; , &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_location_async&quot;&gt;echo_location_async&lt;/a&gt; , &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_subrequest&quot;&gt;echo_subrequest&lt;/a&gt; , 또는 &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_subrequest_async&quot;&gt;echo_subrequest_async의&lt;/a&gt; 지시를.</target>
        </trans-unit>
        <trans-unit id="ed9bc7845d89e1a92593d086dfc039e7de1fa2f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; directives cannot capture locations that include the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_addition_module.html#add_before_body&quot;&gt;add_before_body&lt;/a&gt;, &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_addition_module.html#add_after_body&quot;&gt;add_after_body&lt;/a&gt;, &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request&quot;&gt;auth_request&lt;/a&gt;, &lt;a href=&quot;https://github.com/openresty/echo-nginx-module#echo_location&quot;&gt;echo_location&lt;/a&gt;, &lt;a href=&quot;https://github.com/openresty/echo-nginx-module#echo_location_async&quot;&gt;echo_location_async&lt;/a&gt;, &lt;a href=&quot;https://github.com/openresty/echo-nginx-module#echo_subrequest&quot;&gt;echo_subrequest&lt;/a&gt;, or &lt;a href=&quot;https://github.com/openresty/echo-nginx-module#echo_subrequest_async&quot;&gt;echo_subrequest_async&lt;/a&gt; directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f281a1d124ecac51bb9032c508f80b880e67448" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; function is just a special form of this function. Logically speaking, the &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; can be implemented like this</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture의&lt;/a&gt; 기능은이 기능의 단지 특별한 형태입니다. 논리적으로 말하자면 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2764a1f9a0364748e73368ac778234da9930f9f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tcpsockconnect&quot;&gt;tcpsock:connect&lt;/a&gt; method may indicate &lt;code&gt;success&lt;/code&gt; despite connection failures such as with &lt;code&gt;Connection Refused&lt;/code&gt; errors.</source>
          <target state="translated">&lt;a href=&quot;#tcpsockconnect&quot;&gt;tcpsock : 연결&lt;/a&gt; 방법은 표시 할 수있다 &lt;code&gt;success&lt;/code&gt; 등과 같은 연결 실패에도 불구하고 &lt;code&gt;Connection Refused&lt;/code&gt; 오류를.</target>
        </trans-unit>
        <trans-unit id="128c00acadfcb8dee9b0cf4df11662619e8544da" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; and &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; Lua modules provided by the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/#readme&quot;&gt;lua-resty-core&lt;/a&gt; library are particularly useful in this context. You can use the Lua API offered by these two Lua modules to manipulate the SSL certificate chain and private key for the current SSL connection being initiated.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; 의해 제공 루아 모듈 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/#readme&quot;&gt;LUA-resty 코어&lt;/a&gt; 라이브러리는 이러한 상황에 특히 유용하다. 이 두 Lua 모듈에서 제공하는 Lua API를 사용하여 시작중인 현재 SSL 연결에 대한 SSL 인증서 체인 및 개인 키를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef8e570e76d1ecadf9727b0d395ddc003718e1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://groups.google.com/group/openresty&quot;&gt;openresty&lt;/a&gt; mailing list is for Chinese speakers.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/group/openresty&quot;&gt;openresty&lt;/a&gt; 메일 링리스트 중국 스피커입니다.</target>
        </trans-unit>
        <trans-unit id="0d0549dfd3bfead6565f08db864ffc05c4488458" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://groups.google.com/group/openresty-en&quot;&gt;openresty-en&lt;/a&gt; mailing list is for English speakers.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/group/openresty-en&quot;&gt;openresty 엔&lt;/a&gt; 메일 링리스트 영어 스피커입니다.</target>
        </trans-unit>
        <trans-unit id="2d6b5dc4704498221f954adb82eb433bfeff45cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; argument accepts size units such as &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; 인수 같은 크기 단위 받아 &lt;code&gt;k&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="2b48b3d5f83cc902c237a27cd6f18b6aa9be2766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; argument can be an integer, with an optional time unit, like &lt;code&gt;s&lt;/code&gt; (second), &lt;code&gt;ms&lt;/code&gt; (millisecond), &lt;code&gt;m&lt;/code&gt; (minute). The default time unit is &lt;code&gt;s&lt;/code&gt;, i.e., &quot;second&quot;. The default setting is &lt;code&gt;60s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 인자와 같은 임의의 시간 단위로 정수가 될 수 &lt;code&gt;s&lt;/code&gt; (초), &lt;code&gt;ms&lt;/code&gt; (밀리 초), &lt;code&gt;m&lt;/code&gt; (분). 기본 시간 단위는 &lt;code&gt;s&lt;/code&gt; 입니다 (예 : &quot;초&quot;). 기본 설정은 &lt;code&gt;60s&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f76efab7264944ace4a773d3600bc12c74e84e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-bg&lt;/code&gt; option can be used to include debug information in the LuaJIT bytecode file:</source>
          <target state="translated">&lt;code&gt;-bg&lt;/code&gt; 옵션은 LuaJIT 바이트 코드 파일에 디버그 정보를 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="21883fff5622c3e898fee979cdc9ef400c32999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__index&lt;/code&gt; metamethod will not be added when the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; 의 때 메타 메소드는 추가되지 않습니다 &lt;code&gt;raw&lt;/code&gt; 인수로 설정되어 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c829f5f90628bb0149ea6c6570e3deeed7ca45ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; option can also take plain query strings:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 옵션은 일반 쿼리 문자열을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b02b7c7997642c21bbf45769fefa0d3fb6a22daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; option can specify extra URI arguments, for instance,</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 옵션은, 예를 들어, 별도의 URI 인수를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7cf89182bfe3b5c370dd6b4402e93f39f73497e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy_all_vars&lt;/code&gt; option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.</source>
          <target state="translated">&lt;code&gt;copy_all_vars&lt;/code&gt; 의 같은 하위 요청이 발행 될 때 옵션은 하위 요청에 부모 요청의 Nginx의 변수의 복사본을 제공합니다. 이러한 하위 요청으로 이러한 변수를 변경해도 상위 요청 또는 상위 요청 변수를 공유하는 다른 하위 요청에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64a2f8629ee28bea3f9b37887e862b0413017d80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctx&lt;/code&gt; option can be used to specify a custom Lua table to serve as the &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table for the subrequest.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 옵션은 역할을 사용자 정의 루아 테이블을 지정하는 데 사용할 수 있습니다 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; subrequest 표.</target>
        </trans-unit>
        <trans-unit id="15c398712669d39171da9aab72b931534b30e037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctx&lt;/code&gt; table argument combined with the &lt;code&gt;a&lt;/code&gt; regex modifier can be used to construct a lexer atop &lt;code&gt;ngx.re.match&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 조합 테이블 인수 정규식 개질제 꼭대기 렉서 구성하는데 사용될 수있다 &lt;code&gt;ngx.re.match&lt;/code&gt; 를 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5fbd9fbeb1267a7c66218710fa3f024fe4c22b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exptime&lt;/code&gt; argument has a resolution of &lt;code&gt;0.001&lt;/code&gt; seconds. If &lt;code&gt;exptime&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then the item will never expire.</source>
          <target state="translated">&lt;code&gt;exptime&lt;/code&gt; 의 인수의 해상도가 &lt;code&gt;0.001&lt;/code&gt; 초. 경우 &lt;code&gt;exptime&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; , 다음 항목이 만료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2d5e7004de781376a95603f21c22043e3c96177" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forcible&lt;/code&gt; return value will always be &lt;code&gt;nil&lt;/code&gt; when the &lt;code&gt;init&lt;/code&gt; argument is not specified.</source>
          <target state="translated">&lt;code&gt;forcible&lt;/code&gt; 반환 값은 항상있을 것입니다 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;init&lt;/code&gt; 인수가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b835260dffc4e81e440d5115662c814d87dca546" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header_value&lt;/code&gt; can take an array list of values, for example,</source>
          <target state="translated">&lt;code&gt;header_value&lt;/code&gt; , 예를 들어, 값의 배열리스트를 취할 수</target>
        </trans-unit>
        <trans-unit id="ee36ae2e8ff0e8c0882ad839a0f6dd84b566d5fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inclusive&lt;/code&gt; takes a boolean value to control whether to include the pattern string in the returned data string. Default to &lt;code&gt;false&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;inclusive&lt;/code&gt; 반환 된 데이터 문자열 패턴 문자열을 포함할지 여부를 제어하는 부울 값을 취한다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a53311b2abbb60ba9f29e777a244583b3b78a8b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jump&lt;/code&gt; argument can only be set to &lt;code&gt;true&lt;/code&gt; in &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt;. Use of jump in other contexts is prohibited and will throw out a Lua exception.</source>
          <target state="translated">&lt;code&gt;jump&lt;/code&gt; 인수에만 설정할 수 있습니다 &lt;code&gt;true&lt;/code&gt; 에 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua의 *&lt;/a&gt; . 다른 상황에서 점프를 사용하는 것은 금지되어 있으며 루아 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a6b4d06dbc5cea80082f83b73fa6ab27519ec77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_level&lt;/code&gt; argument can take constants like &lt;code&gt;ngx.ERR&lt;/code&gt; and &lt;code&gt;ngx.WARN&lt;/code&gt;. Check out &lt;a href=&quot;#nginx-log-level-constants&quot;&gt;Nginx log level constants&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;log_level&lt;/code&gt; 인수는 같은 상수 걸릴 수 &lt;code&gt;ngx.ERR&lt;/code&gt; 및 &lt;code&gt;ngx.WARN&lt;/code&gt; 을 . 확인 &lt;a href=&quot;#nginx-log-level-constants&quot;&gt;Nginx의 로그 수준 상수를&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="56c682298710169cd66ca20a1047ce3229128ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mydata&lt;/code&gt; module in this example will only be loaded and run on the first request to the location &lt;code&gt;/lua&lt;/code&gt;, and all subsequent requests to the same nginx worker process will use the reloaded instance of the module as well as the same copy of the data in it, until a &lt;code&gt;HUP&lt;/code&gt; signal is sent to the Nginx master process to force a reload. This data sharing technique is essential for high performance Lua applications based on this module.</source>
          <target state="translated">이 예제 의 &lt;code&gt;mydata&lt;/code&gt; 모듈은 첫 번째 요청에서만 &lt;code&gt;/lua&lt;/code&gt; 위치로로드 및 실행되며 동일한 nginx 작업자 프로세스에 대한 모든 후속 요청은 모듈의 다시로드 된 인스턴스와 동일한 데이터 사본을 사용합니다. &lt;code&gt;HUP&lt;/code&gt; 신호가 Nginx 마스터 프로세스로 전송 될 때까지 강제로 다시로드됩니다. 이 데이터 공유 기술은이 모듈을 기반으로 한 고성능 Lua 애플리케이션에 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="1296364b974d29b718fe0aca669244d08aa2a3f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngx.DECLINED&lt;/code&gt; constant was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;ngx.DECLINED&lt;/code&gt; 의 상수는 처음에 도입 된 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 의 릴리스.</target>
        </trans-unit>
        <trans-unit id="67f3d4e2ec0b9fd970bac65a6443b6be33b09cad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngx.ctx&lt;/code&gt; lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.</source>
          <target state="translated">&lt;code&gt;ngx.ctx&lt;/code&gt; 조회 상대적으로 비싼 메타 메서드 호출을 필요로하며, 명시 적으로 자신의 함수 인수에 의해 함께 당 요청 데이터를 전달하는 것보다 훨씬 느립니다. 따라서 일반적으로 성능에 약간의 영향을 미치기 때문에 자신의 함수 인수를 저장하는 데이 API를 남용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e689016fc7ca45feb6b9e99f973648d06c7875e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngx.null&lt;/code&gt; constant is a &lt;code&gt;NULL&lt;/code&gt; light userdata usually used to represent nil values in Lua tables etc and is similar to the &lt;a href=&quot;http://www.kyne.com.au/%7Emark/software/lua-cjson.php&quot;&gt;lua-cjson&lt;/a&gt; library's &lt;code&gt;cjson.null&lt;/code&gt; constant. This constant was first introduced in the &lt;code&gt;v0.5.0rc5&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;ngx.null&lt;/code&gt; 상수는이다 &lt;code&gt;NULL&lt;/code&gt; 보통 루아 테이블 등의 전무 값을 나타내는 데 사용되는 빛 유저 데이터와 유사하다 &lt;a href=&quot;http://www.kyne.com.au/%7Emark/software/lua-cjson.php&quot;&gt;루아 - cjson의&lt;/a&gt; 라이브러리의 &lt;code&gt;cjson.null&lt;/code&gt; 의 정수입니다. 이 상수는 &lt;code&gt;v0.5.0rc5&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="08d5223bcfdd0a972c3b45f974e90f0662f4d905" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</source>
          <target state="translated">&lt;code&gt;ngx.null&lt;/code&gt; 의 상수는 얻을 것 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 문자열 출력을.</target>
        </trans-unit>
        <trans-unit id="0455d47d04582d1aed2521c4ef684e4fd443fbef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o&lt;/code&gt; option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the &lt;a href=&quot;#lua_regex_cache_max_entries&quot;&gt;lua_regex_cache_max_entries&lt;/a&gt; directive.</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; 문제의 정규식 패턴은 작업자 프로세스 수준에 캐시 한 번 컴파일, 현재 Nginx의 작업자 프로세스의 모든 요청 사이에서 공유되기 때문에 옵션은 성능 조정에 유용합니다. 정규식 캐시의 상한은 &lt;a href=&quot;#lua_regex_cache_max_entries&quot;&gt;lua_regex_cache_max_entries&lt;/a&gt; 지시문을 통해 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14ee349283a58921fe2da7220f2d0c155803b005" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless &lt;a href=&quot;#rewrite_by_lua_no_postpone&quot;&gt;rewrite_by_lua_no_postpone&lt;/a&gt; is turned on.</source>
          <target state="translated">&lt;code&gt;rewrite_by_lua&lt;/code&gt; 의 코드는 항상의 끝에서 실행됩니다 &lt;code&gt;rewrite&lt;/code&gt; 하지 않는 한 요청 처리 단계 &lt;a href=&quot;#rewrite_by_lua_no_postpone&quot;&gt;rewrite_by_lua_no_postpone이&lt;/a&gt; 켜집니다.</target>
        </trans-unit>
        <trans-unit id="c84b0d172e23979ee7fbb19ab54edc10eb1372f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rewrite_by_lua_file&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless &lt;a href=&quot;#rewrite_by_lua_no_postpone&quot;&gt;rewrite_by_lua_no_postpone&lt;/a&gt; is turned on.</source>
          <target state="translated">&lt;code&gt;rewrite_by_lua_file&lt;/code&gt; 의 코드는 항상의 끝에서 실행됩니다 &lt;code&gt;rewrite&lt;/code&gt; 하지 않는 한 요청 처리 단계 &lt;a href=&quot;#rewrite_by_lua_no_postpone&quot;&gt;rewrite_by_lua_no_postpone이&lt;/a&gt; 켜집니다.</target>
        </trans-unit>
        <trans-unit id="87ce706d9c9ef3645427c746bacbff2567f719c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;share_all_vars&lt;/code&gt; option controls whether to share nginx variables among the current request and its subrequests. If this option is set to &lt;code&gt;true&lt;/code&gt;, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.</source>
          <target state="translated">&lt;code&gt;share_all_vars&lt;/code&gt; 의 옵션 컨트롤 현재 요청과 그 하위 요청 사이에서 공유의 nginx 변수에 대한 여부. 이 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 현재 요청 및 관련 하위 요청이 동일한 Nginx 변수 범위를 공유합니다. 따라서 하위 요청에 의해 작성된 Nginx 변수의 변경은 현재 요청에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="a9fe351bd2b9ab1ccc84687c69d3fa760c32cc58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;status&lt;/code&gt; argument can be &lt;code&gt;ngx.OK&lt;/code&gt;, &lt;code&gt;ngx.ERROR&lt;/code&gt;, &lt;code&gt;ngx.HTTP_NOT_FOUND&lt;/code&gt;, &lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;, or other &lt;a href=&quot;#http-status-constants&quot;&gt;HTTP status constants&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 인자가 될 수 &lt;code&gt;ngx.OK&lt;/code&gt; , &lt;code&gt;ngx.ERROR&lt;/code&gt; , &lt;code&gt;ngx.HTTP_NOT_FOUND&lt;/code&gt; , &lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt; , 또는 다른 &lt;a href=&quot;#http-status-constants&quot;&gt;HTTP 상태 상수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a262fbcef8060cdec4782d6b276cecc008abf25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; argument and &lt;code&gt;init&lt;/code&gt; argument can be any valid Lua numbers, like negative numbers or floating-point numbers.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 인수 및 &lt;code&gt;init&lt;/code&gt; 의 인수가 부의 번호 또는 부동 소수점 숫자처럼, 유효한 루아 번호가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a65f5f17f68609b6e86289a796d9b219eb8fce8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; argument inserted can be Lua booleans, numbers, strings, or &lt;code&gt;nil&lt;/code&gt;. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the &lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 삽입 인수는 루아 부울, 숫자, 문자열, 또는 할 수있다 &lt;code&gt;nil&lt;/code&gt; . 값 유형도 사전에 저장되며 나중에 &lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt; 메소드 를 통해 동일한 데이터 유형을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3cca78a6cd56391f34d1abd60cb297d66d46fb0" translate="yes" xml:space="preserve">
          <source>The API is exposed to Lua in the form of two standard packages &lt;code&gt;ngx&lt;/code&gt; and &lt;code&gt;ndk&lt;/code&gt;. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</source>
          <target state="translated">API는 두 개의 표준 패키지 &lt;code&gt;ngx&lt;/code&gt; 및 &lt;code&gt;ndk&lt;/code&gt; 형식으로 Lua에 노출됩니다 . 이 패키지는 ngx_lua 내의 기본 전역 범위에 있으며 항상 ngx_lua 지시문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212e8223d672a1eef118e5c6f551efe0fdc5a203" translate="yes" xml:space="preserve">
          <source>The HTTP 1.0 protocol does not support chunked output and requires an explicit &lt;code&gt;Content-Length&lt;/code&gt; header when the response body is not empty in order to support the HTTP 1.0 keep-alive. So when a HTTP 1.0 request is made and the &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; directive is turned &lt;code&gt;on&lt;/code&gt;, ngx_lua will buffer the output of &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; and &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; calls and also postpone sending response headers until all the response body output is received. At that time ngx_lua can calculate the total length of the body and construct a proper &lt;code&gt;Content-Length&lt;/code&gt; header to return to the HTTP 1.0 client. If the &lt;code&gt;Content-Length&lt;/code&gt; response header is set in the running Lua code, however, this buffering will be disabled even if the &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; directive is turned &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">HTTP 1.0 프로토콜은 청크 출력을 지원하지 않으며 HTTP 1.0 연결 유지를 지원하기 위해 응답 본문이 비어 있지 않은 경우 명시적인 &lt;code&gt;Content-Length&lt;/code&gt; 헤더가 필요합니다 . 따라서 HTTP 1.0 요청이 이루어지고 &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; 지시문이 &lt;code&gt;on&lt;/code&gt; 되면 ngx_lua는 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; 및 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 호출 의 출력을 버퍼링 하고 모든 응답 본문 출력이 수신 될 때까지 응답 헤더 전송을 연기합니다. 이때 ngx_lua는 본문의 전체 길이를 계산하고 적절한 &lt;code&gt;Content-Length&lt;/code&gt; 헤더를 구성하여 HTTP 1.0 클라이언트로 반환 할 수 있습니다. 경우] &lt;code&gt;Content-Length&lt;/code&gt; 응답 헤더가 실행중인 Lua 코드에 설정되어 있지만 &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; 지시문이 설정되어 있어도이 버퍼링은 비활성화 &lt;code&gt;on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40bdf78a0b005cf1a4af1b5ed70dc41c59603dd3" translate="yes" xml:space="preserve">
          <source>The Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md&quot;&gt;ngx.ssl.session&lt;/a&gt; Lua module shipped with the &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">현재 세션 ID를 얻고 캐시 된 SSL 세션 데이터를로드하기위한 Lua API 는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt; 라이브러리 와 함께 제공되는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md&quot;&gt;ngx.ssl.session&lt;/a&gt; Lua 모듈에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="43b66deb98c8575f8c611d86ff54a71bd7327683" translate="yes" xml:space="preserve">
          <source>The Lua API for obtaining the current session ID and the associated session state data is provided in the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme&quot;&gt;ngx.ssl.session&lt;/a&gt; Lua module shipped with the &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">현재 세션 ID 및 관련 세션 상태 데이터를 얻기위한 Lua API 는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt; 와 함께 제공되는 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme&quot;&gt;ngx.ssl.session&lt;/a&gt; Lua 모듈에 제공됩니다. 라이브러리 .</target>
        </trans-unit>
        <trans-unit id="772f1148c1c25c928980a306e0b23b964ef7ac4d" translate="yes" xml:space="preserve">
          <source>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt;[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</source>
          <target state="translated">Lua 코드는 &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt; 를 재정 의하여 자체 수정 된 버전의 입력 데이터 청크를 다운 스트림 Nginx 출력 바디 필터로 전달할 수 있습니다. Lua 문자열 또는 Lua 문자열 테이블로 [1]을 있습니다. 예를 들어 응답 본문의 모든 소문자를 변환하려면 다음과 같이 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5e23db89ef964e3c0c3aac5506e27bcd5de07a32" translate="yes" xml:space="preserve">
          <source>The Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream&quot;&gt;proxy_next_upstream&lt;/a&gt; directive.</source>
          <target state="translated">nginx 업스트림 메커니즘이 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream&quot;&gt;proxy_next_upstream&lt;/a&gt; 과 같은 지시문에 지정된 조건에서 요청을 재 시도 할 때이 지시문에 의해 등록 된 Lua 코드 핸들러는 단일 다운 스트림 요청에서 두 번 이상 호출 될 수 있습니다. 지시문 .</target>
        </trans-unit>
        <trans-unit id="ae87d2d9f3e75ae4933616c9d0f653941993c4d0" translate="yes" xml:space="preserve">
          <source>The Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream&quot;&gt;proxy_next_upstream&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7edd80387b9379245c8e8675949383c18e82714" translate="yes" xml:space="preserve">
          <source>The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.</source>
          <target state="translated">Lua 인터프리터 또는 LuaJIT 인스턴스는 단일 nginx 작업자 프로세스의 모든 요청에서 공유되지만 요청 컨텍스트는 경량 Lua 코 루틴을 사용하여 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff2c3dd0b6d0213a8e9e526376ebaa14d007184" translate="yes" xml:space="preserve">
          <source>The Lua load balancer can totally ignore the list of servers defined in the &lt;code&gt;upstream {}&lt;/code&gt; block and select peer from a completely dynamic server list (even changing per request) via the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;ngx.balancer&lt;/a&gt; module from the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">Lua로드 밸런서는 &lt;code&gt;upstream {}&lt;/code&gt; 블록에 정의 된 서버 목록을 완전히 무시 하고 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 라이브러리 의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;ngx.balancer&lt;/a&gt; 모듈을 통해 완전히 동적 서버 목록에서 요청을 변경하더라도 피어를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="507d01fd24975e1324c525d8b2ac25d906d2f890" translate="yes" xml:space="preserve">
          <source>The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.</source>
          <target state="translated">Lua 상태 (Lua VM 인스턴스)는 단일 nginx 작업자 프로세스에서 처리하는 모든 요청에서 공유되어 메모리 사용을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="52e72aaab502edc0b73edc9cbc1fd4b16ecc0332" translate="yes" xml:space="preserve">
          <source>The OpenResty bundle</source>
          <target state="translated">OpenResty 번들</target>
        </trans-unit>
        <trans-unit id="ae5cadbb997213997b2f9e29a75435f4f048a428" translate="yes" xml:space="preserve">
          <source>The TTL is originally determined by the &lt;code&gt;exptime&lt;/code&gt; argument of the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt;, &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;#ngxshareddictreplace&quot;&gt;replace&lt;/a&gt; (and the likes) methods. It has a time resolution of &lt;code&gt;0.001&lt;/code&gt; seconds. A value of &lt;code&gt;0&lt;/code&gt; means that the item will never expire.</source>
          <target state="translated">TTL은 원래 &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; , &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; , &lt;a href=&quot;#ngxshareddictreplace&quot;&gt;replace&lt;/a&gt; (및 like) 메소드 의 &lt;code&gt;exptime&lt;/code&gt; 인수에 의해 결정됩니다 . 시간 분해능은 &lt;code&gt;0.001&lt;/code&gt; 초입니다. &lt;code&gt;0&lt;/code&gt; 의 값 이면 항목이 만료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e06eb61a6ddf913623d7fe26b376ebf48604e9" translate="yes" xml:space="preserve">
          <source>The ability to require these packages was introduced in the &lt;code&gt;v0.2.1rc19&lt;/code&gt; release.</source>
          <target state="translated">이러한 패키지를 요구하는 기능은 &lt;code&gt;v0.2.1rc19&lt;/code&gt; 릴리스 에서 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="2800315ef27c94fdaae1c63ee269f3f6c3c4d929" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;thread1&lt;/code&gt;, &lt;code&gt;thread2&lt;/code&gt;, and etc are the Lua thread objects returned by earlier calls of &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;.</source>
          <target state="translated">인수는 &lt;code&gt;thread1&lt;/code&gt; , &lt;code&gt;thread2&lt;/code&gt; 를 , 등 루아 스레드가 이전 호출에 의해 반환되는 객체 &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f038d9d54b50157b2cdb8f7c0cae687a1e16048" translate="yes" xml:space="preserve">
          <source>The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run and how the result will be used. Below is a diagram showing the order in which directives are executed.</source>
          <target state="translated">Lua를 사용한 Nginx 스크립팅의 기본 빌딩 블록은 지시문입니다. 지시문은 사용자 Lua 코드 실행시기 및 결과 사용 방법을 지정하는 데 사용됩니다. 아래는 지시문이 실행되는 순서를 보여주는 다이어그램입니다.</target>
        </trans-unit>
        <trans-unit id="c0c2f884cbf8716bac1ee6ebd137ae16742c691d" translate="yes" xml:space="preserve">
          <source>The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this patch applied.</source>
          <target state="translated">OpenResty 1.9.7.2 이상의 NGINX 코어 번들 버전에는 이미이 패치가 적용되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71547188ee86c03861f08b4e98ba54f89f11c74" translate="yes" xml:space="preserve">
          <source>The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, for example,</source>
          <target state="translated">콜백 함수는 클라이언트 중단 이벤트와 함께 수행 할 작업을 모두 결정할 수 있습니다. 예를 들어 아무 것도 수행하지 않고 이벤트를 무시하면 현재 Lua 요청 핸들러가 중단없이 계속 실행됩니다. 또한 콜백 함수는 예를 들어 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; 를 호출하여 모든 것을 종료하도록 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d09cd34554678156dfa6acfe34bd4ddf74a0aff9" translate="yes" xml:space="preserve">
          <source>The changes made in every release of this module are listed in the change logs of the OpenResty bundle:</source>
          <target state="translated">이 모듈의 모든 릴리스에서 변경된 사항은 OpenResty 번들의 변경 로그에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="970e386bd084d99183115bd0d4582833e4033c95" translate="yes" xml:space="preserve">
          <source>The code repository of this project is hosted on github at &lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot;&gt;openresty/lua-nginx-module&lt;/a&gt;.</source>
          <target state="translated">이 프로젝트의 코드 저장소는 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot;&gt;openresty / lua-nginx-module의&lt;/a&gt; github에서 호스팅됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3001a0f56fb277d79c1a53802388f0949531ce3" translate="yes" xml:space="preserve">
          <source>The contents in the dictionary storage will be lost, however, when the Nginx server quits.</source>
          <target state="translated">그러나 Nginx 서버가 종료되면 사전 저장소의 내용이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="18260de332dd4424cdf7f4dd36c9840abf521bce" translate="yes" xml:space="preserve">
          <source>The cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.</source>
          <target state="translated">이 API 함수로 작성된 코 소켓 오브젝트는이를 작성하는 Lua 핸들러와 동일한 수명을 갖습니다. 따라서 코 소켓 객체를 다른 Lua 핸들러 (ngx.timer 콜백 함수 포함)에 전달하지 말고 다른 NGINX 요청간에 코 소켓 객체를 공유하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7ad3ee46d105f2d0645ded0a41553c70a0168f41" translate="yes" xml:space="preserve">
          <source>The cosockets are currently also disabled in the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt; and &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua*&lt;/a&gt; directive contexts but we may add support for these contexts in the future because there is no limitation in the nginx core (or the limitation might be worked around).</source>
          <target state="translated">코 소켓은 현재 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt; 및 &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua *&lt;/a&gt; 에서도 비활성화되어 있습니다. 지시문 컨텍스트 있지만 nginx 코어에는 제한이 없기 때문에 향후 이러한 컨텍스트에 대한 지원을 추가 할 수 있습니다 (또는 제한이 해결 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="b322bf88c6142e1fa37084b8dcd7f42661e58a38" translate="yes" xml:space="preserve">
          <source>The current implementation requires that the iterator returned should only be used in a single request. That is, one should &lt;em&gt;not&lt;/em&gt; assign it to a variable belonging to persistent namespace like a Lua package.</source>
          <target state="translated">현재 구현에서는 반환 된 반복자가 단일 요청에서만 사용해야합니다. 즉,해서는 &lt;em&gt;안됩니다&lt;/em&gt; Lua 패키지와 같은 영속적 네임 스페이스에 속하는 변수에이를 할당 .</target>
        </trans-unit>
        <trans-unit id="e35a882cf5243f7c8003fa6b3108dc930c82df4a" translate="yes" xml:space="preserve">
          <source>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest&quot;&gt;log_subrequest on&lt;/a&gt; directives in &lt;code&gt;nginx.conf&lt;/code&gt; may make the counting faster when subrequests are involved. By default, only &quot;main requests&quot; count.</source>
          <target state="translated">현재 구현은 NGINX 로그 단계 핸들러를 사용하여 요청 계산을 수행합니다. 따라서 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest&quot;&gt;nginx.conf의&lt;/a&gt; 지시문에 &lt;code&gt;nginx.conf&lt;/code&gt; 가 나타나면 하위 요청이 포함될 때 계산 속도 가 빨라질 수 있습니다. 기본적으로 &quot;주요 요청&quot;만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c17b1193412f267b2b737c9b93a29ad1ba35013f" translate="yes" xml:space="preserve">
          <source>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest&quot;&gt;log_subrequest on&lt;/a&gt; directives in &lt;code&gt;nginx.conf&lt;/code&gt; may make the counting faster when subrequests are involved. By default, only &quot;main requests&quot; count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9e120f347f8db1c7d7080e09b7646e67492de2" translate="yes" xml:space="preserve">
          <source>The data chunk and &quot;eof&quot; flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting &lt;code&gt;nil&lt;/code&gt; or an empty Lua string value to &lt;code&gt;ngx.arg[1]&lt;/code&gt;, no data chunk will be passed to the downstream Nginx output filters at all.</source>
          <target state="translated">다운 스트림 Nginx 출력 필터로 전달 된 데이터 청크 및 &quot;eof&quot;플래그는 값을 해당 테이블 요소에 직접 지정하여 재정의 할 수도 있습니다. 설정시 &lt;code&gt;nil&lt;/code&gt; 거나 빈 루아 문자열 값 &lt;code&gt;ngx.arg[1]&lt;/code&gt; , 데이터 청크 모두의 하류 Nginx의 출력 필터에 전달되지 않는다.</target>
        </trans-unit>
        <trans-unit id="ff53116326020147735eea3f86a8d17245b4a849" translate="yes" xml:space="preserve">
          <source>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the &lt;code&gt;o&lt;/code&gt; option was not specified) and there will be one, and only one, warning in the &lt;code&gt;error.log&lt;/code&gt; file:</source>
          <target state="translated">허용되는 기본 항목 수는 1024이며이 한계에 도달하면 새 정규식이 캐시되지 않으며 ( &lt;code&gt;o&lt;/code&gt; 옵션이 지정되지 않은 것처럼 ) &lt;code&gt;error.log&lt;/code&gt; 파일에 경고가 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="8245ee6ca00e0476be7b07495c9182ba0dd3c0e9" translate="yes" xml:space="preserve">
          <source>The dollar sign characters in the return value of the &lt;code&gt;replace&lt;/code&gt; function argument are not special at all.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 함수 인수 의 반환 값에있는 달러 기호 문자 는 전혀 특별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aef324e4e541adc881d9a5e71dd7df104f89ee1" translate="yes" xml:space="preserve">
          <source>The effect in action:</source>
          <target state="translated">실제 효과 :</target>
        </trans-unit>
        <trans-unit id="30472cce7864a329de522917d1afbeccf76ae408" translate="yes" xml:space="preserve">
          <source>The first argument to this method must be the dictionary object itself, for example,</source>
          <target state="translated">이 메소드의 첫 번째 인수는 사전 오브젝트 자체 여야합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="80a97723b542ec4ef2fffd8846e814c828e8f641" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;delay&lt;/code&gt;, specifies the delay for the timer, in seconds. One can specify fractional seconds like &lt;code&gt;0.001&lt;/code&gt; to mean 1 millisecond here. &lt;code&gt;0&lt;/code&gt; delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.</source>
          <target state="translated">첫 번째 인수 인 &lt;code&gt;delay&lt;/code&gt; 는 타이머 지연을 초 단위로 지정합니다. 여기서는 &lt;code&gt;0.001&lt;/code&gt; 과 같은 분수 초를 지정 하여 1 밀리 초를 의미 할 수 있습니다. &lt;code&gt;0&lt;/code&gt; 지연도 지정할 수 있으며,이 경우 현재 처리기가 실행을 수행하면 타이머가 즉시 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5a4a7533b05b60d306511331b4f93c3a14df84" translate="yes" xml:space="preserve">
          <source>The first optional argument, &lt;code&gt;timeout&lt;/code&gt;, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the &lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt; config directive will be used. If the &lt;code&gt;0&lt;/code&gt; value is given, then the timeout interval is unlimited.</source>
          <target state="translated">첫 번째 선택적 인수 인 &lt;code&gt;timeout&lt;/code&gt; 은 현재 연결에 대한 최대 유휴 시간 초과 (밀리 초)를 지정하는 데 사용할 수 있습니다. 생략하면 &lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt; 구성 지시문 의 기본 설정 이 사용됩니다. 경우 &lt;code&gt;0&lt;/code&gt; 값이 지정되고있는 경우, 제한 시간 간격은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3beed3e118d90b065d38c548772e5d410103d33f" translate="yes" xml:space="preserve">
          <source>The following dependencies are required to run the test suite:</source>
          <target state="translated">테스트 스위트를 실행하려면 다음 종속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="637c81eb3986471466bff45b7e19b77e453b9c04" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of &lt;code&gt;ngx.thread.wait&lt;/code&gt; and &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; to emulate &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;:</source>
          <target state="translated">다음 예제의 사용을 보여줍니다 &lt;code&gt;ngx.thread.wait&lt;/code&gt; 및 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 에 에뮬레이션 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2b43209f4ec01cbc1b4586b52109ea9f8fe3d816" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of coroutine.yield() in the &quot;light thread&quot; coroutines to do manual time-slicing:</source>
          <target state="translated">다음 예제는 &quot;light thread&quot;코 루틴에서 coroutine.yield ()를 사용하여 수동 시간 분할을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="64c9a25a7baf360d34e24d9f0d021241f75a2da0" translate="yes" xml:space="preserve">
          <source>The following example emulates the &lt;code&gt;$request_time&lt;/code&gt; variable value (provided by &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_log_module.html&quot;&gt;ngx_http_log_module&lt;/a&gt;) in pure Lua:</source>
          <target state="translated">다음 예제는 순수 Lua에서 &lt;code&gt;$request_time&lt;/code&gt; 변수 값 ( &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_log_module.html&quot;&gt;ngx_http_log_module&lt;/a&gt; 제공 )을 에뮬레이션합니다 .</target>
        </trans-unit>
        <trans-unit id="862c28ed9480f31ebd99f8a2ab0cf822349ce6f2" translate="yes" xml:space="preserve">
          <source>The following example emulates the &lt;code&gt;$request_time&lt;/code&gt; variable value (provided by &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_log_module.html&quot;&gt;ngx_http_log_module&lt;/a&gt;) in pure Lua:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42212cf588944bce0249835bdca575105fd2c0f4" translate="yes" xml:space="preserve">
          <source>The format for the Lua table passed as the &lt;code&gt;args&lt;/code&gt; argument is identical to the format used in the &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 인수 로 전달 된 Lua 테이블 의 형식은 &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt; 메소드에 사용 된 형식과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6041674bdf6d923cdc6ec3c0edb3ff9a62a92fc2" translate="yes" xml:space="preserve">
          <source>The full list can be viewed using the &amp;ldquo;openssl ciphers&amp;rdquo; command.</source>
          <target state="translated">&quot;openssl ciphers&quot;명령을 사용하여 전체 목록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4631f283959351330388f20f8f093a2f71ab22a" translate="yes" xml:space="preserve">
          <source>The hard-coded minimum size is 8KB while the practical minimum size depends on actual user data set (some people start with 12KB).</source>
          <target state="translated">하드 코딩 된 최소 크기는 8KB이고 실제 최소 크기는 실제 사용자 데이터 세트 (일부 사람들은 12KB로 시작)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="94c68830c003240a4ef935b2a4d89403c58e82ff" translate="yes" xml:space="preserve">
          <source>The header names are matched case-insensitively.</source>
          <target state="translated">헤더 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56bf0182962d32c8f269060edf8a10438545124f" translate="yes" xml:space="preserve">
          <source>The input argument &lt;code&gt;data&lt;/code&gt; can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</source>
          <target state="translated">입력 인수 &lt;code&gt;data&lt;/code&gt; 는 Lua 문자열이거나 문자열 조각을 보유하는 (중첩 된) Lua 테이블 일 수 있습니다. 테이블 인수의 경우,이 메소드는 모든 문자열 요소를 기본 Nginx 소켓 전송 버퍼에 하나씩 복사합니다. 이는 일반적으로 Lua 랜드에서 문자열 연결 조작을 수행하는 것보다 최적입니다.</target>
        </trans-unit>
        <trans-unit id="d9a68f2055c86f0b4a5c93aeb116098c9d532c4a" translate="yes" xml:space="preserve">
          <source>The input data chunk is passed via &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt;[1] (as a Lua string value) and the &quot;eof&quot; flag indicating the end of the response body data stream is passed via &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt;[2] (as a Lua boolean value).</source>
          <target state="translated">입력 데이터 청크는 &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt; [1] (루아 문자열 값)를 통해 전달되고 응답 본문 데이터 스트림의 끝을 나타내는 &quot;eof&quot;플래그는 &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt; 를 통해 전달됩니다 . [2] (루아 부울 값) ).</target>
        </trans-unit>
        <trans-unit id="b865b2e89632e2e1a2d9c342cc70c3486d1692a6" translate="yes" xml:space="preserve">
          <source>The iterator function behaves differently (i.e., like a real iterator) when it is called with a &lt;code&gt;size&lt;/code&gt; argument. That is, it will read that &lt;code&gt;size&lt;/code&gt; of data on each invocation and will return &lt;code&gt;nil&lt;/code&gt; at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;nil&lt;/code&gt; too. The iterator function will be reset after the last successful invocation that returns &lt;code&gt;nil&lt;/code&gt; data and &lt;code&gt;nil&lt;/code&gt; error. Consider the following example:</source>
          <target state="translated">iterator 함수는 &lt;code&gt;size&lt;/code&gt; 인수 와 함께 호출 될 때 다르게 작동합니다 (예 : 실제 반복자와 같이) . 즉, 각 호출에서 해당 &lt;code&gt;size&lt;/code&gt; 의 데이터를 읽고 마지막 호출에서 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다 (경계 패턴을 보거나 오류를 충족 함). 반복자 함수를 마지막으로 성공적으로 호출 한 경우, &lt;code&gt;err&lt;/code&gt; 리턴 값도 &lt;code&gt;nil&lt;/code&gt; 이 됩니다. &lt;code&gt;nil&lt;/code&gt; 데이터와 &lt;code&gt;nil&lt;/code&gt; 을 리턴하는 마지막 성공적인 호출 후에 반복자 함수가 재설정됩니다. 오류 . 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0d9bbfa1305dcb6174a5b03d501294b9c5e83d9c" translate="yes" xml:space="preserve">
          <source>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.</source>
          <target state="translated">반복자 함수는 여러 번 호출 될 수 있으며 다른 코 소켓 메소드 호출 또는 다른 반복자 함수 호출과 안전하게 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6fbd7904840a04b5b549ca65672172aa2f1869" translate="yes" xml:space="preserve">
          <source>The latest version of this module is compatible with the following versions of Nginx:</source>
          <target state="translated">이 모듈의 최신 버전은 다음 버전의 Nginx와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="83aea397a109ada439c979d979a50aebbd281b53" translate="yes" xml:space="preserve">
          <source>The limit can be manually modified if required by editing the definition of the &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; macro in the &lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt; file in the Nginx source tree.</source>
          <target state="translated">Nginx 소스 트리 의 &lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt; 파일에서 &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; 매크로 의 정의를 편집하여 필요한 경우 한계를 수동으로 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="738970af6ae4e99f793463247aa27c8e65dc613a" translate="yes" xml:space="preserve">
          <source>The maximal number of pending timers allowed in an Nginx worker is controlled by the &lt;a href=&quot;#lua_max_pending_timers&quot;&gt;lua_max_pending_timers&lt;/a&gt; directive. The maximal number of running timers is controlled by the &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; directive.</source>
          <target state="translated">Nginx 작업자에 허용되는 최대 보류 타이머 수는 &lt;a href=&quot;#lua_max_pending_timers&quot;&gt;lua_max_pending_timers&lt;/a&gt; 지시문에 의해 제어됩니다 . 최대 실행 타이머 수는 &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; 지시문에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="acd52c4075b2cbb03a09ea4b36f69040954f98c8" translate="yes" xml:space="preserve">
          <source>The ngx_lua module does not support the &lt;code&gt;stat&lt;/code&gt; mode available with the Apache &lt;code&gt;mod_lua&lt;/code&gt; module (yet).</source>
          <target state="translated">ngx_lua 모듈은 Apache &lt;code&gt;mod_lua&lt;/code&gt; 모듈 (아직) 에서 사용 가능한 &lt;code&gt;stat&lt;/code&gt; 모드를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="865674885c0565f15c3c0b059fb58e7de950448d" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;8&lt;/code&gt; will be consistently output when accessing &lt;code&gt;/get&lt;/code&gt; regardless of how many Nginx workers there are because the &lt;code&gt;dogs&lt;/code&gt; dictionary resides in the shared memory and visible to &lt;em&gt;all&lt;/em&gt; of the worker processes.</source>
          <target state="translated">&lt;code&gt;dogs&lt;/code&gt; 사전이 공유 메모리에 있고 &lt;em&gt;모든 사람&lt;/em&gt; 에게 표시 되므로 Nginx 작업자 &lt;code&gt;/get&lt;/code&gt; 관계없이 / get에 액세스하면 숫자 &lt;code&gt;8&lt;/code&gt; 이 일관되게 출력됩니다.&lt;em&gt;&lt;/em&gt; 작업자 프로세스에 .</target>
        </trans-unit>
        <trans-unit id="3bbecc7e5eee13fb54f6ff8a682f1c435d42f689" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;exptime&lt;/code&gt; argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is &lt;code&gt;0.001&lt;/code&gt; seconds. If the &lt;code&gt;exptime&lt;/code&gt; takes the value &lt;code&gt;0&lt;/code&gt; (which is the default), then the item will never expire.</source>
          <target state="translated">선택적 &lt;code&gt;exptime&lt;/code&gt; 인수는 삽입 된 키-값 쌍의 만료 시간 (초)을 지정합니다. 시간 해상도는 &lt;code&gt;0.001&lt;/code&gt; 초입니다. 는 IF &lt;code&gt;exptime&lt;/code&gt; 는 값을 가져 &lt;code&gt;0&lt;/code&gt; (디폴트), 다음 항목이 만료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="049bc950fcb5361340e25a8bc84221ec612b5492" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to &lt;code&gt;0&lt;/code&gt;. The user flags argument was first introduced in the &lt;code&gt;v0.5.0rc2&lt;/code&gt; release.</source>
          <target state="translated">선택적 &lt;code&gt;flags&lt;/code&gt; 인수는 저장할 항목과 관련된 사용자 플래그 값을 지정합니다. 나중에 값으로 검색 할 수도 있습니다. 사용자 플래그는 내부적으로 부호없는 32 비트 정수로 저장됩니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 사용자 플래그 인수는 &lt;code&gt;v0.5.0rc2&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa012ff0f72db35d9a285a84ef12bc806db92247" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;init&lt;/code&gt; parameter was first added in the &lt;code&gt;v0.10.6&lt;/code&gt; release.</source>
          <target state="translated">선택적 &lt;code&gt;init&lt;/code&gt; 매개 변수는 &lt;code&gt;v0.10.6&lt;/code&gt; 릴리스 에서 처음 추가 되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c980416b97ee10079e19a3efe4025b8711b6809" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;init_ttl&lt;/code&gt; argument specifies expiration time (in seconds) of the value when it is initialized via the &lt;code&gt;init&lt;/code&gt; argument. The time resolution is &lt;code&gt;0.001&lt;/code&gt; seconds. If &lt;code&gt;init_ttl&lt;/code&gt; takes the value &lt;code&gt;0&lt;/code&gt; (which is the default), then the item will never expire. This argument cannot be provided without providing the &lt;code&gt;init&lt;/code&gt; argument as well, and has no effect if the value already exists (e.g., if it was previously inserted via &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; or the likes).</source>
          <target state="translated">선택적 &lt;code&gt;init_ttl&lt;/code&gt; 인수는 &lt;code&gt;init&lt;/code&gt; 인수 를 통해 초기화 될 때 값의 만료 시간 (초)을 지정합니다 . 시간 해상도는 &lt;code&gt;0.001&lt;/code&gt; 초입니다. 경우 &lt;code&gt;init_ttl&lt;/code&gt; 이 값 걸리는 &lt;code&gt;0&lt;/code&gt; (디폴트), 다음 항목이 만료되지 않습니다. 이 인수는 &lt;code&gt;init&lt;/code&gt; 인수를 제공하지 않으면 제공 할 수 없으며 값이 이미 존재하는 경우 (예 : 이전에 &lt;a href=&quot;#ngxshareddictset&quot;&gt;set 등을&lt;/a&gt; 통해 삽입 된 경우) 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7391c5b4ef241f6506eb3d02c293a05ca4ebd72f" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;init_ttl&lt;/code&gt; parameter was introduced in the &lt;code&gt;v0.10.12rc2&lt;/code&gt; release.</source>
          <target state="translated">선택적 &lt;code&gt;init_ttl&lt;/code&gt; 매개 변수는 &lt;code&gt;v0.10.12rc2&lt;/code&gt; 릴리스 에서 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="665bf9db44f5cfd04f5c66e46f0bf3cb93b28658" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;max_args&lt;/code&gt; argument can be used to specify the maximum number of arguments parsed from the &lt;code&gt;str&lt;/code&gt; argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;max_args&lt;/code&gt; 인수를 사용하여 &lt;code&gt;str&lt;/code&gt; 인수 에서 구문 분석 된 최대 인수 수를 지정할 수 있습니다 . 기본적으로 최대 100 개의 요청 인수가 구문 분석되고 (같은 이름의 인수 포함) 추가 URI 인수는 서비스 거부 공격을 방지하기 위해 자동으로 삭제됩니다. &lt;code&gt;v0.10.13&lt;/code&gt; 부터 한계가 초과되면 문자열 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 인 두 번째 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="493c607735aa0b456d27348fea1f24028e22c5b2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;options&lt;/code&gt; argument takes exactly the same semantics as the &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;code&gt;options&lt;/code&gt; 인수는 &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 메소드 와 정확히 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="705aca588f0b2633abb24406d791e875eeb034ef" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;reused_session&lt;/code&gt; argument can take a former SSL session userdata returned by a previous &lt;code&gt;sslhandshake&lt;/code&gt; call for exactly the same target. For short-lived connections, reusing SSL sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled. This argument defaults to &lt;code&gt;nil&lt;/code&gt;. If this argument takes the boolean &lt;code&gt;false&lt;/code&gt; value, no SSL session userdata would return by this call and only a Lua boolean will be returned as the first return value; otherwise the current SSL session will always be returned as the first argument in case of successes.</source>
          <target state="translated">선택적 &lt;code&gt;reused_session&lt;/code&gt; 인수는 정확히 동일한 대상에 대해 이전 &lt;code&gt;sslhandshake&lt;/code&gt; 호출에서 리턴 한 이전 SSL 세션 사용자 데이터를 사용할 수 있습니다 . 수명이 짧은 연결의 경우 SSL 세션을 재사용하면 일반적으로 핸드 셰이크 속도가 한 단계 씩 빨라질 수 있지만 연결 풀이 활성화 된 경우에는 그렇게 유용하지 않습니다. 이 인수의 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 이 인수가 부울 &lt;code&gt;false&lt;/code&gt; 를 사용하는 경우 값을 SSL 세션 사용자 데이터가이 호출로 리턴되지 않으며 Lua 부울 만 첫 번째 리턴 값으로 리턴됩니다. 그렇지 않으면 현재 SSL 세션이 성공한 경우 항상 첫 번째 인수로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="210cef7f98d6b95bd8bb15065bccf11215f9bada" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;send_status_req&lt;/code&gt; argument takes a boolean that controls whether to send the OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).</source>
          <target state="translated">선택적 &lt;code&gt;send_status_req&lt;/code&gt; 인수는 SSL 핸드 셰이크 요청 (OCSP 스테이플 링 요청)에서 OCSP 상태 요청을 보낼지 여부를 제어하는 ​​부울을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aca11f868b341f7561198d59ae0bfa05b7a00f05" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;server_name&lt;/code&gt; argument is used to specify the server name for the new TLS extension Server Name Indication (SNI). Use of SNI can make different servers share the same IP address on the server side. Also, when SSL verification is enabled, this &lt;code&gt;server_name&lt;/code&gt; argument is also used to validate the server name specified in the server certificate sent from the remote.</source>
          <target state="translated">선택적 &lt;code&gt;server_name&lt;/code&gt; 인수는 새 TLS 확장 서버 이름 표시 (SNI)의 서버 이름을 지정하는 데 사용됩니다. SNI를 사용하면 다른 서버가 서버 측에서 동일한 IP 주소를 공유 할 수 있습니다. 또한 SSL 확인이 사용 가능한 경우이 &lt;code&gt;server_name&lt;/code&gt; 인수는 원격에서 전송 된 서버 인증서에 지정된 서버 이름의 유효성을 검증하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bbdfdf805c45a513d77660c289da3e4e9842140" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ssl_verify&lt;/code&gt; argument takes a Lua boolean value to control whether to perform SSL verification. When set to &lt;code&gt;true&lt;/code&gt;, the server certificate will be verified according to the CA certificates specified by the &lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt; directive. You may also need to adjust the &lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt; directive to control how deep we should follow along the certificate chain. Also, when the &lt;code&gt;ssl_verify&lt;/code&gt; argument is true and the &lt;code&gt;server_name&lt;/code&gt; argument is also specified, the latter will be used to validate the server name in the server certificate.</source>
          <target state="translated">선택적 &lt;code&gt;ssl_verify&lt;/code&gt; 인수는 Lua 부울 값을 사용하여 SSL 확인 수행 여부를 제어합니다. &lt;code&gt;true&lt;/code&gt; 로 설정되면 &lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt; 지시문에 지정된 CA 인증서에 따라 서버 인증서가 확인됩니다 . 인증서 체인에서 따라야하는 깊이를 제어 하기 위해 &lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt; 지시문 을 조정해야 할 수도 있습니다 . 또한 &lt;code&gt;ssl_verify&lt;/code&gt; 인수가 true이고 &lt;code&gt;server_name&lt;/code&gt; 인수도 지정된 경우 후자는 서버 인증서에서 서버 이름의 유효성을 검증하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc49e28c975472bfc5dd816a692c21288c6827eb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;status&lt;/code&gt; parameter specifies the HTTP status code to be used. The following status codes are supported right now:</source>
          <target state="translated">선택적 &lt;code&gt;status&lt;/code&gt; 매개 변수는 사용할 HTTP 상태 코드를 지정합니다. 현재 다음 상태 코드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a92293ecfd6c6a30e71da275ce679f0cde410b27" translate="yes" xml:space="preserve">
          <source>The optional boolean &lt;code&gt;jump&lt;/code&gt; argument can trigger location rematch (or location jump) as &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive, that is, when &lt;code&gt;jump&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later &lt;code&gt;post-rewrite&lt;/code&gt; phase and jumping to the new location.</source>
          <target state="translated">선택적 부울 &lt;code&gt;jump&lt;/code&gt; 인수는 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; 의 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;다시 쓰기&lt;/a&gt; 지시문 으로 위치 재 매치 (또는 위치 점프)를 트리거 할 수 있습니다 . 즉, &lt;code&gt;jump&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; ) 인 경우이 함수는 절대 반환되지 않으며 Nginx에 위치를 다시 검색하도록 지시합니다. 나중에 &lt;code&gt;post-rewrite&lt;/code&gt; 때 새 URI 값으로 단계 을 사용하여 새 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1cd2a0fe70a7ac0d74a2f759dc529489d2938658" translate="yes" xml:space="preserve">
          <source>The optional boolean &lt;code&gt;jump&lt;/code&gt; argument can trigger location rematch (or location jump) as &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive, that is, when &lt;code&gt;jump&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later &lt;code&gt;post-rewrite&lt;/code&gt; phase and jumping to the new location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83458411cec2afcaf29d42425c72dcedef760d7c" translate="yes" xml:space="preserve">
          <source>The optional fourth argument, &lt;code&gt;ctx&lt;/code&gt;, can be a Lua table holding an optional &lt;code&gt;pos&lt;/code&gt; field. When the &lt;code&gt;pos&lt;/code&gt; field in the &lt;code&gt;ctx&lt;/code&gt; table argument is specified, &lt;code&gt;ngx.re.match&lt;/code&gt; will start matching from that offset (starting from 1). Regardless of the presence of the &lt;code&gt;pos&lt;/code&gt; field in the &lt;code&gt;ctx&lt;/code&gt; table, &lt;code&gt;ngx.re.match&lt;/code&gt; will always set this &lt;code&gt;pos&lt;/code&gt; field to the position &lt;em&gt;after&lt;/em&gt; the substring matched by the whole pattern in case of a successful match. When match fails, the &lt;code&gt;ctx&lt;/code&gt; table will be left intact.</source>
          <target state="translated">선택적 네 번째 인수 인 &lt;code&gt;ctx&lt;/code&gt; 는 선택적 &lt;code&gt;pos&lt;/code&gt; 필드를 보유하는 Lua 테이블 일 수 있습니다 . 의 &lt;code&gt;pos&lt;/code&gt; 필드가 &lt;code&gt;ctx&lt;/code&gt; 테이블 인수 가 지정되면 &lt;code&gt;ngx.re.match&lt;/code&gt; 는 해당 오프셋 (1부터 시작)에서 일치하기 시작합니다. &lt;code&gt;ctx&lt;/code&gt; 테이블 에 &lt;code&gt;pos&lt;/code&gt; 필드 가 있는지 여부에 관계없이 &lt;code&gt;ngx.re.match&lt;/code&gt; 는 일치하는 경우 항상이 &lt;code&gt;pos&lt;/code&gt; 필드를 전체 패턴과 일치하는 하위 문자열 &lt;em&gt;뒤&lt;/em&gt; 의 위치로 설정합니다 . 일치가 실패하면 &lt;code&gt;ctx&lt;/code&gt; 테이블은 그대로 유지됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c38d6a3ac6c323ee9a043738d8e0b45b9304ec4c" translate="yes" xml:space="preserve">
          <source>The optional second &lt;code&gt;args&lt;/code&gt; can be used to specify extra URI query arguments, for example:</source>
          <target state="translated">선택적 두 번째 &lt;code&gt;args&lt;/code&gt; 는 추가 URI 쿼리 인수를 지정하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="522e7a360a8ea44d625c2576523c70ff93591236" translate="yes" xml:space="preserve">
          <source>The order in which these modules are added during configuration is important because the position of any filter module in the filtering chain determines the final output, for example. The correct adding order is shown above.</source>
          <target state="translated">예를 들어 필터링 체인에서 필터 모듈의 위치가 최종 출력을 결정하므로 구성 중에 이러한 모듈을 추가하는 순서가 중요합니다. 올바른 추가 순서는 위에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2814945babddb21121d8a1374fb1b668ffccb3" translate="yes" xml:space="preserve">
          <source>The output data stream can be aborted immediately by running the following Lua statement:</source>
          <target state="translated">다음 Lua 문을 실행하여 출력 데이터 스트림을 즉시 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45e99058c7da4dbf8c6726b9c1b8252b6dd1eee" translate="yes" xml:space="preserve">
          <source>The output says that the line 1489 of file &lt;code&gt;lib/foo/bar.lua&lt;/code&gt; writes to a global variable named &lt;code&gt;contains&lt;/code&gt;, the line 1506 reads from the global variable &lt;code&gt;setvar&lt;/code&gt;, and line 1545 reads the global &lt;code&gt;varexpand&lt;/code&gt;.</source>
          <target state="translated">출력 결과 &lt;code&gt;lib/foo/bar.lua&lt;/code&gt; 파일의 1489 행 은 &lt;code&gt;contains&lt;/code&gt; 라는 전역 변수에 쓰고 1506 행은 전역 변수 &lt;code&gt;setvar&lt;/code&gt; 에서 읽으며 1545 행은 전역 &lt;code&gt;varexpand&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5d68859b54d5e8415fc9d3cb8779288046dfb2" translate="yes" xml:space="preserve">
          <source>The packages can be introduced into external Lua modules like this:</source>
          <target state="translated">패키지는 다음과 같이 외부 Lua 모듈에 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a08d46130b3509ef3cef10664d5bc51687c03aa" translate="yes" xml:space="preserve">
          <source>The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.x is enabled.</source>
          <target state="translated">모듈이 Nginx 내에서 다양한 요소들을 모을 수 있고 Lua 언어의 힘을 사용자에게 노출시킬 수 있기 때문에 가능성은 무한합니다. 이 모듈은 스크립팅의 전체 유연성을 제공하는 동시에 CPU 시간 및 메모리 풋 프린트 측면에서 네이티브 C 언어 프로그램과 비교할 수있는 성능 수준을 제공합니다. LuaJIT 2.x가 활성화 된 경우 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="03dc62ed9fbdd78071180eb36357a837cf872078" translate="yes" xml:space="preserve">
          <source>The raw binary form of the &lt;code&gt;HMAC-SHA1&lt;/code&gt; digest will be generated, use &lt;a href=&quot;#ngxencode_base64&quot;&gt;ngx.encode_base64&lt;/a&gt;, for example, to encode the result to a textual representation if desired.</source>
          <target state="translated">&lt;code&gt;HMAC-SHA1&lt;/code&gt; 다이제스트 의 원시 바이너리 형식 이 생성 됩니다. 예를 들어 원하는 경우 결과를 텍스트 표현으로 인코딩 하려면 &lt;a href=&quot;#ngxencode_base64&quot;&gt;ngx.encode_base64&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d811fa560b109c9312c56986cf0442a8abeb693d" translate="yes" xml:space="preserve">
          <source>The regular expressions used in &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;, &lt;a href=&quot;#ngxregmatch&quot;&gt;ngx.re.gmatch&lt;/a&gt;, &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;, and &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub&lt;/a&gt; will be cached within this cache if the regex option &lt;code&gt;o&lt;/code&gt; (i.e., compile-once flag) is specified.</source>
          <target state="translated">&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; , &lt;a href=&quot;#ngxregmatch&quot;&gt;ngx.re.gmatch&lt;/a&gt; 에서 사용되는 정규식 ,&lt;a href=&quot;#ngxresub&quot;&gt; ngx.re.sub&lt;/a&gt; 및 &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub는&lt;/a&gt; 이 캐시에서 캐시 될 경우 정규식 옵션 &lt;code&gt;o&lt;/code&gt; (즉, 컴파일이-일단 플래그) 지정 .</target>
        </trans-unit>
        <trans-unit id="6d564f3171842f11fa2afdb0d7ff03337a33eef0" translate="yes" xml:space="preserve">
          <source>The request body data read using this function can be retrieved later via &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt; or, alternatively, the temporary file name for the body data cached to disk using &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt;. This depends on</source>
          <target state="translated">이 함수를 사용하여 읽은 요청 본문 데이터는 나중에 &lt;a href=&quot;#ngxreqget_body_data&quot;&gt; ngx.req.get_body_data&lt;/a&gt; 또는 &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file을&lt;/a&gt; 사용하여 디스크에 캐시 된 본문 데이터의 임시 파일 이름을 . 이것은에 따라</target>
        </trans-unit>
        <trans-unit id="e3fb71b8a85a4b41e2c9880b9533b43e14d9d0a4" translate="yes" xml:space="preserve">
          <source>The result is exactly the same as the previous example.</source>
          <target state="translated">결과는 이전 예제와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="da11b5ca5aac2a4ab7b57e61c755e66d9f443be0" translate="yes" xml:space="preserve">
          <source>The resulting Lua load balancer can work with any existing nginx upstream modules like &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_proxy&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_fastcgi&lt;/a&gt;.</source>
          <target state="translated">결과적인 Lua로드 밸런서는 다음과 같은 기존 nginx 업스트림 모듈에서 작동 할 수 있습니다 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt; ngx_proxy&lt;/a&gt; 및 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_fastcgi&lt;/a&gt; 와 .</target>
        </trans-unit>
        <trans-unit id="e4bad6f7ae8f653373d33300bb9f05d17376489a" translate="yes" xml:space="preserve">
          <source>The resulting Lua load balancer can work with any existing nginx upstream modules like &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_proxy&lt;/a&gt; and &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_fastcgi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3012f02d1c771ce5bf2f66a27a7de3b37c7bd2b" translate="yes" xml:space="preserve">
          <source>The resulting object &lt;code&gt;dict&lt;/code&gt; has the following methods:</source>
          <target state="translated">결과 객체 &lt;code&gt;dict&lt;/code&gt; 에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73a3e4e5e4001966f65bd5df1db9448fd2f2b7c" translate="yes" xml:space="preserve">
          <source>The return values have exactly the same meaning as &lt;a href=&quot;#coroutineresume&quot;&gt;coroutine.resume&lt;/a&gt;, that is, the first value returned is a boolean value indicating whether the &quot;light thread&quot; terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the &quot;light thread&quot; (in case of success) or the error object (in case of failure).</source>
          <target state="translated">반환 값은 다음과 정확히 같은 의미입니다. &lt;a href=&quot;#coroutineresume&quot;&gt; coroutine.resume&lt;/a&gt; , 리턴 된 첫 번째 값은 &quot;가벼운 스레드&quot;가 성공적으로 종료되는지 여부를 나타내는 부울 값이며, 리턴 된 후속 값은 사용자 Lua 함수의 리턴 값입니다. &quot;라이트 스레드&quot;(성공한 경우) 또는 오류 오브젝트 (실패한 경우)를 생성하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="6762126ca16668ab14fef18778d78e6a4c6d301c" translate="yes" xml:space="preserve">
          <source>The returned file is read only and is usually cleaned up by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.</source>
          <target state="translated">반환 된 파일은 읽기 전용이며 일반적으로 Nginx의 메모리 풀에 의해 정리됩니다. Lua 코드에서 수동으로 수정하거나 이름을 바꾸거나 제거해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1bde323bd751bfec28d0b7ab0e225421b31321f6" translate="yes" xml:space="preserve">
          <source>The right way of doing this is as follows:</source>
          <target state="translated">이를 수행하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c4d749704caedea5598e77d72d1046fb18528fa" translate="yes" xml:space="preserve">
          <source>The same applies to assigning an empty table:</source>
          <target state="translated">빈 테이블 할당에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ac91c3cf48f0dbb24fb4a2e421cfd12c6ca11b" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;callback&lt;/code&gt;, can be any Lua function, which will be invoked later in a background &quot;light thread&quot; after the delay specified. The user callback will be called automatically by the Nginx core with the arguments &lt;code&gt;premature&lt;/code&gt;, &lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, and etc, where the &lt;code&gt;premature&lt;/code&gt; argument takes a boolean value indicating whether it is a premature timer expiration or not, and &lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, and etc, are those (extra) user arguments specified when calling &lt;code&gt;ngx.timer.at&lt;/code&gt; as the remaining arguments.</source>
          <target state="translated">두 번째 인수 인 &lt;code&gt;callback&lt;/code&gt; 은 임의의 Lua 함수일 수 있으며, 지정된 지연 후 백그라운드 &quot;라이트 스레드&quot;에서 나중에 호출됩니다. 사용자 콜백은 인수 &lt;code&gt;premature&lt;/code&gt; , &lt;code&gt;user_arg1&lt;/code&gt; , &lt;code&gt;user_arg2&lt;/code&gt; 등 의 인수로 Nginx 코어에 의해 자동으로 호출되며 , 여기서 &lt;code&gt;premature&lt;/code&gt; 인수는 조기 타이머 만료인지 여부를 나타내는 부울 값을 취하고 &lt;code&gt;user_arg1&lt;/code&gt; , &lt;code&gt;user_arg2&lt;/code&gt; 등입니다. &lt;code&gt;ngx.timer.at&lt;/code&gt; 를 호출 할 때 지정된 추가 사용자 인수입니다. 나머지 인수로 를 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6359f6052ebb3599b90dd93311ee0e13c0370806" translate="yes" xml:space="preserve">
          <source>The second optional argument, &lt;code&gt;size&lt;/code&gt;, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the &lt;a href=&quot;#lua_socket_pool_size&quot;&gt;lua_socket_pool_size&lt;/a&gt; config directive will be used.</source>
          <target state="translated">두 번째 선택적 인수 인 &lt;code&gt;size&lt;/code&gt; 는 현재 서버의 연결 풀에서 허용되는 최대 연결 수 (예 : 현재 호스트-포트 쌍 또는 유닉스 도메인 소켓 파일 경로)를 지정하는 데 사용할 수 있습니다. 풀을 만든 후에는 연결 풀의 크기를 변경할 수 없습니다. 이 인수를 생략하면 &lt;a href=&quot;#lua_socket_pool_size&quot;&gt;lua_socket_pool_size&lt;/a&gt; 구성 지시문 의 기본 설정 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc63d1fe13432660df2182e116d247ebb30a736a" translate="yes" xml:space="preserve">
          <source>The shared dictionary will retain its contents through a server config reload (either by sending the &lt;code&gt;HUP&lt;/code&gt; signal to the Nginx process or by using the &lt;code&gt;-s reload&lt;/code&gt; command-line option).</source>
          <target state="translated">공유 사전은 서버 구성 재로드 ( &lt;code&gt;HUP&lt;/code&gt; 신호를 Nginx 프로세스로 전송하거나 &lt;code&gt;-s reload&lt;/code&gt; 명령 행 옵션 사용)를 통해 내용을 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="0211053300e5717e141766fc7bcecb34955c09ea" translate="yes" xml:space="preserve">
          <source>The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</source>
          <target state="translated">버퍼 크기는 단일 오류 로그 메시지의 최대 길이 (OpenResty의 경우 4K, NGINX의 경우 2K)보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="df05313cf47d7177bbc420d7f0c3d313ea51d9a0" translate="yes" xml:space="preserve">
          <source>The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; directive, and do not mix this call with &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 소켓 오브젝트는 일반적으로 현재 요청의 본문을 스트리밍 방식으로 읽는 데 사용됩니다. 온 켜지 마십시오 &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body의&lt;/a&gt; 지침 및이 호출 혼합하지 않는 &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963a7f5f2fa9d49255e0bbb33fb35b3317a9f2e4" translate="yes" xml:space="preserve">
          <source>The status of the &quot;light thread&quot; coroutine can be &quot;zombie&quot; if</source>
          <target state="translated">&quot;가벼운 실&quot;코 루틴의 상태는 &quot;좀비&quot;일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c60be1727a8d1978c7afe3a3537402ea031ff1c8" translate="yes" xml:space="preserve">
          <source>The support for the &lt;code&gt;TLSv1.3&lt;/code&gt; parameter requires version &lt;code&gt;v0.10.12&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; OpenSSL 1.1.1.</source>
          <target state="translated">&lt;code&gt;TLSv1.3&lt;/code&gt; 매개 변수를 지원 하려면 버전 &lt;code&gt;v0.10.12&lt;/code&gt; &lt;em&gt;및&lt;/em&gt; OpenSSL 1.1.1이 .</target>
        </trans-unit>
        <trans-unit id="63b270ff5cef0623eaa4985a8f926e019073cf35" translate="yes" xml:space="preserve">
          <source>The support for the options table argument was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</source>
          <target state="translated">옵션 테이블 인수에 대한 지원은 &lt;code&gt;v0.5.7&lt;/code&gt; 에서 처음 소개되었습니다. 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="957ec8c0f220006127e950d3788369db2eae32e6" translate="yes" xml:space="preserve">
          <source>The table keys must be Lua strings.</source>
          <target state="translated">테이블 키는 Lua 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae9302013d02b0484ae057dd405b511c8a5c6a77" translate="yes" xml:space="preserve">
          <source>The usage of this function is often like this:</source>
          <target state="translated">이 기능의 사용법은 종종 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="fa94fc26e81e25adcce2a5fed253b8df1b9907d3" translate="yes" xml:space="preserve">
          <source>The use of Lua global variables is a generally inadvisable in the ngx_lua context as:</source>
          <target state="translated">Lua 전역 변수의 사용은 일반적으로 ngx_lua 컨텍스트에서 다음과 같이 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9c0c4638013cb57ad4cd406b8801686b91cea8c" translate="yes" xml:space="preserve">
          <source>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.</source>
          <target state="translated">반환 된 값은 루아 부울, 숫자 또는 문자열과 같이 사전에 삽입 될 때 원래 데이터 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bb15a03d4dace280b7ea3b362724ea82399447e5" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;*_by_lua&lt;/code&gt;, &lt;code&gt;*_by_lua_block&lt;/code&gt; and &lt;code&gt;*_by_lua_file&lt;/code&gt; configuration directives serve as gateways to the Lua API within the &lt;code&gt;nginx.conf&lt;/code&gt; file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</source>
          <target state="translated">다양한 &lt;code&gt;*_by_lua&lt;/code&gt; , &lt;code&gt;*_by_lua_block&lt;/code&gt; 및 &lt;code&gt;*_by_lua_file&lt;/code&gt; 구성 지시문은 &lt;code&gt;nginx.conf&lt;/code&gt; 내의 Lua API에 대한 게이트웨이 역할을합니다. 파일 합니다. 아래 설명 된 Nginx Lua API는 이러한 구성 지시문의 컨텍스트에서 실행되는 사용자 Lua 코드 내에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d93209feaafbc1a12da3a4ff746ce203ae75ff" translate="yes" xml:space="preserve">
          <source>Then</source>
          <target state="translated">Then</target>
        </trans-unit>
        <trans-unit id="0a2d7946869326684c93e256513ea22a5e2532c4" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;GET /main&lt;/code&gt; will give the output</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /main&lt;/code&gt; 은 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dcfc2a9d052e9410cd9b5db2eb718f34233c28fe" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;GET /orig&lt;/code&gt; will give</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /orig&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="11ebfa1866c1ad2d2575e0a4904d7d9ea2df0918" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;GET /t&lt;/code&gt; will just return the output</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /t&lt;/code&gt; 는 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f02bdd38980b3567fd2006573d464d3e0e9047b" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;GET /test&lt;/code&gt; will yield the output</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /test&lt;/code&gt; 는 출력을 산출합니다.</target>
        </trans-unit>
        <trans-unit id="a27689a4cf87415f2165bb395cae546b7d76351b" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;GET /test?foo=bar&amp;amp;bar=baz&amp;amp;bar=blah&lt;/code&gt; will yield the response body</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /test?foo=bar&amp;amp;bar=baz&amp;amp;bar=blah&lt;/code&gt; 는 응답 본문을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2745e53a02aeeeff820807c6f02f218b5d0c8582" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; will be evaluated to the table value &lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; 는 테이블 값 &lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="867ab26696f11437105bcedfaf4cb0e3f982a5e9" translate="yes" xml:space="preserve">
          <source>Then for the incoming data stream &lt;code&gt;'hello, world! -agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, we shall get the following output from the sample code above:</source>
          <target state="translated">그런 다음 수신 데이터 스트림 &lt;code&gt;'hello, world! -agentzh\r\n--abcedhb blah blah'&lt;/code&gt; , 위의 샘플 코드에서 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0eaf4acf4ced3299bbed6cfb57a331ec9b532ee8" translate="yes" xml:space="preserve">
          <source>Then for the input data stream &lt;code&gt;&quot;hello world _END_ blah blah blah&quot;&lt;/code&gt;, then the example above will output &lt;code&gt;hello world _END_&lt;/code&gt;, including the pattern string &lt;code&gt;_END_&lt;/code&gt; itself.</source>
          <target state="translated">그런 다음 입력 데이터 스트림 &lt;code&gt;&quot;hello world _END_ blah blah blah&quot;&lt;/code&gt; 에 대해 위 예제 는 패턴 문자열 &lt;code&gt;_END_&lt;/code&gt; 자체를 포함하여 &lt;code&gt;hello world _END_&lt;/code&gt; 를 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="84b398613be90d1dd7f5da3a27a2a7f6e0c3cd31" translate="yes" xml:space="preserve">
          <source>Then it will generate the output</source>
          <target state="translated">그런 다음 출력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="0854cc34835beeae4c73078714a07e5236cbdde9" translate="yes" xml:space="preserve">
          <source>Then request &lt;code&gt;GET /lua&lt;/code&gt; gives</source>
          <target state="translated">그런 다음 &lt;code&gt;GET /lua&lt;/code&gt; 에게 요청하십시오</target>
        </trans-unit>
        <trans-unit id="d5a78b87abf2b4673ecbc541b67e2bda764051e7" translate="yes" xml:space="preserve">
          <source>Then when building Nginx or OpenResty, pass the &lt;code&gt;--with-ld-opt=&quot;foo.o&quot;&lt;/code&gt; option to the &lt;code&gt;./configure&lt;/code&gt; script:</source>
          <target state="translated">그런 다음 Nginx 또는 OpenResty를 빌드 할 때 &lt;code&gt;--with-ld-opt=&quot;foo.o&quot;&lt;/code&gt; 옵션을 &lt;code&gt;./configure&lt;/code&gt; 스크립트에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="2d9a87c27a218a1f6e03e596aaaece4abe1cff91" translate="yes" xml:space="preserve">
          <source>There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the &lt;a href=&quot;http://search.cpan.org/perldoc?Test::Nginx&quot;&gt;Test::Nginx documentation&lt;/a&gt; for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: &lt;a href=&quot;http://qa.openresty.org&quot;&gt;http://qa.openresty.org&lt;/a&gt;.</source>
          <target state="translated">mockeagain, valgrind 등을 기반으로 한 다양한 테스트 모드도 있습니다. 다양한 고급 테스트 모드에 대한 자세한 내용 은 &lt;a href=&quot;http://search.cpan.org/perldoc?Test::Nginx&quot;&gt;Test :: Nginx 설명서&lt;/a&gt; 를 참조하십시오. Amazon EC2에서 실행되는 Nginx 테스트 클러스터에 대한 테스트 보고서 ( &lt;a href=&quot;http://qa.openresty.org&quot;&gt;http://qa.openresty.org)&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9ea12c61491d8d12905c0bfa2e0e882f413dbc3" translate="yes" xml:space="preserve">
          <source>There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the &lt;a href=&quot;http://search.cpan.org/perldoc?Test::Nginx&quot;&gt;Test::Nginx documentation&lt;/a&gt; for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: &lt;a href=&quot;https://qa.openresty.org&quot;&gt;http://qa.openresty.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2eb364a41bb020a4f7abb02d68e1625251fe56" translate="yes" xml:space="preserve">
          <source>There exists a work-around, however, when the original context does &lt;em&gt;not&lt;/em&gt; need to wait for the cosocket results. That is, creating a zero-delay timer via the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API and do the cosocket results in the timer handler, which runs asynchronously as to the original context creating the timer.</source>
          <target state="translated">그러나 원래 컨텍스트가 코 소켓 결과를 기다릴 필요 가 &lt;em&gt;없는&lt;/em&gt; 경우 해결 방법이 있습니다 . 즉, &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API 를 통해 제로 지연 타이머를 생성하고 코 소켓 결과를 생성하면 타이머 핸들러가 생성됩니다. 타이머 처리기는 원래 컨텍스트에서 타이머를 생성하는 것과 비동기 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="27f769dbad5ece88c4e9d6139bcb22b97592e282" translate="yes" xml:space="preserve">
          <source>There is a hard coded &lt;code&gt;2048&lt;/code&gt; byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; macro definition in the &lt;code&gt;src/core/ngx_log.h&lt;/code&gt; file in the Nginx source tree.</source>
          <target state="translated">Nginx 코어의 오류 메시지 길이 에는 하드 코딩 된 &lt;code&gt;2048&lt;/code&gt; 바이트 제한이 있습니다. 이 제한에는 후행 줄 바꿈 및 선행 타임 스탬프가 포함됩니다. 메시지 크기가이 제한을 초과하면 Nginx는 그에 따라 메시지 텍스트를 자릅니다. 이 한계는 &lt;code&gt;src/core/ngx_log.h&lt;/code&gt; 에서 &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; 매크로 정의를 편집하여 수동으로 수정할 수 있습니다. Nginx 소스 트리 파일에서 .</target>
        </trans-unit>
        <trans-unit id="5f93bd5fc8e1fd9117f533369b695eceb32a611b" translate="yes" xml:space="preserve">
          <source>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was &lt;code&gt;50&lt;/code&gt; concurrent subrequests and in more recent versions, Nginx &lt;code&gt;1.1.x&lt;/code&gt; onwards, this was increased to &lt;code&gt;200&lt;/code&gt; concurrent subrequests. When this limit is exceeded, the following error message is added to the &lt;code&gt;error.log&lt;/code&gt; file:</source>
          <target state="translated">모든 주요 요청에 대해 가능한 동시 하위 요청 수에는 하드 코딩 된 상한이 있습니다. 이전 버전의 Nginx에서는 한 번에 동시 하위 요청 이 &lt;code&gt;50&lt;/code&gt; 개 였으며 , 최신 버전에서는 Nginx &lt;code&gt;1.1.x&lt;/code&gt; 이후로이 수가 &lt;code&gt;200&lt;/code&gt; 개로 동시 하위 요청 으로 증가했습니다 . 이 한계를 초과하면 다음 오류 메시지가 &lt;code&gt;error.log&lt;/code&gt; 파일에 추가 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1d3cde6c32a3988a1b840dd4a879b969a241fc3" translate="yes" xml:space="preserve">
          <source>There is no way to use the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method to specify connecting timeout for this method and the &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt; directive must be set at configure time instead.</source>
          <target state="translated">&lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 메소드를 사용하여이 메소드에 대한 연결 시간 종료를 지정할 수있는 방법이 없으며 대신 구성 시간에 &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt; 지시문을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd2af8aa321d3ce806928a9432c6f6496b11e260" translate="yes" xml:space="preserve">
          <source>These constants are usually used by the &lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt; method.</source>
          <target state="translated">이 상수는 일반적으로 &lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4b4cbebf2656c694dcb77f7cd962cc955b796ea" translate="yes" xml:space="preserve">
          <source>These constants are usually used in &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; method calls.</source>
          <target state="translated">이 상수는 일반적으로 &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 및 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 에서 사용됩니다. 메서드 호출 .</target>
        </trans-unit>
        <trans-unit id="7d3128eea58990545d43b40f9798f537cd62fad0" translate="yes" xml:space="preserve">
          <source>These options can be combined:</source>
          <target state="translated">이 옵션들은 결합 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="69a14c2c57f459c15e02f8eceb620fc62d91bd08" translate="yes" xml:space="preserve">
          <source>These two forms are fundamentally equivalent.</source>
          <target state="translated">이 두 형태는 기본적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a294b87ae83f24b23d4cc036bde3cce057823970" translate="yes" xml:space="preserve">
          <source>This API also respect the &lt;a href=&quot;#lua_max_pending_timers&quot;&gt;lua_max_pending_timers&lt;/a&gt; and &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt;.</source>
          <target state="translated">이 API는 &lt;a href=&quot;#lua_max_pending_timers&quot;&gt;lua_max_pending_timers&lt;/a&gt; 및 &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; 도 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffd61be8b688191c6adcd8e08eaedb8d279fd4e" translate="yes" xml:space="preserve">
          <source>This API function (as well as &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;) always buffers the whole response body of the subrequest in memory. Thus, you should use &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt; and streaming processing instead if you have to handle large subrequest responses.</source>
          <target state="translated">이 API 함수 ( &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; )는 항상 하위 요청의 전체 응답 본문을 메모리에 버퍼링합니다. 따라서 큰 하위 요청 응답을 처리해야하는 경우 대신 &lt;a href=&quot;#ngxsockettcp&quot;&gt;코 소켓&lt;/a&gt; 및 스트리밍 처리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="073c461155c910d59c4f1d0e8fb1b9619eaa64da" translate="yes" xml:space="preserve">
          <source>This API function was first added to the &lt;code&gt;v0.10.1&lt;/code&gt; release.</source>
          <target state="translated">이 API 기능은 &lt;code&gt;v0.10.1&lt;/code&gt; 릴리스 에 처음 추가 되었습니다.</target>
        </trans-unit>
        <trans-unit id="124830fea6371533e0ed11aa5d9a6284089beb96" translate="yes" xml:space="preserve">
          <source>This API function was first introduced in the &lt;code&gt;v0.9.2&lt;/code&gt; release.</source>
          <target state="translated">이 API 기능은 &lt;code&gt;v0.9.2&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc27b9b2a3bf2de174244e046a31d9c81311a52a" translate="yes" xml:space="preserve">
          <source>This API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.</source>
          <target state="translated">이 API는 비교적 비싼 메타 메소드 호출이 필요하므로 핫 코드 경로에서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d058f122e111ff67bf509a45a9bef0bc81ec2c41" translate="yes" xml:space="preserve">
          <source>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the &lt;code&gt;--with-http_ssl_module&lt;/code&gt; option to the &lt;code&gt;./configure&lt;/code&gt; script).</source>
          <target state="translated">이 API를 사용하려면 Nginx 빌드에서 OpenSSL 라이브러리를 활성화해야합니다 (보통 &lt;code&gt;--with-http_ssl_module&lt;/code&gt; 옵션을 &lt;code&gt;./configure&lt;/code&gt; 스크립트에 전달).</target>
        </trans-unit>
        <trans-unit id="eaf1f1abf0a2bd266d528c13cd426502e58abfd3" translate="yes" xml:space="preserve">
          <source>This API was first enabled in the &lt;code&gt;v0.6.0&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.6.0&lt;/code&gt; 릴리스 에서 처음 사용 되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb1c20977be5980b5dffafbf094a213994e04e38" translate="yes" xml:space="preserve">
          <source>This API was first enabled in the &lt;code&gt;v0.7.0&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.7.0&lt;/code&gt; 릴리스 에서 처음 사용 되었습니다.</target>
        </trans-unit>
        <trans-unit id="07bb8dfc07b529bc7d30218081451f11aadab8cb" translate="yes" xml:space="preserve">
          <source>This API was first enabled in the &lt;code&gt;v0.9.9&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.9.9&lt;/code&gt; 릴리스 에서 처음 사용 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6b06ce05bc80d712279da3c3552a2abec489f97" translate="yes" xml:space="preserve">
          <source>This API was first introduced in &lt;code&gt;v0.3.1rc32&lt;/code&gt;.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.3.1rc32&lt;/code&gt; 에서 처음 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="56ba1671edb3c4e51b3548fbc5543f56bb5a496d" translate="yes" xml:space="preserve">
          <source>This API was first introduced in ngx_lua v0.3.1rc6.</source>
          <target state="translated">이 API는 ngx_lua v0.3.1rc6에서 처음 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7be04dfa0f4cd10182b8aca3a10bcbd8980c15f" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;0.9.20&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;0.9.20&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7947818f6263d45180bf357ad69f7642750a31b" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;0.9.3&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;0.9.3&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="4091161f2a3c56021fd534da88f071bffaf43120" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;0.9.5&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;0.9.5&lt;/code&gt; 에서 처음 도입되었습니다. 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca28ec0051905855c12d2b0989ea7628d5fefd43" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.10.9&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.10.9&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f96d67d4e94fef37b1bc1d2ca8c634aca23ad711" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.3.1rc8&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.3.1rc8&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f3efab3146e46ff06a62e58c93c3f1292ea907c" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.5.10&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.5.10&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a0b3990241906331fda8298678ecba55006acb8" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.6.0&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.6.0&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5c7acd2f1cd540a6b91b24ba334d64c9bbc812a" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.7.4&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.7.4&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6a631cf4e42106365b93d6532cb450b3d13daee" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.8.0&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.8.0&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="352c3683af64fe339e5c0f7efdeb7e725feca526" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.9.20&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.9.20&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="47b16c413ac5914784760a6550b6c82e7382f364" translate="yes" xml:space="preserve">
          <source>This API was first introduced in the &lt;code&gt;v0.9.5&lt;/code&gt; release.</source>
          <target state="translated">이 API는 &lt;code&gt;v0.9.5&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d1e6c505dc88d0f71e31693dcc8c43cd5821d55" translate="yes" xml:space="preserve">
          <source>This API was first usable in the context of &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt; since the &lt;code&gt;0.9.2&lt;/code&gt;.</source>
          <target state="translated">이 API는 &lt;code&gt;0.9.2&lt;/code&gt; 이후 &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt; 와 관련하여 처음 사용할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="b42446e8bd13d9a0d0745430d74eeb3d75000148" translate="yes" xml:space="preserve">
          <source>This Lua code execution context &lt;em&gt;does&lt;/em&gt; support yielding, so Lua APIs that may yield (like cosockets, sleeping, and &quot;light threads&quot;) are enabled in this context.</source>
          <target state="translated">이 Lua 코드 실행 컨텍스트 &lt;em&gt;는&lt;/em&gt; 양보를 지원하므로이 컨텍스트에서 생성 될 수있는 Lua API (예 : 코 소켓, 수면 및 &quot;가벼운 스레드&quot;)가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="28f39fcd1746088dadc5de24677b8f530216f09b" translate="yes" xml:space="preserve">
          <source>This Lua code execution context does not support yielding, so Lua APIs that may yield (like cosockets and &quot;light threads&quot;) are disabled in this context. One can usually work around this limitation by doing such operations in an earlier phase handler (like &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;) and passing along the result into this context via the &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table.</source>
          <target state="translated">이 Lua 코드 실행 컨텍스트는 양보를 지원하지 않으므로이 컨텍스트에서 양산 될 수있는 Lua API (예 : 코 소켓 및 &quot;라이트 스레드&quot;)가 비활성화됩니다. 일반적으로 초기 단계 핸들러 (예 : &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; ) 에서 이러한 작업을 수행 하고 결과를 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; 테이블 을 통해이 컨텍스트로 전달 하여이 제한을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="698bc3ca3356fb8c70046deba3672b36c89f7034" translate="yes" xml:space="preserve">
          <source>This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes the SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In other words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.</source>
          <target state="translated">그러나 NGINX / OpenSSL이 SSL 세션 ID 또는 현재 SSL 연결에 대한 TLS 세션 티켓을 통해 SSL 세션을 성공적으로 재개 할 때이 Lua 핸들러는 전혀 실행되지 않습니다. 즉,이 Lua 핸들러는 NGINX가 전체 SSL 핸드 셰이크를 시작해야하는 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f26656cb70005dae06cb7a5932362f35b59296ac" translate="yes" xml:space="preserve">
          <source>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">이 Lua 모듈은이 ngx_lua 모듈 자체와 함께 제공되지 않고 &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; 라이브러리 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3eada3ba0df3425be8bc0d66ee324ba3743bd87b" translate="yes" xml:space="preserve">
          <source>This Lua module provides API functions to control the SSL handshake process in contexts like &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt;.</source>
          <target state="translated">이 Lua 모듈은 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt; 와 같은 컨텍스트에서 SSL 핸드 셰이크 프로세스를 제어하는 ​​API 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5a085478e6d8eccd84a480d0223dd7ff82d17739" translate="yes" xml:space="preserve">
          <source>This Lua module provides API to perform OCSP queries, OCSP response validations, and OCSP stapling planting.</source>
          <target state="translated">이 Lua 모듈은 OCSP 쿼리, OCSP 응답 검증 및 OCSP 스테이플 링 심기를 수행하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ee74bee80759999dc970082a6122ae0692443e3f" translate="yes" xml:space="preserve">
          <source>This also applies to &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc93b1ec2ba0fab80c20df48d34c1deec8a61e9c" translate="yes" xml:space="preserve">
          <source>This argument can be set to zero to remove the limit and to process all request arguments received:</source>
          <target state="translated">이 인수는 한계를 제거하고 수신 된 모든 요청 인수를 처리하기 위해 0으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a85e03d9b81d30be679e6d026bfddaa930f2ed9e" translate="yes" xml:space="preserve">
          <source>This argument can be set to zero to remove the limit and to process all request headers received:</source>
          <target state="translated">이 인수는 한계를 제거하고 수신 된 모든 요청 헤더를 처리하기 위해 0으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e64aa15a4a158416bcd2292a83f5d6b86ed175" translate="yes" xml:space="preserve">
          <source>This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the &lt;code&gt;./configure&lt;/code&gt; option &lt;code&gt;--with-debug&lt;/code&gt;.</source>
          <target state="translated">이 부울 필드는 현재 Nginx가 디버그 빌드인지, 즉 &lt;code&gt;./configure&lt;/code&gt; 옵션 &lt;code&gt;--with-debug&lt;/code&gt; 에 의해 빌드되는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="00a40bdc732303b41974d6bd779f5adafe9c6017" translate="yes" xml:space="preserve">
          <source>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even &lt;code&gt;1&lt;/code&gt; byte buffer size should still work everywhere but the performance could be terrible.</source>
          <target state="translated">이 버퍼는 코 소켓이 100 % 버퍼되지 않은 읽기 및 구문 분석을 지원하므로 모든 것을 동시에 보유하기 위해 크지 않아도됩니다. 따라서 &lt;code&gt;1&lt;/code&gt; 바이트 버퍼 크기도 여전히 모든 곳에서 작동해야하지만 성능은 끔찍할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68093e399a74a014706b233cb9d5289f9ec67e7b" translate="yes" xml:space="preserve">
          <source>This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</source>
          <target state="translated">이 버퍼는 절대 커지지 않습니다. 가득 차면 새로운 오류 로그 메시지가 버퍼에서 가장 오래된 메시지를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e6f035493ae7f11ac2c5ceb682e0f2c53b946328" translate="yes" xml:space="preserve">
          <source>This directive can be freely mixed with all directives of the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;, &lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt;, and &lt;a href=&quot;http://github.com/openresty/array-var-nginx-module&quot;&gt;array-var-nginx-module&lt;/a&gt; modules. All of these directives will run in the same order as they appear in the config file.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; , &lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt; 및 &lt;a href=&quot;http://github.com/openresty/array-var-nginx-module&quot;&gt;array-var-nginx-module의&lt;/a&gt; 모든 지시문과 자유롭게 혼합 할 수 있습니다. 모듈의 . 이러한 모든 지시문은 구성 파일에 표시되는 것과 동일한 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ad237dbbf89327cc7ad99152517079b9b4eec2af" translate="yes" xml:space="preserve">
          <source>This directive can be freely mixed with all directives of the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;, &lt;a href=&quot;https://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt;, and &lt;a href=&quot;https://github.com/openresty/array-var-nginx-module&quot;&gt;array-var-nginx-module&lt;/a&gt; modules. All of these directives will run in the same order as they appear in the config file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6833c048d389e8488d9775d6f06f80722cb43b" translate="yes" xml:space="preserve">
          <source>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</source>
          <target state="translated">이 지정 문은 TCP 또는 UDP 코 소켓에 대해 오류가 발생할 때 오류 로깅을 토글하는 데 사용될 수 있습니다. Lua 코드에서 이미 올바른 오류 처리 및 로깅을 수행하는 경우 nginx 오류 로그 파일에서 데이터 플러시를 방지하려면이 지시문을 끄는 것이 좋습니다 (보통 다소 비쌉니다).</target>
        </trans-unit>
        <trans-unit id="4a92b2155af17f15850cb08e066c15d2de3f99b4" translate="yes" xml:space="preserve">
          <source>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; method.</source>
          <target state="translated">이 지정 문은 코 소켓 내장 연결 풀에서 연결의 기본 최대 유휴 시간을 제어합니다. 이 시간 초과에 도달하면 유휴 연결이 닫히고 풀에서 제거됩니다. 이 설정은 cosocket 객체의 &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; 방법 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e332301365d4441bb00a11e72c7a05ae4a9599c" translate="yes" xml:space="preserve">
          <source>This directive controls the default timeout value used in TCP/unix-domain socket object's &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt; method and can be overridden by the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; or &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; methods.</source>
          <target state="translated">이 지정 문은 TCP / unix-domain 소켓 오브젝트의 &lt;a href=&quot;#tcpsockconnect&quot;&gt;연결&lt;/a&gt; 메소드 에서 사용되는 기본 시간 종료 값을 제어하며 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 또는 &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; 메소드 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe6cfd4127607f21e44e004a1344f29b465ad8dc" translate="yes" xml:space="preserve">
          <source>This directive controls the default timeout value used in TCP/unix-domain socket object's &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; method and iterator functions returned by the &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; method. This setting can be overridden by the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; or &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; methods.</source>
          <target state="translated">이 지정 문 은 &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; 메소드가 리턴 한 TCP / unix-domain 소켓 오브젝트의 &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; 메소드 및 반복자 함수에 사용되는 기본 시간 종료 값을 제어합니다 . 이 설정은 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; 또는 &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; 로 재정의 할 수 있습니다. 메소드 .</target>
        </trans-unit>
        <trans-unit id="c70dd833613431dc3694aaefdcaea040b1be30f7" translate="yes" xml:space="preserve">
          <source>This directive controls whether to check for premature client connection abortion.</source>
          <target state="translated">이 지시문은 조기 클라이언트 연결 중단을 확인할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="aa604cbb755627a5326669110b88b394d4247943" translate="yes" xml:space="preserve">
          <source>This directive currently requires the following NGINX core patch to work correctly:</source>
          <target state="translated">이 지시문은 현재 다음 NGINX 코어 패치가 올바르게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="05258018cd2044f3272f119b24108e0ac10ad61b" translate="yes" xml:space="preserve">
          <source>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</source>
          <target state="translated">이 지시문은 코드 실행 중 Nginx 이벤트 루프가 차단되므로 짧고 빠르게 실행되는 코드 블록을 실행하도록 설계되었습니다. 따라서 시간이 많이 걸리는 코드 시퀀스를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b1bc423124ae13532f0ee1511426b54608cf591" translate="yes" xml:space="preserve">
          <source>This directive is implemented by injecting custom commands into the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s command list. Because &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua &quot;light thread&quot; cannot work in this directive.</source>
          <target state="translated">이 지시문은 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; 의 명령 목록에 사용자 정의 명령을 삽입하여 구현됩니다 . &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; 때문에 은 명령에서 비 차단 I / O를 지원하지 않기 현재 Lua &quot;light thread&quot;를 생성해야하는 Lua API는이 지시문에서 작동 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0faf7cbb704562392b5a2c8ac4b67125aec5a471" translate="yes" xml:space="preserve">
          <source>This directive is implemented by injecting custom commands into the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s command list. Because &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua &quot;light thread&quot; cannot work in this directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a2675ffd6791635c365b02be6d7fb56771e453" translate="yes" xml:space="preserve">
          <source>This directive is turned &lt;code&gt;on&lt;/code&gt; by default.</source>
          <target state="translated">이 지시문은 기본적으로 켜져 &lt;code&gt;on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="966d256ac515e5b981b1d5765420a799eef75759" translate="yes" xml:space="preserve">
          <source>This directive is turned on by default.</source>
          <target state="translated">이 지시문은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b9b6dae2006d538cf51bb6b9da954360ab69c3" translate="yes" xml:space="preserve">
          <source>This directive requires the &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;ngx_devel_kit&lt;/a&gt; module.</source>
          <target state="translated">이 지시문에는 &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;ngx_devel_kit&lt;/a&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="43c2ebab47a0fee63c32630f90c1de6146534e5b" translate="yes" xml:space="preserve">
          <source>This directive runs Lua code as an upstream balancer for any upstream entities defined by the &lt;code&gt;upstream {}&lt;/code&gt; configuration block.</source>
          <target state="translated">이 지시문은 &lt;code&gt;upstream {}&lt;/code&gt; 구성 블록에 의해 정의 된 업스트림 엔티티에 대해 업스트림 밸런서로 Lua 코드를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="72552743119a577068d28f9e3e8937966df21509" translate="yes" xml:space="preserve">
          <source>This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).</source>
          <target state="translated">이 지시문은 Lua 코드를 실행하여 다운 스트림에 대한 현재 SSL 핸드 셰이크 요청에서 제공 한 세션 ID에 따라 SSL 세션을 가져오고 저장합니다 (있는 경우). 저장 또는 캐시 된 SSL 세션 데이터는 전체 SSL 핸드 셰이크 프로세스 (CPU 시간 측면에서 매우 비싸다)를 거치지 않고 SSL 세션을 재개하기 위해 향후 SSL 연결에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91c5b7e007100220fd13a68127d495dd436604b3" translate="yes" xml:space="preserve">
          <source>This directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.</source>
          <target state="translated">이 지시문은 Lua 코드를 실행하여 다운 스트림에 대한 현재 SSL 핸드 셰이크 요청에서 제공 한 세션 ID에 따라 SSL 세션을 찾고로드합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f157917a6c397f4428d9e47e41cf8777acbbf6da" translate="yes" xml:space="preserve">
          <source>This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream SSL (https) connections.</source>
          <target state="translated">이 지시문은 NGINX가 다운 스트림 SSL (https) 연결을위한 SSL 핸드 셰이크를 시작하려고 할 때 사용자 Lua 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="20aa4bf973a332f377e5e121f2164c33f5ab97b1" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.10.0&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.10.0&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e703aa969e97d311451d8ba8becc7781e7b4998" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.10.6&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.10.6&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="639bbd0cc15ae5db5550cd53b776786509f26e66" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.10.7&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.10.7&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="abd982686a7cf5ad53debfe091f7125223804c58" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.10.9&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.10.9&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5451ca1827a84751fa9e8a0b342a8865d7f2dd8" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.2.1rc20&lt;/code&gt; release.</source>
          <target state="translated">이 지시어는 &lt;code&gt;v0.2.1rc20&lt;/code&gt; 릴리스 에서 처음 소개 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f83700bdd9f038e425a3ef018580f8355611ae94" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6bab658c9cfa2c7df8ba9e68b06d406b2ea24cc9" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7dc4e668a75c1c0f8fb2f7492acc9bb25b91d1a" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="020bfecfac04f640e0af1872518ce36ff69c4dbd" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="a74957b0620e96b66a45841926ccebbc0e5101c6" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.0rc31&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.0rc31&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="210819e99d76e019b15ea05b5af6a651b5f172fb" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e13a92ea945c67e6ddb2eda1c47ea3c24c5f34b" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.13&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.13&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="85ceeb256d2031e2a76573826b11d8858b295e55" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.5.5&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.5.5&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="399d736069b3dbdac12ba857203fbc1ecf303198" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.7.4&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.7.4&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b57be562192f90700725a3c6272b839531b679c" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.8.0&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.8.0&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="32a99d5303db0916ba92502c7de108ea41105591" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.8.5&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.8.5&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc8789dd65279a72bd51bfd2db1f4c1285c326b6" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.9.11&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.9.11&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb7ece61f4fbc1e238f802f79761cc92b123fee6" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.9.17&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.9.17&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b668de35606cf2aca8305a40d4443ff6a58d2bb" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.9.1&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.9.1&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5ad21da907ecc15d872d1c8cef5d687a1cddafe" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.9.20&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.9.20&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f76acd06d4a49f75839659b108b835233ae7d14" translate="yes" xml:space="preserve">
          <source>This directive was first introduced in the &lt;code&gt;v0.9.5&lt;/code&gt; release.</source>
          <target state="translated">이 지시문은 &lt;code&gt;v0.9.5&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c4dc6856e3ae3ddb90d885dedbce8073a6568aa" translate="yes" xml:space="preserve">
          <source>This document describes ngx_lua &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;v0.10.13&lt;/a&gt; released on 22 April 2018.</source>
          <target state="translated">이 문서는 2018 년 4 월 22 일에 릴리스 된 ngx_lua &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;v0.10.13에&lt;/a&gt; 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="3ce357e0d6d0880ef5bfe886f336dc6a9f5a3522" translate="yes" xml:space="preserve">
          <source>This example produces the output</source>
          <target state="translated">이 예제는 출력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="b62d1675d707f7b35eb369c2f6f5bc883e49e69b" translate="yes" xml:space="preserve">
          <source>This feature requires at least nginx core version &lt;code&gt;0.7.3&lt;/code&gt;.</source>
          <target state="translated">이 기능에는 최소한 nginx 코어 버전 &lt;code&gt;0.7.3&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="eaebf26ef879d7bd191e5088fa55f053a9abf6dc" translate="yes" xml:space="preserve">
          <source>This feature requires at least nginx core version &lt;code&gt;1.11.7&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하려면 최소한 nginx 코어 버전 &lt;code&gt;1.11.7&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="fa64ef986ea2ac075f6762f420622806c2d108ce" translate="yes" xml:space="preserve">
          <source>This feature requires at least ngx_lua &lt;code&gt;v0.10.0&lt;/code&gt;.</source>
          <target state="translated">이 기능에는 최소한 ngx_lua &lt;code&gt;v0.10.0&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="65b636476e87291c29e3da5e9400ef8f424e67e2" translate="yes" xml:space="preserve">
          <source>This feature requires the &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;ngx_devel_kit&lt;/a&gt; module.</source>
          <target state="translated">이 기능에는 &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;ngx_devel_kit&lt;/a&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6e65e9db12791120855f942f3a9002be6535e753" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.10.11&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.10.11&lt;/code&gt; 릴리스 에서 처음 소개 되었습니다.</target>
        </trans-unit>
        <trans-unit id="126482ec5737c0279ab28e47d795e733362f7605" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.10.6&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.10.6&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="53dfc90594a44aecf5b9b68ddf88aa336fee480e" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.10.7&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.10.7&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="246633ee2a887165d08e065b3fbc4f07dfd811ef" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.2.1rc12&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.2.1rc12&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc98d5f778a394064f3290c99ed43fa46bcebb18" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.2.1rc13&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.2.1rc13&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="a320ed9c6304c389d0bafb436687dbb220b34581" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.2.1rc15&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.2.1rc15&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e60704aa795b6706902e6a2fd197d759c1b0f786" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="02396d434c635c9c686661539b43384bffd7119c" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.5.0rc17&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.0rc17&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="38b048a8352db6c9b0407f80305c1309e8b671db" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="4dbf0627f2373edea9c080cc6eb19fd61ecaa546" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.7&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed97f2e4e3dabfaf07e08205c840cd78dc49a999" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.6.3&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.6.3&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="df92dcfa3a9650d6ea0a180e1eeb71d0bac14431" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.7.18&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.7.18&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef4c94860a1f9b1f4d91a1966486475bba63addd" translate="yes" xml:space="preserve">
          <source>This feature was first introduced in the &lt;code&gt;v0.7.3&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.7.3&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="7577d05e592509e6e63022b5adc96e3a42345435" translate="yes" xml:space="preserve">
          <source>This feature was introduced in the &lt;code&gt;v0.2.1rc11&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.2.1rc11&lt;/code&gt; 릴리스 에서 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="db80afb5c322d57971926cdfb35258656cfeb2d1" translate="yes" xml:space="preserve">
          <source>This field take an integral value indicating the version number of the current &lt;code&gt;ngx_lua&lt;/code&gt; module being used. For example, the version number &lt;code&gt;0.9.3&lt;/code&gt; results in the Lua number 9003.</source>
          <target state="translated">이 필드 는 사용중인 현재 &lt;code&gt;ngx_lua&lt;/code&gt; 모듈 의 버전 번호를 나타내는 정수 값을 갖습니다 . 예를 들어 버전 번호 &lt;code&gt;0.9.3&lt;/code&gt; 은 Lua 번호 9003이됩니다.</target>
        </trans-unit>
        <trans-unit id="5e6c4467aa23b55325fac28b29dd2eb2a2e2992f" translate="yes" xml:space="preserve">
          <source>This field take an integral value indicating the version number of the current Nginx core being used. For example, the version number &lt;code&gt;1.4.3&lt;/code&gt; results in the Lua number 1004003.</source>
          <target state="translated">이 필드는 사용중인 현재 Nginx 코어의 버전 번호를 나타내는 정수 값을 갖습니다. 예를 들어, 버전 번호 &lt;code&gt;1.4.3&lt;/code&gt; 은 Lua 번호 1004003이됩니다.</target>
        </trans-unit>
        <trans-unit id="de21b0df7224b8b35678cee42de047bfd905f4c8" translate="yes" xml:space="preserve">
          <source>This field was first introduced in the &lt;code&gt;0.10.1&lt;/code&gt;.</source>
          <target state="translated">이 필드는 &lt;code&gt;0.10.1&lt;/code&gt; 에서 처음 소개되었습니다 .</target>
        </trans-unit>
        <trans-unit id="86369c84314a915b099f23d02efb5f5f8436ede2" translate="yes" xml:space="preserve">
          <source>This field was first introduced in the &lt;code&gt;0.8.7&lt;/code&gt;.</source>
          <target state="translated">이 필드는 &lt;code&gt;0.8.7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc1125a99662f019c4261a888559a8a0ded9d53" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; , &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 과 함께 사용하여 순수한 Lua에서 효율적인 입력 필터를 구현할 수 있습니다 ( &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 또는 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; 의 컨텍스트에서 ). Nginx 컨텐츠 핸들러 또는 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; 및&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt; ngx_http_fastcgi_module&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1975999547af3c6fc047c4378578fc954bbbddb" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8f6bad46d60b81976e0f954ac746a5903d007a" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; , &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 과 함께 사용하여 순수한 Lua에서 효율적인 입력 필터를 구현할 수 있습니다 ( &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 또는 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; 의 컨텍스트에서 ). Nginx의 콘텐츠 핸들러 나 같은 업스트림 모듈 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; 및 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5956b5354404cb9afd79c472c3a9855fc656c133" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02d358ec4b63d66728f9e3223622f93d9972e3f" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; , &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; 및 &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; 과 함께 사용하여 순수한 Lua에서 효율적인 입력 필터를 구현할 수 있습니다 ( &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt; 또는 &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt; 의 컨텍스트에서 ). Nginx의 콘텐츠 핸들러 나 같은 업스트림 모듈 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; 및 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93079ad93ec0a5c462ea3b8c8422a4493f4ba79d" translate="yes" xml:space="preserve">
          <source>This function can be used with &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;, &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; to implement efficient input filters in pure Lua (in the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; or &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;), which can be used with other Nginx content handler or upstream modules like &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; and &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf7c3e09f0de5420897cc5e6bc10c3f34293f1" translate="yes" xml:space="preserve">
          <source>This function has the same signature as &lt;a href=&quot;#ngxreqget_headers&quot;&gt;ngx.req.get_headers&lt;/a&gt; except getting response headers instead of request headers.</source>
          <target state="translated">이 함수는 요청 헤더 대신 응답 헤더를 얻는 것을 제외하고 &lt;a href=&quot;#ngxreqget_headers&quot;&gt;ngx.req.get_headers&lt;/a&gt; 와 동일한 서명을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="98a85d9dd9d43ed47b9138c1560d7145a9eece65" translate="yes" xml:space="preserve">
          <source>This function is a shortcut for combining &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp()&lt;/a&gt; and the &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect()&lt;/a&gt; method call in a single operation. It is actually implemented like this:</source>
          <target state="translated">이 함수는 단일 작업에서 &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp ()&lt;/a&gt; 및 &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect ()&lt;/a&gt; 메서드 호출 을 결합하기위한 바로 가기입니다 . 실제로 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="bb01e4d92dd09847d5f8a1c0bf97c01d95154bc1" translate="yes" xml:space="preserve">
          <source>This function is added for &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt;LuaSocket&lt;/a&gt; API compatibility and does nothing for now. Its functionality will be implemented in future.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt; LuaSocket&lt;/a&gt; API 호환성을 되었으며 현재로서는 아무 것도 수행하지 않습니다. 그 기능은 미래에 구현 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="75f979b4847e802252cddd2219bafcfd3603def6" translate="yes" xml:space="preserve">
          <source>This function is an asynchronous call and returns immediately.</source>
          <target state="translated">이 함수는 비동기 호출이며 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fdf564ddd6ae8405bd5659721bdffa85cae0d6b" translate="yes" xml:space="preserve">
          <source>This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,</source>
          <target state="translated">이 함수는 입력 테이블에 지정된 여러 병렬 하위 요청을 발행하고 결과를 동일한 순서로 리턴합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d361f892815ef828b5b483c06e6a11e46fae197a" translate="yes" xml:space="preserve">
          <source>This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).</source>
          <target state="translated">이 기능을 사용하려면 Nginx 빌드에서 SHA-1 지원이 필요합니다. (이것은 보통 Nginx를 빌드하는 동안 OpenSSL을 설치해야 함을 의미합니다).</target>
        </trans-unit>
        <trans-unit id="39c35126c7417909014b8ee2fc507e3014c57a47" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;nil&lt;/code&gt; if</source>
          <target state="translated">이 함수는 다음과 같은 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="27f4f895d8ebc971a0cfd8e0e192e6e72c148b54" translate="yes" xml:space="preserve">
          <source>This function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than &lt;code&gt;ngx.var.pid&lt;/code&gt; and can be used in contexts where the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt; API cannot be used (like &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt;).</source>
          <target state="translated">이 함수는 현재 Nginx 작업자 프로세스의 프로세스 ID (PID)에 대한 루아 번호를 반환합니다. 이 API는 &lt;code&gt;ngx.var.pid&lt;/code&gt; 보다 효율적이며 &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt; API를 사용할 수없는 상황 (예 : &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt; )에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9efcf34206aa1159f37ec0f9daa8bfbad1b71fef" translate="yes" xml:space="preserve">
          <source>This function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).</source>
          <target state="translated">이 함수는 현재 Nginx 작업자 프로세스가 이미 종료되기 시작하는지 여부를 나타내는 부울 값을 반환합니다. Nginx 작업자 프로세스 종료는 Nginx 서버 종료 또는 구성 재로드 (일명 HUP 재로드)에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bfa05e68c435d81fd864551512a9c9410c3d936" translate="yes" xml:space="preserve">
          <source>This function returns a string for the NGINX &lt;code&gt;./configure&lt;/code&gt; command's arguments string.</source>
          <target state="translated">이 함수는 NGINX &lt;code&gt;./configure&lt;/code&gt; 명령의 인수 문자열에 대한 문자열을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f7737b3b1a43b63b7ba3f60fd18006bcf4941ef1" translate="yes" xml:space="preserve">
          <source>This function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, it always returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 함수는 NGINX 1.9.1+에 대해서만 의미있는 값을 반환합니다. 이전 버전의 NGINX에서는 항상 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="06240e5e02a8e3d9437cafe67b4a56506cd98936" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;0.9.2&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;0.9.2&lt;/code&gt; 에서 처음 도입되었습니다. .</target>
        </trans-unit>
        <trans-unit id="72b74208d479a492e349209b286b533a25e2d4f8" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.3.1rc17&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.3.1rc17&lt;/code&gt; 에서 처음 도입되었습니다 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c0eb4b3b744365f24028fdbdef97ba810707574" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.3.1rc18&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.3.1rc18&lt;/code&gt; 에서 처음 도입되었습니다 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="39690940ad5fc85f5d270afea776dea09ce9afa2" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.3.1rc29&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.3.1rc29&lt;/code&gt; 에서 처음 도입되었습니다 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b6d2a227aebf85f25e502eb35c86b8b68a24cec8" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 에서 처음 도입되었습니다. 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="84abb3df79e3973a266157f465b0a094432c2054" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.5.0rc6&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.0rc6&lt;/code&gt; 에서 처음 도입되었습니다. .</target>
        </trans-unit>
        <trans-unit id="daf1f07ea830812fc7702fc5b70f10d75b4e960f" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.5.11&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.5.11&lt;/code&gt; 에서 처음 도입되었습니다. 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f07c2f8a257e1020346ac97fd10cc58ddf21bb8" translate="yes" xml:space="preserve">
          <source>This function was first introduced in the &lt;code&gt;v0.7.7&lt;/code&gt; release.</source>
          <target state="translated">이 기능은 &lt;code&gt;v0.7.7&lt;/code&gt; 에서 처음 도입되었습니다. 릴리스 되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c03ca40151ee0ff552fa8b8af4b079356e891b2" translate="yes" xml:space="preserve">
          <source>This function will not return until all the subrequests terminate. The total latency is the longest latency of the individual subrequests rather than the sum.</source>
          <target state="translated">이 함수는 모든 하위 요청이 종료 될 때까지 반환되지 않습니다. 총 대기 시간은 합계가 아닌 개별 하위 요청의 가장 긴 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="d98bd168fe6afc8bad95d319750f3f75a778c04e" translate="yes" xml:space="preserve">
          <source>This hook is often used to create per-worker reoccurring timers (via the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; Lua API), either for backend health-check or other timed routine work. Below is an example,</source>
          <target state="translated">이 후크는 종종 백엔드 상태 점검 또는 기타 정기 작업을 위해 작업자 별 재발 타이머 ( &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; Lua API 를 통해)를 작성하는 데 사용됩니다 . 아래는 예입니다.</target>
        </trans-unit>
        <trans-unit id="0049bd71d0daf3c9c7a289bccaec1c20ee7ffe00" translate="yes" xml:space="preserve">
          <source>This hook no longer runs in the cache manager and cache loader processes since the &lt;code&gt;v0.10.12&lt;/code&gt; release.</source>
          <target state="translated">이 후크는 &lt;code&gt;v0.10.12&lt;/code&gt; 릴리스 이후 더 이상 캐시 관리자 및 캐시 로더 프로세스에서 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="12a046d7fd38d6bc933afc749d40e490f5f2d555" translate="yes" xml:space="preserve">
          <source>This hook, together with the &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua*&lt;/a&gt; hook, can be used to implement distributed caching mechanisms in pure Lua (based on the &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosocket&lt;/a&gt; API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua *&lt;/a&gt; 후크 와 함께 순수 Lua ( &lt;a href=&quot;#ngxsockettcp&quot;&gt;코 소켓&lt;/a&gt; 기반)에서 분산 캐싱 메커니즘을 구현하는 데 사용할 수 있습니다 예 : API . 캐시 된 SSL 세션이 발견되어 현재 SSL 연결 컨텍스트에로드되면 SSL 세션 재개가 즉시 시작되어 전체 SSL 핸드 셰이크 프로세스를 무시하고 CPU 시간 측면에서 매우 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="f544007228f8b9f5612e795f09ef89cec24c7d94" translate="yes" xml:space="preserve">
          <source>This interface was first introduced in the &lt;code&gt;v0.3.1rc13&lt;/code&gt; release.</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;v0.3.1rc13&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9bc7e23dba7b45388ea63a949fb1a195c31a6dc8" translate="yes" xml:space="preserve">
          <source>This interface was first introduced in the &lt;code&gt;v0.3.1rc14&lt;/code&gt; release.</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;v0.3.1rc14&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="8eca6c1df74469066f8294cec1d983e4cd95dd5b" translate="yes" xml:space="preserve">
          <source>This is a Lua module that implements a classic-style semaphore API for efficient synchronizations among different &quot;light threads&quot;. Sharing the same semaphore among different &quot;light threads&quot; created in different (request) contexts are also supported as long as the &quot;light threads&quot; reside in the same NGINX worker process and the &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache&lt;/a&gt; directive is turned on (which is the default).</source>
          <target state="translated">이것은 다른 &quot;경량 스레드&quot;간의 효율적인 동기화를 위해 클래식 스타일의 세마포어 API를 구현하는 Lua 모듈입니다. &quot;라이트 스레드&quot;가 동일한 NGINX 작업자 프로세스에 있고 &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache&lt;/a&gt; 지시문이 켜져있는 경우 (기본값) 다른 (요청) 컨텍스트에서 작성된 다른 &quot;라이트 스레드&quot;간에 동일한 세마포어 공유가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="332c45682de593d442ad645aba892e10fd91aaac" translate="yes" xml:space="preserve">
          <source>This is a Lua module that provides a Lua API to allow defining completely dynamic load balancers in pure Lua.</source>
          <target state="translated">이것은 순수 Lua에서 완전 동적로드 밸런서를 정의 할 수 있도록 Lua API를 제공하는 Lua 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="ac279947186e424b8ee357a8ff59c8d544fae53d" translate="yes" xml:space="preserve">
          <source>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call &lt;code&gt;ngx.flush(true)&lt;/code&gt; after calling &lt;code&gt;ngx.print&lt;/code&gt;. This can be particularly useful for streaming output. See &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt; for more details.</source>
          <target state="translated">이것은 비동기 호출이며 모든 데이터가 시스템 송신 버퍼에 기록 될 때까지 기다리지 않고 즉시 리턴됩니다. 동기 모드로 실행하려면 &lt;code&gt;ngx.flush(true)&lt;/code&gt; 를 호출 한 후 ngx.flush (true) 를 호출 &lt;code&gt;ngx.print&lt;/code&gt; . 스트리밍 출력에 특히 유용 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e66c964fb3c23d4fdb96e9ccdbeb747ef835990" translate="yes" xml:space="preserve">
          <source>This is functionally identical to the previous examples.</source>
          <target state="translated">이것은 이전 예제와 기능적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98fd6c1f95c96ca864c256ab8ede9f57fc04fdcf" translate="yes" xml:space="preserve">
          <source>This is particularly useful in the context of &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;, for example,</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt; 와 관련하여 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="ce57553bbcbd556d34723ff20f45d4ad47c82906" translate="yes" xml:space="preserve">
          <source>This is the UTC time.</source>
          <target state="translated">이것은 UTC 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0c91f1781a683bbba310b40ce815df5672a8e224" translate="yes" xml:space="preserve">
          <source>This is the local time.</source>
          <target state="translated">현지 시간입니다.</target>
        </trans-unit>
        <trans-unit id="18e90cc4a678544e3853d917ac47f4293f2e1f95" translate="yes" xml:space="preserve">
          <source>This issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.</source>
          <target state="translated">이 문제는 Nginx 이벤트 모델의 제한 사항으로 인해 Mac OS X에만 영향을 미치는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="21d36b8102f1fdb27f28c601e2a837388ac84ada" translate="yes" xml:space="preserve">
          <source>This means that phases that normally run are skipped, such as the rewrite or access phase. This also means that later phases that are run regardless, e.g. &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt;, will not have access to information that is normally set in those phases.</source>
          <target state="translated">다시 쓰기 또는 액세스 단계와 같이 정상적으로 실행되는 단계를 건너 뜁니다. 이는 또한 &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt; 와 상관없이 실행되는 이후 단계가 해당 단계에서 일반적으로 설정되는 정보에 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a2cbc67d38c14ae1b1b697e46ad13ec42ccb9aa" translate="yes" xml:space="preserve">
          <source>This mechanism allows calling other nginx C modules' directives that are implemented by &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;Nginx Devel Kit&lt;/a&gt; (NDK)'s set_var submodule's &lt;code&gt;ndk_set_var_value&lt;/code&gt;.</source>
          <target state="translated">이 메커니즘을 통해 &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit&quot;&gt;Nginx Devel Kit&lt;/a&gt; (NDK)의 set_var 하위 모듈의 &lt;code&gt;ndk_set_var_value&lt;/code&gt; 에 의해 구현되는 다른 nginx C 모듈의 지시문을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39f410b28b198d7c523406eb25be674282e4fc7d" translate="yes" xml:space="preserve">
          <source>This method also makes the current cosocket object enter the &quot;closed&quot; state, so there is no need to manually call the &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt; method on it afterwards.</source>
          <target state="translated">이 메소드는 또한 현재 코 소켓 오브젝트를 &quot;폐쇄&quot;상태로 전환하므로 나중에 수동으로 &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt; 메소드를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a3efa3826c081368180b9d6d453ad72dc73b5add" translate="yes" xml:space="preserve">
          <source>This method does not work in HTTP/2 requests yet.</source>
          <target state="translated">이 방법은 아직 HTTP / 2 요청에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30804077619e0b16d472a616a9ccd2d2d72ecb9f" translate="yes" xml:space="preserve">
          <source>This method is a synchronous operation and is 100% nonblocking.</source>
          <target state="translated">이 방법은 동기식 작업이며 100 % 비 차단입니다.</target>
        </trans-unit>
        <trans-unit id="16beaea1f778f25a2f81b6437f3f083d1f95c72c" translate="yes" xml:space="preserve">
          <source>This method is a synchronous operation just like the &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; method and is 100% nonblocking.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; 메소드와 같은 동기식 조작 이며 100 % 비 블로킹입니다.</target>
        </trans-unit>
        <trans-unit id="ca23691f91c5cc27b730efeb024b47e206dba1e0" translate="yes" xml:space="preserve">
          <source>This method is a synchronous operation that will not return until &lt;em&gt;all&lt;/em&gt; the data has been flushed into the system socket send buffer or an error occurs.</source>
          <target state="translated">이 메소드는 &lt;em&gt;모든&lt;/em&gt; 데이터가 시스템 소켓 송신 버퍼로 플러시되거나 오류가 발생할 때까지 리턴되지 않는 동기 조작입니다 .</target>
        </trans-unit>
        <trans-unit id="cac08826936268b86b5549b2ddb1339214bcdb54" translate="yes" xml:space="preserve">
          <source>This method is similar to the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive with the &lt;code&gt;redirect&lt;/code&gt; modifier in the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;, for example, this &lt;code&gt;nginx.conf&lt;/code&gt; snippet</source>
          <target state="translated">이 방법은 표준 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt; 의 &lt;code&gt;redirect&lt;/code&gt; 수정자를 사용 하는 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; 지시문과 유사합니다 ( 예 :이 &lt;code&gt;nginx.conf&lt;/code&gt; 스 니펫)</target>
        </trans-unit>
        <trans-unit id="d91e3f78cd8389314d9a84e3d3bfc68a3294e987" translate="yes" xml:space="preserve">
          <source>This method is similar to the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive with the &lt;code&gt;redirect&lt;/code&gt; modifier in the standard &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;, for example, this &lt;code&gt;nginx.conf&lt;/code&gt; snippet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4a83ede8a97097cc7a9703f14c5b0b45079edd" translate="yes" xml:space="preserve">
          <source>This method performs better on relatively long &lt;code&gt;str&lt;/code&gt; inputs (i.e., longer than 30 ~ 60 bytes), as compared to &lt;a href=&quot;#ngxcrc32_short&quot;&gt;ngx.crc32_short&lt;/a&gt;. The result is exactly the same as &lt;a href=&quot;#ngxcrc32_short&quot;&gt;ngx.crc32_short&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;#ngxcrc32_short&quot;&gt;ngx.crc32_short&lt;/a&gt; 와 비교할 때 비교적 긴 &lt;code&gt;str&lt;/code&gt; 입력 (30 ~ 60 바이트 이상) 에서 더 잘 수행 됩니다. 결과는 &lt;a href=&quot;#ngxcrc32_short&quot;&gt;ngx.crc32_short&lt;/a&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f3585c2e651d3b28bba9db7df5aa5f7e153f6c9b" translate="yes" xml:space="preserve">
          <source>This method performs better on relatively short &lt;code&gt;str&lt;/code&gt; inputs (i.e., less than 30 ~ 60 bytes), as compared to &lt;a href=&quot;#ngxcrc32_long&quot;&gt;ngx.crc32_long&lt;/a&gt;. The result is exactly the same as &lt;a href=&quot;#ngxcrc32_long&quot;&gt;ngx.crc32_long&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;#ngxcrc32_long&quot;&gt;ngx.crc32_long&lt;/a&gt; 과 비교하여 비교적 짧은 &lt;code&gt;str&lt;/code&gt; 입력 (30 ~ 60 바이트 미만) 에서 더 잘 수행 됩니다. 결과는 &lt;a href=&quot;#ngxcrc32_long&quot;&gt;ngx.crc32_long&lt;/a&gt; 과 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="51cd1d7e7ec9442e5cbc877dcf0bea5983febb63" translate="yes" xml:space="preserve">
          <source>This method requires the PCRE library enabled in Nginx. (&lt;a href=&quot;#special-escaping-sequences&quot;&gt;Known Issue With Special Escaping Sequences&lt;/a&gt;).</source>
          <target state="translated">이 방법을 사용하려면 Nginx에서 활성화 된 PCRE 라이브러리가 필요합니다. ( &lt;a href=&quot;#special-escaping-sequences&quot;&gt;특별한 이스케이프 시퀀스의 알려진 문제&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="33357a09b5efe8171e73fc073a065083949145b8" translate="yes" xml:space="preserve">
          <source>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.</source>
          <target state="translated">이 메소드는 지정된 패턴을 보거나 오류가 발생할 때까지 데이터 스트림을 읽기 위해 호출 할 수있는 반복자 Lua 함수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0c2c328fe9debd04ec70ccae494c791d280f980" translate="yes" xml:space="preserve">
          <source>This method returns the (successfully) reused times for the current connection. In case of error, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">이 메소드는 현재 연결에 대해 (성공적으로) 재사용 된 시간을 리턴합니다. 오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8ed48807bd1fe7513c192f85938d222ac43ca691" translate="yes" xml:space="preserve">
          <source>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the &lt;code&gt;&amp;lt;replace&amp;gt;&lt;/code&gt; string argument, it will return &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">이 메소드는 성공적인 새 문자열과 성공적인 대체 수를 리턴합니다. 정규 표현식의 구문 오류 또는 &lt;code&gt;&amp;lt;replace&amp;gt;&lt;/code&gt; 문자열 인수 와 같은 오류가 발생하면 &lt;code&gt;nil&lt;/code&gt; 및 오류를 설명하는 문자열 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9c44db8797cb6660325445822c4517b88523e02" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;0.8.6&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;0.8.6&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="7b40fa428bc115e02c881d1faf5dcaea0646b4e4" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b08194cccbf335f4311841ab0cad7fa6b938327f" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.3.1rc27&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.3.1rc27&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="57abb78a79a7b04980e393d8ab528a56a9b3d550" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="65c77a47ce69f27b65e2b527558cf44442f99ac8" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.5.6&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.5.6&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="24d7b1e6f5bc024280ea624bbe733d21e4af080c" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.5.7&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b68c747ef332f71a789579b0f7c6f0c91c565be8" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.7.17&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.7.17&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="1331c7988be7085ff26eda0e323f41be2e978864" translate="yes" xml:space="preserve">
          <source>This method was first introduced in the &lt;code&gt;v0.9.11&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.9.11&lt;/code&gt; 릴리스 에서 처음 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="0451bdbd9e1be237a3add9bb19bd84927184b5fd" translate="yes" xml:space="preserve">
          <source>This method was introduced in the &lt;code&gt;0.5.0rc30&lt;/code&gt; release.</source>
          <target state="translated">이 방법은 &lt;code&gt;0.5.0rc30&lt;/code&gt; 릴리스 에서 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="1966b5ebf057e27e77bd8f4c08b105410d6f888f" translate="yes" xml:space="preserve">
          <source>This method was introduced in the &lt;code&gt;v0.5.0rc29&lt;/code&gt;.</source>
          <target state="translated">이 방법은 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="dfb9a727555a42442c1c94b3f952a5b1073590fd" translate="yes" xml:space="preserve">
          <source>This module embeds Lua, via the standard Lua 5.1 interpreter or &lt;a href=&quot;http://luajit.org/luajit.html&quot;&gt;LuaJIT 2.0/2.1&lt;/a&gt;, into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.</source>
          <target state="translated">이 모듈은 표준 Lua 5.1 인터프리터 또는 &lt;a href=&quot;http://luajit.org/luajit.html&quot;&gt;LuaJIT 2.0 / 2.1을&lt;/a&gt; 통해 Lua 를 Nginx에 포함시키고 Nginx의 하위 요청을 활용하여 강력한 Lua 스레드 (Lua coroutines)를 Nginx 이벤트 모델에 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f53ee6aad01b2f3725db5af531c83b9044fa92" translate="yes" xml:space="preserve">
          <source>This module embeds Lua, via the standard Lua 5.1 interpreter or &lt;a href=&quot;https://luajit.org/luajit.html&quot;&gt;LuaJIT 2.0/2.1&lt;/a&gt;, into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5112b5de01ae129eff441df39d636b4f8c1acdcc" translate="yes" xml:space="preserve">
          <source>This module is licensed under the BSD license.</source>
          <target state="translated">이 모듈은 BSD 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="f312c739619f14cf3876d7b9af5395ef58521b41" translate="yes" xml:space="preserve">
          <source>This module is plugged into NGINX's &quot;http&quot; subsystem so it can only speaks downstream communication protocols in the HTTP family (HTTP 0.9/1.0/1.1/2.0, WebSockets, and etc). If you want to do generic TCP communications with the downstream clients, then you should use the &lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua&lt;/a&gt; module instead which has a compatible Lua API.</source>
          <target state="translated">이 모듈은 NGINX의 &quot;http&quot;서브 시스템에 연결되어 HTTP 제품군 (HTTP 0.9 / 1.0 / 1.1 / 2.0, WebSockets 등)에서만 다운 스트림 통신 프로토콜을 말할 수 있습니다. 다운 스트림 클라이언트와 일반 TCP 통신을 수행하려면 호환되는 Lua API가있는 &lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua&lt;/a&gt; 모듈을 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a483178bdb549f716d6ee98c8de0997e67b62304" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;false&lt;/code&gt; by default</source>
          <target state="translated">이 옵션은 기본적 으로 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e322ad1bf9f45e8b11b0a0bacdb08a6bceba38a2" translate="yes" xml:space="preserve">
          <source>This section has been renamed to &lt;a href=&quot;#special-escaping-sequences&quot;&gt;Special Escaping Sequences&lt;/a&gt;.</source>
          <target state="translated">이 섹션은 &lt;a href=&quot;#special-escaping-sequences&quot;&gt;특수 이스케이프 시퀀스&lt;/a&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d605b97a4a4724ee7fd4704d3c54112df58a84" translate="yes" xml:space="preserve">
          <source>This section is just holding obsolete documentation sections that have been either renamed or removed so that existing links over the web are still valid.</source>
          <target state="translated">이 섹션은 웹상의 기존 링크가 여전히 유효하도록 이름이 바뀌거나 제거 된 더 이상 사용되지 않는 문서 섹션을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c2aa4eb03a0c12b3b6017b8a231a23cb648528" translate="yes" xml:space="preserve">
          <source>This string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value &lt;code&gt;&quot;http&quot;&lt;/code&gt;. For &lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua_module&lt;/a&gt;, however, this field takes the value &lt;code&gt;&quot;stream&quot;&lt;/code&gt;.</source>
          <target state="translated">이 문자열 필드는 현재 Lua 환경이 기반으로하는 현재 NGINX 서브 시스템을 나타냅니다. 이 모듈의 경우이 필드는 항상 문자열 값 &lt;code&gt;&quot;http&quot;&lt;/code&gt; 를 사용합니다. 합니다. 들어 &lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua_module&lt;/a&gt; 그러나,이 필드에 값한다 &lt;code&gt;&quot;stream&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="751ddda1aa3bb67a142f8bde1fc3e270340d8246" translate="yes" xml:space="preserve">
          <source>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</source>
          <target state="translated">이 테이블은 요청 당 Lua 컨텍스트 데이터를 저장하는 데 사용될 수 있으며 Nginx 변수와 마찬가지로 현재 요청과 동일한 수명 시간을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="327de488a3dc729ebf45eb5fa572053dbfd770c8" translate="yes" xml:space="preserve">
          <source>This tool will guarantee that local variables in the Lua module functions are all declared with the &lt;code&gt;local&lt;/code&gt; keyword, otherwise a runtime exception will be thrown. It prevents undesirable race conditions while accessing such variables. See &lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;Data Sharing within an Nginx Worker&lt;/a&gt; for the reasons behind this.</source>
          <target state="translated">이 도구는 Lua 모듈 함수의 로컬 변수가 모두 &lt;code&gt;local&lt;/code&gt; 선언되도록합니다. 키워드로 . 그렇지 않으면 런타임 예외가 발생합니다. 이러한 변수에 액세스하는 동안 원하지 않는 경쟁 조건을 방지합니다. 이에 대한 이유 &lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;는 Nginx 작업자 내의 데이터 공유를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4c9880c949290c3d762d8a4fb493c0110912b3" translate="yes" xml:space="preserve">
          <source>This will truncate the response body and usually result in incomplete and also invalid responses.</source>
          <target state="translated">이렇게하면 응답 본문이 잘리고 일반적으로 불완전하고 잘못된 응답이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="686ba622e0734f8c6ff964ecfd9e49f077900cf0" translate="yes" xml:space="preserve">
          <source>Timeout for the connecting operation is controlled by the &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt; config directive and the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method. And the latter takes priority. For example:</source>
          <target state="translated">연결 작업의 시간 초과는 &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt; 구성 지시문 및 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout에&lt;/a&gt; 의해 제어됩니다. 메소드에 . 그리고 후자가 우선권을 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86499f97e007bb66b630696b0a0e8b473eb0e79c" translate="yes" xml:space="preserve">
          <source>Timeout for the iterator function's reading operation is controlled by the &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; config directive and the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method. And the latter takes priority. For example:</source>
          <target state="translated">반복자 함수의 읽기 작업에 대한 시간 초과는 &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; 구성 지시문 및 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout에&lt;/a&gt; 의해 제어됩니다. 메소드에 . 그리고 후자가 우선권을 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="356de04e35844a913bcd88d34cf72ab5c7e1814c" translate="yes" xml:space="preserve">
          <source>Timeout for the reading operation is controlled by the &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; config directive and the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method. And the latter takes priority. For example:</source>
          <target state="translated">읽기 작업의 시간 초과는 &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; 구성 지시문 및 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout에&lt;/a&gt; 의해 제어됩니다. 메소드에 . 그리고 후자가 우선권을 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d513def9a797c844c725d5671f7f97e9cf6f97e0" translate="yes" xml:space="preserve">
          <source>Timeout for the reading operation is controlled by the &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; config directive and the &lt;a href=&quot;#udpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method. And the latter takes priority. For example:</source>
          <target state="translated">읽기 작업의 시간 초과는 &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt; 구성 지시문 및 &lt;a href=&quot;#udpsocksettimeout&quot;&gt;settimeout에&lt;/a&gt; 의해 제어됩니다. 메소드에 . 그리고 후자가 우선권을 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b15a69bc6d5ec8bb03c477ddda733f0cf1e518d" translate="yes" xml:space="preserve">
          <source>Timeout for the sending operation is controlled by the &lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt; config directive and the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method. And the latter takes priority. For example:</source>
          <target state="translated">전송 작업의 시간 초과는 &lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt; 구성 지시문 및&lt;a href=&quot;#tcpsocksettimeout&quot;&gt; settimeout&lt;/a&gt; 메소드에 . 그리고 후자가 우선권을 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="263920d54ad58ee3e9fb3bef424ece95f393dc56" translate="yes" xml:space="preserve">
          <source>To avoid this, &lt;em&gt;double&lt;/em&gt; escape the backslash:</source>
          <target state="translated">이를 피하려면 백 슬래시를 &lt;em&gt;두 번&lt;/em&gt; 이스케이프하십시오.</target>
        </trans-unit>
        <trans-unit id="8271d57c9f432da496359f39acfbb2176192b30c" translate="yes" xml:space="preserve">
          <source>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the &lt;code&gt;--with-debug&lt;/code&gt; option to Nginx or OpenResty's &lt;code&gt;./configure&lt;/code&gt; script. Then, enable the &quot;debug&quot; error log level in &lt;code&gt;error_log&lt;/code&gt; directive. The following message will be generated if PCRE JIT is enabled:</source>
          <target state="translated">PCRE JIT가 활성화되어 있는지 확인하려면 &lt;code&gt;--with-debug&lt;/code&gt; 옵션을 Nginx 또는 OpenResty의 &lt;code&gt;./configure&lt;/code&gt; 스크립트 에 추가하여 Nginx 디버그 로그를 활성화하십시오 . 그런 다음 &lt;code&gt;error_log&lt;/code&gt; 지시문 에서 &quot;디버그&quot;오류 로그 수준을 활성화하십시오 . PCRE JIT가 사용 가능한 경우 다음 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47ccf7c2625f44f9fdf6b2cefdc898e32d4ea12e" translate="yes" xml:space="preserve">
          <source>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</source>
          <target state="translated">최신 웹 브라우저로 로컬에서이 후크를 쉽게 테스트하기 위해 https 서버 블록에 다음 행을 임시로 넣어 TLS 세션 티켓 지원을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bbb2ac075fd488f16984505a12a1ae8a3150fff" translate="yes" xml:space="preserve">
          <source>To enable one or more of these macros, just pass extra C compiler options to the &lt;code&gt;./configure&lt;/code&gt; script of either NGINX or OpenResty. For instance,</source>
          <target state="translated">이러한 매크로 중 하나 이상을 활성화하려면 추가 C 컴파일러 옵션을 &lt;code&gt;./configure&lt;/code&gt; 에 전달하십시오. NGINX 또는 OpenResty 스크립트에 전달하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="310f4be17eb9a29b5e6e4b504207330160ba392b" translate="yes" xml:space="preserve">
          <source>To find all instances of Lua global variables in your Lua code, run the &lt;a href=&quot;https://github.com/openresty/nginx-devel-utils/blob/master/lua-releng&quot;&gt;lua-releng tool&lt;/a&gt; across all &lt;code&gt;.lua&lt;/code&gt; source files:</source>
          <target state="translated">Lua 코드에서 Lua 전역 변수의 모든 인스턴스를 찾으려면 모든 &lt;code&gt;.lua&lt;/code&gt; 소스 파일 에서 &lt;a href=&quot;https://github.com/openresty/nginx-devel-utils/blob/master/lua-releng&quot;&gt;lua- &lt;/a&gt;releng 도구 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="06d9a9c22ee8b1b3d8c3c3c61f8b1a07661d3db0" translate="yes" xml:space="preserve">
          <source>To force in-file request bodies, try turning on &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only&lt;/a&gt;.</source>
          <target state="translated">파일 내 요청 본문을 강제 실행하려면 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only을&lt;/a&gt; 켜십시오 .</target>
        </trans-unit>
        <trans-unit id="0b320f4d306203016daa83d02c3edf1b794d2daa" translate="yes" xml:space="preserve">
          <source>To force in-file request bodies, try turning on &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ac5c2a0e8ce48695391762905f56957b82ba11" translate="yes" xml:space="preserve">
          <source>To force in-memory request bodies, try setting &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; to the same size value in &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;.</source>
          <target state="translated">메모리 내 요청 본문을 강제 실행하려면 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; 를 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt; 에서 동일한 크기 값으로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="913971dc74a4e66d6940e033322c9adf85db4991" translate="yes" xml:space="preserve">
          <source>To force in-memory request bodies, try setting &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; to the same size value in &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b9312b835b83f6819193545b3a05a156a8c25b" translate="yes" xml:space="preserve">
          <source>To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua &lt;code&gt;require&lt;/code&gt; builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data). Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.</source>
          <target state="translated">루아가 사용 루아 모듈로 공유 데이터를 캡슐화 같은 nginx를 작업자 프로세스에 의해 처리되는 모든 요청 사이에서 데이터를 공유 전체적으로하려면 &lt;code&gt;require&lt;/code&gt; 내장을 하여 모듈을 가져온 다음 Lua에서 공유 데이터를 조작하십시오. 이것은 필요한 Lua 모듈이 한 번만로드되고 모든 코 루틴이 동일한 모듈 사본 (코드 및 데이터)을 공유하기 때문에 작동합니다. 그러나 Lua 전역 변수 (참고 : 모듈 수준 변수는 아님)는 요청 당 하나의 코 루틴 당 격리 설계로 인해 요청간에 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec062ae9cc0455e26eaafea514d15aff54ba0d4" translate="yes" xml:space="preserve">
          <source>To output very large response data in a streaming fashion (via the &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt; call, for example), this directive MUST be turned off to minimize memory usage.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt; 호출을 통해 매우 큰 응답 데이터를 스트리밍 방식으로 출력하려면 메모리 사용을 최소화하기 위해이 지시문을 꺼야합니다.</target>
        </trans-unit>
        <trans-unit id="e299a25adbaec725c8610575ab06d0d85ad48d98" translate="yes" xml:space="preserve">
          <source>To read an individual header:</source>
          <target state="translated">개별 헤더를 읽으려면</target>
        </trans-unit>
        <trans-unit id="804306edcb4f446374df8d9c022f150fcbcc0adf" translate="yes" xml:space="preserve">
          <source>To read the request body data within the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$request_body&lt;/a&gt; variable, &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; must have the same value as &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;. Because when the content length exceeds &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; but less than &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$request_body&lt;/a&gt; variable.</source>
          <target state="translated">&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$ request_body&lt;/a&gt; 변수 내에서 요청 본문 데이터를 읽으려면 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; 가 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt; 와 동일한 값을 가져야합니다 . 내용 길이가 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size를&lt;/a&gt; 초과 하지만 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt; 보다 작은 경우 Nginx는 데이터를 디스크의 임시 파일로 버퍼링하므로 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$ request_body&lt;/a&gt; 변수 의 빈 값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="582f872e5038297d5c87ae32fbaac266b07904f3" translate="yes" xml:space="preserve">
          <source>To read the request body data within the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$request_body&lt;/a&gt; variable, &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; must have the same value as &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;. Because when the content length exceeds &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; but less than &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size&quot;&gt;client_max_body_size&lt;/a&gt;, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&quot;&gt;$request_body&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bc625bed6e60dbf52f76b84c509262aa04c79d" translate="yes" xml:space="preserve">
          <source>To return an error page with custom contents, use code snippets like this:</source>
          <target state="translated">사용자 정의 컨텐츠가 포함 된 오류 페이지를 리턴하려면 다음과 같은 코드 스 니펫을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e648df2fae0de7fec89656b115ef8b2aa264ce72" translate="yes" xml:space="preserve">
          <source>To run a specific test block in a particular test file, add the line &lt;code&gt;--- ONLY&lt;/code&gt; to the test block you want to run, and then use the &lt;code&gt;prove&lt;/code&gt; utility to run that &lt;code&gt;.t&lt;/code&gt; file.</source>
          <target state="translated">특정 테스트 파일에서 특정 테스트 블록을 실행하려면 실행 하려는 테스트 블록 &lt;code&gt;--- ONLY&lt;/code&gt; 행만 추가 한 다음 &lt;code&gt;prove&lt;/code&gt; 유틸리티를 사용하여 해당 &lt;code&gt;.t&lt;/code&gt; 파일 을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="4181bc9bb97b43542885f396179acd9f2fcf5f1f" translate="yes" xml:space="preserve">
          <source>To run specific test files:</source>
          <target state="translated">특정 테스트 파일을 실행하려면</target>
        </trans-unit>
        <trans-unit id="d1eb0ee98d60c775310798916e8467744cd6bf57" translate="yes" xml:space="preserve">
          <source>To run the whole test suite in the default testing mode:</source>
          <target state="translated">기본 테스트 모드에서 전체 테스트 스위트를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bde06580408f134f13dfc80c9b61771deb5f12b7" translate="yes" xml:space="preserve">
          <source>Typical Uses</source>
          <target state="translated">일반적인 용도</target>
        </trans-unit>
        <trans-unit id="cd365822e145dd82c81ebc25cbd8dda8347de52e" translate="yes" xml:space="preserve">
          <source>URI arguments can be specified as well, for example:</source>
          <target state="translated">URI 인수도 지정할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="2656f5732e461af96ebf59f2affb9fd100171598" translate="yes" xml:space="preserve">
          <source>URI query strings can be concatenated to URI itself, for instance,</source>
          <target state="translated">예를 들어, URI 쿼리 문자열을 URI 자체에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07406874d386595e410e09c0c63df5b635a427f6" translate="yes" xml:space="preserve">
          <source>Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; call with an error code like &lt;code&gt;ngx.ERROR&lt;/code&gt;.</source>
          <target state="translated">바로 현재 SSL 세션 중단 사용자 루아 코드에서 catch되지 루아 예외는, 그래서하지 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit의&lt;/a&gt; 같은 오류 코드와 전화 &lt;code&gt;ngx.ERROR&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c7078cb03027cbac9ec7cc3184809436d3ced9b9" translate="yes" xml:space="preserve">
          <source>Unconditionally removes the key-value pair from the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 키-값 쌍을 무조건 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="d50507f07cc9ec100619d89ceed550e28b2d2377" translate="yes" xml:space="preserve">
          <source>Unconditionally sets a key-value pair into the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns three values:</source>
          <target state="translated">키-값 쌍을 shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 로 무조건 설정합니다 . 세 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b996280c114992d9bdfde90853303086f08eb6b" translate="yes" xml:space="preserve">
          <source>Undefined NGINX variables are evaluated to &lt;code&gt;nil&lt;/code&gt; while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.</source>
          <target state="translated">정의되지 않은 NGINX 변수는 &lt;code&gt;nil&lt;/code&gt; 로 평가 되고 초기화되지 않은 (그러나 정의 된) NGINX 변수는 빈 Lua 문자열로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec7d977aeaafa0a56a073269236d2c825872b99" translate="yes" xml:space="preserve">
          <source>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will also be replaced by dashes (&lt;code&gt;-&lt;/code&gt;) and the header names will be matched case-insensitively. If the response header is not present at all, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">헤더 이름의 밑줄 ( &lt;code&gt;_&lt;/code&gt; )도 대시 ( &lt;code&gt;-&lt;/code&gt; ) 로 바뀌며 헤더 이름은 대소 문자를 구분하지 않습니다. 응답 헤더가 전혀 없으면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="256f8956a6d8bce12cd574227698fe88708530bd" translate="yes" xml:space="preserve">
          <source>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will be replaced by hyphens (&lt;code&gt;-&lt;/code&gt;) by default. This transformation can be turned off via the &lt;a href=&quot;#lua_transform_underscores_in_response_headers&quot;&gt;lua_transform_underscores_in_response_headers&lt;/a&gt; directive.</source>
          <target state="translated">헤더 이름의 밑줄 ( &lt;code&gt;_&lt;/code&gt; )은 기본적으로 하이픈 ( &lt;code&gt;-&lt;/code&gt; ) 으로 바뀝니다 . 이 변환은 &lt;a href=&quot;#lua_transform_underscores_in_response_headers&quot;&gt;lua_transform_underscores_in_response_headers&lt;/a&gt; 지시문을 통해 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7050f6fa22df6c872c0e8e08df1d7c67b27bbe8" translate="yes" xml:space="preserve">
          <source>Unescape &lt;code&gt;str&lt;/code&gt; as an escaped URI component.</source>
          <target state="translated">언 이스케이프 &lt;code&gt;str&lt;/code&gt; 가 AS는 URI 구성 요소를 탈출했다.</target>
        </trans-unit>
        <trans-unit id="c23b46c88e516f87a3f9748ab13db45199040d8c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://httpd.apache.org/docs/trunk/mod/mod_lua.html&quot;&gt;Apache's mod_lua&lt;/a&gt; and &lt;a href=&quot;http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet&quot;&gt;Lighttpd's mod_magnet&lt;/a&gt;, Lua code executed using this module can be &lt;em&gt;100% non-blocking&lt;/em&gt; on network traffic as long as the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; provided by this module is used to handle requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.</source>
          <target state="translated">&lt;a href=&quot;https://httpd.apache.org/docs/trunk/mod/mod_lua.html&quot;&gt;Apache의 mod_lua&lt;/a&gt; 및 &lt;a href=&quot;http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet&quot;&gt;Lighttpd의 mod_magnet&lt;/a&gt; 과 달리 ,이 모듈 에서 제공하는 &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua 용 Nginx API&lt;/a&gt; 가 MySQL, PostgreSQL, Memcached와 같은 업스트림 서비스에 대한 요청을 처리하는 데 사용되는 한이 모듈을 사용하여 실행 된 Lua 코드 는 네트워크 트래픽에서 &lt;em&gt;100 % 비차 단일&lt;/em&gt; 수 있습니다. , Redis 또는 업스트림 HTTP 웹 서비스</target>
        </trans-unit>
        <trans-unit id="26358cadef37f72154fcc704e07d959f806554a5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://httpd.apache.org/docs/trunk/mod/mod_lua.html&quot;&gt;Apache's mod_lua&lt;/a&gt; and &lt;a href=&quot;https://redmine.lighttpd.net/wiki/1/Docs:ModMagnet&quot;&gt;Lighttpd's mod_magnet&lt;/a&gt;, Lua code executed using this module can be &lt;em&gt;100% non-blocking&lt;/em&gt; on network traffic as long as the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; provided by this module is used to handle requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c1eb0f2bf9d5920c0b68ee85c1cffd19a631c2" translate="yes" xml:space="preserve">
          <source>Unlike as with LuaJIT, debug information is included in standard Lua 5.1 bytecode files by default. This can be striped out by specifying the &lt;code&gt;-s&lt;/code&gt; option as shown:</source>
          <target state="translated">LuaJIT과 달리 디버그 정보는 기본적으로 표준 Lua 5.1 바이트 코드 파일에 포함됩니다. 다음 과 같이 &lt;code&gt;-s&lt;/code&gt; 옵션을 지정하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c76436188c55ec6070bada1e60143ac5691c086" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;flush_all&lt;/a&gt; method, this method actually free up the memory used by the expired items.</source>
          <target state="translated">&lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;flush_all&lt;/a&gt; 메소드 와 달리이 메소드는 실제로 만료 된 항목에 사용 된 메모리를 비 웁니다 .</target>
        </trans-unit>
        <trans-unit id="5582ecefc9cc9b7f3a1ec81d54228c116c308155" translate="yes" xml:space="preserve">
          <source>Unmatched subpatterns will have &lt;code&gt;false&lt;/code&gt; values in their &lt;code&gt;captures&lt;/code&gt; table fields.</source>
          <target state="translated">일치하지 않는 하위 패턴은 &lt;code&gt;captures&lt;/code&gt; 테이블 필드 에 &lt;code&gt;false&lt;/code&gt; 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0c2fb9a4cbd7e921d637c4b8ef1f3bf16bfdc5ae" translate="yes" xml:space="preserve">
          <source>Updates of the Nginx time cache can be forced by calling &lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt; first.</source>
          <target state="translated">&lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time을&lt;/a&gt; 먼저 호출하여 Nginx 시간 캐시를 강제로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec181cb11d58bcf5ff1fdbc886cdfbead3b6e8a9" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;exptime&lt;/code&gt; (in second) of a key-value pair in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns a boolean indicating success if the operation completes or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</source>
          <target state="translated">shm 기반 사전 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; 에서 키-값 쌍 의 &lt;code&gt;exptime&lt;/code&gt; (초)을 업데이트합니다 . 반환하는 경우 작업이 완료 또는 성공을 나타내는 부울 &lt;code&gt;nil&lt;/code&gt; 및 오류 메시지가 그렇지.</target>
        </trans-unit>
        <trans-unit id="baf6e2912b0e1b86bbbef2d350b9ef4c66183557" translate="yes" xml:space="preserve">
          <source>Updating query arguments via the nginx variable &lt;code&gt;$args&lt;/code&gt; (or &lt;code&gt;ngx.var.args&lt;/code&gt; in Lua) at runtime is also supported:</source>
          <target state="translated">런타임에 nginx 변수 &lt;code&gt;$args&lt;/code&gt; (또는 Lua의 &lt;code&gt;ngx.var.args&lt;/code&gt; )를 통한 쿼리 인수 업데이트 도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="722357c3e89577ed5bf050ec80b96fff9c78d475" translate="yes" xml:space="preserve">
          <source>Use data storage mechanisms such as &lt;code&gt;memcached&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt;, &lt;code&gt;MySQL&lt;/code&gt; or &lt;code&gt;PostgreSQL&lt;/code&gt;. &lt;a href=&quot;http://openresty.org&quot;&gt;The OpenResty bundle&lt;/a&gt; associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.</source>
          <target state="translated">&lt;code&gt;memcached&lt;/code&gt; , &lt;code&gt;redis&lt;/code&gt; , &lt;code&gt;MySQL&lt;/code&gt; 또는 &lt;code&gt;PostgreSQL&lt;/code&gt; 과 같은 데이터 저장 메커니즘을 사용하십시오 . 이 모듈과 관련된 &lt;a href=&quot;http://openresty.org&quot;&gt;OpenResty 번들&lt;/a&gt; 에는 이러한 데이터 저장 메커니즘과의 인터페이스를 제공하는 동반 Nginx 모듈 및 Lua 라이브러리 세트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6e7baacf83dbff76e605f08c4546c973c26d56" translate="yes" xml:space="preserve">
          <source>Use data storage mechanisms such as &lt;code&gt;memcached&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt;, &lt;code&gt;MySQL&lt;/code&gt; or &lt;code&gt;PostgreSQL&lt;/code&gt;. &lt;a href=&quot;https://openresty.org&quot;&gt;The OpenResty bundle&lt;/a&gt; associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837870561d18c1340fe17d3a8838268c7588531e" translate="yes" xml:space="preserve">
          <source>Use of the &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall&quot;&gt;package.seeall&lt;/a&gt; flag is strongly discouraged due to its various bad side-effects.</source>
          <target state="translated">&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall&quot;&gt;package.seeall&lt;/a&gt; 플래그의 사용은 다양한 부작용으로 인해 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c024fc6f188e18ad607f377862be01a72cc4f693" translate="yes" xml:space="preserve">
          <source>Use of the &lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html#pdf-package.seeall&quot;&gt;package.seeall&lt;/a&gt; flag is strongly discouraged due to its various bad side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117d92fdb073a7582fd4dea508996ad94000fde8" translate="yes" xml:space="preserve">
          <source>Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine).</source>
          <target state="translated">단일 nginx 작업자와 단일 서버 만 사용하십시오 (단일 시스템에 다중 코어 CPU 또는 다중 CPU가있는 경우 권장되지 않음).</target>
        </trans-unit>
        <trans-unit id="bef50a363cba0e7d23e2525c759034abffc23ec1" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; API provided by this module.</source>
          <target state="translated">이 모듈에서 제공 하는 &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; API를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee9d433515bdb74b58c38092021647bad0390c0f" translate="yes" xml:space="preserve">
          <source>Use the following instead:</source>
          <target state="translated">대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e04fbe28b8fd3dc2726c57776964b940afa23da" translate="yes" xml:space="preserve">
          <source>User &quot;light threads&quot; can create &quot;light threads&quot; themselves. And normal user coroutines created by &lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine.create&lt;/a&gt; can also create &quot;light threads&quot;. The coroutine (be it a normal Lua coroutine or a &quot;light thread&quot;) that directly spawns the &quot;light thread&quot; is called the &quot;parent coroutine&quot; for the &quot;light thread&quot; newly spawned.</source>
          <target state="translated">사용자 &quot;경사&quot;는 &quot;경사&quot;자체를 만들 수 있습니다. coroutine.create로 생성 된 일반 사용자 코 &lt;a href=&quot;#coroutinecreate&quot;&gt;루틴&lt;/a&gt; 은 &quot;가벼운 스레드&quot;도 만들 수 있습니다. &quot;경사&quot;를 직접 생성하는 코 루틴 (일반 루아 코 루틴 또는 &quot;경사&quot;)을 새로 생성 된 &quot;경사&quot;의 &quot;부모 코 루틴&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3051d5161dec8259348e20a78d348c96785998d1" translate="yes" xml:space="preserve">
          <source>Uses Lua code specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; to define an output body filter.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 Lua 코드 를 사용하여 출력 본문 필터를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="ded6196731dd60e7a6f3daebcbfe3101e65dafd4" translate="yes" xml:space="preserve">
          <source>Uses Lua code specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; to define an output header filter.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 에 지정된 Lua 코드 를 사용하여 출력 헤더 필터를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="16e6282c4779b152733e47206dc28454bee859bd" translate="yes" xml:space="preserve">
          <source>Using LuaRocks with ngx_lua</source>
          <target state="translated">ngx_lua와 함께 LuaRocks 사용</target>
        </trans-unit>
        <trans-unit id="c069766a735f16bffd3eb81ff8bd3338417e70ad" translate="yes" xml:space="preserve">
          <source>Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems' copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</source>
          <target state="translated">일반적으로이 후크를 사용하여 서버 시작시 Lua 모듈을 사전로드하고 최신 운영 체제의 COW (Copy-On-Write) 최적화를 활용할 수 있습니다. 다음은 Lua 모듈을 사전로드하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="532936ba2128b4e636dfd3eb5ffbd8be55d05ec6" translate="yes" xml:space="preserve">
          <source>Usually, this module is used together with the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; module in the context of &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 모듈은 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt; 컨텍스트에서 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; 모듈 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="52410b56d8b4ca4991fe9794a8f9922ad169e787" translate="yes" xml:space="preserve">
          <source>Waits on one or more child &quot;light threads&quot; and returns the results of the first &quot;light thread&quot; that terminates (either successfully or with an error).</source>
          <target state="translated">하나 이상의 자식 &quot;light thread&quot;를 대기하고 종료 된 첫 번째 &quot;light thread&quot;의 결과를 반환합니다 (성공 또는 오류).</target>
        </trans-unit>
        <trans-unit id="a18661c65b6dfe9c2af3bdd953c07f01ed4281ca" translate="yes" xml:space="preserve">
          <source>We can also use the numerical code directly as the second &lt;code&gt;status&lt;/code&gt; argument:</source>
          <target state="translated">숫자 코드를 두 번째 &lt;code&gt;status&lt;/code&gt; 인수 로 직접 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bdff0fdfa20c1531971ad6042498f40c78809ce" translate="yes" xml:space="preserve">
          <source>What matters here is the name of the &lt;code&gt;.lua&lt;/code&gt; file, which determines how you use this module later on the Lua land. The file name &lt;code&gt;foo.o&lt;/code&gt; does not matter at all except the &lt;code&gt;.o&lt;/code&gt; file extension (which tells &lt;code&gt;luajit&lt;/code&gt; what output format is used). If you want to strip the Lua debug information from the resulting bytecode, you can just specify the &lt;code&gt;-b&lt;/code&gt; option above instead of &lt;code&gt;-bg&lt;/code&gt;.</source>
          <target state="translated">여기서 중요한 것은 나중에 Lua에서이 모듈을 사용하는 방법을 결정하는 &lt;code&gt;.lua&lt;/code&gt; 파일 의 이름입니다 . 파일 이름 &lt;code&gt;foo.o&lt;/code&gt; 는 &lt;code&gt;.o&lt;/code&gt; 파일 확장자 ( &lt;code&gt;luajit&lt;/code&gt; 에게 어떤 출력 형식이 사용되는지 알려줍니다)를 제외하고는 전혀 중요하지 않습니다 . 결과 바이트 코드에서 Lua 디버그 정보를 제거하려면 &lt;code&gt;-bg&lt;/code&gt; 대신 &lt;code&gt;-b&lt;/code&gt; 옵션을 지정하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7da17365da141e4113795fb55cf89317b492eff2" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort&lt;/a&gt; is set to &lt;code&gt;off&lt;/code&gt; (which is the default), then this function call will always return the error message &quot;lua_check_client_abort is off&quot;.</source>
          <target state="translated">때 &lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort가&lt;/a&gt; 설정되어 &lt;code&gt;off&lt;/code&gt; (디폴트),이 함수 호출은 항상 오류 메시지 &quot;lua_check_client_abort이 꺼져&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc91d40857966e0f337496e865bde4a53500d706" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt; is specified at the same time, this hook usually runs before &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt;. When the SSL session is found and successfully loaded for the current SSL connection, SSL session resumption will happen and thus bypass the &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt; hook completely. In this case, NGINX also bypasses the &lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; hook, for obvious reasons.</source>
          <target state="translated">때 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *가&lt;/a&gt; 동시에 지정이 후크는 일반적 전에 실행 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt; . SSL 세션이 발견되고 현재 SSL 연결에 대해 성공적으로로드되면 SSL 세션 재개가 발생하여 &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt; 후크를 완전히 무시합니다 . 이 경우 NGINX는 명백한 이유로 &lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; 후크를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="e1b50a30e6d6cdb2880d71d5862baf40f3f30e74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ngx.flush(true)&lt;/code&gt; is called immediately after &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;, it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.</source>
          <target state="translated">때 &lt;code&gt;ngx.flush(true)&lt;/code&gt; 직후라고 &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; 또는 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; , 그것은 동기 모드에서 실행되도록 후자의 기능을 발생합니다. 스트리밍 출력에 특히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ff135588f575bd4ff6cb32ca6187d053e25778" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;status &amp;gt;= 200&lt;/code&gt; (i.e., &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; and above), it will interrupt the execution of the current request and return status code to nginx.</source>
          <target state="translated">되면 &lt;code&gt;status &amp;gt;= 200&lt;/code&gt; (즉, &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; 위), 그것을 현재의 nginx 요청 복귀 상태 코드의 실행을 중단한다.</target>
        </trans-unit>
        <trans-unit id="225dd63375b0570d2d0cf2e2a9e87f7b0692af7f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;status == 0&lt;/code&gt; (i.e., &lt;code&gt;ngx.OK&lt;/code&gt;), it will only quit the current phase handler (or the content handler if the &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua*&lt;/a&gt; directive is used) and continue to run later phases (if any) for the current request.</source>
          <target state="translated">때 &lt;code&gt;status == 0&lt;/code&gt; (즉, &lt;code&gt;ngx.OK&lt;/code&gt; 가 ), 그것은 단지 현재 단계 핸들러 (또는 경우 컨텐츠 핸들러 종료됩니다 &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua *&lt;/a&gt; 지시어를 사용)를 현재 요청에 대한 (있는 경우) 나중에 단계를 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b6977100a318c0f6aa85f9759462b8efe5aa9a73" translate="yes" xml:space="preserve">
          <source>When LuaJIT 2.x is used, it is possible to statically link the bytecode of pure Lua modules into the Nginx executable.</source>
          <target state="translated">LuaJIT 2.x를 사용하면 순수 Lua 모듈의 바이트 코드를 Nginx 실행 파일에 정적으로 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55c60517607f7b208179809cf800cfeddb46219" translate="yes" xml:space="preserve">
          <source>When Nginx receives the &lt;code&gt;HUP&lt;/code&gt; signal and starts reloading the config file, the Lua VM will also be re-created and &lt;code&gt;init_by_lua&lt;/code&gt; will run again on the new Lua VM. In case that the &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache&lt;/a&gt; directive is turned off (default on), the &lt;code&gt;init_by_lua&lt;/code&gt; handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</source>
          <target state="translated">Nginx가 &lt;code&gt;HUP&lt;/code&gt; 신호를 수신하고 구성 파일을 다시로드하기 시작하면 Lua VM도 다시 만들어지고 새 Lua VM에서 &lt;code&gt;init_by_lua&lt;/code&gt; 가 다시 실행됩니다. 이 경우 &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache의&lt;/a&gt; 지시어 (기본적) 해제되면, &lt;code&gt;init_by_lua&lt;/code&gt; 의 핸들러 때문에 독립 루아 VM은 항상 각 요청에 대해 생성이 특수 모드에서 모든 요청에 따라 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc5712ac2f460da505dec7c9d8b9c0f76df35e9" translate="yes" xml:space="preserve">
          <source>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a &lt;code&gt;FIN&lt;/code&gt; packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the &lt;a href=&quot;http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html&quot;&gt;TCP keepalive&lt;/a&gt; support in your system's TCP stack implementation in order to detect &quot;half-open&quot; TCP connections in time.</source>
          <target state="translated">TCP keepalive가 비활성화되면 클라이언트 쪽을 사용하여 소켓을 정상적으로 닫습니다 ( &lt;code&gt;FIN&lt;/code&gt; 패킷 등 전송 ). (부드러운) 실시간 웹 응용 프로그램의 경우 &quot;half-open&quot;TCP 연결을 적시에 감지하려면 시스템의 TCP 스택 구현에서 &lt;a href=&quot;http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html&quot;&gt;TCP keepalive&lt;/a&gt; 지원 을 구성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="00f5a2a442a78fd438677dd755070a4a12a351ed" translate="yes" xml:space="preserve">
          <source>When a match is found, a Lua table &lt;code&gt;captures&lt;/code&gt; is returned, where &lt;code&gt;captures[0]&lt;/code&gt; holds the whole substring being matched, and &lt;code&gt;captures[1]&lt;/code&gt; holds the first parenthesized sub-pattern's capturing, &lt;code&gt;captures[2]&lt;/code&gt; the second, and so on.</source>
          <target state="translated">일치하는 것이 발견되면, Lua 테이블 &lt;code&gt;captures&lt;/code&gt; 가 리턴되는데, 여기서 &lt;code&gt;captures[0]&lt;/code&gt; 은 일치되는 전체 서브 스트링을 보유하고, &lt;code&gt;captures[1]&lt;/code&gt; 은 첫 번째 괄호로 묶인 서브 패턴의 캡처, 두 번째를 &lt;code&gt;captures[2]&lt;/code&gt; 등을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f8fbda4a23eb8719b23958e48ba15a9fa62752f4" translate="yes" xml:space="preserve">
          <source>When a relative path like &lt;code&gt;foo/bar.lua&lt;/code&gt; is given, they will be turned into the absolute path relative to the &lt;code&gt;server prefix&lt;/code&gt; path determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</source>
          <target state="translated">&lt;code&gt;foo/bar.lua&lt;/code&gt; 와 같은 상대 경로 가 제공되면 Nginx 서버를 시작하는 동안 &lt;code&gt;-p PATH&lt;/code&gt; 명령 행 옵션에 의해 결정된 &lt;code&gt;server prefix&lt;/code&gt; 경로에 상대적인 절대 경로로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="88e147a447417173b6ecd2a2a627664fd5f2cd6a" translate="yes" xml:space="preserve">
          <source>When a timer expires, the user Lua code in the timer callback is running in a &quot;light thread&quot; detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;, cannot be shared between the original request and the timer user callback function.</source>
          <target state="translated">타이머가 만료되면 타이머 콜백의 사용자 Lua 코드가 타이머를 생성하는 원래 요청과 완전히 분리 된 &quot;가벼운 스레드&quot;로 실행됩니다. 따라서 &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt; 와 같이 요청을 생성 한 요청과 동일한 수명을 가진 오브젝트 는 원래 요청과 타이머 사용자 콜백 함수간에 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6abd8579e514353e2c10ecb6e73797049538a" translate="yes" xml:space="preserve">
          <source>When being used in the context of &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua*&lt;/a&gt;, this table just has the same lifetime of the current Lua handler.</source>
          <target state="translated">&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua *&lt;/a&gt; 의 컨텍스트에서 사용될 때이 테이블은 현재 Lua 핸들러의 수명이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9c9f7260a47a62e507608916a302811e705debe9" translate="yes" xml:space="preserve">
          <source>When being used in the contexts of &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;, &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua*&lt;/a&gt;, and &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua*&lt;/a&gt;, &lt;code&gt;ngx.exit()&lt;/code&gt; is an asynchronous operation and will return immediately. This behavior may change in future and it is recommended that users always use &lt;code&gt;return&lt;/code&gt; in combination as suggested above.</source>
          <target state="translated">의 문맥에서 사용되는 경우 &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt; , &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua의 *&lt;/a&gt; 및 &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua *&lt;/a&gt; , &lt;code&gt;ngx.exit()&lt;/code&gt; 비동기 작업이며 즉시 반환한다. 이 동작은 나중에 변경 될 수 있으므로 사용자 는 위에서 제안한대로 항상 &lt;code&gt;return&lt;/code&gt; 을 함께 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3d47f6f40f2d2c5ebfef7a62ca3511835ef4ecd2" translate="yes" xml:space="preserve">
          <source>When called without any argument, the iterator function returns the received data right &lt;em&gt;before&lt;/em&gt; the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is &lt;code&gt;'hello, world! -agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, then the string &lt;code&gt;'hello, world! -agentzh'&lt;/code&gt; will be returned.</source>
          <target state="translated">인수없이 호출되면 반복자 함수는 수신 데이터 스트림에서 지정된 패턴 문자열 &lt;em&gt;직전에&lt;/em&gt; 수신 된 데이터를 리턴합니다 . 위의 예에서 들어오는 데이터 스트림이 &lt;code&gt;'hello, world! -agentzh\r\n--abcedhb blah blah'&lt;/code&gt; 이면 문자열 &lt;code&gt;'hello, world! -agentzh'&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="21df47ff644579b3d7d1a3495d7eedb40f059c1d" translate="yes" xml:space="preserve">
          <source>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message &quot;N lua_max_running_timers are not enough&quot; where &quot;N&quot; is the current value of this directive.</source>
          <target state="translated">이 한계를 초과하면 Nginx는 새로 만료 된 타이머의 콜백 실행을 중지하고 &quot;N lua_max_running_timers가 충분하지 않습니다&quot;라는 오류 메시지를 기록합니다. 여기서 &quot;N&quot;은이 지시문의 현재 값입니다.</target>
        </trans-unit>
        <trans-unit id="50bad6bbea3db52bfad10306d6e125acac34e1ab" translate="yes" xml:space="preserve">
          <source>When exceeding this limit, the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; call will immediately return &lt;code&gt;nil&lt;/code&gt; and the error string &quot;too many pending timers&quot;.</source>
          <target state="translated">이 제한을 초과하면 &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; 호출은 즉시 &lt;code&gt;nil&lt;/code&gt; 및 오류 문자열 &quot;너무 많은 보류 타이머&quot;를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ee59ac626e9ea2758ca750efe715ff5503e58433" translate="yes" xml:space="preserve">
          <source>When it fails to allocate memory for the current key-value item, then &lt;code&gt;set&lt;/code&gt; will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; or memory segmentation), then the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;no memory&lt;/code&gt; and &lt;code&gt;success&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">현재 키-값 항목에 메모리를 할당하지 못하면 &lt;code&gt;set&lt;/code&gt; 은 LRU (Least-Recently Used) 알고리즘에 따라 저장소에서 기존 항목을 제거하려고 시도합니다. 여기서 LRU는 만료 시간보다 우선합니다. (때문에가 지정한 전체 용량의 한계 중 하나를 기존 항목의 수십 업 제거하고 저장 왼쪽이 여전히 부족하면 &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; 또는 메모리 분할), 다음 &lt;code&gt;err&lt;/code&gt; 반환 값은 없습니다 &lt;code&gt;no memory&lt;/code&gt; 와 &lt;code&gt;success&lt;/code&gt; 있을 것입니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f87f1fc15915d742dc78ba9b777775bbb22fc6e4" translate="yes" xml:space="preserve">
          <source>When setting &lt;code&gt;nil&lt;/code&gt; or an empty Lua string value to &lt;code&gt;ngx.arg[1]&lt;/code&gt;, no data chunk will be passed to the downstream Nginx output filters at all.</source>
          <target state="translated">설정시 &lt;code&gt;nil&lt;/code&gt; 거나 빈 루아 문자열 값 &lt;code&gt;ngx.arg[1]&lt;/code&gt; , 데이터 청크 모두의 하류 Nginx의 출력 필터에 전달되지 않는다.</target>
        </trans-unit>
        <trans-unit id="33c4d1ee4bbcee0ac73d2ed2648a8e475a46f777" translate="yes" xml:space="preserve">
          <source>When setting the limit to 0, the default &quot;match limit&quot; when compiling the PCRE library is used. And this is the default value of this directive.</source>
          <target state="translated">한계를 0으로 설정하면 PCRE 라이브러리를 컴파일 할 때 기본 &quot;일치 한계&quot;가 사용됩니다. 이것이이 지시문의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="50f142354601c7a01dc863e20d51d69f63922823" translate="yes" xml:space="preserve">
          <source>When success, returns a &quot;conditional true&quot; value (but not a &lt;code&gt;true&lt;/code&gt;). Otherwise, returns a &quot;conditional false&quot; value and a string describing the error.</source>
          <target state="translated">성공하면 &quot;조건부 true&quot;값을 반환합니다 (그러나 &lt;code&gt;true&lt;/code&gt; 는 아님). 그렇지 않으면 &quot;조건부 false&quot;값과 오류를 설명하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94f068b575575d9d2e236f8212bba9c71158bbe6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;body&lt;/code&gt; option is not specified and the &lt;code&gt;always_forward_body&lt;/code&gt; option is false (the default value), the &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; subrequests will inherit the request bodies of the parent request (if any).</source>
          <target state="translated">때 &lt;code&gt;body&lt;/code&gt; 옵션을 지정하고 있지 않습니다 &lt;code&gt;always_forward_body&lt;/code&gt; 옵션이 false (기본 값)되면, &lt;code&gt;POST&lt;/code&gt; 와 &lt;code&gt;PUT&lt;/code&gt; 의 하위 요청은 부모 요청 (있는 경우)의 요청 기관을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="6de69a62398012124c01070ddfaa80a4d1cae525" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;header_value&lt;/code&gt; argument is &lt;code&gt;nil&lt;/code&gt;, the request header will be removed. So</source>
          <target state="translated">때 &lt;code&gt;header_value&lt;/code&gt; 인수가 &lt;code&gt;nil&lt;/code&gt; , 요청 헤더가 제거됩니다. 그래서</target>
        </trans-unit>
        <trans-unit id="d82a64049b60581f59bb31aa29b8f372f2ee6ec5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;raw&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;, it is required that no pending data from any previous &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;, &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;, or &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; calls exists. So if you have these downstream output calls previously, you should call &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush(true)&lt;/a&gt; before calling &lt;code&gt;ngx.req.socket(true)&lt;/code&gt; to ensure that there is no pending output data. If the request body has not been read yet, then this &quot;raw socket&quot; can also be used to read the request body.</source>
          <target state="translated">때 &lt;code&gt;raw&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; , 이전의 보류중인 데이터 필요가있다 &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; , &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; , 또는 &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers의&lt;/a&gt; 호출이 존재하지 않습니다. 따라서 이전에 이러한 다운 스트림 출력 호출 이있는 경우 보류중인 출력 데이터가 없는지 확인하기 위해 &lt;code&gt;ngx.req.socket(true)&lt;/code&gt; 을 호출하기 전에 &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush (true)&lt;/a&gt; 를 호출 해야합니다. 요청 본문을 아직 읽지 않은 경우이 &quot;원시 소켓&quot;을 사용하여 요청 본문을 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5923b167310ef9d7895099251a4b912f7691107" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;replace&lt;/code&gt; argument is of type &quot;function&quot;, then it will be invoked with the &quot;match table&quot; as the argument to generate the replace string literal for substitution. The &quot;match table&quot; fed into the &lt;code&gt;replace&lt;/code&gt; function is exactly the same as the return value of &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;. Here is an example:</source>
          <target state="translated">때 &lt;code&gt;replace&lt;/code&gt; 인수가 &quot;기능&quot;유형의 다음이를 대체하기위한 대체 문자열 리터럴을 생성하는 인수로 &quot;경기 테이블&quot;로 호출됩니다. &lt;code&gt;replace&lt;/code&gt; 함수에 제공된 &quot;match table&quot; 은 &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; 의 반환 값과 정확히 동일합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc5ceb1d8f797313363763f219b47c4c7abfa124" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;replace&lt;/code&gt; is a string, then it is treated as a special template for string replacement. For example,</source>
          <target state="translated">때 &lt;code&gt;replace&lt;/code&gt; 문자열이고, 다음은 문자열 대체를위한 특별한 템플릿으로 처리됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7046882c8237fc7735b6bbbbc6a42bdad8ea8ac7" translate="yes" xml:space="preserve">
          <source>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache&lt;/a&gt;&lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid reloading Nginx.</source>
          <target state="translated">Lua 코드 캐시가 켜져 있으면 (기본적으로) 사용자 코드가 첫 번째 요청에서 한 번로드되고 캐시되며 Lua 소스 파일을 수정할 때마다 Nginx 구성을 다시로드해야합니다. 루아 코드 캐시는 일시적으로 전환하여 개발 기간 동안 비활성화 할 수 있습니다 &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache을 &lt;/a&gt; &lt;code&gt;off&lt;/code&gt; 에 &lt;code&gt;nginx.conf&lt;/code&gt; 의 Nginx를 다시로드하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f416d93052dbbe13068ebf193919846bca562d9d" translate="yes" xml:space="preserve">
          <source>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache&lt;/a&gt;&lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid repeatedly reloading Nginx.</source>
          <target state="translated">Lua 코드 캐시가 켜져 있으면 (기본적으로) 사용자 코드가 첫 번째 요청에서 한 번로드되고 캐시되며 Lua 소스 파일을 수정할 때마다 Nginx 구성을 다시로드해야합니다. 루아 코드 캐시는 일시적으로 전환하여 개발 기간 동안 비활성화 할 수 있습니다 &lt;a href=&quot;#lua_code_cache&quot;&gt;lua_code_cache을 &lt;/a&gt; &lt;code&gt;off&lt;/code&gt; 에 &lt;code&gt;nginx.conf&lt;/code&gt; 의 Nginx를 다시로드 반복되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af3509c76fdb43db6a9787e75937e10bb5c59a4" translate="yes" xml:space="preserve">
          <source>When the Lua code may change the length of the response body, then it is required to always clear out the &lt;code&gt;Content-Length&lt;/code&gt; response header (if any) in a header filter to enforce streaming output, as in</source>
          <target state="translated">Lua 코드가 응답 본문의 길이를 변경할 수있는 경우 스트리밍 출력을 적용하려면 헤더 필터에서 &lt;code&gt;Content-Length&lt;/code&gt; 응답 헤더 (있는 경우) 를 항상 지워야합니다.</target>
        </trans-unit>
        <trans-unit id="1fc2bbeacbac28ac92b502ea9d6e4b5960bb0814" translate="yes" xml:space="preserve">
          <source>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</source>
          <target state="translated">연결 풀이 사용 가능한 크기 제한을 초과하면 풀에서 이미 가장 최근에 사용 된 (유휴) 연결이 닫혀 현재 연결을위한 공간이 마련됩니다.</target>
        </trans-unit>
        <trans-unit id="1d187073d9963d5bb36b20287faa0c6425a1c3f7" translate="yes" xml:space="preserve">
          <source>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</source>
          <target state="translated">요청 본문의 메모리 버퍼에 데이터를 더 이상 보유 할 수없는 경우 Nginx 코어의 표준 요청 본문 판독기처럼 데이터가 임시 파일로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="1dbad2abaf08f5ead2e02738e55367c0d8314569" translate="yes" xml:space="preserve">
          <source>When the key does not exist or has already expired in the shared dictionary,</source>
          <target state="translated">키가 없거나 공유 사전에 이미 만료 된 경우</target>
        </trans-unit>
        <trans-unit id="53e477dfa7291c96581969ff981143209b0c9a82" translate="yes" xml:space="preserve">
          <source>When the limit is hit, the error string &quot;pcre_exec() failed: -8&quot; will be returned by the &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API&lt;/a&gt; functions on the Lua land.</source>
          <target state="translated">한계에 도달하면 오류 문자열 &quot;pcre_exec () 실패 : -8&quot;이 Lua 랜드 의 &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API&lt;/a&gt; 함수에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4353ea9e30658349de7dc3c1525924337c248688" translate="yes" xml:space="preserve">
          <source>When the system receive buffer for the current connection has unread data, then this method will return the &quot;connection in dubious state&quot; error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.</source>
          <target state="translated">현재 연결에 대한 시스템 수신 버퍼에 읽지 않은 데이터가있는 경우이 세션은 이전 세션에 읽지 않은 데이터가 다음 세션 및 연결에 대해 남아 있기 때문에 &quot;의심스러운 상태의 연결&quot;오류 메시지 (두 번째 리턴 값)를 리턴합니다. 재사용해도 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7527bdcfaf27919cdc412479e62e92e94df60ea" translate="yes" xml:space="preserve">
          <source>When the user &quot;light thread&quot; terminates with a Lua error, however, it will not abort other running &quot;light threads&quot; like the &quot;entry thread&quot; does.</source>
          <target state="translated">그러나 사용자 &quot;light thread&quot;가 Lua 오류와 함께 종료되면 &quot;entry thread&quot;와 같이 실행중인 다른 &quot;light thread&quot;를 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e563f529bfc607d8234b997bd60b236bc5ecdcf" translate="yes" xml:space="preserve">
          <source>When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt;) or just stop and clean up all the Lua &quot;light threads&quot; running in the current request's request handler when there is no user callback function registered.</source>
          <target state="translated">이 지시문이 켜져 있으면 ngx_lua 모듈은 다운 스트림 연결에서 조기 연결 종료 이벤트를 모니터링하고 이러한 이벤트가있을 경우 사용자 Lua 함수 콜백 ( &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort에&lt;/a&gt; 의해 등록됨 )을 호출 하거나 모두 중지하고 정리합니다. 등록 된 사용자 콜백 함수가없는 경우 현재 요청의 요청 처리기에서 실행되는 Lua &quot;라이트 스레드&quot;</target>
        </trans-unit>
        <trans-unit id="f96a370dec09fae7e5f7553f460aca35a9f146e6" translate="yes" xml:space="preserve">
          <source>When this is used in the context of the &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua*&lt;/a&gt; directives, this table is read-only and holds the input arguments to the config directives:</source>
          <target state="translated">이것이 &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua *&lt;/a&gt; 지시문 의 컨텍스트에서 사용될 때이 테이블은 읽기 전용이며 구성 지시문에 대한 입력 인수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="9cd9505fd5f4ffe331c7901b1c9d378293a25bd8" translate="yes" xml:space="preserve">
          <source>When this table is used in the context of &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua*&lt;/a&gt;, the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the &quot;eof&quot; flag indicating the end of the whole output data stream.</source>
          <target state="translated">이 테이블이 &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua *&lt;/a&gt; 의 컨텍스트에서 사용될 때 첫 번째 요소는 출력 필터 코드에 대한 입력 데이터 청크를 보유하고 두 번째 요소는 전체 출력 데이터 스트림의 끝을 나타내는 &quot;eof&quot;플래그에 대한 부울 플래그를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="9a472f7253267d55b4af5f3c0e8341fdeac856c8" translate="yes" xml:space="preserve">
          <source>When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the &lt;code&gt;0.9.3&lt;/code&gt; release. So the Lua files referenced in &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt;, &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;, &lt;a href=&quot;#access_by_lua_file&quot;&gt;access_by_lua_file&lt;/a&gt;, and etc will not be cached and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</source>
          <target state="translated">끄면 ngx_lua가 제공하는 모든 요청은 &lt;code&gt;0.9.3&lt;/code&gt; 릴리스 부터 별도의 Lua VM 인스턴스에서 실행됩니다 . 따라서 &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt; , &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt; , &lt;a href=&quot;#access_by_lua_file&quot;&gt;access_by_lua_file &lt;/a&gt;등에서 참조되는 Lua 파일 은 캐시되지 않으며 사용 된 모든 Lua 모듈이 처음부터로드됩니다. 이를 통해 개발자는 편집 및 새로 고침 방식을 채택 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89d8e0936f9c23a54fde5f08d7fbf8f7e88b042" translate="yes" xml:space="preserve">
          <source>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</source>
          <target state="translated">다운 스트림 연결에 대해 HTTP 1.1 연결 유지 기능을 사용하지 않으면이 메소드를 호출 할 때 잘 작성된 HTTP 클라이언트를 사용하여 연결을 능동적으로 닫을 수 있습니다. 이 트릭은 다음 예제와 같이 HTTP 클라이언트가 연결을 기다리지 않고 백그라운드 작업을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73d8afd53a24f840ab8e9efc3bee4f9f2860686" translate="yes" xml:space="preserve">
          <source>When you have multiple &lt;code&gt;.lua&lt;/code&gt; files to compile and link, then just specify their &lt;code&gt;.o&lt;/code&gt; files at the same time in the value of the &lt;code&gt;--with-ld-opt&lt;/code&gt; option. For instance,</source>
          <target state="translated">컴파일하고 링크 할 &lt;code&gt;.lua&lt;/code&gt; 파일 이 여러 개인 경우 &lt;code&gt;--with-ld-opt&lt;/code&gt; 옵션 의 값으로 &lt;code&gt;.o&lt;/code&gt; 파일을 동시에 지정 하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="94db54106b5dfa9a7364b516a52fe6b32fca8ff0" translate="yes" xml:space="preserve">
          <source>While building this module either via OpenResty or with the NGINX core, you can define the following C macros via the C compiler options:</source>
          <target state="translated">OpenResty 또는 NGINX 코어를 사용하여이 모듈을 빌드하는 동안 C 컴파일러 옵션을 통해 다음 C 매크로를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e803da16672d30b945fda90ac008bafb4fc3ee6" translate="yes" xml:space="preserve">
          <source>With the settings above,</source>
          <target state="translated">위의 설정으로</target>
        </trans-unit>
        <trans-unit id="f274f7e25e73d37fda59c4e9bc146de173e28a70" translate="yes" xml:space="preserve">
          <source>Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification.</source>
          <target state="translated">외부 스크립트 파일 내에서 대괄호로 묶인 Lua 문자열 리터럴로 표시되는 PCRE 시퀀스는 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ae4fa9153538d61e84012cea39683398cd73853" translate="yes" xml:space="preserve">
          <source>Writes argument values into the nginx &lt;code&gt;error.log&lt;/code&gt; file with the &lt;code&gt;ngx.NOTICE&lt;/code&gt; log level.</source>
          <target state="translated">&lt;code&gt;ngx.NOTICE&lt;/code&gt; 로그 레벨을 사용하여 인수 값을 nginx &lt;code&gt;error.log&lt;/code&gt; 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e14b0ba20c614e530843eadd0bb264e9c2ad11ed" translate="yes" xml:space="preserve">
          <source>Yields the execution of the current user Lua coroutine.</source>
          <target state="translated">현재 사용자 루아 코 루틴의 실행을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e138b696d46fc590c8a9bfd87acf83c9dd1cfb70" translate="yes" xml:space="preserve">
          <source>You are recommended to use &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; instead of &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 것이 좋습니다 &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; 대신 &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;의 setTimeout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c7cfaef5025ae2ca4cac694fa8bfd66c71ddfaf" translate="yes" xml:space="preserve">
          <source>You can also initialize the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; shm storage at this phase. Here is an example for this:</source>
          <target state="translated">이 단계에서 &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; shm 스토리지를 초기화 할 수도 있습니다 . 이에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4d370f8493ee40eb9cc6e6bd967af301c94ec9c" translate="yes" xml:space="preserve">
          <source>You can call coroutine.status() and coroutine.yield() on the &quot;light thread&quot; coroutines.</source>
          <target state="translated">&quot;가벼운 스레드&quot;코 루틴에서 coroutine.status () 및 coroutine.yield ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="961000ca825e2709cd7f2398b770b7181dcaf210" translate="yes" xml:space="preserve">
          <source>You can forcibly update the Nginx time cache by calling &lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt; first.</source>
          <target state="translated">&lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time을&lt;/a&gt; 먼저 호출하여 Nginx 시간 캐시를 강제로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e950061e916e474f02f2473273d173d7e7cad54e" translate="yes" xml:space="preserve">
          <source>You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you &lt;em&gt;cannot&lt;/em&gt; pass any thread objects returned by &lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine.create&lt;/a&gt; and &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt; or any cosocket objects returned by &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;, &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; because these objects' lifetime is bound to the request context creating them while the timer callback is detached from the creating request's context (by design) and runs in its own (fake) request context. If you try to share the thread or cosocket objects across the boundary of the creating request, then you will get the &quot;no co ctx found&quot; error (for threads) or &quot;bad request&quot; (for cosockets). It is fine, however, to create all these objects inside your timer callback.</source>
          <target state="translated">대부분의 표준 Lua 값 (널, 부울, 숫자, 문자열, 테이블, 클로저, 파일 핸들 등)을 사용자 인수로 명시 적으로 또는 콜백 클로저에 대한 암시 적으로 업타임으로 타이머 콜백에 전달할 수 있습니다. 몇 가지 예외가, 그러나있다 : 당신이 &lt;em&gt;할 수&lt;/em&gt; 있는 스레드에 의해 반환 된 객체 통과 &lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine.create&lt;/a&gt; 및 &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt; 또는 cosocket에 의해 반환되는 객체 &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; , &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt; 하고,&lt;a href=&quot;#ngxreqsocket&quot;&gt; ngx.req.socket&lt;/a&gt;타이머 콜백이 설계 요청에 따라 작성 요청의 컨텍스트에서 분리되고 자체 (가짜) 요청 컨텍스트에서 실행되는 동안 이러한 오브젝트의 수명은 요청 컨텍스트에 작성됩니다. 작성 요청의 경계를 넘어서 스레드 또는 코 소켓 오브젝트를 공유하려고하면 &quot;no co ctx found&quot;오류 (스레드) 또는 &quot;잘못된 요청&quot;(코 소켓)이 발생합니다. 그러나 타이머 콜백 내에 이러한 모든 객체를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="50a4ab21caee4d1c2c49bbf3f48b6568a6b62286" translate="yes" xml:space="preserve">
          <source>You can read the messages in the buffer on the Lua land via the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs&quot;&gt;get_logs()&lt;/a&gt; function of the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme&quot;&gt;ngx.errlog&lt;/a&gt; module of the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme&quot;&gt;lua-resty-core&lt;/a&gt; library. This Lua API function will return the captured error log messages and also remove these already read from the global capturing buffer, making room for any new error log data. For this reason, the user should not configure this buffer to be too big if the user read the buffered error log data fast enough.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme&quot;&gt;lua-resty-core&lt;/a&gt; 라이브러리 의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme&quot;&gt;ngx.errlog&lt;/a&gt; 모듈의 &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs&quot;&gt;get_logs ()&lt;/a&gt; 함수를 통해 Lua 랜드의 버퍼에서 메시지를 읽을 수 있습니다 . 이 Lua API 함수는 캡처 된 오류 로그 메시지를 반환하고 전역 캡처 버퍼에서 이미 읽은 메시지를 제거하여 새로운 오류 로그 데이터를위한 공간을 만듭니다. 따라서 사용자가 버퍼링 된 오류 로그 데이터를 충분히 빨리 읽는 경우이 버퍼를 너무 크게 구성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="690742b949ff5b3876b8f53a8f40ab9ad0625fe9" translate="yes" xml:space="preserve">
          <source>You can specify the optional &lt;code&gt;no_request_line&lt;/code&gt; argument as a &lt;code&gt;true&lt;/code&gt; value to exclude the request line from the result. For example,</source>
          <target state="translated">선택적 &lt;code&gt;no_request_line&lt;/code&gt; 인수를 &lt;code&gt;true&lt;/code&gt; 값 으로 지정하여 요청 행을 결과에서 제외 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9d15bb344f1445867fadcca27c710dfa11eb5554" translate="yes" xml:space="preserve">
          <source>You can use the &quot;raw request socket&quot; returned by &lt;code&gt;ngx.req.socket(true)&lt;/code&gt; to implement fancy protocols like &lt;a href=&quot;http://en.wikipedia.org/wiki/WebSocket&quot;&gt;WebSocket&lt;/a&gt;, or just emit your own raw HTTP response header or body data. You can refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;lua-resty-websocket library&lt;/a&gt; for a real world example.</source>
          <target state="translated">&lt;code&gt;ngx.req.socket(true)&lt;/code&gt; 에서 반환 한 &quot;원시 요청 소켓&quot;을 사용하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/WebSocket&quot;&gt;WebSocket&lt;/a&gt; 과 같은 멋진 프로토콜을 구현 하거나 고유 한 원시 HTTP 응답 헤더 또는 본문 데이터를 생성 할 수 있습니다. 실제 예제 는 &lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;lua-resty-websocket 라이브러리&lt;/a&gt; 를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fe6dce3051da148abf7a1c0c7732a8a66403c6e" translate="yes" xml:space="preserve">
          <source>You can use the &quot;raw request socket&quot; returned by &lt;code&gt;ngx.req.socket(true)&lt;/code&gt; to implement fancy protocols like &lt;a href=&quot;https://en.wikipedia.org/wiki/WebSocket&quot;&gt;WebSocket&lt;/a&gt;, or just emit your own raw HTTP response header or body data. You can refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;lua-resty-websocket library&lt;/a&gt; for a real world example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc81828fdf6b5bfdb714bddc466fabd55f87bff5" translate="yes" xml:space="preserve">
          <source>You can use units like &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; in the &lt;code&gt;size&lt;/code&gt; value, as in</source>
          <target state="translated">다음과 같이 &lt;code&gt;size&lt;/code&gt; 값 에 &lt;code&gt;k&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 과 같은 단위를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="22c359d2ff1f0a68f628dd63a16719644b23f8de" translate="yes" xml:space="preserve">
          <source>You should always read the request body (by either calling &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; or configuring &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; on) before initiating a subrequest.</source>
          <target state="translated">하위 요청을 시작하기 전에 항상 요청 본문 ( &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; 를 호출 하거나 &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; 를 구성 하여)을 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="99c38dcd7a86861a6925f533077b4eab9f8ab141" translate="yes" xml:space="preserve">
          <source>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the &lt;code&gt;root&lt;/code&gt; account.</source>
          <target state="translated">Nginx 마스터 프로세스는 종종 &lt;code&gt;root&lt;/code&gt; 계정으로 실행되기 때문에이 컨텍스트에 등록 된 Lua 코드의 잠재적 보안 취약성에 대해 매우주의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3a7c071e6e4eaa835aab72980f6430c86b3c0543" translate="yes" xml:space="preserve">
          <source>a &quot;light thread&quot; (either the &quot;entry thread&quot; or a user &quot;light thread&quot; aborts by calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;, or &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri(uri, true)&lt;/a&gt;, or</source>
          <target state="translated">&quot;가벼운 스레드&quot;( &quot;엔트리 스레드&quot;또는 사용자 &quot;가벼운 스레드&quot;)는 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; , &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; , &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; 또는 &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri (uri, true)&lt;/a&gt; 를 호출하여 중단 되거나</target>
        </trans-unit>
        <trans-unit id="0205ec0adfc7d5c99a04ad19e2fab13bdfefd40c" translate="yes" xml:space="preserve">
          <source>a (nonblocking) I/O operation cannot be completed in a single run,</source>
          <target state="translated">(비 차단) I / O 작업은 단일 실행으로 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea92adc1f11d7fe30542473f05266c229ad9e4e" translate="yes" xml:space="preserve">
          <source>access_by_lua</source>
          <target state="translated">access_by_lua</target>
        </trans-unit>
        <trans-unit id="5293cd950938a60cf5c708d34e39091e8da46881" translate="yes" xml:space="preserve">
          <source>access_by_lua_block</source>
          <target state="translated">access_by_lua_block</target>
        </trans-unit>
        <trans-unit id="4ae774dba2ea45d3d3b344384a96aa5050731f79" translate="yes" xml:space="preserve">
          <source>access_by_lua_file</source>
          <target state="translated">access_by_lua_file</target>
        </trans-unit>
        <trans-unit id="f8bc5499f122ed62a6e8913d0f96f5881f8cd53b" translate="yes" xml:space="preserve">
          <source>access_by_lua_no_postpone</source>
          <target state="translated">access_by_lua_no_postpone</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="9a406a10ed1057806377027b0fc568f84a6160f1" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;ignore_resp_headers&lt;/code&gt;, &lt;code&gt;ignore_resp_body&lt;/code&gt;, and &lt;code&gt;ignore_resp&lt;/code&gt; options to &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; methods, to allow micro performance tuning on the user side.</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 및 &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; 메소드 에 &lt;code&gt;ignore_resp_headers&lt;/code&gt; , &lt;code&gt;ignore_resp_body&lt;/code&gt; 및 &lt;code&gt;ignore_resp&lt;/code&gt; 옵션을 추가 하여 사용자 측에서 마이크로 성능 조정을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f715fea5de7ac9f3cd4f352a1c6d7b055f1103d4" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;stat&lt;/code&gt; mode similar to &lt;a href=&quot;https://httpd.apache.org/docs/trunk/mod/mod_lua.html&quot;&gt;mod_lua&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://httpd.apache.org/docs/trunk/mod/mod_lua.html&quot;&gt;mod_lua&lt;/a&gt; 와 비슷한 &lt;code&gt;stat&lt;/code&gt; 모드를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="699ca5c14be3866873be9ebdad3c83cb91c9b9cd" translate="yes" xml:space="preserve">
          <source>add automatic Lua code time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.</source>
          <target state="translated">Lua의 디버그 후크를 통해 Lua VM을 적극적으로 생성하고 다시 시작하여 자동 Lua 코드 시간 슬라이싱 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b5fdbcd4ed95a7e457ae6c8320439dc01d4db773" translate="yes" xml:space="preserve">
          <source>add configure options for different strategies of handling the cosocket connection exceeding in the pools.</source>
          <target state="translated">풀에서 초과하는 코 소켓 연결을 처리하는 다양한 전략에 대한 구성 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="afd41786a0f2a8fe51c13cbf81cc68e281f55f04" translate="yes" xml:space="preserve">
          <source>add directives to run Lua codes when nginx stops.</source>
          <target state="translated">nginx가 중지 될 때 Lua 코드를 실행하기위한 지시문을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5c0be792199b22bac23601eab86f5eb924035fd8" translate="yes" xml:space="preserve">
          <source>add new API function &lt;code&gt;ngx.resp.add_header&lt;/code&gt; to emulate the standard &lt;code&gt;add_header&lt;/code&gt; config directive.</source>
          <target state="translated">표준 &lt;code&gt;add_header&lt;/code&gt; 구성 지시문 을 에뮬레이트하려면 새 API 함수 &lt;code&gt;ngx.resp.add_header&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cb0d4e11a742b2715d4c5b444e17d5151053e37" translate="yes" xml:space="preserve">
          <source>and old &lt;code&gt;Foo&lt;/code&gt; headers will be overridden if there is any.</source>
          <target state="translated">기존 &lt;code&gt;Foo&lt;/code&gt; 헤더가 있으면 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad94b8b9c3eaa965889be7e1888b24254d5f393" translate="yes" xml:space="preserve">
          <source>and then accessing it from &lt;code&gt;nginx.conf&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;nginx.conf&lt;/code&gt; 에서 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef83b68ae8df93a61c4744300349cdfb237b3a69" translate="yes" xml:space="preserve">
          <source>and whether &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only&lt;/a&gt; has been switched on.</source>
          <target state="translated">&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only&lt;/a&gt; 가 켜져 있는지 여부</target>
        </trans-unit>
        <trans-unit id="d8ea46449975e51d6e7b7e3d93410cf6d6466b57" translate="yes" xml:space="preserve">
          <source>and whether &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only&quot;&gt;client_body_in_file_only&lt;/a&gt; has been switched on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72abfe7822625370bbffcbe9d510b96b00a96b50" translate="yes" xml:space="preserve">
          <source>assuming memcached (or something else) is listening on the unix domain socket file &lt;code&gt;/tmp/memcached.sock&lt;/code&gt;.</source>
          <target state="translated">memcached (또는 다른 것)가 유닉스 도메인 소켓 파일 &lt;code&gt;/tmp/memcached.sock&lt;/code&gt; 에서 수신하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8a80dee24963d0e7d2dcb1d3a88f75ff2fe9f04b" translate="yes" xml:space="preserve">
          <source>assuming the datagram service is listening on the unix domain socket file &lt;code&gt;/tmp/some-datagram-service.sock&lt;/code&gt; and the client socket will use the &quot;autobind&quot; feature on Linux.</source>
          <target state="translated">데이터 그램 서비스가 유닉스 도메인 소켓 파일 &lt;code&gt;/tmp/some-datagram-service.sock&lt;/code&gt; 에서 수신 대기 중이고 클라이언트 소켓이 Linux에서 &quot;자동 바인딩 &quot;기능을 사용 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="582a358e2864ee266a97b280fa2b80e00f23a873" translate="yes" xml:space="preserve">
          <source>balancer_by_lua_block</source>
          <target state="translated">balancer_by_lua_block</target>
        </trans-unit>
        <trans-unit id="f683871ee1c7346e73f9316e5431b77b8b2f25ca" translate="yes" xml:space="preserve">
          <source>balancer_by_lua_file</source>
          <target state="translated">balancer_by_lua_file</target>
        </trans-unit>
        <trans-unit id="087451882149bae78baef64b84ed8c85bab52d54" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;if&lt;/code&gt; runs &lt;em&gt;before&lt;/em&gt;&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; even if it is placed after &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; in the config.</source>
          <target state="translated">때문에 &lt;code&gt;if&lt;/code&gt; 실행 &lt;em&gt;전에 &lt;/em&gt;&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua이&lt;/a&gt; 가 뒤에 위치하는 경우에도 &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; 는 config입니다.</target>
        </trans-unit>
        <trans-unit id="3bd6b7b104d2bdc14957c2d9e8d14e963056ce9d" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;set $a 12&lt;/code&gt; and &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; run &lt;em&gt;before&lt;/em&gt;&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua &lt;/a&gt;&lt;em&gt;전에 &lt;/em&gt; &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; &lt;code&gt;set $a 12&lt;/code&gt; 를 설정하고 $ b &quot;&quot;를 실행 했기 때문 입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70206c109fedd65c54e9c77871072f88e173ae83" translate="yes" xml:space="preserve">
          <source>body_filter_by_lua</source>
          <target state="translated">body_filter_by_lua</target>
        </trans-unit>
        <trans-unit id="5ecf1152f084855f70fd420f15744afd0933e011" translate="yes" xml:space="preserve">
          <source>body_filter_by_lua_block</source>
          <target state="translated">body_filter_by_lua_block</target>
        </trans-unit>
        <trans-unit id="6b8892bfc30f7510b57ce6a839ed96b00c455533" translate="yes" xml:space="preserve">
          <source>body_filter_by_lua_file</source>
          <target state="translated">body_filter_by_lua_file</target>
        </trans-unit>
        <trans-unit id="885693dadbd23f9e2c2ba03fae534f35e5945d9e" translate="yes" xml:space="preserve">
          <source>both the &quot;entry thread&quot; and all the user &quot;light threads&quot; terminates,</source>
          <target state="translated">&quot;엔트리 스레드&quot;와 모든 사용자 &quot;라이트 스레드&quot;가 모두 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3caf9cb101f9ab17ab153aa900f187916a831aea" translate="yes" xml:space="preserve">
          <source>can be coded as</source>
          <target state="translated">로 코딩 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e4cda6df48f680ce054a5c4c6214f8249d18fd29" translate="yes" xml:space="preserve">
          <source>can be coded in Lua as</source>
          <target state="translated">루아에서 다음과 같이 코딩 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7e611ed7b3bf8db96950b4312d91de35899fe082" translate="yes" xml:space="preserve">
          <source>can be coded in Lua like this:</source>
          <target state="translated">루아에서 다음과 같이 코딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a66d661cd1e5207d5a64a80af033677983c62b5b" translate="yes" xml:space="preserve">
          <source>can be implemented in ngx_lua as:</source>
          <target state="translated">ngx_lua에서 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb1f56d3fbe09e809244fc8e13671cd876e3860" translate="yes" xml:space="preserve">
          <source>capacity</source>
          <target state="translated">capacity</target>
        </trans-unit>
        <trans-unit id="da38860cb875cb64092e402d80d9fe29c4865b18" translate="yes" xml:space="preserve">
          <source>close</source>
          <target state="translated">close</target>
        </trans-unit>
        <trans-unit id="35f9580d35e4200cec9b6ae47a1058414dd2b551" translate="yes" xml:space="preserve">
          <source>coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,</source>
          <target state="translated">데이터베이스 백엔드 및 기타 스토리지에 대한 동 기적이지만 여전히 블로킹되지 않은 액세스를 사용하여 컨텐츠 핸들러에서 임의로 복잡한 웹 애플리케이션을 코딩</target>
        </trans-unit>
        <trans-unit id="f11a107f38328604e9320754224b60375758bca1" translate="yes" xml:space="preserve">
          <source>connect</source>
          <target state="translated">connect</target>
        </trans-unit>
        <trans-unit id="76bdb07ff81e63c5d6c890ec2a6911074e7c2604" translate="yes" xml:space="preserve">
          <source>content_by_lua</source>
          <target state="translated">content_by_lua</target>
        </trans-unit>
        <trans-unit id="510a31a14b14f2fdf5849cae5ce6be91031acb7c" translate="yes" xml:space="preserve">
          <source>content_by_lua_block</source>
          <target state="translated">content_by_lua_block</target>
        </trans-unit>
        <trans-unit id="2de783ac03434e3d768471853628ec7bcf88e727" translate="yes" xml:space="preserve">
          <source>content_by_lua_file</source>
          <target state="translated">content_by_lua_file</target>
        </trans-unit>
        <trans-unit id="aaae2631f5bb5f54485a73c872bcacfee7de77dc" translate="yes" xml:space="preserve">
          <source>coroutine.create</source>
          <target state="translated">coroutine.create</target>
        </trans-unit>
        <trans-unit id="c31ca37d3862fe3a5e4030ef6aa5c2449aca06d8" translate="yes" xml:space="preserve">
          <source>coroutine.resume</source>
          <target state="translated">coroutine.resume</target>
        </trans-unit>
        <trans-unit id="ce55502f20f668fde01b7bba7aaefbb4d4861abc" translate="yes" xml:space="preserve">
          <source>coroutine.running</source>
          <target state="translated">coroutine.running</target>
        </trans-unit>
        <trans-unit id="ca57d88ceba501ae3f0ad9078c2dd644e0c85bb6" translate="yes" xml:space="preserve">
          <source>coroutine.status</source>
          <target state="translated">coroutine.status</target>
        </trans-unit>
        <trans-unit id="609daeb097353d1a194f2f9b64becd2bd4ec8268" translate="yes" xml:space="preserve">
          <source>coroutine.wrap</source>
          <target state="translated">coroutine.wrap</target>
        </trans-unit>
        <trans-unit id="b474c3b4844418c526eed6cbb8423f4fb6e87cdf" translate="yes" xml:space="preserve">
          <source>coroutine.yield</source>
          <target state="translated">coroutine.yield</target>
        </trans-unit>
        <trans-unit id="49b82aceb2e2e1d21428c137f862316155cfa61a" translate="yes" xml:space="preserve">
          <source>cosocket: add client SSL certificate support.</source>
          <target state="translated">코 소켓 : 클라이언트 SSL 인증서 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fac10ec0b8d8888da63210e8dd96ba6a1b48628f" translate="yes" xml:space="preserve">
          <source>cosocket: add support in the context of &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt;.</source>
          <target state="translated">cosocket : &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt; 의 컨텍스트에서 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f42aaf3339fa3aeaf146de4d631228c86dc94e68" translate="yes" xml:space="preserve">
          <source>cosocket: implement LuaSocket's unconnected UDP API.</source>
          <target state="translated">cosocket : LuaSocket의 연결되지 않은 UDP API를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3823a79d16b550ee7d81c2557738fad1dda525e8" translate="yes" xml:space="preserve">
          <source>cosocket: implement the &lt;code&gt;bind()&lt;/code&gt; method for stream-typed cosockets.</source>
          <target state="translated">코 소켓 : 스트림 유형 코 소켓에 대해 &lt;code&gt;bind()&lt;/code&gt; 메소드를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="d51d6f6ecdb121ebbf1bf1939f1cfe2e3bfc57cb" translate="yes" xml:space="preserve">
          <source>cosocket: pool-based backend concurrency level control: implement automatic &lt;code&gt;connect&lt;/code&gt; queueing when the backend concurrency exceeds its connection pool limit.</source>
          <target state="translated">코 소켓 : 풀 기반 백엔드 동시성 레벨 제어 : 백엔드 동시성이 연결 풀 한계를 초과하면 자동 &lt;code&gt;connect&lt;/code&gt; 큐잉을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="d1de7a2b0625d63b5ca272926e746a4f5e055f95" translate="yes" xml:space="preserve">
          <source>cosocket: review and merge aviramc's &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/pull/290&quot;&gt;patch&lt;/a&gt; for adding the &lt;code&gt;bsdrecv&lt;/code&gt; method.</source>
          <target state="translated">cosocket : &lt;code&gt;bsdrecv&lt;/code&gt; 메소드 추가를위한 aviramc의 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/pull/290&quot;&gt;패치&lt;/a&gt; 를 검토하고 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="3426ee9f481680269d873ce6d23e65fcc7eb6d7d" translate="yes" xml:space="preserve">
          <source>creating a ticket on the &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/issues&quot;&gt;GitHub Issue Tracker&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-nginx-module/issues&quot;&gt;GitHub 이슈 트래커&lt;/a&gt; 에서 티켓 생성</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="426cede9b821e0e7d12522286db68cb3cc38a621" translate="yes" xml:space="preserve">
          <source>doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,</source>
          <target state="translated">요청이 실제로 업스트림 백엔드에 도달하기 전에 Lua에서 임의로 복잡한 액세스 제어 및 보안 검사 수행</target>
        </trans-unit>
        <trans-unit id="e7d58d156125f0bb4d6e499d5bc4942e10404b32" translate="yes" xml:space="preserve">
          <source>doing very complex URL dispatch in Lua at rewrite phase,</source>
          <target state="translated">다시 쓰기 단계에서 Lua에서 매우 복잡한 URL 디스패치</target>
        </trans-unit>
        <trans-unit id="8e0d121c1c0299a43509f0e6dee7215038e5c299" translate="yes" xml:space="preserve">
          <source>drizzle-nginx-module</source>
          <target state="translated">drizzle-nginx-module</target>
        </trans-unit>
        <trans-unit id="610f48001bc9ea4dcecbaf83b4832cdd7eb2416f" translate="yes" xml:space="preserve">
          <source>echo-nginx-module</source>
          <target state="translated">echo-nginx-module</target>
        </trans-unit>
        <trans-unit id="20dda04ba85cc1d159e6c80f0473186d495ab0ca" translate="yes" xml:space="preserve">
          <source>expire</source>
          <target state="translated">expire</target>
        </trans-unit>
        <trans-unit id="ce7f404770ee79ffa96fafb987734df507af6428" translate="yes" xml:space="preserve">
          <source>fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,</source>
          <target state="translated">외부 스토리지 백엔드 (예 : redis, memcached, mysql, postgresql)에서 백엔드 정보를 가져 와서 해당 정보를 사용하여 어떤 업스트림 백엔드를 즉시 액세스할지 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4c6da73188b93089901c81209598fdbf4840286f" translate="yes" xml:space="preserve">
          <source>flush_all</source>
          <target state="translated">flush_all</target>
        </trans-unit>
        <trans-unit id="08f51c012828d59b5a687199627897613fc11376" translate="yes" xml:space="preserve">
          <source>flush_expired</source>
          <target state="translated">flush_expired</target>
        </trans-unit>
        <trans-unit id="d166f6ec1622529cfa244871a0dc3e21112522a7" translate="yes" xml:space="preserve">
          <source>free_space</source>
          <target state="translated">free_space</target>
        </trans-unit>
        <trans-unit id="783923e57ba5e8f1044632c31fd806ee24814bb5" translate="yes" xml:space="preserve">
          <source>get</source>
          <target state="translated">get</target>
        </trans-unit>
        <trans-unit id="71fc98fc23f579d9edcc0f5f49fca34a0b220fa8" translate="yes" xml:space="preserve">
          <source>get_keys</source>
          <target state="translated">get_keys</target>
        </trans-unit>
        <trans-unit id="464ffbd50eaab98aac8938ab38b74ddd20845444" translate="yes" xml:space="preserve">
          <source>get_stale</source>
          <target state="translated">get_stale</target>
        </trans-unit>
        <trans-unit id="6916288ca4cf791ca8d3d8442fa133a628988533" translate="yes" xml:space="preserve">
          <source>getreusedtimes</source>
          <target state="translated">getreusedtimes</target>
        </trans-unit>
        <trans-unit id="d6ba0a23f165c32b684272aaaaa6c9f76e03edfc" translate="yes" xml:space="preserve">
          <source>gives</source>
          <target state="translated">gives</target>
        </trans-unit>
        <trans-unit id="c3ecf75f48b94f75475ee717f736fb998151b911" translate="yes" xml:space="preserve">
          <source>gives something like this:</source>
          <target state="translated">이 같은 것을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="409218cefe4a1dd5a80a0b5d42b043bc9a98c1b9" translate="yes" xml:space="preserve">
          <source>gives the output</source>
          <target state="translated">출력을 준다</target>
        </trans-unit>
        <trans-unit id="7e07feb3e46c434251e62237c90a6517b3d91d9e" translate="yes" xml:space="preserve">
          <source>header_filter_by_lua</source>
          <target state="translated">header_filter_by_lua</target>
        </trans-unit>
        <trans-unit id="81fac0ccc0c7828dfc892b52ea0dd8ed179b4da6" translate="yes" xml:space="preserve">
          <source>header_filter_by_lua_block</source>
          <target state="translated">header_filter_by_lua_block</target>
        </trans-unit>
        <trans-unit id="15ed9e486c3b9eabcb27e2dd7b3fc6e92b70d4ae" translate="yes" xml:space="preserve">
          <source>header_filter_by_lua_file</source>
          <target state="translated">header_filter_by_lua_file</target>
        </trans-unit>
        <trans-unit id="26aab9a4c05c655b7bd143cd27e088971c0a43bf" translate="yes" xml:space="preserve">
          <source>if the &lt;code&gt;init&lt;/code&gt; argument is not specified or takes the value &lt;code&gt;nil&lt;/code&gt;, this method will return &lt;code&gt;nil&lt;/code&gt; and the error string &lt;code&gt;&quot;not found&quot;&lt;/code&gt;, or</source>
          <target state="translated">경우 &lt;code&gt;init&lt;/code&gt; 인수가 지정되거나 값 소요되지 &lt;code&gt;nil&lt;/code&gt; ,이 방법은 반환 &lt;code&gt;nil&lt;/code&gt; 와 오류 문자열 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; , 또는</target>
        </trans-unit>
        <trans-unit id="2c9fa2b41cd6c28df93234da0194fd89a6ad811a" translate="yes" xml:space="preserve">
          <source>if the &lt;code&gt;init&lt;/code&gt; argument takes a number value, this method will create a new &lt;code&gt;key&lt;/code&gt; with the value &lt;code&gt;init + value&lt;/code&gt;.</source>
          <target state="translated">경우 생성 &lt;code&gt;init&lt;/code&gt; 인수는 숫자 값을 얻어,이 방법은 새로 생성 할 &lt;code&gt;key&lt;/code&gt; 값으로 &lt;code&gt;init + value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="278b1a2b5330a5ca4c67d0487e65f0a8c5064db5" translate="yes" xml:space="preserve">
          <source>in the response headers.</source>
          <target state="translated">응답 헤더에.</target>
        </trans-unit>
        <trans-unit id="58086838f67374476c0a7d5d55c207529a620fa4" translate="yes" xml:space="preserve">
          <source>incr</source>
          <target state="translated">incr</target>
        </trans-unit>
        <trans-unit id="6a0db96d1395545fa262310ae37fb3832e14e5db" translate="yes" xml:space="preserve">
          <source>init_by_lua</source>
          <target state="translated">init_by_lua</target>
        </trans-unit>
        <trans-unit id="fb13b0577557a1cbe07b2c49359988f3a602594d" translate="yes" xml:space="preserve">
          <source>init_by_lua_block</source>
          <target state="translated">init_by_lua_block</target>
        </trans-unit>
        <trans-unit id="9dd37ccc5a1fea35e7e5e4e0c961dbb23478d211" translate="yes" xml:space="preserve">
          <source>init_by_lua_file</source>
          <target state="translated">init_by_lua_file</target>
        </trans-unit>
        <trans-unit id="837b3c2bed7fcffc089534674ec9518970f09c5f" translate="yes" xml:space="preserve">
          <source>init_worker_by_lua</source>
          <target state="translated">init_worker_by_lua</target>
        </trans-unit>
        <trans-unit id="94e074f487395b897d2afb2f7f7d57cae105e98d" translate="yes" xml:space="preserve">
          <source>init_worker_by_lua_block</source>
          <target state="translated">init_worker_by_lua_block</target>
        </trans-unit>
        <trans-unit id="113a14ee14c90fd18b357946d5e09835efb6c5ef" translate="yes" xml:space="preserve">
          <source>init_worker_by_lua_file</source>
          <target state="translated">init_worker_by_lua_file</target>
        </trans-unit>
        <trans-unit id="c048e60340b89789177bd04461bd7007fca86909" translate="yes" xml:space="preserve">
          <source>instead of the old deprecated form:</source>
          <target state="translated">더 이상 사용되지 않는 이전 양식 대신 :</target>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="1d3128f696a4a89e9a4b4bf9c2a4de16e6b279b3" translate="yes" xml:space="preserve">
          <source>is equivalent to the following Lua code</source>
          <target state="translated">다음 루아 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6426c8c9924073829d0f1a54ce6584b01a93c3f9" translate="yes" xml:space="preserve">
          <source>it calls &lt;a href=&quot;#coroutineyield&quot;&gt;coroutine.yield&lt;/a&gt; to actively give up execution, or</source>
          <target state="translated">실행을 적극적으로 포기하기 위해 &lt;a href=&quot;#coroutineyield&quot;&gt;coroutine.yield&lt;/a&gt; 를 호출 하거나</target>
        </trans-unit>
        <trans-unit id="db8a89fdcc25e0bba98e9f350ae2ac540df8485a" translate="yes" xml:space="preserve">
          <source>it is aborted by a Lua error or an invocation of &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;, or &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri(uri, true)&lt;/a&gt;.</source>
          <target state="translated">Lua 오류 또는 &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; , &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt; , &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; 또는 &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri (uri, true)&lt;/a&gt; 호출로 인해 중단되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0f49fe6edab36a314c646483713449b3c5cd8d2b" translate="yes" xml:space="preserve">
          <source>its parent coroutine is not waiting on it with &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt;.</source>
          <target state="translated">부모 코 루틴은 &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait로&lt;/a&gt; 기다리고 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4c651bc017b651b4d77a8bdaa862b8da7baa0332" translate="yes" xml:space="preserve">
          <source>its parent coroutine is still alive, and</source>
          <target state="translated">부모 코 루틴은 여전히 ​​살아 있고</target>
        </trans-unit>
        <trans-unit id="91b9502eb092996269765f5bfe2a69619ddabfd6" translate="yes" xml:space="preserve">
          <source>llen</source>
          <target state="translated">llen</target>
        </trans-unit>
        <trans-unit id="755845d946e95adb1a5dee8678673c8b2779fa40" translate="yes" xml:space="preserve">
          <source>log_by_lua</source>
          <target state="translated">log_by_lua</target>
        </trans-unit>
        <trans-unit id="d8104080c6c4ff1bfd0e84d8b2e7fe7897e9fff5" translate="yes" xml:space="preserve">
          <source>log_by_lua_block</source>
          <target state="translated">log_by_lua_block</target>
        </trans-unit>
        <trans-unit id="17c8387e058b4f545877625fbf08a566f68f6566" translate="yes" xml:space="preserve">
          <source>log_by_lua_file</source>
          <target state="translated">log_by_lua_file</target>
        </trans-unit>
        <trans-unit id="fe18c7670939044a3501dd836416694756301df1" translate="yes" xml:space="preserve">
          <source>lpop</source>
          <target state="translated">lpop</target>
        </trans-unit>
        <trans-unit id="6fc389b36b7fa594ae026992fad6543dfe453bb9" translate="yes" xml:space="preserve">
          <source>lpush</source>
          <target state="translated">lpush</target>
        </trans-unit>
        <trans-unit id="df2d63a6ac3c6cad20b2c5c2063d315f55b98942" translate="yes" xml:space="preserve">
          <source>lua-cjson</source>
          <target state="translated">lua-cjson</target>
        </trans-unit>
        <trans-unit id="b2eb49a70066ceb4aed256553d88e644c86c2d42" translate="yes" xml:space="preserve">
          <source>lua-resty-dns</source>
          <target state="translated">lua-resty-dns</target>
        </trans-unit>
        <trans-unit id="25daa68c434dba8dfe67782d9ceb42320e356bcc" translate="yes" xml:space="preserve">
          <source>lua-resty-lock</source>
          <target state="translated">lua-resty-lock</target>
        </trans-unit>
        <trans-unit id="7b3d371473c57fc8bb890e08a3b9f0ef7a7056cb" translate="yes" xml:space="preserve">
          <source>lua-resty-logger-socket</source>
          <target state="translated">lua-resty-logger-socket</target>
        </trans-unit>
        <trans-unit id="34ba9a1a3d38ad5507a9eca6441d9421ddc7b47f" translate="yes" xml:space="preserve">
          <source>lua-resty-lrucache</source>
          <target state="translated">lua-resty-lrucache</target>
        </trans-unit>
        <trans-unit id="3de58d0f0c3804da480bf8f178efb8464ed3236b" translate="yes" xml:space="preserve">
          <source>lua-resty-memcached</source>
          <target state="translated">lua-resty-memcached</target>
        </trans-unit>
        <trans-unit id="c0926b78baa5bd1140359523403cc627de756050" translate="yes" xml:space="preserve">
          <source>lua-resty-mysql</source>
          <target state="translated">lua-resty-mysql</target>
        </trans-unit>
        <trans-unit id="fe0b350660e599b7d5b6a175a5ed2d9395b8fcc6" translate="yes" xml:space="preserve">
          <source>lua-resty-redis</source>
          <target state="translated">lua-resty-redis</target>
        </trans-unit>
        <trans-unit id="e66efd3a244d13ee8b90d1896264a1e9c42d1224" translate="yes" xml:space="preserve">
          <source>lua-resty-string</source>
          <target state="translated">lua-resty-string</target>
        </trans-unit>
        <trans-unit id="156d1b88f9b520176eb39ceaab4ec73332b25f21" translate="yes" xml:space="preserve">
          <source>lua-resty-upload</source>
          <target state="translated">lua-resty-upload</target>
        </trans-unit>
        <trans-unit id="6451dd4350eb74b812a64e20da144a91e23672db" translate="yes" xml:space="preserve">
          <source>lua-resty-websocket</source>
          <target state="translated">lua-resty-websocket</target>
        </trans-unit>
        <trans-unit id="cbcfbd35f59c303fed915f822d3f80908ff33613" translate="yes" xml:space="preserve">
          <source>lua_capture_error_log</source>
          <target state="translated">lua_capture_error_log</target>
        </trans-unit>
        <trans-unit id="a7db675383ff4b226097885271bbf6274afb0e31" translate="yes" xml:space="preserve">
          <source>lua_check_client_abort</source>
          <target state="translated">lua_check_client_abort</target>
        </trans-unit>
        <trans-unit id="5b2255db07c6b353e069bf4119d171a59f0e9767" translate="yes" xml:space="preserve">
          <source>lua_code_cache</source>
          <target state="translated">lua_code_cache</target>
        </trans-unit>
        <trans-unit id="d345e9b82d59938089f1beeb5541c91d1d307e69" translate="yes" xml:space="preserve">
          <source>lua_http10_buffering</source>
          <target state="translated">lua_http10_buffering</target>
        </trans-unit>
        <trans-unit id="6ec6b6c5a30d52ba8b95c6cba43ee1eed84e0d43" translate="yes" xml:space="preserve">
          <source>lua_malloc_trim</source>
          <target state="translated">lua_malloc_trim</target>
        </trans-unit>
        <trans-unit id="63f87c5da74f030c7bca72f9bddf0a37cf0e506e" translate="yes" xml:space="preserve">
          <source>lua_max_pending_timers</source>
          <target state="translated">lua_max_pending_timers</target>
        </trans-unit>
        <trans-unit id="78848c39f68c5cf0ae467441e8a1c40335452143" translate="yes" xml:space="preserve">
          <source>lua_max_running_timers</source>
          <target state="translated">lua_max_running_timers</target>
        </trans-unit>
        <trans-unit id="7094ec2d0c59e55dbe92cedbe1cd725082263d6d" translate="yes" xml:space="preserve">
          <source>lua_need_request_body</source>
          <target state="translated">lua_need_request_body</target>
        </trans-unit>
        <trans-unit id="7c21598d8f828171047696cab66f65428c0c4b50" translate="yes" xml:space="preserve">
          <source>lua_package_cpath</source>
          <target state="translated">lua_package_cpath</target>
        </trans-unit>
        <trans-unit id="80b063f6d09b849d1fb47486d5fb6a7a29f35a3d" translate="yes" xml:space="preserve">
          <source>lua_package_path</source>
          <target state="translated">lua_package_path</target>
        </trans-unit>
        <trans-unit id="4af31cc946657bbf89a8f97f986169620e0fc481" translate="yes" xml:space="preserve">
          <source>lua_regex_cache_max_entries</source>
          <target state="translated">lua_regex_cache_max_entries</target>
        </trans-unit>
        <trans-unit id="8c7076f0b29ca163258f612dd26a2c1ce8daa5ef" translate="yes" xml:space="preserve">
          <source>lua_regex_match_limit</source>
          <target state="translated">lua_regex_match_limit</target>
        </trans-unit>
        <trans-unit id="9cc0cec0dbe42686a2d6b06dd8b65c63b08d7a61" translate="yes" xml:space="preserve">
          <source>lua_shared_dict</source>
          <target state="translated">lua_shared_dict</target>
        </trans-unit>
        <trans-unit id="5870a5c96fc19e13711cf2e91e6d234cbc2fffed" translate="yes" xml:space="preserve">
          <source>lua_socket_buffer_size</source>
          <target state="translated">lua_socket_buffer_size</target>
        </trans-unit>
        <trans-unit id="1d05c5330dbcb68ad4e3f62be4296d9acc17cc0b" translate="yes" xml:space="preserve">
          <source>lua_socket_connect_timeout</source>
          <target state="translated">lua_socket_connect_timeout</target>
        </trans-unit>
        <trans-unit id="f16e3f105d15a7386530adec6cb3d0394aea5cdf" translate="yes" xml:space="preserve">
          <source>lua_socket_keepalive_timeout</source>
          <target state="translated">lua_socket_keepalive_timeout</target>
        </trans-unit>
        <trans-unit id="26f7bf278c903d41d26b877fcd37cabc4c577ff8" translate="yes" xml:space="preserve">
          <source>lua_socket_log_errors</source>
          <target state="translated">lua_socket_log_errors</target>
        </trans-unit>
        <trans-unit id="442b8930f9d99f08ffd788e5cb003cf636c0d42a" translate="yes" xml:space="preserve">
          <source>lua_socket_pool_size</source>
          <target state="translated">lua_socket_pool_size</target>
        </trans-unit>
        <trans-unit id="d95abc230450026ebdfc6709889d2d220ac98287" translate="yes" xml:space="preserve">
          <source>lua_socket_read_timeout</source>
          <target state="translated">lua_socket_read_timeout</target>
        </trans-unit>
        <trans-unit id="e533ae4687f7655c204ace367d0ecc447659dea5" translate="yes" xml:space="preserve">
          <source>lua_socket_send_lowat</source>
          <target state="translated">lua_socket_send_lowat</target>
        </trans-unit>
        <trans-unit id="683f5c1b51b89d9a66668c0f2fc623158b2cbc35" translate="yes" xml:space="preserve">
          <source>lua_socket_send_timeout</source>
          <target state="translated">lua_socket_send_timeout</target>
        </trans-unit>
        <trans-unit id="53932108b62668ff5f90c8ef023d15470fd02303" translate="yes" xml:space="preserve">
          <source>lua_ssl_ciphers</source>
          <target state="translated">lua_ssl_ciphers</target>
        </trans-unit>
        <trans-unit id="b3b0fd6cbb23a0afe9e46cd218d0d154e2b68e7f" translate="yes" xml:space="preserve">
          <source>lua_ssl_crl</source>
          <target state="translated">lua_ssl_crl</target>
        </trans-unit>
        <trans-unit id="77b8329ff39ecd69b2cf3af5b70d9f24614658c7" translate="yes" xml:space="preserve">
          <source>lua_ssl_protocols</source>
          <target state="translated">lua_ssl_protocols</target>
        </trans-unit>
        <trans-unit id="4fa5d9a30792aed6eb6fa61c38eac1e383319e08" translate="yes" xml:space="preserve">
          <source>lua_ssl_trusted_certificate</source>
          <target state="translated">lua_ssl_trusted_certificate</target>
        </trans-unit>
        <trans-unit id="ed8bd6ce577c505c2b5a9d3d2dcf0eb99a7f46ac" translate="yes" xml:space="preserve">
          <source>lua_ssl_verify_depth</source>
          <target state="translated">lua_ssl_verify_depth</target>
        </trans-unit>
        <trans-unit id="ab563c973be1097c4c8aaabbaa7bbb159e4685ea" translate="yes" xml:space="preserve">
          <source>lua_transform_underscores_in_response_headers</source>
          <target state="translated">lua_transform_underscores_in_response_headers</target>
        </trans-unit>
        <trans-unit id="a302ed9d3a3d6a379ad3454c7595b30490d44559" translate="yes" xml:space="preserve">
          <source>lua_use_default_type</source>
          <target state="translated">lua_use_default_type</target>
        </trans-unit>
        <trans-unit id="be8ef63adc4c8a5324aeae0b15184cdc3497ee33" translate="yes" xml:space="preserve">
          <source>manipulating response headers in an arbitrary way (by Lua)</source>
          <target state="translated">임의의 방식으로 응답 헤더 조작 (Lua 작성)</target>
        </trans-unit>
        <trans-unit id="619e4491825d9231fbf6a582490ef554222a0dd0" translate="yes" xml:space="preserve">
          <source>memc-nginx-module</source>
          <target state="translated">memc-nginx-module</target>
        </trans-unit>
        <trans-unit id="7a17fc5dfbd8a089df5162c593183dd0b067fad9" translate="yes" xml:space="preserve">
          <source>memcached: listening on the default port, 11211.</source>
          <target state="translated">memcached : 기본 포트 인 11211에서 수신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e27ab685455c16e1236dc16f3c77ca1d8ce8174a" translate="yes" xml:space="preserve">
          <source>mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'</source>
          <target state="translated">MySQL : 데이터베이스 'ngx_test'를 생성하고 사용자 'ngx_test'에게 모든 권한을 부여하십시오. 암호는 'ngx_test'입니다</target>
        </trans-unit>
        <trans-unit id="beba7d93d3ebe73741e427d8487bce9971eb9545" translate="yes" xml:space="preserve">
          <source>ndk.set_var.DIRECTIVE</source>
          <target state="translated">ndk.set_var.DIRECTIVE</target>
        </trans-unit>
        <trans-unit id="4f60f0f28275cd6504e554edc3c213a84d412ea2" translate="yes" xml:space="preserve">
          <source>nginx / Lua Module</source>
          <target state="translated">nginx / 루아 모듈</target>
        </trans-unit>
        <trans-unit id="1668ffbfdfba06fbb816f555991fa5e4f1265f41" translate="yes" xml:space="preserve">
          <source>ngx.arg</source>
          <target state="translated">ngx.arg</target>
        </trans-unit>
        <trans-unit id="cd6baf9720db99851bcbc16c19686bd4481e719f" translate="yes" xml:space="preserve">
          <source>ngx.balancer</source>
          <target state="translated">ngx.balancer</target>
        </trans-unit>
        <trans-unit id="f0d4cf920df59587d5a0bf5b5c9c07891ff13117" translate="yes" xml:space="preserve">
          <source>ngx.config.debug</source>
          <target state="translated">ngx.config.debug</target>
        </trans-unit>
        <trans-unit id="02b3d16c79bfd793440a9d19b345fbd604a554e0" translate="yes" xml:space="preserve">
          <source>ngx.config.nginx_configure</source>
          <target state="translated">ngx.config.nginx_configure</target>
        </trans-unit>
        <trans-unit id="a0d927929cca671fdf271699bf947d8531dfc779" translate="yes" xml:space="preserve">
          <source>ngx.config.nginx_version</source>
          <target state="translated">ngx.config.nginx_version</target>
        </trans-unit>
        <trans-unit id="86a8d5d122d199d8eb74d79126e0e82a02beff8b" translate="yes" xml:space="preserve">
          <source>ngx.config.ngx_lua_version</source>
          <target state="translated">ngx.config.ngx_lua_version</target>
        </trans-unit>
        <trans-unit id="7c825b89f228e0b7f646e5e06baf260770a1deb7" translate="yes" xml:space="preserve">
          <source>ngx.config.prefix</source>
          <target state="translated">ngx.config.prefix</target>
        </trans-unit>
        <trans-unit id="3120aed47199a5a2dd2521a93b6fc6c078fcf23d" translate="yes" xml:space="preserve">
          <source>ngx.config.subsystem</source>
          <target state="translated">ngx.config.subsystem</target>
        </trans-unit>
        <trans-unit id="2c5ac3e38f83e230734f562d51ff106e7390081b" translate="yes" xml:space="preserve">
          <source>ngx.cookie_time</source>
          <target state="translated">ngx.cookie_time</target>
        </trans-unit>
        <trans-unit id="0857175cb88466f5030dea6557aade3dcc5fdd87" translate="yes" xml:space="preserve">
          <source>ngx.crc32_long</source>
          <target state="translated">ngx.crc32_long</target>
        </trans-unit>
        <trans-unit id="9d127c3195921de2fb885cd7d323357e66e282fa" translate="yes" xml:space="preserve">
          <source>ngx.crc32_short</source>
          <target state="translated">ngx.crc32_short</target>
        </trans-unit>
        <trans-unit id="c6e214a0a7eca73b6d874c5a21b58560fe075e6e" translate="yes" xml:space="preserve">
          <source>ngx.ctx</source>
          <target state="translated">ngx.ctx</target>
        </trans-unit>
        <trans-unit id="106d9dc0d02c1311c85f5e4e4ded49c7fc624074" translate="yes" xml:space="preserve">
          <source>ngx.decode_args</source>
          <target state="translated">ngx.decode_args</target>
        </trans-unit>
        <trans-unit id="8f9c77cb5dace369afc08f2e7fbbd530f1792e12" translate="yes" xml:space="preserve">
          <source>ngx.decode_base64</source>
          <target state="translated">ngx.decode_base64</target>
        </trans-unit>
        <trans-unit id="70737df004e7dd0e6894fc9908158e92f082a1f9" translate="yes" xml:space="preserve">
          <source>ngx.encode_args</source>
          <target state="translated">ngx.encode_args</target>
        </trans-unit>
        <trans-unit id="1eee48fc5ad83f9abd7b18bc68ea192b6e069d7d" translate="yes" xml:space="preserve">
          <source>ngx.encode_base64</source>
          <target state="translated">ngx.encode_base64</target>
        </trans-unit>
        <trans-unit id="1234159cd8d7c370194d0de23a0e7711becf82b8" translate="yes" xml:space="preserve">
          <source>ngx.eof</source>
          <target state="translated">ngx.eof</target>
        </trans-unit>
        <trans-unit id="8e6f67f92ae1abbb6dff82524a1cd237b7c97a3a" translate="yes" xml:space="preserve">
          <source>ngx.escape_uri</source>
          <target state="translated">ngx.escape_uri</target>
        </trans-unit>
        <trans-unit id="87af05cfe31608e406c262de4e71e6310cc4a91c" translate="yes" xml:space="preserve">
          <source>ngx.exec</source>
          <target state="translated">ngx.exec</target>
        </trans-unit>
        <trans-unit id="ce91c1696a2c9908d62853ee7fe8b9876cf9b709" translate="yes" xml:space="preserve">
          <source>ngx.exit</source>
          <target state="translated">ngx.exit</target>
        </trans-unit>
        <trans-unit id="fe76caf9dab251e057d4077bdf702c8b7852a156" translate="yes" xml:space="preserve">
          <source>ngx.flush</source>
          <target state="translated">ngx.flush</target>
        </trans-unit>
        <trans-unit id="d5af4a87cff50b029e81639fb01575645c95c2d4" translate="yes" xml:space="preserve">
          <source>ngx.get_phase</source>
          <target state="translated">ngx.get_phase</target>
        </trans-unit>
        <trans-unit id="58c1434b5b61ad56cccd5dacb0e58afdd8c61360" translate="yes" xml:space="preserve">
          <source>ngx.header.HEADER</source>
          <target state="translated">ngx.header.HEADER</target>
        </trans-unit>
        <trans-unit id="d9e6b54fb58036cdf470f78cc83f13b547d36a89" translate="yes" xml:space="preserve">
          <source>ngx.headers_sent</source>
          <target state="translated">ngx.headers_sent</target>
        </trans-unit>
        <trans-unit id="456b6b8e1e0f91c1c27af06402b70da666f06a57" translate="yes" xml:space="preserve">
          <source>ngx.hmac_sha1</source>
          <target state="translated">ngx.hmac_sha1</target>
        </trans-unit>
        <trans-unit id="a5cdb271678e5b949c359472ba55e4dffd614a15" translate="yes" xml:space="preserve">
          <source>ngx.http_time</source>
          <target state="translated">ngx.http_time</target>
        </trans-unit>
        <trans-unit id="253b73d1c92431242eeb9de0d17ada3697760cc5" translate="yes" xml:space="preserve">
          <source>ngx.is_subrequest</source>
          <target state="translated">ngx.is_subrequest</target>
        </trans-unit>
        <trans-unit id="914f7fe2bfac8b64b89d368ea0a13ab329357c18" translate="yes" xml:space="preserve">
          <source>ngx.localtime</source>
          <target state="translated">ngx.localtime</target>
        </trans-unit>
        <trans-unit id="c91d8074157daa8821d013c81c744409c972cb03" translate="yes" xml:space="preserve">
          <source>ngx.location.capture</source>
          <target state="translated">ngx.location.capture</target>
        </trans-unit>
        <trans-unit id="ce658cd3ebfbe12caa16a434e7b41d2321827c19" translate="yes" xml:space="preserve">
          <source>ngx.location.capture_multi</source>
          <target state="translated">ngx.location.capture_multi</target>
        </trans-unit>
        <trans-unit id="0482e8c0d7cd71359f538475d93333f39f85f6e0" translate="yes" xml:space="preserve">
          <source>ngx.log</source>
          <target state="translated">ngx.log</target>
        </trans-unit>
        <trans-unit id="d00405662cd20d321c21a5bcda53557b966d61b6" translate="yes" xml:space="preserve">
          <source>ngx.md5</source>
          <target state="translated">ngx.md5</target>
        </trans-unit>
        <trans-unit id="2c67517fb5892fc1b78c52c2595a9fe07fde02c3" translate="yes" xml:space="preserve">
          <source>ngx.md5_bin</source>
          <target state="translated">ngx.md5_bin</target>
        </trans-unit>
        <trans-unit id="7d042055ef6abf2cb5dd304cc87a2b7caecae154" translate="yes" xml:space="preserve">
          <source>ngx.now</source>
          <target state="translated">ngx.now</target>
        </trans-unit>
        <trans-unit id="9c6c099acd2b05b1b668cd51dc9b04acd3f07723" translate="yes" xml:space="preserve">
          <source>ngx.ocsp</source>
          <target state="translated">ngx.ocsp</target>
        </trans-unit>
        <trans-unit id="53ba0e49eebaa5c273684a0b27ed61fd09605ee8" translate="yes" xml:space="preserve">
          <source>ngx.on_abort</source>
          <target state="translated">ngx.on_abort</target>
        </trans-unit>
        <trans-unit id="7d18e0ef5598726d3b2d21e5c8e823c4d02b7550" translate="yes" xml:space="preserve">
          <source>ngx.parse_http_time</source>
          <target state="translated">ngx.parse_http_time</target>
        </trans-unit>
        <trans-unit id="29e9331ddbd37de2afa09e4dcdd143149b1bac94" translate="yes" xml:space="preserve">
          <source>ngx.print</source>
          <target state="translated">ngx.print</target>
        </trans-unit>
        <trans-unit id="554aa169c1082bfaf8d01c46f326950fb3e0879f" translate="yes" xml:space="preserve">
          <source>ngx.quote_sql_str</source>
          <target state="translated">ngx.quote_sql_str</target>
        </trans-unit>
        <trans-unit id="630aec6dface694dc2c52950fce906eec448e785" translate="yes" xml:space="preserve">
          <source>ngx.re.find</source>
          <target state="translated">ngx.re.find</target>
        </trans-unit>
        <trans-unit id="3d159dd3d9bc416cd20b4f3829365fae33f976dd" translate="yes" xml:space="preserve">
          <source>ngx.re.gmatch</source>
          <target state="translated">ngx.re.gmatch</target>
        </trans-unit>
        <trans-unit id="f7d69f3d1134a00509649da21df12e2d70cc7511" translate="yes" xml:space="preserve">
          <source>ngx.re.gsub</source>
          <target state="translated">ngx.re.gsub</target>
        </trans-unit>
        <trans-unit id="f20f8474ae604f283bcfe429a6175c9635335526" translate="yes" xml:space="preserve">
          <source>ngx.re.match</source>
          <target state="translated">ngx.re.match</target>
        </trans-unit>
        <trans-unit id="d2df999f4844570a38505e4f5679245d923ef74d" translate="yes" xml:space="preserve">
          <source>ngx.re.sub</source>
          <target state="translated">ngx.re.sub</target>
        </trans-unit>
        <trans-unit id="219d505a9d44895ea6f6b9e5c17343ee63065e1d" translate="yes" xml:space="preserve">
          <source>ngx.redirect</source>
          <target state="translated">ngx.redirect</target>
        </trans-unit>
        <trans-unit id="86a25724a37cba5c44901a32b76a11a33d611d1b" translate="yes" xml:space="preserve">
          <source>ngx.req.append_body</source>
          <target state="translated">ngx.req.append_body</target>
        </trans-unit>
        <trans-unit id="e382e9136184417f530071da8d81d1b49c0f3aea" translate="yes" xml:space="preserve">
          <source>ngx.req.clear_header</source>
          <target state="translated">ngx.req.clear_header</target>
        </trans-unit>
        <trans-unit id="c5163c273178958088f509b7a2dfd16cc4c94dae" translate="yes" xml:space="preserve">
          <source>ngx.req.discard_body</source>
          <target state="translated">ngx.req.discard_body</target>
        </trans-unit>
        <trans-unit id="0613be13e110e9811d87534635fd04830d3639e4" translate="yes" xml:space="preserve">
          <source>ngx.req.finish_body</source>
          <target state="translated">ngx.req.finish_body</target>
        </trans-unit>
        <trans-unit id="1d197aa13fa978589f4a9be0ca51aeb4798f76ba" translate="yes" xml:space="preserve">
          <source>ngx.req.get_body_data</source>
          <target state="translated">ngx.req.get_body_data</target>
        </trans-unit>
        <trans-unit id="a37dc5213fda4e78c87a407b48290f68ee93e02b" translate="yes" xml:space="preserve">
          <source>ngx.req.get_body_file</source>
          <target state="translated">ngx.req.get_body_file</target>
        </trans-unit>
        <trans-unit id="45a5f8c85683d56fa7efbaf482e9b0e9f144ae85" translate="yes" xml:space="preserve">
          <source>ngx.req.get_headers</source>
          <target state="translated">ngx.req.get_headers</target>
        </trans-unit>
        <trans-unit id="8f5f752cd2e9bdc8b107c17598b368b91b8e9724" translate="yes" xml:space="preserve">
          <source>ngx.req.get_method</source>
          <target state="translated">ngx.req.get_method</target>
        </trans-unit>
        <trans-unit id="aa81a696a371b6738a61fc7f12fe75d913288707" translate="yes" xml:space="preserve">
          <source>ngx.req.get_post_args</source>
          <target state="translated">ngx.req.get_post_args</target>
        </trans-unit>
        <trans-unit id="c8ab507cd34565806f58d0ba6b254dc7fe092d52" translate="yes" xml:space="preserve">
          <source>ngx.req.get_uri_args</source>
          <target state="translated">ngx.req.get_uri_args</target>
        </trans-unit>
        <trans-unit id="912dcb3394590e3863f3835f82526e53a1653700" translate="yes" xml:space="preserve">
          <source>ngx.req.http_version</source>
          <target state="translated">ngx.req.http_version</target>
        </trans-unit>
        <trans-unit id="508e034fd324ff7c62e73d676f04e919c4c008e6" translate="yes" xml:space="preserve">
          <source>ngx.req.init_body</source>
          <target state="translated">ngx.req.init_body</target>
        </trans-unit>
        <trans-unit id="166a3c310b8be9706dc5b7bbca06ef758860561c" translate="yes" xml:space="preserve">
          <source>ngx.req.is_internal</source>
          <target state="translated">ngx.req.is_internal</target>
        </trans-unit>
        <trans-unit id="3476ad9ecc3f74dd896100e01a678c545816ceca" translate="yes" xml:space="preserve">
          <source>ngx.req.raw_header</source>
          <target state="translated">ngx.req.raw_header</target>
        </trans-unit>
        <trans-unit id="9d9b4b6929b86202c2c39c5309d56252341849fa" translate="yes" xml:space="preserve">
          <source>ngx.req.read_body</source>
          <target state="translated">ngx.req.read_body</target>
        </trans-unit>
        <trans-unit id="8dd924797c72efa18beddc5f35c76dcb01b2ad45" translate="yes" xml:space="preserve">
          <source>ngx.req.set_body_data</source>
          <target state="translated">ngx.req.set_body_data</target>
        </trans-unit>
        <trans-unit id="66a452698ff23cf22686045918457a0eee886a80" translate="yes" xml:space="preserve">
          <source>ngx.req.set_body_file</source>
          <target state="translated">ngx.req.set_body_file</target>
        </trans-unit>
        <trans-unit id="dafe903114a0bb4d82adb1b2f47fc855aa3e2da8" translate="yes" xml:space="preserve">
          <source>ngx.req.set_header</source>
          <target state="translated">ngx.req.set_header</target>
        </trans-unit>
        <trans-unit id="18b5000171df483a4f7f357004d1d19c94613c83" translate="yes" xml:space="preserve">
          <source>ngx.req.set_method</source>
          <target state="translated">ngx.req.set_method</target>
        </trans-unit>
        <trans-unit id="76838e7548e0f46c2231e630fc8dde6910a01d9d" translate="yes" xml:space="preserve">
          <source>ngx.req.set_uri</source>
          <target state="translated">ngx.req.set_uri</target>
        </trans-unit>
        <trans-unit id="1c6dc598e016783ebb9cbaaf9224a8614c5866a3" translate="yes" xml:space="preserve">
          <source>ngx.req.set_uri_args</source>
          <target state="translated">ngx.req.set_uri_args</target>
        </trans-unit>
        <trans-unit id="36f3a0862b7f3fb6b6c957e3b5dafea98e9d683b" translate="yes" xml:space="preserve">
          <source>ngx.req.socket</source>
          <target state="translated">ngx.req.socket</target>
        </trans-unit>
        <trans-unit id="ba30ba4cfe1612c56a35051e9cf2b4a004ae1865" translate="yes" xml:space="preserve">
          <source>ngx.req.start_time</source>
          <target state="translated">ngx.req.start_time</target>
        </trans-unit>
        <trans-unit id="ab3383774986041cbbbc81ac52c4056f262f8c7b" translate="yes" xml:space="preserve">
          <source>ngx.resp.get_headers</source>
          <target state="translated">ngx.resp.get_headers</target>
        </trans-unit>
        <trans-unit id="24a9d7f2971ea19ecc1eab599da17c51a6ee5ece" translate="yes" xml:space="preserve">
          <source>ngx.say</source>
          <target state="translated">ngx.say</target>
        </trans-unit>
        <trans-unit id="a2caf6e24d6b2c11eacf43646afe0f9a12c66751" translate="yes" xml:space="preserve">
          <source>ngx.semaphore</source>
          <target state="translated">ngx.semaphore</target>
        </trans-unit>
        <trans-unit id="1e8383f551c458641cdf1a52361bbef979498c96" translate="yes" xml:space="preserve">
          <source>ngx.send_headers</source>
          <target state="translated">ngx.send_headers</target>
        </trans-unit>
        <trans-unit id="b7bc738ad7d7587129d357c3cdc6f8e1ff281813" translate="yes" xml:space="preserve">
          <source>ngx.sha1_bin</source>
          <target state="translated">ngx.sha1_bin</target>
        </trans-unit>
        <trans-unit id="7b5a5dc5c2f8a668961859de28e91493d3299447" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT</source>
          <target state="translated">ngx.shared.DICT</target>
        </trans-unit>
        <trans-unit id="a56213ebf2f834521cabd13c0103d43d6fd69884" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.add</source>
          <target state="translated">ngx.shared.DICT.add</target>
        </trans-unit>
        <trans-unit id="4d5b8646470e2de69236d47b7e384bf3d8313b32" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.capacity</source>
          <target state="translated">ngx.shared.DICT.capacity</target>
        </trans-unit>
        <trans-unit id="db0c3082ecf061a77bca5bfa336ea5cc84a3ee9b" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.delete</source>
          <target state="translated">ngx.shared.DICT.delete</target>
        </trans-unit>
        <trans-unit id="73f83990e2929cc0cf3be024bcb6cc5419cb5946" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.expire</source>
          <target state="translated">ngx.shared.DICT.expire</target>
        </trans-unit>
        <trans-unit id="5c074031fe075a07cf5153536845bf2255e0923e" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.flush_all</source>
          <target state="translated">ngx.shared.DICT.flush_all</target>
        </trans-unit>
        <trans-unit id="b655589e7f6b4626b72bb3ce5087080328c0cbca" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.flush_expired</source>
          <target state="translated">ngx.shared.DICT.flush_expired</target>
        </trans-unit>
        <trans-unit id="a2c38603eca9dab111a50aac19ee9f61bfedd575" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.free_space</source>
          <target state="translated">ngx.shared.DICT.free_space</target>
        </trans-unit>
        <trans-unit id="545362f10587dc8d8fd4f11273814b3e950d5b93" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.get</source>
          <target state="translated">ngx.shared.DICT.get</target>
        </trans-unit>
        <trans-unit id="ec41b7db8ead49858b45b33e2d02a4306a86b116" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.get_keys</source>
          <target state="translated">ngx.shared.DICT.get_keys</target>
        </trans-unit>
        <trans-unit id="9804b5634e3dc7aa51ffaf30f6603301e1c56569" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.get_stale</source>
          <target state="translated">ngx.shared.DICT.get_stale</target>
        </trans-unit>
        <trans-unit id="232741af7d17ce9ccd8416951c9879435db59071" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.incr</source>
          <target state="translated">ngx.shared.DICT.incr</target>
        </trans-unit>
        <trans-unit id="588ae067d3e14102d340579edf3a24af9a1b33b4" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.llen</source>
          <target state="translated">ngx.shared.DICT.llen</target>
        </trans-unit>
        <trans-unit id="c005e013e6aeabe483714f3cfb5c00691f6dfa6b" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.lpop</source>
          <target state="translated">ngx.shared.DICT.lpop</target>
        </trans-unit>
        <trans-unit id="4a59e370692132c85a7ff465c0c1a5e1da22d0b8" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.lpush</source>
          <target state="translated">ngx.shared.DICT.lpush</target>
        </trans-unit>
        <trans-unit id="7e6b7fed98f59a311fce2db85fb64337ab4d9e95" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.replace</source>
          <target state="translated">ngx.shared.DICT.replace</target>
        </trans-unit>
        <trans-unit id="76acea97025dc0812d9efba57588f814351d3174" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.rpop</source>
          <target state="translated">ngx.shared.DICT.rpop</target>
        </trans-unit>
        <trans-unit id="44f8cbfc4d75c6e74e3f53eeb7db4f150ff63506" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.rpush</source>
          <target state="translated">ngx.shared.DICT.rpush</target>
        </trans-unit>
        <trans-unit id="76d63f701199ddf3d6c85f7a449c8e6fac44056a" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.safe_add</source>
          <target state="translated">ngx.shared.DICT.safe_add</target>
        </trans-unit>
        <trans-unit id="7b0391e6b5519b46af295a2b3a8c591fe8130803" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.safe_set</source>
          <target state="translated">ngx.shared.DICT.safe_set</target>
        </trans-unit>
        <trans-unit id="d0650b4010a32afe173bf86b5368bcbcf8166df8" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.set</source>
          <target state="translated">ngx.shared.DICT.set</target>
        </trans-unit>
        <trans-unit id="afefbc0e3bcb2a042f029c24b0027b4bb2c19be7" translate="yes" xml:space="preserve">
          <source>ngx.shared.DICT.ttl</source>
          <target state="translated">ngx.shared.DICT.ttl</target>
        </trans-unit>
        <trans-unit id="33bf65fcfc51920f85ac4c30e752e6b2ef014c20" translate="yes" xml:space="preserve">
          <source>ngx.sleep</source>
          <target state="translated">ngx.sleep</target>
        </trans-unit>
        <trans-unit id="9b31d5d4d87fdbd2aee5a7cf49418c459fc77b0b" translate="yes" xml:space="preserve">
          <source>ngx.socket.connect</source>
          <target state="translated">ngx.socket.connect</target>
        </trans-unit>
        <trans-unit id="cc229e04e97ddc8ccfc2d4717f7b2db172b0c531" translate="yes" xml:space="preserve">
          <source>ngx.socket.stream</source>
          <target state="translated">ngx.socket.stream</target>
        </trans-unit>
        <trans-unit id="8717be9f85aaa838763342c5d9b641af259c0c47" translate="yes" xml:space="preserve">
          <source>ngx.socket.tcp</source>
          <target state="translated">ngx.socket.tcp</target>
        </trans-unit>
        <trans-unit id="af96994306432259d63d411e8ec98f373f15e7cf" translate="yes" xml:space="preserve">
          <source>ngx.socket.udp</source>
          <target state="translated">ngx.socket.udp</target>
        </trans-unit>
        <trans-unit id="b91eea6ec565f2f81785fcabfa5e66539fd4d039" translate="yes" xml:space="preserve">
          <source>ngx.ssl</source>
          <target state="translated">ngx.ssl</target>
        </trans-unit>
        <trans-unit id="7f64d79d871a1f0e7f2dad7281931df252e26270" translate="yes" xml:space="preserve">
          <source>ngx.status</source>
          <target state="translated">ngx.status</target>
        </trans-unit>
        <trans-unit id="1cd6e8d7bb47f32691bf2e88579adbf13d625b76" translate="yes" xml:space="preserve">
          <source>ngx.thread.kill</source>
          <target state="translated">ngx.thread.kill</target>
        </trans-unit>
        <trans-unit id="674d2e7287247a84852631616f9548bfde82557b" translate="yes" xml:space="preserve">
          <source>ngx.thread.spawn</source>
          <target state="translated">ngx.thread.spawn</target>
        </trans-unit>
        <trans-unit id="8802227e3a7a22323e56e19e9c1927b331b021a3" translate="yes" xml:space="preserve">
          <source>ngx.thread.wait</source>
          <target state="translated">ngx.thread.wait</target>
        </trans-unit>
        <trans-unit id="eab1423490f068094a015f07c22e19fc5db84519" translate="yes" xml:space="preserve">
          <source>ngx.time</source>
          <target state="translated">ngx.time</target>
        </trans-unit>
        <trans-unit id="1b7352cf5e4b08a3c8d6e5b4d8ed143d8a59af98" translate="yes" xml:space="preserve">
          <source>ngx.timer.at</source>
          <target state="translated">ngx.timer.at</target>
        </trans-unit>
        <trans-unit id="78f8aca5ce28a34663c685996763b09790da834f" translate="yes" xml:space="preserve">
          <source>ngx.timer.every</source>
          <target state="translated">ngx.timer.every</target>
        </trans-unit>
        <trans-unit id="5ba34e3fd4decb8a1bd9954d98396073f04f79e8" translate="yes" xml:space="preserve">
          <source>ngx.timer.pending_count</source>
          <target state="translated">ngx.timer.pending_count</target>
        </trans-unit>
        <trans-unit id="2db6522a85a08d44e9d2f7b15706791e50e9a8b4" translate="yes" xml:space="preserve">
          <source>ngx.timer.running_count</source>
          <target state="translated">ngx.timer.running_count</target>
        </trans-unit>
        <trans-unit id="901ef3c3ebfddcc2e395b0acf06d2d2930a1b877" translate="yes" xml:space="preserve">
          <source>ngx.today</source>
          <target state="translated">ngx.today</target>
        </trans-unit>
        <trans-unit id="bd745f75f1516730c965d8379cdf3777707315de" translate="yes" xml:space="preserve">
          <source>ngx.unescape_uri</source>
          <target state="translated">ngx.unescape_uri</target>
        </trans-unit>
        <trans-unit id="daa55ffabf48fc2864ac7ba9629babac0d113008" translate="yes" xml:space="preserve">
          <source>ngx.update_time</source>
          <target state="translated">ngx.update_time</target>
        </trans-unit>
        <trans-unit id="1d0bba1cf60fe70cf52cede40ef25aaddaf99a3c" translate="yes" xml:space="preserve">
          <source>ngx.utctime</source>
          <target state="translated">ngx.utctime</target>
        </trans-unit>
        <trans-unit id="426734ed62ec4e434281a665323d18d22b9921ed" translate="yes" xml:space="preserve">
          <source>ngx.var.VARIABLE</source>
          <target state="translated">ngx.var.VARIABLE</target>
        </trans-unit>
        <trans-unit id="cc074be043ae86c60c2115c7f542179320520cbe" translate="yes" xml:space="preserve">
          <source>ngx.worker.count</source>
          <target state="translated">ngx.worker.count</target>
        </trans-unit>
        <trans-unit id="7b6d8a14f6ffa7fc6df9091d975cb77efcad4af2" translate="yes" xml:space="preserve">
          <source>ngx.worker.exiting</source>
          <target state="translated">ngx.worker.exiting</target>
        </trans-unit>
        <trans-unit id="9a6d2e596bc67c6d4206d306c6a06fca94173087" translate="yes" xml:space="preserve">
          <source>ngx.worker.id</source>
          <target state="translated">ngx.worker.id</target>
        </trans-unit>
        <trans-unit id="aa8b1b722eb8dd768c5f56ba809bd48c51ea3f7f" translate="yes" xml:space="preserve">
          <source>ngx.worker.pid</source>
          <target state="translated">ngx.worker.pid</target>
        </trans-unit>
        <trans-unit id="ddb114fd0d4f83c1a44b2bba27370f70325154af" translate="yes" xml:space="preserve">
          <source>ngx_coolkit</source>
          <target state="translated">ngx_coolkit</target>
        </trans-unit>
        <trans-unit id="0f5f22d4c16ee13a0be2a39f05c3b76fb7db1ad1" translate="yes" xml:space="preserve">
          <source>ngx_devel_kit</source>
          <target state="translated">ngx_devel_kit</target>
        </trans-unit>
        <trans-unit id="0909e10267135d50782af4bd0a1092d22c9307b4" translate="yes" xml:space="preserve">
          <source>ngx_drizzle</source>
          <target state="translated">ngx_drizzle</target>
        </trans-unit>
        <trans-unit id="0b0a90c8a256e4ba4da85f7506b18951b31c78d9" translate="yes" xml:space="preserve">
          <source>ngx_echo</source>
          <target state="translated">ngx_echo</target>
        </trans-unit>
        <trans-unit id="6c8456c375b91b372fccfc09853fc425aeb86f68" translate="yes" xml:space="preserve">
          <source>ngx_fastcgi</source>
          <target state="translated">ngx_fastcgi</target>
        </trans-unit>
        <trans-unit id="d1b1d8934a4427bfb25475a9504bf5d7d3856d10" translate="yes" xml:space="preserve">
          <source>ngx_headers_more</source>
          <target state="translated">ngx_headers_more</target>
        </trans-unit>
        <trans-unit id="1e3da698a0af3332a7510735da4e91457ad44ef8" translate="yes" xml:space="preserve">
          <source>ngx_http_lua_module</source>
          <target state="translated">ngx_http_lua_module</target>
        </trans-unit>
        <trans-unit id="580bc8a7dc3a4c961511b34bca9b7ae0667e81f6" translate="yes" xml:space="preserve">
          <source>ngx_http_lua_module - Embed the power of Lua into Nginx HTTP Servers.</source>
          <target state="translated">ngx_http_lua_module-Nginx HTTP 서버에 Lua의 강력한 기능을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="e407165470920fde72ec861517839fc452a2bc28" translate="yes" xml:space="preserve">
          <source>ngx_lua (i.e., this module)</source>
          <target state="translated">ngx_lua (즉,이 모듈)</target>
        </trans-unit>
        <trans-unit id="9b52732c84ac0b80fb2c8c21b2743da725e18e93" translate="yes" xml:space="preserve">
          <source>ngx_lua_upstream</source>
          <target state="translated">ngx_lua_upstream</target>
        </trans-unit>
        <trans-unit id="02926098407ce1089fa05c715f14b1db1e96d40f" translate="yes" xml:space="preserve">
          <source>ngx_memc</source>
          <target state="translated">ngx_memc</target>
        </trans-unit>
        <trans-unit id="3b0d3668aef479bea674dae89bcb7cb6fcbdcd73" translate="yes" xml:space="preserve">
          <source>ngx_postgres</source>
          <target state="translated">ngx_postgres</target>
        </trans-unit>
        <trans-unit id="f049e5aaf309f56e40afbbc762f2763a50ee1de3" translate="yes" xml:space="preserve">
          <source>ngx_proxy</source>
          <target state="translated">ngx_proxy</target>
        </trans-unit>
        <trans-unit id="35a95f9fb01efe081c5a74a98bdd33a258e290d8" translate="yes" xml:space="preserve">
          <source>ngx_rds_json</source>
          <target state="translated">ngx_rds_json</target>
        </trans-unit>
        <trans-unit id="eb6c8826620913275aa437868ec3e1dd0204bf1f" translate="yes" xml:space="preserve">
          <source>ngx_redis</source>
          <target state="translated">ngx_redis</target>
        </trans-unit>
        <trans-unit id="4e148b6fa581fc123b6146a70245518f3eb11062" translate="yes" xml:space="preserve">
          <source>ngx_redis2</source>
          <target state="translated">ngx_redis2</target>
        </trans-unit>
        <trans-unit id="1be02dc2cd59211a3bc91fc859efc44cf7758b70" translate="yes" xml:space="preserve">
          <source>ngx_set_misc</source>
          <target state="translated">ngx_set_misc</target>
        </trans-unit>
        <trans-unit id="d63b164bf3eb45b7fd9ee4cf76153b953b3d51c3" translate="yes" xml:space="preserve">
          <source>ngx_srcache</source>
          <target state="translated">ngx_srcache</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="48f7d267be52d9743f4765f9d186d854e46048ea" translate="yes" xml:space="preserve">
          <source>or a Lua table holding the query arguments' key-value pairs, as in</source>
          <target state="translated">또는 쿼리 인수의 키-값 쌍을 보유한 Lua 테이블</target>
        </trans-unit>
        <trans-unit id="f87f65818ff86eedc3fa544bf44c00b87aca2e88" translate="yes" xml:space="preserve">
          <source>or equivalently,</source>
          <target state="translated">또는 동등하게</target>
        </trans-unit>
        <trans-unit id="4bc6d52fe00612a1ae4419574dc67ba9ac3eea09" translate="yes" xml:space="preserve">
          <source>or posting to the &lt;a href=&quot;#community&quot;&gt;OpenResty community&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;#community&quot;&gt;OpenResty 커뮤니티에&lt;/a&gt; 게시하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9f3e687ef3de57814556c261b626f247bdf64f" translate="yes" xml:space="preserve">
          <source>or the request body has zero size.</source>
          <target state="translated">또는 요청 본문의 크기가 0입니다.</target>
        </trans-unit>
        <trans-unit id="060d4ab793b56f27baf868a8b76aea3cb0584c3e" translate="yes" xml:space="preserve">
          <source>or use Lua's syntactic sugar for method calls:</source>
          <target state="translated">또는 메소드 호출에 Lua의 구문 설탕을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4744dce40223cde6314379671367e50863f19d4" translate="yes" xml:space="preserve">
          <source>outputs something like this:</source>
          <target state="translated">다음과 같이 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="dcf3b4e015ee05a6ab3947da89380794ffa1a86d" translate="yes" xml:space="preserve">
          <source>port this module to the &quot;datagram&quot; subsystem of NGINX for implementing general UDP servers instead of HTTP servers in Lua. For example,</source>
          <target state="translated">Lua의 HTTP 서버 대신 일반 UDP 서버를 구현하기 위해이 모듈을 NGINX의 &quot;데이터 그램&quot;하위 시스템으로 포팅하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="73ff64ae590a199f0f3d33640713105ba66342d1" translate="yes" xml:space="preserve">
          <source>postgres-nginx-module</source>
          <target state="translated">postgres-nginx-module</target>
        </trans-unit>
        <trans-unit id="6d0d5876e6710ebb4f309b5af01090cb97381d06" translate="yes" xml:space="preserve">
          <source>print</source>
          <target state="translated">print</target>
        </trans-unit>
        <trans-unit id="63847b2d6190ca9f5ea3fdc74111a2f029b68d4a" translate="yes" xml:space="preserve">
          <source>rather than the original &lt;code&gt;&quot;hello&quot;&lt;/code&gt; value.</source>
          <target state="translated">원래 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 값이 아니라</target>
        </trans-unit>
        <trans-unit id="f1655af968944cb00df7acf9c88447a72068cddc" translate="yes" xml:space="preserve">
          <source>receive</source>
          <target state="translated">receive</target>
        </trans-unit>
        <trans-unit id="fb649a34b4c68bd6b713088832295ec7ad3b945e" translate="yes" xml:space="preserve">
          <source>receiveuntil</source>
          <target state="translated">receiveuntil</target>
        </trans-unit>
        <trans-unit id="a1c710c2b48500ad8ba110160c34595dcc448e11" translate="yes" xml:space="preserve">
          <source>redis: listening on the default port, 6379.</source>
          <target state="translated">redis : 기본 포트 인 6379에서 수신 중입니다.</target>
        </trans-unit>
        <trans-unit id="6b978fe81f9833dd779ee503bf07b645a0ba7af0" translate="yes" xml:space="preserve">
          <source>regardless of the actual request query string.</source>
          <target state="translated">실제 요청 쿼리 문자열에 관계없이</target>
        </trans-unit>
        <trans-unit id="3cacc7bfac0a382c669a884c953d0401a689785d" translate="yes" xml:space="preserve">
          <source>replace</source>
          <target state="translated">replace</target>
        </trans-unit>
        <trans-unit id="aeb74889ac047171b3fcfb7f68c9b13b916a948e" translate="yes" xml:space="preserve">
          <source>review and apply vadim-pavlov's patch for &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;'s &lt;code&gt;extra_headers&lt;/code&gt; option</source>
          <target state="translated">&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; 의 &lt;code&gt;extra_headers&lt;/code&gt; 옵션에 대한 vadim-pavlov의 패치 검토 및 적용</target>
        </trans-unit>
        <trans-unit id="c07d2e9e5a57a09fa0d424572d02175caa6b514e" translate="yes" xml:space="preserve">
          <source>rewrite_by_lua</source>
          <target state="translated">rewrite_by_lua</target>
        </trans-unit>
        <trans-unit id="de507609041b67141f29d6a492aa3bb8ca175394" translate="yes" xml:space="preserve">
          <source>rewrite_by_lua_block</source>
          <target state="translated">rewrite_by_lua_block</target>
        </trans-unit>
        <trans-unit id="4c6db4199abe01ff538bea64ff1ed42356da2bc6" translate="yes" xml:space="preserve">
          <source>rewrite_by_lua_file</source>
          <target state="translated">rewrite_by_lua_file</target>
        </trans-unit>
        <trans-unit id="f2eb1503f25c553983a986fbc8f61578117c1d8b" translate="yes" xml:space="preserve">
          <source>rewrite_by_lua_no_postpone</source>
          <target state="translated">rewrite_by_lua_no_postpone</target>
        </trans-unit>
        <trans-unit id="2e2150107692512f7a1d8703bd9368d6c9448503" translate="yes" xml:space="preserve">
          <source>rpop</source>
          <target state="translated">rpop</target>
        </trans-unit>
        <trans-unit id="728495c88661a13dbac017f8d0b278ab6c2ef895" translate="yes" xml:space="preserve">
          <source>rpush</source>
          <target state="translated">rpush</target>
        </trans-unit>
        <trans-unit id="2b41061dad77cc27ce1f559fc71faa2a2da1b78d" translate="yes" xml:space="preserve">
          <source>safe_add</source>
          <target state="translated">safe_add</target>
        </trans-unit>
        <trans-unit id="983267a75b0051e6f48e072d7fd1cc3f43e348e8" translate="yes" xml:space="preserve">
          <source>safe_set</source>
          <target state="translated">safe_set</target>
        </trans-unit>
        <trans-unit id="37ed539c0cef13959abd980bebf30f4922f606e3" translate="yes" xml:space="preserve">
          <source>send</source>
          <target state="translated">send</target>
        </trans-unit>
        <trans-unit id="65c10dc3549fe07424148a8a4790a3341ecbc253" translate="yes" xml:space="preserve">
          <source>set</source>
          <target state="translated">set</target>
        </trans-unit>
        <trans-unit id="0fa6bbbda1bcfc8393509eef0be602fa1a8215b1" translate="yes" xml:space="preserve">
          <source>set_by_lua</source>
          <target state="translated">set_by_lua</target>
        </trans-unit>
        <trans-unit id="845a1635041c44d81d9a6ab3ede8a05a8612ce5a" translate="yes" xml:space="preserve">
          <source>set_by_lua_block</source>
          <target state="translated">set_by_lua_block</target>
        </trans-unit>
        <trans-unit id="cdaded440dd96c8598f9deda8da0ae45ace1bc00" translate="yes" xml:space="preserve">
          <source>set_by_lua_file</source>
          <target state="translated">set_by_lua_file</target>
        </trans-unit>
        <trans-unit id="07e170526d18d919978eae425cb8673342c7ebc4" translate="yes" xml:space="preserve">
          <source>set_decode_base32</source>
          <target state="translated">set_decode_base32</target>
        </trans-unit>
        <trans-unit id="0a3ca50d74581c7b1ecbf0be63c0d0291223f156" translate="yes" xml:space="preserve">
          <source>set_decode_base64</source>
          <target state="translated">set_decode_base64</target>
        </trans-unit>
        <trans-unit id="3512e367d4d9ee7105db45f54a9a24f1090ae69c" translate="yes" xml:space="preserve">
          <source>set_decode_hex</source>
          <target state="translated">set_decode_hex</target>
        </trans-unit>
        <trans-unit id="f99ad35e589463a50f73893fee88cbc3e7305288" translate="yes" xml:space="preserve">
          <source>set_decrypt_session</source>
          <target state="translated">set_decrypt_session</target>
        </trans-unit>
        <trans-unit id="f7be445d9232d136d1f1a8f6f1ed45a5d4a36684" translate="yes" xml:space="preserve">
          <source>set_encode_base32</source>
          <target state="translated">set_encode_base32</target>
        </trans-unit>
        <trans-unit id="5f46862808000a0d7f7d7d19183b991f8321f132" translate="yes" xml:space="preserve">
          <source>set_encode_base64</source>
          <target state="translated">set_encode_base64</target>
        </trans-unit>
        <trans-unit id="7c06d3dd05664415b8d500571f4db1251efca2a6" translate="yes" xml:space="preserve">
          <source>set_encode_hex</source>
          <target state="translated">set_encode_hex</target>
        </trans-unit>
        <trans-unit id="1674303370a7e28b5bb66788853c53eb81c8dd9d" translate="yes" xml:space="preserve">
          <source>set_encrypt_session</source>
          <target state="translated">set_encrypt_session</target>
        </trans-unit>
        <trans-unit id="5ac15c777898148d6710110ba69baf985bbb4935" translate="yes" xml:space="preserve">
          <source>set_escape_uri</source>
          <target state="translated">set_escape_uri</target>
        </trans-unit>
        <trans-unit id="5db485756785117d7859d179aa629f6e7e92f325" translate="yes" xml:space="preserve">
          <source>set_md5</source>
          <target state="translated">set_md5</target>
        </trans-unit>
        <trans-unit id="cfde2698f89ba2806a816ef1a07ea7f6401a87e0" translate="yes" xml:space="preserve">
          <source>set_quote_json_str</source>
          <target state="translated">set_quote_json_str</target>
        </trans-unit>
        <trans-unit id="973e7e0c0381f644f16f68482b1a35cd1774c505" translate="yes" xml:space="preserve">
          <source>set_quote_pgsql_str</source>
          <target state="translated">set_quote_pgsql_str</target>
        </trans-unit>
        <trans-unit id="05b1f41a6cfcd5a003d9fc0128913d0b6592a2ec" translate="yes" xml:space="preserve">
          <source>set_quote_sql_str</source>
          <target state="translated">set_quote_sql_str</target>
        </trans-unit>
        <trans-unit id="8f3060fc4741a4402382439546c88cf965d1ca07" translate="yes" xml:space="preserve">
          <source>set_sha1</source>
          <target state="translated">set_sha1</target>
        </trans-unit>
        <trans-unit id="cfcd67708ab82be572523b2f74aa72f1cb53b8e1" translate="yes" xml:space="preserve">
          <source>set_unescape_uri</source>
          <target state="translated">set_unescape_uri</target>
        </trans-unit>
        <trans-unit id="d70fbeeae875517c439178d2e43c8cdd593332c3" translate="yes" xml:space="preserve">
          <source>setkeepalive</source>
          <target state="translated">setkeepalive</target>
        </trans-unit>
        <trans-unit id="727eb69633673afa61898f47afd32bd5df1da49b" translate="yes" xml:space="preserve">
          <source>setoption</source>
          <target state="translated">setoption</target>
        </trans-unit>
        <trans-unit id="35c2c212c792b26cb3e6cf71606cc7b967382e4f" translate="yes" xml:space="preserve">
          <source>setpeername</source>
          <target state="translated">setpeername</target>
        </trans-unit>
        <trans-unit id="c72bedb1e4ee72bceb85c99941aa6068a5ccfc34" translate="yes" xml:space="preserve">
          <source>settimeout</source>
          <target state="translated">settimeout</target>
        </trans-unit>
        <trans-unit id="69cde7f1fd77de0764c3a055c1da3acb036c23dc" translate="yes" xml:space="preserve">
          <source>settimeouts</source>
          <target state="translated">settimeouts</target>
        </trans-unit>
        <trans-unit id="7ec5888b8f9f0b5efe1e27f30e7d8dc363edf97d" translate="yes" xml:space="preserve">
          <source>shm: implement a &quot;shared queue API&quot; to complement the existing &lt;a href=&quot;#lua_shared_dict&quot;&gt;shared dict&lt;/a&gt; API.</source>
          <target state="translated">shm : 기존 &lt;a href=&quot;#lua_shared_dict&quot;&gt;공유 dict&lt;/a&gt; API 를 보완하기 위해 &quot;공유 큐 API&quot;를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="8334436def5a6dbd1777d0344429d6132e68e274" translate="yes" xml:space="preserve">
          <source>some Lua global variable references may include typing errors which make such difficult to debug.</source>
          <target state="translated">일부 Lua 전역 변수 참조에는 디버깅을 어렵게하는 입력 오류가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c173ccd27bc82e41d221496f26899e6608bbc0c6" translate="yes" xml:space="preserve">
          <source>ssl_certificate_by_lua_block</source>
          <target state="translated">ssl_certificate_by_lua_block</target>
        </trans-unit>
        <trans-unit id="72bfe60daf37e69f0090e5526659b6c116307435" translate="yes" xml:space="preserve">
          <source>ssl_certificate_by_lua_file</source>
          <target state="translated">ssl_certificate_by_lua_file</target>
        </trans-unit>
        <trans-unit id="c8cdd0666f5e05d972c50f361cf355a7b9cc60ab" translate="yes" xml:space="preserve">
          <source>ssl_session_fetch_by_lua_block</source>
          <target state="translated">ssl_session_fetch_by_lua_block</target>
        </trans-unit>
        <trans-unit id="bae86602eaa66537c3039b26f709b8b410517e6a" translate="yes" xml:space="preserve">
          <source>ssl_session_fetch_by_lua_file</source>
          <target state="translated">ssl_session_fetch_by_lua_file</target>
        </trans-unit>
        <trans-unit id="ba33c836c6cb512718b9d5eb4ff3e54eb5bb5e1f" translate="yes" xml:space="preserve">
          <source>ssl_session_store_by_lua_block</source>
          <target state="translated">ssl_session_store_by_lua_block</target>
        </trans-unit>
        <trans-unit id="164b3a4478d10480288cfd820eb6d84904719ab2" translate="yes" xml:space="preserve">
          <source>ssl_session_store_by_lua_file</source>
          <target state="translated">ssl_session_store_by_lua_file</target>
        </trans-unit>
        <trans-unit id="33c616c42f0e8916e82c92101b18760918bd7c20" translate="yes" xml:space="preserve">
          <source>sslhandshake</source>
          <target state="translated">sslhandshake</target>
        </trans-unit>
        <trans-unit id="1208a56d3568e10068b11d51110a1e1721d73743" translate="yes" xml:space="preserve">
          <source>tcpsock:close</source>
          <target state="translated">tcpsock:close</target>
        </trans-unit>
        <trans-unit id="d42b6dc77f8e4fa7dfd01efd7ae6340288241759" translate="yes" xml:space="preserve">
          <source>tcpsock:connect</source>
          <target state="translated">tcpsock:connect</target>
        </trans-unit>
        <trans-unit id="e0ac52881eaea20cacbc423a2baf672b92a84d19" translate="yes" xml:space="preserve">
          <source>tcpsock:getreusedtimes</source>
          <target state="translated">tcpsock:getreusedtimes</target>
        </trans-unit>
        <trans-unit id="bd1cd1c94f3b3d85b1928836269f14ea0fdc497e" translate="yes" xml:space="preserve">
          <source>tcpsock:receive</source>
          <target state="translated">tcpsock:receive</target>
        </trans-unit>
        <trans-unit id="4251f48da6173e5d4fa96db041594f46a46e8dc8" translate="yes" xml:space="preserve">
          <source>tcpsock:receiveuntil</source>
          <target state="translated">tcpsock:receiveuntil</target>
        </trans-unit>
        <trans-unit id="34f70a7562efd1029eed5b09ed9eeb8551cb06cc" translate="yes" xml:space="preserve">
          <source>tcpsock:send</source>
          <target state="translated">tcpsock:send</target>
        </trans-unit>
        <trans-unit id="0a6eda40d769cc9414d6e7371dc2fc962b7a62bc" translate="yes" xml:space="preserve">
          <source>tcpsock:setkeepalive</source>
          <target state="translated">tcpsock:setkeepalive</target>
        </trans-unit>
        <trans-unit id="f138f13e6ca75aa5703a9e5444d2826c24b8cb1e" translate="yes" xml:space="preserve">
          <source>tcpsock:setoption</source>
          <target state="translated">tcpsock:setoption</target>
        </trans-unit>
        <trans-unit id="1dd61d53f3291c62fb99e0cc52cf290e19d6c6f1" translate="yes" xml:space="preserve">
          <source>tcpsock:settimeout</source>
          <target state="translated">tcpsock:settimeout</target>
        </trans-unit>
        <trans-unit id="5b23bd0f7277df31d87cd962b673ee7916a9c932" translate="yes" xml:space="preserve">
          <source>tcpsock:settimeouts</source>
          <target state="translated">tcpsock:settimeouts</target>
        </trans-unit>
        <trans-unit id="2d3ac7362f48edd508b955f22b37f56822d9bfd7" translate="yes" xml:space="preserve">
          <source>tcpsock:sslhandshake</source>
          <target state="translated">tcpsock:sslhandshake</target>
        </trans-unit>
        <trans-unit id="056b9d5affb49e5134c8ec57f25ea602e0c2afb0" translate="yes" xml:space="preserve">
          <source>that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the &lt;code&gt;args&lt;/code&gt; argument is identical to the format used in the &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt; method.</source>
          <target state="translated">즉,이 메소드는 URI 규칙에 따라 인수 키와 값을 이스케이프하고이를 완전한 쿼리 문자열로 연결합니다. &lt;code&gt;args&lt;/code&gt; 인수 로 전달 된 Lua 테이블 의 형식은 &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt; 메소드에 사용 된 형식과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="95772023145059d68f8f73c4c5d9b4685a919a25" translate="yes" xml:space="preserve">
          <source>that writes out &lt;code&gt;88&lt;/code&gt;, the sum of &lt;code&gt;32&lt;/code&gt; and &lt;code&gt;56&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;32&lt;/code&gt; 와 &lt;code&gt;56&lt;/code&gt; 의 합인 &lt;code&gt;88&lt;/code&gt; 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e923dba6bcd9de80383a297e41b68996a9573032" translate="yes" xml:space="preserve">
          <source>the &quot;entry thread&quot; terminates with a Lua error.</source>
          <target state="translated">&quot;입력 스레드&quot;는 Lua 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4617d6a0c05a420a91310882f5c743afb8a61a2e" translate="yes" xml:space="preserve">
          <source>the Lua cosocket object value gets collected by the Lua GC.</source>
          <target state="translated">Lua 코 소켓 객체 값은 Lua GC에 의해 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="ab112d55164e4303b9ea27d16f1b657c79a52bc5" translate="yes" xml:space="preserve">
          <source>the current &quot;light thread&quot; already terminates (either successfully or with an error),</source>
          <target state="translated">현재 &quot;가벼운 스레드&quot;가 이미 종료되었습니다 (성공 또는 오류).</target>
        </trans-unit>
        <trans-unit id="2c62afe8a38ceadb9d6493147401bef264c21825" translate="yes" xml:space="preserve">
          <source>the current request handler completes, or</source>
          <target state="translated">현재 요청 핸들러가 완료되거나</target>
        </trans-unit>
        <trans-unit id="2b527babc9c580a95016aa47752366deed00a7e7" translate="yes" xml:space="preserve">
          <source>the misuse of Lua globals has detrimental side effects on concurrent requests when such variables should instead be local in scope,</source>
          <target state="translated">Lua 전역을 잘못 사용하면 해당 변수가 범위 내에서 로컬 인 경우 동시 요청에 유해한 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d53543f253256a06466a5af5cfa7555c12423f50" translate="yes" xml:space="preserve">
          <source>the request body has been read into disk temporary files,</source>
          <target state="translated">요청 본문을 디스크 임시 파일로 읽은 경우</target>
        </trans-unit>
        <trans-unit id="c3f7944aecf56fa75f9c9df123ca67fdb89e4f0b" translate="yes" xml:space="preserve">
          <source>the request body has not been read,</source>
          <target state="translated">요청 본문을 읽지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="7fce008ca6bfca5e71f476046b05bfb0d1d08aad" translate="yes" xml:space="preserve">
          <source>the value of &lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; will be a Lua (array) table such as:</source>
          <target state="translated">&lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; 의 값은 다음 과 같은 Lua (배열) 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="20e0a23421887de144fe1086491322617d63c42f" translate="yes" xml:space="preserve">
          <source>then you can link the &lt;code&gt;myluafiles&lt;/code&gt; archive as a whole to your nginx executable:</source>
          <target state="translated">&lt;code&gt;myluafiles&lt;/code&gt; 아카이브를 전체 nginx 실행 파일에 링크 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="36ac89ed0ae82a67e41510a03f385983eb8e8875" translate="yes" xml:space="preserve">
          <source>then you need to rename the &lt;code&gt;foo.lua&lt;/code&gt; file to &lt;code&gt;resty_foo.lua&lt;/code&gt; before compiling it down to a &lt;code&gt;.o&lt;/code&gt; file with the &lt;code&gt;luajit&lt;/code&gt; command-line utility.</source>
          <target state="translated">&lt;code&gt;luajit&lt;/code&gt; 명령 줄 유틸리티를 사용하여 foo.lua 파일을 &lt;code&gt;.o&lt;/code&gt; 파일 로 컴파일하기 전에 &lt;code&gt;foo.lua&lt;/code&gt; 파일의 이름 을 &lt;code&gt;resty_foo.lua&lt;/code&gt; 로 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="13e0ddf7ffd111405cde5e08e1bcba2c630c88fc" translate="yes" xml:space="preserve">
          <source>this directive does not support extra arguments after the Lua script as in &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; 에서와 같이 Lua 스크립트 다음에 추가 인수를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6fb7e68868e272c28ed43ecff521c4b35b1dbacc" translate="yes" xml:space="preserve">
          <source>this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping), and</source>
          <target state="translated">이 지시문 은 NGINX 문자열 리터럴 (특별 문자 이스케이프 필요) 대신에 중괄호 ( &lt;code&gt;{}&lt;/code&gt; ) 안에 Lua 소스를 직접 인라인합니다.</target>
        </trans-unit>
        <trans-unit id="06b7b07b61cf7a7e28c8c3609fa194546c62fb1d" translate="yes" xml:space="preserve">
          <source>timer will be created every &lt;code&gt;delay&lt;/code&gt; seconds until the current Nginx worker process starts exiting.</source>
          <target state="translated">타이머는 현재 Nginx 작업자 프로세스가 종료 될 때까지 &lt;code&gt;delay&lt;/code&gt; 시간 마다 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="62f36ca861be69bc63ea6751f27c9147ae27c31d" translate="yes" xml:space="preserve">
          <source>to be returned when reading &lt;code&gt;ngx.header.Foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngx.header.Foo&lt;/code&gt; 를 읽을 때 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5263c8ea4d774435db80fc53b9f3671d29abb076" translate="yes" xml:space="preserve">
          <source>to prevent (temporary) memory leaking within the current request's lifetime. Another way of caching the result is to use the &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table.</source>
          <target state="translated">현재 요청 수명 내에서 (임시) 메모리 누수가 방지됩니다. 결과를 캐싱하는 또 다른 방법은 &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; 테이블 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2e33266830e76602baef9cc3b70445f3e0fe8b3f" translate="yes" xml:space="preserve">
          <source>ttl</source>
          <target state="translated">ttl</target>
        </trans-unit>
        <trans-unit id="2842d19ba3e63ed13125fe98d238a025894214fb" translate="yes" xml:space="preserve">
          <source>udpsock:close</source>
          <target state="translated">udpsock:close</target>
        </trans-unit>
        <trans-unit id="3844df08601d10dd8ef1feb8b569bd6aac173a6b" translate="yes" xml:space="preserve">
          <source>udpsock:receive</source>
          <target state="translated">udpsock:receive</target>
        </trans-unit>
        <trans-unit id="eb4b4fdc532c4945d7c0691724500508d337d9b9" translate="yes" xml:space="preserve">
          <source>udpsock:send</source>
          <target state="translated">udpsock:send</target>
        </trans-unit>
        <trans-unit id="c3052e9ccfc7864e9b25494bcf50ceca793c248c" translate="yes" xml:space="preserve">
          <source>udpsock:setpeername</source>
          <target state="translated">udpsock:setpeername</target>
        </trans-unit>
        <trans-unit id="ffddb1ac36fc9c37a05c9834196eb76a2e37020a" translate="yes" xml:space="preserve">
          <source>udpsock:settimeout</source>
          <target state="translated">udpsock:settimeout</target>
        </trans-unit>
        <trans-unit id="b3d9fddb78f7fddd68b172f95efb97208b4b93a0" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;ngx_hash_t&lt;/code&gt; to optimize the built-in header look-up process for &lt;a href=&quot;#ngxreqset_header&quot;&gt;ngx.req.set_header&lt;/a&gt;, &lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt;, and etc.</source>
          <target state="translated">&lt;code&gt;ngx_hash_t&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;#ngxreqset_header&quot;&gt;ngx.req.set_header&lt;/a&gt; , &lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt; 등 의 내장 헤더 조회 프로세스를 최적화하십시오 .</target>
        </trans-unit>
        <trans-unit id="d30079cac07392d8577790a4ec459b27ba1c7b20" translate="yes" xml:space="preserve">
          <source>using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.</source>
          <target state="translated">Lua를 사용하여 Nginx의 하위 요청 및 임의 위치에 대한 고급 캐싱 메커니즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a728d97d235aba8ffad9f33a0b3ac36f12f0ca4a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$0&lt;/code&gt; referring to the whole substring matched by the pattern and &lt;code&gt;$1&lt;/code&gt; referring to the first parenthesized capturing substring.</source>
          <target state="translated">여기서 &lt;code&gt;$0&lt;/code&gt; 은 패턴과 일치하는 전체 하위 문자열을 나타내고 &lt;code&gt;$1&lt;/code&gt; 은 첫 번째 괄호로 묶은 캡처 하위 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d61b1c7fbd22496c04bfb67d0a4af3e61fc48c0f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;/path/to/lib&lt;/code&gt; is the path of the directory containing the &lt;code&gt;libmyluafiles.a&lt;/code&gt; file. It should be noted that the linker option &lt;code&gt;--whole-archive&lt;/code&gt; is required here because otherwise our archive will be skipped because no symbols in our archive are mentioned in the main parts of the nginx executable.</source>
          <target state="translated">여기서 &lt;code&gt;/path/to/lib&lt;/code&gt; 는 &lt;code&gt;libmyluafiles.a&lt;/code&gt; 파일이 들어있는 디렉토리의 경로입니다 . 링커 옵션 &lt;code&gt;--whole-archive&lt;/code&gt; 가 필요합니다. 그렇지 않으면 아카이브의 기호가 nginx 실행 파일의 주요 부분에 언급되어 있지 않기 때문에 아카이브가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f611a88fafc785662f4c8f3f58385eccb255a952" translate="yes" xml:space="preserve">
          <source>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</source>
          <target state="translated">후자의 경우,이 메소드는 URI 이스케이프 규칙에 따라 인수 키와 값을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="d520bd48adb610a364031fae267bc856cba61030" translate="yes" xml:space="preserve">
          <source>whether the current request body is already larger than the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt;,</source>
          <target state="translated">현재 요청 여부 본체는 이미보다 큰 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="09d85d8a372967394d1c4518b624cc670065f209" translate="yes" xml:space="preserve">
          <source>whether the current request body is already larger than the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">어느 것이</target>
        </trans-unit>
        <trans-unit id="7c2ed58b4dae4a231d650f38f1ce68d5651ff36c" translate="yes" xml:space="preserve">
          <source>which is functionally equivalent to</source>
          <target state="translated">기능적으로</target>
        </trans-unit>
        <trans-unit id="46200cef96c0961d87e6a88c9a425a6d717be8f2" translate="yes" xml:space="preserve">
          <source>which will result in a query string like &lt;code&gt;a=3&amp;amp;b=5&amp;amp;b=6&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a=3&amp;amp;b=5&amp;amp;b=6&lt;/code&gt; 과 같은 쿼리 문자열이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="917ee86398faff0a7c5d2dfa164fcca29f292612" translate="yes" xml:space="preserve">
          <source>will not work as expected.</source>
          <target state="translated">예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb9bfc63b82056a09850870ebe213acc89605927" translate="yes" xml:space="preserve">
          <source>will produce two new request headers:</source>
          <target state="translated">두 개의 새로운 요청 헤더가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f35769f887dd5465ff95016a2677fc83c59eed11" translate="yes" xml:space="preserve">
          <source>will result in</source>
          <target state="translated">결과</target>
        </trans-unit>
        <trans-unit id="e1b07468e07aae42183959d404cba0617c29e6ae" translate="yes" xml:space="preserve">
          <source>will yield</source>
          <target state="translated">생산할 것이다</target>
        </trans-unit>
        <trans-unit id="219e68a29cda73c921f1171d1c84ef1037462b7f" translate="yes" xml:space="preserve">
          <source>will yield the output</source>
          <target state="translated">출력을 산출합니다</target>
        </trans-unit>
        <trans-unit id="c9b0dddd930529e92c358b4064a2785ef70b93ab" translate="yes" xml:space="preserve">
          <source>will yield the response body like</source>
          <target state="translated">다음과 같은 응답 본문을 생성합니다</target>
        </trans-unit>
        <trans-unit id="0c475a60ccfd5eb49061a276875f9aa016aef39b" translate="yes" xml:space="preserve">
          <source>will yield:</source>
          <target state="translated">산출 할 것이다 :</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
        <trans-unit id="0c6a74f768bbdfb3a090fb3dd3d885a9f500fb09" translate="yes" xml:space="preserve">
          <source>yields the output</source>
          <target state="translated">출력을 산출</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
