<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">&lt;em&gt;hello_cargo&lt;/em&gt; 디렉토리 로 이동 하여 파일을 나열하십시오. Cargo가 두 개의 파일과 하나의 디렉토리 ( &lt;em&gt;Cargo.toml&lt;/em&gt; 파일과 &lt;em&gt;main.rs&lt;/em&gt; 파일이있는 &lt;em&gt;src&lt;/em&gt; 디렉토리)를 &lt;em&gt;생성했음을 알 수&lt;/em&gt; 있습니다. 또한 &lt;em&gt;.gitignore&lt;/em&gt; 파일 과 함께 새로운 Git 리포지토리를 초기화했습니다 .</target>
        </trans-unit>
        <trans-unit id="50e6889164bb8054d882b924cda71582b6d6d180" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 유한 해집니다 .</target>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 함께 유한 :</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">정상 종료 및 정리</target>
        </trans-unit>
        <trans-unit id="14b567b853879017732fc7e6b51b1225fb2590d3" translate="yes" xml:space="preserve">
          <source>Gradual initialization of an &lt;code&gt;UnsafeCell&lt;/code&gt; requires &lt;code&gt;raw_get&lt;/code&gt;, as calling &lt;code&gt;get&lt;/code&gt; would require creating a reference to uninitialized data:</source>
          <target state="translated">의 점진적 초기화 &lt;code&gt;UnsafeCell&lt;/code&gt; 이 필요 &lt;code&gt;raw_get&lt;/code&gt; 호출로, &lt;code&gt;get&lt;/code&gt; 초기화되지 않은 데이터에 대한 참조를 만들 필요 :</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">큰! 코드는 파일의 내용을 읽고 인쇄했습니다. 그러나 코드에는 몇 가지 결함이 있습니다. &lt;code&gt;main&lt;/code&gt; 기능은 여러 책임이있다 : 각 기능은 하나의 아이디어에 대한 책임이 경우 일반적으로, 기능을 유지하기 위해 명확하고 쉽다. 다른 문제는 우리가 할 수있는만큼 오류를 처리하지 않는다는 것입니다. 프로그램은 여전히 ​​작기 때문에 이러한 결함은 큰 문제는 아니지만 프로그램이 커질수록 깨끗하게 수정하기가 더 어려워집니다. 적은 양의 코드를 리팩토링하는 것이 훨씬 쉽기 때문에 프로그램을 개발할 때 리팩토링을 일찍 시작하는 것이 좋습니다. 다음에 해보겠습니다.</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">큰! 그들은 통과했다. 이제 &lt;code&gt;run&lt;/code&gt; 함수 에서 새로운 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수를 호출 해 봅시다 . 먼저 &lt;code&gt;Config&lt;/code&gt; 구조체에 구성 옵션을 추가하여 대소 문자를 구분하는 검색과 대소 문자를 구분하지 않는 검색을 전환합니다. 이 필드를 추가하면 아직이 필드를 초기화하지 않기 때문에 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">큰! 이 에러는 &lt;code&gt;ThreadPool&lt;/code&gt; 타입이나 모듈이 필요하다는 것을 알려주 므로 지금 빌드 할 것입니다. 우리의 &lt;code&gt;ThreadPool&lt;/code&gt; 구현은 웹 서버가 수행하는 작업의 종류와 무관합니다. 자,이 전환 할 수 &lt;code&gt;hello&lt;/code&gt; 우리 개최 라이브러리 상자에 진 상자에서 상자를 &lt;code&gt;ThreadPool&lt;/code&gt; 구현. 라이브러리 상자로 변경 한 후에는 웹 요청을 처리하기위한 것이 아니라 스레드 풀을 사용하여 수행하려는 모든 작업에 별도의 스레드 풀 라이브러리를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">큰! 이 결과는 사용자에게 훨씬 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">프로그램이 작동하고 있습니다. 필요한 인수 값이 올바른 변수에 저장됩니다. 나중에 사용자가 인수를 제공하지 않는 경우와 같이 특정 잠재적 오류 상황을 처리하기 위해 오류 처리를 추가 할 것입니다. 지금은 그러한 상황을 무시하고 대신 파일 읽기 기능을 추가하는 작업을합니다.</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">테스트가 예상대로 정확하게 실패합니다. 시험에 합격합시다!</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">보다 큰</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">비교보다 큼</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">비교 이상</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Arc&lt;/code&gt; 대한 비교보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 비교보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">그리스 문자 &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot;는 잠재적으로 비어있는 토큰 트리 시퀀스를 나타냅니다. 그러나 그리스 문자 &quot;&amp;epsilon;&quot;(epsilon)는 프레젠테이션에서 특별한 역할을하며 토큰 트리 시퀀스를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">그룹 표현식 속성</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">그룹화 된 표현</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">그룹화 된 패턴</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">구성 값 그룹화</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">그룹스 항목</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">프로젝트에 적합한 라이센스에 대한 지침은이 책의 범위를 벗어납니다. Rust 커뮤니티의 많은 사람들은 &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; 의 이중 라이센스를 사용하여 Rust와 동일한 방식으로 프로젝트 라이센스를 부여합니다 . 이 연습에서는 &lt;code&gt;OR&lt;/code&gt; 로 구분 된 여러 라이센스 식별자를 지정 하여 프로젝트에 대한 여러 라이센스를 가질 수도 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">오류 처리 지침</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">HEX_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ] &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL :</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTP는 텍스트 기반 프로토콜이며 요청은 다음 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">했다 &lt;code&gt;path&lt;/code&gt; , 유효하지 않은 유니 코드 포함 &lt;code&gt;to_string_lossy&lt;/code&gt; 의 호출이 반환 수도 &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서 &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; 에서 리턴 된 처리 오류</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">I / O 처리</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">유효하지 않은 입력 처리</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt; 여러 조건 처리</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">&lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; 유형으로 잠재적 실패 처리</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">동시 프로그래밍을 안전하고 효율적으로 처리하는 것은 Rust의 주요 목표 중 하나입니다. &lt;em&gt;프로그램의&lt;/em&gt; 다른 부분이 독립적으로 실행되는 &lt;em&gt;동시 프로그래밍&lt;/em&gt; 과 프로그램의 다른 부분이 동시에 실행 되는 &lt;em&gt;병렬 프로그래밍&lt;/em&gt; 은 더 많은 컴퓨터가 여러 프로세서를 활용함에 따라 점점 더 중요 해지고 있습니다. 역사적으로 이러한 맥락에서 프로그래밍하는 것은 어렵고 오류가 발생하기 쉽습니다. Rust는이를 변경하기를 희망합니다.</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">에러 처리 ( &lt;a href=&quot;ch09-00-error-handling&quot;&gt;9 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 에서 오류를 반환하는 경우 오류 처리</target>
        </trans-unit>
        <trans-unit id="9779c3f0bfcc6c7bd84ac8dc1d7d0faaf0886246" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;OnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59701e203928fde4afc37f856c0fe1389efbf77a" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;SyncOnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605c9af0dc3550ddfefeee4d42138a7f1adc2bd1" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 의 효과가 함께 있음 :로드의 경우 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 순서를 사용합니다 . 상점의 경우 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 순서를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; 가&lt;/a&gt; 함께 효과가 있습니다.로드의 경우 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 주문을 사용합니다 . 상점의 경우 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 주문을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">해시 맵 및 소유권</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">원시 포인터를 해시하십시오.</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">해시 맵은 벡터를 사용할 때처럼 인덱스를 사용하지 않고 모든 유형의 키를 사용하여 데이터를 조회 할 때 유용합니다. 예를 들어 게임에서 각 키는 팀 이름이고 값은 각 팀의 점수 인 해시 맵에서 각 팀의 점수를 추적 할 수 있습니다. 팀 이름이 주어지면 점수를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">해시 메모</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">해싱 함수</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Haskell (GHC) : 타입 클래스, 타입 패밀리</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">갖는 &lt;code&gt;common&lt;/code&gt; 테스트 결과에 표시 &lt;code&gt;running 0 tests&lt;/code&gt; 이를 표시하는 것은 우리가 원하는 것이 아니다. 우리는 다른 통합 테스트 파일과 일부 코드를 공유하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 결합하여 여러 개의 가변 데이터 소유자 보유</target>
        </trans-unit>
        <trans-unit id="b3039ad6abf86928bcfdadaa49d3256f9e624f29" translate="yes" xml:space="preserve">
          <source>Having multiple relaxed default bounds is unsupported.</source>
          <target state="translated">완화 된 기본 경계가 여러 개있는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">객체에 대한 하나의 변경 가능한 참조 ( &lt;code&gt;&amp;amp;mut T&lt;/code&gt; )가 있습니다 ( &lt;strong&gt;mutability&lt;/strong&gt; 라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">오브젝트에 대한 여러 불변의 참조 ( &lt;code&gt;&amp;amp;T&lt;/code&gt; )가 있습니다 ( &lt;strong&gt;앨리어싱&lt;/strong&gt; 이라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 데이터와 동기화되지 않는 &lt;code&gt;word&lt;/code&gt; 의 색인에 대해 걱정 해야하는 것은 지루하고 오류가 발생하기 쉽습니다! &lt;code&gt;second_word&lt;/code&gt; 함수를 작성하면 이러한 인덱스를 관리하는 것이 훨씬 더 취약 합니다. 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">안녕하세요,화물!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">안녕, 월드!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 경로를 안전하게 인쇄하기위한 도우미 구조 ! 와 &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8498955fde08da370bacddfd1434e8493282db8" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; 에&lt;/a&gt; 대한 도우미 특성입니다 .</target>
        </trans-unit>
        <trans-unit id="bbdd82587ac5843ce3d9f6e79bf40efba742c5a2" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; 의&lt;/a&gt; 도우미 특성</target>
        </trans-unit>
        <trans-unit id="d8870a3f309d445b4b67cf35abad15e6e3e773d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;T&lt;/code&gt; is a trait object with two explicit lifetime bounds, 'a and 'b.</source>
          <target state="translated">여기서 &lt;code&gt;T&lt;/code&gt; 는 'a와'b '라는 두 개의 명시 적 수명 경계가있는 특성 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">여기서 &lt;code&gt;X&lt;/code&gt; 는 &lt;code&gt;Y&lt;/code&gt; 가 발생할 때까지 판별 자 0으로 이미 지정 되었으므로 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">이 오류의 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">사용중인 비교 연산자의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">사용되는 이러한 연산자의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">다음은 비슷한 예이지만 지금은 마지막입니다.</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">다음은 이러한 연산자의 예입니다</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">다음은 제거 오류의 예입니다.</target>
        </trans-unit>
        <trans-unit id="4bcc69e7a08f9cc053bd0cff82d93712f586660e" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions don't have extended temporary scopes:</source>
          <target state="translated">다음은 표현식에 확장 된 임시 범위가없는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="c92962597dc4ffea4ff897a85b4d5e4dec6ca581" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions have extended temporary scopes:</source>
          <target state="translated">다음은 표현식에 확장 된 임시 범위가있는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">참조 : 몇 가지 예 &lt;code&gt;i32&lt;/code&gt; 수명 파라미터 제공되지 않을 경우에 참조 &lt;code&gt;i32&lt;/code&gt; 이라는 수명 파라미터 가진다 &lt;code&gt;'a&lt;/code&gt; 내지 An 및 가변 기준 &lt;code&gt;i32&lt;/code&gt; 또한 수명이 있는지 &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">이 모듈에 포함 된 것들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">이 오류가 발생하는 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a02d5c5d61bf51906767acca68761775d677fe8" translate="yes" xml:space="preserve">
          <source>Here are the abilities Unsafe Rust has in addition to Safe Rust:</source>
          <target state="translated">다음은 안전한 Rust에 더해 Unsafe Rust의 능력입니다.</target>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">이 장에서 다룰 주제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">다음은 &lt;code&gt;entry&lt;/code&gt; 이 사용 되는 두 가지 기본 방법입니다 . 첫째, 값에 대해 수행되는 논리가 사소한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">다음은 실행 &lt;code&gt;x = None&lt;/code&gt; 일치되는 값을 수정하지 않으며이 &quot;시간을 거슬러&quot;가서 우리를 필요 &lt;code&gt;None&lt;/code&gt; 팔을.</target>
        </trans-unit>
        <trans-unit id="b54fff02e5e3fe8139f3151b798d2ca6781ef79d" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm. To fix it, change the value in the match arm:</source>
          <target state="translated">여기서 &lt;code&gt;x = None&lt;/code&gt; 실행 하면 일치하는 값이 수정되고 &lt;code&gt;None&lt;/code&gt; 팔로 &quot;시간을 거슬러 올라갑니다&quot; . 이를 수정하려면 매치 암의 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택해야하는 이유를 요약하면 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">다음은 이전 예제의 변형으로 , 첫 번째 &lt;code&gt;Err&lt;/code&gt; 이후의 &lt;code&gt;iter&lt;/code&gt; 에서 더 이상 요소를 가져 오지 않음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">다음 예제 는 첫 번째 &lt;code&gt;None&lt;/code&gt; 이후 &lt;code&gt;iter&lt;/code&gt; 에서 더 이상 요소를 가져 오지 않음을 보여주는 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">다음은 제네릭을 사용하여 &lt;code&gt;Add&lt;/code&gt; 특성을 구현하는 동일한 &lt;code&gt;Point&lt;/code&gt; 구조체 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">다음은 제네릭을 사용하여 &lt;code&gt;Sub&lt;/code&gt; 특성을 구현하는 동일한 &lt;code&gt;Point&lt;/code&gt; 구조체 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">다음은 HTTP 버전 1.1을 사용하고 상태 코드 200, 확인 이유 문구, 헤더 및 본문이없는 응답 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d3dccad44a11aba4a0bfd15fb7b2845992244bd" translate="yes" xml:space="preserve">
          <source>Here is an example showcasing how to soundly mutate the contents of an &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; despite there being multiple references aliasing the cell:</source>
          <target state="translated">다음은 셀 별칭을 지정하는 여러 참조가 있음에도 불구하고 &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 의 내용을 제대로 변경하는 방법을 보여주는 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">다음은 오류를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 값의 범위를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">다음은 세 번째 수명 제거 규칙이 적용되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">다음은 벡터의 모든 정수를 증가시키고 오버플로를 확인하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">다음은 벡터의 모든 정수를 증가시키는 예입니다. 계산에 오버플로가 발생하면 &lt;code&gt;None&lt;/code&gt; 을 반환 하는 &lt;code&gt;add&lt;/code&gt; 의 확인 된 변형을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">다음은 본문에서 아무 것도하지 않는 &lt;code&gt;dangerous&lt;/code&gt; 라는 안전하지 않은 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">다음은 언더 플로를 검사하는 다른 정수 목록에서 하나를 빼려는 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">다음은 값의 소유권을 가져 오는 대신 객체에 대한 참조가 있는 &lt;code&gt;calculate_length&lt;/code&gt; 함수를 정의하고 사용하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">다음은 몇 가지 설명 주석이 포함 된 동일한 예입니다.</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">이 코드를 컴파일 할 때 발생하는 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">웹 서버 구축 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">올바른 순서로 이전 예를 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">여기이 알고리즘은 의사 코드로 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">여기 &lt;code&gt;Apple&lt;/code&gt; 변형에는 두 개의 필드가 있으며 다음과 같이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="847a36b4e8f5bc18d0a990ee9501fe6c952a3db3" translate="yes" xml:space="preserve">
          <source>Here the type &lt;code&gt;T&lt;/code&gt; cannot have a relaxed bound for multiple default traits (&lt;code&gt;Sized&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;). This can be fixed by only using one relaxed bound.</source>
          <target state="translated">여기서 유형 &lt;code&gt;T&lt;/code&gt; 는 여러 기본 특성 ( &lt;code&gt;Sized&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; )에 대해 완화 된 경계를 가질 수 없습니다 . 이것은 하나의 완화 된 경계를 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">여기에서 우리는 만들 &lt;code&gt;Status::Value&lt;/code&gt; 각 사용 인스턴스 &lt;code&gt;u32&lt;/code&gt; 하는 범위에서 값 &lt;code&gt;map&lt;/code&gt; 의 초기화 기능을 사용하여 호출됩니다 &lt;code&gt;Status::Value&lt;/code&gt; . 어떤 사람들은이 스타일을 선호하고 어떤 사람들은 클로저를 사용하는 것을 선호합니다. 그것들은 같은 코드로 컴파일되므로, 당신에게 더 명확한 스타일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">여기에 변수 &lt;code&gt;y&lt;/code&gt; 를 사용 하지 않는다는 경고가 표시되지만 밑줄 앞에 변수를 사용하지 않는다는 경고는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5caa2018a964f99eaa055d4bd09b35c0163bd0e" translate="yes" xml:space="preserve">
          <source>Here we have an addition of &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;n.into()&lt;/code&gt;. Hence, &lt;code&gt;n.into()&lt;/code&gt; can return any type &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;into&lt;/code&gt; method can return any type where &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">여기 에 &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; 대한 반복자 &lt;code&gt;results&lt;/code&gt; 가 있습니다 . 따라서 &lt;code&gt;results.collect()&lt;/code&gt; 는 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 구현하는 모든 유형을 리턴 할 수 있습니다 . 반면에 &lt;code&gt;?&lt;/code&gt; 연산자는 &lt;code&gt;Try&lt;/code&gt; 를 구현하는 모든 유형을 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">여기에서는 문자열 슬라이스라고도하는 문자열 리터럴을 선언했습니다. 문자열 리터럴은 정적 수명을 가지므로 &lt;code&gt;hello_world&lt;/code&gt; 문자열 은 전체 프로그램 기간 동안 유효합니다. &lt;code&gt;hello_world&lt;/code&gt; 의 수명도 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6025ae753da089e1d8586a3532b960124e6dc6" translate="yes" xml:space="preserve">
          <source>Here we have used the &lt;code&gt;continue&lt;/code&gt; keyword incorrectly. As we have seen above that &lt;code&gt;continue&lt;/code&gt; pointing to a labeled block.</source>
          <target state="translated">여기에서는 &lt;code&gt;continue&lt;/code&gt; 키워드를 잘못 사용했습니다 . 위에서 보았 듯이 &lt;code&gt;continue&lt;/code&gt; 레이블이 지정된 블록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">여기서 &lt;code&gt;flatten()&lt;/code&gt; 은 &quot;deep&quot;flatten을 수행하지 않습니다. 대신, 한 수준의 중첩 만 제거됩니다. 즉, 3 차원 배열 을 &lt;code&gt;flatten()&lt;/code&gt; 하면 결과는 2 차원이며 1 차원이 아닙니다. 1 차원 구조를 얻으려면 다시 &lt;code&gt;flatten()&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">여기서 Rust에 결과가 &lt;code&gt;Ok&lt;/code&gt; 일 때 &lt;code&gt;Ok&lt;/code&gt; 변형 에서 내부 &lt;code&gt;file&lt;/code&gt; 값을 반환 한 다음 해당 파일 핸들 값을 변수 &lt;code&gt;f&lt;/code&gt; 에 지정 합니다. &lt;code&gt;match&lt;/code&gt; 후에 파일 핸들을 사용하여 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">여기서는 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 값에 대한 참조 인 &lt;code&gt;&amp;amp;m&lt;/code&gt; 인수와 함께 &lt;code&gt;hello&lt;/code&gt; 함수를 호출합니다 . Listing 15-10의 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Deref&lt;/code&gt; 특성을 구현했기 때문에 Rust는 &lt;code&gt;deref&lt;/code&gt; 를 호출 하여 &lt;code&gt;&amp;amp;String&lt;/code&gt; &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 을 &amp;amp; String 으로 바꿀 수있다 . 표준 라이브러리의 구현 제공 &lt;code&gt;Deref&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 문자열 조각을 반환하고이에 대한 API 문서에 &lt;code&gt;Deref&lt;/code&gt; . 녹 호출 &lt;code&gt;deref&lt;/code&gt; 차례 다시 &lt;code&gt;&amp;amp;String&lt;/code&gt; 로 &lt;code&gt;&amp;amp;str&lt;/code&gt; 성냥하는 &lt;code&gt;hello&lt;/code&gt; 함수의 정의.</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">여기에 구조체를 정의하고 이름을 &lt;code&gt;Rectangle&lt;/code&gt; 로 지정했습니다 . 중괄호 안에 필드를 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 로 정의했으며 둘 다 유형이 &lt;code&gt;u32&lt;/code&gt; 입니다. 그런 다음 &lt;code&gt;main&lt;/code&gt; 에서 너비가 30이고 높이가 50 인 &lt;code&gt;Rectangle&lt;/code&gt; 의 특정 인스턴스를 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">간단한 의견은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">다음은 작은 프로그래밍 문제입니다. 문자열을 가져 와서 해당 문자열에서 찾은 첫 번째 단어를 반환하는 함수를 작성하십시오. 함수가 문자열에서 공백을 찾지 못하면 전체 문자열이 한 단어 여야하므로 전체 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">다음은 상수 이름이 &lt;code&gt;MAX_POINTS&lt;/code&gt; 이고 값이 100,000으로 설정된 상수 선언의 예입니다 . 상수에 대한 Rust의 명명 규칙은 단어 사이에 밑줄이있는 모든 대문자를 사용하는 것이며 가독성을 높이기 위해 밑줄을 숫자 리터럴로 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">다음은 개발 및 릴리스 프로세스의 작동 방식에 대한 예입니다. Rust 팀이 Rust 1.5 릴리스를 작업 중이라고 가정 해 봅시다. 이 릴리스는 2015 년 12 월에 발생했지만 실제 버전 번호를 제공 할 것입니다. Rust에 새로운 기능이 추가되었습니다 : 새로운 커밋이 &lt;code&gt;master&lt;/code&gt; 브랜치 . 매일 밤 Rust의 새로운 야간 버전이 생성됩니다. 매일은 릴리스 일이며 이러한 릴리스는 릴리스 인프라에서 자동으로 생성됩니다. 시간이 지남에 따라 릴리스는 다음과 같이 밤에 한 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">여기에 예가 있습니다 &lt;code&gt;clone&lt;/code&gt; 방법의 실제 .</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">다음은 실제 부동 소수점 숫자를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">작동 방식은 다음과 같습니다. &lt;code&gt;object.something()&lt;/code&gt; 으로 메소드를 호출하면 Rust가 자동으로 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; 는 메서드의 서명과 일치합니다. 다시 말해 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">컴파일러 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">다음은 참조를위한 전체 코드입니다.</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">결과 컴파일 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">테스트 할 시나리오는 다음과 같습니다. 최대 값에 대해 값을 추적하고 현재 값이 최대 값에 얼마나 가까운 지에 따라 메시지를 보내는 라이브러리를 만듭니다. 이 라이브러리는 예를 들어 사용자가 허용 한 API 호출 수에 대한 사용자 할당량을 추적하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">다음은 &lt;code&gt;for&lt;/code&gt; 루프와 범위를 뒤집기 위해 아직 이야기하지 않은 또 다른 방법 인 &lt;code&gt;rev&lt;/code&gt; 를 사용하여 카운트 다운을하는 모습입니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">다음은 위에서 설명한 세 가지 사례를 보여주는 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">이 문제가있는 구조체의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">다음은 컬렉션이 &lt;code&gt;needs_drop&lt;/code&gt; 을 사용하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">다음은 진행중인 코드의 예입니다. &lt;code&gt;Foo&lt;/code&gt; 라는 특성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; 을 무시하고 키만 기준으로 사람을 정렬하려는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cce1c09bcbbaec9487020ee6e7f8025e34bed6b" translate="yes" xml:space="preserve">
          <source>Here's another example but here we do not try and return an expression:</source>
          <target state="translated">여기 또 다른 예가 있지만 여기에서는 표현식을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">실패 할 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 같은 예제이지만 &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f461dd8cfe66dce3c71bb1a0db34025a57dc2b4e" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 동일한 예이지만 &lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 사용&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b538038816d2b9d80e3095023dd492b1ae3c134a" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 동일한 예이지만 &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 사용&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; 는 변경할 수 있지만 &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; 는 변경할 수 없습니다. 값에 대한 불변의 참조를 작성하면 불변으로 차용됩니다. 동일한 값을 가리키는 &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; 유형에 대한 여러 참조가있을 수 있으므로 동일한 값에 대한 여러 변경 가능한 참조를 방지하려면 변경 불가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">여기에서 &lt;code&gt;Grams2&lt;/code&gt; 는 &lt;code&gt;Grams&lt;/code&gt; 와 동등하지 않습니다 . 전자는 단일 float를 포함하는 (투명하지 않은) 구조체를 투명하게 감싸고, &lt;code&gt;Grams&lt;/code&gt; 는 float 주위의 투명한 래퍼입니다. 이것은 ABI를 변화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;demo&lt;/code&gt; 는 인수 &lt;code&gt;s&lt;/code&gt; 내에 보유 된 문자열 데이터 를 빌린 다음 빌린 값을 반환 하려고 시도합니다 . 그러나 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;Drop&lt;/code&gt; 구현으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">여기서 &lt;code&gt;fancy_num&lt;/code&gt; 은 fancy_ref 에 의해 빌려 &lt;code&gt;fancy_ref&lt;/code&gt; 클로저 &lt;code&gt;x&lt;/code&gt; 로 이동할 수 없습니다 . 차용을 무효화 할 수 있기 때문에 차용 한 값을 클로저로 옮길 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">여기에서는 &lt;code&gt;first&lt;/code&gt; &lt;code&gt;to_vec&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 유형 매개 변수를 참조하여 유형 &lt;code&gt;A&lt;/code&gt; 를 갖습니다 . 그리고 &lt;code&gt;rest&lt;/code&gt; 유형이 &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; , 요소 유형과 벡터 &lt;code&gt;A&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="843f8d3cb9b3a29d042bd0b638e62192879181c8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the array contains five elements.</source>
          <target state="translated">여기서 &lt;code&gt;i32&lt;/code&gt; 는 각 요소의 유형입니다. 세미콜론 뒤의 숫자 &lt;code&gt;5&lt;/code&gt; 는 배열에 5 개의 요소가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">여기서 &lt;code&gt;i32&lt;/code&gt; 는 각 요소의 유형입니다. 세미콜론 다음에 숫자 &lt;code&gt;5&lt;/code&gt; 는 요소에 5 개의 항목이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;s&lt;/code&gt; 는 문자열의 처음 4 바이트를 포함 하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 입니다. 앞에서 우리는이 문자들 각각이 2 바이트라고 언급했는데, 이는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;Зд&lt;/code&gt; 일 것 입니다.</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">여기서 &lt;code&gt;score&lt;/code&gt; 는 Blue 팀과 관련된 값을 가지며 결과는 &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; 입니다. &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; 반환 하므로 결과는 &lt;code&gt;Some&lt;/code&gt; 로 래핑됩니다 . 해시 맵에 해당 키에 대한 값이 없으면 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 프로그램은 6 장에서 다룬 방법 중 하나로 &lt;code&gt;Option&lt;/code&gt; 을 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 의 수명은 &lt;code&gt;'b&lt;/code&gt; ' 이며,이 경우 &lt;code&gt;'a&lt;/code&gt; ' 보다 큽니다 . 이 방법은 &lt;code&gt;r&lt;/code&gt; 에 참조 할 수 &lt;code&gt;x&lt;/code&gt; 녹에서 참조 것을 알고 있기 때문에 &lt;code&gt;r&lt;/code&gt; 은 동안 항상 유효합니다 &lt;code&gt;x&lt;/code&gt; 는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">여기서 &lt;code&gt;y&lt;/code&gt; 는 하나의 경우 값에 의해 바인딩되고 다른 경우에는 참조에 의해 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">여기서, &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;Some&lt;/code&gt; 의 내용에 묶여 있고 매치 암에 해당하는 블록 내에서 사용될 수있다. 그러나 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;code&gt;y&lt;/code&gt; 가 무엇인지 지정하지 않았 으며 블록은 존재하지 않는 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">여기에 구현 모든 유형의 &lt;code&gt;Foo&lt;/code&gt; 메소드가 있어야합니다 &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; 모든 종류의 걸릴 수 &lt;code&gt;T&lt;/code&gt; 를 . 그러나 &lt;code&gt;bool&lt;/code&gt; 의 &lt;code&gt;impl&lt;/code&gt; 에 추가 경계를 추가했습니다. &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Copy&lt;/code&gt; 인 하여 원래 특성과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">여기서, 비록 &lt;code&gt;x&lt;/code&gt; 의 파라미터 중 하나가 아닌 &lt;code&gt;equal_to_x&lt;/code&gt; 상기 &lt;code&gt;equal_to_x&lt;/code&gt; 클로져가 사용하도록 허용 &lt;code&gt;x&lt;/code&gt; 것과 동일한 범위에 정의되어 가변 &lt;code&gt;equal_to_x&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">여기서는 평생 매개 변수를 지정했지만 &lt;code&gt;'a&lt;/code&gt; 반환 유형에 'a 를 반환 값 수명이 매개 변수의 수명과 전혀 관련이 없으므로이 구현은 컴파일에 실패합니다. 우리가 얻는 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">여기에 응답에 상태 코드가 404 인 상태 표시 줄과 이유 구문 &lt;code&gt;NOT FOUND&lt;/code&gt; 가 있습니다. 우리는 여전히 헤더를 반환하지 않으며 응답 본문은 &lt;em&gt;404.html&lt;/em&gt; 파일의 HTML이됩니다 . &lt;em&gt;404.html&lt;/em&gt; 을 만들어야합니다&lt;em&gt;&lt;/em&gt;오류 페이지에 대해 &lt;em&gt;hello.html&lt;/em&gt; 옆에 파일 합니다. 원하는 HTML을 사용하거나 Listing 20-8의 예제 HTML을 자유롭게 사용한다.</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기, &lt;code&gt;BitAndAssign&lt;/code&gt; 특성은 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 주위의 래퍼에 대해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">여기서 &lt;code&gt;nothing_is_true&lt;/code&gt; 메소드는 &lt;code&gt;self&lt;/code&gt; 의 소유권을 갖습니다 . 그러나 &lt;code&gt;.borrow()&lt;/code&gt; 는 &lt;code&gt;RefCell&lt;/code&gt; 소유의 컨텐츠를 빌린 &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; 만 제공 하기 때문에 &lt;code&gt;self&lt;/code&gt; 를 이동할 수 없습니다 . 이 오류를 해결하려면 세 가지 선택 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ecdeb34514236dc334d979e1fa6dac1a4f47ca1" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;yield&lt;/code&gt; keyword is used in an &lt;code&gt;async&lt;/code&gt; block, which is not yet supported.</source>
          <target state="translated">여기서 &lt;code&gt;yield&lt;/code&gt; 키워드는 아직 지원되지 않는 &lt;code&gt;async&lt;/code&gt; 블록 에서 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">여기서 코드는 배열의 요소를 통해 계산됩니다. 인덱스 &lt;code&gt;0&lt;/code&gt; 에서 시작한 다음 배열의 최종 인덱스에 도달 할 때까지 (즉, &lt;code&gt;index &amp;lt; 5&lt;/code&gt; 가 더 이상 참이 아닌 경우) 반복됩니다 . 이 코드를 실행하면 배열의 모든 요소가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">여기에서 &lt;code&gt;&amp;amp;foo()&lt;/code&gt; 표현식은 &lt;code&gt;foo()&lt;/code&gt; 표현식을 빌리고 있습니다. 마찬가지로 &lt;code&gt;foo()&lt;/code&gt; A A 함수 호출, 그리고 변수의 이름이며, 이는 생성 &lt;strong&gt;일시&lt;/strong&gt; - 즉 임시 저장 반환 값 &lt;code&gt;foo()&lt;/code&gt; 가 대여 할 수 있도록한다. 당신이 상상할 수있는 &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; 이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">여기서 &lt;code&gt;eat&lt;/code&gt; 함수 는 &lt;code&gt;x&lt;/code&gt; 의 소유권을 갖습니다 . 그러나 &lt;code&gt;_ref_to_val&lt;/code&gt; 에 &lt;code&gt;borrow&lt;/code&gt; 함수는 차용 함수까지 지속 되어야하므로 &lt;code&gt;x&lt;/code&gt; 를 이동할 수 없습니다 . 이를 해결하기 위해 몇 가지 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">여기서 &lt;code&gt;foo&lt;/code&gt; 함수 는 수명 &lt;code&gt;'x&lt;/code&gt; 를 참조하는 &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; 유형의 값을 리턴합니다 . 그러나 반환 유형은 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 로 선언됩니다. 이는 &lt;code&gt;foo&lt;/code&gt; 가 &quot; &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 를 구현하는 일부 유형&quot;을 반환 하지만 반환 유형 &lt;strong&gt;은 수명 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;'y&lt;/code&gt; 를&lt;/strong&gt;&lt;strong&gt; 참조하는 데이터 만 캡처&lt;/strong&gt; 함을 나타냅니다.&lt;strong&gt;&lt;/strong&gt; . 이 경우 수명이 &lt;code&gt;'x&lt;/code&gt; 인 데이터를 참조 하므로이 기능에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">여기서 루프는 끝나지 않습니다 &lt;code&gt;!&lt;/code&gt; 식의 값입니다. 우리가 포함 된 경우,이 사실이되지 않을 것 &lt;code&gt;break&lt;/code&gt; 가 도착했을 때 루프가 종료 때문에, &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">여기서 문제는 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 와 같은 참조 유형 이 T의 모든 데이터가 수명 &lt;code&gt;'a&lt;/code&gt; 보다 오래 지속되는 경우에만 유효하다는 것 입니다. 그러나 작성된이 IMPL은 평생에 적용 할 수있다 &lt;code&gt;'a&lt;/code&gt; 어떤 타입의 &lt;code&gt;T&lt;/code&gt; - 우리는 보장이 없다는 &lt;code&gt;T&lt;/code&gt; 의 들보 다 오래 남았습니다 &lt;code&gt;'a&lt;/code&gt; . 이 문제를 해결하기 위해 &lt;code&gt;where T: 'a&lt;/code&gt; 와 같은 where 절을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0ef28f4a5284b6e2516b2e042ed2f018d33a029" translate="yes" xml:space="preserve">
          <source>Here, the problem is that the compiler cannot be sure that the &lt;code&gt;'b&lt;/code&gt; lifetime will live longer than &lt;code&gt;'a&lt;/code&gt;, which should be mandatory in order to be sure that &lt;code&gt;Trait::Out&lt;/code&gt; will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than &lt;code&gt;'b&lt;/code&gt; must outlive &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">여기에서 문제는 컴파일러가 있는지 확인하는 것이 될 수 없다는 것입니다 &lt;code&gt;'b&lt;/code&gt; 수명보다 더 오래 살 것이다 &lt;code&gt;'a&lt;/code&gt; 있는지 확인하기 위해 의무적으로해야하는 &lt;code&gt;Trait::Out&lt;/code&gt; 항상 기존의 유형에 대한 참조를 가리키는 것입니다. 따라서이 경우 컴파일러에게 &lt;code&gt;'b&lt;/code&gt; 는 'a 보다 오래 살아야한다 &lt;code&gt;'a&lt;/code&gt; 알려 주면됩니다 .</target>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">여기에서, 초 특성은 다음과 같은 방법을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">여기, &lt;code&gt;bar&lt;/code&gt; 의 종류 알려져 있지 않습니다. 그것은 무엇이든에 대한 포인터 일 수 있습니다. 대신 포인터의 유형을 지정하십시오 (바람직하게 가리키는 대상).</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">여기서 impl에 나타나는 where 절 &lt;code&gt;T: 'a&lt;/code&gt; 는 구조체에서 충족되는 것으로 알려져 있지 않습니다. 이 예제를 컴파일하려면 구조체 정의에 &lt;code&gt;T: 'a&lt;/code&gt; 와 같은 where-clause를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">루프 내부에 더 많은 메모리를 할당 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">여기서 변환은 fn 인수의 유형을 변환하는 데 사용됩니다. 이 패턴은 &lt;code&gt;foo&lt;/code&gt; 의 유형이 크기가 0 인 함수 &lt;strong&gt;항목&lt;/strong&gt; ( &lt;code&gt;typeof(foo)&lt;/code&gt; )이고 대상 유형 ( &lt;code&gt;fn()&lt;/code&gt; )이 0이 아닌 함수 포인터이기 때문에 올바르지 않습니다. 이 패턴을 다시 작성해야합니다. 이를 수행 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">여기서 우리는 여전히 &lt;code&gt;foo()&lt;/code&gt; 빌리고 있지만, 빌려 오기가 변수에 직접 할당되기 때문에 임시 블록은 둘러싸는 블록이 끝날 때까지 삭제되지 않습니다. 임시 규칙이 튜플 또는 구조체와 같은 집계 구조에 저장 될 때 유사한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">여기에 새로운 변수 &lt;code&gt;case_sensitive&lt;/code&gt; 를 만듭니다 . 값을 설정하기 위해 &lt;code&gt;env::var&lt;/code&gt; 함수를 호출 하고 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 환경 변수 의 이름을 전달합니다 . &lt;code&gt;env::var&lt;/code&gt; 함수는 반환 &lt;code&gt;Result&lt;/code&gt; 성공적으로 될 것입니다 &lt;code&gt;Ok&lt;/code&gt; 환경 변수가 설정되어있는 경우 환경 변수의 값을 포함 변형. 환경 변수가 설정되지 않은 경우 &lt;code&gt;Err&lt;/code&gt; 변형 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">여기서는 &lt;code&gt;trait&lt;/code&gt; 키워드를 사용하여 특성을 선언 한 다음 특성의 이름 ( 이 경우 &lt;code&gt;Summary&lt;/code&gt; 을 선언합니다 . 중괄호 안에이 특성을 구현하는 유형의 동작을 설명하는 메소드 시그니처를 선언합니다.이 경우 &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">먼저 &lt;code&gt;receiver&lt;/code&gt; 에서 &lt;code&gt;lock&lt;/code&gt; 을 호출 하여 뮤텍스를 얻은 다음 &lt;code&gt;unwrap&lt;/code&gt; 을 호출 하여 오류가 발생하면 패닉 상태가됩니다. 뮤텍스가 &lt;em&gt;독&lt;/em&gt; 상태 인 경우 잠금을 획득하지 못할 수 있습니다. 잠금을 해제하지 않고 잠금을 잡고있는 동안 다른 스레드가 당황한 경우 발생할 수 있습니다. 이 상황에서 &lt;code&gt;unwrap&lt;/code&gt; 을 호출 하여이 스레드 패닉이 발생하도록하는 것이 올바른 조치입니다. 의미있는 오류 메시지와 함께이 &lt;code&gt;unwrap&lt;/code&gt; 를 &lt;code&gt;expect&lt;/code&gt; 대로 변경하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">여기에서는 &lt;code&gt;add_one&lt;/code&gt; 함수의 기능에 대한 설명 을 제공 하고 제목 &lt;code&gt;Examples&lt;/code&gt; 로 섹션을 시작한 다음 &lt;code&gt;add_one&lt;/code&gt; 함수 를 사용하는 방법을 보여주는 코드를 제공 합니다. &lt;code&gt;cargo doc&lt;/code&gt; 을 실행하여이 문서 주석에서 HTML 문서를 생성 할 수 있습니다 . 이 명령은 Rust와 함께 배포 된 &lt;code&gt;rustdoc&lt;/code&gt; 도구를 실행하고 생성 된 HTML 문서를 &lt;em&gt;target / doc&lt;/em&gt; 디렉토리 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">여기에는 &lt;em&gt;src / main.rs&lt;/em&gt; 만 포함하는 패키지가 있습니다 . 즉, &lt;code&gt;my-project&lt;/code&gt; 라는 이진 상자 만 포함합니다 . 패키지에 &lt;em&gt;src / main.rs&lt;/em&gt; 및 &lt;em&gt;src / lib.rs&lt;/em&gt; 가 포함 된 경우 패키지 와 이름이 같은 라이브러리와 바이너리라는 두 개의 상자가 있습니다. 패키지는 &lt;em&gt;src / bin&lt;/em&gt; 디렉토리에 파일을 배치하여 여러 바이너리 상자를 가질 수 있습니다 . 각 파일은 별도의 바이너리 상자입니다.</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">여기에는 &lt;code&gt;TokenStream&lt;/code&gt; 유형의 두 매개 변수가 있습니다 . 첫 번째는 속성의 내용 인 &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; 부분입니다. 두 번째는 속성이 첨부 된 항목의 본문입니다.이 경우 &lt;code&gt;fn index() {}&lt;/code&gt; 및 나머지 함수의 본문입니다.</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">여기서 우리는 패턴과 튜플을 일치시킵니다. Rust는 값 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 을 패턴 &lt;code&gt;(x, y, z)&lt;/code&gt; 와 비교하고 값이 패턴과 일치하는 것을 확인하므로 Rust는 &lt;code&gt;1&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 &lt;code&gt;z&lt;/code&gt; 에 바인딩 합니다. 이 튜플 패턴은 그 안에 세 개의 개별 변수 패턴을 중첩시키는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">여기에서는 &lt;code&gt;Drop&lt;/code&gt; 특성 을 구현하는 &lt;code&gt;DropStruct&lt;/code&gt; 유형의 구조체에서 필드를 이동하려고했습니다 . 그러나 하나 이상의 필드가 이동 된 경우 구조체를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">여기에서는 &lt;code&gt;tx.send&lt;/code&gt; 를 통해 &lt;code&gt;val&lt;/code&gt; 을 채널로 보낸 후에 val 을 인쇄하려고합니다 . 이것을 허용하는 것은 나쁜 생각입니다. 일단 값이 다른 스레드로 보내지면 값을 다시 사용하기 전에 해당 스레드가 수정하거나 삭제할 수 있습니다. 잠재적으로 다른 스레드의 수정으로 인해 데이터가 일치하지 않거나 존재하지 않아 오류가 발생하거나 예기치 않은 결과가 발생할 수 있습니다. 그러나 Listing 16-9의 코드를 컴파일하려고하면 Rust에서 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">여기서 우리는 하나의 스레드가 값을 생성하여 채널로 전송하고 다른 스레드가 값을 수신하여 인쇄하는 프로그램으로 작업합니다. 기능을 설명하기 위해 채널을 사용하여 스레드간에 간단한 값을 전송합니다. 이 기술에 익숙해지면 채널을 사용하여 많은 스레드가 계산의 일부를 수행하고 결과를 집계하는 하나의 스레드로 부품을 보내는 채팅 시스템 또는 시스템을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">여기서는 벡터의 100 번째 요소 (인덱싱이 0에서 시작하기 때문에 인덱스 99에 있음)에 액세스하려고하지만 3 개의 요소 만 있습니다. 이 상황에서 Rust는 공황 상태에 빠질 것입니다. &lt;code&gt;[]&lt;/code&gt; 를 사용 하면 요소를 반환하지만 잘못된 인덱스를 전달하면 Rust가 여기에 반환 할 수있는 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">여기서는 &lt;code&gt;do_something&lt;/code&gt; 함수를 100 번 호출 하지만 &lt;code&gt;for&lt;/code&gt; 루프 의 본문에서 변수 &lt;code&gt;i&lt;/code&gt; 를 사용하지 않습니다 . 녹은 우리에게 그것에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">여기서는 &lt;code&gt;email&lt;/code&gt; 이라는 필드가있는 &lt;code&gt;User&lt;/code&gt; 구조체 의 새 인스턴스를 만듭니다 . &lt;code&gt;email&lt;/code&gt; 필드의 값을 &lt;code&gt;build_user&lt;/code&gt; 함수 의 &lt;code&gt;email&lt;/code&gt; 매개 변수 값 으로 설정 하려고 합니다. 때문에 &lt;code&gt;email&lt;/code&gt; 필드와 &lt;code&gt;email&lt;/code&gt; 매개 변수는 같은 이름을 가지고, 우리는 쓰기에 필요한 &lt;code&gt;email&lt;/code&gt; 이 아닌 &lt;code&gt;email: email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">여기, 우리가의 수명 주석 한 &lt;code&gt;r&lt;/code&gt; 함께 &lt;code&gt;'a&lt;/code&gt; 및의 수명 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;'b&lt;/code&gt; . 보시다시피, 내부 &lt;code&gt;'b&lt;/code&gt; 블록은 외부 &lt;code&gt;'a&lt;/code&gt; 평생 블록 보다 훨씬 작습니다 . 컴파일 타임에 Rust는 두 수명의 크기를 비교하여 &lt;code&gt;r&lt;/code&gt; 의 수명이 &lt;code&gt;'a&lt;/code&gt; 이지만 수명이 &lt;code&gt;'b&lt;/code&gt; 인 메모리를 나타냅니다 . 때문에이 프로그램은 거부 &lt;code&gt;'b&lt;/code&gt; 는 보다 짧은 &lt;code&gt;'a&lt;/code&gt; : 참조의 대상이 참조로하지 라이브 한 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기, 우리가하는 방법이라는 정의한 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 이 반환 필드의 데이터에 대한 참조 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">여기, 우리는 구조체 정의한 &lt;code&gt;IpAddr&lt;/code&gt; A : 두 개의 필드가 &lt;code&gt;kind&lt;/code&gt; 유형 인 필드 &lt;code&gt;IpAddrKind&lt;/code&gt; (우리가 이전에 정의 된 열거)과 &lt;code&gt;address&lt;/code&gt; 타입의 필드 &lt;code&gt;String&lt;/code&gt; . 이 구조체의 두 인스턴스가 있습니다. 첫 번째, &lt;code&gt;home&lt;/code&gt; 값이 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 그와 같은 &lt;code&gt;kind&lt;/code&gt; 관련해, 주소 데이터와 &lt;code&gt;127.0.0.1&lt;/code&gt; 을 . 두 번째 인스턴스 인 &lt;code&gt;loopback&lt;/code&gt; 은 &lt;code&gt;kind&lt;/code&gt; 값 &lt;code&gt;V6&lt;/code&gt; 으로 &lt;code&gt;IpAddrKind&lt;/code&gt; 의 다른 변형을 가지며 이와 관련된 주소 &lt;code&gt;::1&lt;/code&gt; 을 갖 습니다. 우리는 구조체를 사용하여 &lt;code&gt;kind&lt;/code&gt; 와 &lt;code&gt;address&lt;/code&gt; 값이 함께 있으므로 이제 변형이 값과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">여기서는 래핑 된 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현할 때만 구현이 래퍼에 존재한다고 말합니다 . &lt;code&gt;where&lt;/code&gt; 일부 유형의 구현하지 않기 때문에 절은 중요 &lt;code&gt;Clone&lt;/code&gt; 이 방법을받지 않습니다 따라서합니다.</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="translated">여기에서 &lt;code&gt;impl Trait&lt;/code&gt; 에서 부적절한 수명을 사용했습니다 . &lt;code&gt;impl Trait&lt;/code&gt; 은 fn 또는 impl 수준에서 바인딩 된 수명 만 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">16 진 정수</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">더 높은 수준의 동기화 개체</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">더 높은 수명주기</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">특성 직전에 더 높은 수명을 지정할 수도 있지만, 유일한 차이는 전체 매개 변수가 아닌 다음 특성의 끝까지 만 연장되는 수명 매개 변수의 범위입니다. 이 기능은 마지막 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">더 높은 특성의 한계</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">코드 생성 또는 최적화 방법에 영향을주는 컴파일러 힌트.</target>
        </trans-unit>
        <trans-unit id="410abe45925442482c6a1847631462e1f9e2aa9a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 거짓 일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 참일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">만세! 녹 1.5가 완료되었습니다! 그러나 6 주가 지났기 때문에 &lt;em&gt;다음&lt;/em&gt; 버전의 Rust, 1.6 의 새로운 베타 버전도 필요합니다 . 따라서 &lt;code&gt;beta&lt;/code&gt; 에서 &lt;code&gt;stable&lt;/code&gt; 브랜치가 나간 후 다음 버전의 &lt;code&gt;beta&lt;/code&gt; 브랜치가 &lt;code&gt;nightly&lt;/code&gt; 다시 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Deref 강제 변환이 돌연변이와 상호 작용하는 방법</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">두 가지 유형을 어떻게 비교할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">어떻게 &lt;code&gt;Eq&lt;/code&gt; 를 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">기본값을 어떻게 정의 할 수 있습니까? 당신은 &lt;code&gt;Default&lt;/code&gt; 을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 이 &lt;code&gt;Result&lt;/code&gt; 반환 한다는 것을 어떻게 알 수 있습니까? 우리는 볼 수 있었다 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 API 문서&lt;/a&gt; , 또는 우리는 컴파일러를 요청할 수 있습니다! &lt;code&gt;f&lt;/code&gt; 가 함수의 반환 유형 이 &lt;em&gt;아니라는&lt;/em&gt; 타입 주석을 제공 한 다음 코드를 컴파일하려고하면 컴파일러는 유형이 일치하지 않는다고 알려줍니다. 오류 메시지는 다음의 종류 무엇을 우리에게 말할 것이다 &lt;code&gt;f&lt;/code&gt; 는&lt;em&gt;것입니다&lt;/em&gt; . 해 봅시다! &lt;code&gt;File::open&lt;/code&gt; 의 반환 유형이 &lt;code&gt;u32&lt;/code&gt; 유형이 아니므로 &lt;code&gt;let f&lt;/code&gt; 문을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">이 책을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">시험을 쓰는 방법</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">사용자 지정 &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; 매크로 를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">하위 표현식의 값을 결합하여 표현식의 값을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">동시에 여러 코드 조각을 실행하는 스레드를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">이 문서를 읽는 방법</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">12 장에서이 두 기능을 사용하여 I / O 프로젝트를 개선하는 방법</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">그러나 &lt;code&gt;Vec&lt;/code&gt; 에 없는 인덱스에 액세스하려고하면 소프트웨어가 패닉 상태가됩니다! 너는 이것을 못해:</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">그러나주의해야합니다.이 방법은 &lt;code&gt;self&lt;/code&gt; 가 변경 가능할 것으로 예상합니다. 일반적으로 &lt;code&gt;RefCell&lt;/code&gt; 을 사용할 때는 그렇지 않습니다 . &lt;code&gt;self&lt;/code&gt; 가 변경 불가능한 경우, 대신 &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 메소드를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">그러나 전체 주문이없는 유형에 대해서는 다른 것을 별도로 구현할 수 있습니다. 예를 들어 부동 소수점 숫자의 경우 &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; 및 &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (IEEE 754-2008 섹션 5.11 참조).</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">그러나 프로그래머는 일반적으로 스레드 스케줄링에 대해 생각하지 않기 때문에 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; es 또는 동기화 루틴에 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">그러나 유형 기억 &lt;em&gt;함유 &lt;/em&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 반드시 동일한 레이아웃 아니다; Rust는 일반적으로 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 의 크기와 정렬이 동일 하더라도 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 의 필드가 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 와 동일한 순서를 보장하지 않습니다 . 또한 비트 값이 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 유효하기 때문에 컴파일러는 0이 아닌 / 틈새 채우기 최적화를 적용 할 수 없으므로 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">그러나 한 가지 경우가 있습니다 &lt;code&gt;!&lt;/code&gt; 구문은 전에 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 함수의 반환 유형 위치에서 본격적인 유형으로 안정화됩니다. 특히 두 가지 다른 함수 포인터 유형에 대한 구현이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">그러나 한 가지 경우가 있습니다 &lt;code&gt;!&lt;/code&gt; 구문은 전에 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 함수의 반환 유형 위치에서 전체 유형으로 안정화됩니다. 특히 두 가지 함수 포인터 유형에 대한 구현이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">그러나 IEEE-754의 2008 버전 이전에는 NaN 신호 비트를 해석하는 방법이 실제로 지정되지 않았다는 한 가지 경고가 있습니다. 대부분의 플랫폼 (특히 x86 및 ARM)은 2008 년에 궁극적으로 표준화 된 해석을 선택했지만 일부는 그렇지 않았습니다 (특히 MIPS). 결과적으로 MIPS의 모든 신호 NaN은 x86의 조용한 NaN이며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">그러나 &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 는 동적 상황에 가장 적합합니다. 이것은 모든 구성 요소를 미리 알고있을 때이를 수행하는 더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="translated">그러나 &lt;code&gt;dyn Trait&lt;/code&gt; 은 메서드가 각 구체적인 유형에 대해 중복되지 않으므로 &lt;code&gt;impl Trait&lt;/code&gt; / 일반 매개 변수 보다 작은 코드를 생성 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">그러나 더 나은 해결책은 유형과 특성을 완전히 명시 적으로 명명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">그러나 매크로 호출에서 후행 쉼표를 무시하는 규칙에 따라 후행 쉼표가있는 단일 인수는 여전히 튜플로 취급되지 않습니다. 필요한 경우 1 개의 튜플을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">그러나 특성의 일부인 관련 함수에는 &lt;code&gt;self&lt;/code&gt; 매개 변수 가 없습니다 . 동일한 범위의 두 유형이 해당 특성을 구현할 때 &lt;em&gt;정규화 된 구문&lt;/em&gt; 을 사용하지 않으면 Rust가 어떤 유형을 의미하는지 파악할 수 없습니다 . 예를 들어, 목록 19-19 의 &lt;code&gt;Animal&lt;/code&gt; 특성에는 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; , 구조체 &lt;code&gt;Dog&lt;/code&gt; 에 대한 &lt;code&gt;Animal&lt;/code&gt; 구현 및 &lt;code&gt;Dog&lt;/code&gt; 에 직접 정의 된 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">그러나 두 유형에 공통된 유형이있는 경우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">그러나, &lt;code&gt;a&lt;/code&gt; 여전히 참조하고 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 있었던 &lt;code&gt;b&lt;/code&gt; 것으로, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 상기 메모리 있도록 1보다 0의 카운트를 보유하고, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 힙 갖는다는 삭제되지 않을 것이다. 기억은 단지 1의 카운트로 영원히 거기에 앉을 것입니다. 이 참조주기를 시각화하기 위해 그림 15-4에서 다이어그램을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">그러나 이렇게 넓은 범위의 숫자를 표현할 수 있다는 것은 정밀도를 떨어 뜨립니다. 실수는 실수의 일부만 표현할 수 있고, 표현 가능한 근처의 수로 반올림 한 부동 소수점으로 계산할 수 있습니다. 예를 들어 &lt;code&gt;5.0&lt;/code&gt; 과 &lt;code&gt;1.0&lt;/code&gt; 은 &lt;code&gt;f32&lt;/code&gt; 로 정확하게 표현할 수 있지만 &lt;code&gt;1.0 / 5.0&lt;/code&gt; 은 &lt;code&gt;0.2&lt;/code&gt; 를 &lt;code&gt;f32&lt;/code&gt; 로 정확하게 표현할 수 없기 때문에 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; 가 됩니다 . 그러나 &lt;code&gt;println&lt;/code&gt; 으로 플로트를 인쇄 하고 친구들은 종종 중요하지 않은 숫자를 버립니다. &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; 는 &lt;code&gt;0.2&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="bc86d5089c69372edd80eafac68df3ec0dbaefb7" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note, however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">그러나 &lt;code&gt;alloc_excess&lt;/code&gt; 가 로컬로 리턴 한 용량을 추적하지 않으려는 클라이언트의 경우이 방법으로 유용한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">그러나 모든 기능에 많은 오류 검사가 있으면 장황하고 성 가실 것입니다. 다행스럽게도 Rust의 타입 시스템 (따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 할 수 있습니다. 함수에 특정 유형의 매개 변수가있는 경우 컴파일러가 이미 유효한 값을 가지고 있음을 알고 코드 논리를 진행할 수 있습니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 이 아닌 유형이있는 경우 프로그램 은 &lt;em&gt;아무것도&lt;/em&gt; 아닌 &lt;em&gt;것을&lt;/em&gt; 기대합니다 . 그러면 코드에서 &lt;code&gt;Some&lt;/code&gt; 과 &lt;code&gt;None&lt;/code&gt; 에 대해 두 가지 경우를 처리 할 필요가 없습니다.&lt;em&gt;&lt;/em&gt;변형 : 확실히 가치가있는 경우는 하나뿐입니다. 함수에 아무것도 전달하지 않는 코드는 컴파일되지 않으므로 런타임에 함수가 해당 사례를 확인할 필요가 없습니다. 또 다른 예는 &lt;code&gt;u32&lt;/code&gt; 와 같은 부호없는 정수 유형을 사용 하여 매개 변수가 음수가 아닌지 확인 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">그러나 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현 하면 대신 'copy semantics'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">그러나 &lt;code&gt;Super&lt;/code&gt; 가 객체 안전 하더라도 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 에서 파생되는 경우 &lt;code&gt;get_a()&lt;/code&gt; 메소드 는 함수에서 호출 될 때 알 수없는 유형의 객체를 반환합니다. &lt;code&gt;Self&lt;/code&gt; 유형 매개 변수를 사용하면 객체 안전 특성을 더 이상 안전하게 만들 수 없으므로 수퍼 특성을 지정할 때 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">그러나 이러한 유형을 계속 사용하려면 안전하지 않은 래퍼로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">그러나 구조체의 필드에 액세스하려면 필드 이름의 철자가 올바른지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">하지만 한 줄은 읽기 어렵 기 때문에 나누는 것이 가장 좋습니다. 이제이 라인이 무엇을하는지 논의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">그러나 하나의 긴 줄은 읽기가 어렵 기 때문에 나누는 것이 가장 좋습니다. 두 개의 메소드 호출에 대해 두 줄입니다. 이제이 라인이 무엇을하는지 논의 해 보자.</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">그러나이 장의 목적은 쉬운 길을 택하지 않고 배우는 것을 돕기위한 것입니다. Rust는 시스템 프로그래밍 언어이기 때문에 작업하려는 추상화 수준을 선택할 수 있으며 다른 언어에서 가능하거나 실용적인 것보다 낮은 수준으로 갈 수 있습니다. 기본 HTTP 서버 및 스레드 풀을 수동으로 작성하여 향후 사용할 상자 뒤에있는 일반적인 아이디어와 기술을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">그러나 첫 번째 솔루션을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">그러나 일부 고급 할당 방법 ( &lt;code&gt;alloc_one&lt;/code&gt; , &lt;code&gt;alloc_array&lt;/code&gt; )은 크기가 0 인 유형에 대해 잘 정의되어 있으며 선택적으로 지원할 수 있습니다. &lt;code&gt;Err&lt;/code&gt; 를 반환할지 또는 포인터 로 &lt;code&gt;Ok&lt;/code&gt; 를 반환 할지 여부는 구현 자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">그러나 때로는 라이브러리 사용자가 특정 상황에서 유효한 유형 세트를 확장 할 수 있기를 원합니다. 이를 달성하는 방법을 보여주기 위해 항목 목록을 반복하는 GUI (Graphical User Interface) 도구를 만들어 각 GUI 도구에 대한 일반적인 기술인 화면에 &lt;code&gt;draw&lt;/code&gt; 방법을 호출 합니다. GUI 라이브러리의 구조를 포함하는 &lt;code&gt;gui&lt;/code&gt; 라는 라이브러리 상자를 만듭니다 . 이 상자에는 &lt;code&gt;Button&lt;/code&gt; 또는 &lt;code&gt;TextField&lt;/code&gt; 와 같이 사람들이 사용할 수있는 일부 유형이 포함될 수 있습니다 . 또한 &lt;code&gt;gui&lt;/code&gt; 사용자는 그릴 수있는 고유 한 유형을 만들려고합니다. 예를 들어 한 프로그래머가 &lt;code&gt;Image&lt;/code&gt; 추가 하고 다른 프로그래머가 이미지 를 추가 할 수 있습니다. &lt;code&gt;SelectBox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">그러나 구조적 고정에는 몇 가지 추가 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">그러나 Rust 코드로 구문 분석 된 리터럴 토큰의 접미 부는 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">그러나 Rust 코드로 파싱 된 리터럴 토큰의 접미사는 제한됩니다. 숫자가 아닌 리터럴 토큰에서는 모든 접미사가 거부되고 숫자 리터럴 토큰은 아래 목록의 접미사에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;em&gt;하나&lt;/em&gt; 의 경우 에만 관심이있는 상황 에서는 &lt;code&gt;match&lt;/code&gt; 표현식이 약간 까다로울 수 있습니다 . 이 상황에서 Rust은 &lt;code&gt;if let&lt;/code&gt; 제공 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">그러나 null이 표현하려고한다는 개념은 여전히 ​​유용한 개념입니다. null은 현재 어떤 이유로 인해 유효하지 않거나없는 값입니다.</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">그러나 포인터가 실제로 할당 된 메모리를 가리 키지 않을 수 있습니다. 특히 &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt; 를 통해 용량이 0 인 &lt;code&gt;Vec&lt;/code&gt; 을 구성 하거나 빈 Vec에서 &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; 을 호출 하면 메모리가 할당되지 않습니다. 마찬가지로 &lt;code&gt;Vec&lt;/code&gt; 안에 0 크기의 유형을 저장하면 공간을 할당하지 않습니다. &lt;em&gt;이 경우 &lt;/em&gt;&lt;em&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 은 &lt;/em&gt;&lt;em&gt;&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 0을 &lt;/em&gt;&lt;em&gt;보고하지 않을 수 있습니다&lt;/em&gt; . &lt;code&gt;Vec&lt;/code&gt; 은 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; 경우에만 할당합니다 . 일반적으로 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;Vec&lt;/code&gt; 을 사용 하여 메모리를 할당 하고 다른 용도로 사용하려는 경우 (안전하지 않은 코드로 전달하거나 자체 메모리 기반 컬렉션을 작성하려는 경우)를 사용하여이 메모리를 할당 해제해야합니다. &lt;code&gt;from_raw_parts&lt;/code&gt; 를 사용하여 &lt;code&gt;Vec&lt;/code&gt; 을 복구 한 다음 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32()&lt;/code&gt; 는 입력 값이 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 유효한 값이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 는 이것을 무시하고 맹목적으로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; 로&lt;/a&gt; 캐스팅 하여 유효하지 않은 것을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;code&gt;char&lt;/code&gt; 인 것은 아닙니다 . &lt;code&gt;from_u32()&lt;/code&gt; 는 입력이 &lt;code&gt;char&lt;/code&gt; 에 대해 유효한 값이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;code&gt;char&lt;/code&gt; 인 것은 아닙니다 . &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 는 이것을 무시하고 맹목적으로 &lt;code&gt;char&lt;/code&gt; 로 캐스팅 하여 잘못된 것을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">그러나 두 번째 부분은 다릅니다. &lt;em&gt;가비지 수집기 (GC)&lt;/em&gt; 가있는 언어 에서 GC는 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 이에 대해 생각할 필요가 없습니다. GC가 없으면 메모리를 더 이상 사용하지 않을 때를 식별하고 요청하는 것처럼 메모리를 명시 적으로 반환하는 코드를 호출해야합니다. 이것을 올바르게하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어 버리면 기억이 낭비됩니다. 너무 일찍하면 유효하지 않은 변수가 생깁니다. 우리가 두 번 그렇게하면 버그이기도합니다. 우리는 정확히 하나의 &lt;code&gt;allocate&lt;/code&gt; 을 정확히 하나의 &lt;code&gt;free&lt;/code&gt; 와 페어링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">그러나 값이 메소드에서 자체적으로 변경되는 것이 유용하지만 다른 코드에서는 변경할 수없는 상황이 있습니다. 값의 메소드 외부의 코드는 값을 변경할 수 없습니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 내부 변경 기능을 사용할 수 있습니다. 그러나 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 차용 규칙을 완전히 극복하지 못합니다. 컴파일러의 차용 검사기는 이러한 내부 변경을 허용하며 차용 규칙은 런타임에 대신 확인됩니다. 규칙을 위반하면 &lt;code&gt;panic!&lt;/code&gt; 컴파일러 오류 대신.</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">그러나 함수 항목 에서 동일한 서명을 가진 &lt;a href=&quot;function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 로 &lt;a href=&quot;../type-coercions&quot;&gt;강제 변환&lt;/a&gt; 됩니다. 이는 함수 포인터가 직접 예상 될 때 함수 항목이 사용될 때뿐만 아니라 동일한 서명을 가진 다른 함수 항목 유형이 다른 경우에도 트리거됩니다. 같은 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;match&lt;/code&gt; 하는 무기 :</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">그러나이 테스트에는 다음과 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">그러나 &lt;code&gt;hello_macro&lt;/code&gt; 와 함께 사용하려는 각 유형에 대해 구현 블록을 작성해야합니다 . 우리는이 일을하지 않아도되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="translated">그러나이 &quot;zombie&quot;값은 안전한 코드에 노출되어서는 안되며이 함수는 두 번 이상 호출되지 않아야합니다. 값을 삭제 한 후 사용하거나 값을 여러 번 삭제하면 정의되지 않은 동작이 발생할 수 있습니다 ( &lt;code&gt;drop&lt;/code&gt; 가 수행 하는 작업에 따라 다름 ). 이는 보통 타입 시스템에 의해 방해되어 있지만, 사용자 &lt;code&gt;ManuallyDrop&lt;/code&gt; 는 컴파일러의 도움없이 그 보장을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="translated">그러나이 추가 권한에는 추가 책임이 따릅니다. 이제 건전성을 보장하는 것은 사용자의 몫입니다. &lt;code&gt;unsafe&lt;/code&gt; 키워드는 분명히 필요가 이것에 대해 걱정하는 것이 코드의 조각을 표시하여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">그러나 이것은 이상적인 해결책은 아닙니다. 프로그램이 1에서 100 사이의 값으로 만 작동하는 것이 절대적으로 중요하고이 요구 사항을 가진 많은 기능이있는 경우 모든 기능에서 이와 같이 확인하는 것이 번거롭고 영향을 줄 수 있습니다. 공연).</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">그러나이 패턴은 매우 일반적이므로 Rust는이를 위해 &lt;code&gt;while&lt;/code&gt; 루프 라고하는 내장 언어 구조를 가지고 있습니다. Listing 3-3은 &lt;code&gt;while&lt;/code&gt; : 프로그램을 세 번 반복하고 매번 카운트 다운 한 다음 루프 후에 다른 메시지를 인쇄하고 종료한다.</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">그러나 이것은 :</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">그러나 언어에는 두 개의 동시성 개념이 포함되어 있습니다. &lt;code&gt;std::marker&lt;/code&gt; 특성 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">그러나 &lt;code&gt;..&lt;/code&gt; 를 사용하면 명확해야합니다. 일치시킬 값과 무시해야 할 값이 확실하지 않은 경우 Rust는 오류를 표시합니다. Listing 18-25는 &lt;code&gt;..&lt;/code&gt; 를 모호하게 사용하는 예제를 보여 주므로 컴파일되지 않는다.</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">그러나 Listing 13-3의 문제점 중 하나를 다시 도입했다. 첫 번째 &lt;code&gt;if&lt;/code&gt; 블록 에서 클로저를 여전히 두 번 호출하고 있는데,이 경우 고가의 코드를 두 번 호출하고 사용자가 필요한 시간을 두 번 기다릴 것이다. 클로저 호출 결과를 보유하기 위해 &lt;code&gt;if&lt;/code&gt; 블록에 로컬 변수를 생성하여이 문제를 해결할 수 있지만 클로저는 다른 솔루션을 제공합니다. 우리는 그 해결책에 대해 조금 이야기 할 것입니다. 그러나 먼저 클로저 정의에 클로저 정의에 타입 주석이없는 이유와 클로저와 관련된 특성에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">그러나 실패가 예상되는 경우 &lt;code&gt;panic!&lt;/code&gt; 를 만드는 것보다 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 것이 더 적절합니다 ! 요구. 예를 들어 형식이 잘못된 데이터가 제공되는 파서 또는 속도 제한에 도달했음을 나타내는 상태를 반환하는 HTTP 요청이 있습니다. 이 경우 &lt;code&gt;Result&lt;/code&gt; 반환 하면 호출 코드를 처리하는 방법을 결정해야 할 가능성이 예상되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">그러나 특성 오브젝트를 사용 하여 특성을 구현 하는 &lt;em&gt;모든&lt;/em&gt; 오브젝트를 포함하는 테이블을 작성해야합니다 . 유형 매개 변수가있는 경우 이제 특성을 구현하는 모든 유형에 대한 구현을 추가해야하며 이론적으로 무한한 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">그러나 단일 유형을 반환하는 경우 &lt;code&gt;impl Trait&lt;/code&gt; 만 사용할 수 있습니다 . 예를 들어, &lt;code&gt;NewsArticle&lt;/code&gt; 또는 반환 형식이 &lt;code&gt;impl Summary&lt;/code&gt; 로 지정된 &lt;code&gt;Tweet&lt;/code&gt; 을 반환하는이 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">크고 작은 수백 개의 회사에서 다양한 작업을 위해 생산시 Rust를 사용합니다. 이러한 작업에는 명령 줄 도구, 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석 및 트랜스 코딩, 암호 화폐, 생물 정보학, 검색 엔진, 사물 인터넷 응용 프로그램, 기계 학습 및 Firefox 웹 브라우저의 주요 부분이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">쌍곡 코사인 함수.</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">쌍곡 사인 함수.</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">쌍곡 탄젠트 함수.</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">나는 그것을 10 억 달러의 실수라고 부릅니다. 당시에는 객체 지향 언어로 참조 할 수있는 최초의 포괄적 인 유형 시스템을 설계하고있었습니다. 필자의 목표는 컴파일러가 자동으로 검사를 수행하여 모든 참조 사용이 절대적으로 안전하도록하는 것이 었습니다. 그러나 구현하기가 쉽기 때문에 null 참조를 넣는 유혹에 저항 할 수 없었습니다. 이로 인해 수많은 오류, 취약성 및 시스템 충돌이 발생했으며, 이는 아마도 지난 40 년 동안 수십억 달러의 고통과 피해를 야기했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Rust Language Server를 사용한 IDE 통합</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">식별자 :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754는 부동 소수점의 비트 레이아웃을 매우 정확하게 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 섹션 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 섹션 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt; 에서 32 비트 정수로 정의됩니다 . 그것들은 보통 4 옥텟으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4 소켓 주소 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 명시된대로 &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; 주소&lt;/a&gt; 와 16 비트 포트 번호로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4 소켓 주소 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 명시된 바와 같이 &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 주소&lt;/a&gt; 와 16 비트 포트 번호로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 에서 128 비트 정수로 정의됩니다 . 일반적으로 8 개의 16 비트 세그먼트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6 소켓 주소는 &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; 주소&lt;/a&gt; , 16 비트 포트 번호, 트래픽 클래스, 흐름 레이블 및 범위 식별자를 포함하는 필드로 구성됩니다 (자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, 섹션 3.3&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6 소켓 주소 는 트래픽 클래스, 플로우 레이블 및 범위 ID를 포함하는 필드뿐만 아니라 &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 주소&lt;/a&gt; , 16 비트 포트 번호로 구성됩니다 (자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, 섹션 3.3&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">식별자 패턴</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 하위 패턴이 반박 할 수 없거나 하위 패턴이 지정되지 않은 경우 식별자 패턴은 반박 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">식별자 패턴은 변수와 일치하는 값을 바인딩합니다. 식별자는 패턴 내에서 고유해야합니다. 변수는 범위 내에서 같은 이름의 변수를 음영 처리합니다. 새 바인딩의 범위는 패턴이 사용되는 컨텍스트 (예 : &lt;code&gt;let&lt;/code&gt; 바인딩 또는 &lt;code&gt;match&lt;/code&gt; arm)에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">중복 코드를 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">&amp;epsilon; &amp;isin; LAST ( &lt;code&gt;uu ...&lt;/code&gt; )이면 LAST (M) = LAST ( &lt;code&gt;tt&lt;/code&gt; ) &amp;cup; (LAST ( &lt;code&gt;uu ...&lt;/code&gt; ) \ {&amp;epsilon;})입니다.</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt; 가 이전에 호출 된 경우 &lt;code&gt;VecDeque&lt;/code&gt; 의 모든 요소 는 첫 번째 슬라이스에 있고 두 번째 슬라이스는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 확장이 추가됩니다; 그렇지 않으면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; 가&lt;/a&gt; 없었다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ,이 밀어에 해당 &lt;code&gt;file_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 확장이 추가됩니다; 그렇지 않으면 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;file_name&lt;/code&gt; 을 누르는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt; 가 이전에 호출 된 경우 &lt;code&gt;VecDeque&lt;/code&gt; 의 모든 요소 는 첫 번째 슬라이스에 있고 두 번째 슬라이스는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;'static&lt;/code&gt; 다음 바인딩 어떤 일생에 사용되는 &lt;code&gt;'static&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">경우 &lt;code&gt;..&lt;/code&gt; 가 사용되지 않는, 모든 필드와 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;.create_new(true)&lt;/code&gt; 설정, &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;.create_new(true)&lt;/code&gt; 설정, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">경우 &lt;code&gt;Complete&lt;/code&gt; IS 다음 반환 된 발전기는 완전히 제공되는 값으로 완료되었습니다. 생성기가 다시 재개 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">&lt;code&gt;ForeignTrait&lt;/code&gt; 이 일부 외부 상자 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 특성 인 경우 다음 특성 &lt;code&gt;impl&lt;/code&gt; 이 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">만약 &lt;code&gt;Hello, world!&lt;/code&gt; 인쇄, 축하했다! 당신은 공식적으로 Rust 프로그램을 작성했습니다. 그것은 당신을 Rust 프로그래머로 만듭니다 &amp;ndash; 환영합니다!</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; 은 슬라이스의 크기보다 큰, 그것은 어떤 창을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">만약 &lt;code&gt;T: Drop&lt;/code&gt; , 호출 &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Arc&lt;/code&gt; 동일한 할당으로의 그 지점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 절대 시점은 동일하지.</target>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 할당으로의 그 지점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 할당으로의 시점 결코 동일하지.</target>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 같은 값으로 그 시점의 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 구현하지 않습니다 &lt;code&gt;Copy&lt;/code&gt; 사용 &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 의 구현은 &lt;code&gt;Copy&lt;/code&gt; , 그것은 사용에 더 확대됨에 될 수 &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 있다 &lt;code&gt;Sized&lt;/code&gt; 이 기능은 항상 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 FFI-안전하고 그렇습니다 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 열거되지 않습니다,이 함수를 호출하면 정의되지 않은 동작이 발생할 수 있지만, 반환 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8dca1b3ef01a1ffebdb81541f8580fb6c5190017" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified. Equally, if &lt;code&gt;T&lt;/code&gt; is an enum with more variants than &lt;code&gt;usize::MAX&lt;/code&gt; the return value is unspecified. Uninhabited variants will be counted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70442d0f7a75e13703c9f3f655e0ebf8ba235584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Ti&lt;/code&gt; can be coerced to the current target type &lt;code&gt;T_t&lt;/code&gt;, then no change is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 수신기를 리턴 할 때까지 각 주소로 시도됩니다. 리스너 작성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 리턴 된 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 소켓을 반환 할 때까지 각 주소로 시도됩니다. 소켓 생성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 여러 개의 주소를 얻을 수, &lt;code&gt;connect&lt;/code&gt; 연결이 성공할 때까지 각 주소로 시도됩니다. 어떤 주소도 연결에 성공하지 못하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;connect&lt;/code&gt; 기본 OS 기능 반환하지 오류 때까지 각 주소로 시도됩니다. 일반적으로 성공적인 &lt;code&gt;connect&lt;/code&gt; 호출은 포트에서 수신 대기중인 원격 서버가 있음을 지정하지 않으며, 이러한 오류는 첫 번째 송신 후에 만 ​​감지됩니다. OS가 지정된 각 주소에 대해 오류를 반환하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;self&lt;/code&gt; 의 접두사가 아닌 경우 (즉, &lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함) &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;self&lt;/code&gt; 의 접두사가 아닌 경우 (즉, &lt;a href=&quot;struct.path#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 반환) &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 의 바이트로 시작 &lt;code&gt;get&lt;/code&gt; , 우리가 다른 요청을 받았습니다 의미한다. 잠시 후 &lt;code&gt;else&lt;/code&gt; 블록에 코드를 추가하여 다른 모든 요청에 ​​응답합니다.</target>
        </trans-unit>
        <trans-unit id="65de2dbca56069ac5ddb30aad7c8e3292f2e853a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; panics, the panic is propagated to the caller, and the cell remains uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 이 반복자의 다음 값, 소비 및 반환. 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;k&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;k == len()&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 당황 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 보다 큰 &lt;code&gt;VecDeque&lt;/code&gt; 의 현재 길이,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 벡터의 현재 길이보다 큰 경우,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;mid&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;mid == len()&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 당황을하고, 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 개의 문자열이 반환, 마지막 문자열합니다 ( &lt;code&gt;n&lt;/code&gt; 번째 문자열은) 문자열의 나머지 부분을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각각의 추가 슬롯, 차이에 의해 확장되는 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;value&lt;/code&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 폐쇄 호출의 결과로 채워진 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 의 반환 값 은 &lt;code&gt;Vec&lt;/code&gt; 에서 생성 된 순서대로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 문자열의 현재 길이보다 큰이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">경우 &lt;code&gt;num&lt;/code&gt; 있었던 &lt;code&gt;Some(10)&lt;/code&gt; 대신에 제 1 암의 경기 가드했을 거짓 (10)는 녹는 다음 두 번째 팔이 없기 때문에 일치하는 것이다, 제 2 암에 갈 것이라고 이하 5보다이기 때문에 성냥 가드 따라서 &lt;code&gt;Some&lt;/code&gt; 변형 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 문자열을 숫자로 켤 수, 그것은 반환 &lt;code&gt;Err&lt;/code&gt; 오류에 대한 자세한 정보가 포함되어 값입니다. &lt;code&gt;Err&lt;/code&gt; 값이 일치하지 &lt;code&gt;Ok(num)&lt;/code&gt; 제의 패턴 &lt;code&gt;match&lt;/code&gt; 아암 있지만 일치 않는 &lt;code&gt;Err(_)&lt;/code&gt; 제 2 아암의 패턴. 밑줄 &lt;code&gt;_&lt;/code&gt; 은 포괄적 인 값입니다. 이 예에서는 어떤 정보가 내부에 있는지에 상관없이 모든 &lt;code&gt;Err&lt;/code&gt; 값 을 일치 시키려고 합니다. 따라서 프로그램은 두 번째 암의 코드를 &lt;code&gt;continue&lt;/code&gt; 실행 하여 &lt;code&gt;loop&lt;/code&gt; 의 다음 반복으로 이동하도록 프로그램에 지시합니다.또 다른 추측을 요청하십시오. 따라서 프로그램은 &lt;code&gt;parse&lt;/code&gt; 할 수있는 모든 오류를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 성공적으로 문자열을 숫자로 설정 할 수 있습니다, 그것은 반환됩니다 &lt;code&gt;Ok&lt;/code&gt; 결과 수를 포함 값입니다. 해당 &lt;code&gt;Ok&lt;/code&gt; 값은 첫 번째 팔의 패턴과 &lt;code&gt;match&lt;/code&gt; 하며 일치 표현식은 &lt;code&gt;parse&lt;/code&gt; 하여 &lt;code&gt;Ok&lt;/code&gt; 값 안에 넣은 &lt;code&gt;num&lt;/code&gt; 값만 반환합니다 . 그 숫자는 우리가 만들고 있는 새로운 &lt;code&gt;guess&lt;/code&gt; 변수 에서 원하는 위치에있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 절대, 현재의 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 가 &lt;code&gt;Unpin&lt;/code&gt; 유형을 참조하지 않으면 대신 &lt;code&gt;Pin::new&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; 이 절대 경로가 아닌 경우 &lt;code&gt;PATH&lt;/code&gt; 는 OS 정의 방식으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;self &amp;lt;= other&lt;/code&gt; : &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">경우 &lt;code&gt;self.value&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 코드에 저장된 폐쇄 호출 &lt;code&gt;self.calculation&lt;/code&gt; 을 ,에 결과를 저장 &lt;code&gt;self.value&lt;/code&gt; 향후 사용을 위해, 그리고뿐만 아니라 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 이미 규정 된 정렬을 충족 한 후 반환 &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 입니다 &lt;code&gt;Some(s)&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 것입니다 &lt;code&gt;Some(o)&lt;/code&gt; ,이 메소드의 반환 &lt;code&gt;Some((s, o))&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 입니다 &lt;code&gt;Some(s)&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 것입니다 &lt;code&gt;Some(o)&lt;/code&gt; ,이 메소드의 반환 &lt;code&gt;Some(f(s, o))&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 작성된 경우 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 사용하여 만든 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 되지, 반환 값이 있기 때문에, 적어도 한 경우,이 0을 반환합니다 &lt;code&gt;self&lt;/code&gt; 가치에 아직 점.</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 생성 된 경우 &lt;code&gt;None&lt;/code&gt; 이 반환 됩니다. 그렇지 않은 경우 &lt;code&gt;self&lt;/code&gt; 는 여전히 값을 가리 키 므로 리턴 된 값은 1 이상 입니다.</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 사용하여 만든 &lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 남아있는 강력한 포인터가없는 경우, 혹은이 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;self&lt;/code&gt; 를 만든 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">경우 &lt;code&gt;some_option_value&lt;/code&gt; 이 했다 &lt;code&gt;None&lt;/code&gt; 값이이 패턴과 일치하지 않을 것이라고 &lt;code&gt;Some(x)&lt;/code&gt; 패턴을 의미하는 것은 논박이다. 그러나 &lt;code&gt;let&lt;/code&gt; 문은 코드가 &lt;code&gt;None&lt;/code&gt; 값으로 수행 할 수있는 유효한 것이 없기 때문에 반박 할 수없는 패턴 만 허용 합니다. 컴파일 타임에 Rust는 반박 할 수없는 패턴이 필요한 반박 가능한 패턴을 사용하려했다고 불평합니다.</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 구현하지 않습니다 &lt;code&gt;Copy&lt;/code&gt; 사용 &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 가 구현 &lt;code&gt;Copy&lt;/code&gt; , 그것은 사용에 더 확대됨에 될 수 &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2fb513c03fabfd0da48ed321e5c2ec7c086217d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 있었다 &lt;code&gt;None&lt;/code&gt; 값 대신 &lt;code&gt;Some(5)&lt;/code&gt; 값은 밑줄에 일치하는 것, 그래서 처음 두 팔에 패턴이 일치하지 것이다. 밑줄의 패턴에 &lt;code&gt;x&lt;/code&gt; 변수를 도입하지 않았 으므로 표현식 의 &lt;code&gt;x&lt;/code&gt; 는 여전히 음영 처리되지 않은 외부 &lt;code&gt;x&lt;/code&gt; 입니다. 이 가상의 경우, &lt;code&gt;match&lt;/code&gt; 는 &lt;code&gt;Default case, x = None&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 1, 2, 3, 4, 또는 5이고, 제 1 아암이 일치한다. 이 구문은 &lt;code&gt;|&lt;/code&gt; 같은 생각을 표현하는 연산자; 대신 &lt;code&gt;1...5&lt;/code&gt; , 우리는 지정해야 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 를 사용한 경우 &lt;code&gt;|&lt;/code&gt; . 범위를 지정하는 것이 훨씬 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 1, 2, 3, 4, 또는 5이고, 제 1 아암이 일치한다. 이 구문은 &lt;code&gt;|&lt;/code&gt; 동일한 아이디어를 표현하는 연산자; 대신 &lt;code&gt;1..=5&lt;/code&gt; , 우리는 지정해야 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 사용한 경우 &lt;code&gt;|&lt;/code&gt; . 범위를 지정하는 것이 훨씬 더 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!</target>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">만약 &lt;em&gt;main.rs은&lt;/em&gt; 당신이었다 &quot;안녕하세요, 세계!&quot; 프로그램에서이 줄은 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에.</target>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">&lt;em&gt;main.rs&lt;/em&gt; 가 당신의 Hello, world 라면 ! 프로그램,이 줄은 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에.</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Rust 코드 &lt;em&gt;가&lt;/em&gt; 해당 문자열을 조사해야하는 경우 문자열 인코딩을 처리하는 다른 Rust API에서 일반적으로 수행되는 것과 같이 &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 유효하지 않은 시퀀스를 대체하여 유실 한 UTF-8로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Rust가 역 참조 강제를 구현하지 않았다면 Listing 15-12의 코드 대신 Listing 15-13의 코드를 작성하여 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 유형의 값으로 &lt;code&gt;hello&lt;/code&gt; 를 호출 해야한다 .</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">경우 &lt;code&gt;Read&lt;/code&gt; 어 기본 오버라이드 (override)하지 않는 &lt;code&gt;read_vectored&lt;/code&gt; 구현, 그것을 사용하는 코드는 모두 함께 방법을 방지 할 수 있으며, 유착은 더 높은 성능을 위해 하나의 버퍼에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Read&lt;/code&gt; 가 초기화되지 않은 메모리가 제대로 작동 할 수있는 어 보장, 그것은 호출해야 &lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">경우 &lt;code&gt;String&lt;/code&gt; 을 다시 할당하지 않습니다 그것에 요소를 추가 충분한 용량을 가지고 있습니다. 예를 들어 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">&lt;code&gt;Vacant(entry)&lt;/code&gt; 이 나오면 키 &lt;em&gt;를&lt;/em&gt; 찾지 &lt;em&gt;못한 것&lt;/em&gt; 입니다. 이 경우 유효한 조작은 항목에 값 을 &lt;code&gt;insert&lt;/code&gt; 하는 것입니다. 이 작업이 완료되면 비어있는 항목이 소비되고 삽입 된 값에 대한 변경 가능한 참조로 변환됩니다. 이를 통해 검색 자체의 수명을 넘어서 값을 추가로 조작 할 수 있습니다. 값이 삽입되었는지 여부에 관계없이 값에 대해 복잡한 논리를 수행해야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 메모리 &lt;em&gt;를&lt;/em&gt; 할당 한 경우 할당 된 메모리가 힙에 있고 (할당 자 Rust가 기본적으로 사용하도록 정의 된대로) 포인터가 &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 초기화되고 연속 된 요소를 순서대로 가리 킵니다. 슬라이스로 강제 변환 한 다음)&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 논리적으로 초기화되지 않은, 연속적인 요소.</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">경우 &lt;code&gt;Write&lt;/code&gt; 어 기본 오버라이드 (override)하지 않는 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 구현, 그것을 사용하는 코드는 모두 함께 방법을 방지 할 수 있으며, 유착은 더 높은 성능을 위해 하나의 버퍼에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="887bcf39fbff642c3b328187978b79bee02328d7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;const&lt;/code&gt; item contains some type that does not implement this trait, then that type either (1.) does not implement &lt;code&gt;PartialEq&lt;/code&gt; (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements &lt;em&gt;its own&lt;/em&gt; version of &lt;code&gt;PartialEq&lt;/code&gt; (which we assume does not conform to a structural-equality comparison).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">경우 &lt;code&gt;static&lt;/code&gt; 항목이 선언되어 &lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; 키워드, 다음은 프로그램에 의해 수정 될 수있다. 그러나 변경 가능한 &lt;code&gt;static&lt;/code&gt; 에 액세스 하면 다중 스레드 컨텍스트에서 데이터 경합과 같은 여러 가지 방식으로 정의되지 않은 동작이 발생할 수 있습니다. 따라서 변경 가능한 &lt;code&gt;static&lt;/code&gt; 에 대한 모든 액세스 에는 &lt;a href=&quot;keyword.unsafe&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; &lt;/a&gt; 블록이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">아직 존재하지 않아서 &lt;em&gt;새&lt;/em&gt; 파일을 만든 경우 &lt;code&gt;.create(true)&lt;/code&gt; 또는 &lt;code&gt;.create_new(true)&lt;/code&gt; 지정되어, 새로운 파일이 속성으로 선언 주어진다 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">바인딩 패턴이 명시되어 있지 않은 경우 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ref mut&lt;/code&gt; , 또는 &lt;code&gt;mut&lt;/code&gt; , 다음은 사용 &lt;em&gt;기본 바인딩 모드&lt;/em&gt; 변수가 바인딩되는 방법을 결정합니다. 기본 바인딩 모드는 이동 의미론을 사용하는 &quot;이동&quot;모드에서 시작합니다. 패턴을 일치시킬 때 컴파일러는 패턴 외부에서 시작하여 안쪽으로 작동합니다. 비 참조 패턴을 사용하여 참조를 일치시킬 때마다 자동으로 값을 역 참조하고 기본 바인딩 모드를 업데이트합니다. 참조는 기본 바인딩 모드를 &lt;code&gt;ref&lt;/code&gt; 로 설정합니다 . 변경 가능한 참조로 모드를 설정합니다 &lt;code&gt;ref mut&lt;/code&gt; 모드가 이미하지 않는 한 &lt;code&gt;ref&lt;/code&gt; 이 경우에 남아 &lt;code&gt;ref&lt;/code&gt; . 자동 역 참조 된 값이 여전히 참조 인 경우 역 참조되고이 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="translated">차용, 역 참조, 필드 또는 튜플 인덱싱 식에 확장 된 임시 범위가 있으면 해당 피연산자도 마찬가지입니다. 인덱싱 식에 확장 된 임시 범위가있는 경우 인덱싱 된 식에도 확장 된 임시 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 소문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 대문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">클린 셧다운이 필요한 경우 더 이상 소멸자가 남아 있지 않은 알려진 지점에서만이 기능을 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">const 함수가 &lt;a href=&quot;../const_eval#const-context&quot;&gt;const 컨텍스트&lt;/a&gt; 외부에서 호출되면 다른 함수와 구별 할 수 없습니다. 정규 함수로 할 수있는 const 함수로 자유롭게 무엇이든 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">자체 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야하는 경우 &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">동적 라이브러리 또는 동적으로 링크되는 실행 파일이 생성되는 경우 컴파일러는 사용 가능한 종속성을 rlib 또는 dylib 형식으로 조정하여 최종 제품을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">읽기 및 추가 액세스 권한으로 파일이 열린 경우, 파일을 연 후, 쓰기가 끝날 때마다 읽기 위치가 파일 끝에 설정 될 수 있습니다. 따라서 쓰기 전에 현재 위치를 저장하고 ( &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; 사용 ) 다음 읽기 전에 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">읽기 및 추가 액세스로 파일을 연 경우에는 파일을 연 후 및 모든 쓰기 후에 파일의 끝에서 읽을 위치를 설정할 수 있습니다. 따라서 쓰기 전에 현재 위치를 저장하고 ( &lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; 사용 ) 다음 읽기 전에 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">이 옵션을 설정 한 상태에서 파일을 성공적으로 열면 파일이 이미 있으면 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">부동 소수점 유형이 &lt;em&gt;고유&lt;/em&gt; 할 수있는 경우&lt;em&gt;&lt;/em&gt;주변 프로그램 컨텍스트에서 판별 경우 접미사 부동 소수점 리터럴에 해당 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">언어가 객체 지향 언어가되도록 상속을 받아야하는 경우 Rust는 언어가 아닙니다. 부모 구조체의 필드와 메소드 구현을 상속하는 구조체를 정의 할 방법이 없습니다. 그러나 프로그래밍 도구 상자에서 상속을받는 데 익숙한 경우 먼저 상속 이유에 따라 Rust에서 다른 솔루션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">테스트에서 메소드 호출이 실패하면 해당 메소드가 테스트중인 기능이 아니더라도 전체 테스트에 실패 할 수 있습니다. &lt;code&gt;panic!&lt;/code&gt; 때문에 ! 테스트가 실패로 표시되는 방법입니다. &lt;code&gt;unwrap&lt;/code&gt; 또는 &lt;code&gt;expect&lt;/code&gt; 호출 하면 정확히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;File::open_opts&lt;/code&gt; 호출의 일부로 새 파일이 작성되면 이 지정된 &lt;code&gt;mode&lt;/code&gt; 가 새 파일의 권한 비트로 사용됩니다. &lt;code&gt;mode&lt;/code&gt; 를 설정 하지 않으면 기본값 &lt;code&gt;0o666&lt;/code&gt; 이 사용됩니다. 운영 체제는 &lt;code&gt;umask&lt;/code&gt; 시스템으로 비트를 마스크 하여 최종 권한을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;OpenOptions::open&lt;/code&gt; 호출의 일부로 새 파일이 생성되면 이 지정된 &lt;code&gt;mode&lt;/code&gt; 가 새 파일에 대한 권한 비트로 사용됩니다. &lt;code&gt;mode&lt;/code&gt; 가 설정 되지 않은 경우 기본값 인 &lt;code&gt;0o666&lt;/code&gt; 이 사용됩니다. 운영 체제 는 최종 권한을 생성하기 위해 시스템의 &lt;code&gt;umask&lt;/code&gt; 로 비트를 마스킹합니다 .</target>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="translated">nul 바이트가 있고 마지막 요소가 없거나 nul ​​바이트가 없으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">명명 된 스레드에서 패닉이 발생하면 스레드 이름이 패닉 메시지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">프로그램에 산술 오버플로가 포함되어 있으면 프로그래머가 오류를 범한 것입니다. 다음 논의에서, 우리는 산술 오버 플로우와 랩핑 산술의 구별을 유지합니다. 첫 번째는 잘못된 반면 두 번째는 의도적 인 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">정적 키워드 가 &lt;code&gt;mut&lt;/code&gt; 키워드로 선언 되면 프로그램이이를 수정할 수 있습니다. Rust의 목표 중 하나는 동시성 버그가 발생하기 어렵게 만드는 것이며, 이는 경쟁 조건 또는 기타 버그의 매우 큰 원인입니다. 이러한 이유로, 가변 정적 변수를 읽거나 쓸 때 &lt;code&gt;unsafe&lt;/code&gt; 블록이 필요합니다. 동일한 프로세스에서 실행중인 다른 스레드와 관련하여 변경 가능한 정적에 대한 수정이 안전하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">정적 라이브러리가 생성되는 경우 모든 업스트림 종속성이 &lt;code&gt;rlib&lt;/code&gt; 에서 사용 가능해야합니다. 형식 . 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환 할 수없는 이유에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">일반 메소드 또는 특성이 동일한 것으로 간주되는 경우와 같이 둘 이상의 가능한 메소드가있는 단계에 도달하면 컴파일러 오류입니다. 이러한 경우 메소드 및 함수 호출을위한 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;명확한 함수 호출 구문&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">문자열에 연속 된 여러 구분 기호가 포함되어 있으면 출력에 빈 문자열이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">유형 &lt;code&gt;Item&lt;/code&gt; 에 특성 &lt;code&gt;Trait&lt;/code&gt; 의 연관 유형 &lt;code&gt;Assoc&lt;/code&gt; 이있는 경우 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 은 연관된 유형 정의에 지정된 유형의 별명 인 유형입니다. 또한 &lt;code&gt;Item&lt;/code&gt; 이 유형 매개 변수 인 경우 &lt;code&gt;Item::Assoc&lt;/code&gt; 을 형식 매개 변수에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">유형에 &lt;code&gt;PhantomPinned&lt;/code&gt; 가 포함 된 경우 기본적으로 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">모두 잘되면 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에 인쇄해야합니다. &lt;code&gt;cargo build&lt;/code&gt; 를 처음으로 실행 하면 Cargo는 최상위 레벨 &lt;em&gt;Cargo.lock에&lt;/em&gt; 새 파일을 작성합니다 . 이 파일은 프로젝트에서 정확한 버전의 종속성을 추적합니다. 이 프로젝트에는 종속성이 없으므로 파일이 약간 희박합니다. 이 파일을 수동으로 변경할 필요는 없습니다. 화물은 당신을 위해 그 내용을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">경우 &lt;code&gt;Alloc&lt;/code&gt; 구현이 돌아 선택 &lt;code&gt;Ok&lt;/code&gt; 이 경우 반환 포인터가 &quot;현재 할당&quot;으로 간주해야한다고 다음 (즉, 포인터가 0 크기의 액세스 블록을 의미한다). 이러한 할당 자에서 현재 할당 된 포인터를 입력으로 사용하는 &lt;em&gt;모든&lt;/em&gt; 메서드는 정의되지 않은 동작 &lt;em&gt;을&lt;/em&gt; 발생 &lt;em&gt;시키지 않고&lt;/em&gt; 크기가 0 인 포인터를 수용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">경우 &lt;code&gt;Err(e)&lt;/code&gt; 결과가 반환되는, 값 &lt;code&gt;e&lt;/code&gt; 바깥 쪽 범위의 리턴 타입 (그 자체가 구현해야하는 「랩」됩니다 &lt;code&gt;Try&lt;/code&gt; ). 특히 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; 이 반환됩니다. 여기서 &lt;code&gt;X&lt;/code&gt; 는 둘러싸는 함수의 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">는 IF &lt;code&gt;Occupied(entry)&lt;/code&gt; 산출되고, 그 키를 &lt;em&gt;한&lt;/em&gt; 발견했다. 이 경우, 사용자는 여러 가지 옵션이 있습니다 : 그들은 수 있습니다 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 점령 항목의 값을. 또한, 점유 된 항목을 해당 값에 대한 변경 가능한 참조로 변환하여 빈 &lt;code&gt;insert&lt;/code&gt; 케이스에 대칭을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">는 IF &lt;code&gt;rlib&lt;/code&gt; 의 파일이 생성되고, 그 상류 종속성에서 사용할 수있는 형식을 무엇에 아무런 제한이 없습니다. 단순히 모든 업스트림 의존성에서 메타 데이터를 읽을 수있는 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;기존&lt;/em&gt; 파일이 열립니다 &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; , 기존의 속성은 보존으로 선언 된 것들과 결합 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">I / O 오류가 발생하면 지금까지 읽은 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 있으며 길이가 적절하게 조정 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">실행 파일이 생성되고 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; 플래그가 지정되지 않은 경우 우선 &lt;code&gt;rlib&lt;/code&gt; 형식으로 종속성을 찾습니다 . rlib 형식으로 일부 종속성을 사용할 수없는 경우 동적 연결이 시도됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="45d869ce1ba972ba36ff54baa74eb31c5112c34d" translate="yes" xml:space="preserve">
          <source>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;wake&lt;/code&gt; on the clone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="translated">impl에 &lt;code&gt;#[may_dangle]&lt;/code&gt; 속성 이있는 일반 매개 변수가있는 경우 해당 impl은 &lt;code&gt;unsafe impl&lt;/code&gt; 로 선언되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">impl에 &lt;code&gt;#[may_dangle]&lt;/code&gt; 속성 이있는 일반 매개 변수가있는 경우 해당 impl은 `안전하지 않은 impl로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">주변 프로그램 컨텍스트에서 정수 유형을 &lt;em&gt;고유하게&lt;/em&gt; 판별 할 수있는 경우 접미사없는 정수 리터럴이 해당 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="translated">내장 함수가 &lt;code&gt;rustc_const_stable&lt;/code&gt; 속성 과 함께 &lt;code&gt;const fn&lt;/code&gt; 에서 사용되어야하는 경우 내장 속성도 &lt;code&gt;rustc_const_stable&lt;/code&gt; 이어야합니다 . 이러한 변경은 컴파일러 지원 없이는 사용자 코드에서 복제 할 수없는 언어로 기능을 베이크하므로 T-lang 협의없이 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">개인 항목 인 경우 현재 모듈과 해당 하위 항목에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">항목이 공개되면, 다음은 몇 가지 모듈에서 외부에서 액세스 할 수 &lt;code&gt;m&lt;/code&gt; 당신은 모든 항목의 상위 모듈에 액세스 할 수 있는지 &lt;code&gt;m&lt;/code&gt; . 다시 내보내기를 통해 항목의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">항목이 공개되면, 다음은 몇 가지 모듈에서 외부에서 액세스 할 수 &lt;code&gt;m&lt;/code&gt; 당신은 모든 항목의 부모 모듈에 액세스 할 수 있는지 &lt;code&gt;m&lt;/code&gt; . 재수출을 통해 항목의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="translated">반복기 어댑터가 패닉하면 반복기는 지정되지 않은 (그러나 메모리 안전) 상태가됩니다. 또한이 상태는 Rust 버전간에 동일하게 유지된다는 보장이 없으므로 당황한 반복자가 반환하는 정확한 값에 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 잠금 장치가 손상 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 뮤텍스가 중독 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="78ea9516ec8ea7a6ed978cbfe197fc08ae18d0c1" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우이 호출은 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우,이 호출은 뮤텍스가 획득되면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우, 뮤텍스를 획득하면이 호출은 실패를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로에있는 디렉토리로 지정하면 &lt;code&gt;path&lt;/code&gt; 가 존재하지 않으며, 그렇지 않으면 만들 수 없습니다. 디렉토리가 생성 될 때 (존재하지 않는 것으로 확인 된 후)에 대한 특정 오류 조건은 &lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt; 로 요약됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">다음 조건 중 하나라도 위반하면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이미 읽은 바이트는 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">둘 다없는 경우 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">둘 다 존재하지 않으면 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">dylib로 컴파일 된 경우 결과 .so는 C 라이브러리에서 링크 될 수 있으며 다른 라이브러리에서 온 것처럼 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">두 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 압축 된 반복자로부터 반환하지 않습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . 최초의 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;zip&lt;/code&gt; 단락 것이다 &lt;code&gt;next&lt;/code&gt; 두 번째 반복자에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">활성화되면 멀티 캐스트 패킷이 로컬 소켓으로 루프백됩니다. IPv6 소켓에는 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">활성화되면 멀티 캐스트 패킷이 로컬 소켓으로 루프백됩니다. 이것은 IPv6 소켓에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">언어가 객체 지향으로 간주되기 위해 캡슐화가 필수 요소 인 경우 Rust는 해당 요구 사항을 충족합니다. 다른 코드 부분에 &lt;code&gt;pub&lt;/code&gt; 을 사용 하거나 사용 하지 않는 옵션을 사용 하면 구현 세부 정보를 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">튜플 내부의 모든 유형이 다음 특성 중 하나를 구현하면 튜플 자체도이를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">일반 코드가 관련 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공 할 수있는 모든 유형에 &lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 경우 더 많은 유형이 안전하게 구현할 수 있으므로 AsRef &amp;lt;T&amp;gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="translated">제네릭 코드가 관련 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공 할 수있는 모든 유형에 대해 작동해야하는 경우 더 많은 유형이 안전하게 구현할 수 있으므로 [ &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; ] 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">위치가 지정되면 해당 위치의 요소에 대한 참조를 리턴하거나 범위를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">범위가 지정되면 해당 범위에 해당하는 하위 슬라이스를 반환하거나 범위 를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfe4ffb9dd92d20a6a4139ebde5c4444a81b450b" translate="yes" xml:space="preserve">
          <source>If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads. If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">그렇다면 반환하는 값 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">그렇지 않으면 아무 것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="translated">포인터를 정렬 할 수없는 경우 구현은 &lt;code&gt;usize::MAX&lt;/code&gt; 반환합니다 . 구현시 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;usize::MAX&lt;/code&gt; 반환 하는 것이 허용됩니다 . 알고리즘의 성능은 정확성이 아니라 여기서 사용 가능한 오프셋을 얻는 데 달려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">포인터를 정렬 할 수 없으면 구현에서 &lt;code&gt;usize::max_value()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">가능하면 가능한 각 유형 대체에 대한 함수를 작성하여 코드를 수동으로 변형하십시오. 예를 들어 특성을 사용하여이를 명확하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개 미만의 요소를 사용할 수있는 경우 &lt;code&gt;take&lt;/code&gt; 는 기본 반복기의 크기로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 생성 과 &lt;code&gt;mem::forget()&lt;/code&gt; 호출 사이에 더 많은 코드가 추가 되면 동일한 메모리가 &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;s&lt;/code&gt; 모두에서 처리되기 때문에 내부 패닉으로 인해 이중 해제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식 에 대해 동일한 팔에서 여러 패턴이 사용되는 경우 지정되지 않은 패턴이 드롭 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">필요한 경우 사용자 지정 대상 사양을 사용하여이 검사를 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c94321a1ed561693d40d9b66f1f46aeaaecd3c4" translate="yes" xml:space="preserve">
          <source>If neither of the above env vars are set, then &lt;code&gt;Backtrace::capture&lt;/code&gt; will be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">이러한 규칙 중 어느 것도 적용되지 않으면 특성의 경계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">사용자 정의 후크가 등록되지 않은 경우 기본 후크가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">지정된 유형의 자동 특성에 대해 명시 적 구현 또는 부정적인 구현이 작성되지 않은 경우 컴파일러는 다음 규칙에 따라 자동 구현을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="translated">강력한 포인터가 남아 있지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="translated">그렇지 않은 경우 한 번에 하나씩 클로저를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6f7fa92522a250a6d3be880c3209e2e00d855d4b" translate="yes" xml:space="preserve">
          <source>If not, try to compute a mutual supertype of &lt;code&gt;T_t&lt;/code&gt; and &lt;code&gt;Ti&lt;/code&gt;, which will become the new target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 다른 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fd66bf5358b1619dbf93c578d3488d32d0c0fca1" translate="yes" xml:space="preserve">
          <source>If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">일부 메서드 만 객체로부터 안전하지 않은 경우 특성 : 객체에 명시 적으로 사용할 수없는 것으로 표시하기 위해 &lt;code&gt;where Self: Sized&lt;/code&gt; 제한을 추가 할 수 있습니다 . &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 과 같은 다른 모든 구현자는이 기능을 계속 사용할 수 있습니다 ( Box &amp;lt;Trait&amp;gt;의 &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 한다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">우리의 프로젝트 만이 포함 진 상자 인 경우 &lt;em&gt;SRC / main.rs의&lt;/em&gt; 파일을하고 있지 않습니다 &lt;em&gt;SRC / lib.rs의&lt;/em&gt; 파일을, 우리는에서 통합 테스트를 작성할 수 없습니다 &lt;em&gt;테스트를&lt;/em&gt; 디렉토리에 정의 가져 기능 &lt;em&gt;/ 주요 SRC를 .rs&lt;/em&gt; 는 &lt;code&gt;use&lt;/code&gt; 문을 사용 하여 범위 내에 있습니다 . 라이브러리 상자 만 다른 상자가 사용할 수있는 기능을 노출합니다. 이진 상자는 자체적으로 실행되도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">요구 사항이 변경되고 &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 으로 이동할 수 있어야하는 경우 문제가 발생합니다. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 에서 포인터 &lt;code&gt;Owner&lt;/code&gt; 에 &lt;code&gt;Gadget&lt;/code&gt; 는 값 사이에주기를 도입합니다. 이는 참조 카운트가 0에 도달 할 수 없으며 메모리 누출이라는 ​​값이 영원히 할당 된 상태로 유지됨을 의미합니다. 이 문제를 해결하기 위해 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">요구 사항이 변경되고 &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 으로 이동할 수 있어야하는 경우 문제가 발생합니다. &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 의 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 는주기를 도입합니다. 이는 참조 횟수가 0에 도달 할 수 없으며 할당이 절대 파괴되지 않음을 의미합니다. 메모리 누수입니다. 이 문제를 해결하기 위해 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">구문 분석에 성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 안에 값을 반환하고 , 그렇지 않으면 문자열 형식이 잘못된 경우 내부에 특정한 오류를 반환&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 에&lt;/a&gt;. 오류 유형은 특성의 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">설정된 경우이 옵션은 Nagle 알고리즘을 비활성화합니다. 즉, 적은 양의 데이터 만 있더라도 세그먼트는 가능한 한 빨리 전송됩니다. 설정하지 않으면 데이터를 보낼 양이 충분해질 때까지 데이터가 버퍼링되므로 작은 패킷이 자주 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최대 인 경우 마지막 요소가 반환됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최소 인 경우 첫 번째 요소가 리턴됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">누군가 코드를 호출하고 의미가 맞지 않는 값을 전달하면 &lt;code&gt;panic!&lt;/code&gt; 을 호출하는 것이 가장 좋습니다 ! 라이브러리를 사용하는 사람에게 코드의 버그를 알려 주어 개발 중에 수정할 수 있도록합니다. 비슷하게, &lt;code&gt;panic!&lt;/code&gt; 제어 할 수없는 외부 코드를 호출하고 수정 방법이없는 잘못된 상태를 반환하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">우리의 라이브러리를 사용하여 누군가가 구현하기로 결정하면 &lt;code&gt;SelectBox&lt;/code&gt; 가지고 구조체 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , 및 &lt;code&gt;options&lt;/code&gt; 필드를 그들은 구현 &lt;code&gt;Draw&lt;/code&gt; 상의 특성 &lt;code&gt;SelectBox&lt;/code&gt; Listing 17-8에 표시된 것처럼 유형에서도 .</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 반환되며 여기서 지속 시간은 지정된 측정에서이 측정까지 경과 한 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;buf&lt;/code&gt; 에 읽고 추가 된 바이트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">성공하면이 함수는 읽은 총 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">소유권을 얻는 것이 옵션이 아닌 경우 인덱스를 사용하는 것도 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">해당 필드의 유형이 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 인 경우 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 하는 동안 연결이 끊어 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . 마찬가지로 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 를 시도하는 동안 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 연결이 끊어 지면 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; 를 반환합니다 . .</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">는 IF &lt;code&gt;documentation&lt;/code&gt; 환경 변수가 정의되지 않으며, 다음과 같은 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">는 IF &lt;code&gt;move&lt;/code&gt; 키워드를 사용, 모든 캡처를 위해, 이동에 의해 또는 &lt;code&gt;Copy&lt;/code&gt; 유형, 복사에 의해 관계없이의 차용이 작동할지 여부. &lt;code&gt;move&lt;/code&gt; 키워드는 일반적으로 폐쇄는 폐쇄 반품 새로운 스레드를 생성하는 데 사용되는 경우로 캡처 한 값을, 오래 살 수 있도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우] &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;core&lt;/code&gt; 크레이트의 매크로 ( &lt;code&gt;std&lt;/code&gt; 가 아닌 )가 형식화 문자열 및 일부 추가 인수와 함께 사용되었으며, 예를 들어 &lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수있는 메시지를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">는 IF &lt;code&gt;push_str&lt;/code&gt; 의 방법은 소유권했다 &lt;code&gt;s2&lt;/code&gt; , 우리는 마지막 줄에 그 값을 인쇄 할 수 없습니다. 그러나이 코드는 예상대로 작동합니다!</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">상기 중간 &lt;code&gt;self&lt;/code&gt; 파라미터 접두어 &lt;code&gt;mut&lt;/code&gt; , 그것을 사용하여 일반 파라미터 유사한 가변 변수된다 &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;식별자 패턴&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 작은 현재 파일의 크기보다, 다음 파일이 수축 될 것입니다. 그것은 현재 파일의 크기보다 큰 경우, 파일이 확장 될 것입니다 &lt;code&gt;size&lt;/code&gt; 와 0으로 채워 중간 데이터를 모두 가지고있다.</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">이때 액세스 권한을 부여 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 공유 액세스가 삭제 될 때 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">실제 유형이 드롭 접착제를 필요로하거나 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않으면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="translated">실제 유형에 drop glue가 필요하지 않거나 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않으면 이 함수의 반환 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">두 포인터간에 다른 주소가 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 배수가 아닌 경우 나누기 결과는 0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">배열에 32 개 이하의 요소가있는 경우 (위 참조) 배열 참조의 &lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 구현을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">Cargo가 사용자 환경에서 얻은 작성자 정보가 올바르지 않은 경우 파일에서 수정 한 후 다시 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼에 데이터가 없으면 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; 를&lt;/a&gt; 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼에 데이터가 없으면 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; 를&lt;/a&gt; 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2baf63139a4a500a73ca143a78e4d4794de4fa4c" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;poll&lt;/code&gt; returns &lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/a&gt;, then the future returns &lt;code&gt;Poll::Pending&lt;/code&gt;, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 2;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">용량이 &lt;code&gt;usize&lt;/code&gt; 오버플 로되거나 할당자가 오류를보고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">용량이 초과되거나 할당자가 실패를보고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">자식이 종료되면 &lt;code&gt;Ok(Some(status))&lt;/code&gt; 가 반환됩니다. 현재 종료 상태를 사용할 수 없으면 &lt;code&gt;Ok(None)&lt;/code&gt; 이 반환됩니다. 오류가 발생하면 해당 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자식 스레드가 패닉하면 패닉에 주어진 매개 변수와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자식 스레드 패닉 이 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; 하면 panic에 지정된 매개 변수와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">클로저가 이동중인 값보다 오래 지속될 수없는 경우 이동하는 대신 참조를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">클로저가 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; 반환하면 해당 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 맵에서 제거되고 양보됩니다. 클로저가 false를 반환하거나 패닉이 발생하면 요소가지도에 남아 있으며 양보되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 목록에 유지되며 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 벡터에 남아 있고 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 참을 반환하면 값이 제거되고 양보됩니다. 클로저가 false를 반환하면 값은 목록에 남아 있고 반복기에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="214ba23b863f161492d3f9635dec38066733211c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] 슬라이스 와 함께 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 유효하지 않은 UTF-8 시퀀스를 &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 바꾸고 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 를 결과와 함께 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 슬라이스를 리턴합니다 . 그렇지 않으면 UTF-8 유효성 검사가 실패한 위치에 대한 세부 정보가 포함 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 슬라이스를 반환합니다 . 그렇지 않으면 UTF-8 유효성 검사가 실패한 위치에 대한 세부 정보와 함께 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">해당 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 가 연결을 끊었 거나이 호출이 차단되는 동안 연결이 끊어지면이 호출은 깨어나 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환 하여이 채널에서 더 이상 메시지를 수신 할 수 없음을 나타냅니다. 그러나 채널이 버퍼링되므로 연결 끊기 전에 전송 된 메시지는 여전히 제대로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="91ebc4eb9040370bb60e1b55cb245ed551a2b766" translate="yes" xml:space="preserve">
          <source>If the cursor is currently pointing to the &quot;ghost&quot; non-element then no element is removed and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4624b3463b579ff38cd7090e939e0664781afc4a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the entire contents of the &lt;code&gt;LinkedList&lt;/code&gt; are moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d335a3b2bd9233a3fbdf7c96e469f75d1c5e365d" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31375a5dbf525938d61772845c72aab093fab9cf" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the front of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58963dd2948fd819f86fd5e461e02e99ecc3a20a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f945e6d3050ed5d918eb8a5e109487061da86ff" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the start of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9708432e377fc3315ff2743a227e5ee6ae976fb7" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a515e2eb729ab1875351c8ecfe7942b25cd004cc" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bf96ffdc655962850c81ce839b17c859f11a67" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825c50dec4e26dcdffad5ec9a6866af450b9f9e9" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">이 스트림의 데이터가 유효한 UTF-8 이 &lt;em&gt;아닌&lt;/em&gt; 경우 오류가 리턴되고 &lt;code&gt;buf&lt;/code&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 정의가 제어 할 수있는 경우 가장 간단한 해결책은 데이터를 가변적으로 캡처하는 것입니다. Fn 대신 FnMut을 사용하도록 &lt;code&gt;foo&lt;/code&gt; 를 정의하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">대상 유형이 현재 상자의 일부가 아닌 경우에 당신은 구현할 수 없습니다 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 직접. 예를 들어 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드에 도달 할 수 없다는 결정이 틀린 것으로 판명되면 프로그램은 즉시 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 종료됩니다 ! .</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복기의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현하지 않거나 반복 된 요소를 메모리에 유지하지 않으려면 대신 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt; 함수 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현하지 않거나 반복 된 요소를 메모리에 유지하지 않으려면 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복기의 요소 유형이 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; 을&lt;/a&gt; 구현 하고 소스 요소를 메모리에 유지하는 것이 괜찮다면 대신 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt; 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현 하고 소스 요소를 메모리에 유지하는 것이 좋다면 대신 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">환경 변수가 정의되어 있지 않으면 컴파일 오류가 발생합니다. 컴파일 오류를 발생시키지 않으려면 &lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;대신 매크로.</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">실행 파일이 심볼릭 링크를 통해 호출 된 경우 일부 플랫폼은 심볼릭 링크의 경로를 반환하고 다른 플랫폼은 심볼릭 링크 대상의 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">이들 강요 부위 중 하나에서의 발현이 강요-전파 발현 인 경우, 그 발현의 관련 하위-발현도 강요 부위이다. 전파는이 새로운 강제 사이트에서 반복됩니다. 전파 표현 및 관련 하위 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">기능이 승인되면 Rust 저장소에서 문제가 열리고 누군가가이를 구현할 수 있습니다. 잘 구현 한 사람은 처음에 기능을 제안한 사람이 아닐 수도 있습니다! 구현이 준비되면 &lt;a href=&quot;#unstable-features&quot;&gt;&quot;불안정한 기능&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기능 게이트 뒤 의 &lt;code&gt;master&lt;/code&gt; 브랜치에 도달 합니다.</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">파일이 이미 존재하면 파일을 쓸 때 파일을 자르지 않고 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">첫 번째 요소가 일치하면 빈 슬라이스가 반복자가 반환 한 첫 번째 항목이됩니다. 마찬가지로 슬라이스의 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 용량이 &lt;code&gt;0&lt;/code&gt; 이면 할당이 발생하지 않으며이 방법은 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 용량이 &lt;code&gt;0&lt;/code&gt; 이면 할당이 발생하지 않으며이 방법은 &lt;a href=&quot;struct.string#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">주어진 클로저 가 동일한 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;code&gt;call_once&lt;/code&gt; 를 재귀 적으로 호출 하는 경우 정확한 동작이 지정되지 않은 경우 허용되는 결과는 패닉 또는 교착 상태입니다.</target>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">지정된 클로저 가 동일한 &lt;code&gt;Once&lt;/code&gt; 인스턴스에서 &lt;code&gt;call_once&lt;/code&gt; 를 재귀 적으로 호출 하는 경우 정확한 동작이 지정되지 않으면 허용되는 결과는 패닉 또는 교착 상태입니다.</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">입력이 NaN이 아닌 경우 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">항목이 함수이면 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">항목이 수정되면 최악의 시간 복잡도는 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; ))이고 그렇지 않으면 &lt;em&gt;O&lt;/em&gt; (1)입니다.</target>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">항목이 현재 모듈에 정의되어 있지 않으면 다음 과 같이 &lt;code&gt;use&lt;/code&gt; 문을 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">가져 오는 항목이 현재 모듈의 일부 수퍼 모듈에 정의되어 있지 않으면 공용으로 선언해야합니다 (예 : &lt;code&gt;pub fn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">반복기가 부분적으로 만 사용되거나 전혀 사용되지 않는 경우 나머지 각 요소는 여전히 클로저의 대상이되고 true를 반환하면 제거되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">반복기가 부분적으로 만 사용되거나 전혀 사용되지 않는 경우 나머지 각 값은 여전히 ​​닫히고 true를 반환하면 제거되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="translated">조각의 마지막 요소가 일치하면 해당 요소는 이전 조각의 종결 자로 간주됩니다. 해당 슬라이스는 반복자가 반환하는 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="translated">문자열의 마지막 요소가 일치하면 해당 요소는 이전 하위 문자열의 종결 자로 간주됩니다. 해당 하위 문자열은 반복자가 반환하는 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="translated">길이가 일치하지 않으면 입력이 &lt;code&gt;Err&lt;/code&gt; 로 돌아옵니다 .</target>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">스레딩과 같이 참조의 수명이 충분하지 않으면 &lt;code&gt;Arc&lt;/code&gt; 를 사용하여 참조 카운트 값을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴됩니다. 가드가 떨어지면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 잠금이 해제 될 때 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">메인 스레드 패닉이 발생하면 모든 스레드가 종료되고 코드 &lt;code&gt;101&lt;/code&gt; 로 프로그램이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">맵에이 키가있는 경우 값이 업데이트되고 이전 값이 반환됩니다. 하지만 키는 업데이트되지 않습니다. 이것은 동일하지 않고 &lt;code&gt;==&lt;/code&gt; 일 수있는 유형에 중요 합니다. 자세한 내용은 &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;모듈 수준 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">지도에이 키가 있으면 값이 업데이트되고 이전 값이 반환됩니다. 그러나 키는 업데이트되지 않습니다. 이것은 동일하지 않고 &lt;code&gt;==&lt;/code&gt; 일 수있는 유형에 중요 합니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">명명 환경 변수 컴파일시에 존재하는 경우, 이러한 유형의 표현으로 확장 할 &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 그 값이 &lt;code&gt;Some&lt;/code&gt; 환경 변수의 값을. 환경 변수가 없으면 &lt;code&gt;None&lt;/code&gt; 으로 확장됩니다 . 이 유형에 대한 자세한 내용 은 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">패턴의 요소 수가 튜플의 요소 수와 일치하지 않으면 전체 유형이 일치하지 않으며 컴파일러 오류가 발생합니다. 예를 들어, 목록 18-5는 세 개의 요소가있는 튜플을 두 개의 변수로 구조화하려는 시도를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0d2c1202b42295052cad83d3a70ac58e5c8cc86e" translate="yes" xml:space="preserve">
          <source>If the number of hardware threads is not known for the target platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">나노초의 수가 10 억을 초과하면 (초당 나노초의 수) 제공된 초로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="c7b893dcc899fca09569911e017ff49f116f8bab" translate="yes" xml:space="preserve">
          <source>If the option already contains a value, the old value is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">경로가 일반 파일 인 경우 파일 이름입니다. 디렉토리 경로 인 경우 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 순방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 순방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="translated">패턴이 &lt;code&gt;let&lt;/code&gt; 문이 연장 패턴 다음 초기화 표현의 임시 범위가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">술어가 true이면, &lt;code&gt;cfg&lt;/code&gt; 속성 이없는 것으로 재 작성됩니다 . 술어가 false 인 경우 소스 코드에서 해당 내용이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">프로세스가 신호에 의해 종료 된 경우 해당 신호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 과도하게 제한하는 경우 정적 유형 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본값은 &lt;code&gt;f64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본적으로 부호있는 32 비트 정수 &lt;code&gt;i32&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">프로그램 경로가 상대적인 경우 (예 : &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ) 부모의 작업 디렉토리 또는 &lt;code&gt;current_dir&lt;/code&gt; 과 관련하여 해석해야하는지 모호합니다 . 이 경우의 동작은 플랫폼에 따라 다르고 불안정하므로 &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; 프로그램 을 사용 하여 절대 프로그램 경로를 얻는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">수신기 입력이있는 경우 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , 그 다음에 기준의 수명 &lt;code&gt;Self&lt;/code&gt; 모두 생략 된 출력 유효 기간 파라미터에 할당된다.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">반복이 0 번 일치 할 수 있으면 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; ), 이후에 오는 것은 무엇이든 따라 올 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">반복이 여러 번 반복 될 수있는 경우 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; ) 내용이 스스로 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">반복에 구분 기호가 포함 된 경우 해당 구분 기호는 반복 내용을 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">이 방법의 결과가 동일한 아키텍처에 의해서만 조작된다면, 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 합니다. 반환 값이 &lt;code&gt;0&lt;/code&gt; 이면 일반적으로 기본 개체가 더 이상 바이트를 받아 들일 수 없으며 앞으로는 더 이상 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">반환 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt; 이 보장되어야합니다 . 반환 값 &lt;code&gt;0&lt;/code&gt; 은 일반적으로 기본 개체가 더 이상 바이트를받을 수없고 앞으로도 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">이 메소드의 리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 보장되어야합니다 . &lt;code&gt;n&lt;/code&gt; 이 아닌 n 값은 버퍼 &lt;code&gt;buf&lt;/code&gt; 가이 소스의 &lt;code&gt;n&lt;/code&gt; 바이트 데이터 로 채워 졌음을 나타냅니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 경우 두 시나리오 중 하나를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">탐색 작업이 성공적으로 완료되면이 메서드는 스트림 시작 부분에서 새 위치를 반환합니다. 이 위치는 나중에 &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 항목이 업데이트되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">세트에이 값이 없으면 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">슬라이스가 &lt;code&gt;size&lt;/code&gt; 보다 짧은 경우 :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">슬라이스가 정렬되면 첫 번째로 반환 된 슬라이스에 중복이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">소켓이 연결되어 있지 않으면 &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; 오류 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 끝나지 않는 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 시작하지 않으면 &lt;code&gt;prefix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">패턴과 문자열의 끝 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;Some&lt;/code&gt; 접미사가 제거 된 문자열로 반환됩니다. &lt;code&gt;trim_end_matches&lt;/code&gt; 와 달리 메서드는 접미사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">문자열이 &lt;code&gt;prefix&lt;/code&gt; 패턴으로 시작 하면 &lt;code&gt;Some&lt;/code&gt; 은 접두사가 제거 된 부분 문자열과 함께 반환됩니다. &lt;code&gt;trim_start_matches&lt;/code&gt; 와 달리 메서드는 접두사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 특성 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어진 경우 해당 유형의 객체를 확실히 반환 하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">특성 &lt;code&gt;Trait&lt;/code&gt; 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어 졌기 때문에 괜찮습니다. 형식이 해당 형식의 개체를 확실히 반환 .</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">특성에 수명 한계가없는 경우 수명은 표현식에서 유추되며 &lt;code&gt;'static&lt;/code&gt; 표현식 외부에서 정적 입니다.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">특성이 단일 수명 &lt;em&gt;한계&lt;/em&gt; 로 정의 &lt;em&gt;된&lt;/em&gt; 경우 해당 한계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">trait 객체가 제네릭 형식의 형식 인수로 사용되는 경우 포함 형식을 먼저 사용하여 바운드를 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 유형 중 하나로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 문법에 의해 생성되는 유형으로 제한됩니다 (여기서 &lt;code&gt;'lt&lt;/code&gt; 임의의 수명을 나타냄).</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">실수로 형식 매개 변수가 포함 된 경우 아래에 표시된 것처럼 형식 매개 변수를 간단히 제거하면이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;code&gt;Unpin&lt;/code&gt; , &lt;code&gt;Pin::get_mut&lt;/code&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 작성 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 액세스 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 쓰기 시간을 지원하지 않으면 반환 된 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 지정되지 않은 꼬리면 가 다음 :</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">사용자가 선호하는 색상을 지정하면 해당 색상이 배경색입니다. 오늘이 화요일이면 배경색이 녹색입니다. 사용자가 나이를 문자열로 지정하고 숫자로 구문 분석 할 수있는 경우 숫자 값에 따라 색상이 자주색 또는 주황색입니다. 이러한 조건 중 어느 것도 해당되지 않으면 배경색이 파란색입니다.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">사용자가 고강도 운동을 원한다면 몇 가지 추가 논리가 있습니다. 앱에서 생성 된 난수 값이 3이면 앱은 휴식과 수화를 권장합니다. 그렇지 않으면 복잡한 알고리즘을 기반으로 몇 분 동안 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌린 다음 이동해야하는 경우 범위가 지정된 블록을 사용하여 빌림의 수명을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌려야하는 경우 범위가 지정된 블록을 사용하여 빌려주기를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">패턴 가드에서 값을 사용하는 경우 복제본을 사용해도 소유권이 이동하지 않으므로 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">벡터가 정렬되면 모든 복제본이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="translated">여러 유형이 관련된 경우, 이들과 상호 작용하는 유일한 방법은 트레이 트의 인터페이스를 통하는 것이며, 동적 디스패치에 의존해야하는 것도 허용 가능 &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;합니다&lt;/a&gt; . &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; 또는 &lt;code&gt;Arc&lt;/code&gt; 와 같은 다른 컨테이너 유형과 .</target>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="translated">다른 것이 없다면 &lt;code&gt;Rc&lt;/code&gt; 이 할당에 대한 Rc 포인터&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 대한 포인터는 연결 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">이 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 없으면 이 값에 대한 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터의 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 새 할당을 만들고 내부 값에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 하여 고유 한 소유권을 보장합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가 &lt;code&gt;make_mut&lt;/code&gt; 는 고유 한 소유권을 보장하기 위해 내부 값에서 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 새 할당에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 있으면 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 방식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">단일 유형이 관련된 경우 &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">포함 유형에서 고유 한 경계가있는 경우 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">매개 변수에 사용 된 수명이 정확히 하나 (필요한지 여부) 인 경우 해당 수명은 &lt;em&gt;모든&lt;/em&gt; 생략 된 출력 수명에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">포함 유형에서 둘 이상의 바운드가있는 경우 명시 적 바운드를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">첨부 데이터가없는 경우에 &lt;em&gt;임의의&lt;/em&gt; 열거의 변형 후 판별 직접 선택 및 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 가 삭제 될 때 버퍼에 여전히 부분 라인이 있으면 해당 내용을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt; &lt;code&gt;last_os_error&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt; &lt;code&gt;from_raw_os_error&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;last_os_error&lt;/code&gt; 또는 &lt;code&gt;from_raw_os_error&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환하고, 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 소문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 대문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 소문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 대문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 가 특별한 고려 사항 (예 : 다중 &lt;code&gt;char&lt;/code&gt; )을 필요로하는 경우 반복기 는 &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; 에&lt;/a&gt; 의해 제공된 &lt;code&gt;char&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장이 여러분의 관심을 불러 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;일으켰고&lt;/a&gt; 자신 만의 스마트 포인터를 구현하고 싶다면 &amp;ldquo;The Rustonomicon&amp;rdquo; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장에서 관심을 끌고 자신 만의 스마트 포인터를 구현하려는 경우 &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;Rustonomicon&amp;rdquo;&lt;/a&gt; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;을 발견하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">이 함수에 임의의 I / O 형식 또는 기타 오류가 발생하면 오류 변형이 반환됩니다. 오류가 리턴되면 읽은 바이트가 없음을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;code&gt;Ok(0)&lt;/code&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">이 함수가 오류를 반환하면 읽은 바이트 수는 지정되지 않지만 버퍼를 완전히 채우는 데 필요한 것보다 더 이상 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">이것이 버퍼링 된 채널 인 경우, 현재 버퍼가 가득 찼습니다. 이것이 버퍼링 된 채널이 아닌 경우 , 데이터를 획득 할 수있는 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">이것이 옵션이 아닌 경우 유형 매개 변수를 다른 특성 오브젝트로 바꾸는 것을 고려하십시오 (예 &lt;code&gt;T: OtherTrait&lt;/code&gt; 인 경우 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). 이 방법에 제공하려는 유형의 수가 제한되어 있으면 다른 유형의 방법을 수동으로 나열 해보십시오.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">이번이 처음 인 경우 표준 라이브러리에 대한 문서가 우연히 사용되도록 작성되었습니다. 재미있는 것을 클릭하면 일반적으로 흥미로운 장소로 연결됩니다. 여전히 놓치고 싶지 않은 중요한 것들이 있으므로 표준 라이브러리와 설명서를 둘러보십시오.</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 리턴 하면 메모리 블록의 소유권이이 할당 자에게 전송되지 않고 메모리 블록의 내용이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Ok(addr)&lt;/code&gt; 리턴하면 , 리턴 된 &lt;code&gt;addr&lt;/code&gt; 은 &lt;code&gt;layout&lt;/code&gt; 인스턴스를 보유하기에 적합한 스토리지 블록을 가리키는 널이 아닌 주소 입니다.</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 널을 리턴하면, 메모리 블록의 소유권이이 할당 자로 전송되지 않았으며 메모리 블록의 내용은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">이로 인해 여러 후보가 발생하면 오류가 발생하며 수신자는 메소드를 호출하기 위해 적절한 수신자 유형 으로 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;변환&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">이것이 &lt;code&gt;Err&lt;/code&gt; 을 리턴하면 , 메모리 블록은 여전히 ​​원래 (더 큰) &lt;code&gt;layout&lt;/code&gt; 나타내는 것으로 간주됩니다 . 다른 곳에서 재사용하기 위해 블록을 조각하지 않았으며 메모리 블록의 소유권이 이전되지 않았으며 메모리 블록의 내용이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조되는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 해제되었거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 메소드의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 , 그 크기의 레이아웃과 &lt;code&gt;layout&lt;/code&gt; 과 같은 정렬의 데이터를 전달하는데 사용될 수 있다고 주장했다 . (할당자는 후속 블록 또는 가상 메모리 트릭을 포함하도록 메모리 블록을 확장하는 등의 작업을 수행하기 위해 노력을 기울일 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 따라서 더 작은 레이아웃의 데이터를 전달하는 데만 사용될 수 있다고 주장했습니다 . (할당자는이를 활용하여 다른 곳에서 재사용 할 수 있도록 블록의 일부를 잘라낼 수 있습니다.) 더 작은 레이아웃 내에서 블록의 잘린 내용은 변경되지 않으며 블록의 소유권이 이전되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면, &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 할당 해제되었거나 할당되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 방법의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자로 전송 된 것입니다. 메모리는 할당 해제되거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주되어야합니다 (물론이 메서드의 반환 값을 통해 호출자에게 다시 전송되지 않는 한). 새 메모리 블록은 &lt;code&gt;layout&lt;/code&gt; 으로 할당 되지만 &lt;code&gt;size&lt;/code&gt; 는 &lt;code&gt;new_size&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="translated">이 슬라이스가 분할되지 않은 경우이 메서드는 일종의 이진 검색을 수행하므로 반환 된 결과는 지정되지 않고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구문을 사용하는 경우 인쇄 할 문자 수가 실제 오브젝트보다 형식화되기 때문에 문자 수는 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하는 경우이 함수는 패닉, 래핑 또는 포화 상태가 될 수 있습니다. 제안 된 동작은 디버그 어설 션이 활성화되면 패닉 상태가되고 그렇지 않으면 래핑되거나 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">일치하는 두 요소가 바로 인접 해 있으면 그 사이에 빈 조각이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">우리가하면 &lt;em&gt;않는&lt;/em&gt; 깊이의 힙 데이터를 복사 할 &lt;code&gt;String&lt;/code&gt; 뿐 아니라 스택 데이터, 우리라는 일반적인 방법 사용할 수 있습니다 &lt;code&gt;clone&lt;/code&gt; . 5 장에서 메소드 구문에 대해 설명하지만 메소드는 많은 프로그래밍 언어에서 공통적 인 기능이므로 이전에 본 적이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">이 코드를 지금 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">오류를 계속 읽으면 다음과 같은 유용한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">유형의 정의를 제어하면 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 직접 &lt;code&gt;Clone&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">여기에 형식 주석을 추가하지 않으면 Rust에 다음 오류가 표시됩니다. 이는 컴파일러가 사용하려는 형식을 알기 위해 더 많은 정보가 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 함수를 &lt;code&gt;Copy&lt;/code&gt; 특성 을 구현하는 유형 으로 제한하지 않으려면 &lt;code&gt;T&lt;/code&gt; 대신 &lt;code&gt;Copy&lt;/code&gt; 대신 특성 바인딩 &lt;code&gt;Clone&lt;/code&gt; 를 갖도록 지정할 수 있습니다. 그런 다음 &lt;code&gt;largest&lt;/code&gt; 함수가 소유권을 갖기를 원할 때 슬라이스의 각 값을 복제 할 수 있습니다. 은 Using &lt;code&gt;clone&lt;/code&gt; 우리가 잠재적으로 같은 자신의 힙 데이터 것을 유형의 경우 더 힙 할당을 만들고있어 기능 수단을 &lt;code&gt;String&lt;/code&gt; 우리는 많은 양의 데이터로 작업하는 경우, 힙 할당이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">수명 주석을 잊어 버리고이 함수를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">뮤텍스를 잠그면 &lt;code&gt;recv&lt;/code&gt; 를 호출 하여 채널에서 &lt;code&gt;Job&lt;/code&gt; 을 수신합니다 . 최종 &lt;code&gt;unwrap&lt;/code&gt; 은 여기에서도 오류를지나 이동 합니다. 수신 측이 종료되면 &lt;code&gt;send&lt;/code&gt; 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 반환 하는 방식과 유사하게 채널의 송신 측을 보유하는 스레드가 종료 된 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 행 사용을 나열하지 않은 경우이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 줄을 넣지 않았다면 이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">더 복잡한 키가있는 경우 &lt;code&gt;insert&lt;/code&gt; 호출 은 키 값을 업데이트하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">문자열 슬라이스가 있으면 직접 전달할 수 있습니다. 우리가 &lt;code&gt;String&lt;/code&gt; 을 가지고 있다면 , 우리는 전체 &lt;code&gt;String&lt;/code&gt; 의 슬라이스를 전달할 수 있습니다 . 대신에 대한 참조의 캐릭터 조각 걸릴하는 함수를 정의하는 &lt;code&gt;String&lt;/code&gt; 어떤 기능을 잃지 않고 우리의 API가 더 일반적이고 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">키와 값을 해시 맵에 삽입 한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연관된 값이 대체됩니다. Listing 8-24 호출의 코드가 두 번 &lt;code&gt;insert&lt;/code&gt; 되지만 해시 맵에는 Blue 팀 키 값을 두 번 삽입하기 때문에 하나의 키 / 값 쌍만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">값에 대한 참조를 해시 맵에 삽입하면 값이 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 한 유효해야합니다. 이러한 문제에 대해서는 10 장의 &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;평생 검증 참조&quot;&lt;/a&gt; 섹션에서 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Devanagari 스크립트로 작성된 힌디어 단어 &quot;नमस्ते&quot; 를 보면 다음과 같은 &lt;code&gt;u8&lt;/code&gt; 값 으로 구성된 벡터로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">여러 문자열을 연결 해야하는 경우 &lt;code&gt;+&lt;/code&gt; 연산자 의 동작 이 다루기 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">앞에서 본 것처럼 인수를 전달하지 않고 테스트를 실행하면 모든 테스트가 동시에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">&lt;em&gt;hello.txt&lt;/em&gt; 파일 &lt;em&gt;없이이&lt;/em&gt; 코드를 실행 하면 &lt;code&gt;panic!&lt;/code&gt; 에서 오류 메시지가 나타납니다 ! 것을 전화 &lt;code&gt;unwrap&lt;/code&gt; 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">이 코드를 실행하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">&lt;code&gt;takes_ownership&lt;/code&gt; 호출 한 후 &lt;code&gt;s&lt;/code&gt; 를 사용하려고하면 Rust에서 컴파일 타임 오류가 발생합니다. 이러한 정적 검사는 실수로부터 우리를 보호합니다. &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 를 사용 하는 코드를 &lt;code&gt;main&lt;/code&gt; 에 추가하여 코드를 사용할 수있는 위치와 소유권 규칙으로 인해 코드를 사용할 수없는 위치를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">&lt;code&gt;assert_eq!(5, y);&lt;/code&gt; 를 쓰려고하면 ! (5, y); 대신이 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">범위가 끝난 후 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 액세스하려고 하면 &lt;code&gt;None&lt;/code&gt; 을 다시 얻 습니다. 프로그램의 끝에서, &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;leaf&lt;/code&gt; 변수에 있기 때문에, (1)의 강한 카운트 0 약함 카운트를 갖는 &lt;code&gt;leaf&lt;/code&gt; 이제 유일한 기준이다 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 다시.</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Listing 15-15와 같이 Listing 15-14에서 &lt;code&gt;main&lt;/code&gt; 함수를 수정 하여 &lt;code&gt;Drop&lt;/code&gt; 특성의 &lt;code&gt;drop&lt;/code&gt; 메소드를 수동으로 호출하려고 하면 컴파일러 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Listing 15-3에서 코드를 컴파일하려고하면 Listing 15-4에 표시된 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Listing 10-21에 나와있는 것처럼 &lt;code&gt;longest&lt;/code&gt; 함수 를 구현하려고하면 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">참조와 마찬가지로 컴파일러 오류가 발생하지 않고 이러한 규칙을 위반하려고하면 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 구현이 런타임시 패닉 상태가됩니다. Listing 15-23은 Listing 15-22 의 &lt;code&gt;send&lt;/code&gt; 구현 수정을 보여준다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 인해 런타임 시이 작업을 수행 할 수 없음 을 설명하기 위해 동일한 범위에 대해 두 개의 변경 가능한 차용을 의도적으로 작성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; 대신 &lt;code&gt;None&lt;/code&gt; 을 사용하는 경우 컴파일러 가 &lt;code&gt;None&lt;/code&gt; 값만 보고 &lt;code&gt;Some&lt;/code&gt; 변형이 보유 할 유형을 유추 할 수 없으므로 Rust에 어떤 유형의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 있는지 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">벡터의 각 요소에 차례로 액세스하려면 인덱스를 사용하여 한 번에 하나씩 액세스하는 대신 모든 요소를 ​​반복 할 수 있습니다. Listing 8-8은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용하여 &lt;code&gt;i32&lt;/code&gt; 값으로 구성된 벡터의 각 요소에 대한 불변 참조를 가져 와서 인쇄하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">경로에 정의 된 &lt;em&gt;모든&lt;/em&gt; 공개 항목을 범위 로 가져 오려면 해당 경로 다음에 glob 연산자 인 &lt;code&gt;*&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도 보려면 &lt;code&gt;--nocapture&lt;/code&gt; 플래그 를 사용하여 출력 캡처 동작을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도보고 싶다면 마지막에 &lt;code&gt;--show-output&lt;/code&gt; 을 사용하여 성공한 테스트의 출력을 보여 주도록 Rust에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">이 함수가 &lt;code&gt;item1&lt;/code&gt; 과 &lt;code&gt;item2&lt;/code&gt; 가 다른 유형을 갖도록하려면 &lt;code&gt;impl Trait&lt;/code&gt; 을 사용하는 것이 적절합니다 (두 유형이 &lt;code&gt;Summary&lt;/code&gt; 를 구현하는 한 ). 두 매개 변수를 모두 같은 유형으로 만들려면 다음과 같이 특성 바운드를 사용하여 표현하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">튜플에서 하나 이상의 값을 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;무시&lt;/a&gt; 하려면 &quot;패턴의 값 무시&quot; 섹션 에서 볼 수 있듯이 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 을 사용할 수 있습니다 . 문제가 패턴에 너무 많은 변수가있는 경우, 해결책은 변수를 제거하여 유형을 일치시켜 변수의 수가 튜플의 요소 수와 같도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">이 코드를 실행할 수 있다면 스폰 된 스레드가 전혀 실행되지 않고 즉시 백그라운드에 놓일 수 있습니다. 스폰 된 스레드는 &lt;code&gt;v&lt;/code&gt; 내부에 대한 참조를 갖지만 주 스레드 는 15 장에서 설명한 &lt;code&gt;drop&lt;/code&gt; 함수를 사용하여 즉시 &lt;code&gt;v&lt;/code&gt; 를 삭제 합니다. 그런 다음 스폰 된 스레드가 실행되기 시작하면 &lt;code&gt;v&lt;/code&gt; 는 더 이상 유효하지 않으므로 이에 대한 참조는 또한 유효하지 않습니다. 아뇨!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">우리는 전화로한다면 &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , &lt;code&gt;coin&lt;/code&gt; 것 &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . 해당 값을 각 일치 팔과 비교할 때 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 도달 할 때까지 일치하지 않습니다 . 이 시점에서 &lt;code&gt;state&lt;/code&gt; 바인딩은 &lt;code&gt;UsState::Alaska&lt;/code&gt; 값이됩니다 . 그런 다음 &lt;code&gt;println!&lt;/code&gt; 에서 해당 바인딩을 사용할 수 있습니다 ! 따라서 &lt;code&gt;Quarter&lt;/code&gt; 의 &lt;code&gt;Coin&lt;/code&gt; 열거 형 변형 에서 내부 상태 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">상태 패턴을 사용하지 않는 대체 구현을 작성하는 경우 &lt;code&gt;Post&lt;/code&gt; 의 메소드 또는 게시물 의 상태를 확인하고 해당 위치의 동작을 변경 하는 &lt;code&gt;main&lt;/code&gt; 코드 에서 &lt;code&gt;match&lt;/code&gt; 표현식을 대신 사용할 수 있습니다. 즉, 게시 된 상태에있는 게시물의 모든 의미를 이해하려면 여러 곳을 살펴 봐야합니다! 이것은 우리가 추가 한 상태를 증가시킬뿐입니다. 각각의 &lt;code&gt;match&lt;/code&gt; 표현에는 다른 팔이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 상자 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 한 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 우리가 목록 2-4의 추측 게임에서 가졌던 다음 두 개의 &lt;code&gt;use&lt;/code&gt; 문은 &lt;code&gt;std&lt;/code&gt; 에서 항목 을 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 패키지 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 자체 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 추측 게임의 목록 2-4에있는 이 두 가지 &lt;code&gt;use&lt;/code&gt; 문장은 &lt;code&gt;std&lt;/code&gt; 에서 범위로 항목을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">당신이 경우 &lt;em&gt;어떻게&lt;/em&gt; 녹에, 컴파일러는 당신에게 (에 의해 제어 기본적으로 경고를 줄 것이다 쓰기 &lt;code&gt;unused_must_use&lt;/code&gt; 의 보풀).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">찾고있는 이름을 이미 알고 있다면 가장 빠른 방법은 페이지 상단의 검색 창을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">자체 스마트 포인터 유형을 정의하고 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST 강제 변환 시스템&lt;/a&gt; 을 사용 하여 크기가 조정되지 않은 유형에서 크기가 조정되지 않은 유형으로 변환 하려면 &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">타입을 잘 생각한다면 &lt;code&gt;map()&lt;/code&gt; 과 같이 생각할 수 있습니다 : &lt;code&gt;A&lt;/code&gt; 타입 의 요소를 제공 하는 반복자가 있고 다른 &lt;code&gt;B&lt;/code&gt; 타입의 반복자를 원한다면 &lt;code&gt;map()&lt;/code&gt; 사용할 수 있습니다 &lt;code&gt;A&lt;/code&gt; 를 가져 오고 &lt;code&gt;B&lt;/code&gt; 를 반환 하는 클로저를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 변환 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 함수의 안전하지 않은 버전이 있습니다.이 함수 는 동작이 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 null이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 반환하는 일종의 &lt;code&gt;as_mut_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 널이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;T&lt;/code&gt; 를 리턴하는 일종의 &lt;code&gt;as_ref_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">숫자 유형을 bool로 캐스트하려는 경우 대신 0과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">속기 필드 패턴을 사용하지만 다른 이름으로 구조체 필드를 참조하려는 경우 명시 적으로 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">속기 필드 패턴을 사용하고 있지만 다른 이름으로 struct 필드를 참조하려면 명시 적으로 이름을 변경해야합니다. 구조체 필드는 콜론 전에 사용 된 이름에 의해 식별됩니다 &lt;code&gt;:&lt;/code&gt; 구조체 패턴이 구조체 형식의 선언이 일치되고 유사합니다 그래서.</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">기존 파일 형식을 처리 할 프로그램을 작성하는 경우이 기능을 사용하기 전에 해당 형식의 공백 정의를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">예를 들어 권한 오류로 인해 파일이 포함 된 디렉토리에 액세스 할 수 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 전략을 사용할 수없는 경우 유형 이 메소드가없는 &lt;code&gt;Eq&lt;/code&gt; 를 구현하도록 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">안전한 코드로 액세스 할 수 있는 수명 &lt;code&gt;'a&lt;/code&gt; ( &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 참조) 로 안전한 참조를 작성하는 경우 (예를 들어 리턴했기 때문에) 해당 참조와 모순되는 방식으로 데이터에 액세스하면 안됩니다 &lt;code&gt;'a&lt;/code&gt; 의 나머지 . 예를 들어,이 방법은 당신이 가지고 있다고하면 &lt;code&gt;*mut T&lt;/code&gt; 에서 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 와에 캐스팅 &lt;code&gt;&amp;amp;T&lt;/code&gt; 다음의 데이터를, &lt;code&gt;T&lt;/code&gt; 는 (모든 모듈로 불변 유지해야 &lt;code&gt;UnsafeCell&lt;/code&gt; 의 데이터 내에서 발견 &lt;code&gt;T&lt;/code&gt; 해당 참조의 수명까지 물론,) 만료됩니다. 마찬가지로 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 생성하면안전 코드로 해제 된 참조가 있으면 해당 참조가 만료 될 때까지 &lt;code&gt;UnsafeCell&lt;/code&gt; 내의 데이터에 액세스하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">변수를 만들지 만 아무데도 사용하지 않으면 Rust는 일반적으로 버그가 될 수 있으므로 경고를 표시합니다. 그러나 때로는 프로토 타입을 만들거나 프로젝트를 시작할 때와 같이 아직 사용하지 않는 변수를 만드는 것이 유용합니다. 이 상황에서 변수 이름을 밑줄로 시작하여 사용하지 않는 변수에 대해 경고하지 않도록 Rust에 지시 할 수 있습니다. Listing 18-20에서는 사용하지 않는 두 개의 변수를 작성하지만이 코드를 실행할 때 그 중 하나에 대한 경고 만 표시된다.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="translated">트레이 트 객체를 사용하기로 결정한 경우 컴파일러는 컴파일 도중이 아니라 &lt;em&gt;런타임&lt;/em&gt; 에 호출 할 메서드를 파악하는 코드를 생성해야하므로 성능에 영향을주는 &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;동적 디스패치에&lt;/a&gt; 의존한다는 점에 유의 하십시오 . 특성 개체를 사용하여 성능을 위해 유연성을 거래하고 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="translated">당신이없는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 하지만, 단지 &lt;code&gt;&amp;amp;U&lt;/code&gt; 있도록 &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (예 : &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt; ), 당신은 사용할 수 있습니다 &lt;code&gt;iter().any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &quot;적어도&quot;동작을 원하지 않으면 &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 호출하지 않으면 프로그램이 컴파일되지만 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">테스트를 병렬로 실행하지 않거나 사용 된 스레드 수를보다 세밀하게 제어하려면 &lt;code&gt;--test-threads&lt;/code&gt; 플래그와 사용하려는 스레드 수를 테스트에 보낼 수 있습니다 이진. 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아주 ​​가능성이 높음) 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아마도) 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Rust의 기본 사항을 모르는 경우 Rust Book을 방문하여 시작할 수 있습니다. https://doc.rust-lang.org/book/</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="translated">Rust의 기초를 모르신다면 &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; 에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">이름을 한정하지 않으면 코드는 &quot;GET&quot;및 &quot;POST&quot;라는 새 변수를 대신 바인딩합니다. 이 동작은 원하는 것이 &lt;code&gt;rustc&lt;/code&gt; 있으므로 rustc 는 이러한 상황이 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">이 오류가 발생하면 입력 유형의 가능한 모든 값이 일치하도록 패턴을 변경해야합니다. 열거 형과 같이 변형이 적은 유형의 경우 모든 경우를 명시 적으로 다루어야합니다. 또는 밑줄 &lt;code&gt;_&lt;/code&gt; 와일드 카드 패턴을 &quot;다른 것&quot;과 일치시키기 위해 다른 모든 패턴 뒤에 추가 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">이 오류가 발생하면 당신은 아마 사용할 필요가 &lt;code&gt;match&lt;/code&gt; 하거나 &lt;code&gt;if let&lt;/code&gt; 실패의 가능성을 처리 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">C 또는 C ++ 배경이 있다면 &lt;code&gt;gcc&lt;/code&gt; 또는 &lt;code&gt;clang&lt;/code&gt; 과 유사하다는 것을 알 수 있습니다. 성공적으로 컴파일 한 후 Rust는 바이너리 실행 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 목록 이있는 경우 &lt;code&gt;collect()&lt;/code&gt; 를 사용 하여 실패한 것이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있다면 일반적으로 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 불변입니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경되거나 변경되지 않고 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 될 수 없다는 제한을 해결하는 유일한 핵심 언어 기능 입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 변경을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서도 앨리어싱 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 을 얻을 수있는 합법적 인 방법 은 &lt;em&gt;없습니다.&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있으면 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 변경할 수 없습니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 가능하게 별명 지정되거나 변경되지 않았으며 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는이 제한을 해결하는 유일한 핵심 언어 기능입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 가변성을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">프로그램에 &lt;code&gt;match&lt;/code&gt; 를 사용하여 표현하기에 너무 장황한 논리가 있는 &lt;code&gt;if let&lt;/code&gt; 이 Rust 도구 상자에도 있다는 것을 기억 하십시오.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;String&lt;/code&gt; 을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 여기 에서 &lt;code&gt;String&lt;/code&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">유효한 UTF-8 바이트의 벡터가 있으면 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 만들 수 있습니다 . 당신도 반대를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&lt;/code&gt; 의 소유권이 있다면 , 대신 &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">컨테이너의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값에 대한 소유권이있는 경우에는 대신 &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">당신은 구현하는 뭔가가있는 경우 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , 당신이 사용할 수있는 &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 의 유형을&lt;/a&gt; 로를 설정하는 &lt;code&gt;BufRead&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">변경하지 않고 즉시 &lt;code&gt;cargo build&lt;/code&gt; 다시 실행 하면 &lt;code&gt;Finished&lt;/code&gt; 라인 에서 다른 출력을 얻을 수 없습니다 . Cargo는 이미 종속성을 다운로드하여 컴파일 &lt;em&gt;했음을 알고 있으며 Cargo.toml&lt;/em&gt; 파일 에서 관련 항목을 변경하지 않았습니다 . Cargo는 또한 코드에 대해 아무것도 변경하지 않았으므로 다시 컴파일하지도 않는다는 것을 알고 있습니다. 할 일이 없으면 단순히 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 대신 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 필요한 경우 &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">널 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">nul 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대신 &lt;code&gt;String&lt;/code&gt; 이 필요한 경우 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 이 소멸 될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 물론 &lt;code&gt;Hash&lt;/code&gt; 특성을 직접 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 여러 개 필요한 경우 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 여러 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">기능이 필요한 경우 야간 릴리스의 컴파일러를 사용해야합니다 (하지만 나중에 기능이 제거되거나 변경 될 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">이것이 필요한 경우, 무언가 잘못하고있을 가능성이 큽니다. Rust는 다른 구조체의 레이아웃에 대해 많은 것을 보증하지 않습니다 (동일한 선언을 가진 두 구조체는 다른 레이아웃을 가질 수 있음). 변환을 완전히 피하는 해결책이 있다면 대신 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">객체 경계를 넘어야하는 경우 포인터를 정수로 캐스팅하고 거기에서 산술을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">&lt;em&gt;많은&lt;/em&gt; 스트림 의 길이를 가져와야하고 탐색 위치를 신경 쓰지 않는 경우 &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; 를 호출 하고 반환 값을 사용하여 탐색 조작 수를 줄일 수 있습니다. 또한 스트림 길이입니다).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">개별 유니 코드 스칼라 값에 대한 작업을 수행해야하는 경우 &lt;code&gt;chars&lt;/code&gt; 메서드 를 사용하는 것이 가장 좋습니다 . &quot;नमस्ते&quot;에서 &lt;code&gt;chars&lt;/code&gt; 를 호출 하면 &lt;code&gt;char&lt;/code&gt; 유형의 6 개 값이 분리되어 반환 되며 결과를 반복하여 각 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">네임 스페이스 만 가져 오려면 직접 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">&lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 열고 사소한 변경을 한 다음 저장하고 다시 빌드하면 두 줄의 출력 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">원하는 경우 스크립트를 다운로드하여 실행하기 전에 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">작업 공간의 상자를 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에 게시하는 경우 작업 공간의 각 상자를 별도로 게시해야합니다. &lt;code&gt;cargo publish&lt;/code&gt; 명령은 없습니다 &lt;code&gt;--all&lt;/code&gt; 플래그 또는 &lt;code&gt;-p&lt;/code&gt; 각 상자의 디렉토리 및 실행으로 변경해야합니다, 그래서 깃발을 &lt;code&gt;cargo publish&lt;/code&gt; 나무 상자를 게시하는 작업 공간에 각각의 상자에.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">전역 변경 가능 상태를 원하면 &lt;code&gt;static mut&lt;/code&gt; 변경 또는 전역 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">이 코드를 실행하고 기본 스레드의 출력 만 보거나 겹치지 않으면 범위에서 숫자를 늘려서 운영 체제가 스레드간에 전환 할 수있는 기회를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">버전 번호가 표시되면 가지고 있습니다! &lt;code&gt;command not found&lt;/code&gt; 과 같은 오류가 표시되는 경우 설치 방법에 대한 설명서를보고 Cargo를 별도로 설치하는 방법을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 표시되면 Rust가 성공적으로 설치된 것입니다! 이 정보가 표시되지 않고 Windows에있는 경우 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하십시오 . 이것이 모두 정확하고 Rust가 여전히 작동하지 않으면 도움을 얻을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 거기서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 자신이라고 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 유용한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 및 &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;스택 오버플로가 있습니다.&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 보이면 Rust를 성공적으로 설치 한 것입니다! 이 정보가 보이지 않고 Windows를 사용하고 있다면 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하세요 . 모든 것이 맞고 Rust가 여전히 작동하지 않는다면 도움을받을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 그곳에서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 스스로 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 훌륭한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">우리가 &quot;Hello, world!&quot;에서했던 것처럼 Cargo를 사용하지 않는 프로젝트를 시작했다면 프로젝트에서 Cargo를 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리 로 이동하고 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Cargo를 사용하지 않는 프로젝트를 시작했다면 Hello, world! 프로젝트에서화물을 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리로 &lt;em&gt;옮기고&lt;/em&gt; 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="translated">여전히 열거 형에 &lt;code&gt;Default&lt;/code&gt; 를 구현 하려면 &quot;직접&quot;수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">외부 크레이트의 모듈을 사용하려고했고 Rust 2015를 사용하고 있다면, 외부 &lt;code&gt;extern crate&lt;/code&gt; 선언 (보통 크레이트 루트에 위치)을 놓쳤을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">당신이 구현하려고하면 &lt;code&gt;Copy&lt;/code&gt; 비 포함하는 구조체 또는 열거에 &lt;code&gt;Copy&lt;/code&gt; 된 데이터를, 당신은 오류 얻을 것이다 &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">마지막 &lt;code&gt;println!&lt;/code&gt; 주석을 해제하면 ! 프로그램을 실행, 녹으로이주기를 인쇄하려고합니다 를 가리키는 &lt;code&gt;b&lt;/code&gt; 가리키는 등이 스택 오버 플로우 때까지. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 속성에서 제공하는 것과 다른 동작을 원할 경우 수동으로 구현하는 방법에 대한 자세한 내용은 각 특성에 대한 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">다른 사용자가 모듈에서 변형을 직접 가져올 수있게하려면 &lt;code&gt;pub use&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">이 필드에 액세스하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소멸자를 실행하여 값을 올바르게 처리하려면 &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">클로저가 환경에서 사용하는 값의 소유권을 갖도록하려면 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이 기술은 데이터를 새 스레드가 소유하도록 데이터를 이동하기 위해 새 스레드에 클로저를 전달할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">명령 행 인수를 얻으려면 &lt;code&gt;std::env::args&lt;/code&gt; . 지정된 종료 코드로 종료하려면 &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="translated">정렬 순서를 유지하면서 정렬 된 벡터에 항목을 삽입하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">첫 번째 &lt;code&gt;String&lt;/code&gt; 을 계속 사용하려면 이를 복제하고 대신 복제본에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리를 누출하려면 &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 과 일치 시키려면 가드를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="translated">메서드에서 반환 된 값과 일치 시키려면 먼저 값을 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리에 대한 원시 포인터를 얻으려면 &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최대 값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최소값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">현재 오류를 생략하고 해당 소스 만 사용하려면 &lt;code&gt;skip(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">특정 옵션을 무시하고 다른 기본값을 계속 유지하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 변수의 값을 바꾸려면 &lt;a href=&quot;fn.swap&quot;&gt; &lt;code&gt;swap&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 대신 전달 된 값으로 바꾸려면 replace를 참조 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 또는 더미 값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전달 된 값으로 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 이전 값을 반환하려면 replace를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">SPDX에 나타나지 않는 라이센스를 사용하려면 해당 라이센스의 텍스트를 파일에 넣고 프로젝트에 파일을 포함시킨 다음 &lt;code&gt;license-file&lt;/code&gt; 을 사용하여 해당 파일의 이름을 대신 지정해야합니다. 사용 &lt;code&gt;license&lt;/code&gt; 키</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">메소드를 사용하려면 메소드 뒤에 &lt;code&gt;()&lt;/code&gt; 를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.4.0&lt;/code&gt; 또는 &lt;code&gt;0.4.x&lt;/code&gt; 시리즈의 버전 을 사용 하려면 다음과 같이 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 업데이트해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">당신이 사용하고자하는 경우 &lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.6.0&lt;/code&gt; 시작 또는 모든 버전 &lt;code&gt;0.6.x&lt;/code&gt; 시리즈를, 당신은 업데이트해야 할 것 &lt;em&gt;Cargo.toml의&lt;/em&gt; 대신이 같은 모습에 파일을 :</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">이 속성을 impl의 모든 메소드에 적용하려면 각 메소드에 수동으로 주석을 답니다. 전체 impl에 &lt;code&gt;#[inline]&lt;/code&gt; 으로 주석을 달 수 없습니다 . 속성으로 .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="translated">Rust의 소유권에 대해 더 알고 싶다면 책의 &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;소유권 이해&lt;/a&gt; 장에서 시작 하십시오.</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Rust의 소유권에 대해 더 배우려면 다음 장에서 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Windows API로 작업하는 경우 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">내 보낸 매크로를 모두 가져 오려면 인수없이 &lt;code&gt;macro_use&lt;/code&gt; 를 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Ruby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙한 경우 별도의 단계로 프로그램을 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다. Rust는 &lt;em&gt;미리 컴파일 된&lt;/em&gt; 언어로, 프로그램을 컴파일하고 다른 사람에게 실행 파일을 제공 할 수 있으며 Rust를 설치하지 않아도 실행할 수 있습니다. 누군가에게 &lt;em&gt;.rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; 또는 &lt;em&gt;.js&lt;/em&gt; 파일을 제공하는 경우 루비, 파이썬 또는 JavaScript 구현이 (각각) 설치되어 있어야합니다. 그러나 이러한 언어에서는 프로그램을 컴파일하고 실행하기위한 명령이 하나만 필요합니다. 모든 것은 언어 디자인의 절충입니다.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">문제가 발생하면 Listing 20-15의 코드를보기 전에 이러한 변경 사항을 직접 구현해보십시오.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Linux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 하나가 아닌 두 개의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Rust 베타 또는 안정적인 릴리스를 사용하는 경우 기능 플래그를 사용할 수 없습니다. 이것이 우리가 새로운 기능을 영원히 안정적으로 선언하기 전에 새로운 기능을 실제로 사용할 수있게하는 열쇠입니다. 최첨단 기술을 선택하려는 사람들은 그렇게 할 수 있으며, 견고한 경험을 원하는 사람들은 안정을 유지하고 코드가 깨지지 않을 것임을 알 수 있습니다. 정체없는 안정성.</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 로&lt;/a&gt; 작업하는 경우 &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 파일 시스템 경로를 사용하는 경우 &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">다른 언어로 작업하는 동안 &lt;em&gt;얕은 복사&lt;/em&gt; 와 &lt;em&gt;깊은 복사&lt;/em&gt; 라는 용어를 들었다면 데이터를 복사하지 않고 포인터, 길이 및 용량을 복사하는 개념은 얕은 복사를하는 것처럼 들릴 것입니다. 그러나 Rust는 얕은 카피 라 불리는 대신 첫 번째 변수를 무효화하기 때문에 &lt;em&gt;이동이라고&lt;/em&gt; 합니다. 이 예제에서, 우리는 말할 것 &lt;code&gt;s1&lt;/code&gt; 되었다 &lt;em&gt;이동&lt;/em&gt; 에 &lt;code&gt;s2&lt;/code&gt; . 실제 상황은 그림 4-4에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">값의 소멸자를 명시 적으로 호출하려면 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 을 대신 사용할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
