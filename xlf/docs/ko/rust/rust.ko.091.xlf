<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">품질 비교</target>
        </trans-unit>
        <trans-unit id="aa380f41959815056bfdd3029c1845bf486477df" translate="yes" xml:space="preserve">
          <source>Nor can you use direct field access to do field-by-field gradual initialization:</source>
          <target state="translated">직접 필드 액세스를 사용하여 필드 별 점진적 초기화를 수행 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">이것도 마찬가지입니다 :</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">일반적으로, 여기에, 하나는 사용하는 것이 &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 내용을 올바르게 삭제하기 를 하므로 메모리가 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5084dc27f957de7bc8c196b5f20cd9275d3c3a4f" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">일반적으로 여기서는 내용을 올바르게 삭제하기 위해 대신 &lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; 를&lt;/a&gt; 사용하여 메모리 누수를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">숫자가 아님 (NaN).</target>
        </trans-unit>
        <trans-unit id="d52a965ff185906c6e9fb5c36534475faa112b26" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt;&lt;code&gt;f32::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">NaN (Not a Number). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt; &lt;code&gt;f32::NAN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd484bf7d113fac0a06fa50cec141b09e01e967e" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt;&lt;code&gt;f64::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">NaN (Not a Number). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt; &lt;code&gt;f64::NAN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="736e9bdbdcdd4b04a6c46d181f239630b7b9a187" translate="yes" xml:space="preserve">
          <source>Not all uses of &lt;code&gt;unsafe&lt;/code&gt; are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say &quot;I have checked the contract, go ahead and do this&quot;. The following &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;discussion on Rust Internals&lt;/a&gt; has more in-depth explanations about this but here is a summary of the main points:</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 모든 사용 이 동일 하지는 않습니다 . 일부는 프로그래머가 확인해야하는 계약의 존재를 표시하기 위해 여기에 있으며, 다른 일부는 &quot;계약을 확인했습니다. &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;Rust Internals에&lt;/a&gt; 대한 다음 토론 은 이것에 대해 더 심층적 인 설명을 가지고 있지만 여기에 주요 요점에 대한 요약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2508d67aae4fe16b65d89f08837d02c03c4df29" translate="yes" xml:space="preserve">
          <source>Not be &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 이 아님</target>
        </trans-unit>
        <trans-unit id="d13ee2c7e4ca985d57b930eb6ea7f0b33421d3e0" translate="yes" xml:space="preserve">
          <source>Not be infinite</source>
          <target state="translated">무한하지 않음</target>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">같지 않다</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">패턴을 찾지 못했습니다 :</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">평생 매개 변수가 허용되지만 유형 매개 변수가 없으며</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">널이 아닌 값을 가정한다고 잘못 걱정하지 않아도 코드에 대한 자신감이 높아집니다. 널이 될 수있는 값을 가지려면 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값의 유형을 지정하여 명시 적으로 선택해야합니다 . 그런 다음 해당 값을 사용할 때 값이 널인 경우를 명시 적으로 처리해야합니다. 값이 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 가 아닌 유형을 갖는 모든 곳 에서 값이 null이 아니라고 가정 할 &lt;em&gt;수 있습니다&lt;/em&gt; . 이는 Rust가 널 (null)의 보급률을 제한하고 Rust 코드의 안전성을 높이기위한 의도적 인 설계 결정이었습니다.</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">소멸자를 실행하지 않음</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">Rust에서 소멸자를 실행하지 않으면 &lt;code&gt;'static&lt;/code&gt; 이 아닌 유형이 있어도 안전 합니다. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt; 은 변수 또는 필드가 자동으로 삭제되지 않도록 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">초기 값이 NaN 인 경우이 함수는 NaN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 지정된 디렉토리를 동시에 작성하여 작성할 수없는 상황에서는 예외가 발생 합니다. 이러한 경우는 성공적인 것으로 간주됩니다. 즉, 여러 스레드 또는 프로세스에서 &lt;code&gt;create_dir_all&lt;/code&gt; 을 동시에 호출 하면 경쟁 조건으로 인해 실패하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a734e9b17de37ddc28f39d989ac717c3bd9ad8" translate="yes" xml:space="preserve">
          <source>Notable features that const contexts have, but const fn haven't are:</source>
          <target state="translated">const 컨텍스트에는 있지만 const fn에는없는 주목할만한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="215a4bdf475a8ec68726e515897b581b10444b3f" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ [u8]</source>
          <target state="translated">&amp;amp; '_ [u8]의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d369df1510ca517b58a49f8cd6e6bb0e489ca52a" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut F</source>
          <target state="translated">&amp;amp; '_ mut F의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6cb09acdfe424fff47bc90762c736658052520f0" translate="yes" xml:space="preserve">
          <source>Notable traits for Ancestors&amp;lt;'a&amp;gt;</source>
          <target state="translated">조상의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="49884a82c86f5e2dcfd40b1838c34bab8f05e373" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunks&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayChunks &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0cd325ab96ff06257d643a3909af2cf159e2fa33" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunksMut&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayChunksMut &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8e4c4055a5d727f7480702b2cc7fa22ff495757b" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayWindows&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayWindows &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a8627fe98c009205a399c633908682c9a3e1ee4d" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F&amp;gt;</source>
          <target state="translated">Box &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="01102f0879a5c2ca5c62809ffff0c0b0bad939d6" translate="yes" xml:space="preserve">
          <source>Notable traits for BufReader&amp;lt;R&amp;gt;</source>
          <target state="translated">BufReader &amp;lt;R&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="bcafa8b1481fa65c646affea37accfbcf24f6580" translate="yes" xml:space="preserve">
          <source>Notable traits for BufWriter&amp;lt;W&amp;gt;</source>
          <target state="translated">BufWriter &amp;lt;W&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="73e8f6f48862fb0efc8b91d4c920e5075c8f689b" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;'_&amp;gt;</source>
          <target state="translated">바이트의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="be95aee73944208a8cbfa7ffa1a48d80537a439d" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;R&amp;gt;</source>
          <target state="translated">Bytes &amp;lt;R&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e3aa0ca54ac23d2115ba17da930b0b2c7d22ecc0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;'a&amp;gt;</source>
          <target state="translated">Chain &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="425c2e101149bb0adbc3f3833b4e9a88563fb4a0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;A, B&amp;gt;</source>
          <target state="translated">Chain &amp;lt;A, B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2a7e1c82210baf0b46d0937fbf969162cf98c76c" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;T, U&amp;gt;</source>
          <target state="translated">Chain &amp;lt;T, U&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="cd4d751abd8ab3ab6e55826ec326c6f4c431564f" translate="yes" xml:space="preserve">
          <source>Notable traits for CharIndices&amp;lt;'a&amp;gt;</source>
          <target state="translated">CharIndices의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08171c5effb66b03601f395559057c5c02e5ba5f" translate="yes" xml:space="preserve">
          <source>Notable traits for Chars&amp;lt;'a&amp;gt;</source>
          <target state="translated">Chars의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f9df882063622aa637c014b3eaf06c558ffb8da5" translate="yes" xml:space="preserve">
          <source>Notable traits for Chunks&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">청크의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7e432bd66d3f874ed890c86d21283df436f2bbd0" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksExact의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="584a1b10a62ffb190941baeea973451d496428d5" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksExactMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="95cc072812a01dbd66f6d2c5f3918fc1eecb2a25" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="fefa79cd49091a7a7a4ec1ce49b7dc2c3e8635da" translate="yes" xml:space="preserve">
          <source>Notable traits for Cloned&amp;lt;I&amp;gt;</source>
          <target state="translated">Cloned &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ae1c1d71ecdd9048c788733f05c8ee9170150c39" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandArgs&amp;lt;'a&amp;gt;</source>
          <target state="translated">CommandArgs의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d1d93748b1b05464de3995712c8cd56c0fc09338" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandEnvs&amp;lt;'a&amp;gt;</source>
          <target state="translated">CommandEnvs &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a97de3ec8fdabeefc703a8e7d7547f9f3496a716" translate="yes" xml:space="preserve">
          <source>Notable traits for Components&amp;lt;'a&amp;gt;</source>
          <target state="translated">구성 요소에 대한 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d315c976ebb90a2389ef7743e81e7feecc3a3a82" translate="yes" xml:space="preserve">
          <source>Notable traits for Copied&amp;lt;I&amp;gt;</source>
          <target state="translated">Copied &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="baf59bdb6fb943dc984c5feb9e03a98364bc20d8" translate="yes" xml:space="preserve">
          <source>Notable traits for Cursor&amp;lt;T&amp;gt;</source>
          <target state="translated">Cursor &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d59f29f61cd42c0f0ff909de6d45f9e90f184a20" translate="yes" xml:space="preserve">
          <source>Notable traits for Cycle&amp;lt;I&amp;gt;</source>
          <target state="translated">Cycle &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c53b4ea31bf598b85ea40c284bdb3c0198881f8c" translate="yes" xml:space="preserve">
          <source>Notable traits for DecodeUtf16&amp;lt;I&amp;gt;</source>
          <target state="translated">DecodeUtf16 &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b5127544158054e8bfb051274dd2021f84d9c3e7" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">차이점에 대한 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="49894b4bfbcd9313cd8e1fca37fff62b0d5fe327" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">차이점에 대한 주목할만한 특성 &amp;lt; 'a, T, S&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7bc7c96c5bc0e2db809df1de91687bd4053c4024" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_&amp;gt;</source>
          <target state="translated">배수의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f0c298a9ee76878fdf90e4aa0fdba569c9110023" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_, T&amp;gt;</source>
          <target state="translated">Drain &amp;lt; '_, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="bfff38769221a3bcf19fc3461189daa684992a6d" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K&amp;gt;</source>
          <target state="translated">드레인의 주목할만한 특성 &amp;lt; 'a, K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="958272eb22af639d41c1f50e43d47fb61a6b14ef" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Drain &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0daba3253b1d0ae9af8dc2745c8744b02b11222b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, K, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2385be6e59fcef027951939bd378844cfa66cc4e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, V, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, K, V, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="830f76c13044b7581905cb940dcf417e291d507b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, T, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, T, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="304a6f343623430e09952339820090a6a8ba207e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainSorted&amp;lt;'_, T&amp;gt;</source>
          <target state="translated">DrainSorted &amp;lt; '_, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ac510d8e5089a326a2eb18feaee192a8adc0a137" translate="yes" xml:space="preserve">
          <source>Notable traits for Empty&amp;lt;T&amp;gt;</source>
          <target state="translated">Empty &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f3573695011deffd446de805daa200465e4ba04e" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeUtf16&amp;lt;'a&amp;gt;</source>
          <target state="translated">EncodeUtf16 &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e43fb28465d3894c2c42629f7fcac035e497cddd" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeWide&amp;lt;'a&amp;gt;</source>
          <target state="translated">EncodeWide &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f89d4ae7f36a369049ddb4e7f3c8216010d3419d" translate="yes" xml:space="preserve">
          <source>Notable traits for Enumerate&amp;lt;I&amp;gt;</source>
          <target state="translated">Enumerate &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="df3db15928fc8d95aa51b8ec8568ffb5eabd15ff" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug</source>
          <target state="translated">EscapeDebug의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4c8ea88e979fa0c14d5d9cdbbd9d161b88b39045" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeDebug &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="098a62e8683b0a13c0908e723720ee9c6810fedc" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault</source>
          <target state="translated">EscapeDefault의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1190462f1941cfb82dacec2de3ad04f7c9541203" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeDefault &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ac599426120513bc277a63e47f672a5774b2c3d2" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode</source>
          <target state="translated">EscapeUnicode의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8024ca6f7e281ae2b2c49427386c5bf3564e02b9" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeUnicode &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="09f685f90ec7f2abae36adf82f3e91f906928c37" translate="yes" xml:space="preserve">
          <source>Notable traits for File</source>
          <target state="translated">File의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c974ed1aff38ed15c92fd39174e5a139046f0e34" translate="yes" xml:space="preserve">
          <source>Notable traits for Filter&amp;lt;I, P&amp;gt;</source>
          <target state="translated">Filter &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0176f9f85bf66bf907565450c64018c10c6cb978" translate="yes" xml:space="preserve">
          <source>Notable traits for FilterMap&amp;lt;I, F&amp;gt;</source>
          <target state="translated">FilterMap &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6bcdf064b818fb335120a0a13f2aad0c77345394" translate="yes" xml:space="preserve">
          <source>Notable traits for FlatMap&amp;lt;I, U, F&amp;gt;</source>
          <target state="translated">FlatMap &amp;lt;I, U, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1073550fde927671db722e47a13215279dc8806e" translate="yes" xml:space="preserve">
          <source>Notable traits for Flatten&amp;lt;I&amp;gt;</source>
          <target state="translated">Flatten &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c3bb84e817e2df7af3ebf4adf8af3eae4361fbed" translate="yes" xml:space="preserve">
          <source>Notable traits for FromFn&amp;lt;F&amp;gt;</source>
          <target state="translated">FromFn &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="dab5351ad5f13713d82cab1221966fc7e75e9d94" translate="yes" xml:space="preserve">
          <source>Notable traits for Fuse&amp;lt;I&amp;gt;</source>
          <target state="translated">Fuse &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="98b96e5efed1886b8e4bb59473b0f591f83aa189" translate="yes" xml:space="preserve">
          <source>Notable traits for Incoming&amp;lt;'a&amp;gt;</source>
          <target state="translated">Incoming의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="69f0a4d3c756c850a0608c731279e5ac5c5ca49c" translate="yes" xml:space="preserve">
          <source>Notable traits for Inspect&amp;lt;I, F&amp;gt;</source>
          <target state="translated">Inspect &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9f01a7c49836f7656e92d546f4185d1aefd357b8" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">교차로의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="20846e5c04b975b9bee849726ac0019c4f7b197d" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">교차로의 주목할만한 특성 &amp;lt; 'a, T, S&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4917b9b001be9af84b1ad65c2d45310be0927721" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;A&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1104b62a63a5899e12eeb37d5678f9df68b057f0" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;K&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1b19c0d62a927883656bbd747f944a9ce1ae1de8" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="5480768feb968b4174c1ae6ddf0dcc0e359f66ea" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3722bff12524c5b2d2d05cda59ba23d190ce3bfe" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T, N&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8c2d3479bd2162e028960fa1d767fb2598f2f013" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIterSorted&amp;lt;T&amp;gt;</source>
          <target state="translated">IntoIterSorted &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="5ad4c5fe36c7d254f4808dae95121b2bb0b54801" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoKeys&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoKeys &amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="da31fc5c3cf56bab8c815369c2547a6911c833ba" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoValues&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoValues ​​&amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="80895d49113bdb3cb86cfb4506bc6ebd9cd990ad" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d36ae4aeecd3653ca01fd74624e132869451eaf4" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, A&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6d5c2ab959e5631dfaa0a10009806935497b8c43" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K&amp;gt;</source>
          <target state="translated">Iter의 주목할만한 특성 &amp;lt; 'a, K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6b3bc881963ccadbe18c6746d9bbee3015f5abf1" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="00b543ae90963f05f96f4dd377980b1713d5159b" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2b070bfb60176569efaa6c1a4d324dc380b18332" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, A&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c915012f89d1a99c63f545f2ebffcef019fb4f2d" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c7bfb298a8fa281946d7580611e184273523102f" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9e5811113cb7885323072cf61d5667a2b362dde2" translate="yes" xml:space="preserve">
          <source>Notable traits for Keys&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Keys의 주목할만한 특성 &amp;lt; 'a, K, V&amp;gt;</target>
        </trans-unit>
        <trans-unit id="99c669d87d53a9eb6f676c0605066d307d9e6144" translate="yes" xml:space="preserve">
          <source>Notable traits for LineWriter&amp;lt;W&amp;gt;</source>
          <target state="translated">LineWriter &amp;lt;W&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6228658663ccbd3f41a5107629651e3c2771c99b" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;'a&amp;gt;</source>
          <target state="translated">라인의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9213f8c618faa944ed6f22753d61edcc9d4ecdf2" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;B&amp;gt;</source>
          <target state="translated">Lines &amp;lt;B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f6a5e49b0d0ee24c230282dd8f08580ff2f4ffb7" translate="yes" xml:space="preserve">
          <source>Notable traits for LinesAny&amp;lt;'a&amp;gt;</source>
          <target state="translated">LinesAny &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b99d80dc293caeb573cce051072ed906b6f15c5e" translate="yes" xml:space="preserve">
          <source>Notable traits for Map&amp;lt;I, F&amp;gt;</source>
          <target state="translated">Map &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="172f87d0793ddf7da88be709a2311741cbd4b363" translate="yes" xml:space="preserve">
          <source>Notable traits for MapWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">MapWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="64729c888eeabe7cf12e1842e01480ed82b337ff" translate="yes" xml:space="preserve">
          <source>Notable traits for MatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">MatchIndices의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b0d2b75e66e9e050b8169e3218de5ee791479721" translate="yes" xml:space="preserve">
          <source>Notable traits for Matches&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">Matches의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25ae519d64a28536d279768ad769256299621686" translate="yes" xml:space="preserve">
          <source>Notable traits for Once&amp;lt;T&amp;gt;</source>
          <target state="translated">Once &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f8b307122c682ff77253a547508bfd2ee6faae04" translate="yes" xml:space="preserve">
          <source>Notable traits for OnceWith&amp;lt;F&amp;gt;</source>
          <target state="translated">OnceWith &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ed7b3a034e2d225ecfcc33f32f2f83f5b7d3d90b" translate="yes" xml:space="preserve">
          <source>Notable traits for Peekable&amp;lt;I&amp;gt;</source>
          <target state="translated">Peekable &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6b8f81a496f377f17826b87b054d41b9d3f6cb71" translate="yes" xml:space="preserve">
          <source>Notable traits for Pending&amp;lt;T&amp;gt;</source>
          <target state="translated">Pending &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="74be0fa24b2449c87cf0033da73af99abb038226" translate="yes" xml:space="preserve">
          <source>Notable traits for Pin&amp;lt;P&amp;gt;</source>
          <target state="translated">Pin &amp;lt;P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="cf6ce59e954214088a5388d7abe14ace680afd30" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunks&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunks의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ff0549023d3e07da72d7eaec8fd8c7d3b1bfc8bb" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksExact의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1891d732a25cb1a2d6470e2f1e61d90d79932069" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksExactMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="272511b477fb6f4d7e66f455a8927b6aa68fd2ce" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4bc67e64b7ea3bfd3fc10ece7ec2491353da6e9d" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RMatchIndices의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ae7b6da19243fedcfa70bfd82f4cf8717d322f80" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatches&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RMatches의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3aa09ee60858aa32b9e0f1689cc4891931af0d24" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplit의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a0fe88a7318fe9810ff3810f98339d43244a6877" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplit의 주목할만한 특성 &amp;lt; 'a, T, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="70be06d4120000b8b8b94371aec7e2580c6b381b" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="7b31a8c9c6cb2046e7ec9e536ce72d0609e4c5c4" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplitN &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="19040f24ad7c9687e49caaeab46d848dc263b5ea" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitN &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1988fde6a09875d4b04a7b9e55d197b9d9a90765" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitNMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="907edfb9c1524174e07ccbc24ecb37a8cbb06d65" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplitTerminator &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9198631706611f9de2afa1f3a5e4389cd7cb8e7a" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Range &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3d3fe2b23ebaced9425f58daf076814b8c0291d9" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Range &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0614892f74433d616b37d2ae04d67fe7f14ad105" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;A&amp;gt;</source>
          <target state="translated">Range &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="beebcbfc8cc5133e5166a3028ebbd90ecdb7055f" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeFrom&amp;lt;A&amp;gt;</source>
          <target state="translated">RangeFrom &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f744d9434a4d9b5c37c99f5c97d2b2cc90b13077" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeInclusive&amp;lt;A&amp;gt;</source>
          <target state="translated">RangeInclusive &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0a4e925f094b7a69f246e42e8b50c5128f8129c7" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">RangeMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="abd184a89bc10bea6baedba72d627209bea1056f" translate="yes" xml:space="preserve">
          <source>Notable traits for Ready&amp;lt;T&amp;gt;</source>
          <target state="translated">Ready &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="64702f1280547e388d11ff5ae890bb729b733d36" translate="yes" xml:space="preserve">
          <source>Notable traits for Repeat&amp;lt;A&amp;gt;</source>
          <target state="translated">Repeat &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="49a3b2a3770cc905b8da25f64e140b4ab80c6ffe" translate="yes" xml:space="preserve">
          <source>Notable traits for RepeatWith&amp;lt;F&amp;gt;</source>
          <target state="translated">RepeatWith &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b0ad194cda463ad2c6dd1506daf0367114be5c8e" translate="yes" xml:space="preserve">
          <source>Notable traits for Rev&amp;lt;I&amp;gt;</source>
          <target state="translated">Rev &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="translated">Scan &amp;lt;I, St, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="translated">Skip &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">SkipWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="translated">Splice &amp;lt; '_, I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">Split &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">Split &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="translated">Split &amp;lt;B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitAsciiWhitespace &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusive &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusiveMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitNMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitTerminator &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitWhitespace &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StderrLock &amp;lt; '_&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdinLock의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdoutLock의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="translated">StepBy &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="translated">후임자의 주목할만한 특성 &amp;lt;T, F&amp;gt;</target>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">SymmetricDifference에 대한 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">SymmetricDifference &amp;lt; 'a, T, S&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="translated">Take &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="translated">Take &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">TakeWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="translated">TcpStream의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="translated">ToLowercase의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="translated">ToUppercase의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">TryIter &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Union &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">Union &amp;lt; 'a, T, S&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="translated">UnixStream의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">가치에 대한 주목할만한 특성 &amp;lt; 'a, K, V&amp;gt;</target>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">ValuesMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="translated">Vec &amp;lt;u8&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Windows의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="translated">Zip &amp;lt;A, B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">특히이 함수는 &lt;code&gt;flag&lt;/code&gt; 매개 변수를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; , 함수 매개 변수, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; 및 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 항목은 &lt;code&gt;Sized&lt;/code&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">참고 1 : 반복자가 끝까지 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">참고 1 : 반복자가 부분적으로 만 소비되거나 전혀 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">참고 1 : 주어진 단계에 관계없이 반복자의 첫 번째 요소가 항상 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">참고 2 : &lt;code&gt;Drain&lt;/code&gt; 값이 삭제되지 않았지만 보유한 차용이 만료되는 경우 (예 : &lt;code&gt;mem::forget&lt;/code&gt; ) 디 케이크 에서 제거되는 요소 수는 지정되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">참고 2 : &lt;code&gt;Drain&lt;/code&gt; 값이 유출 된 경우 벡터에서 얼마나 많은 요소가 제거되는지는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">참고 2 : 무시 된 요소를 가져 오는 시간은 고정되어 있지 않습니다. &lt;code&gt;StepBy&lt;/code&gt; 는 &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; 시퀀스처럼 동작하지만, &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; 시퀀스처럼 자유롭게 동작 할 수 있습니다. 성능상의 이유로 일부 반복자에 대해 변경하십시오. 두 번째 방법은 반복기를 더 빨리 진행시키고 더 많은 항목을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">또한 Listing 19-1과 19-3 에서 &lt;code&gt;num&lt;/code&gt; 이 저장된 동일한 메모리 위치를 가리키는 &lt;code&gt;*const i32&lt;/code&gt; 및 &lt;code&gt;*mut i32&lt;/code&gt; raw 포인터를 작성했다 . 대신 &lt;code&gt;num&lt;/code&gt; 에 대한 불변 및 변경 가능한 참조를 만들려고 시도하면 Rust의 소유권 규칙이 변경 불가능한 참조와 동시에 변경 가능한 참조를 허용하지 않기 때문에 코드가 컴파일되지 않았을 것입니다. 원시 포인터를 사용하면 변경 가능한 포인터와 동일한 위치에 대한 변경 불가능한 포인터를 만들고 변경 가능한 포인터를 통해 데이터를 변경하여 잠재적으로 데이터 경쟁을 일으킬 수 있습니다. 조심해!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">이 형식의 맥락에서 &quot;토큰&quot;이라는 용어 &lt;em&gt;에는&lt;/em&gt; 일반적으로 간단한 NT가 &lt;em&gt;포함됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="translated">그러나 &lt;code&gt;black_box&lt;/code&gt; 는 &quot;최선의 노력&quot;으로 만 제공되며 제공 될 수 있습니다. 최적화를 차단할 수있는 정도는 사용되는 플랫폼 및 코드 생성 백엔드에 따라 다를 수 있습니다. 프로그램은 어떤 식 으로든 &lt;em&gt;정확성&lt;/em&gt; 을 위해 &lt;code&gt;black_box&lt;/code&gt; 에 의존 할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">로캘에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">&amp;amp; Any는 값이 지정된 콘크리트 유형인지 여부를 테스트하는 것으로 제한되며 유형이 특성을 구현하는지 여부를 테스트하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; 는&lt;/a&gt; 이미 워크로드의 일부 적은 수의 감소시킬 수있는 경우에는이 검사를 수행 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; 의&lt;/a&gt; 이 불필요하여, 전화. 특히 슬라이스를 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; &lt;/a&gt; 할 수 있으며 모든 값에 대해 단일 needs_drop 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">참고 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , 예를 들어 S는 프리미티브를 이용하여 구현된다. 실제로 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;recv&lt;/code&gt; 를 호출 할 때 차단되는 채널을 사용할 수 없으면 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">참고 &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; 이&lt;/a&gt; 구현 &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; 구현 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">참고 &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; 값이 지정된 구체적인 유형인지 여부를 테스트로 제한되며, 테스트에 있는지 여부 타입 구현하는 특성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">그 주 &lt;code&gt;(T,)&lt;/code&gt; 항상 형의 원소 함유 한 튜플의 유형이고 &lt;code&gt;T&lt;/code&gt; 가 . 쉼표는 구문 명확성을 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">참고 &lt;code&gt;CoerceUnsized&lt;/code&gt; 는 주로 같은 스마트 포인터에 의해 사용되는 &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; 를 하고 &lt;code&gt;Arc&lt;/code&gt; 그들이 가리키는 것을 크기를 지정하지 않은 유형을 강요 할 수 있음을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">참고 것을 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에만 단일 스레드 시나리오에서 사용할 수 있습니다. 16 장에서 동시성에 대해 논의 할 때 다중 스레드 프로그램에서 참조 횟수를 계산하는 방법을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다. 예를 들어 &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; 구현 하여 &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; 형식의 작업을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다. 예를 들어 &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; 구현 하여 &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; 형식의 작업을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">하는 것으로 &lt;code&gt;T&lt;/code&gt; 가 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , 그렇지 않은 경우에도 복제 및 재설정 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; . 그러나 &lt;code&gt;replace&lt;/code&gt; 의 원래 값 해제 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; 에서 &lt;code&gt;self&lt;/code&gt; 가 반환 될 수 :</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">하는 것으로 &lt;code&gt;T&lt;/code&gt; 가 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , 그렇지 않은 경우에도 복제 및 재설정 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; . 그러나 &lt;code&gt;take&lt;/code&gt; 의 원래 값 해제 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; 에서 &lt;code&gt;self&lt;/code&gt; 가 반환 될 수 :</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">참고 것을 &lt;code&gt;T&lt;/code&gt; 는 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 우리가 심지어 복제 할 수 있도록 &lt;code&gt;self.buf[i]&lt;/code&gt; 이동을 방지하기 위해. 그러나 &lt;code&gt;replace&lt;/code&gt; 를 사용하여 해당 인덱스의 원래 값을 &lt;code&gt;self&lt;/code&gt; 에서 분리하여 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">참고 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 암시 &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt; ; 이것은 &lt;code&gt;b&lt;/code&gt; 에 도달하기 위해 &lt;code&gt;usize::MAX&lt;/code&gt; 단계 이상이 필요한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">참고 것을 &lt;code&gt;drain_filter&lt;/code&gt; 는 또한 관계없이 유지하거나 제거 할 수 있는지 여부, 필터 폐쇄의 모든 요소를 변이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; 를 사용하면 필터 유지 또는 제거 여부에 관계없이 필터 클로저의 모든 요소 를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; 를 사용하면 유지 또는 제거 여부에 관계없이 필터 클로저의 모든 값 을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;iter.filter(f).next()&lt;/code&gt; 에 해당 &lt;code&gt;iter.find(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;iter.find(f)&lt;/code&gt; 동일하다 &lt;code&gt;iter.filter(f).next()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">하는 것으로 &lt;code&gt;ptr::drop_in_place&lt;/code&gt; 이미이 불필요하여, 작업 부하가 drop_in_place 통화의 일부 적은 수의 감소시킬 수있는 경우에는이 검사를 수행합니다. 특히 슬라이스를 drop_in_place 할 수 있으며 모든 값에 대해 단일 needs_drop 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">참고 &lt;code&gt;query&lt;/code&gt; 지금이다 &lt;code&gt;String&lt;/code&gt; 호출하기 때문이 아니라 문자열 조각 &lt;code&gt;to_lowercase&lt;/code&gt; 하면 기존 데이터를 참조하는 것이 아니라 새로운 데이터를 생성한다. 예를 들어 쿼리가 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 라고 가정하십시오 . 문자열 슬라이스에 소문자 &lt;code&gt;u&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; 가 포함되어 있지 않으므로 &lt;code&gt;&quot;rust&quot;&lt;/code&gt; 가 포함 된 새 &lt;code&gt;String&lt;/code&gt; 을 할당해야합니다 . 우리가 통과 할 때 &lt;code&gt;query&lt;/code&gt; (가)에 인수로 &lt;code&gt;contains&lt;/code&gt; 지금 방법을, 우리의 서명 때문에 앰퍼샌드를 추가 할 필요가 &lt;code&gt;contains&lt;/code&gt; 문자열 조각을 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">참고 &lt;code&gt;std::env::args&lt;/code&gt; 인수가 유효하지 않은 유니 코드가 포함되어있는 경우 당황 할 것이다. 프로그램이 유효하지 않은 유니 코드를 포함하는 인수를 승인해야하는 경우 &lt;code&gt;std::env::args_os&lt;/code&gt; 대신 사용하십시오. 이 함수는 반복자를 생성합니다. &lt;code&gt;OsString&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 값 대신 OsString 값 합니다. &lt;code&gt;OsString&lt;/code&gt; 값은 플랫폼마다 다르고 &lt;code&gt;String&lt;/code&gt; 값 보다 다루기 가 더 복잡 하므로 여기서는 단순성 을 위해 &lt;code&gt;std::env::args&lt;/code&gt; 를 사용하기로 선택했습니다 .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;zip&lt;/code&gt; 만 4 쌍의 생산; 이론적 다섯 쌍 &lt;code&gt;(5, None)&lt;/code&gt; 때문에 생산되지 않는다 &lt;code&gt;zip&lt;/code&gt; 리턴 &lt;code&gt;None&lt;/code&gt; 입력 반복자 중 반환하지 않는 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Rust에는 선택적 함수 인수 나 가변 함수 (C-FFI 제외)라는 개념이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">스레드 로컬 스토리지에 저장된 유형의 소멸자가 실행되도록하기 위해 &quot;최선의 노력&quot;이 수행되지만 모든 플랫폼이 스레드 로컬 스토리지의 모든 유형에 대해 소멸자가 실행되도록 보장 할 수는 없습니다. 예를 들어, 소멸자가 실행되지 않는 알려진 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">참고 &lt;code&gt;()&lt;/code&gt; -returning &lt;code&gt;main&lt;/code&gt; 성공적인 종료에 암시 적으로 결과는, 그래서에서이를 반환 할 필요가 없습니다 &lt;code&gt;main&lt;/code&gt; 당신은 또한 다른 가능한 코드를 반환하지 않는 한이.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">캡처는 변수를 이동하거나 빌리지 만이 상황에서 클로저는 변수를 빌립니다. 캡처에 대한 자세한 내용은 http://rustbyexample.com/fn/closures/capture.html을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="translated">캡처는 변수를 이동하거나 차용하지만이 상황에서 클로저는 변수를 차용합니다. 더 많은 정보는 예제로 Rust 에서 &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;캡처&lt;/a&gt; 하기 장 을보세요.</target>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">매처는 단지 토큰 트리 일뿐입니다. 상기 언급 된 &quot;단순 NT&quot;는 메타-변수 NT이고; 따라서 그것은 비 반복입니다. 예를 들어 &lt;code&gt;$foo:ty&lt;/code&gt; 는 단순한 NT이지만 &lt;code&gt;$($foo:ty)+&lt;/code&gt; 는 복잡한 NT입니다.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">참조의 범위는 소개 된 곳에서 시작하여 해당 참조가 마지막으로 사용될 때까지 계속됩니다. 예를 들어, 변경 불가능한 참조가 도입되기 전에 변경 불가능한 참조의 마지막 사용이 발생하기 때문에이 코드는 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">성공적인 전송은 &lt;em&gt;&lt;/em&gt; 한다고해서이 채널에 버퍼가있는 경우 수신자가 데이터를 볼 수있는&lt;em&gt; 아닙니다&lt;/em&gt; . 수신기가 나중에 수신 할 수 있도록 내부 버퍼에 항목을 큐에 넣을 수 있습니다. 그러나 버퍼 크기가 0이면 채널이 랑데부 채널이되고이 함수가 성공을 반환하면 수신자가 실제로 데이터를 수신했음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="translated">&lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 내부의 값에 액세스하는 것은 안전합니다. 즉 , 콘텐츠가 삭제 된 &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 는 공용 안전 API를 통해 노출되지 않아야합니다. 따라서, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; 은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="translated">일부 유형에서는 정렬이 구현되지 않을 수 있습니다. 특히 일반적으로 &lt;code&gt;Debug&lt;/code&gt; 특성에 대해서는 구현되지 않습니다 . 패딩이 적용되는지 확인하는 좋은 방법은 입력 형식을 지정한 다음 결과 문자열을 패딩하여 출력을 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">일부 유형에서는 정렬이 구현되지 않을 수 있습니다. 특히, 일반적으로 &lt;code&gt;Debug&lt;/code&gt; 특성에 . 패딩이 적용되도록하는 좋은 방법은 입력을 포맷 한 다음이 결과 문자열을 사용하여 출력을 채우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">모든 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 은 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 이며 다음과 같이 캐스트 할 수 있습니다. &lt;code&gt;as&lt;/code&gt; 다음 같이 .</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">참고 모든 것을 &lt;code&gt;char&lt;/code&gt; 의가 유효 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 들, 그리고 하나에 캐스트 할 수 있습니다 &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">반환 된 요소를 포함하여 끝과 반환 된 요소 사이의 모든 요소가 사용됩니다. 이것은 또한 &lt;code&gt;nth_back(0)&lt;/code&gt; 동일한 반복자에서 nth_back (0)을 여러 번 하면 다른 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">반환 된 요소뿐만 아니라 모든 이전 요소는 반복자에서 사용됩니다. 즉, 이전 요소는 삭제되고 &lt;code&gt;nth(0)&lt;/code&gt; 동일한 반복자에서 nth (0)을 여러 번 하면 다른 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">컴파일 된 &lt;em&gt;Rust 프로그래밍 언어&lt;/em&gt; 의 이전 반복에 &lt;em&gt;있는&lt;/em&gt; 모든 코드 는 사용중인 Rust 컴파일러 버전을 업데이트하더라도 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 없이 계속 컴파일됩니다 . 이것이 바로 Rust의 하위 호환성 보장입니다!&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">컴파일 된 &lt;em&gt;The Rust Programming Language&lt;/em&gt; 의 첫 번째 인쇄 코드 는 사용중인 Rust 컴파일러 버전을 업데이트하더라도 프로젝트 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 없이 계속 컴파일됩니다 . 그것은 직장에서 Rust의 이전 버전과의 호환성을 보장합니다!&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">내부 버퍼의 남은 데이터는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="translated">내부 버퍼에 남은 데이터는 모두 손실됩니다. 따라서 기본 판독기에서 다음 읽기로 인해 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">이 함수는 절대 반환하지 않고 프로세스를 종료하므로 현재 스택 또는 다른 스레드 스택에서 소멸자가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">이 함수는 절대 반환하지 않고 프로세스를 종료하므로 현재 스택 또는 다른 스레드 스택에서 소멸자가 실행되지 않습니다. 클린 셧다운이 필요한 경우, 더 이상 소멸자가 남아 있지 않은 알려진 지점에서만이 함수를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Listing 10-13 의 동일한 &lt;em&gt;lib.rs&lt;/em&gt; 에서 &lt;code&gt;Summary&lt;/code&gt; 특성과 &lt;code&gt;NewsArticle&lt;/code&gt; 및 &lt;code&gt;Tweet&lt;/code&gt; 유형을 정의 &lt;em&gt;했으므로&lt;/em&gt; 모두 동일한 범위에 있습니다. 이 &lt;em&gt;lib.rs&lt;/em&gt; 는 우리가 &lt;code&gt;aggregator&lt;/code&gt; 라고 부르는 상자를위한 것이고 다른 누군가는 우리 상자의 기능을 사용 하여 라이브러리 범위 내에서 정의 된 구조체에 &lt;code&gt;Summary&lt;/code&gt; 특성 을 구현 하려고합니다. 그들은 먼저 특성을 범위로 가져와야합니다. &lt;code&gt;use aggregator::Summary;&lt;/code&gt; 지정 하면 됩니다 . 그러면 해당 유형에 대한 &lt;code&gt;Summary&lt;/code&gt; 을 구현할 수 있습니다 . &lt;code&gt;Summary&lt;/code&gt; trait는 또 다른 상자가 그것을 구현하기 위해 공개적인 trait 일 필요가있을 것이다. 이것은 Listing 10-12에서 &lt;code&gt;pub&lt;/code&gt; 키워드를 &lt;code&gt;trait&lt;/code&gt; 앞에 두기 때문이다 .</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">우리가 정의하는 하나의 일반적인 유형을 사용했기 때문에 참고 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 이 정의는 말한다 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체는 몇 가지 유형을 통해 제네릭 &lt;code&gt;T&lt;/code&gt; , 그리고 필드는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 있습니다 &lt;em&gt;모두&lt;/em&gt; 같은 유형, 어떤 유형 아마도. Listing 10-7과 같이 다른 유형의 값 을 가진 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스를 생성하면 코드가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 를 드롭하면 &lt;code&gt;T&lt;/code&gt; 의 드롭 코드를 호출하지 않습니다 . &lt;code&gt;T&lt;/code&gt; 가 초기화되면 T 가 삭제 되도록하는 것은 귀하의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">메소드 호출 참조 강제 변환으로 인해 단순히 특성 메소드를 호출하면 참조 값과 소유 값에서 작동하는 것처럼 작동합니다! 여기에 설명 된 구현은 최종 컨텍스트 &lt;code&gt;T&lt;/code&gt; 가 형식 매개 변수이거나 로컬에 알려지지 않은 일반 컨텍스트를위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">빈 배열 &lt;code&gt;[T; 0]&lt;/code&gt; 은 요소 유형 &lt;code&gt;T&lt;/code&gt; 와 동일한 정렬 요구 사항을 갖습니다 . 또한 크기가 0 인 유형의 정렬이 데이터 필드의 정렬보다 작거나 같더라도 오류가 보수적으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">환경 변수 이름은 Windows에서 대소 문자를 구분하지 않지만 대소 문자를 구분하지만 다른 모든 플랫폼에서는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">효과적으로 복사 된 크기 ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; )가 &lt;code&gt;0&lt;/code&gt; 이라도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">효과적으로 복사 된 크기 ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; )가 &lt;code&gt;0&lt;/code&gt; 이라도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패닉이 발생하더라도 값은 삭제 된 것으로 간주됩니다. &lt;code&gt;drop&lt;/code&gt; 이 다시 호출 되지 않도록해야 합니다. 이것은 일반적으로 컴파일러에 의해 자동으로 처리되지만 안전하지 않은 코드를 사용할 때, 특히 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; 사용할 때 의도하지 않게 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">표준 라이브러리에 &lt;code&gt;IpAddr&lt;/code&gt; 에 대한 정의가 포함되어 있어도 표준 라이브러리 정의를 범위로 가져 오지 않았으므로 충돌없이 자체 정의를 작성하고 사용할 수 있습니다. 우리는 7 장에서 타입을 범위에 포함시키는 것에 대해 더 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">일부 원자 연산을 지원하지 않는 향후 플랫폼이 추가 될 수 있습니다. 이식성이 뛰어난 코드는 어떤 원자 유형이 사용되는지주의를 기울여야합니다. &lt;code&gt;AtomicUsize&lt;/code&gt; 및 &lt;code&gt;AtomicIsize&lt;/code&gt; 는 일반적으로 가장 이식성이 뛰어나지 만 어느 곳에서도 사용할 수 없습니다. 참고로 &lt;code&gt;std&lt;/code&gt; 라이브러리에는 포인터 크기의 원자가 필요하지만 &lt;code&gt;core&lt;/code&gt; 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">열거 형 변형 생성자에 대한 일반 인수는 열거 형이 아닌 변형을 따릅니다. 예를 들어 &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; 대신 &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">여기서 &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 은 명확성을 기하기위한 것입니다. 이는 주어진 값으로 완료되었으며 파기되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">참고 경우에 것을 &lt;code&gt;Self::Item&lt;/code&gt; 아니라 &lt;code&gt;PartialOrd&lt;/code&gt; 있지만 &lt;code&gt;Ord&lt;/code&gt; , 위의 정의는이 함수가 반환 된 것을 의미한다 &lt;code&gt;false&lt;/code&gt; 두 연속 항목을 비교하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">만약합니다 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 동일한 파일에 두 점, 다음 파일을 가능성이 작업에 의해 잘릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">함수가 여러 유형의 인수를 취하지 만 컴파일러가 그 중 일부를 유추하도록하려면 유형 플레이스 홀더를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">경우 생성합니다 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 를 항목 자체가 참조를 포함하는 함수 또는 폐쇄 참조를 포함, 컴파일러는 먼저 표준 생략 규칙을 다할 것입니다. 일반적인 규칙으로 수명을 해결할 수 없으면 오류가 발생합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Rust에서 구조체는 크기가 지정되지 않은 유형을 포함하는 필드가 구조체에서 마지막으로 유일한 크기가 지정되지 않은 유형 필드 인 경우 크기가 지정되지 않은 유형 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">참고 일부 언어와 테스트 프레임 워크, 두 값이 같은 주장이라고하는 기능 매개 변수의 &lt;code&gt;expected&lt;/code&gt; 과 &lt;code&gt;actual&lt;/code&gt; , 우리가 인수 문제를 지정하는 순서. 그러나 Rust에서는 그것들을 &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; 라고 부르며 , 우리가 기대하는 값과 테스트중인 코드가 생성하는 값을 지정하는 순서는 중요하지 않습니다. 이 테스트에서 &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; 로 어설 션을 작성할 수 있으며 어설 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; 를 표시하는 실패 메시지가 나타납니다 :`(left == right)` 그리고 &lt;code&gt;left&lt;/code&gt; 는 &lt;code&gt;5&lt;/code&gt; 이고 &lt;code&gt;right&lt;/code&gt; 는 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">다른 속성을위한 장소를 갖기 위해 다른 &lt;code&gt;struct&lt;/code&gt; 를 도입 하면 의도 치 않은 부작용이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">기본 동적 종속성에서 정적 라이브러리에 링크 할 수 없으며이 경우 연결되지 않은 모든 기본 동적 종속성에 대한 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">동일한 메소드의 대체 구현에서 기본 구현을 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">스트림 길이는 시간이 지남에 따라 변경 될 수 있습니다 (예 : 데이터가 파일에 추가 될 때). 따라서이 메소드를 여러 번 호출한다고해서 매번 같은 길이를 리턴 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">양의 정수를 부정하면 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">다른 정규화는 일어나지 않습니다. 특히, &lt;code&gt;a/c&lt;/code&gt; 및 &lt;code&gt;a/b/../c&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 가 기호 링크 일 가능성을 설명하기 위해 구별 됩니다 (따라서 부모는 &lt;code&gt;a&lt;/code&gt; 가 아님 ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="translated">모든 오류에 &lt;code&gt;Backtrace&lt;/code&gt; 가 포함되는 것은 아닙니다 . 또한 &lt;code&gt;Backtrace&lt;/code&gt; 는 실제로 비어있을 수 있습니다. 자세한 내용은 &lt;code&gt;Backtrace&lt;/code&gt; 유형 자체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">모든 플랫폼이이 필드 업데이트를 파일의 메타 데이터에 보관하지는 않습니다. 예를 들어 Windows는 파일에 액세스하고 Linux에 &lt;code&gt;noatime&lt;/code&gt; 이있을 때 이번에는 업데이트를 비활성화 할 수있는 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">이 출력의 어느 곳에서도 &lt;code&gt;I got the value 4&lt;/code&gt; 못합니다.이 값 은 통과 테스트가 실행될 때 인쇄됩니다. 출력이 캡처되었습니다. 실패한 테스트의 결과 &lt;code&gt;I got the value 8&lt;/code&gt; 테스트 요약 출력 섹션에 표시하고 테스트 실패의 원인도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 에 대한 여러 호출에서 최근 호출로 전달 된 &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 만 깨우기를 받도록 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; 를 &lt;code&gt;handle_alloc_error&lt;/code&gt; 함수에 전달할 수는 없습니다 . 클라이언트는 중단없이 &lt;code&gt;grow_in_place&lt;/code&gt; 실패 에서 복구 할 수 있거나 중단에 의지하기 전에 다른 재 할당 방법으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; 를 &lt;code&gt;handle_alloc_error&lt;/code&gt; 함수에 전달할 수는 없습니다 . 클라이언트는 중단없이 &lt;code&gt;shrink_in_place&lt;/code&gt; 실패 에서 복구 하거나 중단에 의지하기 전에 다른 재 할당 방법으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Rust의 패닉은 항상 해제를 통해 구현되는 것은 아니지만 프로세스를 중단하여 구현할 수 있습니다. 패닉이 이런 식으로 구현 될 때이 함수가 호출되면이 함수는 프로세스를 중단하고 해제를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">이 블록의 일부가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">고정 및 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 래핑 된 포인터 유형 &lt;code&gt;P&lt;/code&gt; 자체가 아니라 가리키는 &lt;code&gt;P::Target&lt;/code&gt; 유형에만 영향을줍니다 . 예를 들어 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 인지 여부 는 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 의 동작에 영향을주지 않습니다 (여기서 &lt;code&gt;T&lt;/code&gt; 는 지정 대상 유형).</target>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">고정 및 &lt;code&gt;Unpin&lt;/code&gt; 는 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 래핑 된 포인터 유형 &lt;code&gt;P&lt;/code&gt; 자체가 아니라 지정된 &lt;code&gt;P::Target&lt;/code&gt; 유형에만 영향을 미칩니다 . 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Unpin&lt;/code&gt; 인지 여부 는 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 의 동작에 영향을 미치지 않습니다 (여기서 &lt;code&gt;T&lt;/code&gt; 는 pointed to type).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">읽기는 아직 읽지 않은 부분을 가리 키도록 슬라이스를 업데이트합니다. EOF에 도달하면 슬라이스가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 읽기로 리턴하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 쓰기를 반환하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 쓰기를 리턴하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::read&lt;/code&gt; 와 유사하게 짧은 읽기로 리턴하는 것은 오류가 아닙니다. 이러한 짧은 읽기에서 돌아올 때 파일 포인터는 여전히 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::write&lt;/code&gt; 와 유사하게 짧은 쓰기를 리턴하는 것은 오류가 아닙니다. 이러한 짧은 쓰기에서 돌아올 때 파일 포인터는 여전히 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 플랫폼은 단순히 &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; 측면에서 이를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">stdout은 기본적으로 종종 라인 버퍼링되므로 출력이 즉시 방출되도록 &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Rust의 안전 보장 덕분 에이 모듈에서 동기화 프리미티브를 사용하지 않는다고 가정 할 때 전역 (정적) 변수에 액세스하려면 &lt;code&gt;unsafe&lt;/code&gt; 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">참고 그 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 연산자 단락, 즉 결과에 기여하는 경우에만 두 번째 피연산자를 평가합니다. 이 동작은 특성으로 시행 할 수 없으므로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 과부하 연산자로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">있습니다 &lt;code&gt;*&lt;/code&gt; 운영자가받는 호출로 대체됩니다 &lt;code&gt;deref&lt;/code&gt; 다음 방법과의 호출 &lt;code&gt;*&lt;/code&gt; 한 번만 운영자, 우리가 사용할 때마다 &lt;code&gt;*&lt;/code&gt; 을 우리의 코드에. 의 대체 때문에 &lt;code&gt;*&lt;/code&gt; 의 운영자가 같이 Recurse 무한, 우리는 타입의 데이터와 끝까지하지 않습니다 &lt;code&gt;i32&lt;/code&gt; 성냥, &lt;code&gt;5&lt;/code&gt; 년 &lt;code&gt;assert_eq!&lt;/code&gt; 리스팅 15-9.</target>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;FromFn&lt;/code&gt; 반복자가 폐쇄의 행동에 대한 가정을하지 않기 때문에 보수적으로 구현하지 않습니다 &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; 를&lt;/a&gt; , 또는 무시 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt; 기본에서 &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;FromFn&lt;/code&gt; 반복자가 폐쇄의 행동에 대한 가정을하지 않기 때문에 보수적으로 구현하지 않습니다 &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; 을&lt;/a&gt; , 또는 오버라이드 (override) &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; 기본에서 &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">있습니다 &lt;code&gt;PrimaryColor&lt;/code&gt; 및 &lt;code&gt;SecondaryColor&lt;/code&gt; 유형이 첫 페이지에 나와있는, 나있다되지 않습니다 &lt;code&gt;mix&lt;/code&gt; 기능. &lt;code&gt;kinds&lt;/code&gt; 와 &lt;code&gt;utils&lt;/code&gt; 를 클릭 하여보아야합니다.</target>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">점을 유의 &lt;code&gt;black&lt;/code&gt; 및 &lt;code&gt;origin&lt;/code&gt; 값이 다른 튜플 구조체의 그들이 있기 때문에있는 거 인스턴스가, 다른 유형입니다. 구조체 내 필드의 유형이 동일하더라도 정의한 각 구조체는 고유 한 유형입니다. 예를 들어, 두 가지 유형이 세 개의 &lt;code&gt;i32&lt;/code&gt; 값 으로 구성되어 있어도 &lt;code&gt;Color&lt;/code&gt; 유형의 매개 변수를 사용하는 함수 는 &lt;code&gt;Point&lt;/code&gt; 를 인수로 사용할 수 없습니다 . 그렇지 않으면 튜플 구조체 인스턴스는 튜플처럼 동작합니다. 튜플 구조체 인스턴스를 개별 조각으로 구성 해제 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 개별 값에 액세스하기위한 색인 등이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">있습니다 &lt;code&gt;internal_adder&lt;/code&gt; 의 함수로 표시되지 &lt;code&gt;pub&lt;/code&gt; ,하지만 테스트는 단지 녹 코드이며, 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈이 또 다른 모듈, 당신은 가져올 수 &lt;code&gt;internal_adder&lt;/code&gt; 테스트의 범위로하고 호출합니다. 개인 기능을 테스트해야한다고 생각하지 않는다면 Rust에는 그렇게하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;mod common;&lt;/code&gt; 유의하십시오 . 선언은 우리가 Listing 7-21에서 보여준 모듈 선언과 동일합니다. 그런 다음 테스트 함수에서 &lt;code&gt;common::setup()&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">참고이 &lt;code&gt;mod common;&lt;/code&gt; 선언은 Listing 7-25에서 보여준 모듈 선언과 동일하다. 그런 다음 테스트 함수에서 &lt;code&gt;common::setup()&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">있습니다 &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; 에 문 &lt;em&gt;SRC를 / lib.rs는&lt;/em&gt; 또한 변경도하지 않은 &lt;code&gt;use&lt;/code&gt; 파일이 상자의 일환으로 컴파일 무엇에 어떤 영향을 미친다. &lt;code&gt;mod&lt;/code&gt; 키워드는 모듈을 선언하고 녹 해당 모듈에 들어가는 코드 모듈과 동일한 이름의 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Rust 구문 은 단일 정수 리터럴 대신 정수 리터럴 &lt;code&gt;1i8&lt;/code&gt; 에 대한 &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;단항 빼기 연산자&lt;/a&gt; 를 적용하는 것으로 &lt;code&gt;-1i8&lt;/code&gt; 을 고려 합니다.</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="translated">결과 레이아웃의 정렬은 두 부분의 정렬을 보장하기 위해 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 의 최대 정렬이됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 &lt;code&gt;reserve&lt;/code&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 예비를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">대기 시간이 모노 토닉 시계로 측정되고 시스템 시간 변경에 영향을받지 않도록 최선의 노력을 다합니다.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">대기 시간이 모노 토닉 시계로 측정되고 시스템 시간 변경에 영향을받지 않도록 최선의 노력을 다합니다. 이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 연관된 부울 술어가 있으며이 함수가 가짜 웨이크 업을 방지하기 위해 리턴 될 때마다 술어를 항상 확인해야합니다. 또한, 허위 웨이크에도 불구하고 타임 아웃이 일부 지속 시간을 초과하지 않는 것이 바람직하므로, 수면 지속 시간은 슬리핑 된 양만큼 감소된다. 또는 &lt;code&gt;wait_timeout_until&lt;/code&gt; 메소드를 사용하여 가짜 깨우기와 상관없이 조건이 총 시간 종료에 도달 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="translated">대기 시간이 단조로운 시계로 측정되고 시스템 시간 변경의 영향을받지 않도록 최선의 노력을 다합니다. 이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 관련된 부울 술어가 있으며,이 함수가 반환 될 때마다 술어를 항상 확인하여 가짜 깨우기를 방지해야합니다. 추가적으로, 시간 초과가 가짜 웨이크에도 불구하고 일정 기간을 초과하지 않는 것이 일반적으로 바람직하기 때문에 수면 시간은 수면량만큼 감소합니다. 또는 &lt;code&gt;wait_timeout_while&lt;/code&gt; 메소드를 사용하여 술어가 참인 동안 제한 시간을 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 능력은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">전체 인스턴스는 변경 가능해야합니다. 녹으로 인해 특정 필드 만 변경 가능으로 표시 할 수 없습니다. 다른 식과 마찬가지로 함수 본문에서 마지막 식으로 구조체의 새 인스턴스를 구성하여 해당 새 인스턴스를 암시 적으로 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">여기서 오류는 일반 함수의 정의에 있습니다. 우리는 &lt;code&gt;Debug&lt;/code&gt; 를 구현하는 매개 변수로만 호출하지만 컴파일러는 여전히 함수를 거부합니다. 가능한 모든 입력 유형에서 작동해야합니다. 이 예제를 컴파일하려면 허용하는 제네릭 형식을 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">입력 토큰의 확장 된 결과는 나중에 변경 될 수 있습니다. 출력에 의존하는 경우주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">가장 안쪽의 객체가 경계를 설정하므로 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; 는 여전히 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">소문자 점선 'i'는 라틴어와 동일합니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">매크로는 디버깅 도구로 사용되기 때문에 버전 관리에서 장기간 사용하지 않아야합니다. 버전 제어에 추가해야하는 디버그 출력과 관련된 사용 사례는 &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;로부터 &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 상자.</target>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">이 매크로는 디버깅 도구로 사용되므로 버전 관리에서 장기간 사용하지 않는 것이 좋습니다. 버전 제어에 추가되어야하는 디버그 출력과 관련된 사용 사례는 디버그와 같은 매크로에 의해 더 잘 제공됩니다 &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;로부터 &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 상자.</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">테스트 결과와 테스트 결과는 인터리브됩니다. 그 이유는 이전 섹션에서 설명한 것처럼 테스트가 병렬로 실행되기 때문입니다. 사용해보십시오 &lt;code&gt;--test-threads=1&lt;/code&gt; 옵션과 &lt;code&gt;--nocapture&lt;/code&gt; 플래그를, 출력 외모는 다음 좋아하는 것을 볼!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">포인터 값은 잠재적으로 &lt;code&gt;T&lt;/code&gt; 에 대한 유효한 포인터를 나타낼 수 있습니다 . 이는 &quot;초기화되지 않은&quot;센티넬 값으로 사용되어서는 안됩니다. 느리게 할당하는 형식은 다른 방법으로 초기화를 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">포인터 값은 잠재적으로 유효한 포인터를 나타낼 수 있습니다. 이는 &quot;아직 초기화되지 않은&quot;센티널 값으로 사용되지 않아야 함을 의미합니다. 느리게 할당되는 유형은 다른 방법으로 초기화를 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">메인 스레드의 스택 크기는 Rust에 의해 결정 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">표준 라이브러리 ( &lt;code&gt;std&lt;/code&gt; )도 패키지 외부에있는 상자입니다. 표준 라이브러리는 Rust 언어와 함께 제공되므로 &lt;code&gt;std&lt;/code&gt; 를 포함하도록 &lt;em&gt;Cargo.toml&lt;/em&gt; 을 변경할 필요가 없습니다 . 그러나 항목을 패키지 범위로 가져 오는 데 &lt;code&gt;use&lt;/code&gt; 하여 참조해야합니다 . 예를 들어 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하면 다음 줄을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../convert/trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 특성 은 고정 크기 배열이 아닐 수있는 유형에 대해 유사한 메서드를 제공합니다. 구현자는 대신 이러한 특성을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">AsRef 및 AsMut 특성은 고정 크기 배열이 아닌 유형에 대해 유사한 방법을 제공합니다. 구현자는 이러한 특성을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 유형은 이제 &lt;code&gt;temp&lt;/code&gt; 유형에서 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">때 반복자를 기본주의는 여전히 진보 &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 다음의 요소를 검색하기 위해, : 처음이라고 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 의 따라서 부작용 (다음 값을 가져 오는 이외 즉, 아무것도), 기본 반복자에 호출 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 방법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">리턴 값의 유틸리티가 필요 유의 &lt;code&gt;align&lt;/code&gt; 보다 적은 수 또는 메모리의 전체 할당 된 블록의 시작 주소의 배향과 동일한다. 이 제약 조건을 충족시키는 한 가지 방법은 &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">열거 형의 변형은 식별자 아래에 네임 스페이스가 있으며 이중 콜론을 사용하여 둘을 분리합니다. 이것이 유용한 이유는 이제 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 및 &lt;code&gt;IpAddrKind::V6&lt;/code&gt; 값이 모두 같은 유형 인 &lt;code&gt;IpAddrKind&lt;/code&gt; 이기 때문 입니다. 예를 들어, &lt;code&gt;IpAddrKind&lt;/code&gt; 를 취하는 함수를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; 만 사용하는 것과 밑줄로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있습니다. 구문 &lt;code&gt;_x&lt;/code&gt; 는 여전히 값을 변수에 바인딩 하지만 &lt;code&gt;_&lt;/code&gt; 는 전혀 바인딩하지 않습니다. 이러한 차이점이 중요한 경우를 보여주기 위해 Listing 18-21은 오류를 제공 할 것이다.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">파일이 즉시 삭제된다는 보장은 없습니다 (예 : 플랫폼에 따라 다른 열린 파일 디스크립터가 즉시 제거되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">두 &lt;code&gt;Match&lt;/code&gt; 사이에 &lt;code&gt;Reject&lt;/code&gt; 가 두 개 이상있을 수 있으므로 두 경기 를 하나로 합칠 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">이러한 출력은 여러 개를 지정하면 컴파일러가 다시 컴파일하지 않고도 한 번에 각 형태의 출력을 생성한다는 점에서 스택 가능합니다. 그러나 이것은 동일한 방법으로 지정된 출력에만 적용됩니다. 경우에만 &lt;code&gt;crate_type&lt;/code&gt; 의 속성이 지정되어, 그들은 모두 내장되지만, 하나 또는 그 이상의 경우 &lt;code&gt;--crate-type&lt;/code&gt; 명령 줄 플래그가 지정된 후 만 출력이 내장됩니다.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 이러한 요구 사항은 특성 자체가 대칭과 이적으로 구현되어야한다는 것을 의미하는 것이 : 만약 &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; 및 &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 다음 &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 이러한 요구 사항은 특성 자체가 대칭과 이적으로 구현되어야한다는 것을 의미하는 것이 : 만약 &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; 및 &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 다음 &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;let&lt;/code&gt; 문은 &lt;code&gt;expensive_closure&lt;/code&gt; 에 익명 함수 를 호출 한 &lt;em&gt;결과 값&lt;/em&gt; 이 아니라 익명 함수 의 &lt;em&gt;정의&lt;/em&gt; 가 포함됨을 의미합니다. 한 시점에서 호출 할 코드를 정의하고 해당 코드를 저장 한 후 나중에 호출하기 때문에 클로저를 사용하고 있음을 상기하십시오. 우리가 호출하려는 코드는 이제 &lt;code&gt;expensive_closure&lt;/code&gt; 에 저장됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">이 방법은 수명이 &lt;code&gt;'a&lt;/code&gt; 인 S에 대한 참조가 필요 합니다 . 보다 짧은 아무것도 &lt;code&gt;'a&lt;/code&gt; 짧은 수명이 후 것을 의미합니다 : 충분 &lt;code&gt;demo&lt;/code&gt; (! 같은 소멸자로) 마감이 다른 것을 실행에 액세스 할 수 &lt;code&gt;s.data&lt;/code&gt; 을 다시 위반하는, 그 짧은 수명의 종료 후 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow의 독점을 접속하다.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="translated">이 동작은 &lt;code&gt;impl Future&lt;/code&gt; 를 반환하는 함수로 desugaring 한 결과입니다.이 경우 desugar 함수 는 &lt;code&gt;unsafe&lt;/code&gt; 함수이지만 반환 값은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="translated">이것은 나머지 &lt;code&gt;Weak&lt;/code&gt; 포인터 를 분리하는 &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt; &lt;code&gt;Rc::make_mut&lt;/code&gt; &lt;/a&gt; 의 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">이것은 OS 문자열 형식으로 문자열의 바이트 수를 반환 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">&lt;code&gt;transmute&lt;/code&gt; 와 달리 &lt;code&gt;v&lt;/code&gt; 는 이동하지 않으며 소멸자가 호출되는 것을 피하기 위해 &lt;code&gt;mem::forget(v)&lt;/code&gt; 를 호출해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">이 예제는 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 아니라 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용합니다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 단일 스레드 시나리오를위한 것입니다. 다중 스레드 상황에서 공유 변경 가능성이 필요한 경우 &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">이 예제는 아직 컴파일되지 않습니다. 우리는 왜 조금 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">이 기능 &lt;strong&gt;은&lt;/strong&gt; Rust에서 &lt;strong&gt;모든 패닉&lt;/strong&gt; 을 &lt;strong&gt;포착하지 못할 수도 있습니다&lt;/strong&gt; . Rust의 패닉은 항상 풀기를 통해 구현되는 것은 아니지만 프로세스를 중단하여 구현할 수도 있습니다. 이 기능 은 풀리는 패닉 &lt;em&gt;만&lt;/em&gt; 잡을 &lt;em&gt;뿐&lt;/em&gt; 프로세스를 중단시키는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">이 함수는 구별 된 참고 &lt;code&gt;as&lt;/code&gt; 유지] 시도 캐스팅, &lt;em&gt;숫자&lt;/em&gt; 값이 아닌 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">이 기능은 슬라이스 대신 작업하도록 특수화된다는 점을 제외하면 &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. Rust가 전문화를 얻는 경우이 기능은 더 이상 사용되지 않을 수 있지만 여전히 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">이 함수는 대신 슬라이스로 작업하도록 전문화된다는 점을 제외하면 &lt;a href=&quot;struct.vec#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. Rust가 전문화되면이 함수는 더 이상 사용되지 않을 것입니다 (하지만 여전히 사용 가능).</target>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 연관된 부울 술어가 있으며이 함수가 가짜 웨이크 업을 방지하기 위해 리턴 될 때마다 술어를 항상 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">이 기능은 해상도가 수행되는 동안 현재 스레드를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">이 함수는 초기 값이 NaN 인 경우에도 NaN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">이것은 Windows-1252 일명 코드 페이지 1252 &lt;em&gt;와도&lt;/em&gt; 다릅니다. 이 코드 페이지 1252는 구두점 및 다양한 라틴 문자에 일부 (전부는 아님) 공백을 할당하는 수퍼 셋 ISO / IEC 8859-1입니다.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 왼쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;a href=&quot;#method.rotate_left&quot;&gt; &lt;code&gt;rotate_left&lt;/code&gt; &lt;/a&gt; 함수를 구현하며 대신 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="translated">이것은 왼쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;code&gt;[&lt;/code&gt; rotate_left`] (# method.rotate_left) 함수를 구현합니다 . 대신 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">이 것을 참고 &lt;em&gt;하지&lt;/em&gt; 와 동일한 회전 왼쪽; 랩핑 시프트-왼쪽의 RHS는 다른 쪽 끝으로 리턴되는 LHS로부터 시프트 된 비트가 아니라 타입의 범위로 제한된다. 프리미티브 정수 타입은 모두 &lt;code&gt;rotate_left&lt;/code&gt; 함수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 오른쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 오른쪽 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;a href=&quot;#method.rotate_right&quot;&gt; &lt;code&gt;rotate_right&lt;/code&gt; &lt;/a&gt; 함수를 구현하며 대신 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 오른쪽 회전과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; . 랩핑 시프트 우측의 RHS는 다른 쪽 끝으로 리턴되는 LHS로부터 시프트 된 비트가 아니라 타입의 범위로 제한된다. 프리미티브 정수 타입은 모두 &lt;code&gt;rotate_right&lt;/code&gt; 함수를 구현하는데 , 대신 원하는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">이는 ISO / IEC 8859-1 (일명 하이픈이 있음)과 다르며 일부 &quot;공백&quot;, 문자에 할당되지 않은 바이트 값을 남겨 둡니다. ISO-8859-1 (IANA 하나)은이를 C0 및 C1 제어 코드에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">아직 완전히 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">이 목록은 나중에 설명이 이루어질수록 시간이 지남에 따라 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">IPv6 소켓에는 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">이것은 IPv6 소켓에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 보다는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 가져도 기본 파일의 내용을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 아닌 &lt;code&gt;&amp;amp;self&lt;/code&gt; 하더라도 기본 파일의 권한을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">이 메서드는 반환 된 레이아웃의 정렬이 다른지 여부에 관계없이 전체 크기에 여백을 추가하지 않습니다. 경우 즉, &lt;code&gt;K&lt;/code&gt; 는 크기 (16)가, &lt;code&gt;K.align_to(32)&lt;/code&gt; 것이다 &lt;em&gt;여전히&lt;/em&gt; 크기 (16)이있다.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">이 방법은 문자열의 할당 용량에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">이 방법은 벡터의 할당 된 용량에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">이 구조는 유의 &lt;strong&gt;하지 &lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; 와 FFI 함수의 서명에 배치하는 것은 좋지 않습니다. 대신, FFI 함수의 안전한 래퍼는 안전하지 않은 &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt; 생성자를 활용하여 다른 소비자에게 안전한 인터페이스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">이 구조는 유의 &lt;strong&gt;하지 &lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; 와 FFI 함수의 서명에 배치하는 것은 좋지 않습니다. 대신 FFI 함수의 안전한 래퍼는 안전하지 않은 &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt; &lt;code&gt;CStr::from_ptr&lt;/code&gt; &lt;/a&gt; 생성자를 활용하여 다른 소비자에게 안전한 인터페이스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">이 기술은 또한 일치 표현식의 팔에도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">이렇게하면 초과 용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt; 과 달리이 반복자는 융합 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 첫 번째 &lt;code&gt; None&lt;/code&gt; 이 반환 된 후이 반복자가 반환하는 내용도 지정되지 않습니다 . 융합 된 반복기가 필요하면 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 와 달리이 함수는 stdin을 삭제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">배열 표현식과 달리이 구문은 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 를 구현하는 모든 요소를 ​​지원하며 요소 수는 상수 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">크기가 지정되지 않은 유형에는 길이, vtable 등이 아닌 원시 데이터 포인터 만 고려되므로 가능한 많은 널 포인터가 있습니다. 따라서 널인 두 포인터는 여전히 서로 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">앞으로 이런 식으로 &lt;code&gt;self&lt;/code&gt; 를 사용하는 것이 필요하지 않을 수도 있습니다. Rust 개발자들이 제거하려고하는 언어의 불일치입니다.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">사용합니다 &lt;code&gt;type&lt;/code&gt; 때문에 키워드 것은 여기에 작동하지 않는 &lt;code&gt;type&lt;/code&gt; 단지 형 별칭을 소개합니다 :</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="translated">이러한 특성 메서드를 사용하면 함수 호출 당 힙 할당이 발생합니다. 이는 대부분의 애플리케이션에서 상당한 비용이 아니지만, 초당 수백만 번 호출 될 것으로 예상되는 저수준 함수의 공용 API에서이 기능을 사용할지 여부를 결정할 때 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">수동으로 지정된 판별 변수가없는 변형은 0부터 시작하여 위에서 아래로 번호가 매겨 지므로 관련이없는 변형으로 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">여기에 유형 주석이 추가되었습니다. 이 벡터에 값을 삽입하지 않기 때문에 Rust는 어떤 종류의 요소를 저장할 것인지 모릅니다. 이것은 중요한 포인트입니다. 벡터는 제네릭을 사용하여 구현됩니다. 우리는 10 장에서 자신 만의 타입으로 제네릭을 사용하는 방법을 다룰 것입니다. 지금, 표준 라이브러리가 제공 하는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 타입은 모든 타입을 보유 할 수 있으며 특정 벡터가 특정 타입을 보유 할 때 타입은 꺾쇠 괄호 안에 지정됩니다. Listing 8-1 에서 &lt;code&gt;v&lt;/code&gt; 의 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 유형의 요소를 보유 할 것이라고 Rust에 말했다 .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">부울을 보유하는 &lt;code&gt;case_sensitive&lt;/code&gt; 필드를 추가했습니다 . 다음으로, &lt;code&gt;case_sensitive&lt;/code&gt; 필드의 값 을 확인하고 이를 사용하여 &lt;code&gt;search&lt;/code&gt; 함수 또는 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수 를 호출할지 여부를 결정하는 데 &lt;code&gt;run&lt;/code&gt; 함수 가 필요합니다 ( 목록 12-22 참조). 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">결과 &lt;code&gt;split_at_mut&lt;/code&gt; 함수를 &lt;code&gt;unsafe&lt;/code&gt; 로 표시 할 필요가 없으며 safe Rust에서이 함수를 호출 할 수 있습니다. &lt;code&gt;unsafe&lt;/code&gt; 코드를 안전하게 사용하는 함수를 구현하여 안전하지 않은 코드를 안전하게 추상화했습니다. 이 함수는이 함수가 액세스 할 수있는 데이터에서 유효한 포인터 만 생성하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 바로 뒤에 &lt;code&gt;T&lt;/code&gt; 를 선언 해야 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 유형에서 메소드를 구현하도록 지정할 수 있습니다 . &lt;code&gt;impl&lt;/code&gt; 뒤에 &lt;code&gt;T&lt;/code&gt; 를 일반 유형으로 선언 하면 Rust는 &lt;code&gt;Point&lt;/code&gt; 의 꺾쇠 괄호 유형이 콘크리트 유형이 아닌 일반 유형 임을 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_string&lt;/code&gt; 이라는 여러 함수를 사용할 수 있으므로 앞에서 설명한 &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&quot;고급 특성&quot;&lt;/a&gt; 섹션 에서 설명한 정규화 된 구문을 사용해야합니다 . 여기에서는 표준 라이브러리가 &lt;code&gt;Display&lt;/code&gt; 를 구현하는 모든 유형에 대해 구현 한 &lt;code&gt;ToString&lt;/code&gt; 특성에 정의 된 &lt;code&gt;to_string&lt;/code&gt; 함수를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">10 장에서 논의한 것처럼이 방법에 대한 수명 주석이 필요합니다. &lt;code&gt;post&lt;/code&gt; 대한 참조를 인수로 사용하여 해당 &lt;code&gt;post&lt;/code&gt; 일부에 대한 참조를 반환하므로 반환 된 참조 의 수명은 &lt;code&gt;post&lt;/code&gt; 인수의 수명 .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">먼저 표준 라이브러리의 collections 부분에서 &lt;code&gt;HashMap&lt;/code&gt; 을 &lt;code&gt;use&lt;/code&gt; 합니다 . 세 가지 공통 모음 중이 모음은 가장 많이 사용되지 않으므로 서곡에 자동으로 포함 된 기능에는 포함되지 않습니다. 해시 맵은 표준 라이브러리의 지원이 적습니다. 예를 들어 내장 매크로가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">왼쪽에 &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 가 필요합니다 . 예를 들어 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 수집 할 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">&lt;code&gt;v1_iter&lt;/code&gt; 를 변경 가능 하게 만들어야 했습니다. 반복자 에서 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하면 반복자가 시퀀스의 위치를 ​​추적하는 데 사용하는 내부 상태가 변경됩니다. 즉,이 코드 &lt;em&gt;는&lt;/em&gt; 반복자를 &lt;em&gt;소비&lt;/em&gt; 하거나 사용합니다. &lt;code&gt;next&lt;/code&gt; 호출 할 때마다 반복기에서 항목을 가져옵니다. 루프가 &lt;code&gt;v1_iter&lt;/code&gt; 의 소유권을 가져 와서 장면 뒤에서 변경 가능하게 했기 때문에 &lt;code&gt;for&lt;/code&gt; 루프를 사용할 때 &lt;code&gt;v1_iter&lt;/code&gt; 를 변경 가능 하게 만들 필요가 없었 습니다 .</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수가 매개 변수의 소유권을 갖기를 원하지 않기 때문에 함수 가 참조 인 문자열 슬라이스를 사용하기를 원합니다 . 목록 10-20에서 사용하는 매개 변수가 우리가 원하는 매개 변수 인 이유에 대한 자세한 내용은 4 장의 &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&quot;문자열 슬라이스를 매개 변수로&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수가 매개 변수의 소유권을 갖기를 원하지 않기 때문에 함수 가 참조 인 문자열 슬라이스를 사용하기를 원합니다 . 우리는 함수가 &lt;code&gt;String&lt;/code&gt; 조각 (변수 &lt;code&gt;string1&lt;/code&gt; 에 저장된 유형 )뿐만 아니라 문자열 리터럴 (변수 &lt;code&gt;string2&lt;/code&gt; 가 포함하는 것) 을 허용하도록하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; 모듈 안에 새로운 줄을 추가했습니다 : &lt;code&gt;use super::*;&lt;/code&gt; . &lt;code&gt;tests&lt;/code&gt; 모듈은 우리가에서 7 장에서 다루는 보통의 가시성 규칙은 다음과 일반 모듈 &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;개인 정보 보호 경계로 모듈&quot;&lt;/a&gt; 절을 참조하십시오. 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈은 내부 모듈로서, 우리는 내부 모듈의 범위 내로 외부 모듈 테스트중인 코드를 가져와야. 여기서는 glob를 사용하므로 외부 모듈에서 정의한 모든 것을이 &lt;code&gt;tests&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; 모듈 내부에 새 줄을 추가했습니다 . &lt;code&gt;use super::*;&lt;/code&gt; . &lt;code&gt;tests&lt;/code&gt; 모듈은 우리가 7 장에서 다루는 보통의 가시성 규칙은 다음과 일반 모듈 &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&quot;모듈 트리의 항목을 참조하기위한 경로&quot;&lt;/a&gt; 절을 참조하십시오. 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈은 내부 모듈로서, 우리는 내부 모듈의 범위 내로 외부 모듈 테스트중인 코드를 가져와야. 여기서는 glob을 사용하므로 외부 모듈에서 정의한 모든 것을이 &lt;code&gt;tests&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">이전 테스트의 &lt;code&gt;contents&lt;/code&gt; 도 편집했습니다 . &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; 라는 텍스트가 새 줄에 추가되었습니다 . 대소 문자 구분 방식으로 검색 할 때 쿼리 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 와 일치하지 않아야하는 대문자 D를 사용합니다 . 이 방법으로 이전 테스트를 변경하면 이미 구현 한 대소 문자 구분 검색 기능을 실수로 중단하지 않습니다. 이 테스트는 이제 통과해야하며 대소 문자를 구분하지 않는 검색을 수행하면서 계속 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="translated">와일드 카드 &lt;code&gt;*&lt;/code&gt; 가 유형에 사용되는 경우 메서드를 가져 오지 않습니다 ( &lt;code&gt;enum&lt;/code&gt; 의 경우 아래 예에 표시된대로 변형을 가져 오지만).</target>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계가 발생하는 경우, 유의 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 일반적으로보다 더 빨리 될 것입니다 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; 는&lt;/a&gt; 일반적으로보다 더 빨리 될 것입니다 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; 의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Rust에서는 환경 변수에 대한 동시 액세스가 안전하지만 일부 플랫폼은 환경 검사를 위해 본질적으로 안전하지 않은 스레드 안전하지 않은 API 만 노출합니다. 결과적으로 안전하지 않은 외부 FFI 기능에 대한 호출을 감사 할 때 외부 환경 액세스가 Rust의 액세스와 올바르게 동기화되도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Rust에서는 환경 변수에 대한 동시 액세스가 안전하지만 일부 플랫폼은 환경을 검사하기 위해 본질적으로 안전하지 않은 스레드 안전하지 않은 API 만 노출합니다. 결과적으로 안전하지 않은 외부 FFI 함수에 대한 호출을 감사 할 때 외부 환경 액세스가 Rust의 액세스와 적절하게 동기화되도록 추가주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">&lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 변경하거나 변경 가능하게 앨리어싱하는 것은 괜찮지 만 (다른 방법으로 불변을 적용하는 경우) 여러 개의 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 별칭 을 갖는 것은 아직 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 변경하는 동안 (다른 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 가 셀 별칭을 참조 하는 경우에도 ) 괜찮지 만 (위의 불변을 다른 방식으로 적용하는 경우) 여전히 정의되지 않은 동작으로 여러 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 별칭. 즉, &lt;code&gt;UnsafeCell&lt;/code&gt; 은 &lt;em&gt;공유&lt;/em&gt; 액세스 ( &lt;em&gt;예 : &lt;/em&gt; &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 참조를 통해) 와 특별한 상호 작용을 갖도록 설계된 래퍼입니다 . 를 처리 할 때 마법은 전혀 없다 &lt;em&gt;독점&lt;/em&gt; (액세스 &lt;em&gt;예&lt;/em&gt; 를 통해, &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; ) :그 기간 동안 셀이나 래핑 된 값 모두 별칭을 지정할 수 없습니다. &lt;code&gt;&amp;amp;mut&lt;/code&gt; 빌려. 이것은 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 산출하는 &lt;code&gt;unsafe&lt;/code&gt; getter 인 &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt; &lt;code&gt;.get_mut()&lt;/code&gt; &lt;/a&gt; 접근 자에 의해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">이 기능을 사용하면 메인 스레드가 종료되면 실행이 완료되었는지 여부에 관계없이 새 스레드가 중지됩니다. 이 프로그램의 출력은 매번 약간 씩 다를 수 있지만 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">쓰면 아직 쓰지 않은 부분을 가리 키도록 슬라이스가 업데이트됩니다. 완전히 덮어 쓰면 슬라이스가 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 를&lt;/a&gt; 사용할 수 없습니다 . &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환하지 않는 함수의 연산자 . 대신 &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; 호출 하거나 반환 값을 &lt;code&gt;match&lt;/code&gt; 시켜 가능한 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">read 및 write 메소드에는 &lt;code&gt;&amp;amp;mut File&lt;/code&gt; 필요하지만 &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 인터페이스로 인해 &lt;code&gt;&amp;amp;File&lt;/code&gt; 홀더는 &amp;amp; File 을 사용하는 메소드를 통해 또는 기본 OS 오브젝트를 검색하고 &lt;code&gt;&amp;amp;File&lt;/code&gt; 을 수정하여 파일을 계속 수정할 수 있습니다. 그런 식으로. 또한 많은 운영 체제에서 서로 다른 프로세스로 파일을 동시에 수정할 수 있습니다. &lt;code&gt;&amp;amp;File&lt;/code&gt; 을 보유 하면 파일이 변경되지 않는다고 가정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">&lt;code&gt;$crate&lt;/code&gt; 는 현재 상자를 나타내므로 매크로가 아닌 항목을 참조 할 때 정규화 된 모듈 경로와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">등, 그 주 &lt;code&gt;Option&lt;/code&gt; 열거의 &lt;code&gt;Result&lt;/code&gt; 우리가 지정할 필요가 없습니다 열거 및 그 변종은 전주곡에 의해 범위를하게 된 &lt;code&gt;Result::&lt;/code&gt; 전과 &lt;code&gt;Ok&lt;/code&gt; 하고 &lt;code&gt;Err&lt;/code&gt; 변종 &lt;code&gt;match&lt;/code&gt; 팔.</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">달리합니다 &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; 수행의 반복 인스턴스 것을하지 보장 &lt;code&gt;self&lt;/code&gt; 올바르게 정렬됩니다의 지정된 인스턴스 경우에도 &lt;code&gt;self&lt;/code&gt; 올바르게 정렬됩니다. 다시 말해서, &lt;code&gt;repeat_packed&lt;/code&gt; 에 의해 리턴 된 레이아웃 이 배열을 할당하는 데 사용되는 경우, 배열의 모든 요소가 올바르게 정렬되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">원시 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; ( 'slice'라고도 함)에 대한 문서를 참고하십시오 . &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 대한 많은 메서드 호출 은 실제로 &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref 강제&lt;/a&gt; 를 통한 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; 메서드에 대한 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">프리미티브 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; ( '슬라이스'라고도 함)에 대한 설명서를 참고하십시오 . &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 많은 메소드 호출 은 실제로 &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt; 를 통해 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; 의&lt;/a&gt; 메소드에 대한 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">구현 자 참고 사항</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">구현에주의 :이 복귀하면 &lt;code&gt;Ok(ptr)&lt;/code&gt; , 다음 &lt;code&gt;ptr&lt;/code&gt; 고려해야 &quot;현재 할당 된&quot;과 같은 방식으로 허용 가능한 입력이어야 &lt;code&gt;realloc&lt;/code&gt; 또는 &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;하더라도 &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 는 제로 - 크기의 유형이다. 즉, &lt;code&gt;Alloc&lt;/code&gt; 구현이 크기가 0 인 &lt;code&gt;ptr&lt;/code&gt; 을 리턴 할 수있는 방식으로이 메소드를 대체하는 경우 입력과 같은 값을 승인하기 위해 모든 재 할당 및 할당 해제 메소드를 유사하게 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기에 두 가지 세부 사항이 있습니다. 먼저 인덱스 값 &lt;code&gt;2&lt;/code&gt; 를 사용하여 세 번째 요소를 가져옵니다. 벡터는 0부터 시작하여 숫자로 인덱스됩니다. 둘째, 세 번째 요소를 얻는 두 가지 방법은 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 참조를 제공하거나 인덱스로 인수로 전달 된 &lt;code&gt;get&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 를 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">참고로, &lt;code&gt;OsString&lt;/code&gt; 및 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 은&lt;/a&gt; 내부적으로 플랫폼에 고유 한 형식으로 문자열을 보유 할 필요는 없습니다. Unix에서는 문자열이 8 비트 값의 시퀀스로 저장되는 반면, Windows에서는 방금 설명한대로 문자열이 16 비트 값을 기반으로하며, 문자열은 실제로 8 비트 값의 시퀀스로 저장되며 더 적은 값으로 인코딩됩니다. UTF-8의 엄격한 변형. 이는 용량 및 길이 값을 처리 할 때 이해하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">참고 &lt;code&gt;OsString&lt;/code&gt; 및 &lt;code&gt;OsStr&lt;/code&gt; 는 내부적으로 반드시 플랫폼 형태 출신의 문자열을 보유하지 않는다; 유닉스에서는 문자열이 8 비트 값 시퀀스로 저장되고, Windows에서는 문자열이 앞에서 설명한대로 16 비트 값으로 저장되며, 문자열은 실제로 8 비트 값 시퀀스로 저장됩니다. UTF-8의 엄격한 변형. 용량 및 길이 값을 처리 할 때 이해하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">그러나 순간이 &lt;strong&gt;안정적&lt;/strong&gt; 임을 보장하지는 않습니다 . 다시 말해, 기본 클록의 각 틱은 동일한 길이가 아닐 수있다 (예를 들어, 몇 초는 다른 것보다 길 수있다). 순간이 앞으로 뛰거나 시간이 느려질 수 있지만 (느리게하거나 속도가 빨라질 수 있지만) 결코 뒤쳐지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">그러나 이름이 같은 항목은 겹치지 않는 고유 한 &lt;code&gt;impl&lt;/code&gt; 블록에 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">그러나 이것은 안전하지 않은 특성이 아니므로이 특성이 제공하는 간결한 계약이 없습니다. 대신, 사용자에게 &lt;code&gt;catch_unwind&lt;/code&gt; 에 대해 경고하기 위해 &quot;스피드 범프&quot;를 더 많이 사용하여 깨진 불변이 목격 될 수 있으며이를 고려해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">많은 경우 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;.parse()&lt;/code&gt; 메소드 가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Pin&lt;/code&gt; 은 대상에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하여 내부 값에 액세스하는 데 사용할 수 있습니다. 그러나 &lt;code&gt;Deref&lt;/code&gt; 는 &lt;code&gt;Pin&lt;/code&gt; 자체 의 수명이 아니라 &lt;code&gt;Pin&lt;/code&gt; 을 빌리는 기간 동안 만 참조 할 수 있습니다 . 이 방법을 사용하면 &lt;code&gt;Pin&lt;/code&gt; 을 원래 &lt;code&gt;Pin&lt;/code&gt; 과 동일한 수명으로 기준으로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Pin&lt;/code&gt; 은 데이터에 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현 하여 내부 값에 액세스하는 데 사용할 수 있습니다. 그러나 &lt;code&gt;DerefMut&lt;/code&gt; 은 &lt;code&gt;Pin&lt;/code&gt; 자체 의 수명이 아니라 &lt;code&gt;Pin&lt;/code&gt; 을 빌린 기간 동안 지속되는 참조 만 제공 합니다. 이 방법을 사용하면 &lt;code&gt;Pin&lt;/code&gt; 을 원래 &lt;code&gt;Pin&lt;/code&gt; 과 동일한 수명으로 기준으로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;core&lt;/code&gt; 는 발신자 위치를 관찰하기 위해 &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt; &lt;code&gt;core::panic::Location::caller&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . 그것은 랩 &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt; &lt;code&gt;core::intrinsics::caller_location&lt;/code&gt; &lt;/a&gt; 고유에 의해 구현 &lt;code&gt;rustc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">참고 : &lt;code&gt;fold()&lt;/code&gt; 및 전체 반복자를 통과하는 유사한 메소드는 결과가 유한 시간 내에 결정될 수있는 특성에서도 무한 반복자에 대해 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">참고 : &lt;code&gt;move&lt;/code&gt; 클로저는 이동으로 변수를 캡처하더라도 여전히 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있습니다 . 클로저 유형으로 구현 된 특성은 클로저가 캡처하는 방식이 아니라 캡처 된 값으로 수행하는 특성에 따라 결정되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="translated">참고 : &lt;code&gt;move&lt;/code&gt; 클로저는 &lt;code&gt;move&lt;/code&gt; 로 변수를 캡처하더라도 여전히 &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있습니다 . 폐쇄 형에 의해 구현되는 특성에 의해 결정되기 때문입니다 &lt;em&gt;무엇을&lt;/em&gt; 폐쇄 캡처 값으로,하지 않는 &lt;em&gt;방법&lt;/em&gt; 은 그들을 캡처 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 는 현재 &quot;clippy&quot;및 &quot;rustfmt&quot;도구를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 에는 각 대상 및 CPU에 대해 사용 가능한 기본 기능 세트가 있습니다. CPU는 &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 선택할 수 있습니다 . &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 전체 상자에 대해 개별 기능을 활성화 또는 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="translated">참고 : &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; 여기에 의미가 없습니다. 이 특성 유형 매개 변수는 다른 impl을 활성화하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="translated">참고 : 비 &lt;code&gt;Copy&lt;/code&gt; 필드가있는 &lt;code&gt;union&lt;/code&gt; 는 불안정 합니다. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">참고 : Haskell 및 Rust와 같은 엄격한 컴파일러를 사용하는 언어에 대해들을 수 있다는 말은 &quot;코드가 컴파일되면 작동합니다.&quot;입니다. 그러나이 말은 보편적으로 사실이 아닙니다. 우리 프로젝트는 컴파일되지만 전혀 아무것도하지 않습니다! 우리가 실제적이고 완전한 프로젝트를 만들고 있다면, 코드가 컴파일 &lt;em&gt;되고&lt;/em&gt; 원하는 동작을 가지고 있는지 확인하기 위해 단위 테스트 작성을 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">참고 : Rust는 다른 언어와 마찬가지로 컴파일러뿐만 아니라 인터프리터로도 구현할 수 있지만 기존의 유일한 구현은 컴파일러이며 언어는 항상 컴파일되도록 설계되었습니다. 이러한 이유로이 섹션에서는 컴파일러를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">참고 : 표현이 항목의 속성이기 때문에 표현은 일반 매개 변수에 의존하지 않습니다. 이름이 같은 두 유형은 모두 같은 표현을 갖습니다. 예를 들어, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; 모두 동일한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">주 : 제어 플로우 표현식으로서 블록 표현식이 표현식 명령문의 외부 표현식 인 경우 예상되는 유형은 바로 뒤에 세미콜론이 오지 않는 한 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="translated">참고 : &lt;code&gt;repr(C)&lt;/code&gt; 구조체 및 공용체 의 표현으로 인해 변형에 단일 필드가있는 경우 해당 필드를 공용체에 직접 넣거나 구조체로 래핑하는 것 사이에는 차이가 없습니다. 따라서 이러한 &lt;code&gt;enum&lt;/code&gt; 의 표현 을 조작하려는 시스템 은 더 편리하거나 일관성있는 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">참고 : 보푸라기를 제외하고 함수 항목에 외부 속성 만 사용하는 것은 관용적입니다.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">참고 : 명확하게하기 위해 코드베이스가 Rust 1.26 이하로 컴파일하는 것을 지원하지 않는 경우 항상 형질 개체에 &lt;code&gt;dyn&lt;/code&gt; 키워드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">참고 : &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 구현 세부 사항에 대한 자세한 내용은 https://doc.rust-lang.org/stable/nomicon/vec.html의&amp;ldquo;Rustonomicon&amp;rdquo;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 구현 세부 사항에 대한 자세한 내용 은 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">참고 : 간단하게하기 위해, 우리는 &lt;em&gt;동시 및 / 또는 병렬&lt;/em&gt; 을 말함으로써 더 많은 문제를 보다 정확하지 않고 &lt;em&gt;동시 적&lt;/em&gt; 으로 언급 할 것 입니다. 이 책이 동시성 및 / 또는 병렬 처리에 관한 것이면 더 구체적입니다. 이 장에서는, 우리가 &lt;em&gt;동시&lt;/em&gt; 를 사용할 때마다 &lt;em&gt;동시 및 / 또는 병렬을&lt;/em&gt; 정신적으로 대체하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">참고 : 함수는 세 가지 &lt;code&gt;Fn&lt;/code&gt; 특성도 모두 구현할 수 있습니다. 우리가 원하는 것이 환경에서 가치를 포착 할 필요가 없다면, &lt;code&gt;Fn&lt;/code&gt; 특성 을 구현하는 무언가가 필요한 클로저 대신 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">참고 : Git은 일반적인 버전 관리 시스템입니다. &lt;code&gt;--vcs&lt;/code&gt; 플래그 를 사용하여 다른 버전 제어 시스템을 사용하거나 버전 제어 시스템을 사용하지 않도록 &lt;code&gt;cargo new&lt;/code&gt; 을 변경할 수 있습니다 . 사용 가능한 옵션을 확인하려면 &lt;code&gt;cargo new --help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">참고 : 역사적으로 장소 표현식은 &lt;em&gt;lvalues&lt;/em&gt; 이고 값 표현식은 &lt;em&gt;rvalues&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">참고 : &lt;code&gt;PeekMut&lt;/code&gt; 값이 누출되면 힙이 일치하지 않는 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">참고 : 어떤 이유로 &lt;code&gt;rustup&lt;/code&gt; 사용하지 않으려면 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;Rust 설치 페이지&lt;/a&gt; 에서 다른 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">참고 : C ++에서 항목 수명이 끝날 때 이러한 리소스 할당 해제 패턴을 &lt;em&gt;RAII (Resource Acquisition Is Initialization&lt;/em&gt; )라고도 &lt;em&gt;합니다&lt;/em&gt; . RAII 패턴을 사용한 경우 Rust 의 &lt;code&gt;drop&lt;/code&gt; 기능이 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">참고 : 일반적으로 &lt;code&gt;FusedIterator&lt;/code&gt; 반복기가 필요한 경우 제네릭 경계에서 FusedIterator 를 사용하면 안됩니다 . 대신 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse()&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다. 반복기가 이미 융합 된 경우 추가 &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; 래퍼는 성능 저하없이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">참고 : 일반적으로 융합 반복기가 필요한 경우 일반 범위에서 &lt;code&gt;FusedIterator&lt;/code&gt; 를 사용하지 않아야 합니다. 대신 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다. 반복자가 이미 융합 된 경우 추가 &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; 래퍼는 성능 저하없이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(n)&lt;/code&gt; 에서 &lt;code&gt;n&lt;/code&gt; 빼기 내부 버퍼 길이가 &lt;code&gt;i64&lt;/code&gt; 를 오버플로하는 가장자리 의 경우 하나가 아닌 두 번의 탐색이 수행됩니다. 두 번째 검색이 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환 하면 &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 을 사용 하여 &lt;code&gt;seek&lt;/code&gt; 를 호출 한 경우와 동일한 위치에 기본 판독기가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; 하여 찾고있는 가장자리의 경우 &lt;code&gt;n&lt;/code&gt; 에서 내부 버퍼 길이를 뺀 &lt;code&gt;i64&lt;/code&gt; 가 넘치면 하나 대신 두 번의 탐색이 수행됩니다. 두 번째 탐색이 &lt;code&gt;Err&lt;/code&gt; 을 반환 하면 &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; 하여 &lt;code&gt;seek&lt;/code&gt; 를 호출 한 경우와 동일한 위치에 기본 판독기가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">참고 : 반드시 사용해야하는 값을 의도적으로 버릴 경우 패턴이 &lt;code&gt;_&lt;/code&gt; 인&lt;a href=&quot;../statements#let-statements&quot;&gt;let 문&lt;/a&gt; 을 사용하는 것이 관용적 입니다.</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">참고 : 수명은 일반적으로이 속기에서 제외 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">참고 : &lt;code&gt;|&lt;/code&gt; 작업자는 패턴 가드 및 여러 번 실행해야하는 부작용이 발생할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">참고 : 문자열 슬라이스 범위 인덱스는 유효한 UTF-8 문자 경계에서 발생해야합니다. 멀티 바이트 문자 중간에 문자열 슬라이스를 만들려고하면 프로그램이 오류와 함께 종료됩니다. 문자열 슬라이스를 도입하기 위해이 섹션에서는 ASCII 만 가정합니다. UTF-8 처리에 대한 자세한 내용은 8 장의 &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&quot;문자열과 함께 UTF-8 인코딩 텍스트 저장&quot;&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">참고 : &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 표준 라이브러리 유형은 힙 할당 크기 조정 가능 배열 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">참고 : &lt;code&gt;//&lt;/code&gt; 구문은 줄 끝까지 계속되는 주석을 시작합니다. Rust는 주석의 모든 내용을 무시합니다.이 내용은 3 장에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">참고 : &lt;code&gt;2..=9&lt;/code&gt; A는 &lt;a href=&quot;../patterns#range-patterns&quot;&gt;범위 패턴&lt;/a&gt; 이 아닌 &lt;a href=&quot;range-expr&quot;&gt;범위 표현&lt;/a&gt; . 따라서, 범위 패턴에 의해 지원되는 이러한 유형의 범위 만 매치 암에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">참고 : &lt;code&gt;vec!&lt;/code&gt; 의 실제 정의 ! 표준 라이브러리의 매크로에는 올바른 양의 메모리를 미리 할당하는 코드가 포함되어 있습니다. 이 코드는 예제를 단순화하기 위해 여기에 포함되지 않은 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="translated">참고 : &lt;code&gt;track_caller&lt;/code&gt; 가 함수 ABI에 암시 적 매개 변수를 추가하여 codegen 컨텍스트에서 &lt;code&gt;rustc&lt;/code&gt; 구현 하기 때문에 앞서 언급 한 함수 포인터에 대한 shim이 필요 하지만 매개 변수가 함수 유형의 일부가 아니므로 간접 호출에는 적합하지 않습니다. 주어진 함수 포인터 유형은 속성을 가진 함수를 참조하거나 참조하지 않을 수 있습니다. shim을 만들면 함수 포인터 호출자로부터 암시 적 매개 변수가 숨겨져 서 건전성이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 1048576입니다.</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 128입니다.</target>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 64입니다.</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">참고 : 반복자가 끝까지 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">참고 : C의 열거 형 표현은 구현 정의이므로 실제로는 &quot;최선의 추측&quot;입니다. 특히, 관심있는 C 코드가 특정 플래그로 컴파일 될 때 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">참고 : 위의 예제는 컴파일러에서 잘못 받아 들여졌지만 이후 수정되었습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;문제 # 33685&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">참고 : Listing 10-17, 10-18 및 10-24의 예제는 변수에 초기 값을 제공하지 않고 변수를 선언하므로 변수 이름이 외부 범위에 존재합니다. 언뜻보기에 이것은 Rust의 null 값이없는 것과 충돌하는 것처럼 보일 수 있습니다. 그러나 변수에 값을주기 전에 변수를 사용하려고하면 컴파일 타임 오류가 발생하는데, 이는 Rust가 실제로 널값을 허용하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">참고 : 반환 유형이 허용되는 구현은 불안정한 &lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">참고 : 반환 유형이 허용되는 구현은 불안정한 &lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 가 지원하는 보푸라기 검사 는 기본 설정과 함께 &lt;code&gt;rustc -W help&lt;/code&gt; 통해 찾을 수 있으며 &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc 서적에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">참고 : 다음 섹션에서는 &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&quot;새 유형 패턴을 사용하여 외부 유형에 외부 특성 구현&quot;&lt;/a&gt; 섹션을 읽었다 고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">참고 : &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하여 참조하는 것과 반대 인 참조 는 &lt;em&gt;역&lt;/em&gt; 참조 연산자 &lt;code&gt;*&lt;/code&gt; 로 수행 됩니다. 8 장에서 역 참조 연산자를 사용하고 15 장에서 역 참조에 대한 세부 사항을 논의 할 것이다.</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">참고 : 명령문 뒤의 세미콜론은 명령문 자체의 일부가 아닙니다. &lt;code&gt;stmt&lt;/code&gt; 매크로 매처를 사용할 때 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">참고 : 테스트 모드는 &lt;code&gt;--test&lt;/code&gt; 인수를 &lt;code&gt;rustc&lt;/code&gt; 에 전달 하거나 &lt;code&gt;cargo test&lt;/code&gt; 사용하여 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="translated">참고 :이 알고리즘은 크기가 0 인 구조체를 생성 할 수 있습니다. C에서 &lt;code&gt;struct Foo { }&lt;/code&gt; 와 같은 빈 구조체 선언 은 불법입니다. 그러나 gcc 및 clang 모두 이러한 구조체를 활성화하고 크기를 0으로 할당하는 옵션을 지원합니다. 반대로 C ++는 빈 구조체에 1의 크기를 제공합니다. 단, 상속되지 않거나 &lt;code&gt;[[no_unique_address]]&lt;/code&gt; 속성 이있는 필드 인 경우에는 구조체의 전체 크기가 증가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">참고 :이 알고리즘은 크기가 0 인 구조체를 생성 할 수 있습니다. 이것은 데이터가없는 구조체의 크기가 여전히 1 바이트 인 C와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">참고 :이 책은 명령 행에 대한 기본 지식이 있다고 가정합니다. Rust는 편집 또는 툴링 또는 코드의 위치에 대해 특별한 요구를하지 않으므로 명령 줄 대신 IDE (Integrated Development Environment)를 사용하려면 원하는 IDE를 자유롭게 사용하십시오. 많은 IDE가 이제 어느 정도의 Rust를 지원합니다. 자세한 내용은 IDE 설명서를 확인하십시오. 최근 Rust 팀은 훌륭한 IDE 지원에 초점을 맞추고 있으며 그 진전이 빠르게 진행되고 있습니다!</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">참고 :이 책은 &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press의&lt;/a&gt; 인쇄 및 전자 책 형식으로 제공 &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;되는 녹 프로그래밍 언어&lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">참고 :이 예는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 의 내부를 보여줍니다 . 정상적인 상황에서는 &lt;code&gt;unsafe&lt;/code&gt; 문자열 슬라이스를 사용해서는 안됩니다. 대신 &lt;code&gt;as_slice&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="translated">참고 :이 예는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 의 내부를 보여줍니다 . &lt;code&gt;unsafe&lt;/code&gt; 는 정상적인 상황에서 문자열 조각을 얻는 데 사용해서는 안됩니다. 대신 &lt;code&gt;as_str&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">참고 : 이것은 슬라이스에 대한 포인터 ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; 등)가 아니라 원시 &lt;code&gt;[T]&lt;/code&gt; 유형 에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">참고 : 이것은 특성 오브젝트에 대한 포인터 ( &lt;code&gt;&amp;amp;Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 등)가 아닌 원시 특성 오브젝트 유형에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">참고 : 이것은 트레이 트 객체에 대한 포인터 ( &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 등)가 아닌 원시 트레이 트 객체 유형에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">참고 :이를 &quot;인수 위치의 impl Trait&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">참고 :이를 &quot;복귀 위치의 impl Trait&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">참고 :이 매크로는 &lt;code&gt;no_std&lt;/code&gt; 설정 에서도 사용할 수 있습니다 . A의 &lt;code&gt;no_std&lt;/code&gt; 설치하면 구성 요소의 구현 세부 사항에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">참고 : 함수가 &lt;code&gt;Some(_)&lt;/code&gt; 반환하는 한 값이 다른 스레드에서 변경된 경우 함수가 여러 번 호출 될 수 있지만 함수는 저장된 값에 한 번만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="translated">참고 : 함수가 &lt;code&gt;Some(_)&lt;/code&gt; 반환하는 한 그 동안 다른 스레드에서 값이 변경된 경우 함수를 여러 번 호출 할 수 있지만 함수는 저장된 값에 한 번만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="translated">참고 : 태그에 유니온에서 자체 멤버가 주어지면 조작이 더 명확 해지면이 표현은 변경되지 않습니다 (C ++ 표준을 따르더라도 태그 멤버는 &lt;code&gt;struct&lt;/code&gt; 로 래핑되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">참고 :이 섹션은보다 포괄적 인 참조 자료의 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">참고 :이 섹션은 언어보다는 컴파일러 측면에서 더 많이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">참고 : 이것에 의존해서는 안되지만 모든 포인터는</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">참고 : 특성은 약간의 차이가 있지만 다른 언어로 &lt;em&gt;인터페이스&lt;/em&gt; 라고하는 기능과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">참고 : 값을 포함하는 간단한 no-op 식은 보푸라기를 위반하지 않습니다. 예를 들어 &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않은 유형으로 값을 랩핑 한 다음 해당 유형을 사용하지 않고 사용되지 않는 &lt;a href=&quot;../expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 의 최종 표현식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">참고 : 복합 유형이 더 적합 할 때 기본 값을 사용하는 것은 &lt;em&gt;기본 강박&lt;/em&gt; 이라고 알려진 안티 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">참고 : 이 예제에서는 &lt;code&gt;i32&lt;/code&gt; 값만 보유하는 단점 목록을 구현하고 있습니다 . 우리는 10 장에서 논의한 것처럼 어떤 타입의 값을 저장할 수있는 cons list 타입을 정의하기 위해 generics를 사용하여 그것을 구현할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">참고 : 크기가 조정되지 않은 강제 변환의 정의와 구현이 안정화되었지만 특성 자체는 아직 안정적이지 않으므로 안정된 Rust에서 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">참고 : Windows 이식성 고려 사항</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">참고 : 상자에서 사용할 특성과 호출 할 메소드와 함수 만 알 수 없습니다. 상자 사용 지침은 각 상자의 설명서에 있습니다. Cargo의 또 다른 멋진 기능은 &lt;code&gt;cargo doc --open&lt;/code&gt; 명령을 실행하여 모든 종속 항목이 로컬로 제공 한 문서를 작성하여 브라우저에서 열 수 있다는 것입니다. &lt;code&gt;rand&lt;/code&gt; 상자의 다른 기능에 관심이있는 경우 , &lt;code&gt;cargo doc --open&lt;/code&gt; 실행 하고 왼쪽의 사이드 바에서 &lt;code&gt;rand&lt;/code&gt; 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="translated">참고 : 내장 함수의 일관성에 대한 모든 변경 사항은 언어 팀과 논의해야합니다. 여기에는 constness의 안정성 변경이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="translated">참고 : 결과 &lt;code&gt;Location&lt;/code&gt; 가 힌트 이기 때문에 구현시 스택을 조기에 중단 할 수 있습니다. 중요한주의 사항 은 &lt;a href=&quot;#limitations&quot;&gt;제한 사항&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">참고 : 여러 브라우저 창에서 동시에 &lt;em&gt;/ sleep&lt;/em&gt; 을 열면 5 초 간격으로 한 번에 하나씩로드 될 수 있습니다. 일부 웹 브라우저는 캐싱을 위해 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이 제한은 웹 서버에 의한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="translated">참고 : 향후 Rust 버전에서는 배열 리터럴 구문이 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;반복되는 const 표현식을&lt;/a&gt; 허용 할 때이 방법이 불필요해질 수 있습니다 . 아래 예제에서는 &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">참고 : 문자열을 시작하는 확장 된 grapheme 코드 포인트 만 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">참고 : 각 유형에 대해 조회가 순서대로 수행되므로 때때로 놀라운 결과가 발생할 수 있습니다. 아래 코드는 &quot;특성 impl!&quot;을 인쇄합니다. 왜냐하면 &lt;code&gt;&amp;amp;self&lt;/code&gt; 메소드가 먼저 조회 되기 때문에 , trait 메소드는 struct의 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 메소드가 발견 되기 전에 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">참고 :이 방법으로 반환 된 값은 범위가 모두 소진 된 후에 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">참고 : 빌드 하려는 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 유형과 실제 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사이에는 큰 차이 가 있습니다.이 버전에서는 데이터가 힙에 저장되지 않습니다. 이 예제는 &lt;code&gt;Deref&lt;/code&gt; 에 초점을 맞추고 있으므로 데이터가 실제로 저장되는 위치는 포인터와 유사한 동작보다 덜 중요합니다.</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="translated">참고 :이 오류 코드는 더 이상 컴파일러에서 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">참고 :이 오류 코드는 더 이상 컴파일러에서 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 :이 연관된 당신이로 호출해야 함을 의미 기능입니다 &lt;code&gt;Box::into_raw(b)&lt;/code&gt; 대신 &lt;code&gt;b.into_raw()&lt;/code&gt; . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 :이 연관된 당신이로 호출해야 함을 의미 기능입니다 &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; 대신 &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 : 이것은 관련 함수이므로 &lt;code&gt;b.leak()&lt;/code&gt; 대신 &lt;code&gt;Box::leak(b)&lt;/code&gt; 로 호출해야합니다 . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 :이 유형은 불안정하지만 &lt;a href=&quot;index#functions&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; 의 무료 기능을 통해 제공되는 기능에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">부작용에 대한 메모</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">참고 및 안전</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">책의 상태에 대한 유용한 정보를 포함하거나 유용하지만 대부분 범위를 벗어난 정보는 &lt;strong&gt;굵은 글씨로&lt;/strong&gt; &quot;Note :&quot;로 시작하는 인용 부호로 &lt;strong&gt;표시&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Rust의 어떤 것도 특성이 다른 특성의 방법과 동일한 이름을 가진 메소드를 갖는 것을 막지 않으며 Rust가 한 유형에 두 특성을 구현하는 것을 방해하지도 않습니다. 특성의 메소드와 동일한 이름을 가진 유형에 메소드를 직접 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">Listing 16-1에서 우리가 &lt;code&gt;thread::spawn&lt;/code&gt; 전달하는 클로저는 인수를 취하지 않는다는 것을 주목 하라. 스폰 된 스레드 코드에서 메인 스레드의 데이터를 사용하지 않는다. 생성 된 스레드에서 기본 스레드의 데이터를 사용하려면 생성 된 스레드의 클로저가 필요한 값을 캡처해야합니다. Listing 16-3은 메인 스레드에서 벡터를 생성하여 생성 된 스레드에서 사용하려는 시도를 보여줍니다. 그러나 잠시 후에 알 수 있듯이 아직 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">이 특정 실행의 흥미로운 측면 중 하나는 &lt;code&gt;ThreadPool&lt;/code&gt; 이 채널로 종료 메시지를 보냈고 작업자가 메시지를 받기 전에 작업자 0에 가입하려고 시도한 것입니다. 작업자 0은 아직 종료 메시지를받지 않았으므로 주 스레드는 대기를 차단했습니다. 작업자 0이 완료됩니다. 그 동안 각 작업자는 종료 메시지를 받았습니다. 작업자 0이 완료되면 주 스레드는 나머지 작업자가 완료 될 때까지 기다렸습니다. 이 시점에서 그들은 모두 종료 메시지를 받고 종료 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;From&lt;/code&gt; 에 대한 예를 &lt;code&gt;&amp;amp;T&lt;/code&gt; . 그러나 이것은 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 내부에서 돌연변이가 발생하지 않는 한 공유 참조 (a에서 파생 된 포인터)를 통한 돌연변이가 정의되지 않은 동작이라는 사실을 변경하지는 않습니다 . 공유 참조에서 변경 가능한 참조를 작성하는 것도 마찬가지입니다. 이를 사용하는 경우 &lt;code&gt;From&lt;/code&gt; 없이 예를 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; , 그 확인하는 것은 귀하의 책임입니다 &lt;code&gt;as_mut&lt;/code&gt; 가 호출되지 및 &lt;code&gt;as_ptr&lt;/code&gt; 는 돌연변이에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">것을 알 수 &lt;code&gt;x&lt;/code&gt; 에 의해 스택 할당 &lt;code&gt;foo()&lt;/code&gt; . 기본적으로 Rust는 참조로 닫힌 데이터를 캡처합니다. 즉, &lt;code&gt;foo()&lt;/code&gt; 반환되면 &lt;code&gt;x&lt;/code&gt; 는 더 이상 존재하지 않습니다. 따라서 클로저 내에서 &lt;code&gt;x&lt;/code&gt; 에 액세스하려는 시도 는 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">차단이 해제되었다고해서이 스레드를 해제 한 다른 사람과의 동기화를 의미하지는 않으며 가짜 일 수도 있습니다. 예를 들어, 아무 일도하지 않고 바로 &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;파크 를 즉시 반환하는 것은 유효하지만 비효율적 인 구현 입니다.</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">&lt;code&gt;compare_and_swap&lt;/code&gt; 의 경우 작업이 어떤 저장도 수행하지 않고 결국 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; ordering 만 수행 할 수 있습니다 . 그러나 &lt;code&gt;AcqRel&lt;/code&gt; 은 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 액세스를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">&lt;code&gt;compare_and_swap&lt;/code&gt; 의 경우 , 조작이 상점을 수행하지 않고 결과적으로 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 주문 만있을 수 있습니다 . 그러나 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 액세스를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">메시지와 함께 당황한 코드는 &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; 입니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 가 런타임에 차용 규칙 위반을 처리 하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">압축 된 구조체를 제거 할 때 컴파일러는이 복사본을 자동으로 수행합니다. 즉, &lt;code&gt;drop_in_place&lt;/code&gt; 를 수동으로 호출하지 않으면 일반적으로 이러한 문제에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">벡터의 첫 번째 값은 &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; 이며 이진의 이름입니다. 이는 C에서 인수 목록의 동작과 일치하여 프로그램이 실행시 호출 된 이름을 사용할 수 있도록합니다. 메시지를 인쇄하거나 프로그램을 호출하는 데 사용 된 명령 행 별명에 따라 프로그램의 동작을 변경하려는 경우 프로그램 이름에 액세스하는 것이 편리합니다. 그러나이 장의 목적 상이를 무시하고 필요한 두 가지 주장 만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">상자에서 상호 작용하는 유일한 유형은 &lt;code&gt;Post&lt;/code&gt; 유형입니다. 이 유형은 상태 패턴을 사용하며 게시물이 초안, 검토 대기 또는 게시 될 수있는 다양한 상태를 나타내는 세 가지 상태 객체 중 하나 인 값을 보유합니다. 한 상태에서 다른 상태로 변경하면 &lt;code&gt;Post&lt;/code&gt; 유형 내에서 내부적으로 관리됩니다 . &lt;code&gt;Post&lt;/code&gt; 인스턴스 에서 라이브러리 사용자가 호출 한 메소드에 따라 상태가 변경 되지만 상태 변경을 직접 관리 할 필요는 없습니다. 또한 사용자는 검토하기 전에 게시물을 게시하는 것과 같이 상태에 대해 실수를 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">작업 공간에는 각 상자의 디렉토리에 &lt;em&gt;Cargo.lock&lt;/em&gt; 이없는 작업 공간의 최상위 레벨에 하나의 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 만 있습니다. 이렇게하면 모든 상자가 동일한 버전의 모든 종속성을 사용하게됩니다. 우리는 추가하면 &lt;code&gt;rand&lt;/code&gt; 받는 사람 상자를 &lt;em&gt;가산기 / Cargo.toml&lt;/em&gt; 및&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt; 추가 한 / Cargo.toml의&lt;/em&gt; 파일을,화물은 한 버전으로 그 모두를 해결할 &lt;code&gt;rand&lt;/code&gt; 하나에 그 기록 &lt;em&gt;Cargo.lock&lt;/em&gt; . 작업 공간의 모든 상자가 동일한 종속성을 사용하게하면 작업 공간의 상자가 항상 서로 호환됩니다. &lt;code&gt;rand&lt;/code&gt; 상자를 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션에 추가해 보겠습니다 .&lt;em&gt; 추가 한 / Cargo.toml를&lt;/em&gt; 파일을 사용할 수 있도록 &lt;code&gt;rand&lt;/code&gt; 에 상자를 &lt;code&gt;add-one&lt;/code&gt; 상자 :</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">작업 공간에는 각 상자의 디렉토리에 &lt;em&gt;Cargo.lock&lt;/em&gt; 이있는 것이 아니라 작업 공간의 최상위 수준에 하나의 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 만 있습니다. 이렇게하면 모든 상자가 모든 종속성의 동일한 버전을 사용하게됩니다. 우리는 추가하면 &lt;code&gt;rand&lt;/code&gt; 받는 패키지를 &lt;em&gt;가산기 / Cargo.toml&lt;/em&gt; 및 &lt;em&gt;추가 한 / Cargo.toml의&lt;/em&gt; 파일을,화물은 한 버전으로 그 모두를 해결할 &lt;code&gt;rand&lt;/code&gt; 사람의 것을 기록 &lt;em&gt;Cargo.lock&lt;/em&gt; . 작업 공간의 모든 상자가 동일한 종속성을 사용하도록한다는 것은 작업 공간의 상자가 항상 서로 호환된다는 것을 의미합니다. &lt;code&gt;rand&lt;/code&gt; 상자를 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션에 추가하겠습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;add-one / Cargo.toml&lt;/em&gt; 파일을 &lt;code&gt;add-one&lt;/code&gt; 하여 추가 상자에서 &lt;code&gt;rand&lt;/code&gt; 상자 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">이 보장은 메모리가 누출 되지 &lt;em&gt;않는다는&lt;/em&gt; 것을 의미하지 않습니다! 고정 된 요소에서 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 을 호출하지 않는 것은 여전히 ​​완전히 괜찮습니다 (예 : &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 에서 &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다 ). 이중 연결 목록의 예에서 해당 요소는 목록에 남아 있습니다. 그러나 &lt;em&gt;&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 을 호출하지 않고&lt;/em&gt; 는 저장 공간 &lt;em&gt;을 확보&lt;/em&gt; 하거나 재사용 할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">이 보증 않음을주의 &lt;em&gt;하지&lt;/em&gt; 메모리가 누출되지 않는 것을 의미! 고정 된 요소에서 &lt;code&gt;drop&lt;/code&gt; 을 호출하지 않는 것은 여전히 ​​괜찮습니다 (예 : 여전히 &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; 호출 가능 A의 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ). 이중 연결 목록의 예에서 해당 요소는 목록에 그대로 있습니다. 그러나 &lt;em&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 을 호출하지 않고&lt;/em&gt; 스토리지 &lt;em&gt;를&lt;/em&gt; 해제하거나 재사용 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">이번에는 Cargo가 &lt;code&gt;hello_cargo&lt;/code&gt; 를 컴파일하고 있음을 나타내는 출력이 표시되지 않았습니다 . 화물은 파일이 변경되지 않았 음을 알았으므로 바이너리를 실행했습니다. 소스 코드를 수정 한 경우, Cargo는 프로젝트를 실행하기 전에 프로젝트를 다시 빌드했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 로드 작업 이 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 됩니다!</target>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 저장 작업이 수행됩니다!</target>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 로드 조작으로.</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; store 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">이 코드 에는 &lt;code&gt;unsafe&lt;/code&gt; 키워드가 포함되어 있지 않습니다 . 안전한 코드로 원시 포인터를 만들 수 있습니다. 우리는 안전하지 않은 블록 외부에서 원시 포인터를 역 참조 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">공지 사항 우리가 명시 적으로 수명 필요 &lt;code&gt;'a&lt;/code&gt; 의 서명에 정의 된 &lt;code&gt;search&lt;/code&gt; 및 사용 &lt;code&gt;contents&lt;/code&gt; 인수와 반환 값을. 불러올 &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;10 장&lt;/a&gt; 수명 파라미터는 반환 값의 수명에 접속되는 인수 수명 지정한. 이 경우 반환 된 벡터에는 인수 &lt;code&gt;contents&lt;/code&gt; 의 슬라이스를 참조하는 문자열 슬라이스가 포함되어야 함을 나타냅니다. 인수 &lt;code&gt;query&lt;/code&gt; 가 아닌 .</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">코드를 &lt;code&gt;TokenStream&lt;/code&gt; 파싱을 담당 하는 &lt;code&gt;impl_hello_macro&lt;/code&gt; 함수와 구문 트리 변환을 담당 하는 &lt;code&gt;hello_macro_derive&lt;/code&gt; 함수 로 코드를 분할했습니다 . 이렇게하면 절차 적 매크로 작성이 더 편리해집니다. 외부 함수의 코드 ( &lt;code&gt;hello_macro_derive&lt;/code&gt; 이 경우 )는 보거나 생성하는 거의 모든 절차 적 매크로 상자에 대해 동일합니다. 내부 함수의 본문에 지정하는 코드 ( 이 경우 &lt;code&gt;impl_hello_macro&lt;/code&gt; )는 절차 매크로의 목적에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; 시작하는 마지막 줄 뒤에는 코드가 없습니다 ! . &lt;code&gt;//!&lt;/code&gt; 주석을 시작했기 때문에 ! &lt;code&gt;///&lt;/code&gt; 대신 이 주석 다음에 나오는 항목이 아니라이 주석이 포함 된 항목을 문서화합니다. 이 경우이 주석이 포함 된 항목 은 크레이트 루트 인 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일입니다. 이 의견은 전체 상자를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">이 정의는 이 특성과 &lt;em&gt;연관된 유형&lt;/em&gt; 을 정의하는 새로운 &lt;code&gt;type Item&lt;/code&gt; : type Item 및 &lt;code&gt;Self::Item&lt;/code&gt; 구문을 사용합니다 . 우리는 19 장에서 연관된 타입들에 대해 깊이 이야기 할 것입니다. 지금, 당신이 알아야 할 것은이 코드는 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하기 위해서는 &lt;code&gt;Item&lt;/code&gt; 타입 도 정의해야 하며이 &lt;code&gt;Item&lt;/code&gt; 타입은 반환 타입에 사용 된다는 것 입니다. &lt;code&gt;next&lt;/code&gt; 방법. 즉, &lt;code&gt;Item&lt;/code&gt; 유형은 반복자에서 리턴 된 유형입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">이제 모든 인스턴스 &lt;code&gt;Point&lt;/code&gt; 표시된 Point의 가 허용됩니다! 정의에 원하는만큼 많은 제네릭 형식 매개 변수를 사용할 수 있지만 몇 개 이상을 사용하면 코드를 읽기가 어렵습니다. 코드에 많은 제네릭 형식이 필요한 경우 코드를 더 작은 조각으로 재구성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">이제이 함수 시그니처의 모든 참조에는 수명이 있으며 컴파일러는 프로그래머가이 함수 시그니처의 수명에 주석을 달지 않고도 분석을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">이제 &lt;code&gt;bool&lt;/code&gt; 의 예 을 정수 유형으로 캐스트 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">이제 우리는 &lt;code&gt;rev&lt;/code&gt; 호출을 추가하는이 비틀기를 고려하십시오 . 이 버전은 &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; 합니다. 문자는 반대로되어 있지만 카운터 값은 여전히 ​​순서대로 유지됩니다. &lt;code&gt;map()&lt;/code&gt; 때문입니다 이 여전히 각 항목에서 게으르게 호출 벡터를 앞에서 뒤로 이동하는 대신 벡터 뒷면에서 항목을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;em&gt;src / main.rs&lt;/em&gt; 에 Listing 20-1의 코드를 입력하여 시작 &lt;em&gt;하자&lt;/em&gt; . 이 코드는 들어오는 TCP 스트림에 대해 주소 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 을 수신합니다. 들어오는 스트림을 받으면 &lt;code&gt;Connection established!&lt;/code&gt; 을 인쇄 합니다!.</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">이제 프로그램의 모든 것이 예상대로 작동합니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">이제 함수 또는 예제를 변경하면 &lt;code&gt;assert_eq!&lt;/code&gt; 예에서 패닉과 런 &lt;code&gt;cargo test&lt;/code&gt; 다시 하면 doc 테스트에서 예제와 코드가 서로 맞지 않는다는 것을 알 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Foo&lt;/code&gt; 의 인스턴스를 하나 이상 만들 수 있습니다 : &lt;code&gt;Foo { x: None }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">이제 Listing 20-7의 코드를 &lt;code&gt;else&lt;/code&gt; 블록 에 추가하여 상태 코드가 404 인 응답을 반환하면 요청의 컨텐츠를 찾을 수 없음을 알 수있다. 또한 최종 사용자에 대한 응답을 나타내는 페이지를 브라우저에서 렌더링 할 HTML을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">이제이 &quot;Hello, world!&quot;를 컴파일합시다. &lt;code&gt;cargo run&lt;/code&gt; 명령을 사용하여 동일한 단계에서 프로그램을 실행하고 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">이제 Listing 6-5에서 &lt;code&gt;plus_one&lt;/code&gt; 의 두 번째 호출을 고려하자 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 이다. 우리는 &lt;code&gt;match&lt;/code&gt; 입력 첫 번째 팔과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">이제 &lt;code&gt;longest&lt;/code&gt; 함수 의 맥락에서 평생 주석을 살펴 보겠습니다 . 제네릭 형식 매개 변수와 마찬가지로 함수 이름과 매개 변수 목록 사이의 꺾쇠 괄호 안에 일반 수명 매개 변수를 선언해야합니다. 이 서명으로 표현하려는 제약 조건은 매개 변수의 모든 참조와 반환 값의 수명이 같아야한다는 것입니다. 우리는 수명 &lt;code&gt;'a&lt;/code&gt; 이름을 'a'로 지정한 다음 목록 10-22에 표시된 것처럼 각 참조에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">이제 컴파일러에 의지하여 변경해야 할 다른 장소를 찾으십시오. 이 코드를 확인하면 두 가지 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">이제 &lt;code&gt;String&lt;/code&gt; 버전을 보자 :</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">이제이 암과 관련된 코드의 본문에 패턴에하자보기 : &lt;code&gt;temp_vec.push()&lt;/code&gt; 내에서 &lt;code&gt;$()*&lt;/code&gt; 일치하는 각 부분에 대해 생성됩니다 &lt;code&gt;$()&lt;/code&gt; 횟수에 따라 패턴에서 0 번 이상을 패턴 일치. &lt;code&gt;$x&lt;/code&gt; 유사한 각각의 식으로 대체된다. 우리가 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 로이 매크로를 호출 할 때 ! [1, 2, 3]; 이 매크로 호출을 대체하는 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">이제 &quot;Hello, world!&quot;를 빌드하고 실행할 때 무엇이 ​​다른지 살펴 보겠습니다. Cargo로 프로그램! 당신의에서 &lt;em&gt;hello_cargo의&lt;/em&gt; 디렉토리, 다음 명령을 입력하여 프로젝트를 빌드 :</target>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">이제 Hello, world를 빌드하고 실행할 때의 차이점을 살펴 보겠습니다. 화물 프로그램! 당신의&lt;em&gt; hello_cargo에서&lt;/em&gt; 디렉토리, 다음 명령을 입력하여 프로젝트를 빌드 :</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">이제 테스트를 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">이제 &lt;em&gt;src / main.rs를&lt;/em&gt; 엽니 다&lt;em&gt;&lt;/em&gt; 살펴보십시오 :</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">이제 &lt;em&gt;main.rs를&lt;/em&gt; 엽니 다&lt;em&gt;&lt;/em&gt; 방금 만든 파일을 목록 1-1에 코드를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">이제 코드는 &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;filename&lt;/code&gt; 이 관련되어 있으며 프로그램의 작동 방식을 구성하는 것임을 더 명확하게 전달합니다 . 이 값을 사용하는 모든 코드는 &lt;code&gt;config&lt;/code&gt; 에서 값을 찾는 것을 알고 있습니다. 인스턴스에서 목적으로 이름 지정된 필드의 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">이제 최상위 레벨 &lt;em&gt;추가&lt;/em&gt; 에서 &lt;code&gt;cargo test&lt;/code&gt; 를 실행 &lt;em&gt;하십시오.&lt;/em&gt; 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">이제 것을 &lt;code&gt;search&lt;/code&gt; 기능이 작동 및 테스트, 우리는 호출 할 필요가 &lt;code&gt;search&lt;/code&gt; 우리의 &lt;code&gt;run&lt;/code&gt; 기능을. &lt;code&gt;config.query&lt;/code&gt; 값과 &lt;code&gt;run&lt;/code&gt; 된 &lt;code&gt;contents&lt;/code&gt; 을 파일에서 &lt;code&gt;search&lt;/code&gt; 기능 으로 전달해야 합니다. 그런 다음 &lt;code&gt;run&lt;/code&gt; 은 &lt;code&gt;search&lt;/code&gt; 에서 반환 된 각 줄을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">클로저에는 자체 데이터 사본이 있으므로 안전에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">이제 우리는 작업 공간에서 라이브러리 상자를 가지고, 우리는 진 상자 가질 수 &lt;code&gt;adder&lt;/code&gt; 라이브러리 나무 상자에 따라 &lt;code&gt;add-one&lt;/code&gt; . 먼저 &lt;code&gt;add-one&lt;/code&gt; 에 &lt;em&gt;adder / Cargo.toml&lt;/em&gt; 에 경로 의존성을 추가 해야합니다.&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">이제 풀에 저장할 수있는 스레드 수가 유효한지 알 수 있으므로 해당 스레드를 작성하여 반환하기 전에 &lt;code&gt;ThreadPool&lt;/code&gt; 구조체 에 저장할 수 있습니다. 그러나 어떻게 스레드를 &quot;저장&quot;합니까? &lt;code&gt;thread::spawn&lt;/code&gt; 을 다시 살펴 보겠습니다. signature를 :</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">이제 외부 의존성 이 &lt;a href=&quot;https://crates.io/&quot;&gt;생겼으므로 Cargo&lt;/a&gt; 는 Crates.io 의 데이터 복사 본인 &lt;em&gt;레지스트리&lt;/em&gt; 에서 최신 버전을 가져옵니다. . Crates.io는 Rust 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 Rust 프로젝트를 게시하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">이제 작업 공간에 다른 패키지가 있으므로 바이너리 가있는 &lt;code&gt;adder&lt;/code&gt; 패키지가 라이브러리가 있는 &lt;code&gt;add-one&lt;/code&gt; 패키지 에 종속되도록 할 수 있습니다 . 첫째, 우리는에 경로 의존성을 추가해야합니다 &lt;code&gt;add-one&lt;/code&gt; 에 &lt;em&gt;/ 가산기 Cargo.toml을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">이제 주석이 달린 Rust 코드를 &lt;code&gt;TokenStream&lt;/code&gt; 에서 &lt;code&gt;DeriveInput&lt;/code&gt; 인스턴스 로 변환하는 코드를 작성 &lt;code&gt;HelloMacro&lt;/code&gt; 에 표시된대로 주석이있는 유형 에서 HelloMacro 특성 을 구현하는 코드를 생성하자 .</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">이제 컨텍스트가 완성되었으므로 알고리즘을 살펴 보겠습니다. Listing 13-3의 &lt;code&gt;generate_workout&lt;/code&gt; 함수 에는이 예제에서 가장 관심있는 앱의 비즈니스 로직이 포함되어있다. 이 예제에서 코드의 나머지 부분은이 기능에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">이제 사용자 입력과 임의의 숫자가 있으므로 비교할 수 있습니다. 이 단계는 목록 2-4에 표시되어 있습니다. 이 코드는 아직 설명하지 않듯이 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">브라우저가 요구하는 것을 알고 있으므로 데이터를 다시 보내 봅시다!</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">&lt;code&gt;Summary&lt;/code&gt; 특성을 사용하여 원하는 동작을 정의 했으므로 미디어 집 계기의 유형에이를 구현할 수 있습니다. 10-13 쇼의 구현 목록 &lt;code&gt;Summary&lt;/code&gt; 상의 특성 &lt;code&gt;NewsArticle&lt;/code&gt; 의 제목, 저자, 그리고 반환 값을 만들 수있는 위치에 사용하는 구조체 &lt;code&gt;summarize&lt;/code&gt; . 를 들어 &lt;code&gt;Tweet&lt;/code&gt; 구조체, 우리는 정의 &lt;code&gt;summarize&lt;/code&gt; 사용자 이름이 그 트윗 내용이 이미 280 자로 제한됩니다 가정, 트윗의 전체 텍스트 뒤에있다.</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Rust에서 스레드를 정의 했으므로 표준 라이브러리에서 제공하는 스레드 관련 API를 사용하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">벡터를 사용하는 가장 일반적인 방법에 대해 논의 했으므로 이제 표준 라이브러리 에서 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정의 된 모든 유용한 메서드에 대한 &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;API 설명서&lt;/a&gt; 를 검토 하십시오 . 예를 들어,뿐만 아니라 &lt;code&gt;push&lt;/code&gt; 하는 &lt;code&gt;pop&lt;/code&gt; 방법 제거하고 반환 마지막 요소. 다음 컬렉션 유형 인 &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">벡터를 사용하는 가장 일반적인 방법 중 일부를 살펴 보았 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 표준 라이브러리에 의해 Vec &amp;lt;T&amp;gt; 에 정의 된 많은 유용한 방법에 대한 API 설명서를 검토하십시오 . 예를 들어,뿐만 아니라 &lt;code&gt;push&lt;/code&gt; 하는 &lt;code&gt;pop&lt;/code&gt; 방법 제거하고 반환 마지막 요소. 다음 컬렉션 타입으로 넘어 갑시다 : &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">이제 &lt;code&gt;panic!&lt;/code&gt; 전화의 세부 사항에 대해 논의했습니다 ! 또는 &lt;code&gt;Result&lt;/code&gt; 반환하는 경우 어떤 경우에 사용하기에 적합한지를 결정하는 방법의 주제로 돌아가 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">우리가 검토 한 이제 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 스마트 포인터의 특성 중 일부를 표준 라이브러리에 정의 된 몇 가지 다른 스마트 포인터에서의 모습을 보자.</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">변수의 작동 방식을 살펴 보았으므로 더 많은 데이터 유형을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">이제 논리를 &lt;em&gt;src / lib.rs&lt;/em&gt; 로 추출하고 인수 수집 및 오류 처리를 &lt;em&gt;src / main.rs에 남겨 두었으므로&lt;/em&gt; 코드의 핵심 기능에 대한 테스트를 작성하는 것이 훨씬 쉽습니다. 명령 행에서 바이너리를 호출하지 않고도 다양한 인수로 직접 함수를 호출하고 리턴 값을 확인할 수 있습니다. 의 기능에 대한 몇 가지 테스트 쓰기 자유롭게 &lt;code&gt;Config::new&lt;/code&gt; 및 &lt;code&gt;run&lt;/code&gt; 자신의 기능을.</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">구성 구문 분석 리팩토링을 마쳤으므로 프로그램 논리로 돌아가 보겠습니다. &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;이진 프로젝트에 대한 우려 분리&amp;rdquo;&lt;/a&gt; 에서 언급했듯이 구성 설정 또는 오류 처리와 관련이없는 &lt;code&gt;main&lt;/code&gt; 기능에 현재있는 모든 논리를 보유하는 &lt;code&gt;run&lt;/code&gt; 이라는 함수를 추출 합니다. 완료되면 &lt;code&gt;main&lt;/code&gt; 은 간결하고 검사를 통해 쉽게 확인할 수 있으며 다른 모든 논리에 대한 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">이제 I / O 프로젝트의 표현성을 향상 시켰으므로 프로젝트를 세계와 공유하는 데 도움이되는 &lt;code&gt;cargo&lt;/code&gt; 몇 가지 추가 기능을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">반복자를 소개 했으므로 &lt;code&gt;filter&lt;/code&gt; 반복자 어댑터를 사용하여 환경을 캡처하는 클로저의 일반적인 사용을 보여줄 수 있습니다 . 반복자 의 &lt;code&gt;filter&lt;/code&gt; 메소드는 반복자에서 각 항목을 가져 와서 부울을 리턴하는 클로저를 가져옵니다. 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환하면 &lt;code&gt;filter&lt;/code&gt; 의해 생성 된 반복기에 값이 포함됩니다 . 클로저가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 결과 반복자에 값이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">채널 작동 방식을 살펴 보았으므로 다른 동시성 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">이제 Rust의 언 와인드 안전성에 대한 아이디어를 얻었으므로이 특성이 무엇을 나타내는 지 이해하는 것이 중요합니다. 위에서 언급 한 것처럼 깨진 불변량을 목격하는 한 가지 방법 은 패닉을 포착 한 다음 클로저 환경을 재사용 할 수 있도록이 모듈 의 &lt;code&gt;catch_unwind&lt;/code&gt; 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">계정이 생겼으니 게시하려는 상자가 있다고 가정하겠습니다. 게시하기 전에 상자의 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 의 &lt;code&gt;[package]&lt;/code&gt; 섹션에 메타 데이터를 추가하여 상자에 메타 데이터를 추가해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">이제 벡터를 생성, 업데이트 및 제거하는 방법을 알았으므로 내용을 읽는 방법을 아는 것이 좋은 다음 단계입니다. 벡터에 저장된 값을 참조하는 두 가지 방법이 있습니다. 이 예에서는 추가 기능을 위해 이러한 함수에서 반환되는 값 유형에 주석을 달았습니다.</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">특성을 정의하고 구현하는 방법을 배웠으므로 특성을 사용하여 다양한 유형을 허용하는 함수를 정의하는 방법을 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">제네릭 형식 매개 변수의 경계를 사용하여 사용하려는 동작을 지정하는 방법을 알았으므로 제 10-5 장으로 돌아가서 제네릭 형식 매개 변수를 사용하는 &lt;code&gt;largest&lt;/code&gt; 함수 의 정의를 수정 해 봅시다 ! 지난번에 코드를 실행하려고 할 때 다음 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">테스트를 작성하는 몇 가지 방법을 알았으므로 테스트를 실행할 때 발생하는 상황을 살펴보고 &lt;code&gt;cargo test&lt;/code&gt; 사용할 수있는 다양한 옵션을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">참조의 수명이 어디인지, Rust가 수명을 분석하여 참조가 항상 유효한지 확인한 후, 함수의 맥락에서 파라미터의 일반적인 수명과 값을 반환 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">패턴을 사용할 위치와 반박 가능 패턴과 반박 불가능 패턴의 차이점을 알았으므로 패턴을 만드는 데 사용할 수있는 모든 구문을 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 상자를 &lt;em&gt;Cargo.toml에&lt;/em&gt; 추가 &lt;em&gt;했으므로 &lt;/em&gt; &lt;code&gt;rand&lt;/code&gt; 사용을 시작하겠습니다 . 다음 단계는 Listing 2-3과 같이 &lt;em&gt;src / main.rs&lt;/em&gt; 를 업데이트하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">계정을 만들고 API 토큰을 저장하고 상자 이름을 선택하고 필요한 메타 데이터를 지정 했으므로 게시 할 준비가되었습니다! 상자를 게시하면 다른 사람들이 사용할 수 있도록 특정 버전이 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에 업로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Rust를 설치 했으니 이제 첫 번째 Rust 프로그램을 작성해 봅시다. 텍스트를 인쇄하는 작은 프로그램을 작성하는 새로운 언어를 배우는 것은 전통적 &lt;code&gt;Hello, world!&lt;/code&gt; 화면에 표시되므로 여기서도 동일하게 수행합니다!</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용법을 살펴 보았으니 작동 방식에 대해 알아 보자!</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">표준 라이브러리가 &lt;code&gt;Option&lt;/code&gt; 및 &lt;code&gt;Result&lt;/code&gt; 열거 형 과 함께 제네릭을 사용하는 유용한 방법을 살펴 보았 으므로 제네릭이 작동하는 방식과 코드에서 제네릭을 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">다양한 시나리오에서 테스트 결과가 어떻게 보이는지 살펴 봤으니, &lt;code&gt;panic!&lt;/code&gt; 이외의 매크로를 살펴 보자 ! 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">이제 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록은 튜플에서 상태 행과 파일 이름에 적절한 값만 반환합니다. 그런 다음 18 장에서 논의한 것처럼 &lt;code&gt;let&lt;/code&gt; 문 에서 패턴 을 사용하여 destructuring을 사용 &lt;code&gt;status_line&lt;/code&gt; 두 값을 status_line 및 &lt;code&gt;filename&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">이제 &lt;code&gt;search&lt;/code&gt; 함수는 &lt;code&gt;query&lt;/code&gt; 가 포함 된 행만 반환 해야하며 테스트는 통과해야합니다. 테스트를 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">이제 코드가 컴파일됩니다! 절대 경로와 상대 경로를 살펴보고 &lt;code&gt;pub&lt;/code&gt; 키워드를 추가 하여 개인 정보 규칙과 관련하여 &lt;code&gt;add_to_waitlist&lt;/code&gt; 에서 이러한 경로를 사용할 수 있는 이유를 다시 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">이제 전체 프로그램이 작동합니다! Emily Dickinson의시에서 정확히 한 줄을 돌려 보내야하는 단어로 먼저 시도해 보도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">이제 &lt;code&gt;ThreadPool&lt;/code&gt; 에 &lt;code&gt;execute&lt;/code&gt; 메서드 가 없기 때문에 오류가 발생합니다 . 스레드 풀이 &lt;code&gt;thread::spawn&lt;/code&gt; 과 유사한 인터페이스를 가져야한다고 결정한 &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&quot;유한 한 수의 스레드를위한 유사한 인터페이스 생성&quot;&lt;/a&gt; 섹션을 떠올려 보십시오 . 추가로 우리는 주어진 클로저를 받아 풀의 유휴 스레드에 제공하도록 &lt;code&gt;execute&lt;/code&gt; 함수를 구현할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">이제 비싼 계산은 한 곳에서만 호출되며 결과가 필요한 곳에서만 해당 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">이제 프로그램이 재미있어지고 있습니다! 이 작은 줄에는 많은 일이 일어나고 있습니다. 이것은 &lt;code&gt;let&lt;/code&gt; 문이며 &lt;em&gt;변수&lt;/em&gt; 를 만드는 데 사용됩니다 . 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">이제 서명은 함수 데이터가 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 에서 빌려 왔음을 나타냅니다 . 또는 &lt;code&gt;y&lt;/code&gt; 에서 데이터를 반환하지 않도록 본문을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">이제 상태 패턴의 장점을 볼 수 있습니다 . &lt;code&gt;Post&lt;/code&gt; 의 &lt;code&gt;request_review&lt;/code&gt; 메소드 는 &lt;code&gt;state&lt;/code&gt; 값에 관계없이 동일 합니다. 각 주마다 자체 규칙에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">이제 경고와 오류가 발생합니다. 경고를 잠시 무시하면 &lt;code&gt;ThreadPool&lt;/code&gt; 에 &lt;code&gt;execute&lt;/code&gt; 메소드 가 없으므로 오류가 발생합니다 . 로부터 호출 &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&quot;스레드의 유한 수의 비슷한 인터페이스를 만들기&quot;&lt;/a&gt; 우리가 우리의 스레드 풀과 유사한 인터페이스가 있어야 결정했다고 섹션 &lt;code&gt;thread::spawn&lt;/code&gt; . 또한 &lt;code&gt;execute&lt;/code&gt; 함수를 구현하여 주어진 클로저를 가져 와서 풀의 유휴 스레드에 실행을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">이제 &lt;em&gt;src / lib.rs&lt;/em&gt; 로 옮긴 코드를 &lt;em&gt;src / main.rs&lt;/em&gt; 의 바이너리 크레이트 범위로 &lt;em&gt;가져와야한다 (&lt;/em&gt; 목록 12-14 참조).</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">이제 &lt;code&gt;Post&lt;/code&gt; 에서 &lt;code&gt;content&lt;/code&gt; 메소드 를 업데이트해야 합니다. 상태가 &lt;code&gt;Published&lt;/code&gt; 이면 포스트의 &lt;code&gt;content&lt;/code&gt; 필드에 값을 리턴하려고 합니다. 그렇지 않으면 Listing 17-17에 표시된 것처럼 빈 문자열 슬라이스를 리턴하려고한다.</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">이제 화면에 오류가 있고 &lt;em&gt;output.txt&lt;/em&gt; 에 아무것도 포함되어 있지 않습니다. 이는 명령 행 프로그램에서 예상되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">이제 &lt;code&gt;filename&lt;/code&gt; 명령 줄 인수에 지정된 파일을 읽는 기능을 추가하겠습니다 . 먼저 테스트 할 샘플 파일이 필요합니다. &lt;code&gt;minigrep&lt;/code&gt; 이 작동 하는지 확인하는 데 사용할 수있는 최상의 파일 유형은 반복되는 단어가 여러 줄에 걸쳐 적은 양의 텍스트가있는 파일입니다. 리스팅 12-3에는 잘 작동하는 Emily Dickinson 시가있다! 프로젝트의 루트 수준에서 &lt;em&gt;poem.txt&lt;/em&gt; 라는 파일을 &lt;em&gt;만들고&lt;/em&gt; &amp;ldquo;I 'm Nobody! 누구세요?&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">이제 &lt;code&gt;Draw&lt;/code&gt; 특성 을 구현하는 몇 가지 유형을 추가하겠습니다 . &lt;code&gt;Button&lt;/code&gt; 유형을 제공하겠습니다 . 다시 말하지만 실제로 GUI 라이브러리를 구현하는 것은이 책의 범위를 벗어나므로 &lt;code&gt;draw&lt;/code&gt; 메소드에는 유용한 구현이 없습니다. 구현이 어떻게 생겼는지 상상하기 위해, &lt;code&gt;Button&lt;/code&gt; struct 에는 Listing 17-7에 표시된 것처럼 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;label&lt;/code&gt; 필드가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">이제 클라이언트 요청에 대한 응답으로 데이터 전송을 구현합니다. 응답의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">이제 &lt;code&gt;Drop&lt;/code&gt; 특성을 구현하여 풀의 각 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 처리 전에 요청을 완료 할 수 있도록합니다. 그런 다음 스레드에 새 요청 수락을 중지하고 종료해야한다는 것을 알리는 방법을 구현합니다. 이 코드가 실제로 작동하는지 확인하기 위해 스레드 풀을 정상적으로 종료하기 전에 두 개의 요청 만 수락하도록 서버를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;thread::spawn&lt;/code&gt; 주어진 클로저 가 아무 것도하지 않는 문제를 해결해 보겠습니다 . 현재 우리는 &lt;code&gt;execute&lt;/code&gt; 메소드 에서 실행하려는 클로저를 얻습니다 . 그러나 &lt;code&gt;ThreadPool&lt;/code&gt; 을 만드는 동안 각 &lt;code&gt;Worker&lt;/code&gt; 를 만들 때 &lt;code&gt;thread::spawn&lt;/code&gt; 에 클로저 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">이제 오류 처리 문제를 해결해 보겠습니다. 인덱스 1 또는 인덱스 2에서 &lt;code&gt;args&lt;/code&gt; 벡터 의 값에 액세스하려고하면 벡터에 3 개 미만의 항목이 포함 된 경우 프로그램이 패닉 상태가됩니다. 인수없이 프로그램을 실행하십시오. 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">이제 시작 &lt;em&gt;및&lt;/em&gt; 끝 색인을 추적하고 있으며 특정 상태의 데이터에서 계산되었지만 해당 상태와 전혀 관련이없는 더 많은 값이 있습니다. 우리는 이제 세 개의 관련없는 변수들이 떠다니며 동기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">이제 &lt;code&gt;first_word&lt;/code&gt; 를 호출 하면 기본 데이터와 연결된 단일 값을 다시 얻습니다. 이 값은 슬라이스의 시작점과 슬라이스의 요소 수에 대한 참조로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">이제 프로그램을 실행할 때 오류가 발생하지 않으며 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">이제 테스트를 실행하면보다 유익한 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">이제 새 특성 패턴이 특성과 관련하여 어떻게 사용되는지 알았습니다. 특성이 관련되지 않은 경우에도 유용한 패턴입니다. 포커스를 전환하고 Rust의 유형 시스템과 상호 작용하는 고급 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">이제는 trait 객체 에서 &lt;code&gt;foo()&lt;/code&gt; 를 더 이상 호출 할 수 없지만 이제는 trait 객체를 만들 수 있으며 객체 안전 메서드를 호출 할 수 있습니다. 그러한 바운드를 사용하면 특성 객체 뒤에없는 특성을 구현하는 유형에서 여전히 &lt;code&gt;foo()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">이제 때마다 당신이 전화 &lt;code&gt;rustc&lt;/code&gt; 또는 &lt;code&gt;cargo&lt;/code&gt; 의 내부 &lt;em&gt;~ / 프로젝트 / 요구 - 야간&lt;/em&gt; , &lt;code&gt;rustup&lt;/code&gt; 은 오히려 안정 녹의 기본보다, 야간 녹를 사용하고 있는지 확인합니다. Rust 프로젝트가 많을 때 편리합니다!</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">이제 다음 코드가 있다면 :</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">이제 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여 여러 스레드간에 값을 공유해 봅시다 . 우리는 10 개의 스레드를 회전시키고 각각의 카운터 값을 1 씩 증가 시키도록합니다. 따라서 카운터는 0에서 10으로갑니다. 다음 몇 가지 예제에는 컴파일러 오류가있을 것입니다. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 와 Rust가 올바르게 사용하는 방법 Listing 16-13에는 시작 예제가있다.</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="translated">이제 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여 여러 스레드간에 값을 공유해 보겠습니다 . 10 개의 스레드를 스핀 업하고 각각 카운터 값을 1 씩 증가 시키도록 할 것입니다. 따라서 카운터는 0에서 10으로 이동합니다. 목록 16-13의 다음 예제에는 컴파일러 오류가 있으며이 오류를 사용하여 학습 할 것입니다. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용에 대한 자세한 내용 과 Rust가이를 올바르게 사용하는 데 어떻게 도움이되는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;cargo run&lt;/code&gt; 사용하여이 프로그램을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">별명 &lt;code&gt;Kilometers&lt;/code&gt; 는 &lt;code&gt;i32&lt;/code&gt; 의 &lt;em&gt;동의어&lt;/em&gt; 입니다 . 목록 19-15에서 만든 &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; 유형 과 달리 &lt;code&gt;Kilometers&lt;/code&gt; 는 별도의 새로운 유형이 아닙니다. 타입이 값 &lt;code&gt;Kilometers&lt;/code&gt; 타입의 값과 동일하게 취급한다 &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">이제 더 나아갈 수 있습니다. 다음은 잘못된 코드 예입니다.</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">이제 사용할 수 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 대신 반환 유형이 훨씬 더 의미가 있습니다. 루프가 중지되면 오류가 발생했음을 의미합니다. 우리는 심지어에서 루프를 포장하지 않아도 &lt;code&gt;Ok&lt;/code&gt; 하기 때문에 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; 자동 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">이제 서버 연결이 끊어지면 당황하지 않고 오류와 함께 루프를 종료합니다. 단순히 오류를 반환하는 것이 직관적 일 수도 있지만 대신 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 래핑 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">이제 코드를 변경하지 않고 Listing 2-2와 같이 프로젝트를 빌드하자.</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">이제 모든 기본값을 얻습니다. Rust 는 다양한 프리미티브 유형에 대해 &lt;code&gt;Default&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">확인되지 않은 버전</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">널 입력 가능 포인터</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">밑이 2 인 유효 자릿수</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 진법의 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 진법의 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">숫자 연산</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">숫자 형 캐스트</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">특정 유형의 숫자 ​​리터럴</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">이 유형에 사용 된 숫자 값은 이식 가능한 의미가 없으며 플랫폼에 따라 다른 양으로 가려 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O (로그 n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O (분 (i, ni))</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O (분 (i, ni)) *</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="translated">OS 별 동작</target>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; 대한 OS 별 확장 .</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">OS 별 기능.</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Rust의 객체 지향 프로그래밍 기능</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">객체 안전</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">특성 개체에 개체 안전이 필요합니다</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">객체 안전 특성</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">개체 안전 특성은 &lt;a href=&quot;../types/trait-object&quot;&gt;특성 개체&lt;/a&gt; 의 기본 특성 일 수 있습니다 . 특성은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255에&lt;/a&gt; 정의 된 다음과 같은 특성이있는 경우 &lt;em&gt;객체 안전&lt;/em&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">객체 지향 프로그래밍 (OOP)은 프로그램을 모델링하는 방법입니다. 개체는 1960 년대 Simula에서 나왔습니다. 이러한 개체는 개체가 서로 메시지를 전달하는 Alan Kay의 프로그래밍 아키텍처에 영향을 미쳤습니다. 그는 1967 년에 &lt;em&gt;객체 지향 프로그래밍&lt;/em&gt; 이라는 용어를 만들어이 아키텍처를 설명했습니다. 많은 경쟁 정의는 OOP가 무엇인지 설명합니다. 일부 정의는 Rust를 객체 지향으로 분류하지만 다른 정의는 그렇지 않습니다. 이 장에서는 일반적으로 객체 지향으로 간주되는 특정 특성과 이러한 특성이 관용적 녹으로 변환되는 방식을 살펴 봅니다. 그런 다음 Rust에서 객체 지향 디자인 패턴을 구현하는 방법을 보여주고 대신 Rust의 강점을 사용하여 솔루션을 구현하는 것과의 단점을 논의합니다.</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">객체 지향 프로그램은 객체로 구성됩니다. &lt;em&gt;개체&lt;/em&gt; 패키지 데이터와 데이터에서 작동 절차. 절차를 일반적으로 &lt;em&gt;방법&lt;/em&gt; 또는 &lt;em&gt;작업&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">객체는 데이터와 행동을 포함</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">양방향으로 걸을 수있는 물체.</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="translated">&lt;em&gt;후속&lt;/em&gt; 작업 및 &lt;em&gt;선행&lt;/em&gt; 작업 의 개념이있는 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">때때로 &quot;후드&quot;에서 발생하는 돌연변이가 API에 노출되지 않는 것이 바람직 할 수 있습니다. 이는 논리적으로 작업이 변경 불가능하기 때문일 수 있지만, 예를 들어 캐싱은 구현이 돌연변이를 수행하도록 강제합니다. 또는 원래 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 취하도록 정의 된 특성 분석법을 구현하려면 돌연변이를 사용해야하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">의 발생 &lt;code&gt;.&lt;/code&gt; 경로의 시작 부분에있는 경우를 제외하고 정규화됩니다. 예를 들어, &lt;code&gt;a/./b&lt;/code&gt; , &lt;code&gt;a/b/&lt;/code&gt; , &lt;code&gt;a/b/.&lt;/code&gt; 및 &lt;code&gt;a/b&lt;/code&gt; 모두가 및 &lt;code&gt;b&lt;/code&gt; 성분뿐만 아니라 &lt;code&gt;./a/b&lt;/code&gt; 추가로 시작 &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt; 성분. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">8 진 정수</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">물론, 어떤 컬렉션이 작업에 적합한 지 알면 즉시 사용할 수있는 것은 아닙니다. 다음은 일반적으로 표준 모음을 효율적이고 올바르게 사용하기위한 몇 가지 빠른 팁입니다. 특정 모음을 사용하는 방법에 관심이있는 경우 자세한 설명 및 코드 예제는 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">물론 &lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt; 직접 사용하는 것은 &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 같은 것보다 덜 일반적입니다 ! .</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="translated">물론, 참조하는 모듈이 조상이라면 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">종종 두 개의 기존 문자열을 결합하려고 할 것입니다. 한 가지 방법은 목록 8-18에 표시된대로 &lt;code&gt;+&lt;/code&gt; 연산자 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="translated">에 &lt;code&gt;packed&lt;/code&gt; 구조체</target>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Linux 시스템에서 이것이 &lt;code&gt;foo&lt;/code&gt; 로 컴파일 된 경우 :</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">Linux, macOS 및 Windows의 PowerShell에서는 쉘에 &lt;code&gt;ls&lt;/code&gt; 명령 을 입력하여 실행 파일을 볼 수 있습니다 . Linux 및 macOS에는 두 개의 파일이 있습니다. Windows에서 PowerShell을 사용하면 CMD를 사용할 때와 동일한 세 개의 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">Linux에서 :</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Redox에서는 항상 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">유닉스에서</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">Unix 플랫폼에서이 메소드 호출은 &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 호출에 해당합니다 . Windows 호출에서이 메소드는 &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 호출에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">Unix 플랫폼에서 기본 syscall은 가짜 웨이크 업 또는 신호 처리기에 의해 중단 될 수 있습니다. 지정된 기간 동안 휴면이 발생하도록하기 위해이 함수는 해당 시스템 호출을 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">Unix 플랫폼에서 기본 syscall은 가짜 웨이크 업 또는 신호 처리기에 의해 중단 될 수 있습니다. 지정된 기간 동안 휴면이 발생하도록하기 위해이 함수는 해당 시스템 호출을 여러 번 호출 할 수 있습니다. 해야합니다 수면을위한 나노초 정밀도를 지원하지 않는 플랫폼 &lt;code&gt;dur&lt;/code&gt; 그들이 잘 수있는 시간의 가장 가까운 단위로 반올림.</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">유닉스 시스템에서 쉘은 일반적으로 glob 패턴 (예 : &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; ) 으로 따옴표없는 인수를 확장 합니다. Windows에서는이 작업이 수행되지 않으며 이러한 인수는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">Unix 시스템에서 쉘은 일반적으로 glob 패턴 (예 : &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; ) 으로 인용되지 않은 인수를 확장 합니다. Windows에서는이 작업이 수행되지 않으며 이러한 인수는있는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">pthread 기반 TLS를 사용중인 Unix 시스템에서는 종료시 기본 스레드에서 TLS 값에 대해 소멸자가 실행되지 않습니다. 메인 스레드가 종료 된 직후에도 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">유닉스 시스템에서 문자열은 종종 0이 아닌 바이트의 임의의 시퀀스이며, 많은 경우 UTF-8로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">Unix에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; 의&lt;/a&gt; 두 가지 방법으로 기능을 보강합니다 . 이것들은 UTF-8 바이트 슬라이스를 저렴하게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">유닉스에서 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작하면 루트가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">Unix에서 루트로 시작하면 경로는 절대이므로 &lt;code&gt;is_absolute&lt;/code&gt; 와 &lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; 는 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">Unix에서 루트로 시작하는 경로는 절대 경로이므로 &lt;code&gt;is_absolute&lt;/code&gt; 와 &lt;a href=&quot;struct.path#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">유닉스에서는 프로세스가 신호에 의해 종료되면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. &lt;code&gt;std::os::unix&lt;/code&gt; 는 &lt;code&gt;ExitStatus&lt;/code&gt; 에서 신호 및 기타 세부 사항을 추출하기위한 확장 특성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">Windows에서</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">Windows 및 대부분의 Unix 플랫폼에서이 기능은 무료이지만 (추가 시스템 호출이 필요하지 않음) 일부 Unix 플랫폼 에서는 대상 파일 유형에 대해 학습 하기 위해 &lt;code&gt;symlink_metadata&lt;/code&gt; 에 해당하는 호출이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">Windows에서는이 기능을 호출하는 것이 저렴하지만 (추가 시스템 호출이 필요하지 않음) Unix 플랫폼에서이 기능은 경로에서 &lt;code&gt;symlink_metadata&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공합니다 . 이것은 &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 의 벡터로 &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 될 수있는 반복자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공하는 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;트레이 트를 구현합니다 . 이것은 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 벡터로 &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 될 수있는 반복자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">Windows에서 경로는 다음과 같은 경우 루트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">Windows에서 접두어가 있고 루트로 시작하는 경로는 절대 경로입니다. &lt;code&gt;c:\windows&lt;/code&gt; 는 절대이지만 &lt;code&gt;c:temp&lt;/code&gt; 및 &lt;code&gt;\temp&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">Windows에서 기호 링크는 파일인지 디렉토리인지를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">Windows에서 명령을 입력 &lt;code&gt;.\main.exe&lt;/code&gt; 대신 &lt;code&gt;./main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; 로 이동하여 Rust 설치 지침을 따릅니다. 설치의 어느 시점에서 Visual Studio 2013 이상용 C ++ 빌드 도구도 필요하다는 메시지가 표시됩니다. 빌드 도구를 얻는 가장 쉬운 방법 &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;은 Visual Studio 2019 용 빌드 도구&lt;/a&gt; 를 설치하는 것 입니다. 설치할 워크로드를 묻는 메시지가 표시되면 &quot;C ++ 빌드 도구&quot;가 선택되어 있고 Windows 10 SDK 및 영어 언어 팩 구성 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">Windows의 경우 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; 로 이동하여 Rust 설치 지침을 따르십시오. 설치의 어느 시점에서 Visual Studio 2013 이상의 C ++ 빌드 도구가 필요하다는 메시지가 표시됩니다. 빌드 도구를 얻는 가장 쉬운 방법 &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;은 Visual Studio 2019 용 빌드 도구&lt;/a&gt; 를 설치하는 것 입니다. 도구는 기타 도구 및 프레임 워크 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">Windows에서 문자열은 종종 0이 아닌 16 비트 값의 임의 시퀀스이며, 유효 할 때 UTF-16으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;확장 된 길이 경로&lt;/a&gt; 구문 을 사용하도록 경로를 변환 하여 프로그램에서 더 긴 경로 이름을 사용할 수 있지만 백 슬래시로 구분 된 경로 만 결합 할 수 있으며 다른 응용 프로그램과 호환되지 않을 수 있습니다 ( 명령 줄에서 응용 프로그램을 작성하거나 다른 응용 프로그램이 읽을 수있는 파일에 기록됨).</target>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">Windows에서는 경로를 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;확장 길이 경로&lt;/a&gt; 구문 을 사용하도록 변환 하여 프로그램에서 더 긴 경로 이름을 사용할 수 있지만 백 슬래시로 구분 된 경로 만 조인 할 수 있으며 다른 응용 프로그램과 호환되지 않을 수 있습니다 ( 명령 줄에있는 응용 프로그램 또는 다른 응용 프로그램이 읽을 수있는 파일에 기록).</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">Windows에서는 기호 링크가 파일 또는 디렉토리를 가리키는 지 여부를 지정해야합니다. 사용 &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; 파일에 대한 심볼릭 링크를 만들거나 &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; 디렉토리에 대한 심볼릭 링크를 만들 수 있습니다. 또한 심볼릭 링크를 만들려면 프로세스에 &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">구조체 패턴에서 필드는 이름, 인덱스 (튜플 구조체의 경우)로 참조되거나 &lt;code&gt;..&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">기술적으로 Rust inserts</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">모든 플랫폼에서 TLS는 파괴 중에 다른 TLS 슬롯을 다시 초기화 할 수 있습니다. 일부 플랫폼은 파괴 된 슬롯의 재 초기화를 방지하여 무한정 발생할 수는 없지만 모든 플랫폼에 이러한 보호 기능이있는 것은 아닙니다. 보호하지 않는 플랫폼은 일반적으로 더 이상 소멸자가 실행되지 않는 합성 한계를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="translated">모든 플랫폼에서 개행 문자는 LINE FEED 문자 ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) 만입니다 (추가 CARRIAGE RETURN ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ) 없음).</target>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">모든 플랫폼에서 줄 바꿈은 LINE FEED 문자 ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) 단독입니다 (추가 캐리지 리턴 ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ) 없음 ).</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">산술 오버플로에서 &lt;code&gt;LayoutErr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">빅 엔디안에서 이것은 no-op입니다. 리틀 엔디안에서는 바이트가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">실패하면 원래 &lt;code&gt;CString&lt;/code&gt; 의 소유권 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">실패하면 원래 &lt;code&gt;OsString&lt;/code&gt; 의 소유권 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">glibc Linux 시스템에서는 &quot;.init_array&quot;에 함수를 배치하여 인수를 검색합니다. Glibc는 &quot;.init_array&quot;의 함수에 비표준 확장으로 argc, argv 및 envp를 전달합니다. 이것은 &lt;code&gt;std::env::args&lt;/code&gt; 가 macOS 및 Windows에서와 마찬가지로 &lt;code&gt;cdylib&lt;/code&gt; 또는 &lt;code&gt;staticlib&lt;/code&gt; 에서도 작동하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">glibc Linux 시스템에서 인수는 &lt;code&gt;.init_array&lt;/code&gt; 에 함수를 배치하여 검색 됩니다 . Glibc는 비표준 확장으로 &lt;code&gt;argc&lt;/code&gt; , &lt;code&gt;argv&lt;/code&gt; 및 &lt;code&gt;envp&lt;/code&gt; 를 &lt;code&gt;.init_array&lt;/code&gt; 의 함수에 전달 합니다. 이것은 &lt;code&gt;std::env::args&lt;/code&gt; 가 macOS 및 Windows에서와 마찬가지로 &lt;code&gt;cdylib&lt;/code&gt; 또는 &lt;code&gt;staticlib&lt;/code&gt; 에서도 작동하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">반복시 클로저는 반복자의 각 요소에 적용되며 클로저의 반환 값인 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 은 반복자에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">리틀 엔디안에서는 이것이 작동하지 않습니다. 빅 엔디안에서는 바이트가 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">비 포인터 유형 &lt;code&gt;*x&lt;/code&gt; 동등 &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; 에서 &lt;a href=&quot;../expressions#mutability&quot;&gt;불변 장소 식 컨텍스트&lt;/a&gt; 및 &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 변경 가능한 곳에 표현 문맥.</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">패닉 상태에서이 매크로는 표현식의 값을 디버그 표현으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">일부 시스템에서는 OS가 리소스를 해제하려면 호출 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 것이 필요합니다. 종료되었지만 대기하지 않은 프로세스는 여전히 &quot;좀비&quot;입니다. 주위에 너무 많은 좀비를 남겨두면 전역 리소스 (예 : 프로세스 ID)가 소모 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">일부 시스템에서는 OS가 리소스를 해제하기 위해 &lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 호출 이 필요합니다. 종료되었지만 기다리지 않은 프로세스는 여전히 &quot;좀비&quot;로 남아 있습니다. 좀비를 너무 많이 남겨두면 글로벌 리소스 (예 : 프로세스 ID)가 고갈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">성공하면이 함수는 반환되지 않으며, 그렇지 않으면 exec (또는 &lt;code&gt;Command&lt;/code&gt; 설정의 다른 부분 )가 실패한 이유를 나타내는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">성공하면 읽은 바이트 수와 데이터가 왔을 때의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">성공하면 읽은 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">성공하면 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">성공시, 복사 된 총 바이트 수를 반환하고, 그것은의 길이와 동일한 &lt;code&gt;to&lt;/code&gt; 의해보고 된 파일 &lt;code&gt;metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;reader&lt;/code&gt; 에서 &lt;code&gt;writer&lt;/code&gt; 로 복사 된 총 바이트 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">온 &lt;code&gt;Screen&lt;/code&gt; 구조체, 우리는 방법 이름을 정의 할 것이다 &lt;code&gt;run&lt;/code&gt; 부르는 것 &lt;code&gt;draw&lt;/code&gt; 는 각각 방법을 &lt;code&gt;components&lt;/code&gt; 17-5 목록과 같이를 :</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 의 첫 번째 줄에서 &lt;code&gt;env::args&lt;/code&gt; 라고 부르고 즉시 &lt;code&gt;collect&lt;/code&gt; 를 사용 하여 반복자를 반복자에 의해 생성 된 모든 값을 포함하는 벡터로 바꿉니다. 우리는 사용할 수 있습니다 &lt;code&gt;collect&lt;/code&gt; 우리가 명시 적으로 유형 주석, 그래서 컬렉션의 많은 종류를 생성하는 기능을 &lt;code&gt;args&lt;/code&gt; 우리가 문자열의 벡터를 지정할 수 있습니다. Rust에서 유형에 주석을 달아야 &lt;code&gt;collect&lt;/code&gt; 는 거의 없지만 collect 는 Rust가 원하는 컬렉션을 유추 할 수 없기 때문에 주석을 달아야하는 함수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반면에 구현하기에 적합하지 않은 한 가지 특성은 &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="translated">반면에 이것은 정확합니다.</target>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="translated">반면에, &lt;code&gt;where 'b: 'a&lt;/code&gt; 절이 없기 때문에 컴파일되지 않습니다 : &lt;code&gt;'b&lt;/code&gt; 수명은 적어도 &lt;code&gt;'a&lt;/code&gt; 만큼 오래 사는 것으로 알려져 있지 않습니다. 즉,이 함수가 항상 유효한 참조를 반환하도록 보장 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">반면에 struct, enum 및 기타 &lt;code&gt;use&lt;/code&gt; 항목을 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 리스팅 7-14는 표준 라이브러리의 &lt;code&gt;HashMap&lt;/code&gt; 구조체를 이진 크레이트의 범위로 가져 오는 관용적 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">반면에 trait 객체를 사용하는 메서드를 사용하면 하나의 &lt;code&gt;Screen&lt;/code&gt; 인스턴스는 &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; 과 &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; 를 포함하는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 보유 할 수 있습니다 . 이것이 어떻게 작동하는지 살펴보고 런타임 성능 관련 사항에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="translated">표면적으로 &lt;code&gt;static&lt;/code&gt; 항목은 &lt;a href=&quot;keyword.const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; 와 매우 유사 해 보입니다 . 둘 다 값을 포함하고 둘 다 유형 주석을 필요로하며 둘 다 상수 함수 및 값으로 만 초기화 할 수 있습니다. 그러나 &lt;code&gt;static&lt;/code&gt; 은 메모리의 위치를 ​​나타내는 점에서 현저하게 다릅니다. 즉, &lt;code&gt;static&lt;/code&gt; 항목에 대한 참조를 가질 수 있고 잠재적으로 수정하여 본질적으로 전역 변수로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; (또는 해당 멤버) 의 &lt;code&gt;Drop&lt;/code&gt; 구현 이 이에 의존 할 수 있으므로 &lt;code&gt;T&lt;/code&gt; 유형의 모든 추가 불변 이 충족되어야합니다 . 예를 들어, &lt;code&gt;1&lt;/code&gt; 초기화 된 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 데이터 포인터가 null이 아니어야한다는 것을 알고있는 유일한 요구 사항이기 때문에 초기화 된 것으로 간주됩니다 (현재 구현에서 이것은 안정적인 보장을 구성하지 않음). 그러나 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 삭제 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="translated">또한 함수 포인터는 사용하는 ABI에 따라 달라질 수 있습니다. 이는 유형 앞에 &lt;code&gt;extern&lt;/code&gt; 키워드 를 추가하고 그 뒤에 해당 ABI를 추가하면 됩니다. 기본 ABI는 &quot;Rust&quot;입니다. 즉, &lt;code&gt;fn()&lt;/code&gt; 은 &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt; 과 정확히 동일한 유형 입니다. C ABI를 사용하는 함수에 대한 포인터는 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">또한 함수 포인터는 사용하는 ABI에 따라 달라질 수 있습니다. &lt;code&gt;extern&lt;/code&gt; 키워드를 형식 이름 에 추가 한 다음 해당 ABI를 추가하면 됩니다. 예를 들어, &lt;code&gt;fn()&lt;/code&gt; 은 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 과 다릅니다. 이는 &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; 과 는 다릅니다 . Rust가 지원하는 다양한 ABI에 대해서도 마찬가지입니다. 비 &lt;code&gt;extern&lt;/code&gt; 함수는 ABI가 &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; 이고, 명시 적 ABI가없는 &lt;code&gt;extern&lt;/code&gt; 함수는 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;은 외래 통화 규칙에 대한 nomicon 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">또한 대부분의 유형에는 단순히 유형 수준에서 초기화되는 것으로 간주되는 것 이상의 추가 불변성이 있다는 점을 기억하십시오. 예를 들어, &lt;code&gt;1&lt;/code&gt; 초기화 된 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 데이터 포인터가 null이 아니어야한다는 것을 알고있는 유일한 요구 사항이기 때문에 초기화 된 것으로 간주됩니다 (현재 구현에서 이것은 안정적인 보장을 구성하지 않음). 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 생성 하면 &lt;em&gt;즉시&lt;/em&gt; 정의되지 않은 동작이 발생하지는 않지만 대부분의 안전한 작업 (삭제 포함)으로 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">또한 대부분의 유형에는 유형 수준에서 초기화 된 것으로 간주되는 것 외에 추가 불변이 있습니다. 예를 들어, 컴파일러가 알고있는 유일한 요구 사항은 데이터 포인터가 널이 아니어야하기 때문에 &lt;code&gt;1&lt;/code&gt; - 초기화 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 초기화 된 것으로 간주됩니다. 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성 하면 &lt;em&gt;즉시&lt;/em&gt; 정의되지 않은 동작이 발생하지 않지만 가장 안전한 조작 (삭제 포함)에서 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">일단 &lt;code&gt;Config::new&lt;/code&gt; 것을 빌려을 인덱싱 작업을 사용하여 반복자의 소유권을 정지, 우리는 이동할 수 있습니다 &lt;code&gt;String&lt;/code&gt; 로 반복자의 값 &lt;code&gt;Config&lt;/code&gt; 하지 않고 호출하는 대신 &lt;code&gt;clone&lt;/code&gt; 및 새로운 할당을.</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">미래가 완료되면 ( &lt;code&gt;poll&lt;/code&gt; 에서 &lt;code&gt;Ready&lt;/code&gt; 완료로 돌아옴 ), &lt;code&gt;poll&lt;/code&gt; 방법을 다시 호출하면 패닉이 발생하거나 영원히 차단되거나 다른 종류의 문제가 발생할 수 있습니다. &lt;code&gt;Future&lt;/code&gt; 특성은 호출의 효과에 대한 요구 사항을 배치하지 않습니다. 그러나 &lt;code&gt;poll&lt;/code&gt; 방법이 &lt;code&gt;unsafe&lt;/code&gt; 로 표시되지 않으므로 Rust의 일반적인 규칙이 적용됩니다. 호출은 미래 상태에 관계없이 정의되지 않은 동작 (메모리 손상, &lt;code&gt;unsafe&lt;/code&gt; 기능 의 잘못된 사용 등)을 유발해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">미래가 끝나면 클라이언트는 다시 &lt;code&gt;poll&lt;/code&gt; 하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">유효한 크기가 수신되면 &lt;code&gt;ThreadPool&lt;/code&gt; 은 &lt;code&gt;size&lt;/code&gt; 항목을 보유 할 수있는 새로운 벡터를 생성 합니다. 이 책 에서는 &lt;code&gt;with_capacity&lt;/code&gt; 함수를 아직 사용하지 않았습니다.이 함수는 &lt;code&gt;Vec::new&lt;/code&gt; 와 동일한 작업을 수행 하지만 중요한 차이점이 있습니다. 벡터의 공간을 미리 할당합니다. 벡터에 &lt;code&gt;size&lt;/code&gt; 요소 를 저장해야한다는 것을 알고 있기 때문에이 할당을 &lt;code&gt;Vec::new&lt;/code&gt; 하는 것은 요소가 삽입 될 때 자체 크기를 조정 하는 Vec :: new를 사용하는 것보다 약간 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">다시 한번 우리는 사용하고 있습니다 &lt;code&gt;!&lt;/code&gt; 이 경우의 다른 타입으로 강요의 능력, &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; . 이 방법은 &lt;code&gt;&amp;amp;!&lt;/code&gt; 인수로 우리는 호출 될 수 없다는 것을 알고 있습니다 (호출 할 유형의 값이 없기 때문에 &lt;code&gt;!&lt;/code&gt; ). &lt;code&gt;*self&lt;/code&gt; 를 작성 하면 본질적으로 컴파일러에게 &quot;이 코드를 실행할 수 없다는 것을 알고 있으므로 전체 함수 본문을 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 유형 &quot; 으로 취급하면 됩니다. 이 패턴은 특성을 구현할 때 많이 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; . 일반적으로 &lt;code&gt;self&lt;/code&gt; 매개 변수 를 취하는 방법 만있는 특성 은 그러한 의미를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">다시 한 번, 컴파일하고 다른 오류가 발생합니다! 컴파일러는 우리에게 많은 것을 가르치고 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">채널의 절반이 할당 해제되면 대부분의 작업이 더 이상 진행을 계속할 수 없으므로 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 많은 응용 프로그램 이이 모듈에서 반환 된 결과를 계속해서 &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; 면서 예기치 않게 스레드가 중단 될 경우 스레드간에 오류가 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">내부 저장 장치가 연속되면, &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; 의&lt;/a&gt; 방법은 그 전체 내용 반환 &lt;code&gt;VecDeque&lt;/code&gt; 을 한 조각이다.</target>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">내부 저장 장치가 연속되면, &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; 의&lt;/a&gt; 방법은 그 전체 내용 반환 &lt;code&gt;VecDeque&lt;/code&gt; 을 한 조각이다.</target>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="translated">이 함수가 반환되면 &lt;code&gt;bufs&lt;/code&gt; 의 내용 이 지정되지 않습니다. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 에 대한 호출 이 필요한 횟수 에 따라 달라집니다 . 이 기능은 &lt;code&gt;bufs&lt;/code&gt; 의 소유권을 가지고 나중에 &lt;code&gt;bufs&lt;/code&gt; 를 사용하지 않는 것으로 이해하는 것이 가장 좋습니다 . &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 가 가리키는 기본 버퍼 ( &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 자체는 아님)는 변경되지 않으며 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">반복자를 만든 후에는 다양한 방법으로 사용할 수 있습니다. 3 장의 목록 3-5에서 &lt;code&gt;for&lt;/code&gt; 루프 와 함께 반복자를 사용 하여 각 항목에 대해 일부 코드를 실행했지만 지금까지 &lt;code&gt;iter&lt;/code&gt; 호출이 수행 한 작업에 대해 설명했습니다 .</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하면 반복자 가 있습니다! Listing 13-22는 Listing 13-15의 벡터에서 생성 된 이터레이터에서와 마찬가지로 &lt;code&gt;next&lt;/code&gt; 메소드를 직접 호출하여 &lt;code&gt;Counter&lt;/code&gt; 구조체 의 이터레이터 기능을 사용할 수 있음을 보여주는 테스트를 보여준다 .</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">표준 라이브러리의 내용에 익숙해지면 산만 산만 함의 장황함을 찾기 시작할 수 있습니다. 개발 단계에서 페이지 상단 부근의 &lt;code&gt;[-]&lt;/code&gt; 버튼 을 눌러 더보기 좋게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">필요한 종류의 슬라이스가 있으면 (널 터미네이터를 사용하거나 사용하지 않고) 슬라이스 자체 &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 extern 함수에 전달할 읽기 전용 원시 포인터를 얻을 수 있습니다. 원시 포인터의 수명을 보장하는 것에 대한 설명은 해당 기능의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
