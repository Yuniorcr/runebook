<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;Ref::clone(...)&lt;/code&gt; 으로 사용해야하는 관련 함수입니다 . &lt;code&gt;Clone&lt;/code&gt; 구현이나 방법의 광범위한 사용을 방해 할 &lt;code&gt;r.borrow().clone()&lt;/code&gt; a의 내용을 복제 할 &lt;code&gt;RefCell&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Ref::leak(...)&lt;/code&gt; 로 사용해야하는 관련 함수입니다 . 메서드는 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용되는 &lt;code&gt;Deref&lt;/code&gt; 의 내용에서 동일한 이름의 메서드를 방해 합니다.</target>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;Ref::map(...)&lt;/code&gt; 으로 사용해야하는 관련 함수입니다 . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;Ref::map_split(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RefMut::leak(...)&lt;/code&gt; 로 사용되어야하는 관련 함수입니다 . 메서드는 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용되는 &lt;code&gt;Deref&lt;/code&gt; 의 내용에서 동일한 이름의 메서드를 방해 합니다.</target>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;RefMut::map(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">초기화되지 않은 메모리를 초기화하거나 이전에 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 메모리를 덮어 쓰는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">초기화되지 않은 메모리를 초기화하거나 이전에 읽은 메모리를 덮어 쓰는 데 적합합니다. &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; 로 적합&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">이것은 기반으로합니다 &lt;code&gt;malloc&lt;/code&gt; Unix 플랫폼의 malloc 과 Windows의 &lt;code&gt;HeapAlloc&lt;/code&gt; 및 관련 기능을 합니다.</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">이는 &lt;code&gt;AddAssign&lt;/code&gt; 이 자동으로 구현되지 않기 때문에 사용자 유형에 맞게 수동으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">셀 유형이 스레드로부터 안전하지 않은 작업을 수행하기 때문입니다. 이로 인해 동기화를 구현하지 않으므로 스태틱에 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">이는 일부 특성의 연관된 유형 (예 : &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; 구현 하는 T &lt;code&gt;T::Bar&lt;/code&gt; )과 &lt;code&gt;T::Bar&lt;/code&gt; 동일해야하는 다른 유형 &lt;code&gt;U&lt;/code&gt; 간의 유형이 일치하지 않기 때문입니다 . 와 아니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Clone::clone_from&lt;/code&gt; 의 차용 일반화 버전입니다. .</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">6 주마다 릴리스가 &quot;스테이션을 떠나지 만&quot;베타 채널이 안정적인 릴리스로 도착하기 전에 여행해야하기 때문에 이것을 &quot;기차 모델&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">이것은 재앙 적입니다. 먼저 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 내용을 고정한 다음 ( &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ) 나중에 얻은 변경 가능한 참조를 사용하여 해당 내용을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">이것은 치명적이므로 먼저 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 고정하고 ( &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ) 나중에 얻은 가변 참조를 사용하여 해당 내용을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값 생성기를 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 거의 모든 것을 다루는 반복자가있을 수 있지만 특별한 경우가 더 필요합니다. 반복자에서 작동하는 함수가있을 수 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값 생성기를 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 어쩌면 거의 모든 것을 다루는 반복자가 있지만 특별한 경우가 필요합니다. 반복자에서 작동하는 함수가 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">일반적으로 단일 값을 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 거의 모든 것을 다루는 반복자가있을 수 있지만 특별한 경우가 더 필요합니다. 반복자에서 작동하는 함수가있을 수 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값을 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 다른 종류의 반복 에 . 어쩌면 거의 모든 것을 다루는 반복자가 있지만 특별한 경우가 필요합니다. 반복자에서 작동하는 함수가 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">이것은 정확합니다 (명시 적).</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; 와 동일합니다. 이것은 두 가지 이유로 믿을 수 없을만큼 이식성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; 와 동일합니다. 이것은 두 가지 이유로 믿을 수 없을만큼 이식성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">예를 들어 C 코드 계층에 패닉을 전달하기 위해 &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 와 함께 사용하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">이것은 다르다 &lt;code&gt;C&lt;/code&gt; 의 가진 구조체 때문에 표현 &lt;code&gt;C&lt;/code&gt; 의 표현은 항상의 ABI있을 것이다 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;struct&lt;/code&gt; , 예를 들면, 함께 구조체 중에 &lt;code&gt;transparent&lt;/code&gt; 원시적 필드 표현 프리미티브 필드 ABI있을 것이다.</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; , &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; 주어진 유클리드 분할 알고리즘에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">이것은 Rust 컴파일러에 의해 시행됩니다. 그러나이 규칙이 충분히 유연하지 않은 상황이 있습니다. 때로는 객체에 대한 여러 참조가 있어야하지만 여전히 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">이는 &lt;code&gt;padding_needed_for&lt;/code&gt; 의 결과를 레이아웃의 현재 크기 에 추가하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">이것은 &lt;code&gt;self&lt;/code&gt; 를 &lt;code&gt;*const T&lt;/code&gt; 로 캐스팅하는 것과 동일 하지만 더 형식에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">이것은 &lt;code&gt;self&lt;/code&gt; 를 &lt;code&gt;*mut T&lt;/code&gt; 로 캐스팅하는 것과 동일 하지만 더 형식에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">이것은 Unix 플랫폼에서 SIGKILL을 보내는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">이것은을 사용하는 것과 같습니다 &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 있지만, 반복자에 루프 &lt;code&gt;break&lt;/code&gt; 과 &lt;code&gt;continue&lt;/code&gt; 폐쇄에서 가능하지 않습니다. 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 를 사용하는 것이 관용적 이지만 &lt;code&gt;for_each&lt;/code&gt; 는 더 긴 반복자 체인 끝에서 항목을 처리 할 때 더 읽기 쉽습니다 . 경우에 따라 &lt;code&gt;for_each&lt;/code&gt; 는 &lt;code&gt;Chain&lt;/code&gt; 과 같은 어댑터에서 내부 반복을 사용하기 때문에 루프보다 빠를 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">이것은 본질적으로 &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;Iterator::nth()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 . 대부분의 인덱싱 작업과 마찬가지로 개수는 0부터 시작하므로 &lt;code&gt;nth_back(0)&lt;/code&gt; 은 끝에서 첫 번째 값을 반환하고 &lt;code&gt;nth_back(1)&lt;/code&gt; 은 두 번째 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">이것은 본질적으로 &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt; 의 반대 버전입니다 . 대부분의 인덱싱 작업과 마찬가지로 카운트는 0부터 시작하므로 &lt;code&gt;nth_back(0)&lt;/code&gt; 은 끝의 첫 번째 값, &lt;code&gt;nth_back(1)&lt;/code&gt; 의 두 번째 값 등을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">이것은 이전 섹션의 침입 링크 목록이 올바르게 작동해야한다는 보장입니다.</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">컴파일러는 런타임 검사 생략 및 &lt;code&gt;enum&lt;/code&gt; 레이아웃 최적화와 같은 다양한 최적화를 위해 컴파일러를 이용 합니다.</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">이것은 다음과 같이 impl 블록을 선언하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt; 와 같은 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안을 &lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">이것은 확인되지 않은 불변의 수로 인해 매우 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">이것은 변환이 특정 최적화를 방해하기 때문에 정수로 변환하거나 정수에서 변환하는 것을 피하기 위해 본질적으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">이것은 변환이 앨리어싱 정보를 버릴 것이기 때문에 정수로 변환하거나 정수에서 변환하는 것을 피하기 위해 본질적으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">이것은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 의 기본 행동과 대조적입니다 ! 현재 스레드의 스택을 풀고 모든 소멸자를 호출합니다. 때 &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; 설정되어, 하나의 인수로 &lt;code&gt;rustc&lt;/code&gt; 또는 상자의 Cargo.toml에, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;및 &lt;code&gt;abort&lt;/code&gt; 유사하다. 그러나, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;abort&lt;/code&gt; 되지 않는 동안 여전히 &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;공황 고리&lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">콘텐츠를 동기화해야하지만 디스크의 메타 데이터가 필요없는 사용 사례를위한 것입니다. 이 방법의 목표는 디스크 작업을 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">이것은 무손실입니다. 결과 문자열에서 &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;OsStrExt::encode_wide&lt;/code&gt; &lt;/a&gt; 를 호출 하면 항상 원래 코드 단위가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">이는 손실이 없습니다. 결과 문자열에서 &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 를 호출 하면 항상 원래 코드 단위가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">전화 : 이것은 손실이 &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;encode_wide&lt;/code&gt; 결과에 원래의 코드 단위를 얻을 것입니다. 인코딩은 최종 널 종료자를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">이것은 무손실입니다. &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsStringExt::from_wide&lt;/code&gt; &lt;/a&gt; 호출 한 다음 결과에 대해 &lt;code&gt;encode_wide&lt;/code&gt; 를 호출 하면 원래 코드 단위가 생성됩니다. 인코딩은 최종 null 종결자를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">이것은 오류에만 관심 이있는 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; 로 수집과 같은 상위 레벨 추상화와 결합 할 때 더 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">이것은 현재 지원되지 않습니다. &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; 으로 정의되어야합니다 . 괄호는 현재 &lt;code&gt;Fn&lt;/code&gt; 계열 특성에 대한 매개 변수를 정의 할 때 일반 유형에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">원시 포인터를 사용하여 데이터 구조를 빌드 할 때 사용하는 것이 올바른 경우가 많지만 추가 특성으로 인해 사용하는 것이 더 위험합니다. &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 사용 해야하는지 확실하지 않으면 &lt;code&gt;*mut T&lt;/code&gt; 만 사용하십시오 !</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">이 이유 녹 바이너리 가지고 간단 제공하는 프로젝트 중 하나입니다 &lt;em&gt;SRC / main.rs&lt;/em&gt; 파일이 호출 논리를 그의 삶 &lt;em&gt;SRC / lib.rs의&lt;/em&gt; 파일. 그 구조를 사용하여 통합 테스트는 &lt;em&gt;수&lt;/em&gt; 와 라이브러리 상자를 테스트 &lt;code&gt;use&lt;/code&gt; 중요한 기능을 사용할 수 있도록. 중요한 기능이 작동하면 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 의 소량의 코드 도 잘 작동하며 소량의 코드는 테스트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">유닉스 플랫폼에서만 사용할 수 있으며 메소드를 호출하려면 가져와야합니다. Windows 플랫폼에는 해당 &lt;code&gt;AsRawHandle&lt;/code&gt; 및 &lt;code&gt;AsRawSocket&lt;/code&gt; 특성 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이것은 iterator에 끝이있는 경우에만 가능하므로 &lt;code&gt;rev()&lt;/code&gt; 는 &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">다음과 같은 경우에 최적입니다.</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="translated">이는 주로 두 속성 간의 ABI 비 호환성 때문입니다. 이에 대한 자세한 내용과 기타 제한 사항 은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">이것은 순전히 최적화 힌트이며 보수적으로 구현 될 수 있습니다 . 실제로 삭제하지 않아도되는 유형에 대해서는 &lt;code&gt;true&lt;/code&gt; 를 반환 할 수 있습니다. 따라서 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 하면이 함수의 유효한 구현이됩니다. 그러나이 함수가 실제로 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;T&lt;/code&gt; 를 떨어 뜨리면 부작용이 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 메소드 또는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 프로세스 의 &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt; 메소드에 의해 결과로 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">공유 참조에서 벗어날 수 없기 때문에 안전합니다. 문제는 내부 가변성 여기가 것처럼 보일 수 있습니다 : 사실, &lt;em&gt;이다&lt;/em&gt; 이동 할 수 &lt;code&gt;T&lt;/code&gt; 를 에서 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . 그러나 동일한 데이터를 가리키는 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 없고 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하면 해당 내용에 대한 고정 된 참조를 만들 수없는 한 문제가되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;투영 고정&quot;&lt;/a&gt; 에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">값으로 &lt;code&gt;self&lt;/code&gt; 를 전달 하면 다른 스레드가 원자 데이터에 동시에 액세스하지 못 하므로 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">변경 가능한 참조는 다른 스레드가 원자 데이터에 동시에 액세스하지 않도록하기 때문에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 절대 끝나지 않는 &lt;code&gt;'static&lt;/code&gt; 수명 ' 동안 빌리기 때문에 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">이것은 의미 적으로 &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 를 호출 하고 결과를 버리는 것과 동일 하지만 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">이것은 의미 적으로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 를 호출 하고 결과를 버리는 것과 동일 하지만 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;뮤텍스&lt;/a&gt; 를 이용한 중독과 유사하다 .</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;wake&lt;/code&gt; 와 비슷 하지만 소유 한 &lt;code&gt;Waker&lt;/code&gt; 를 사용할 수 있는 경우 약간 덜 효율적일 수 있습니다. 이 메소드는 &lt;code&gt;waker.clone().wake()&lt;/code&gt; 를 호출하는 것보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">이것은 전체 &lt;code&gt;String&lt;/code&gt; 참조 하지만 여분의 &lt;code&gt;[0..5]&lt;/code&gt; 비트 를 갖는 것과 유사합니다 . 전체 &lt;code&gt;String&lt;/code&gt; 에 대한 참조가 아니라 &lt;code&gt;String&lt;/code&gt; 의 일부에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">이것은 두 번째 하위 오류와 비슷하지만 미묘합니다. 다음과 같은 상황에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 단순히 이전의 특별한 경우이지만 일반적인 경우입니다. 변경 불가능한 것으로 보이는 조작에 대해 변경 가능한 숨기기. &lt;code&gt;clone&lt;/code&gt; 방법은 소스 값을 변경할 것으로 예상되며, 취할 선언 &lt;code&gt;&amp;amp;self&lt;/code&gt; ,하지 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; . 따라서 &lt;code&gt;clone&lt;/code&gt; 방법 에서 발생하는 모든 돌연변이는 세포 유형을 사용해야합니다. 예를 들어, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 내에서 참조 횟수를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">이것은 때때로 FFI의 일부로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">이것은 Linux에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">이것은 유닉스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">이것은 Windows에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">이것은 Listing 10-22에서 &lt;code&gt;longest&lt;/code&gt; 함수로, 두 문자열 슬라이스 중 더 긴 문자열을 반환합니다. 그러나 이제 일반 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;ann&lt;/code&gt; 이라는 추가 매개 변수 가 있으며 , &lt;code&gt;where&lt;/code&gt; 절에 지정된대로 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형으로 채울 수 있습니다 . 이 추가 매개 변수는 함수가 문자열 슬라이스의 길이를 비교하기 전에 인쇄되므로 &lt;code&gt;Display&lt;/code&gt; 특성 제한이 필요한 이유 입니다. 수명은 제네릭 형식이므로 수명 매개 변수 &lt;code&gt;'a&lt;/code&gt; 와 제네릭 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 의 선언은 함수 이름 뒤에 꺾쇠 괄호 안에있는 동일한 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">구조체 필드에 사용되는 정렬입니다. 선호하는 정렬보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; 와 동등한 일반 const 입니다.</target>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">이것은 올바른 구문입니다.</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="translated">이것은 &lt;code&gt;1.0&lt;/code&gt; 과 다음으로 큰 표현 가능한 숫자의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">이것은 &lt;code&gt;1.0&lt;/code&gt; 과 다음으로 가장 큰 표현 가능한 숫자의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">이것이 Rust의 안전 원칙의 첫 번째 예입니다. 많은 저수준 언어에서 이러한 종류의 검사는 수행되지 않으며 잘못된 인덱스를 제공하면 유효하지 않은 메모리에 액세스 할 수 있습니다. Rust는 메모리 액세스를 허용하고 계속하는 대신 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9 장에서는 Rust의 오류 처리에 대해 더 설명합니다.</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 주요 반복자 특성입니다. 반복자의 개념에 대한 자세한 내용은 &lt;a href=&quot;index&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오 . 특히, &lt;a href=&quot;index#implementing-iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 구현 방법을 알고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 당황하지 않는 대안 입니다. 동등한 인덱싱 작업이 패닉 될 때마다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 당황하지 않는 대안 입니다. 동등한 색인 작업이 패닉 상태가 될 때마다 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 당황스럽지 않은 &lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 당황하지 않은 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;Iterator::fold()&lt;/code&gt; &lt;/a&gt; 의 반대 버전입니다. 반복기 의 뒤에서 시작하는 요소를받습니다.</target>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복자의 뒤에서 시작하는 요소를 취합니다.</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다.</target>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 . 그것은 반복자의 뒤에서 시작하는 요소를 취합니다.</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;==&lt;/code&gt; 연산자 를 사용하는 것과 동일 하지만 덜 일반적입니다. 인수는 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현하는 것이 아니라 &lt;code&gt;*const T&lt;/code&gt; 원시 포인터 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 확인되지 않은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">메소드의 수신자 유형을 전달할 수 있는지 확인하기 위해 오브젝트 안전에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">이것은 프로그래머가 스레드가 한동안 아무 것도 할 일이 없다는 것을 알고 컴퓨팅 시간 낭비를 피할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">이것은 컴파일러가 일부 코드에 도달 할 수 없다고 판단 할 수 없을 때 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">이것은 유용합니다</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">이는 수신기에서 차단을 결정하기 전에 &quot;낙관적 검사&quot;의 특징에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">이것은 &lt;code&gt;Vec::new&lt;/code&gt; 처럼 지연 할당하는 타입을 초기화하는데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">이것은 원래 반복자의 소유권을 계속 유지하면서 반복자 어댑터를 적용 할 수 있도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="translated">이는 예를 들어 원시 파일 설명자를 C 코드로 전송하여 기본 리소스의 소유권이 이전에 Rust 외부의 코드로 전송되었을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">이것은 사소하게 성공할 수 있지만 특별한 처리가 필요할 수도있는 유형 변환을 수행 할 때 유용합니다. 예를 들어 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 를 사용하여 i64 를 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 로 변환 할 수있는 방법이 없습니다 . &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 가 나타낼 수없는 값이 포함될 수 있으므로 변환에서 데이터가 손실 될 수 있기 때문 입니다. 이것은 &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 로&lt;/a&gt;자르거나 (본질적으로 &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 의 값 모듈로 &lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; ) 또는 단순히 &lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; 를 반환 하거나 다른 방법으로 처리 할 수 ​​있습니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 특성은, 완벽한 전환을위한 소위되어 &lt;code&gt;TryFrom&lt;/code&gt; 특성은 프로그래머에게 유형 변환이 잘못 될 수 있음을 알리고 처리 방법을 결정할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">사소하게 성공할 수도 있지만 특수 처리가 필요할 수도있는 유형 변환을 수행 할 때 유용합니다. 예를 들어, 변환 할 수있는 방법이 없습니다 &lt;code&gt;i64&lt;/code&gt; 로 &lt;code&gt;i32&lt;/code&gt; 를 사용 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 때문에, 특성 &lt;code&gt;i64&lt;/code&gt; 하는 값이 포함될 수 있습니다 &lt;code&gt;i32&lt;/code&gt; 변환이 데이터를 잃을 수 있도록 표현하고 할 수 있습니다. 이것은 &lt;code&gt;i64&lt;/code&gt; 를 &lt;code&gt;i32&lt;/code&gt; 로자르거나 (필수적으로 &lt;code&gt;i64&lt;/code&gt; 의 값 modulo &lt;code&gt;i32::MAX&lt;/code&gt; ) 또는 단순히 &lt;code&gt;i32::MAX&lt;/code&gt; 를 반환 하거나 다른 방법으로 처리 할 수 ​​있습니다. &lt;code&gt;From&lt;/code&gt; 특성은, 완벽한 전환을위한 소위되어 &lt;code&gt;TryFrom&lt;/code&gt; trait는 프로그래머에게 타입 변환이 나빠질 때 알려주고 처리 방법을 결정할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">이터레이터의 이터레이터 또는 이터레이터로 변환 될 수있는 것들의 이터레이터가 있고 한 레벨의 간접적 인 제거를 원할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">당신의 반복자가있을 때 유용 &lt;code&gt;&amp;amp;T&lt;/code&gt; ,하지만 당신은 반복자 필요 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 항목 목록을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 맵을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 항목 집합을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 구조체를 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 튜플을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; es&lt;/a&gt; 는 잠금 장치를 잡고있는 동안 스레드 패닉이 발생하면 이미 중독 되기 때문에 일반적으로 안전한 코드를 작성할 때는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">일반적으로 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 와 동일 합니다. 그러나 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;에&lt;/em&gt; 정적으로 알려진 크기, 예를 들어 슬라이스 &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;특성 객체&lt;/a&gt; 가없는 경우 &lt;code&gt;size_of_val&lt;/code&gt; 을 사용하여 동적으로 알려진 크기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">이것은 표준 라이브러리에있는 정확한 서명이 아닙니다. 표준 라이브러리에서 &lt;code&gt;add&lt;/code&gt; 는 제네릭을 사용하여 정의됩니다. 여기서는 일반적인 타입으로 대체 된 구체적인 타입을 가진 &lt;code&gt;add&lt;/code&gt; 의 시그니처를보고 있는데, 이것은 &lt;code&gt;String&lt;/code&gt; 값 으로이 메소드를 호출 할 때 발생 합니다. 10 장에서 제네릭에 대해 논의 할 것입니다.이 서명은 &lt;code&gt;+&lt;/code&gt; 연산자 의 까다로운 비트를 이해하는 데 필요한 단서를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">이 책에서 동시성에 대해 마지막으로 볼 수있는 것은 아닙니다. 20 장의 프로젝트는 여기에서 논의 된 작은 예제보다 더 현실적인 상황에서이 장의 개념을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">이것은 허용되지 않지만 특성을 사용하여 메소드를 구현하는 것이 좋습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="translated">이것은 일반적으로 원하는 방법이 아닙니다. 이러한 주소는 일반적으로 최신 시스템에서 작동하지 않습니다. 대신 &lt;code&gt;to_ipv6_mapped&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">이 문제는 두 번째 문제와도 관련이 있습니다. &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;filename&lt;/code&gt; 은 프로그램의 구성 변수 이지만 &lt;code&gt;contents&lt;/code&gt; 과 같은 변수 는 프로그램의 논리를 수행하는 데 사용됩니다. &lt;code&gt;main&lt;/code&gt; 이 길어질 수록 범위에 더 많은 변수를 가져와야합니다. 범위에있는 변수가 많을수록 각각의 목적을 추적하기가 더 어려워집니다. 구성 변수를 하나의 구조로 그룹화하여 목적을 명확하게하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">이 반복자입니다 &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;융합&lt;/a&gt; 만의 특정 값 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 반복이 완료된 후에는 &lt;strong&gt;지정되지 않은&lt;/strong&gt; 그 이외의 &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; 더 이상 값이 생성되지 않습니다 번.</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt; 이지만 반복이 완료된 후 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 의 특정 값 은 &lt;strong&gt;지정되지&lt;/strong&gt; 않습니다. 그 &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; 가 더 이상 값이 생성되지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">이 반복자는 이 모듈 의 &lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt; 함수 에서 반환되며 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; 를&lt;/a&gt; 통해 항목의 경로 및 기타 메타 데이터와 같은 정보를 학습 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메시지가 호출 될 때마다 차단 되고 새 메시지를 기다리며 해당 채널이 중단되면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 이 호출 될 때마다 차단 되고 새 메시지를 기다리며 해당 채널이 중단되면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 반복기는 데이터를 사용할 수있을 때까지 호출자를 차단하지 않습니다. 대신 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">이 반복자는 슬라이스의 요소에 대해 변경 가능한 참조를 생성하므로 슬라이스의 요소 유형은 &lt;code&gt;i32&lt;/code&gt; 이고 반복자의 요소 유형은 &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 키는 대상 플랫폼에 대해 가장 빠른 구현을 사용합니다. &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; 로 인스턴스화됩니다 ! 매크로와 기본 방법은 &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">이러한 종류의 재정렬은 CPU에 의해 투명하게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">이러한 종류의 문자열 &lt;em&gt;은 변경&lt;/em&gt; 될 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">이 마지막 예제는 마침표로 끝나는 부동 소수점 리터럴과 함께 접미어 구문을 사용할 수 없기 때문에 다릅니다. &lt;code&gt;2.f64&lt;/code&gt; 는 방법이라는 호출을 시도 할 &lt;code&gt;f64&lt;/code&gt; 에 &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 grapheme이 아닌 바이트 단위 입니다. 다시 말해, 인간이 줄의 길이를 고려하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 바이트,하지에 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s 또는 제자. 즉, 인간이 현의 길이를 고려하는 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 grapheme이 아닌 바이트 단위 입니다. 다시 말해, 인간이 줄의 길이를 고려하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 바이트,하지에 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s 또는 제자. 즉, 인간이 현의 길이를 고려하는 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">이 제한은 이후 버전의 Rust에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">Rust가 배열 유형의 크기보다 일반적인 코드를 아직 지원하지 않기 때문에 크기 &lt;code&gt;N&lt;/code&gt; 에 대한 이러한 제한이 존재합니다. &lt;code&gt;[Foo; 3]&lt;/code&gt; 및 &lt;code&gt;[Bar; 3]&lt;/code&gt; 은 동일한 제네릭 형식 &lt;code&gt;[T; 3]&lt;/code&gt; 이지만 &lt;code&gt;[Foo; 3]&lt;/code&gt; 및 &lt;code&gt;[Foo; 5]&lt;/code&gt; 는 완전히 다른 유형입니다. 스탑 갭으로서, 특성 구현은 정적으로 32까지 정적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">이 줄은 &lt;code&gt;std::io&lt;/code&gt; 및 &lt;code&gt;std::io::Write&lt;/code&gt; 를 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">이 줄은 &lt;code&gt;s&lt;/code&gt; 라는 빈 문자열을 새로 만들어 데이터를로드 할 수 있습니다. 종종 문자열을 시작하려는 초기 데이터가 있습니다. 이를 위해 &lt;code&gt;to_string&lt;/code&gt; 메소드를 사용합니다 .이 메소드는 문자열 리터럴처럼 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형에서 사용할 수 있습니다 . 목록 8-12는 두 가지 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">이 행은 &lt;code&gt;foo&lt;/code&gt; 라는 새 변수를 작성하고 이를 &lt;code&gt;bar&lt;/code&gt; 변수 의 값에 바인드합니다 . Rust에서 변수는 기본적으로 불변입니다. 이 개념에 &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;대해서는&lt;/a&gt; 3 장의 &quot;변수 및 변경 가능성&quot; 섹션 에서 자세히 설명합니다 . 다음 예제는 변수 이름 앞에 &lt;code&gt;mut&lt;/code&gt; 를 사용 하여 변수를 변경 가능하게 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="translated">이 줄은이 작은 프로그램의 모든 작업을 수행합니다. 텍스트를 화면에 인쇄합니다. 여기서 주목해야 할 4 가지 중요한 세부 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">이 줄은이 작은 프로그램의 모든 작업을 수행합니다. 화면에 텍스트를 인쇄합니다. 여기에 주목해야 할 네 가지 중요한 세부 사항이 있습니다. 먼저, 녹 스타일은 탭이 아닌 네 개의 공백으로 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">이 줄은 사용자의 입력을 저장 한 문자열을 인쇄합니다. 중괄호 &lt;code&gt;{}&lt;/code&gt; 는 자리 표시 자입니다. &lt;code&gt;{}&lt;/code&gt; 는 값을 유지하는 작은 게 집게로 생각하십시오 . 중괄호를 사용하여 둘 이상의 값을 인쇄 할 수 있습니다. 첫 번째 중괄호 세트는 형식 문자열 뒤에 나열된 첫 번째 값을 보유하고 두 번째 세트는 두 번째 값을 보유합니다. 한 번의 호출로 &lt;code&gt;println!&lt;/code&gt; 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">이 목록은 시간이 지남에 따라 증가하기위한 것이며 철저하게 일치시키는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">이 긴 형식은 이전 섹션의 예와 동일하지만 더 장황합니다. 콜론과 꺾쇠 괄호 뒤에 generic 형식 매개 변수를 선언하여 특성 경계를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">이것은 이전 코드와 매우 비슷해 보이므로 작동 방식이 동일하다고 가정 할 수 있습니다. 즉, 두 번째 줄은 &lt;code&gt;s1&lt;/code&gt; 의 값을 복사 하여 &lt;code&gt;s2&lt;/code&gt; 에 바인딩합니다 . 그러나 이것은 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 형식 문자열, 인수 목록 및 '작성기'를 허용합니다. 인수는 지정된 형식 문자열에 따라 형식이 지정되고 결과가 작성기에 전달됩니다. writer는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드를 사용하는 모든 값이 될 수 있습니다 . 일반적으로 이것은 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성 의 구현에서 비롯됩니다 . 매크로는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드가 반환하는 모든 것을 반환합니다. 일반적으로 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 형식 문자열, 인수 목록 및 '작성자'를 허용합니다. 인수는 지정된 형식 문자열에 따라 형식이 지정되고 결과는 작성기에 전달됩니다. 기록기는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드를 사용하는 임의의 값일 수 있습니다 . 일반적으로 이것은 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt; 특성 의 구현에서 비롯됩니다 . 매크로는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드가 리턴하는 모든 것을 리턴합니다. 일반적으로 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">이 매크로 는 전달 된 각 추가 인수에 대해 &lt;code&gt;{}&lt;/code&gt; 를 포함하는 형식화 문자열 리터럴을 사용하여 작동합니다 . &lt;code&gt;format_args!&lt;/code&gt; 출력이 문자열로 해석 될 수 있도록 추가 매개 변수를 준비하고 인수를 단일 유형으로 정규화합니다. &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성 을 구현하는 모든 값 을 &lt;code&gt;format_args!&lt;/code&gt; 전달할 수 있습니다 ! 형식화 문자열 내에서 모든 &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 구현을 &lt;code&gt;{:?}&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">이 매크로는 두 번째 형식으로, 사용자 정의 패닉 메시지를 형식화를위한 인수와 함께 또는 인수없이 제공 할 수 있습니다. 이 양식의 구문 은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">이 매크로에는 두 번째 형식이 있습니다. 여기서 사용자 지정 패닉 메시지는 형식 지정 인수를 포함하거나 포함하지 않고 제공 할 수 있습니다. 이 양식의 구문 은 &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">이 매크로는 표준 라이브러리에 제공되며 지정된 CPU 기능이 감지되는지 런타임에 감지합니다. 지정된 기능이 전체 상자에서 이미 활성화되어 있지 않으면 컴파일 타임에 해결 되지 &lt;strong&gt;않습니다&lt;/strong&gt; . 런타임 감지는 현재 대부분 &lt;code&gt;cpuid&lt;/code&gt; 명령어 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="translated">이 매크로는 예제 코드와 테스트에서 조건을 주장하는 완벽한 방법입니다. &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 열거 형 의 &lt;code&gt;unwrap&lt;/code&gt; 메서드 와 밀접하게 연결되어 있습니다. 두 구현 모두 &lt;code&gt;panic!&lt;/code&gt; 호출합니다 ! &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 변형으로 설정된 경우 .</target>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">이 매크로는 예제 코드와 테스트에서 조건을 확인하는 완벽한 방법입니다. &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 열거 형 의 &lt;code&gt;unwrap&lt;/code&gt; 메소드 와 밀접하게 연결되어 있습니다. 두 가지 구현 모두 &lt;code&gt;panic!&lt;/code&gt; None 또는 Err 변형으로 설정된 경우</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">이 매크로는 Rust 스레드에 패닉을 주입하여 스레드를 완전히 패닉 상태로 만드는 데 사용됩니다. 각 스레드의 패닉은 &lt;a href=&quot;boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;any/trait.any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 유형과 &lt;code&gt;panic!&lt;/code&gt; 의 단일 인수 형식으로 거둘 수 있습니다! 매크로는 전송되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">이 매크로는 패닉을 Rust 스레드에 주입하여 스레드가 완전히 패닉되도록하는 데 사용됩니다. 각 스레드의 패닉은 &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; 유형과 단일 인수 형태의 &lt;code&gt;panic!&lt;/code&gt; 매크로는 전송되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 테스트 할 기능의 문자열 리터럴 인 하나의 인수 만 사용합니다. 지원되는 기능 이름은 &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;설명서&lt;/a&gt; 에서 인텔이 정의한 소문자 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성합니다 . 이 값은 유용한 리디렉션을 수행하기 위해 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 내의 매크로에 전달 될 수 있습니다 . 다른 모든 형식의 매크로 ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 등)이 하나를 통해 프락시된다. &lt;code&gt;format_args!&lt;/code&gt; 파생 매크로와 달리 힙 할당을 피합니다.</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성합니다 . 이 값은 유용한 리디렉션을 수행하기 위해 &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 내의 매크로에 전달 될 수 있습니다 . 다른 모든 형식의 매크로 ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 등)이 하나를 통해 프락시된다. &lt;code&gt;format_args!&lt;/code&gt; 는 파생 된 매크로와 달리 힙 할당을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="translated">이 매크로는 크레이트가 잘못된 조건에 대해 더 나은 오류 메시지를 제공하기 위해 조건부 컴파일 전략을 사용할 때 사용해야합니다. 이것은 컴파일러 수준의 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;그러나 &lt;em&gt;런타임이&lt;/em&gt; 아닌 &lt;em&gt;컴파일&lt;/em&gt; 중에 오류가 발생 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">상자에서 조건부 컴파일 전략을 사용하여 잘못된 조건에 대해 더 나은 오류 메시지를 제공 할 때이 매크로를 사용해야합니다. 컴파일러 수준의 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;컴파일 중이 아닌 &lt;em&gt;런타임시&lt;/em&gt; 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">이 매크로는 &lt;code&gt;#[target_feature]&lt;/code&gt; 가 지원하는 것과 동일한 이름을 지원합니다. 그러나 &lt;code&gt;#[target_feature]&lt;/code&gt; 와 달리이 매크로는 쉼표로 구분 된 이름을 지원하지 않습니다. 대신 여러 기능에 대한 테스트는 현재 별도의 매크로 호출을 통해 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">이 매크로는 임의의 수의 쉼표로 구분 된 식별자를 가져 와서 모두 하나로 결합하여 새로운 식별자 인 표현식을 생성합니다. 위생은이 매크로가 지역 변수를 캡처 할 수 없도록합니다. 또한 일반적으로 매크로는 항목, 명령문 또는 표현식 위치에서만 허용됩니다. 즉, 기존 변수, 함수 또는 모듈 등을 참조하기 위해이 매크로를 사용할 수 있지만 새 변수를 정의 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">이 매크로는 임의의 수의 쉼표로 구분 된 리터럴을 사용하여 왼쪽에서 오른쪽으로 연결된 모든 리터럴을 나타내는 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 컴파일 타임에 명명 된 환경 변수의 값으로 확장되어 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">이 매크로는 &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; 파일의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">이 매크로는 파일의 내용 인 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">이 매크로는 매크로에 전달 된 모든 토큰의 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 . 매크로 호출 자체의 구문에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">이 매크로는 그 안에있는 SQL 문을 구문 분석하고 구문 상 올바른지 확인합니다. 이는 &lt;code&gt;macro_rules!&lt;/code&gt; 보다 훨씬 복잡한 처리입니다 ! 매크로가 할 수 있습니다. &lt;code&gt;sql!&lt;/code&gt; 매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">이를 통해 범위의 모든 유형에 특성이 구현됩니다. 따라서 그 후에 다른 것을 구현하려고하면 구현이 충돌합니다. 예:</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">실제로 용량을 늘리지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">이은으로 호출 할 수 &lt;code&gt;Read&lt;/code&gt; 가 전달 버퍼에서 읽을 것이라는 점을 보증 ERS &lt;code&gt;Read&lt;/code&gt; 방법 및 메소드의 반환 값은 정확하게 버퍼의 머리에 기록 된 바이트 수를 반영.</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">함수 본문에 추가 유형 힌트가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 모두 허용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">즉, 외부 상자 참조 &lt;code&gt;implementation::api::f&lt;/code&gt; 는 개인 정보 보호 위반을 수신하지만 경로 &lt;code&gt;api::f&lt;/code&gt; 는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">이것은 아마도 앞의 패턴 중 일부가 너무 일반적이거나,이 패턴이 너무 구체적이거나 순서가 잘못되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">이것은 누군가가 그러한 기능을 지정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">제 문자열의 내용이 상술 한 것을 의미 &lt;em&gt;한다&lt;/em&gt; (A) 내로 맞 &lt;code&gt;char&lt;/code&gt; 동안 제 문자열의 내용은 &lt;em&gt;하지 않을 것이다&lt;/em&gt; . 두 번째 문자열의 내용으로 &lt;code&gt;char&lt;/code&gt; 리터럴 을 만들려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">이것은 피연산자가 이동할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">이것은 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;demo&lt;/code&gt; 의 끝에 도달하면 소멸자는 &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrowed 문자열 데이터에 독점적으로 액세스 할 수 있음을 의미합니다. 해당 문자열 데이터 ( &lt;code&gt;p&lt;/code&gt; ) 의 다른 차용이 &lt;code&gt;s&lt;/code&gt; 의 드롭에 걸쳐 존재 하게하는 것은 &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrows가 참조 된 데이터에 대한 독점적이고 별명으로 액세스 할 수 없다는 원칙을 위반하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="translated">이는 예를 들어 &lt;code&gt;(u8, u16)&lt;/code&gt; 의 패딩 바이트 가 반드시 0이 될 필요는 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">즉, &lt;code&gt;a == b&lt;/code&gt; 및 &lt;code&gt;a != b&lt;/code&gt; 외에 엄격한 역수를 갖는 등호 (모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; ) 는 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">이 방법 자체는 안전하지만 올바르게 사용하려면 특별한주의가 필요합니다. 다른 스레드는이 메소드 호출과 결과 수행 사이를 포함하여 언제든지 강력한 수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">이 방법 자체는 안전하지만 올바르게 사용하려면 특별한주의가 필요합니다. 다른 스레드는이 메소드 호출과 결과 수행 사이를 포함하여 언제든지 약한 수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">이 메소드는 패턴으로 &lt;em&gt;구분&lt;/em&gt; 되지 않고 &lt;em&gt;종료&lt;/em&gt; 되는 문자열 데이터에 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">이 방법을 사용하면 비교를 반대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">이 방법은 벡터가 다른 코드, 특히 FFI를위한 버퍼 역할을하는 상황에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">이 방법은 전체 바이트 슬라이스가 성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">이 메서드는 전체 문자열 조각이 성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지이 메서드는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">이 방법은 채널의 버퍼가 가득 찼거나 수신자가 데이터를 수집하기 위해 대기하지 않는 경우 즉시 리턴 하여 &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 과 다릅니다 . &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 비교할 때이 함수는 하나 대신 두 개의 실패 사례가 있습니다 (하나는 연결 해제, 하나는 전체 버퍼).</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">이 메소드는 원시 파일 디스크립터의 소유권을 호출자에게 전달 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 디스크립터는 원래 오브젝트가 아직 파괴되지 않은 동안에 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">이 메소드는 마이크로 초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 백만 미만).</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">이 메소드는 밀리 초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 1000 미만).</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">이 메소드는 나노초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 10 억 미만).</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="translated">이 메서드는 삽입 된 요소의 순서를 할당하거나 변경하지 않습니다. 가변 슬라이스를 반환하므로 데크를 정렬하거나 이진 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">이 방법은 값을 생성하지 않지만 쓰기가 실패 할 수 있습니다. 오류 사례를 처리하고 다음과 같이 쓰지 &lt;em&gt;않는&lt;/em&gt; 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">이 메서드에는 &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt; &lt;code&gt;ExactSizeIterator::len()&lt;/code&gt; &lt;/a&gt; 사용하는 기본 구현이 있으므로 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">이 메소드에는 &lt;code&gt;self.len()&lt;/code&gt; 사용하는 기본 구현이 있으므로 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">이 메소드에는 기본 구현이 있으므로 일반적으로 직접 구현하지 않아야합니다. 그러나보다 효율적인 구현을 제공 할 수 있다면 그렇게 할 수 있습니다. 예를 들어 &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;특성 수준&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">이 방법은 입력 요소 &lt;code&gt;T&lt;/code&gt; 또는 출력 요소 &lt;code&gt;U&lt;/code&gt; 가 크기가 0 인 경우 아무 목적도 없으며 아무 것도 나누지 않고 원래 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">이 메서드는 값이 범위를 벗어날 때 암시 적으로 호출되며 명시 적으로 호출 할 수 없습니다 (이는 컴파일러 오류 &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt; ). 그러나 전주곡 의 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수의 &lt;code&gt;Drop&lt;/code&gt; 구현 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">이 메소드는 값이 범위를 벗어날 때 내재적으로 호출되며 명시 적으로 호출 할 수 없습니다 (이는 컴파일러 오류 &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040입니다&lt;/a&gt; ). 그러나, prelude 의 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수의 &lt;code&gt;Drop&lt;/code&gt; 구현 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">이 방법은 할당을 피하기 위해 신중하게 구성됩니다. 바이트를 옮길 때 오류가 발생하여 바이트 사본을 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 에서 동일한 이름의 고유 메서드를 사용하기 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">이 방법은 &lt;code&gt;v&lt;/code&gt; 에 0 바이트가 포함되지 않는다는 런타임 어설 션이 없고 실제 바이트 벡터가 필요 하다는 점을 제외하고는 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 와 동등합니다 . Into를 사용하여 변환 할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">이 메서드는 &lt;code&gt;v&lt;/code&gt; 에 0 바이트 가 없다는 런타임 어설 션이 없다는 점을 제외하고는 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt; 동일 하며 Into를 사용하여 변환 할 수있는 것이 아니라 실제 바이트 벡터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">이 방법은 반환 된 중간 슬라이스의 요소와 관련하여 본질적으로 &lt;code&gt;transmute&lt;/code&gt; 이므로 변환식과 관련된 모든 일반적인주의 사항 &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; 도 여기에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 편안한 수명 한계를 제외하고 &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt; 과 동일하므로 안전하지 않습니다. 보다 완전한 문서는 &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">이 방법은 최대 3 개의 탐색 작업을 사용하여 구현됩니다. 이 메소드가 성공적으로 리턴되면 탐색 위치는 변경되지 않습니다 (즉,이 메소드를 호출하기 전의 위치는 이후와 동일 함). 그러나이 메소드가 오류를 리턴하면 탐색 위치는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">이 방법은 주로 값을 떨어 뜨리기위한 것입니다. &lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; 을 사용 하여 값을 수동으로 삭제하는 대신 이 방법을 사용하여 값을 가져와 원하는대로 사용할 수 있습니다. 일반적인 범위 끝 규칙에 따라 반환 된 값에 대해 &lt;code&gt;Drop&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="translated">이 방법은 주로 값을 떨어 뜨리는 데 사용됩니다. &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; 을 사용 하여 값을 수동으로 삭제하는 대신 이 방법을 사용하여 값을 가져와 원하는대로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">이 메소드는 주로 &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 와 인터페이스하는 데 사용됩니다 ! 매크로, 그러나 명시 적으로 호출해야하는 경우는 거의 없습니다. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;대신이 메소드를 호출하기 위해 매크로를 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 안정적이고 사용 가능하지만 안전하지 않아야합니다. 이 문제를 해결하기 위해 안전하지 않은 &lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; 를 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 안정적이고 사용할 수 있지만 안전하지 않습니다. 이 문제를 해결하기 위해 안전하지 않은 &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; 대신 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; 에&lt;/a&gt; 해당하는 const 제네릭입니다 .</target>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; 에&lt;/a&gt; 해당하는 const 제네릭입니다 .</target>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">때문에이 방법은 안전하지 않은 &lt;code&gt;Read&lt;/code&gt; 어 그렇지 않으면 비 제로 반환 할 수 &lt;code&gt;Initializer&lt;/code&gt; 서로 &lt;code&gt;Read&lt;/code&gt; 없이 형 &lt;code&gt;unsafe&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="translated">이 메서드는 고정 된 형식을 사용하는 함수를 여러 번 호출 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법을 사용하려면 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 에서 전달 된 값을 복제 할 수 있어야합니다. 더 많은 유연성이 필요하거나 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 를 사용하려면 &lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드 는 전달 된 값을 복제 할 수 있도록 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 을 구현 해야 합니다. 더 많은 유연성이 필요하거나 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 를 사용하려면 &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt; &lt;code&gt;Vec::resize_with&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">slice가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나지 않으면 이 메서드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 또한 &lt;code&gt;suffix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">이 메서드는 slice가 &lt;code&gt;prefix&lt;/code&gt; 로 시작하지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 합니다 . 또한 &lt;code&gt;prefix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">이 메소드는 [RFC 4291 섹션 2.4]에 의해 예약 된 범위의 주소, 즉 다음 형식의 주소에 대해 &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">이 방법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 섹션 2.5.7에&lt;/a&gt; 따라 사이트 로컬 주소에 대해 &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">이 메소드는 [RFC 4291 섹션 2.4]에 의해 예약 된 범위의 주소, 즉 다음 형식의 주소에 대해 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 섹션 2.5.7에&lt;/a&gt; 따라 사이트 로컬 주소에 대해 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">slice가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나지 않으면 이 메서드는 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 또한 &lt;code&gt;suffix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">이 메서드는 slice가 &lt;code&gt;prefix&lt;/code&gt; 로 시작하지 않으면 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 합니다 . 또한 &lt;code&gt;prefix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">이 메소드는 반복이 완료된 후 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">이 메소드는 일반적으로 수동으로 호출되는 것이 아니라 &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; 통해 호출되어야합니다 ! 매크로 자체.</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">이 방법은 슬라이스를 접두사, 올바르게 정렬 된 새 유형의 중간 슬라이스 및 접미사 슬라이스의 세 가지 개별 슬라이스로 분할합니다. 이 방법은 중간 슬라이스를 주어진 유형과 입력 슬라이스에 대해 가능한 최대 길이로 만들기 위해 최선의 노력을 다하지만 알고리즘의 정확성 만이 아니라 그 성능에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="translated">이 방법은 슬라이스를 접두사, 새 유형의 올바르게 정렬 된 중간 슬라이스 및 접미사 슬라이스의 세 가지 개별 슬라이스로 분할합니다. 이 방법은 중간 슬라이스를 주어진 유형 및 입력 슬라이스에 대해 가능한 최대 길이로 만들 수 있지만 알고리즘의 성능 만이 정확성이 아니라 그것에 의존해야합니다. 모든 입력 데이터가 접두사 또는 접미사 슬라이스로 반환되는 것은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;!=&lt;/code&gt; 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 을 사용하여 모든 푸시에서 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 을 사용하여 푸시 할 때마다 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">이 방법은 클로저를 사용하여 모든 푸시에서 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 특성 을 사용하여 값을 생성 하려는 경우 두 번째 인수로 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">이 방법은 모든 푸시에서 새로운 값을 생성하기 위해 클로저를 사용합니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;Vec::resize&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 트레이 트 를 사용하여 값을 생성하려면 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt; 를 두 번째 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 메서드는 RFC에 정의 된 형식의 유효성을 검사하고 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 과 같은 다음 주소 를 유니 캐스트 링크 로컬 주소로 인식하지 않습니다 . 덜 엄격한 유효성 검사가 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 RFC에 정의 된 형식의 유효성을 검사하고 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 와 같은 다음 주소 를 유니 캐스트 링크 로컬 주소로 인식하지 않습니다 . 덜 엄격한 유효성 검사가 필요한 경우 대신 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 에서 동일한 이름의 고유 메소드를 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="translated">이 방법은 곧 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">이 메소드는 다른 초기화 루틴이 현재 실행중인 경우 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 만날 때까지 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; 를&lt;/a&gt; 반복적으로 호출 하여 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 본 횟수를 반환합니다 . 참고 것을 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 반복자는 어떤 요소가없는 경우에도 한 번에 적어도 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 데이터가 더 이상 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 리턴 될 때까지 쓰기 를 계속 호출 합니다. 이 메소드는 전체 버퍼가 성공적으로 작성되거나 그러한 오류가 발생할 때까지 리턴되지 않습니다. 이 메소드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드는 쓸 데이터가 더 이상 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 리턴 될 때까지 &lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메소드는 전체 버퍼가 성공적으로 작성되거나 그러한 오류가 발생할 때까지 리턴되지 않습니다. 이 메소드에서 생성 된 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드 는 더 이상 쓸 데이터가 없거나 비 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 반환 될 때까지 &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 전체 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메서드 는 더 이상 쓸 데이터가 없거나 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 유형이 아닌 오류 가 반환 될 때까지 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 모든 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메서드 는 더 이상 쓸 데이터가 없거나 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류가 아닌 오류 가 반환 될 때까지 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 전체 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">이 메소드는 현재 항상 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; 을&lt;/a&gt; 리턴 하지만 이후 버전에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 만날 때까지 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;n&lt;/code&gt; 번 호출 하여 n &lt;code&gt;n&lt;/code&gt; 요소를 간절히 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 방법을 사용하면 조건 변수의 현재 웨이터가 해제됩니다. &lt;code&gt;notify_all()&lt;/code&gt; 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 리턴 될 때까지 반복자를 평가합니다 . 그렇게하는 동안 현재 요소를 추적합니다. &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환 된 후 &lt;code&gt;last()&lt;/code&gt; 는 마지막으로 본 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 이&lt;/a&gt; 리턴 될 때까지 반복자를 평가합니다 . 일단 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 발생되지 않으며, &lt;code&gt;count()&lt;/code&gt; 의 수를 반환이라는 시간 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">소켓이 연결되어 있지 않으면이 방법이 실패합니다. &lt;code&gt;connect&lt;/code&gt; 방법은 리모트 주소에 소켓을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">이 메소드는 데이터가 사용 가능할 때까지 호출자를 차단하지 않습니다. 대신 채널에서 보류중인 데이터의 가능한 옵션과 함께 항상 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">이 메소드는 현재 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">결과가 유한, 음수 또는 오버플로 &lt;code&gt;Duration&lt;/code&gt; 이 아닌 경우이 메서드는 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">이 방법은 효율성을 위해 벡터를 복사하지 않도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">이 방법은 &lt;code&gt;key&lt;/code&gt; 와 함께 전체 항목을 미리 알 수 없을 때 사용할 수있는 &lt;code&gt;entry&lt;/code&gt; 의 대안 입니다. 사용 가능한 경우 &lt;code&gt;entry&lt;/code&gt; 방법을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">이 방법은 &lt;code&gt;value&lt;/code&gt; 와 함께 전체 항목을 미리 알 수없는 경우 사용할 수있는 &lt;code&gt;entry&lt;/code&gt; 의 대안 입니다. 사용 가능한 경우 &lt;code&gt;entry&lt;/code&gt; 방법을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">이 모듈은 Rust 프로그램을위한 스레드 로컬 스토리지의 구현도 제공합니다. 스레드 로컬 저장소는 프로그램의 각 스레드가 고유 한 복사본을 갖는 전역 변수에 데이터를 저장하는 방법입니다. 스레드는이 데이터를 공유하지 않으므로 액세스를 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 로컬 파일 시스템의 내용을 조작하는 기본 방법이 포함되어 있습니다. 이 모듈의 모든 메소드는 크로스 플랫폼 파일 시스템 조작을 나타냅니다. 추가 플랫폼 별 기능은 &lt;code&gt;std::os::$platform&lt;/code&gt; 의 확장 특성에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">이 모듈에는 유형의 크기와 정렬을 쿼리하고 메모리를 초기화하고 조작하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">이 모듈에는 환경 변수, 프로세스 인수, 현재 디렉토리 및 기타 중요한 디렉토리와 같은 다양한 측면을 검사하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형, &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; 변환에 대한 특성 및 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 작업으로 인해 발생할 수있는 몇 가지 오류 유형이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 대한 런타임 지원이 포함되어 있습니다 ! 구문 확장. 이 매크로는 컴파일러에서 구현되어 런타임시 인수를 문자열로 형식화하기 위해이 모듈에 대한 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">이 모듈에는 값을 정렬하고 비교하기위한 다양한 도구가 포함되어 있습니다. 요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt; 등을 포함하여 선택된 수의 기본 유형의 원자 버전을 정의합니다 . 원자 유형은 올바르게 사용될 때 스레드 간 업데이트를 동기화하는 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">이 모듈에 대한 기본 문서, 기술적 인 이유로 존재 &lt;code&gt;char&lt;/code&gt; 에 바로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 원시 형 자체.</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Any&lt;/code&gt; 특성을 구현하여 런타임 반영을 통해 모든 &lt;code&gt;'static&lt;/code&gt; 유형을 동적으로 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">이 모듈은 크게 유형별로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">이 모듈은 주로 자식 프로세스의 생성 및 상호 작용과 관련이 있지만 현재 프로세스를 종료하기위한 &lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;char&lt;/code&gt; 에 구현 된 반복자에 대한 반복자 구현 과 다양한 유형을 &lt;code&gt;char&lt;/code&gt; 로 변환하는 유용한 상수 및 변환 함수의 홈입니다 .</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이 모듈 은 현재 지원되는 모든 플랫폼에 노출되는 한 비트의 정보 인 &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;Permissions::readonly&lt;/code&gt; &lt;/a&gt; 만 제공 합니다. 모드 비트와 같은 Unix 관련 기능은 &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; 특성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이 모듈은 현재 현재 지원되는 모든 플랫폼에서 공개되는 1 비트의 정보 인 &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; 만 제공 합니다. 모드 비트와 같은 유닉스 관련 기능은 &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; 특성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 값의 해시를 계산하는 일반적인 방법을 제공합니다. 형식을 해시 가능하게 만드는 가장 간단한 방법은 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f32&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f64&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">이 모듈은 세 가지 유형으로 구체적으로 정의 된 채널을 통한 메시지 기반 통신을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">이 모듈은 IP 및 소켓 주소 유형뿐만 아니라 전송 제어 및 사용자 데이터 그램 프로토콜에 대한 네트워킹 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">이 모듈은 수치 작업을 할 때 유용한 추가 유형을 제공합니다. 자세한 내용은 각 부분에 대한 개별 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">이 모듈은 경로를 추상적으로 사용하기 위해 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; )의 두 가지 유형을 제공합니다 . 이러한 유형은 각각 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 주위의 얇은 래퍼 입니다. 즉, 로컬 플랫폼의 경로 구문에 따라 문자열에서 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">이 모듈은 추상적 인 경로 작업을 위해 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 유사)의 두 가지 유형을 제공합니다 . 이러한 유형은 각각 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 을&lt;/a&gt; 둘러싼 얇은 래퍼 입니다. 즉, 로컬 플랫폼의 경로 구문에 따라 문자열에서 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">이 모듈은 다른 프로그래밍 언어 및 기본 운영 체제와 같이 비 Rust 인터페이스에서 데이터를 처리하는 유틸리티를 제공합니다. C 유사 문자열을 다른 언어와 교환해야하는 FFI (Foreign Function Interface) 바인딩 및 코드에 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="translated">이 모듈은 다른 선언 된 유형에 의해 가려지지 않는 사용을 허용하기 위해 기본 유형을 다시 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">이 뮤텍스는 잠금을 사용할 수있게되기를 기다리는 스레드를 차단합니다. 뮤텍스는 정적으로 초기화되거나 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 생성자 를 통해 생성 될 수도 있습니다 . 각 뮤텍스에는 보호하고있는 데이터를 나타내는 유형 매개 변수가 있습니다. 데이터는 &lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 에서 반환 된 RAII 가드를 통해서만 액세스 할 수 있으며, 뮤텍스가 잠겨있을 때만 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">이 뮤텍스는 잠금을 사용할 수있을 때까지 기다리는 스레드를 차단합니다. 뮤텍스는 정적으로 초기화되거나 &lt;a href=&quot;struct.mutex#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 생성자 를 통해 생성 될 수도 있습니다 . 각 뮤텍스에는 보호중인 데이터를 나타내는 유형 매개 변수가 있습니다. 데이터는 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 에서 반환 된 RAII 가드를 통해서만 액세스 할 수 있으며 , 이는 뮤텍스가 잠겨있을 때만 데이터에 액세스 할 수 있음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">재 할당 할 필요 는 없지만 순환 버퍼가 할당의 시작 부분에 있지 않으면 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 데이터 이동 을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">이것은 다시 할당 할 필요는 없지만 순환 버퍼가 할당의 시작 부분에 있지 않으면 O (n) 데이터 이동을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">이 새로운 슬라이스는 &lt;code&gt;begin&lt;/code&gt; 을 제외한 &lt;code&gt;end&lt;/code&gt; 를 포함하여 &lt;code&gt;begin&lt;/code&gt; 부터 &lt;code&gt;end&lt;/code&gt; 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">다음 예제는 일반 매개 변수에서 수퍼 특성 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">다음 예제 에서는 &lt;code&gt;Shape&lt;/code&gt; 의 &lt;code&gt;area&lt;/code&gt; 함수를 사용하여 &lt;code&gt;radius&lt;/code&gt; 에 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">이 숫자는 하한입니다. &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 더 보유 할 수있을 수도 있지만, 적어도이 많이 보유 할 수 있도록 보장한다.</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">이 숫자는 재 할당을 피하기 위해 &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt; 와 같은 다른 메소드로 전달하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">&lt;code&gt;ForeignTrait2&lt;/code&gt; 에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; 이 바뀌 었다는 점에서 이것은 이전 &lt;code&gt;impl&lt;/code&gt; 과 다릅니다 . 이 예제는 고아 규칙을 위반 하지 &lt;em&gt;않습니다&lt;/em&gt; . 허용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="translated">여기에는 &lt;a href=&quot;struct.command#method.env&quot;&gt; &lt;code&gt;Command::env&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.command#method.envs&quot;&gt; &lt;code&gt;Command::envs&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.command#method.env_remove&quot;&gt; &lt;code&gt;Command::env_remove&lt;/code&gt; &lt;/a&gt; 명시 적으로 설정된 환경 변수 만 포함됩니다 . 하위 프로세스에서 상속 할 환경 변수는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 작업은 파일 시스템을 수정 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 파일 시스템을 수정하려면 &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 작업은 파일 시스템을 수정 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 파일 시스템을 수정하려면 &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;set_permissions&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">이 작업은 &lt;code&gt;O(1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">이 작업을 때때로 '감소'또는 '주입'이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="translated">이 작업은 조정없이 무조건 매핑을 수행합니다. 즉, 변환은 컨텍스트 및 언어와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">이 연산은 0으로 반올림하여 정확한 결과의 일부를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">이 연산은 &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; 충족시킵니다 . 결과는 왼쪽 피연산자와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; (1) 시간과 &lt;em&gt;O&lt;/em&gt; (1) 메모리 에서 계산해야 합니다.</target>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; (1) 시간에 계산되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 시간에 계산해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">이 작업은 O (1) 시간과 O (1) 메모리로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">이 작업은 O (1) 시간으로 계산되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">이 작업은 O (n) 시간으로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">이 작업이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">이 작업은 오버플로로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">이 옵션은 파일이 아직없는 경우 새 파일을 만들지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">이 옵션은 새 파일을 만들지 여부를 나타냅니다. 대상 위치에 파일이 존재하지 않으며 (댕글 링) 심볼릭 링크도 없습니다.</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">이 옵션은 원자 적이기 때문에 유용합니다. 그렇지 않으면 파일이 존재하는지 확인하고 새 파일을 작성하는 사이에 다른 프로세스 (TOCTOU 경쟁 조건 / 공격)에 의해 파일이 작성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 true이면 쓰기가 이전 내용을 덮어 쓰지 않고 파일에 추가됨을 의미합니다. 설정주의 &lt;code&gt;.write(true).append(true)&lt;/code&gt; 만을 설정하는 것과 같은 효과가있다 &lt;code&gt;.append(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션이 true 인 경우 파일을 열면 파일을 &lt;code&gt;read&lt;/code&gt; 수 있어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션은 true 인 경우 파일을 열면 &lt;code&gt;write&lt;/code&gt; 해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">이 순서는로드를 수행 할 수있는 작업에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">이 주문은 상점을 수행 할 수있는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">이 주문은로드와 저장을 모두 결합하는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">이 출력이 더 좋습니다 : 이제 합리적인 오류 메시지가 나타납니다. 그러나 사용자에게 제공하고 싶지 않은 정보도 있습니다. 아마도 우리가 Listing 9-10에서 사용한 기술을 사용하는 것이 여기에 사용하기에 가장 좋은 것은 아닙니다 &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;9 장에서 논의 된 것처럼&lt;/a&gt; 사용 문제보다 프로그래밍 문제에 더 적합합니다 . 대신 9 장에서 배운 다른 기술인 성공 또는 오류를 나타내는 &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">이 결과는 우리가 원하는 것이 아닙니다. 우리는 &lt;code&gt;Dog&lt;/code&gt; 에 구현 한 &lt;code&gt;Animal&lt;/code&gt; 특성의 일부인 &lt;code&gt;baby_name&lt;/code&gt; 함수 를 호출하여 코드를 인쇄 &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; 합니다 . baby dog는 강아지라고합니다 . Listing 19-18에서 사용한 특성 이름을 지정하는 기술은 여기서 도움이되지 않습니다. Listing 19-20의 코드로 &lt;code&gt;main&lt;/code&gt; 을 변경 하면 컴파일 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">이 출력은 &lt;code&gt;cargo test&lt;/code&gt; 에서 &lt;code&gt;add-one&lt;/code&gt; 크레이트에 대한 테스트 만 실행했으며 &lt;code&gt;adder&lt;/code&gt; 크레이트 테스트 는 실행하지 않았 음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">이 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">이것은 고정 된 데이터를 덮어 쓰지만 괜찮습니다. 소멸자가 덮어 쓰기 전에 실행되므로 고정 보장이 위반되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example에&lt;/a&gt; 대한 다음 규칙의 공식 사양을 설명합니다 . 그것들은 원래 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550에&lt;/a&gt; 지정되었으며 ,이 텍스트의 대부분이 복사되고 후속 RFC에서 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;macros-by-example&quot;&gt;예제 별 매크로&lt;/a&gt; 에 대한 다음 규칙의 공식 사양을 문서화합니다 . 원래 는이 텍스트의 대부분이 복사되고 후속 RFC에서 확장되는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt; 에서 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">이 패턴은 Rust 코드 작성 방식에 중대한 영향을 미칩니다. 지금은 단순 해 보일 수 있지만 더 복잡한 상황에서는 여러 변수가 힙에 할당 한 데이터를 사용하도록하려는 경우 코드 동작이 예상치 못한 것일 수 있습니다. 이러한 상황 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">이 패턴은 우려를 분리하는 것에 관한 것입니다 : &lt;em&gt;main.rs&lt;/em&gt; 는 프로그램 실행을 처리하고 &lt;em&gt;lib.rs&lt;/em&gt; 는 작업의 모든 논리를 처리합니다. 당신이 테스트 할 수 없기 때문에 &lt;code&gt;main&lt;/code&gt; 직접 기능을,이 구조는 당신이 함수로 이동하여 프로그램의 로직을 모두 테스트 할 수 있습니다 &lt;em&gt;lib.rs&lt;/em&gt; . &lt;em&gt;main.rs에&lt;/em&gt; 남아있는 유일한 코드는 코드를 읽고 정확성을 확인할 수있을 정도로 작습니다. 이 과정에 따라 프로그램을 재 작업하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">이 패턴은 하위 패턴 중 하나가 반박 가능한 경우 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">이러한 전파 오류 패턴은 Rust에서 매우 일반적이므로 Rust는 물음표 연산자를 제공 &lt;code&gt;?&lt;/code&gt; 이것을 쉽게하기 위해.</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 소문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 대문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">이 Rust 히스토리는 더 결정적인 패턴이 나타나고 컴파일러에 추가 될 수 있기 때문에 관련이 있습니다. 앞으로는 더 적은 수명의 주석이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">다음과 같은 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr에&lt;/a&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">이 유형 은 &lt;code&gt;Bar&lt;/code&gt; 유형 을 사용하려는 특성을 지정하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">이 프로세스는 수신자의 가변성 또는 수명 또는 메소드가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 여부를 고려하지 않습니다 . 메소드를 찾은 후 이러한 이유 중 하나 이상으로 호출 할 수없는 경우 결과는 컴파일러 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">이 프로세스는 소프트웨어를 작성하는 여러 가지 방법 중 하나 일 뿐이지 만 TDD는 코드 설계를 지원할 수 있습니다. 테스트를 통과시키는 코드를 작성하기 전에 테스트를 작성하면 프로세스 전체에서 높은 테스트 범위를 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 오류없이 컴파일되며 &lt;code&gt;s.clear()&lt;/code&gt; 호출 한 후 &lt;code&gt;word&lt;/code&gt; 를 사용하면 컴파일됩니다 . 때문에 &lt;code&gt;word&lt;/code&gt; 의 상태에 연결되어 있지 &lt;code&gt;s&lt;/code&gt; 모든에서, &lt;code&gt;word&lt;/code&gt; 여전히 값 포함 &lt;code&gt;5&lt;/code&gt; . 우리는 그 값을 사용할 수 있습니다 &lt;code&gt;5&lt;/code&gt; 변수와 &lt;code&gt;s&lt;/code&gt; 첫 번째 단어를 추출하려고하지만, 내용 때문에 버그 것 &lt;code&gt;s&lt;/code&gt; 변경되었습니다 우리가 구원 이후 &lt;code&gt;5&lt;/code&gt; 에 &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">이 프로그램은 튜플 &lt;code&gt;x&lt;/code&gt; 를 만든 다음 색인을 사용하여 각 요소에 대해 새 변수를 만듭니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">이 프로그램은 튜플 &lt;code&gt;x&lt;/code&gt; 를 만든 다음 해당 인덱스를 사용하여 각 요소에 대한 새 변수를 만듭니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.</target>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">이 프로그램은 먼저 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;5&lt;/code&gt; 값에 바인딩 합니다. 그런 다음 &lt;code&gt;let x =&lt;/code&gt; 를 반복 하여 원래 값을 취하고 &lt;code&gt;1&lt;/code&gt; 을 추가하여 &lt;code&gt;x&lt;/code&gt; 의 값이 &lt;code&gt;6&lt;/code&gt; 이 되도록하여 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 합니다. 세 번째 &lt;code&gt;let&lt;/code&gt; 문은 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 하여 이전 값에 &lt;code&gt;2&lt;/code&gt; 를 곱하여 &lt;code&gt;x&lt;/code&gt; 에 최종 값 &lt;code&gt;12&lt;/code&gt; 를 제공 합니다. 이 프로그램을 실행하면 다음이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 먼저 튜플을 만들어 변수 &lt;code&gt;tup&lt;/code&gt; 에 바인딩합니다 . 그런 다음 &lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;tup&lt;/code&gt; 패턴을 사용하여 세 개의 개별 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 로 바꿉니다 . 이것은 단일 터플을 세 부분으로 나누기 때문에 &lt;em&gt;destructuring&lt;/em&gt; 이라고 합니다. 마지막으로,이 프로그램의 출력 값 &lt;code&gt;y&lt;/code&gt; 이며, &lt;code&gt;6.4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">이 프로그램에는 가능한 4 가지 경로가 있습니다. 실행 한 후 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">이 프로젝트는 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , 메소드, 관련 함수, 외부 상자 사용 등과 같은 많은 새로운 Rust 개념을 소개하는 실제 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 자세히 설명합니다. 3 장에서는 변수, 데이터 유형 및 함수와 같은 대부분의 프로그래밍 언어가 갖고있는 개념을 다루고 Rust에서이를 사용하는 방법을 보여줍니다. 4 장에서는 Rust를 다른 언어와 차별화하는 기능인 소유권에 대해 설명합니다. 5 장에서는 구조체와 메서드 구문에 대해 설명하고 6 장에서는 열거 형 작동 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="translated">이 속성은 컴파일러에서 확인할 수 없으므로 &lt;code&gt;Eq&lt;/code&gt; 는 &lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; 를&lt;/a&gt; 의미 하며 추가 메서드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">이 속성은 컴파일러에서 확인할 수 없으므로 &lt;code&gt;Eq&lt;/code&gt; 는 &lt;code&gt;PartialEq&lt;/code&gt; 를 암시 하며 추가 메서드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;em&gt;UNIX 네트워크 프로그래밍, 제 2 판&lt;/em&gt; , W. Richard Stevens, p. 891; &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">이 대기열에는 컨테이너의 양쪽 끝에서 &lt;code&gt;O(1)&lt;/code&gt; 상각 삽입 및 제거가 있습니다. 또한 벡터처럼 &lt;code&gt;O(1)&lt;/code&gt; 인덱싱이 있습니다. 포함 된 요소는 복사 할 필요가 없으며 포함 된 유형을 보낼 수있는 경우 큐를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">이 대기열에는 컨테이너의 양쪽 끝에서 &lt;em&gt;O&lt;/em&gt; (1) 개의 상각 된 삽입 및 제거가 있습니다. 또한 벡터와 같은 &lt;em&gt;O&lt;/em&gt; (1) 인덱싱이 있습니다. 포함 된 요소는 복사 가능할 필요가 없으며 포함 된 유형이 전송 가능한 경우 큐를 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">이 독자는 &quot;파일 끝&quot;에 도달하여 더 이상 바이트를 생성 할 수 없습니다. 참고이 독자는 것을 의미하지 않는다는 것을 &lt;em&gt;항상&lt;/em&gt; 더 이상 바이트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">이 재정렬에는 비교 함수를 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같다는 추가 특성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 비교기 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">이 재정렬에는 comparator 함수를 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 제공된 비교기 함수를 사용하여 주어진 인덱스의 값보다 작은 모든 요소, 주어진 인덱스의 값, 주어진 인덱스의 값보다 큰 모든 요소의 세 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">이 재정렬에는 키 추출 기능을 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 키 추출 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">이 재정렬에는 키 추출 기능을 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 제공된 키 추출 함수를 사용하여 주어진 인덱스의 값보다 작은 모든 요소, 지정된 인덱스의 값, 지정된 인덱스의 값보다 큰 모든 요소의 세 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">이 재정렬에는 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 지정된 인덱스의 값보다 작은 모든 요소, 지정된 인덱스의 값 및 지정된 인덱스의 값보다 큰 모든 요소의 트리플렛을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">이 재정렬에는 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 위치의 값이 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 위치의 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 주어진 인덱스에있는 것보다 작은 모든 요소, 주어진 인덱스에있는 값, 주어진 인덱스에있는 것보다 큰 모든 요소의 삼중 항 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">이 표현은 구조체, 공용체 및 열거 형에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="translated">이 표현은 구조체, 공용체 및 열거 형에 적용 할 수 있습니다. 예외는 &lt;code&gt;C&lt;/code&gt; 표현이 오류 인 &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;0 변형 열거 형&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 언핀 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">이를 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 &lt;code&gt;Unpin&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">이 제한은 돌연변이를 허용하지만 매우 통제 된 방식으로 이루어집니다. 대부분의 언어로 원할 때마다 변경할 수 있기 때문에 새로운 Rustaceans가 어려움을 겪고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">이렇게하면 &lt;code&gt;Button&lt;/code&gt; 유형 또는 &lt;code&gt;TextField&lt;/code&gt; 유형의 구성 요소 목록이 있는 &lt;code&gt;Screen&lt;/code&gt; 인스턴스로 제한 됩니다. 동종 컬렉션 만있는 경우에는 정의가 콘크리트 유형을 사용하기 위해 컴파일 타임에 단일화되므로 제네릭 및 특성 경계를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">이 결과는 어설 션이 실패했으며 어설 션이 어느 행에 있는지 나타냅니다. 이 경우 더 유용한 실패 메시지는 &lt;code&gt;greeting&lt;/code&gt; 기능 에서 얻은 값을 인쇄합니다 . 테스트 함수를 변경하여 &lt;code&gt;greeting&lt;/code&gt; 함수 에서 얻은 실제 값으로 자리 표시자가 채워진 형식 문자열로 작성된 사용자 지정 실패 메시지를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">이 반환 유형은 &lt;code&gt;File::open&lt;/code&gt; 대한 호출 이 성공하고 읽거나 쓸 수있는 파일 핸들을 반환 할 수 있음을 의미합니다 . 함수 호출도 실패 할 수 있습니다. 예를 들어 파일이 없거나 파일에 액세스 할 수있는 권한이 없을 수 있습니다. &lt;code&gt;File::open&lt;/code&gt; 기능 요구는 성공 또는 실패와 동시에 우리에게 파일 핸들 또는 오류 정보 중 하나를 제공하는지 여부를 알려 수있는 방법이 있습니다. 이 정보는 &lt;code&gt;Result&lt;/code&gt; 열거 형이 전달 하는 것과 정확히 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="translated">작업 디렉토리가 변경되지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;ThreadId&lt;/code&gt; 로 식별되는 스레드의 숫자 식별자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">이것은 &lt;code&gt;other&lt;/code&gt; 노드의 모든 노드를 재사용하고 &lt;code&gt;self&lt;/code&gt; 로 옮깁니다 . 이 작업 후에 &lt;code&gt;other&lt;/code&gt; 은 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">이 재 작업은 우리의 작은 프로그램에 대해 과도한 것처럼 보일 수 있지만, 우리는 작은 단계적으로 리팩토링하고 있습니다. 이 변경을 수행 한 후 프로그램을 다시 실행하여 인수 구문 분석이 여전히 작동하는지 확인하십시오. 문제가 발생할 때 원인을 식별하는 데 도움이되도록 진행 상황을 자주 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">이 규칙은 const 메소드를 포함하는 impl 블록의 유형 매개 변수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">이 코드는 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 코드를 실행하며 &lt;code&gt;add-one&lt;/code&gt; 상자 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">이 섹션에서는 상자의 컴파일 된 출력의 ABI에 영향을주는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">이 섹션에서는 Rust 런타임의 일부 측면을 정의하는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 에서&lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; 를 호출하여 이전에 얻은 포인터로만 호출해야합니다 . 다른 사용법 (예 : 외래 코드에 의해 할당 된 문자열의 소유권을 얻으려고 시도)은 정의되지 않은 동작 또는 할당 자 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt; &lt;code&gt;CString::into_raw&lt;/code&gt; &lt;/a&gt; 를 호출하여 이전에 얻은 포인터로만 호출되어야합니다 . 다른 사용 (예 : 외부 코드에 의해 할당 된 문자열의 소유권을 얻으려는 시도)은 정의되지 않은 동작 또는 할당 자 손상으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">확장명 이 &lt;em&gt;.rs 인&lt;/em&gt; 소스 코드 파일 , 실행 파일 ( Windows에서는 &lt;em&gt;main.exe&lt;/em&gt; , 다른 모든 플랫폼 에서는 &lt;em&gt;main&lt;/em&gt; ) 및 Windows를 사용할 경우 확장자 가 &lt;em&gt;.pdb 인&lt;/em&gt; 디버깅 정보가 들어있는 파일이 표시 됩니다. 여기에서 &lt;em&gt;main&lt;/em&gt; 또는 &lt;em&gt;main.exe&lt;/em&gt; 파일을 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">이 슬라이스는 &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; 유형 입니다. 첫 번째 요소에 대한 참조와 길이를 저장하여 문자열 슬라이스와 같은 방식으로 작동합니다. 모든 종류의 다른 컬렉션에이 종류의 슬라이스를 사용합니다. 8 장에서 벡터에 대해 이야기 할 때 이러한 컬렉션에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m * n * log(n))&lt;/code&gt; 최악의 경우 키 함수가 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소의 순서를 변경하지 않음) &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; 최악의 경우 키 함수가 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n + n log n)&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n log(m n))&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(n * log(n))&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이런 종류의 (즉, 동일한 요소의 순서를 변경 할 수 있습니다)에 장소 (즉, 할당하지 않습니다) 불안정하고, &lt;code&gt;O(m n log(m n))&lt;/code&gt; 의 핵심 기능은 최악의 경우, &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 불안정하며 (즉, 동일한 요소를 재정렬 할 수 있음), 내부 (즉, 할당하지 않음) 및 &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="translated">이 정렬은 불안정하고 (즉, 동일한 요소를 재정렬 할 수 있음) 제자리에 (즉, 할당하지 않음), &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">이 정렬은 불안정하고 (즉, 동일한 요소를 재정렬 할 수 있음) 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; (m * &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우 키 함수가 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">이러한 종류의 동작은 잘못 사용될 경우 &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;권한 상승&lt;/a&gt; 으로 이어지는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">이 상태는 생성기가 일시 중지되었음을 나타내며 일반적으로 &lt;code&gt;yield&lt;/code&gt; 문에 해당 합니다. 이 변형에 제공된 값은 &lt;code&gt;yield&lt;/code&gt; 전달 된 표현에 해당하며 생성자가 생성 할 때마다 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">이 상태는 생성기가 제공된 값으로 실행을 완료했음을 나타냅니다. 생성기가 &lt;code&gt;Complete&lt;/code&gt; 를 반환하면 다시 &lt;code&gt;resume&lt;/code&gt; 다시 호출하는 프로그래머 오류로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">이 스트림은 무시됩니다. 이것은 스트림을 &lt;code&gt;/dev/null&lt;/code&gt; 에 첨부하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">이 구조체에는 문자열 슬라이스를 보유하는 하나의 필드 &lt;code&gt;part&lt;/code&gt; 가 있으며 이는 참조입니다. 일반 데이터 유형과 마찬가지로 구조체 이름 뒤에 꺾쇠 괄호 안에 일반 수명 매개 변수의 이름을 선언하므로 구조체 정의 본문에서 수명 매개 변수를 사용할 수 있습니다. 이 주석은 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 인스턴스가 &lt;code&gt;part&lt;/code&gt; 필드 에서 보유한 참조보다 오래 지속될 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 구조체는 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 및 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 와 같은 형식과 레이아웃이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 구조체는 &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; 및 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 와 같은 유형과 동일한 레이아웃을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt; &lt;code&gt;Vec::sort_by_key&lt;/code&gt; &lt;/a&gt; 와 같은 함수와 함께 사용되는 도우미 이며 키의 일부를 역순으로 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">이 구조체는 &lt;code&gt;Vec::sort_by_key&lt;/code&gt; 와 같은 함수와 함께 사용할 수있는 도우미 이며 키의 일부를 역순으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;env::args()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;env::args_os()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt; &lt;code&gt;Vec::drain_filter&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;Vec::splice()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 특성에 의해 제공되는 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 메소드로 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc7e6b8159c36d037a08968dd41820bb2c65481" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d0cc773f4b725ed1f190beeb33e3f1817949265" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;repeat()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 호출을 통해 생성됩니다 . 자세한 내용은 &lt;code&gt;repeat()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="24b0eaa40ab28907590f0749ecb8c76a4046ae2e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink()&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc05dce26bdc09f8fc488132c92d5215b0e0bb48" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;sink()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;sink()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6405be6b1dfbc1fabe9afe38ed753782ffca52fa" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a732d552fb11922cbdd232738709d5ceaab3ab0" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;lines()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;lines()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6120cd0b709f995e698179414e725d511642b6c" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57521da9d072a5a75b7ef81a11e1941632c07769" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;split()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;split()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1deb8df82a06cf7e25723eca2d9b3c3500c212f" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 리더에서 &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="137e3be8282a7112c63c8d5b6052cbdcefad663e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 리더에서 &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="047a4ebdecfd5e2897b79c73996497448f62e8a9" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; on reader를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7395af01bd4a50c6dfb48da98c0430b70139ec6" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="45d9e2d1a8753395175acd043fb98b742fa0c7b1" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0e77c1cd6c1d6c1011116ad5fd2720b269732ff" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c78ae69a32ba5f8bbcb17b7abd5cf067694229aa" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c446cff104f615e56344282bb3df53e735cf1fdb" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;env::vars()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;env::vars()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64b2bbf5e29e3f661a1f1f7db6c4d0d2f77172fd" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31822658b6e7064c66c1754cfb13fa7a6a0cb6b1" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;PanicInfo::location()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;PanicInfo::location()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c3b3caed2d7f9ef42e3b6090d38c4f7a8f595c9" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;std::env::split_paths&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;std::env::split_paths&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="763fd05613c0342afc387ef243d7b2fcab0e70ec" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;std::env::vars&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;std::env::vars&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aeb9c6eb7e34424ffff3b1a0d353cc1e7da71bbe" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;std::env::vars_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;std::env::vars_os&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49ca05175d2c16657b8d4f1e47558a6913b20cd1" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 메소드 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a6f95cf45a5bcc128684cebfbd05d3880902f8d" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;struct.panicinfo&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.panicinfo&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;location&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ba43b358d72c0f70633e8ff8edbb3820ba26ae8" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 try_read 메소드로 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="37c48c912f9cb67a5286393a48bcb5981e2a346b" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.rwlock#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 및 try_write 메소드로 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b64e1281a00cf103b0dc5f24e83df69f16eb4c" translate="yes" xml:space="preserve">
          <source>This structure is returned from the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;symlink_metadata&lt;/code&gt;&lt;/a&gt; function or method and represents known metadata about a file such as its permissions, size, modification times, etc.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;metadata&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;symlink_metadata&lt;/code&gt; &lt;/a&gt; 함수 또는 메소드 에서 리턴되며 파일의 권한, 크기, 수정 시간 등과 같은 알려진 메타 데이터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a90c6bba494b412af840afa94f3d4327e4e6ac5c" translate="yes" xml:space="preserve">
          <source>This structure is used to represent and manage child processes. A child process is created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct, which configures the spawning process and can itself be constructed using a builder-style interface.</source>
          <target state="translated">이 구조는 자식 프로세스를 나타내고 관리하는 데 사용됩니다. 자식 프로세스는 &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; 구조체 를 통해 생성되며, 생성 프로세스는 스폰 프로세스를 구성하며 빌더 스타일의 인터페이스를 사용하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21f163fe5401a35062783545bd12a7fe23e7c94b" translate="yes" xml:space="preserve">
          <source>This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</source>
          <target state="translated">이 구조는 안전하게 사전 컴파일 된 형식 문자열 및 인수를 나타냅니다. 안전하게 수행 할 수 없기 때문에 런타임에 생성 할 수 없으므로 생성자가 제공되지 않으며 수정을 막기 위해 필드가 비공개입니다.</target>
        </trans-unit>
        <trans-unit id="0adc11971ab38c810ebf2248ed011aa51008e125" translate="yes" xml:space="preserve">
          <source>This suffers the same restrictions and reasoning as implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, see there for details.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현과 동일한 제한 및 추론을 겪습니다 . 자세한 내용은 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f2d7a21c40fec745cf07aea5a678e00b27d1d6d" translate="yes" xml:space="preserve">
          <source>This sums up every integer in a vector, rejecting the sum if a negative element is encountered:</source>
          <target state="translated">이것은 벡터의 모든 정수를 합산하여 음수 요소가 발생하면 합계를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="3b38ed7b25f08579fef293fd7b9ae8fd73fe03b3" translate="yes" xml:space="preserve">
          <source>This sums up the position of the character 'a' in a vector of strings, if a word did not have the character 'a' the operation returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">문자열 벡터에서 문자 'a'의 위치를 ​​합산합니다. 단어에 문자 'a'가 없으면 연산은 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7b5e0845ef8959eb8d683ea0316747264243c8d" translate="yes" xml:space="preserve">
          <source>This syntax seems comparable to that of generics. So why not just define the &lt;code&gt;Iterator&lt;/code&gt; trait with generics, as shown in Listing 19-13?</source>
          <target state="translated">이 구문은 제네릭의 구문과 비슷합니다. 그렇다면 Listing 19-13에 나와있는 것처럼 제네릭으로 &lt;code&gt;Iterator&lt;/code&gt; 특성을 정의하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2e389d45d6848629d7d0a8141a0d2eefc943d3d3" translate="yes" xml:space="preserve">
          <source>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named &lt;code&gt;Screen&lt;/code&gt; that holds a vector named &lt;code&gt;components&lt;/code&gt;. This vector is of type &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt;, which is a trait object; it&amp;rsquo;s a stand-in for any type inside a &lt;code&gt;Box&lt;/code&gt; that implements the &lt;code&gt;Draw&lt;/code&gt; trait.</source>
          <target state="translated">이 문법은 10 장에서 특성을 정의하는 방법에 대한 논의에서 친숙해 보일 것입니다. 다음은 새로운 구문입니다. Listing 17-4는 &lt;code&gt;components&lt;/code&gt; 라는 벡터를 보유하는 &lt;code&gt;Screen&lt;/code&gt; 이라는 구조체를 정의합니다 . 이 벡터는 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 유형 이며 특성 객체입니다. &lt;code&gt;Draw&lt;/code&gt; 특성 을 구현 하는 &lt;code&gt;Box&lt;/code&gt; 내부의 모든 유형에 대한 스탠드 인입니다.</target>
        </trans-unit>
        <trans-unit id="157ddb41dd66b7335f1aa23c99d8dc3500848966" translate="yes" xml:space="preserve">
          <source>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use &lt;code&gt;MyStruct::X&lt;/code&gt; is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</source>
          <target state="translated">이 구문은 MyStruct에서 구체적으로 만든 것처럼 MyTrait에서 X 유형을 원한다는 것을 지정합니다. &lt;code&gt;MyStruct::X&lt;/code&gt; 단순히 사용할 수없는 이유 는 MyStruct가 동일한 이름의 연관된 유형으로 두 가지 특성을 구현할 수 있기 때문입니다 . 이 구문은 둘 사이의 명확성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6be1eead3ada3953477a6dbe51c912612a272761" translate="yes" xml:space="preserve">
          <source>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model and the single-threaded async I/O model. If you&amp;rsquo;re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</source>
          <target state="translated">이 기술은 웹 서버의 처리량을 향상시키는 여러 가지 방법 중 하나 일뿐입니다. 탐색 할 수있는 다른 옵션은 포크 / 조인 모델 및 단일 스레드 비동기 I / O 모델입니다. 이 주제에 관심이 있다면 다른 솔루션에 대해 자세히 읽고 Rust에서 구현해보십시오. Rust와 같은 저수준 언어로 이러한 모든 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731e8ea356524b34210881afc68de295a0e37bff" translate="yes" xml:space="preserve">
          <source>This technique is pretty neat! By using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we have an outwardly immutable &lt;code&gt;List&lt;/code&gt; value. But we can use the methods on &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it&amp;rsquo;s sometimes worth trading a bit of speed for this flexibility in our data structures.</source>
          <target state="translated">이 기술은 매우 깔끔합니다! &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하면 외부 적으로 변경할 수없는 &lt;code&gt;List&lt;/code&gt; 값이 있습니다. 그러나 내부 변경 가능성에 대한 액세스를 제공 하는 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 메소드를 사용하여 필요할 때 데이터를 수정할 수 있습니다. 차용 규칙의 런타임 검사는 데이터 경쟁으로부터 우리를 보호하며, 데이터 구조에서 이러한 유연성을 위해 약간의 속도로 거래 할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9283a8a2efae9e1f40a1d640e7fbf1f6c7025c52" translate="yes" xml:space="preserve">
          <source>This tells us the return type of the &lt;code&gt;File::open&lt;/code&gt; function is a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in here with the type of the success value, &lt;code&gt;std::fs::File&lt;/code&gt;, which is a file handle. The type of &lt;code&gt;E&lt;/code&gt; used in the error value is &lt;code&gt;std::io::Error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 함수 의 반환 유형은 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 입니다. 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 여기 에서 파일 핸들 인 성공 값의 유형 &lt;code&gt;std::fs::File&lt;/code&gt; 로 채워졌습니다 . 오류 값에 사용 된 &lt;code&gt;E&lt;/code&gt; 의 유형 은 &lt;code&gt;std::io::Error&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1369ebc6a80c7328fbe0b2bd897392d17a8945de" translate="yes" xml:space="preserve">
          <source>This test code defines a &lt;code&gt;MockMessenger&lt;/code&gt; struct that has a &lt;code&gt;sent_messages&lt;/code&gt; field with a &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; values to keep track of the messages it&amp;rsquo;s told to send. We also define an associated function &lt;code&gt;new&lt;/code&gt; to make it convenient to create new &lt;code&gt;MockMessenger&lt;/code&gt; values that start with an empty list of messages. We then implement the &lt;code&gt;Messenger&lt;/code&gt; trait for &lt;code&gt;MockMessenger&lt;/code&gt; so we can give a &lt;code&gt;MockMessenger&lt;/code&gt; to a &lt;code&gt;LimitTracker&lt;/code&gt;. In the definition of the &lt;code&gt;send&lt;/code&gt; method, we take the message passed in as a parameter and store it in the &lt;code&gt;MockMessenger&lt;/code&gt; list of &lt;code&gt;sent_messages&lt;/code&gt;.</source>
          <target state="translated">이 테스트 코드는 &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; 값을 가진 &lt;code&gt;sent_messages&lt;/code&gt; 필드 가 있는 &lt;code&gt;MockMessenger&lt;/code&gt; 구조체를 정의하여 보낸 메시지를 추적합니다. 또한 빈 메시지 목록으로 시작하는 새로운 &lt;code&gt;MockMessenger&lt;/code&gt; 값을 편리하게 만들 수 있도록 관련 함수를 &lt;code&gt;new&lt;/code&gt; 정의했습니다 . 우리는 다음 구현 &lt;code&gt;Messenger&lt;/code&gt; 에 대한 특성 &lt;code&gt;MockMessenger&lt;/code&gt; 을 우리가 제공 할 수 있도록 &lt;code&gt;MockMessenger&lt;/code&gt; 을 A와 &lt;code&gt;LimitTracker&lt;/code&gt; . &lt;code&gt;send&lt;/code&gt; 메소드 의 정의에서 전달 된 메시지를 매개 변수로 가져 &lt;code&gt;MockMessenger&lt;/code&gt; 목록에 저장합니다. &lt;code&gt;sent_messages&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7bdfe2c080bcfbd294561ba32984ed7b6655c2" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Cacher&lt;/code&gt; instance with a closure that returns the value passed into it. We call the &lt;code&gt;value&lt;/code&gt; method on this &lt;code&gt;Cacher&lt;/code&gt; instance with an &lt;code&gt;arg&lt;/code&gt; value of 1 and then an &lt;code&gt;arg&lt;/code&gt; value of 2, and we expect the call to &lt;code&gt;value&lt;/code&gt; with the &lt;code&gt;arg&lt;/code&gt; value of 2 to return 2.</source>
          <target state="translated">이 테스트 는 전달 된 값을 반환하는 클로저를 사용하여 새로운 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스를 만듭니다 . 우리는 전화 &lt;code&gt;value&lt;/code&gt; 이에 대한 방법 &lt;code&gt;Cacher&lt;/code&gt; 의 와 인스턴스를 &lt;code&gt;arg&lt;/code&gt; 1의 값과 다음 &lt;code&gt;arg&lt;/code&gt; 2의 값, 우리는 호출 기대 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;arg&lt;/code&gt; 2를 반환 2의 값입니다.</target>
        </trans-unit>
        <trans-unit id="72299afca54f19e85015cb228f6cdc67fc73f999" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Counter&lt;/code&gt; instance in the &lt;code&gt;counter&lt;/code&gt; variable and then calls &lt;code&gt;next&lt;/code&gt; repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;counter&lt;/code&gt; 변수 에 새 &lt;code&gt;Counter&lt;/code&gt; 인스턴스를 만든 &lt;code&gt;next&lt;/code&gt; 반복적으로 호출 하여이 반복자가 원하는 동작을 구현했는지 확인합니다. 값을 1에서 5로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05dea38628c56d1ac2dee0da9506b8c1998c15fa" translate="yes" xml:space="preserve">
          <source>This test searches for the string &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. The text we&amp;rsquo;re searching is three lines, only one of which contains &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. We assert that the value returned from the &lt;code&gt;search&lt;/code&gt; function contains only the line we expect.</source>
          <target state="translated">이 테스트는 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 문자열을 검색합니다 . 우리가 검색하는 텍스트는 세 줄이며 그중 하나에 만 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;search&lt;/code&gt; 함수 에서 반환 된 값에 예상 한 줄만 포함되어 있다고 주장합니다 .</target>
        </trans-unit>
        <trans-unit id="ddca2fdf5e68d60216a77aaaba507a1415303561" translate="yes" xml:space="preserve">
          <source>This test will pass because the value we put in the &lt;code&gt;should_panic&lt;/code&gt; attribute&amp;rsquo;s &lt;code&gt;expected&lt;/code&gt; parameter is a substring of the message that the &lt;code&gt;Guess::new&lt;/code&gt; function panics with. We could have specified the entire panic message that we expect, which in this case would be &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; What you choose to specify in the expected parameter for &lt;code&gt;should_panic&lt;/code&gt; depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 속성의 &lt;code&gt;expected&lt;/code&gt; 매개 변수에 넣은 값 이 &lt;code&gt;Guess::new&lt;/code&gt; 함수가 패닉 하는 메시지의 하위 문자열 이기 때문에이 테스트는 통과합니다 . 예상되는 전체 패닉 메시지를 지정할 수 있습니다.이 경우 &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; 을 &lt;code&gt;should_panic&lt;/code&gt; 합니다. should_panic 에 대해 예상되는 매개 변수에서 지정 하는 것은 패닉의 양에 따라 다릅니다. 메시지는 독특하거나 역동적이며 테스트의 정확성을 원합니다. 이 경우 패닉 메시지의 하위 문자열로 테스트 함수의 코드가 &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; 경우 else를 실행하기에 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="bbe227be9e7db744874fde49a6fb7f9f9cde2ed8" translate="yes" xml:space="preserve">
          <source>This text is available in &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;paperback and ebook format from No Starch Press&lt;/a&gt;.</source>
          <target state="translated">이 텍스트는 &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;No Starch Press의 페이퍼 백 및 전자 책 형식으로 제공됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abaa655d972948c0991360be1b3331d77edb5df2" translate="yes" xml:space="preserve">
          <source>This time when we compile the code, we get a different set of errors:</source>
          <target state="translated">이번에는 코드를 컴파일 할 때 다른 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ef45f877ddb3c6c79878e62a645c0f1bb5d754ab" translate="yes" xml:space="preserve">
          <source>This time when we run the &lt;code&gt;should_panic&lt;/code&gt; test, it will fail:</source>
          <target state="translated">이번에는 &lt;code&gt;should_panic&lt;/code&gt; 테스트를 실행 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="927ffba8c6b861ab1b3ffedb0e60fa4989110409" translate="yes" xml:space="preserve">
          <source>This time, before we create the first spawned thread, we call &lt;code&gt;clone&lt;/code&gt; on the sending end of the channel. This will give us a new sending handle we can pass to the first spawned thread. We pass the original sending end of the channel to a second spawned thread. This gives us two threads, each sending different messages to the receiving end of the channel.</source>
          <target state="translated">이번에는 첫 번째 생성 된 스레드를 만들기 전에 채널의 전송 끝에서 &lt;code&gt;clone&lt;/code&gt; 을 호출 합니다. 그러면 생성 된 첫 번째 스레드에 전달할 수있는 새로운 전송 핸들이 제공됩니다. 채널의 원래 전송 끝을 두 번째 생성 스레드로 전달합니다. 이것은 우리에게 두 개의 쓰레드를 제공하는데, 각각의 쓰레드는 서로 다른 메시지를 채널의 수신단에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="03b02e99d0c7b36f56fe77cf1bc6781836989a07" translate="yes" xml:space="preserve">
          <source>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the &lt;code&gt;thread::sleep&lt;/code&gt; function with a &lt;code&gt;Duration&lt;/code&gt; value of 1 second.</source>
          <target state="translated">이번에는 스폰 된 쓰레드에 메인 쓰레드로 보내려는 문자열 벡터가 있습니다. 우리는 그것들을 반복하여 각각 개별적으로 보내고 , &lt;code&gt;Duration&lt;/code&gt; 값을 1 초로 &lt;code&gt;thread::sleep&lt;/code&gt; 함수를 호출하여 각각을 일시 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="704e60202fcb30892563c7bc7f66fbb6decda49f" translate="yes" xml:space="preserve">
          <source>This trait allows constructing network objects like &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.udpsocket&quot;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; easily with values of various types for the bind/connection address. It is needed because sometimes one type is more appropriate than the other: for simple uses a string like &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; is much nicer than manual construction of the corresponding &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, but sometimes &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; value is &lt;em&gt;the&lt;/em&gt; main source of the address, and converting it to some other type (e.g., a string) just for it to be converted back to &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; in constructor methods is pointless.</source>
          <target state="translated">이 특성은 바인드 / 연결 주소에 대한 다양한 유형의 값으로 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.udpsocket&quot;&gt; &lt;code&gt;UdpSocket&lt;/code&gt; &lt;/a&gt; 과 같은 네트워크 오브젝트를 쉽게 구성 할 수있게 합니다. 때로는 하나의 유형이 다른 유형보다 더 적합하기 때문에 필요합니다. 단순 사용의 경우 &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; 와 같은 문자열 이 해당 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 의 수동 구성보다 훨씬 좋지만 때로는 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 값이 주소 &lt;em&gt;의&lt;/em&gt; 주요 소스이며 변환 생성자 메소드에서 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 로 다시 변환하기 위해 다른 유형 (예 : 문자열)으로 쓸모 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4c03571c99fa2a4a0d6d2bd73efa6856a353a75" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 완전한 동등성 관계가없는 유형에 대해 부분 동등성을 허용합니다. 예를 들어, 부동 소수점 수 &lt;code&gt;NaN != NaN&lt;/code&gt; 에서 부동 소수점 유형은 &lt;a href=&quot;trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 가&lt;/a&gt; 아닌 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="6796333a1773b86bb39aa9af35062f79738f2038" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802ac1cfe1536c265ef2f2bdbe3a05ea51c03f9" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">이 특성은 완전한 등가 관계가없는 유형에 대해 부분적 평등을 허용합니다. 예를 들어 부동 소수점 숫자 &lt;code&gt;NaN != NaN&lt;/code&gt; 에서 부동 소수점 형식은 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현 하지만 &lt;code&gt;Eq&lt;/code&gt; 는 구현 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ff1d61ee8b274d07d29615e751a57961b3d97e97" translate="yes" xml:space="preserve">
          <source>This trait can be used to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. An executor can define an implementation of this trait, and use that to construct a Waker to pass to the tasks that are executed on that executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebce9a7c84fca1499f5aca86035aeb53d64365" translate="yes" xml:space="preserve">
          <source>This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.</source>
          <target state="translated">이 특성을 사용하면 메타 데이터가 크게 증가하지 않으면 서 고정 크기 배열에서 다른 특성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45737752ce770a5a32320c65da9b598f29acafd8" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">이 특성은 모든 필드가 &lt;code&gt;Clone&lt;/code&gt; 인 경우 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 호출 의 &lt;code&gt;derive&lt;/code&gt; 구현은 각 필드에서 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5800007da2c584795de3c7fc5ff71b96b272866c" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">모든 필드가 &lt;code&gt;Clone&lt;/code&gt; 인 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 호출 의 &lt;code&gt;derive&lt;/code&gt; 구현은 각 필드에서 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e6a77474d17602cdca329051113afe871aed6794" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields implement &lt;code&gt;Debug&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d for structs, it will use the name of the &lt;code&gt;struct&lt;/code&gt;, then &lt;code&gt;{&lt;/code&gt;, then a comma-separated list of each field's name and &lt;code&gt;Debug&lt;/code&gt; value, then &lt;code&gt;}&lt;/code&gt;. For &lt;code&gt;enum&lt;/code&gt;s, it will use the name of the variant and, if applicable, &lt;code&gt;(&lt;/code&gt;, then the &lt;code&gt;Debug&lt;/code&gt; values of the fields, then &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">모든 필드가 &lt;code&gt;Debug&lt;/code&gt; 를 구현 하는 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 경우 &lt;code&gt;derive&lt;/code&gt; D는 구조체에 대해, 그것의 이름을 사용하는 &lt;code&gt;struct&lt;/code&gt; 후 &lt;code&gt;{&lt;/code&gt; 각 필드의 이름 다음의 쉼표로 구분 &lt;code&gt;Debug&lt;/code&gt; 값 다음 &lt;code&gt;}&lt;/code&gt; . 들어 &lt;code&gt;enum&lt;/code&gt; 의,이 경우, 적용, 변형의 이름을 사용하는 것 &lt;code&gt;(&lt;/code&gt; 다음 &lt;code&gt;Debug&lt;/code&gt; 필드의 값을, 다음 &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a45e25757830b253d95a2bc878b147cc25a79e" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all of the type's fields implement &lt;code&gt;Default&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, it will use the default value for each field's type.</source>
          <target state="translated">모든 유형의 필드가 &lt;code&gt;Default&lt;/code&gt; 를 구현하는 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 언제 &lt;code&gt;derive&lt;/code&gt; d를 파생 각 필드 유형에 대한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2676a9e67ccce40e213776c8079ad50bcc6e9ebc" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographic_order&quot;&gt;lexicographic&lt;/a&gt; ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d6ff7ae1d14cf4065033999ff08ecaa8a87ff" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom declaration order.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 때 &lt;code&gt;derive&lt;/code&gt; 구조체에 d를,이 구조체의 멤버의 위에서 아래로 선언 순서에 따라 사전 식 순서를 생성합니다. 열거 형에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 변형은 위에서 아래로 선언 된 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9c8b40d33d991fc237bdd0ad2e6af05e65ea6f04" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 구조체에서 d를 &lt;code&gt;derive&lt;/code&gt; 할 때 구조체 멤버의 맨 위에서 맨 아래로 선언 순서를 기반으로 사전 식 순서를 생성합니다. 열거 형에서 d를 &lt;code&gt;derive&lt;/code&gt; 할 때 변형은 위에서 아래로 판별 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="86c69254ea90ce1d6926208560c4e9d29d5a8ded" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When &lt;code&gt;derive&lt;/code&gt;d on enums, each variant is equal to itself and not equal to the other variants.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 구조체에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 모든 필드가 같으면 두 인스턴스가 같고 필드가 같지 않으면 같지 않습니다. 열거 형에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 각 변형은 다른 변형과 같지 않고 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d52b5ae617172e107648185da3f817960014bc61" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, because &lt;code&gt;Eq&lt;/code&gt; has no extra methods, it is only informing the compiler that this is an equivalence relation rather than a partial equivalence relation. Note that the &lt;code&gt;derive&lt;/code&gt; strategy requires all fields are &lt;code&gt;Eq&lt;/code&gt;, which isn't always desired.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . d를 &lt;code&gt;derive&lt;/code&gt; 할 때 , &lt;code&gt;Eq&lt;/code&gt; 는 추가적인 방법이 없기 때문에 컴파일러에게 이것이 부분적 동등성 관계가 아니라 동등성 관계임을 알리는 것입니다. 점을 유의 &lt;code&gt;derive&lt;/code&gt; 전략은 모든 필드가 필요 &lt;code&gt;Eq&lt;/code&gt; 항상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f803568cc6e1099a89a4940b9eb35200f2785e5" translate="yes" xml:space="preserve">
          <source>This trait is &lt;code&gt;unsafe&lt;/code&gt; because its implementation must be correct for the safety of &lt;code&gt;unsafe trait TrustedLen&lt;/code&gt; implementations, and the results of using this trait can otherwise be trusted by &lt;code&gt;unsafe&lt;/code&gt; code to be correct and fulfill the listed obligations.</source>
          <target state="translated">이 특성은 &lt;code&gt;unsafe&lt;/code&gt; &lt;code&gt;unsafe trait TrustedLen&lt;/code&gt; 구현 의 안전을 위해 구현이 정확해야하기 때문에 안전 하지 않으며, 그렇지 않으면이 특성을 사용한 결과가 &lt;code&gt;unsafe&lt;/code&gt; 코드로 신뢰할 수 있고 나열된 의무를 이행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec116d7c92b2e4ed9689a8552deb9b1c3c9f209" translate="yes" xml:space="preserve">
          <source>This trait is a memory-safe and ergonomic alternative to constructing a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;. It supports the common executor design in which the data used to wake up a task is stored in an &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;. Some executors (especially those for embedded systems) cannot use this API, which is why &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; exists as an alternative for those systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8679bc430feac142d06128a89f1af63473e460" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for almost every type.</source>
          <target state="translated">이 특성은 거의 모든 유형에 대해 자동으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8cc586f2666a5f5f3d6650a18ec09e61d24a39" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for any type which implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait. As such, &lt;code&gt;ToString&lt;/code&gt; shouldn't be implemented directly: &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; should be implemented instead, and you get the &lt;code&gt;ToString&lt;/code&gt; implementation for free.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성 을 구현하는 모든 유형에 대해 자동으로 구현됩니다 . 따라서 &lt;code&gt;ToString&lt;/code&gt; 은 직접 구현하면 안됩니다. 대신 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 를 구현해야합니다. &lt;code&gt;ToString&lt;/code&gt; 구현은 무료로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="82a06decfe065900879f7436e10b252705283acf" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for every type and does not add any guarantees to &lt;a href=&quot;../mem/struct.discriminant&quot;&gt;&lt;code&gt;mem::Discriminant&lt;/code&gt;&lt;/a&gt;. It is &lt;strong&gt;undefined behavior&lt;/strong&gt; to transmute between &lt;code&gt;DiscriminantKind::Discriminant&lt;/code&gt; and &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3b32607a26276b7eeb2dc3f257150496699a30" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented when the compiler determines it's appropriate.</source>
          <target state="translated">이 특성은 컴파일러가 적절하다고 판단 할 때 자동으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="494ae62c6025e3f79bcb3a8e54a1efc9a121264f" translate="yes" xml:space="preserve">
          <source>This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; traits. The purpose of this trait is to encode what types are safe to cross a &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; boundary with no fear of unwind safety.</source>
          <target state="translated">이 특성은 기본적으로 여러 유형에 대해 구현되며 &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 특성 에 대한 구현 유추 측면에서 유사하게 작동 합니다. 이 특성의 목적은 &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 와인드 안전성에 대한 두려움없이 catch_unwind 경계 를 넘어 안전한 유형을 인코딩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6fb1b7be6434ef1f997fff7cbfd045083e8560fe" translate="yes" xml:space="preserve">
          <source>This trait is namely not implemented by &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&lt;/code&gt;&lt;/a&gt;, the root of all interior mutability.</source>
          <target state="translated">이 특성은 모든 내부 변경의 근본 인 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&lt;/code&gt; &lt;/a&gt; 에 의해 구현되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d0c0de184f4ceb6563275bbcba7c14bd0a8edcc" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; which is used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">이 특성은 변경 가능한 참조 간 변환에 사용되는 &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 과 유사합니다 . 비용이 많이 드는 변환이 필요한 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 유형으로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 을 구현 하거나 사용자 정의 함수를 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="72c951714ee4a3342d70f41b91f0921e7e49ebf0" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; but used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 변경 가능한 참조 간 변환에 사용됩니다. 비용이 많이 드는 변환이 필요한 경우 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유형으로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 을 구현하는 것이 좋습니다. 하거나 사용자 정의 함수를 작성하는 .</target>
        </trans-unit>
        <trans-unit id="1a731da3b36000bb0e86dfbd3105e49bf55c952e" translate="yes" xml:space="preserve">
          <source>This trait is the type which this modules requires when formatting information. This is similar to the standard library's &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait, but it is only intended for use in libcore.</source>
          <target state="translated">이 특성은 정보를 형식화 할 때이 모듈에 필요한 유형입니다. 이것은 표준 라이브러리의 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성 과 유사 하지만 libcore에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b733d2267c635d65e2675dc57b25279df45e854" translate="yes" xml:space="preserve">
          <source>This trait is used for generic address resolution when constructing network objects. By default it is implemented for the following types:</source>
          <target state="translated">이 특성은 네트워크 개체를 구성 할 때 일반 주소 확인에 사용됩니다. 기본적으로 다음 유형에 대해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3fe626c5ddea26b813fe813b589bf866e90fcc" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복기 에서 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 메서드 를 구현하는 데 사용됩니다 . 트레이 트를 구현하는 유형은 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 메소드 로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 마찬가지로이 트레이 트는 거의 직접 호출되지 않아야하며 대신 &lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product()&lt;/code&gt; &lt;/a&gt; 를 통해 상호 작용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d670e5f44288c65ae601422a01219d930136f211" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복자 에서 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 데 사용됩니다 . 특성을 구현하는 유형은 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; 방법 으로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 같이이 특성은 거의 직접 호출되지 않고 &lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product&lt;/code&gt; &lt;/a&gt; 를 통해 상호 작용하지 않아야합니다. .</target>
        </trans-unit>
        <trans-unit id="45f3e129667be9feede25a178448a0d3c4ddec5b" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복기 에서 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 메서드 를 구현하는 데 사용됩니다 . 트레이 트를 구현하는 유형은 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 메소드 로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 마찬가지로이 트레이 트는 거의 직접 호출되지 않아야하며 대신 &lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum()&lt;/code&gt; &lt;/a&gt; 을 통해 상호 작용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f91608e2b2b005f5d3b20c487cd2efcf273838ce" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복자 에서 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 데 사용됩니다 . 특성을 구현하는 유형은 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 같이이 특성은 직접 호출되지 않고 &lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum&lt;/code&gt; &lt;/a&gt; 을 통해 상호 작용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="b392534a7b8b5e656825847e787994b0e838f382" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">이 특성은 계약이 체결 된 경우에만 구현해야합니다. 이 특성의 소비자는 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; 의 상한을 검사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d78a10342907305049d898a7fef5c559c08564a" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">이 특성은 계약이 유지 될 때만 구현되어야합니다. 이 특성의 소비자는 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt; 의 상한을 검사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f26cbb7d217e71e5e8a2a5d99b20ac95a15952a0" translate="yes" xml:space="preserve">
          <source>This trait only accepts UTF-8&amp;ndash;encoded data and is not &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;flushable&lt;/a&gt;. If you only want to accept Unicode and you don't need flushing, you should implement this trait; otherwise you should implement &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b09db877c076776794822e006bb3f0094cf13d" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the back (right) of a string.</source>
          <target state="translated">이 특성은 문자열의 뒷면 (오른쪽)에서 시작하여 패턴이 겹치지 않는 일치 항목을 검색하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="581e031865e09ba379141c2883157c1d8acecf2b" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the front (left) of a string.</source>
          <target state="translated">이 특성은 문자열의 앞 (왼쪽)에서 시작하여 패턴의 겹치지 않는 일치를 검색하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="577d84c8d58ef48b8ffaf1a01ef5ed3b028f5279" translate="yes" xml:space="preserve">
          <source>This trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that</source>
          <target state="translated">이 특성은 다음 조건에서 인터 레이터 어댑터 파이프 라인의 소스 단계에 대한 전 이적 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7d02b91849e023371b70419d209ec71d8ae7432d" translate="yes" xml:space="preserve">
          <source>This trait should generally not be implemented by consumers of the standard library. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro accepts an instance of &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait is favored over implementing this trait.</source>
          <target state="translated">이 특성은 일반적으로 표준 라이브러리 소비자가 구현해서는 안됩니다. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;매크로의 인스턴스 받아 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성이 특성을 구현을 통해 선호한다.</target>
        </trans-unit>
        <trans-unit id="6159bc779b64f1381d56daf00e89fd123440f35d" translate="yes" xml:space="preserve">
          <source>This tree shows how some of the modules nest inside one another (for example, &lt;code&gt;hosting&lt;/code&gt; nests inside &lt;code&gt;front_of_house&lt;/code&gt;). The tree also shows that some modules are &lt;em&gt;siblings&lt;/em&gt; to each other, meaning they&amp;rsquo;re defined in the same module (&lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt; are defined within &lt;code&gt;front_of_house&lt;/code&gt;). To continue the family metaphor, if module A is contained inside module B, we say that module A is the &lt;em&gt;child&lt;/em&gt; of module B and that module B is the &lt;em&gt;parent&lt;/em&gt; of module A. Notice that the entire module tree is rooted under the implicit module named &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">이 트리는 일부 모듈이 서로 중첩되는 방법을 보여줍니다 (예 : &lt;code&gt;front_of_house&lt;/code&gt; 내부의 중첩 &lt;code&gt;hosting&lt;/code&gt; ). 트리는 또한 일부 모듈이 서로 &lt;em&gt;형제&lt;/em&gt; 임을 보여줍니다. 즉 , 동일한 모듈에 정의되어 있습니다 ( &lt;code&gt;hosting&lt;/code&gt; 및 &lt;code&gt;serving&lt;/code&gt; 는 &lt;code&gt;front_of_house&lt;/code&gt; 내에 정의 됨 ). 패밀리 비유를 계속하기 위해 모듈 A가 모듈 B에 포함 된 경우 모듈 A는 모듈 B의 &lt;em&gt;자식&lt;/em&gt; 이고 모듈 B 는 모듈 A 의 &lt;em&gt;부모&lt;/em&gt; 라고합니다. 전체 모듈 트리는 암시 적 모듈이라는 이름 아래에 있습니다. &lt;code&gt;crate&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a2a59de8ad5e3abf90b08ea27feb4c5c9564363" translate="yes" xml:space="preserve">
          <source>This trick is very sneaky and complicated. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make perfect sense; someday, it will be completely unnecessary.</source>
          <target state="translated">이 트릭은 매우 교묘하고 복잡합니다. 그것이 완벽하지 않다고 걱정하지 마십시오. 언젠가는 완전히 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="e51c9b4abf7ac4d9724545d7cabc828636bce6da" translate="yes" xml:space="preserve">
          <source>This type can represent a wide range of decimal numbers, like &lt;code&gt;3.5&lt;/code&gt;, &lt;code&gt;27&lt;/code&gt;, &lt;code&gt;-113.75&lt;/code&gt;, &lt;code&gt;0.0078125&lt;/code&gt;, &lt;code&gt;34359738368&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;. So unlike integer types (such as &lt;code&gt;i32&lt;/code&gt;), floating point types can represent non-integer numbers, too.</source>
          <target state="translated">이 유형은 &lt;code&gt;3.5&lt;/code&gt; , &lt;code&gt;27&lt;/code&gt; , &lt;code&gt;-113.75&lt;/code&gt; , &lt;code&gt;0.0078125&lt;/code&gt; , &lt;code&gt;34359738368&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;-1&lt;/code&gt; 과 같은 광범위한 십진수를 나타낼 수 있습니다 . 따라서 정수 유형 (예 : &lt;code&gt;i32&lt;/code&gt; ) 과 달리 부동 소수점 유형은 정수가 아닌 숫자도 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b151d516c842037f13cd18d29f046aea06e0121e" translate="yes" xml:space="preserve">
          <source>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">이 유형은 임의로 커야하므로 크기를 잘 정의 할 수 없습니다 ( &lt;code&gt;ListNode&lt;/code&gt; 를 깊이 에 중첩시킬 수 있기 때문에 ). 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="84f5f45f7092418ba53ffa588ed49cf6c55b3005" translate="yes" xml:space="preserve">
          <source>This type does not support transmission of an error other than that an error occurred. Any extra information must be arranged to be transmitted through some other means.</source>
          <target state="translated">이 유형은 오류가 발생한 것 이외의 오류 전송을 지원하지 않습니다. 추가 정보는 다른 수단을 통해 전송되도록 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca06708cb31886f20e9999f83e4a96bd88513b09" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;a href=&quot;../../primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;../../primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7ed5168f106b9ae49d6a5ac8c4fbf062da809a4c" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">이 유형은 &lt;code&gt;*mut T&lt;/code&gt; 와 동일한 메모리 내 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bde0ba16d9d2a17d2da79db3c616fd2db5d4b738" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11fe8d9ef82cc58363e607b1900488902f96b062" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2c41e53be3c451cd7fe9d715ded32f7f324930" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8709735902527f53136366bbc4da81e059b1cf29" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22a2662795b52aff8d9d5db4f32fbfd5a6eae45b" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 인 &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0e9d5aecbbcb90f5394cd93afd041c8660e20d3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b9ce184354cce38ff31805f5b9e99cf85271c3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f3b430d11ed80e34dede1d2fe612c5e93a3e75e" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da5885bb51df1018c63942e6cd581107a9d67b99" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1494d8fbdc9903b4f7f4ce3473fbf110556d56ce" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 인 &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd773ba06290a2ef0eb43046e43b15b9753a1b01" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 유형 은 &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성으로 등록 된 할당 자 또는 &lt;code&gt;std&lt;/code&gt; 크레이트의 기본값으로 호출을 전달 하여 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0d10c935129b21e89e6454b38394b060ce3b284b" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 유형 은 &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성이있는 경우 등록 된 할당 자 또는 &lt;code&gt;std&lt;/code&gt; 크레이트의 기본값으로 호출을 전달 하여 &lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1acd93eca07f0189a95b444e7590b0d811f50e31" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;code&gt;GlobalAlloc&lt;/code&gt; trait and Rust programs by default work as if they had this definition:</source>
          <target state="translated">이 유형은 &lt;code&gt;GlobalAlloc&lt;/code&gt; 특성 및 Rust 프로그램을 기본적으로 다음 정의를 가진 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="58e8fa6622de2c31c9adb96ad4ef78c440c610d0" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;Lazy&lt;/code&gt;, and can be used in statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c766a6dd40937d2b1bee433cf315fc82a362370f" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;OnceCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466a15ddbbbf930acad97c2c30afa51f3b95564c" translate="yes" xml:space="preserve">
          <source>This type is broadly used across &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; for any operation which may produce an error.</source>
          <target state="translated">이 유형은 오류가 발생할 수있는 모든 작업에 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt; 에서 광범위하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="37345f83ba0c67385672d5daf1593634da8686e6" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt;&lt;code&gt;from_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt; &lt;code&gt;from_utf16&lt;/code&gt; &lt;/a&gt; 메소드에 대한 오류 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8498c071c2463be5580b4f49150396661778b8bc" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. It is designed in such a way to carefully avoid reallocations: the &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt; method will give back the byte vector that was used in the conversion attempt.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드에 대한 오류 유형입니다 . &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt; 메소드는 변환 시도에 사용 된 바이트 벡터를 다시 제공 하여 재 할당을 신중하게 피할 수 있도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d92453a7345aece96356ae2979efa1f42765d4ea" translate="yes" xml:space="preserve">
          <source>This type is very similar to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many bits. Please see &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double precision values&lt;/a&gt; for more information.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 와 매우 유사 하지만 두 배 많은 비트를 사용하여 정밀도가 향상되었습니다. 자세한 내용 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;은 &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;배정 밀도 값에 &lt;/a&gt;대한 f32 또는 Wikipedia 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63b84d2000b910b8457b4220e8938add88b701b5" translate="yes" xml:space="preserve">
          <source>This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</source>
          <target state="translated">이 유형의 잠금은 특정 시점에 여러 독자 또는 최대 한 명의 작성자를 허용합니다. 이 잠금의 쓰기 부분은 일반적으로 기본 데이터 (독점 액세스)의 수정을 허용하고이 잠금의 읽기 부분은 일반적으로 읽기 전용 액세스 (공유 액세스)를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c6101d6dc5e2fd547d5ca4f8075c490b739700a9" translate="yes" xml:space="preserve">
          <source>This type provides methods like &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt;&lt;code&gt;set_extension&lt;/code&gt;&lt;/a&gt; that mutate the path in place. It also implements &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, meaning that all methods on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slices are available on &lt;code&gt;PathBuf&lt;/code&gt; values as well.</source>
          <target state="translated">이 유형은 경로를 변경하는 &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt; &lt;code&gt;set_extension&lt;/code&gt; &lt;/a&gt; 과 같은 메소드를 제공합니다 . 또한 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; 에 대한&lt;/a&gt;&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 를 구현 하므로 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 슬라이스의 모든 메소드 를 &lt;code&gt;PathBuf&lt;/code&gt; 값에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c0f0dd2b187cb6784df147ee7001123c8936c0" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 널 종료 바이트 배열에 대한 빌린 참조를 나타냅니다. &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스에서 안전하게 또는 raw &lt;code&gt;*const c_char&lt;/code&gt; 에서 안전하지 않게 구성 할 수 있습니다 . 그런 다음 UTF-8 유효성 검사를 수행하거나 소유 한 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 으로 Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="020b3bfb2ee1251c34f42849931a1e6222269e82" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 널로 끝나는 바이트 배열에 대한 차용 된 참조를 나타냅니다. &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 에서 안전하게 생성 되거나 원시 &lt;code&gt;*const c_char&lt;/code&gt; 에서 안전하지 않게 생성 될 수 있습니다 . 그런 다음 UTF-8 유효성 검사를 수행 하여 Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 또는 소유 된 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e18df5bb8ad819c600cd4afb1d82afc59b7f998" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a string in the operating system's preferred representation.</source>
          <target state="translated">이 유형은 운영 체제의 선호 표현에서 문자열에 대한 빌린 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6142b61fe2d2c68dea4ad8a85d9dc10ccc2f98b3" translate="yes" xml:space="preserve">
          <source>This type represents a stack backtrace for an OS thread captured at a previous point in time. In some instances the &lt;code&gt;Backtrace&lt;/code&gt; type may internally be empty due to configuration. For more information see &lt;code&gt;Backtrace::capture&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b774085d693678b6b309fbc90af8e885fb4742c" translate="yes" xml:space="preserve">
          <source>This type represents the status code a process can return to its parent under normal termination.</source>
          <target state="translated">이 유형은 정상적인 종료 상태에서 프로세스가 부모에게 반환 할 수있는 상태 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b966cfbeebcefe7f0330e7e9f54f7098bf1152f" translate="yes" xml:space="preserve">
          <source>This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (&quot;nul characters&quot;) and that the final byte is 0 (&quot;nul terminator&quot;).</source>
          <target state="translated">이 유형은 Rust 바이트 슬라이스 또는 벡터에서 C 호환 문자열을 안전하게 생성 할 수 있도록합니다. 이 유형의 인스턴스는 기본 바이트에 내부 0 바이트 ( &quot;널 문자&quot;)가없고 마지막 바이트가 0 ( &quot;널 종결 자&quot;)임을 정적으로 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7d87337ad285058ac7367e471ff8622a41dfdd71" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or  on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">이 유형은 경로를 구성 요소로 나누는 것을 포함하여 경로를 검사하기위한 여러 작업을 지원합니다 ( 유닉스에서 &lt;code&gt;/&lt;/code&gt; 로 구분하고 &lt;code&gt;/&lt;/code&gt; 또는 Windows로 구분), 파일 이름 추출, 절대 경로 판별 .</target>
        </trans-unit>
        <trans-unit id="5d992ca66aeeffa4346515aab9e07f94a5a7aea4" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">이 유형은 경로를 구성 요소로 분리 ( Unix 에서는 &lt;code&gt;/&lt;/code&gt; 로 , Windows에서는 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; 로 구분), 파일 이름 추출, 경로가 절대인지 확인하는 등 경로를 검사하기위한 여러 작업을 지원합니다 . .</target>
        </trans-unit>
        <trans-unit id="f22ec26e83b1f093f0fa10a8ffd75ef588107911" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 이며 Rust 에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 단 정밀도 부동 소수점&lt;/a&gt; 으로 보장됩니다 . 즉, 표준은 기술적으로 부동 소수점 수임을 보장하며 정밀도보다 정확도가 떨어질 수 있습니다 &lt;code&gt;f32&lt;/code&gt; 떨어지 거나 IEEE-754 표준을 전혀 따르지 않을 .</target>
        </trans-unit>
        <trans-unit id="b34eb94d33cfcd2b81be054dc12a48e0b5f8dc2f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 이며 Rust 에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 배정 밀도 부동 소수점&lt;/a&gt; 으로 보장됩니다 . 즉, 표준은 기술적으로 그것이 적어도 &lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 의 정밀도를 가진 부동 소수점 숫자임을 보증하며 , &lt;code&gt;f32&lt;/code&gt; 또는 IEEE-754 표준과 완전히 다른 .</target>
        </trans-unit>
        <trans-unit id="2713919b8810fb3f44c86782b09415ed3b59cda3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 16 비트 이상의 부호있는 정수 여야합니다. 일부 시스템은 다음과 같이 정의 할 수 있습니다. &lt;code&gt;i32&lt;/code&gt; 예를 들어 i32 .</target>
        </trans-unit>
        <trans-unit id="c0d84326d8675408ac530de354cda2d1a8ac7eb3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 적어도 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 크기의 부호있는 정수 여야합니다 . 예를 들어 일부 시스템에서는이를 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ab581f0ea98e052030c778602ef0ca98c399648d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적 으로이 유형이 64 비트 이상 및 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기 이상의 부호있는 정수 만 요구 하지만 실제로 는 대부분의 시스템이 그렇지 않기 때문에 시스템이 &lt;code&gt;i64&lt;/code&gt; 가 아닌 &lt;code&gt;long long&lt;/code&gt; 을 갖지는 않습니다. 표준화 된 &lt;a href=&quot;../../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b5edcf451c79ce2991144552b8f569664ab769" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ba1b7005ffb5ad84714cb0adcd9cce8dfd29a44" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수 여야합니다 . 일부 시스템은이를 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다예를 들어 .</target>
        </trans-unit>
        <trans-unit id="10f7763a2c07ba8b71ea9cbe73fe235f098f6f03" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.u128&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적 으로이 유형이 &lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt; 크기의 부호없는 정수 일 것을 요구 하지만 실제로 는 대부분의 시스템에 표준화 된 &lt;a href=&quot;../../primitive.u128&quot;&gt; &lt;code&gt;u128&lt;/code&gt; &lt;/a&gt; 유형 이 없으므로 실제로 &lt;code&gt;long long&lt;/code&gt; 이 &lt;code&gt;u64&lt;/code&gt; 가 아닌 시스템은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="62b8bfd925dec29031c9f9af8d15530118a5f2ce" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 이며, Rust에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 단 정밀도 부동 소수점&lt;/a&gt; 이 보장됩니다 . 즉, 표준은 기술적으로 부동 소수점 숫자임을 보증하며 &lt;code&gt;f32&lt;/code&gt; 보다 정밀도가 낮 거나 IEEE-754 표준을 전혀 따르지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c674b282d61f34daea9ef2ee13aae39fb8505b63" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f64.html&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 이며 Rust에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 배정 밀도 부동 소수점&lt;/a&gt; 이 보장됩니다 . 즉, 표준은 기술적으로 최소한 &lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 정밀도를 가진 부동 소수점 숫자임을 보증 하며 &lt;code&gt;f32&lt;/code&gt; 또는 IEEE-754 표준과 완전히 다른 것일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea8042a19bb3c7392d0a03d8aac515052ed54c02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형이 최소 16 비트의 부호있는 정수 여야합니다. 예를 들어 일부 시스템에서는이를 &lt;code&gt;i32&lt;/code&gt; 로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f5a6e28ddb1307caa7a25d8ee94ecc741d04f02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준은 기술적으로이 유형이 최소한 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 크기 인 부호있는 정수 여야합니다 . 예를 들어 일부 시스템에서는이를 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2ab7786704bfcc1276eecf70ffb134c89a7de414" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i128.html&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적으로이 유형이 최소한 64 비트이고 최소한 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기 인 부호있는 정수 여야한다고 요구 하지만, 실제로 는 대부분의 시스템이 그렇지 않은 것처럼 &lt;code&gt;i64&lt;/code&gt; 가 아닌 &lt;code&gt;long long&lt;/code&gt; 을 갖는 시스템은 없습니다. 표준화 된 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i128.html&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d3f0d1d67d74135ffdd410a290383d90e8fe31" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준은 기술적으로이 유형이 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="202dca95d3eb592c40ce655fef3c1ec8be90922f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준은 기술적으로이 유형이 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 크기가 같은 부호없는 정수 여야합니다 . 예를 들어 일부 시스템에서는이를 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="469cb3e6510770c6f62e6ffb0ed8eda80a71067d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u128.html&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적에만이 유형은의 크기와 부호없는 정수 있어야합니다 &lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt; 실제로, 어떤 시스템이이 없을 것입니다 있지만, &lt;code&gt;long long&lt;/code&gt; 하지 않은입니다 &lt;code&gt;u64&lt;/code&gt; 대부분의 시스템이 표준화되어 있지 않는 한, &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u128.html&quot;&gt; &lt;code&gt;u128&lt;/code&gt; 의&lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cf97ad06e74edf68697dac1b4dcee83cfa2a22b5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 입니다. 대부분의 Linux 기반 시스템은 &lt;code&gt;i64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;i32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적 으로이 유형이 32 비트 이상이고 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 크기 이상인 부호있는 정수 만 요구 하지만 실제로는 시스템이 &lt;code&gt;i32&lt;/code&gt; 나 &lt;code&gt;i64&lt;/code&gt; 가 아닌 &lt;code&gt;long&lt;/code&gt; 을 갖지 는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7164487891e0a7833d4edf15c16beda44c3572d5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 같은 크기의 부호있는 정수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ffb84596c9e59eea63cf919456fbd81bc2d5347" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 입니다. 대부분의 Linux 기반 시스템은 &lt;code&gt;u64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;u32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적 으로이 유형이 &lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기의 부호없는 정수 일 것을 요구 하지만 실제로는 시스템이 &lt;code&gt;u32&lt;/code&gt; 가 아닌 &lt;code&gt;ulong&lt;/code&gt; 을 갖지 않습니다. &lt;code&gt;u64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702c3c35c3eb36099eb087128d0090cf4cdc5cb9" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수로 정의됩니다. .</target>
        </trans-unit>
        <trans-unit id="3bd4e6f17c1fadac181d74e7c6fccf81e88a4338" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 입니다. 특히 많은 Linux 기반 시스템은 &lt;code&gt;i64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;i32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적으로이 유형이 32 비트 이상이고 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 크기 이상인 부호있는 정수 &lt;code&gt;i64&lt;/code&gt; . 실제로 시스템은 &lt;code&gt;i32&lt;/code&gt; 도 i64 도 아닌 &lt;code&gt;long&lt;/code&gt; 을 갖지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d40fc3671ec7ae824bd7929d61ce78e74ef07a2" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i8.html&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i8.html&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호있는 정수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a9f45d2d1c5aca56d0bed11f4011cece6101639" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 입니다. 특히 많은 Linux 기반 시스템은 &lt;code&gt;u64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;u32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적으로이 유형이 &lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기의 부호없는 정수 여야 하지만 실제로 는 &lt;code&gt;u32&lt;/code&gt; 도 &lt;code&gt;u64&lt;/code&gt; 도 아닌 &lt;code&gt;ulong&lt;/code&gt; 을 갖는 시스템은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb106d3debd5b58c7a1ae3e283c55499cf8e5484" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 같은 크기의 부호없는 정수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4424cbb3fbb90751454ec3bf9577dceb9d9a320d" translate="yes" xml:space="preserve">
          <source>This typedef is generally used to avoid writing out &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; directly and is otherwise a direct mapping to &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 typedef는 일반적으로 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; 직접 쓰지 않고 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 에&lt;/a&gt; 직접 매핑하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="9571d5615d4085a615ed7c5ad4cadc1ded956713" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.</source>
          <target state="translated">이는 일반적으로 특정 바이트 수를 읽는 경우에만 작업이 성공하지만 더 적은 수의 바이트 만 읽을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="692f047748f56fd7b6dd085f2d1ee90a117e619a" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.</source>
          <target state="translated">이는 일반적으로 특정 수의 바이트를 쓴 경우에만 작업이 성공하지만 더 적은 수의 바이트 만 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="066666922981580e3c6ec7b57246e05ce6d242d4" translate="yes" xml:space="preserve">
          <source>This usage of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create safe nullable pointers is so common that Rust does special optimizations to make the representation of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.</source>
          <target state="translated">이 사용 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 안전 널 (NULL) 포인터를 만들 수는 녹 표현하기 위해 특별한 최적화 않도록 일반적인 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 하나의 포인터. Rust의 선택적 포인터는 다른 포인터 유형만큼 효율적으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3473dac5d293883be110e74db63b95a407d1ea5c" translate="yes" xml:space="preserve">
          <source>This usage of &lt;code&gt;extern&lt;/code&gt; does not require &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;extern&lt;/code&gt; 사용은 &lt;code&gt;unsafe&lt;/code&gt; 하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="d52ccca3efa09c9ce1760baf0a04fa97e3aed552" translate="yes" xml:space="preserve">
          <source>This use of a &lt;code&gt;where&lt;/code&gt; clause is strange - a more common usage would look something like the following:</source>
          <target state="translated">이 사용하는 &lt;code&gt;where&lt;/code&gt; 절을 것은 이상합니다.보다 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ee77b0606c712a9409edf4f68e92618c8d2ee4a" translate="yes" xml:space="preserve">
          <source>This value is not suitable for passing to &lt;code&gt;Path::new&lt;/code&gt; or similar constructors when the host platform and target platform differ.</source>
          <target state="translated">이 값은 호스트 플랫폼과 대상 플랫폼이 다를 때 &lt;code&gt;Path::new&lt;/code&gt; 또는 유사한 생성자 에 전달하는 데 적합하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ededb49250daf0db79bbb927c06d879d238521da" translate="yes" xml:space="preserve">
          <source>This value sets the time-to-live field that is used in every packet sent from this socket.</source>
          <target state="translated">이 값은이 소켓에서 전송 된 모든 패킷에 사용되는 TTL 필드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="75beec589ecae6a039a7d01c52fb4b4aea8d427f" translate="yes" xml:space="preserve">
          <source>This value should be considered only a hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d769cb0769d945ca70d65f4d25befb01295f124d" translate="yes" xml:space="preserve">
          <source>This variant is also constructed when a &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; is misplaced within a string either on its own or in the middle of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413d9b4dc5521012c4ffcf2dbef4c140f61e2a52" translate="yes" xml:space="preserve">
          <source>This variant is the most common one, it represents references to files or directories.</source>
          <target state="translated">이 변형은 가장 일반적인 변형이며 파일 또는 디렉토리에 대한 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ad9c1ff17fcdcd8bc09eee76d183971a27c0cfe" translate="yes" xml:space="preserve">
          <source>This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.</source>
          <target state="translated">이 변형은 구문 분석 문자열의 값이 0 일 때 생성되며 이는 0이 아닌 유형에는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f262b16f3428e356cf4b0dde5dbe8613ec4091d5" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="translated">이 버전의 텍스트는 Rust 2018 Edition 관용구를 사용하기 위해 모든 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 과 함께 Rust 1.41.0 이상을 사용하고 있다고 가정합니다 . 참고 항목 &lt;a href=&quot;book/ch01-01-installation&quot;&gt;제 1 장 &quot;설치&quot;섹션&lt;/a&gt; 설치하거나 녹를 업데이트하고 새로운 볼 수있는 &lt;a href=&quot;book/appendix-05-editions&quot;&gt;부록 E를&lt;/a&gt; 판에 대한 정보를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e89485f5fe729fa0419251d6d1b6a0bc0fb1791" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="translated">이 버전의 텍스트는 Rust 2018 Edition 관용구를 사용하기 위해 모든 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 과 함께 Rust 1.41.0 이상을 사용하고 있다고 가정합니다 . 참고 항목 &lt;a href=&quot;ch01-01-installation&quot;&gt;제 1 장 &quot;설치&quot;섹션&lt;/a&gt; 설치하거나 녹를 업데이트하고 새로운 볼 수있는 &lt;a href=&quot;appendix-05-editions&quot;&gt;부록 E를&lt;/a&gt; 판에 대한 정보를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">이 방법의 수명 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; 을&lt;/a&gt; 에 &lt;code&gt;hello&lt;/code&gt; 의 수명 포함 &lt;code&gt;ptr&lt;/code&gt; 과 &lt;code&gt;unsafe&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">이 방법의 수명 &lt;code&gt;CString&lt;/code&gt; 을 에 &lt;code&gt;hello&lt;/code&gt; 의 수명 포함 &lt;code&gt;ptr&lt;/code&gt; 과 &lt;code&gt;unsafe&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 구성하는 데 필요한만큼 여러 번 할당 한 다음 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로 전환하기 위해 한 번 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 구성하는 데 필요한만큼 여러 번 할당 한 다음 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로 전환하기 위해 한 번 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이것은 항상 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">이것은 항상 &lt;a href=&quot;macro.panic&quot;&gt;공황 상태입니다!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="translated">이것은 항상 &lt;a href=&quot;macro.panic&quot;&gt;당황&lt;/a&gt; 할 것입니다 ! &lt;code&gt;unimplemented!&lt;/code&gt; 않았기 때문에 ! &lt;code&gt;panic!&lt;/code&gt; 의 속기 일뿐입니다 ! 고정 된 특정 메시지로.</target>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">이것은 최대 힙이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="translated">이것은 미래의 어느 시점에서 허용 될 것이지만 구현은 아직 완료되지 않았습니다. 이 제한 사항 은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="translated">이것은 미래의 어느 시점에서 허용 될 것이지만 구현은 아직 완료되지 않았습니다. 현재 상태에 대해서는 const 컨텍스트의 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;조건&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;루프&lt;/a&gt; 에 대한 추적 문제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 항상 그런 것은 아니며 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 또는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">type 매개 변수에 제약이 있기 때문에 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">이것은 컴파일됩니다 :</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">이렇게하면 &lt;code&gt;String&lt;/code&gt; 에서 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 생성 되어 전달됩니다.이 변환은 매우 저렴하므로 일반적으로 함수는 특정한 이유로 &lt;code&gt;String&lt;/code&gt; 필요하지 않은 경우 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 을 인수로 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">이렇게하면 기본 매개 변수 인 &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 를&lt;/a&gt; 사용하여 스레드가 생성됩니다 . 스택 크기 또는 스레드 이름을 지정하려면이 API를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">초과 용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">이것은 &lt;code&gt;\u{NNNNNN}&lt;/code&gt; 형식의 Rust 구문으로 문자를 이스케이프합니다. 여기서 &lt;code&gt;NNNNNN&lt;/code&gt; 은 16 진 표현입니다.</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 의 &lt;code&gt;Debug&lt;/code&gt; 구현 과 유사한 문자를 이스케이프합니다 .</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">컴파일러는 어떤 예를 모르기 때문에이 실패합니다 &lt;code&gt;Foo&lt;/code&gt; 통화로 &lt;code&gt;bar&lt;/code&gt; 에 있습니다. 변경 &lt;code&gt;Foo::bar()&lt;/code&gt; 에 &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; 오류를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">특성과 유형이 현재 상자에 의해 정의되지 않은 경우 유형에 대한 특성을 구현할 수 없으므로 컴파일에 실패합니다. 이것은 Rust의 고아 규칙 때문입니다. 이를 우회하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 직접 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">Rust의 고아 규칙이 조금 더 엄격했기 때문에 이전 버전의 언어에서는 컴파일되지 않습니다. 이를 우회하려면 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 직접 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">이것은 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 을 불러 일으킬 것입니다! 제공된 표현식을 &lt;code&gt;true&lt;/code&gt; 로 평가할 수없는 경우 매크로 을 런타임 .</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">이 스레드가이 키를 아직 참조하지 않은 경우 값을 느리게 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스레드가이 키를 아직 참조하지 않은 경우 값을 느리게 초기화합니다. 키가 소멸 된 경우 (소멸자에서 호출 된 경우 발생할 수 있음)이 함수는 &lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="translated">이렇게하면 나머지 셸 세션 동안 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 가 유지됩니다. &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet을 사용하여 설정을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">이터레이터를 사용하는 대신 생성기 만 만들었으므로 값이 인쇄되지 않습니다. 컴파일러는 이러한 종류의 동작에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">새 이름이 다른 마운트 지점에있는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">이것은하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">이것은 다음을 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">&lt;code&gt;OpenOptions&lt;/code&gt; 구조 의 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;append&lt;/code&gt; 플래그를 재정의합니다 . 이 방법은 데이터 읽기, 쓰기 및 추가 권한, 숨겨진 속성 및 시스템 속성 및 확장 속성에 대한 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="translated">이것은 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">&quot;( 'a', 1), ( 'b', 2), ( 'c', 3)&quot;이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">이것은 각각 자신의 라인에 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;5&lt;/code&gt; 까지 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">이것은 각각 자신의 줄에 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;4&lt;/code&gt; 까지 의 숫자를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">이것은 각각의 줄에 1부터 5까지의 숫자를 인쇄합니다. 그러나 여기서 알 수 있듯이 반복기 생성을 위해 벡터에 아무것도 호출하지 않았습니다. 무엇을 제공합니까?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 및 &lt;code&gt;send&lt;/code&gt; 작업이 차단되지 않게됩니다. 즉, 해당 호출에서 즉시 반환됩니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도 &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; 종류의 오류 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;recv&lt;/code&gt; , &lt;code&gt;recv_from&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;send_to&lt;/code&gt; 작업이 차단되지 않게 됩니다. 즉, 해당 호출에서 즉시 반환됩니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도해야하는 경우 종류 오류&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;accept&lt;/code&gt; 작업이 차단 되지 않게됩니다. 즉, 호출에서 즉시 반환됩니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 다시 시도 &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; 종류의 오류 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;accept&lt;/code&gt; 작업이 비 차단 상태가되어 즉, 해당 호출에서 즉시 돌아옵니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도해야하는 경우 종류 오류&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">그러면 프로세스에서 필드를 지우고 기본 소켓에 저장된 오류가 검색됩니다. 통화 간 오류를 확인하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Metadata&lt;/code&gt; 인스턴스가 &lt;code&gt;DirEntry::metadata&lt;/code&gt; 대한 호출에서 생성 된 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 . 이 &lt;code&gt;Metadata&lt;/code&gt; 가 &lt;code&gt;fs::metadata&lt;/code&gt; 또는 &lt;code&gt;File::metadata&lt;/code&gt; 를 사용하여 생성 된 경우 &lt;code&gt;Some&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로컬 소켓의 IP 버전이 &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; 에서 반환 된 것과 일치하지 않으면 오류가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">뛰어난 약한 참조가 있어도 성공합니다.</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">이것은 &lt;code&gt;clone&lt;/code&gt; 을 사용 하여 표현식을 복제하므로 비표준 &lt;code&gt;Clone&lt;/code&gt; 구현 이있는 유형에 이것을 사용해야합니다 . 예를 들어, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; 는 독립적 인 박스형 정수를 가리키는 5 개의 기준이 아니라 동일한 박스형 정수 값에 대한 5 개의 기준으로 구성된 벡터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">이것은 &lt;code&gt;Box&lt;/code&gt; 가 포인터 이기 때문에 작동하므로 크기가 잘 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">이것은 특성 범위와 함께 제네릭 형식 매개 변수를 사용하는 구조체를 정의하는 것과 다르게 작동합니다. 일반 유형 매개 변수는 한 번에 하나의 콘크리트 유형으로 만 대체 할 수있는 반면, 특성 오브젝트는 런타임에 특성 오브젝트에 여러 콘크리트 유형을 채울 수 있습니다. 예를 들어, Listing 17-6에서와 같이 제네릭 형식과 특성 바인딩을 사용하여 &lt;code&gt;Screen&lt;/code&gt; 구조체를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">이것은 잘 작동하지만 메서드가 일반 매개 변수를 얻으면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">이것은 잘 작동하며 그림 4-3에 표시된 것처럼 힙 데이터 &lt;em&gt;가&lt;/em&gt; 복사 되는 동작을 명시 적으로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">이것은 아무런 문제없이 작동합니다. 소유권이 철회되고 할당이 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">이 랩퍼는 유형의 필드 사이의 삭제 순서 종속성을 명시 적으로 문서화하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">이 포장지는 0 비용입니다.</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="translated">크기가 0 인이 유형 은 일반 함수 포인터로 &lt;em&gt;강제 변환&lt;/em&gt; 됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">둘 다 무서운 이름을 가지고 있지만 &lt;code&gt;PhantomData&lt;/code&gt; 와 'phantom 유형'은 관련되어 있지만 동일하지는 않습니다. 팬텀 유형 매개 변수는 결코 사용되지 않는 유형 매개 변수입니다. Rust에서 이것은 종종 컴파일러가 불평하게하며, 해결책은 &lt;code&gt;PhantomData&lt;/code&gt; 를 통해 &quot;더미&quot;사용을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">이 예제는 무해하고 해결하기 쉬운 것처럼 보이지만 값을 소비하는 함수가 발생하면 문제가 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">이 방법은 두 포인터에 대해 안전하지만 두 포인터가 동일한 할당 된 객체에 있지 않은 경우 (예 : 두 개의 다른 로컬 변수를 가리키는 경우) 결과는 대부분 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">새 스레드의 속성을 구성하기 위해 사용할 수있는 스레드 팩토리.</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">지정된 이름의 스레드 :</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">스레드 로컬 스토리지</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">스레드는 식별을 위해 연관된 이름을 가질 수 있습니다. 기본적으로 생성 된 스레드는 이름이 없습니다. 스레드의 이름을 지정하려면 &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 로 스레드를 빌드 하고 원하는 스레드 이름을 &lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt; 전달하십시오 . 스레드 내에서 스레드 이름을 검색하려면 &lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt; . 스레드 이름이 사용되는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">스레드는 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 유형을 통해 표시되며 두 가지 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">스레드는 &lt;code&gt;Thread&lt;/code&gt; 유형을 통해 표시되며 두 가지 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">스레드에는 기본적으로 이름이 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;extern crate&lt;/code&gt; 선언 의 세 가지 예 :</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">이 책 전체에서 여러 가지 패턴의 예를 보았습니다. 이 섹션에서는 패턴에 유효한 모든 구문을 수집하고 각 구문을 사용하려는 이유에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">문서 전체에서 몇 가지 규칙을 따릅니다. 모든 작업에서 컬렉션의 크기는 n으로 표시됩니다. 작업에 다른 컬렉션이 포함 된 경우 m 개의 요소가 포함됩니다. &lt;em&gt;상각 후원&lt;/em&gt; 이있는 작업 에는 &lt;code&gt;*&lt;/code&gt; 가 붙습니다 . &lt;em&gt;예상&lt;/em&gt; 비용이 포함 된 작업 에는 &lt;code&gt;~&lt;/code&gt; 가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">이 책 전반에 걸쳐, 우리는 사용했습니다 &lt;code&gt;let&lt;/code&gt; 시간의 수백처럼, 당신이 그것을 실현하지 않을 수도 있지만, 당신은 패턴을 사용했다! 보다 공식적으로 &lt;code&gt;let&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">따라서 폴링 실패 후의 &lt;code&gt;yield&lt;/code&gt; 패턴은 저수준 공유 자원 또는 동기화 프리미티브를 구현할 때 다소 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">따라서 &lt;code&gt;ref&lt;/code&gt; 은 상대가되는 것이 아닙니다. 일치하는 내용을 복사하거나 이동하는 대신 일치하는 바인딩을 참조로 만드는 것이 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="translated">따라서 스레드 패닉을 처리하는 현명한 방법은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">시간 복잡성</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">하려면 &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; 또는 &lt;code&gt;panic!&lt;/code&gt; 하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">추가하려면 &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; , 우리는 지정 &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; 의 값을 설정하는 &lt;code&gt;RHS&lt;/code&gt; 의 형식 매개 변수를 대신 기본 사용 &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">추가하려면 &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; , 우리는 지정 &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; 의 값을 설정하는 &lt;code&gt;Rhs&lt;/code&gt; 형식 매개 변수를 대신 기본 사용 &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">특정 경우에 사용자 정의를 허용하기 위해 대부분의 사용자는 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">적절한 설계를 지원하기 위해 다음 시나리오는 단일 스레드 코드에 대해 합법적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 누수를 피하려면 &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt; 사용하여 포인터를 다시 &lt;code&gt;Arc&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 누수를 방지하기 위해 포인터가로 변환 다시해야 &lt;code&gt;Rc&lt;/code&gt; 를 사용하여 &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; 참조가 해당 별명을 작성하지 않도록하기 위해 리턴 된 슬라이스는 메소드가 적용된 반복자에서 수명을 차용합니다.</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">별명에 대한 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 참조를 작성하지 않으려면 반복자를 소비해야합니다.</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">않도록하려면 &lt;code&gt;common&lt;/code&gt; 대신 작성하는 테스트 출력에 표시 &lt;em&gt;테스트 / common.rs을&lt;/em&gt; , 우리가 만듭니다 &lt;em&gt;시험 / 일반 / mod.rs을&lt;/em&gt; . 이것은 Rust도 이해하는 대체 명명 규칙입니다. 이 방법으로 파일 이름을 지정하면 Rust는 &lt;code&gt;common&lt;/code&gt; 모듈을 통합 테스트 파일로 취급하지 않습니다 . &lt;code&gt;setup&lt;/code&gt; 기능 코드를 &lt;em&gt;tests / common / mod.rs&lt;/em&gt; 로 이동하고 &lt;em&gt;tests / common.rs&lt;/em&gt; 파일을 삭제 하면 테스트 출력의 섹션이 더 이상 나타나지 않습니다. &lt;em&gt;tests&lt;/em&gt; 디렉토리의 서브 디렉토리에있는 파일은 별도의 상자로 컴파일되거나 테스트 출력에 섹션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="translated">이를 방지하려면 상수가 아닌 값을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="translated">오류를 방지하기 위해 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="translated">이 오류를 방지하려면 먼저 임시 변수를 명명 된 로컬 변수에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">이 오류를 피하려면 그 중 하나만 유지하고 다른 것을 제거해야합니다. 예를 들어서 고쳐 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">이러한 종류의 오류를 피하려면 &lt;code&gt;impl&lt;/code&gt; 에서 하나 이상의 로컬 유형을 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">이러한 문제를 피하려면 유형이 올바르게 일치해야합니다. 따라서 이전 예제를 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">유형으로 색인을 생성하려면 &lt;code&gt;std::ops::Index&lt;/code&gt; 특성 을 구현해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">명확하게 : 대부분의 기능은 모든 버전에서 사용할 수 있습니다. Rust 에디션을 사용하는 개발자는 새로운 안정 버전이 출시됨에 따라 계속 개선 될 것입니다. 그러나 경우에 따라 주로 새 키워드가 추가 될 때 일부 새로운 기능은 이후 버전에서만 사용할 수 있습니다. 이러한 기능을 이용하려면 에디션을 전환해야합니다.</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">유효하려면 매 처가 다음 세 가지 불변량을 충족해야합니다. FIRST 및 FOLLOW의 정의는 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="translated">이러한 기능이 Rust에서 어떻게 작동하는지 더 잘 이해하려면 책의 &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; 장을 읽어 보세요.</target>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">왜 두 개의 개별 루프가 필요한지 더 잘 이해하려면 두 명의 작업자가있는 시나리오를 상상하십시오. 우리가 첫 번째 반복에 각 직원을 반복하는 하나의 루프를 사용하면 종료 메시지가 채널 아래로 전송되는 및 &lt;code&gt;join&lt;/code&gt; 최초의 노동자의 스레드에서 호출. 첫 번째 작업자가 그 순간에 요청을 처리하는 중이라면 두 번째 작업자는 채널에서 종료 메시지를 가져 와서 종료합니다. 첫 번째 작업자가 종료되기를 기다리지 만 두 번째 스레드가 종료 메시지를 선택했기 때문에 절대 종료되지 않습니다. 이중 자물쇠!</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">패턴의 일치하는 값을 변수에 바인딩하려면 구문 &lt;code&gt;variable @ subpattern&lt;/code&gt; 사용하십시오 . 예를 들어, 다음은 값 2를 &lt;code&gt;e&lt;/code&gt; 에 바인딩합니다 (전체 범위가 아님 : 여기서 범위는 범위 하위 패턴 임).</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경로를 작성하거나 수정하려면 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; 구조의 레이아웃과 해당 필드의 레이아웃에서 필드의 오프셋 을 계산하려면 :</target>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">&lt;code&gt;prediction&lt;/code&gt; 값을 계산하기 위해이 코드는 &lt;code&gt;coefficients&lt;/code&gt; 의 12 개 값 각각을 반복 하고 &lt;code&gt;zip&lt;/code&gt; 방법을 사용 하여 계수 값을 &lt;code&gt;buffer&lt;/code&gt; 의 이전 12 개 값과 쌍을 이룹니다 . 그런 다음 각 쌍에 대해 값을 곱하고 모든 결과를 합산하고 합계 &lt;code&gt;qlp_shift&lt;/code&gt; 비트의 비트를 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">&lt;code&gt;Pilot&lt;/code&gt; 특성 또는 &lt;code&gt;Wizard&lt;/code&gt; 특성 에서 &lt;code&gt;fly&lt;/code&gt; 메소드 를 호출하려면 더 명확한 구문을 사용하여 의미 하는 &lt;code&gt;fly&lt;/code&gt; 메소드 를 지정해야 합니다. Listing 19-18은이 구문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">이와 관련된 함수를 호출하기 위해 구조체 이름과 함께 &lt;code&gt;::&lt;/code&gt; 구문을 사용합니다 . &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; 예입니다. 이 함수는 구조체에 의해 네임 스페이스가 지정됩니다. &lt;code&gt;::&lt;/code&gt; 구문은 관련 함수와 모듈에 의해 생성 된 네임 스페이스 모두에 사용됩니다. 7 장에서 모듈에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 특성 을 구현하는 유형으로 만이 코드를 호출 하기 위해 &lt;code&gt;T&lt;/code&gt; 의 특성 범위에 &lt;code&gt;Copy&lt;/code&gt; 를 추가 할 수 있습니다 ! 코드 10-15는 함수에 전달하는 슬라이스의 값 유형이 &lt;code&gt;i32&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 처럼 &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하는 한 컴파일되는 &lt;code&gt;largest&lt;/code&gt; 일반 함수 의 전체 코드를 보여줍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">변경 가능한 참조가 참조하는 값을 변경하려면 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하기 전에 역 참조 연산자 ( &lt;code&gt;*&lt;/code&gt; )를 사용하여 &lt;code&gt;i&lt;/code&gt; 의 값을 가져와야합니다. 15 장의 &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&quot;역 참조 연산자를 사용하여 포인터를 값에 따라 가기&quot;&lt;/a&gt; 섹션 에서 역 참조 연산자에 대해 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="8d0f5fc712b1dc8e53a799fd7ad61e2d58ce4f6e" translate="yes" xml:space="preserve">
          <source>To check the type for the return type of a function with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">Rust가 올바르게 설치되었는지 확인하려면 쉘을 열고 다음 줄을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 을 형식 매개 변수와 결합하려면 &lt;code&gt;PhantomData&lt;/code&gt; 가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">더 자세한 내용을 혼동하기 위해 &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;웹 &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; 및 &lt;code&gt;windows-1252&lt;/code&gt; 는 나머지 공백을 해당 C0 및 C1 제어 코드로 채우는 Windows-1252의 상위 집합에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">이전 상태를 사용하려면 &lt;code&gt;request_review&lt;/code&gt; 메소드가 상태 값의 소유권을 가져와야 합니다. 여기 에서 &lt;code&gt;Post&lt;/code&gt; 의 &lt;code&gt;state&lt;/code&gt; 필드에 &lt;code&gt;Option&lt;/code&gt; 이 나온다 : 우리는 &lt;code&gt;take&lt;/code&gt; 메소드를 호출 하여 &lt;code&gt;state&lt;/code&gt; 필드 에서 &lt;code&gt;Some&lt;/code&gt; 값을 빼고 &lt;code&gt;None&lt;/code&gt; 을 그 자리에 남겨둔다 . 이를 통해 &lt;code&gt;state&lt;/code&gt; 값을 빌리지 않고 &lt;code&gt;Post&lt;/code&gt; 밖으로 옮길 수 있습니다 . 그런 다음 게시물의 &lt;code&gt;state&lt;/code&gt; 값을이 작업의 결과로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">Rust는 모듈에서 인터페이스를 사용할 수 있는지 여부를 제어하기 위해 항목의 각 사용을 검사하여 허용 여부를 확인합니다. 개인 정보 보호 경고가 생성되는 곳입니다. 그렇지 않으면 &quot;다른 모듈의 개인 항목을 사용했지만 허용되지 않았습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">단일 값을 문자열로 변환하려면 &lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 형식 특성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">단일 값을 문자열로 변환하려면 &lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 형식 특성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">음영 처리 된 변수를 도입하지 않고 외부 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 값을 비교 하는 &lt;code&gt;match&lt;/code&gt; 표현식 을 작성하려면 대신 일치 가드 조건을 사용해야합니다. 나중에 &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;&lt;/a&gt; 경비대가있는 추가 조건부&amp;rdquo; 섹션 에서 성냥 대에 대해 이야기하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">새 스레드를 만들려면 &lt;code&gt;thread::spawn&lt;/code&gt; 함수를 호출 하고 새 스레드에서 실행할 코드가 포함 된 클로저 (제 13 장에서 클로저에 대해 이야기했습니다)를 전달합니다. Listing 16-1의 예제는 메인 스레드에서 일부 텍스트를 인쇄하고 새 스레드에서 다른 텍스트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">비어있는 새 벡터를 만들려면 목록 8-1에 표시된 것처럼 &lt;code&gt;Vec::new&lt;/code&gt; 함수를 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">벡터를 생성 한 다음 벡터를 추가하기 위해 &lt;code&gt;push&lt;/code&gt; 방법을 사용할 수 있습니다 ( Listing 8-3 참조).</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 제네릭이지만 다른 유형을 가질 수 있는 &lt;code&gt;Point&lt;/code&gt; 구조체 를 정의하기 위해 여러 제네릭 형식 매개 변수를 사용할 수 있습니다. 예를 들어, 목록 10-8에서 &lt;code&gt;Point&lt;/code&gt; 의 정의를 유형 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 에서 일반으로 변경하고 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형 이고 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;U&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">매크로를 정의하려면 &lt;code&gt;macro_rules!&lt;/code&gt; 구성합니다. &lt;code&gt;macro_rules!&lt;/code&gt; 사용법을 살펴 보자 ! &lt;code&gt;vec!&lt;/code&gt; 가 어떻게 보이는지보고 ! 매크로가 정의됩니다. 8 장에서는 &lt;code&gt;vec!&lt;/code&gt; 어떻게 사용할 수 있는지 설명했습니다 ! 매크로를 사용하여 특정 값으로 새 벡터를 만듭니다. 예를 들어 다음 매크로는 세 개의 정수를 포함하는 새 벡터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">구조체를 정의하기 위해 키워드 &lt;code&gt;struct&lt;/code&gt; 입력 하고 전체 구조체의 이름을 지정합니다. 구조체의 이름은 함께 그룹화되는 데이터 조각의 중요성을 설명해야합니다. 그런 다음 중괄호 안에 &lt;em&gt;필드&lt;/em&gt; 라고하는 데이터의 이름과 유형을 정의 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, 목록 5-1은 사용자 계정에 대한 정보를 저장하는 구조체를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">튜플 구조체를 정의하려면 &lt;code&gt;struct&lt;/code&gt; 키워드와 구조체 이름으로 시작하고 튜플의 유형이 뒤 따릅니다. 예를 들어, &lt;code&gt;Color&lt;/code&gt; 와 &lt;code&gt;Point&lt;/code&gt; 라는 두 튜플 구조체의 정의와 사용법은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 컨텍스트 내에서 함수를 정의 하기 위해 &lt;code&gt;impl&lt;/code&gt; (구현) 블록을 시작합니다 . 그런 다음 &lt;code&gt;area&lt;/code&gt; 함수를 &lt;code&gt;impl&lt;/code&gt; 중괄호 내에서 이동하고 첫 번째 (이 경우에만) 매개 변수를 서명 &lt;code&gt;self&lt;/code&gt; 와 본문 내 임의의 위치로 변경합니다. 에서 &lt;code&gt;main&lt;/code&gt; 우리가 호출 된 경우, &lt;code&gt;area&lt;/code&gt; 기능과 통과 &lt;code&gt;rect1&lt;/code&gt; 인수로를, 우리는 대신 사용할 수있는 &lt;em&gt;방법 구문을&lt;/em&gt; 부르는하기 위해 &lt;code&gt;area&lt;/code&gt; 우리의 방법을 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스입니다. 메소드 구문은 인스턴스를 따릅니다. 점 뒤에 메소드 이름, 괄호 및 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">테스트 서브 세트를 실행하는 방법을 보여주기 위해 Listing 11-11에 표시된 것처럼 &lt;code&gt;add_two&lt;/code&gt; 함수에 대해 세 가지 테스트를 작성하고 실행할 테스트를 선택한다.</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">시연을 위해 1에서 5까지만 계산되는 반복자를 만들어 봅시다. 먼저, 일부 값을 보유하는 구조체를 만듭니다. 그런 다음 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하고 해당 구현의 값을 사용 하여이 구조체를 반복자로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 값 에 할당 할 공간의 양을 결정하기 위해 Rust는 각 변형을 검토하여 가장 많은 공간이 필요한 변형을 확인합니다. Rust는 &lt;code&gt;Message::Quit&lt;/code&gt; 공간이 필요하지 않고 &lt;code&gt;Message::Move&lt;/code&gt; 두 개의 &lt;code&gt;i32&lt;/code&gt; 값 등 을 저장하기에 충분한 공간이 필요하다는 것을 알았습니다 . 하나의 변형 만 사용되므로 &lt;code&gt;Message&lt;/code&gt; 값에 가장 필요한 공간은 가장 큰 변형을 저장하는 데 필요한 공간입니다.</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">있는지 확인하려면 &lt;code&gt;T&lt;/code&gt; 가 있다 &lt;code&gt;Foo&lt;/code&gt; , 우리는 있는지 확인해야 할 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;Foo&lt;/code&gt; . 그러나이 검사를 수행하려면 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 인지 확인해야합니다 . 이를 결정하기 위해 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 등 인지 확인합니다 . 이것은 직접적으로 해결할 수없는 재귀 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">에 의해 표현되는 초 총 수를 확인하려면 &lt;code&gt;Duration&lt;/code&gt; , 사용 &lt;code&gt;as_secs&lt;/code&gt; 와 함께 &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">에 의해 표현되는 초 총 수를 확인하려면 &lt;code&gt;Duration&lt;/code&gt; , 사용 &lt;code&gt;as_secs&lt;/code&gt; 와 함께 &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">루프 또는 반복자를 사용할지 여부를 판별하려면 명시적인 &lt;code&gt;for&lt;/code&gt; 루프 가 있는 버전 또는 반복자가있는 버전 인 &lt;code&gt;search&lt;/code&gt; 기능의 버전이 더 빠른지 알아야 합니다.</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">Rust에게 우리가 &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; 구현을 사용하고 싶다고 명확하게 말하려면 정규화 된 구문을 사용해야합니다. Listing 19-21은 정규화 된 구문을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">상속 된 언어로이를 수행하기 위해 &lt;code&gt;draw&lt;/code&gt; 라는 메서드가있는 &lt;code&gt;Component&lt;/code&gt; 라는 클래스를 정의 할 수 있습니다 . &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Image&lt;/code&gt; 및 &lt;code&gt;SelectBox&lt;/code&gt; 와 같은 다른 클래스 는 &lt;code&gt;Component&lt;/code&gt; 에서 상속하므로 &lt;code&gt;draw&lt;/code&gt; 메서드 를 상속합니다 . 이들은 각각 &lt;code&gt;draw&lt;/code&gt; 메소드를 재정 의하여 사용자 정의 동작을 정의 할 수 있지만 프레임 워크는 모든 유형을 마치 &lt;code&gt;Component&lt;/code&gt; 인스턴스 처럼 취급하고 &lt;code&gt;draw&lt;/code&gt; 를 호출 할 수 있습니다. 그러나 Rust에는 상속이 없으므로 사용자가 새로운 유형으로 확장 할 수 있도록 &lt;code&gt;gui&lt;/code&gt; 라이브러리를 구성하는 다른 방법이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">복제 특성을 쉽게 구현하기 위해 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 사용할 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">이 중복을 제거하기 위해 매개 변수에 지정된 정수 목록에서 작동하는 함수를 정의하여 추상화를 작성할 수 있습니다. 이 솔루션을 사용하면 코드가 명확 해지고 목록에서 가장 큰 숫자를 찾는 개념을 추상적으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">&lt;code&gt;minigrep&lt;/code&gt; 이 전달하는 명령 행 인수의 값을 읽을 수있게하려면 Rust의 표준 라이브러리에 제공되는 함수 인 &lt;code&gt;std::env::args&lt;/code&gt; 합니다. 이 함수는 &lt;code&gt;minigrep&lt;/code&gt; 에 제공된 명령 행 인수의 반복자를 리턴합니다 . &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; 에서 반복자를 완전히 다룰 것 입니다. 지금은 반복자에 대한 두 가지 세부 사항 만 알아야합니다. 반복자는 일련의 값을 생성하며 반복자에서 &lt;code&gt;collect&lt;/code&gt; 메소드를 호출 하여 반복자가 생성하는 모든 요소를 ​​포함하는 벡터와 같은 콜렉션으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">다중 소유권을 가능하게하기 위해 Rust에는 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 라는 유형 이 있으며 이는 &lt;em&gt;참조 횟수 계산&lt;/em&gt; 의 약어입니다 . &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 유형 값이 아직 사용 여부를 결정하는 값에 대한 참조 수를 추적한다. 값에 대한 참조가없는 경우 참조가 유효하지 않게 값을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">야간 버전의 rustc에서이 기능을 사용하려면 &lt;code&gt;const_fn&lt;/code&gt; 기능 플래그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">메모리 안전을 보장하기 위해 Rust에서이 상황에서 발생하는 일에 대해 더 자세히 설명합니다. Rust는 할당 된 메모리를 복사하는 대신 &lt;code&gt;s1&lt;/code&gt; 이 더 이상 유효하지 않다고 간주 하므로 &lt;code&gt;s1&lt;/code&gt; 이 범위를 벗어날 때 아무것도 해제 할 필요가 없습니다 . &lt;code&gt;s2&lt;/code&gt; 가 작성된 후 &lt;code&gt;s1&lt;/code&gt; 을 사용하려고 할 때 어떤 일이 발생하는지 확인하십시오 . 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="translated">건전성을 보장하기 위해 Safe Rust는 자동으로 확인할 수있을만큼 제한됩니다. 그러나 때때로 컴파일러가 이해하기에는 너무 영리한 이유로 올바른 코드를 작성해야합니다. 이 경우 Unsafe Rust를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">기존 코드를 손상시키지 않고 유형을 확장하려면</target>
        </trans-unit>
        <trans-unit id="7b84fa9a4a555e1a74d29f79dcd3abb8731f5940" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of if branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ddccf4caea85a4bf8ac030a69155b2d937a94" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of match arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd607b32ed771d3a582f20b6ce2e41a23d6c8021" translate="yes" xml:space="preserve">
          <source>To find the common type for array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">두 개의 서로 다른 숫자 목록에서 가장 큰 숫자를 찾으려면 목록 10-1에서 코드를 복제하고 목록 10-2에 표시된 것처럼 프로그램의 서로 다른 두 위치에서 동일한 논리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886ceb6ce4fcd41c44c60891b1e238be8050a3e5" translate="yes" xml:space="preserve">
          <source>To find the type for the return type of a closure with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">이러한 코드를 수정하려면 extern &quot;C&quot;블록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">Listing 16-3에서 컴파일러 오류를 수정하기 위해 오류 메시지의 조언을 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="translated">문제를 해결하려면 패턴을 제거하십시오 ( &lt;code&gt;_&lt;/code&gt; 는 허용됨). 예:</target>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="translated">문제를 해결하려면 중복 선언을 제거하세요.</target>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="translated">이전 코드 예제를 수정하기 위해 &lt;code&gt;PartialEq&lt;/code&gt; 및 &lt;code&gt;Eq&lt;/code&gt; 를 파생합니다 .</target>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">우리가 반박 할 수없는 패턴이 필요로하는 논박 패턴이 문제를 해결하려면, 우리는 패턴을 사용하는 코드를 변경할 수 있습니다 대신에 사용하는 &lt;code&gt;let&lt;/code&gt; , 우리가 사용할 수있는 &lt;code&gt;if let&lt;/code&gt; . 그런 다음 패턴이 일치하지 않으면 코드는 중괄호 안에있는 코드를 건너 뛰어 계속 진행할 수있는 방법을 제공합니다. 코드 18-9는 코드 18-8에서 코드를 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">문제를 해결하려면 알 수없는 메타 항목을 제거하거나 이름이 잘못된 경우 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">문제를 해결하려면 동일한 키를 가진 메타 항목 중 하나를 제외한 모든 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">이 문제를 해결하고 반복자를 사용하기 &lt;code&gt;collect&lt;/code&gt; 12 장에서 &lt;code&gt;env::args&lt;/code&gt; 와 함께 사용하는 collect 메소드를 사용합니다 ( 목록 12-1). 이 메소드는 반복자를 사용하고 결과 값을 콜렉션 데이터 유형으로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt; 를 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;main&lt;/code&gt; 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="translated">이 오류를 수정하려면 누락 된 숫자를 추가하세요.</target>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="translated">이 오류를 수정하려면 문자열 끝에 누락 된 큰 따옴표를 추가하세요.</target>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="translated">이 오류를 수정하려면 누락 된 따옴표를 추가하세요.</target>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">이 오류를 해결하려면 필드 이름의 철자가 틀리지 않았거나 필드가 실제로 존재하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="translated">이 오류를 수정하려면 TrustZone-M 확장을 지원하는 Rust 대상에 대한 코드를 컴파일하십시오. 현재 가능한 대상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;mut&lt;/code&gt; 키워드 를 사용하여 &lt;code&gt;ss&lt;/code&gt; 를 mutable로 선언 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 를 사용하여 C ABI로 입력 함수를 선언하세요 .</target>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">이 오류를 해결하려면 얇은 포인터와 뚱뚱한 포인터 사이에 직접 캐스트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="translated">이 오류를 수정하려면 예상 수명을 줄이거 나 현재 범위 밖에서이 참조를 사용할 필요가없는 방법을 찾으십시오 (예를 들어 동일한 블록에서 직접 코드를 실행하는 방법?).</target>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">이 오류를 해결하려면 여러 개의 일치 암으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="translated">이 오류를 수정하려면 구조체 정의의 각 필드가 패턴에 언급되어 있는지 확인하거나 &lt;code&gt;..&lt;/code&gt; 을 사용 하여 원하지 않는 필드를 무시하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">이 오류를 해결하려면 변수에 변경하기 전에 변수에 대한 다른 참조가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">이 오류를 해결하려면 일치 팔 종류가 일치하는 표현식과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">이 오류를 해결하려면 다음 중 하나를 가리지 않도록 바인딩 이름을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">이 오류를 해결하려면 변수 유형을 지정하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">이 오류를 해결하려면 두 경우 모두 동일한 모드를 사용하십시오. 일반적으로 아직 사용되지 않은 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 를 사용하면이 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="translated">이 오류를 수정하려면 모듈이 범위 내에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">이 오류를 해결하려면이 유형이 이진 연산을 구현하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">이 오류를 해결하려면 구조체의 모든 필드가 공용인지 확인하거나 쉽게 인스턴스화 할 수있는 기능을 구현하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">이 오류를 해결하려면 유형에 특성을 구현하거나 구조체로 감싸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">이 오류를 해결하려면 필요하지 않은 가시성 한정자를 제거하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">이 오류를 해결하려면 값을 상수로 바꾸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">이 오류를 해결하려면 메소드 이름의 철자가 틀리지 않았는지 확인하고 올바른 특성 항목을 실제로 구현했는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">이 오류를 해결하려면 형식 이름의 철자가 틀리지 않았는지 확인하고 선언하거나 범위로 가져 오십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="translated">이 오류를 수정하려면 null 문자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="translated">이 오류를 수정하려면 패턴 인수를 일반 인수로 바꾸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="translated">이 오류를 수정하려면 const 매개 변수에 구체적인 유형을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;Sea&lt;/code&gt; 모듈 내부에서 &lt;code&gt;Shark&lt;/code&gt; 구조체 를 이동해야 합니다.</target>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;create_some&lt;/code&gt; 을 상수 함수로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">이 오류를 해결하려면 캡처 된 변수를 사용하기 전에 클로저 사용을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="translated">이 오류를 수정하려면 튜플 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="translated">이 오류를 수정하려면 &lt;code&gt;async&lt;/code&gt; 블록 에서 &lt;code&gt;yield&lt;/code&gt; 를 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="translated">이 오류를 수정하려면 두 가지 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">이 오류를 해결하려면 모든 상위 구현을 기본값으로 표시해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">이 문제를 해결하려면 인수에서 수명을 사용하거나 &lt;code&gt;'static&lt;/code&gt; 을 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="translated">이 문제를 해결하려면 인수에 수명을 사용하거나 &lt;code&gt;'static&lt;/code&gt; 수명. 예:</target>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">이 문제를 해결하려면 입력에서 수명을 사용하거나 &lt;code&gt;'static&lt;/code&gt; 을 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="translated">이 문제를 해결하려면 제네릭을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">이 문제를 해결하려면 return 키워드를 제거하거나 표현식을 함수로 옮기십시오. 예:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="translated">이 문제를 해결하려면 수퍼 트레이 트를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="translated">이 문제를 해결하려면 const 제네릭의 수명을 &lt;code&gt;'static&lt;/code&gt; 으로 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">이 문제를 해결하려면 두 가져 오기 중 적어도 하나의 이름을 바꿔야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">이 문제를 해결하기 위해 스레드가 &lt;code&gt;Job&lt;/code&gt; 실행 을 수신 대기하거나 수신 대기를 중지하고 무한 루프를 종료해야한다는 신호를 수신하도록 스레드를 수정합니다 . &lt;code&gt;Job&lt;/code&gt; 인스턴스 대신 채널에서이 두 가지 열거 형 변형 중 하나를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">이 문제를 해결하려면 다음 중 하나를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">이 문제를 해결하려면 임시에 의존하지 않고 값을 저장할 로컬 변수를 작성해야합니다. 예를 들어, 원래 프로그램을 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="translated">이 문제를 해결하려면 함수 또는 impl 수준에서 수명을 정의하고 &lt;code&gt;impl Trait&lt;/code&gt; 에서 해당 수명을 사용해야합니다 . 예를 들어 함수에서 수명을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="translated">이 문제를 해결하려면 레이블이 지정된 블록을 올바르게 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">이 문제를 해결하려면 어떤 루프가 끊어 졌는지 지정하는 레이블을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">이 문제를 해결하려면 특성에서 각 기본 메소드에 대한 구현을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;adder&lt;/code&gt; 상자에 대한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 편집하고 &lt;code&gt;rand&lt;/code&gt; 도 해당 상자에 대한 종속성 임을 나타냅니다 . 건물 &lt;code&gt;adder&lt;/code&gt; 상자이 부가됩니다 &lt;code&gt;rand&lt;/code&gt; 에 대한 종속성 목록에 &lt;code&gt;adder&lt;/code&gt; 에 &lt;em&gt;Cargo.lock&lt;/em&gt; 만의 추가 사본 &lt;code&gt;rand&lt;/code&gt; 다운로드되지 않습니다. 화물은 &lt;code&gt;rand&lt;/code&gt; 크레이트를 사용하는 작업 공간의 모든 크레이트 가 동일한 버전을 사용하도록 보장했습니다 . 작업 공간 에서 동일한 버전의 &lt;code&gt;rand&lt;/code&gt; 를 사용하면 사본이 여러 개 없기 때문에 작업 공간의 상자가 서로 호환되므로 공간이 절약됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;adder&lt;/code&gt; 패키지 의 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 편집하고 &lt;code&gt;rand&lt;/code&gt; 도 이에 대한 종속성 임을 표시하십시오 . &lt;code&gt;adder&lt;/code&gt; 패키지를 빌드하면 &lt;em&gt;Cargo.lock의 &lt;/em&gt; &lt;code&gt;adder&lt;/code&gt; 에 대한 종속성 목록에 &lt;code&gt;rand&lt;/code&gt; 가 추가 되지만 &lt;code&gt;rand&lt;/code&gt; 의 추가 사본은 다운로드 되지 않습니다 . Cargo는 &lt;code&gt;rand&lt;/code&gt; 패키지를 사용하는 작업 공간의 모든 패키지에있는 모든 상자 가 동일한 버전을 사용하도록했습니다. 작업 공간 전체 에서 동일한 버전의 &lt;code&gt;rand&lt;/code&gt; 를 사용하면 여러 개의 복사본이없고 작업 공간의 상자가 서로 호환 될 수 있으므로 공간이 절약됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">이 문제를 해결하려면 외부 참조를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">이 문제를 해결하려면 선언 된 변수를 사용하기 전에 초기화해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">이 문제를 해결하려면 이름의 철자가 정확하고 올바른 형식의 이니셜 라이저가 사용되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">이 문제를 해결하려면 type 매개 변수를 사용하여 메서드를 호출하지 않으려는 경우 위의 하위 오류에 대한 수정과 비슷한 &lt;code&gt;where Self: Sized&lt;/code&gt; bound 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">이 문제를 해결하려면 다음 열거 형 값을 수동으로 설정하거나 열거 형 끝 부분에 열거 형 변형을 최대 값으로 설정하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">이 문제를 해결하려면 일반 매개 변수를 필요한 특수화로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">이 문제를 해결하기 위해 값을 const로 추출한 다음 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; 를 구현 하고 다음과 같이 &lt;code&gt;OutlinePrint&lt;/code&gt; 에 필요한 제약 조건을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">이 문제를 해결하려면 반환 유형에서 수명 &lt;code&gt;'x&lt;/code&gt; 를 참조해야합니다 . 예를 들어 반환 유형을 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; 하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7f876767b17c3198e0a111feeef857c2ed3d8806" translate="yes" xml:space="preserve">
          <source>To forcibly capture a backtrace regardless of environment variables, use the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">사용자가 숫자가 아닌 숫자를 입력 할 때 프로그램을 중단시키지 않고 게임의 동작을 더 세분화하기 위해, 숫자가 아닌 숫자를 무시하고 게임을 계속해서 추측 할 수 있습니다. Listing 2-5와 같이 &lt;code&gt;guess&lt;/code&gt; 이 &lt;code&gt;String&lt;/code&gt; 에서 &lt;code&gt;u32&lt;/code&gt; 로 변환되는 행을 변경하여이를 수행 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 가변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; 메서드를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; 메서드를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">상자 값에 대한 포인터를 얻으려면 상자를 역 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">구조체에서 특정 값을 얻으려면 점 표기법을 사용할 수 있습니다. 이 사용자의 전자 메일 주소 만 원하면이 값을 사용 &lt;code&gt;user1.email&lt;/code&gt; 모든 위치에서 user1.email을 사용할 수 있습니다 . 인스턴스가 변경 가능한 경우 점 표기법을 사용하고 특정 필드에 할당하여 값을 변경할 수 있습니다. Listing 5-3은 변경 가능한 &lt;code&gt;User&lt;/code&gt; 인스턴스 의 &lt;code&gt;email&lt;/code&gt; 필드 에서 값을 변경하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 불변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 불가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 불가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 불변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 불가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 불가능한 문자열 슬라이스를 얻으려면 &lt;a href=&quot;primitive.str#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 가변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 가능한 문자열 조각을 얻으려면 &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 메서드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 변경 가능한 문자열 조각을 얻으려면 &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 메서드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">이것을 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 을&lt;/a&gt; 사용해야 합니다. 이 두 컬렉션은 일반적인 데이터 저장 및 처리에 대한 대부분의 사용 사례를 다룹니다. 그들은 그들이하는 일을 매우 잘합니다. 표준 라이브러리의 다른 모든 컬렉션에는 최적의 선택 인 특정 사용 사례가 있지만 이러한 경우는 경계선의 &lt;em&gt;틈새&lt;/em&gt; 입니다. &lt;code&gt;Vec&lt;/code&gt; 과 &lt;code&gt;HashMap&lt;/code&gt; 이 기술적으로 차선책 일지라도 시작하기에 충분한 선택 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">오류 사례를 처리하고 사용자에게 친숙한 메시지를 인쇄하려면 목록 12-10에 표시된대로 &lt;code&gt;Config::new&lt;/code&gt; 에서 반환되는 &lt;code&gt;Result&lt;/code&gt; 를 처리하도록 &lt;code&gt;main&lt;/code&gt; 을 업데이트해야합니다 . 또한 &lt;code&gt;panic!&lt;/code&gt; 에서 0이 아닌 오류 코드로 명령 행 도구를 종료해야 할 책임이 있습니다 ! 손으로 구현하십시오. 0이 아닌 종료 상태는 프로그램이 오류 상태로 종료되었음을 프로그램이라고하는 프로세스에 알리는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">IDE 통합을 돕기 위해 Rust 프로젝트는 &lt;em&gt;Rust Language Server&lt;/em&gt; ( &lt;code&gt;rls&lt;/code&gt; )를 배포합니다 . 이 도구는 IDE와 프로그래밍 언어가 서로 통신하기위한 사양 인 &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol을&lt;/a&gt; 말합니다 . 다른 클라이언트는 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code 용 Rust 플러그인&lt;/a&gt; 과 같은 &lt;code&gt;rls&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">환경을 캡처 할 수있는 클로저가 함수 매개 변수로 유용한 상황을 설명하기 위해 다음 주제 인 반복자 (iterator)로 넘어가겠습니다.</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">소유권 규칙을 설명하기 위해, 우리는 3 장의 &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;데이터 유형&quot;&lt;/a&gt; 섹션 에서 다루었던 것보다 복잡한 데이터 유형이 필요합니다. 이전에 다룬 유형은 모두 스택에 저장되고 해당 범위에서 스택에서 튀어 나옵니다. 끝났지 만 힙에 저장된 데이터를보고 Rust가 해당 데이터를 정리할시기를 어떻게 알고 있는지 조사하려고합니다.</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">&lt;code&gt;gui&lt;/code&gt; 에 원하는 동작을 구현하기 위해 &lt;code&gt;draw&lt;/code&gt; 라는 메소드가있는 &lt;code&gt;Draw&lt;/code&gt; 라는 특성을 정의합니다 . 그런 다음 &lt;em&gt;특성 객체&lt;/em&gt; 를 취하는 벡터를 정의 할 수 있습니다 . 특성 객체는 지정된 특성을 구현하는 유형의 인스턴스와 런타임시 해당 유형의 특성 메소드를 찾는 데 사용되는 테이블을 모두 가리 킵니다. &lt;code&gt;&amp;amp;&lt;/code&gt; reference 또는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터 와 같은 일종의 포인터 를 지정하고 &lt;code&gt;dyn&lt;/code&gt; 키워드를 지정한 다음 관련 특성을 지정하여 특성 개체를 만듭니다 . (특징 객체가 &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&quot;동적 크기의 유형과&lt;/a&gt; &quot; 섹션의 19 장에서 포인터를 사용해야하는 이유에 대해 설명합니다&lt;em&gt;&lt;/em&gt; &lt;code&gt;Sized&lt;/code&gt; 특성.&quot; ) 일반 또는 콘크리트 유형 대신 특성 객체를 사용할 수 있습니다. 우리가 형질 오브젝트를 사용하는 곳마다 Rust의 타입 시스템은 컴파일시에 해당 컨텍스트에 사용 된 모든 값이 형질 오브젝트의 특성을 구현하도록 보장합니다. 결과적으로 컴파일 타임에 가능한 모든 유형을 알 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">프로그램을 개선하기 위해 프로그램 구조와 관련된 네 가지 문제와 잠재적 오류를 처리하는 방법을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 열거 형 을 통합하려면 &lt;code&gt;ThreadPool&lt;/code&gt; 정의 와 &lt;code&gt;Worker::new&lt;/code&gt; 서명 두 위치에서 &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; 를 변경해야합니다 . &lt;code&gt;ThreadPool&lt;/code&gt; 의 &lt;code&gt;execute&lt;/code&gt; 메소드 는 &lt;code&gt;Message::NewJob&lt;/code&gt; 변형으로 랩핑 된 작업을 보내야 합니다. 그런 다음에 &lt;code&gt;Worker::new&lt;/code&gt; 여기서 &lt;code&gt;Message&lt;/code&gt; 경우 생성 채널로부터 수신되고, 작업을 처리한다 &lt;code&gt;NewJob&lt;/code&gt; 의 변이체를 수신하고, 만약 쓰레드가 루프를 탈출한다 &lt;code&gt;Terminate&lt;/code&gt; 변이체가 수신된다.</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">&lt;code&gt;rustfmt&lt;/code&gt; 를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">Clippy를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">&lt;code&gt;rls&lt;/code&gt; 를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Formatter&lt;/code&gt; 와 상호 작용 하기 위해 다양한 메서드를 호출하여 형식과 관련된 다양한 옵션을 변경합니다. 예를 들어, 아래의 &lt;code&gt;Formatter&lt;/code&gt; 정의 된 메소드의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">안전하지 않은 코드를 가능한 많이 격리하려면 안전하지 않은 코드를 안전한 추상화 내에 포함하고 안전한 API를 제공하는 것이 가장 좋습니다. 안전하지 않은 기능 및 방법을 검사 할 때이 장의 뒷부분에서 설명합니다. 표준 라이브러리의 일부는 감사 된 안전하지 않은 코드에 대한 안전한 추상화로 구현됩니다. 안전하지 않은 코드를 안전한 추상화로 감싸면 안전한 추상화 를 사용하는 것이 안전하기 때문에 &lt;code&gt;unsafe&lt;/code&gt; 코드 사용으로 안전 하지 않은 코드로 구현 된 기능을 사용하려는 모든 위치로 &lt;code&gt;unsafe&lt;/code&gt; 사용이 유출되는 것을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리에서 제공하는 다른 종류의 컬렉션에 대한 자세한 내용 &lt;a href=&quot;../std/collections/index&quot;&gt;은 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="translated">액세스 허용에 대한 자세한 내용은 &lt;a href=&quot;keyword.pub&quot;&gt; &lt;code&gt;pub&lt;/code&gt; &lt;/a&gt; 키워드에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 소문자로 &lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; 려면 to_lowercase를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 소문자로 만들려면 &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 소문자로하려면 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적절한 위치에 값을 소문자로 만들려면 &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적절한 위치에 값을 소문자로 만들려면 &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에서 값을 소문자로 지정하려면 &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에서 값을 소문자로 지정하려면 &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에서 값을 소문자로 지정하려면 &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에서 값을 소문자로 지정하려면 &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에 값을 소문자로 지정하려면 &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제자리에서 값을 소문자로 지정하려면 &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">클로저를 보유한 구조체를 만들려면 구조체 정의가 각 필드의 타입을 알아야하기 때문에 클로저의 타입을 지정해야합니다. 각 클로저 인스턴스에는 고유 한 익명 유형이 있습니다. 즉, 두 클로저의 서명이 동일하더라도 해당 유형은 여전히 ​​다른 것으로 간주됩니다. 클로저를 사용하는 구조체, 열거 형 또는 함수 매개 변수를 정의하기 위해 10 장에서 설명한 것처럼 제네릭과 특성 경계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">유효하게하려면 다음을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">struct &lt;code&gt;Bar&lt;/code&gt; 만 모듈 &lt;code&gt;foo&lt;/code&gt; 에서만 보이게 하려면 &lt;code&gt;in&lt;/code&gt; 키워드를 사용해야합니다 :</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">자식 노드가 부모를 인식하게하려면 &lt;code&gt;Node&lt;/code&gt; 구조체 정의에 &lt;code&gt;parent&lt;/code&gt; 필드를 추가해야합니다 . 문제는 &lt;code&gt;parent&lt;/code&gt; 의 유형을 결정하는 데 있습니다. 우리는 그것이 포함 할 수 없습니다 알고 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 그와 참조주기 만들 것이기 때문에, &lt;code&gt;leaf.parent&lt;/code&gt; 가리키는 &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;branch.children&lt;/code&gt; 가리키는 &lt;code&gt;leaf&lt;/code&gt; 그 원인이, &lt;code&gt;strong_count&lt;/code&gt; 의 값을 결코 0이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">이 작업을 수행하기 위해 모든 요소에는 목록에있는 선행 및 후속 항목에 대한 포인터가 있습니다. 요소를 이동하면 포인터가 무효화되므로 요소가 고정 된 경우에만 추가 할 수 있습니다. 더욱이, 연결 목록 요소 의 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현은 이전 및 후속 요소의 포인터를 패치하여 목록에서 자신을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">이 작업을 수행하기 위해 모든 요소에는 목록의 선행 작업 및 후속 작업에 대한 포인터가 있습니다. 요소를 이동하면 포인터가 무효화되므로 요소를 고정 할 때만 요소를 추가 할 수 있습니다. 또한, 연결된 목록 요소 의 &lt;code&gt;Drop&lt;/code&gt; 구현은 이전 및 후속 작업의 포인터를 패치하여 목록에서 자신을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">많은 사람들에게 다형성은 상속과 동의어입니다. 그러나 실제로는 여러 유형의 데이터를 처리 할 수있는 코드를 나타내는보다 일반적인 개념입니다. 상속을 위해 이러한 유형은 일반적으로 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">경과 시간을 안정적으로 측정하려면 대신 &lt;a href=&quot;struct.instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">FFI에서 불투명 한 유형에 대한 포인터를 모델링하려면 &lt;code&gt;extern type&lt;/code&gt; 이 안정화 될 때까지 빈 바이트 배열 주위에 newtype 래퍼를 사용하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">문자열로 오류 설명을 얻으려면 &lt;code&gt;to_string()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">정의 할 새 함수에서 유형을 매개 변수화하려면 값 매개 변수를 함수에 지정하는 것처럼 유형 매개 변수의 이름을 지정해야합니다. 식별자를 형식 매개 변수 이름으로 사용할 수 있습니다. 그러나 우리는 Rust의 매개 변수 이름이 짧고 종종 문자 일 뿐이며 Rust의 형식 명명 규칙이 CamelCase이기 때문에 &lt;code&gt;T&lt;/code&gt; 를 사용 합니다. &quot;type&quot;의 &lt;code&gt;T&lt;/code&gt; 는 대부분의 Rust 프로그래머가 선택하는 기본입니다.</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">경로를 파싱하기 위해 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 슬라이스 에서 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 슬라이스를 생성하고 질문을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">경로를 구문 분석하려면 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 슬라이스 에서 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 슬라이스를 만들고 질문을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 인수를 전달하려면 &lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 인수를 전달하려면 &lt;a href=&quot;struct.command#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 인수를 전달하려면 &lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 인수를 전달하려면 &lt;a href=&quot;struct.command#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="translated">비동기 재귀를 수행하려면 &lt;code&gt;Future&lt;/code&gt; 가 반환 유형에 명시 되도록 &lt;code&gt;async fn&lt;/code&gt; 을 desugared해야 합니다.</target>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">이 시나리오를 방지하기 위해 먼저 모든 &lt;code&gt;Terminate&lt;/code&gt; 메시지를 채널의 루프에 넣습니다 . 그런 다음 다른 루프의 모든 스레드를 결합합니다. 각 작업자는 종료 메시지를 받으면 채널에서 요청 수신을 중지합니다. 따라서 워커와 동일한 수의 종료 메시지를 보내면 스레드에서 &lt;code&gt;join&lt;/code&gt; 이 호출 되기 전에 각 워커가 종료 메시지를 받게됩니다 .</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">이런 종류의 취약점으로부터 프로그램을 보호하기 위해 존재하지 않는 인덱스에서 요소를 읽으려고하면 Rust는 실행을 중지하고 계속을 거부합니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">중독 된 뮤텍스를 복구하려면 :</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">공개 API에서 내부 조직을 제거하기 위해 Listing 14-5에서와 같이 &lt;code&gt;pub use&lt;/code&gt; 문을 추가 하여 항목을 최상위 레벨로 다시 내보내도록 Listing 14-3 의 &lt;code&gt;art&lt;/code&gt; 크레이트 코드를 수정할 수있다 .</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">모호성을 해결하기 위해 프로그래머는보다 구체적인 경로, 유형 또는 특성을 사용하여 원하는 방법 또는 기능을 참조 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
