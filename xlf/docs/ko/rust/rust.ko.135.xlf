<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="translated">패턴이 &lt;code&gt;let&lt;/code&gt; 문이 연장 패턴 다음 초기화 표현의 임시 범위가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="973c0cc5d4929bc5f421c4d51b3af832d7dcc650" translate="yes" xml:space="preserve">
          <source>If the pattern is a slice of chars, split on each occurrence of any of the characters:</source>
          <target state="translated">패턴이 문자 조각 인 경우 문자가 나타날 때마다 분할합니다.</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">술어가 true이면, &lt;code&gt;cfg&lt;/code&gt; 속성 이없는 것으로 재 작성됩니다 . 술어가 false 인 경우 소스 코드에서 해당 내용이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">프로세스가 신호에 의해 종료 된 경우 해당 신호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 과도하게 제한하는 경우 정적 유형 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본값은 &lt;code&gt;f64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본적으로 부호있는 32 비트 정수 &lt;code&gt;i32&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">프로그램 경로가 상대적인 경우 (예 : &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ) 부모의 작업 디렉토리 또는 &lt;code&gt;current_dir&lt;/code&gt; 과 관련하여 해석해야하는지 모호합니다 . 이 경우의 동작은 플랫폼에 따라 다르고 불안정하므로 &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; 프로그램 을 사용 하여 절대 프로그램 경로를 얻는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">수신기 입력이있는 경우 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , 그 다음에 기준의 수명 &lt;code&gt;Self&lt;/code&gt; 모두 생략 된 출력 유효 기간 파라미터에 할당된다.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">반복이 0 번 일치 할 수 있으면 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; ), 이후에 오는 것은 무엇이든 따라 올 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">반복이 여러 번 반복 될 수있는 경우 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; ) 내용이 스스로 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">반복에 구분 기호가 포함 된 경우 해당 구분 기호는 반복 내용을 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">이 방법의 결과가 동일한 아키텍처에 의해서만 조작된다면, 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 합니다. 반환 값이 &lt;code&gt;0&lt;/code&gt; 이면 일반적으로 기본 개체가 더 이상 바이트를 받아 들일 수 없으며 앞으로는 더 이상 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">반환 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt; 이 보장되어야합니다 . 반환 값 &lt;code&gt;0&lt;/code&gt; 은 일반적으로 기본 개체가 더 이상 바이트를받을 수없고 앞으로도 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">이 메소드의 리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 보장되어야합니다 . &lt;code&gt;n&lt;/code&gt; 이 아닌 n 값은 버퍼 &lt;code&gt;buf&lt;/code&gt; 가이 소스의 &lt;code&gt;n&lt;/code&gt; 바이트 데이터 로 채워 졌음을 나타냅니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 경우 두 시나리오 중 하나를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">탐색 작업이 성공적으로 완료되면이 메서드는 스트림 시작 부분에서 새 위치를 반환합니다. 이 위치는 나중에 &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 항목이 업데이트되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">세트에이 값이 없으면 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">슬라이스가 &lt;code&gt;suffix&lt;/code&gt; 끝나지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">슬라이스가 &lt;code&gt;prefix&lt;/code&gt; 시작하지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">슬라이스가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나는 경우 &lt;code&gt;Some&lt;/code&gt; 에 래핑 된 접미사 앞의 하위 슬라이스를 반환합니다 . &lt;code&gt;suffix&lt;/code&gt; 가 비어 있으면 원래 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">슬라이스가 &lt;code&gt;size&lt;/code&gt; 보다 짧은 경우 :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">슬라이스가 정렬되면 첫 번째로 반환 된 슬라이스에 중복이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">슬라이스가로 시작하는 경우 &lt;code&gt;prefix&lt;/code&gt; 에 싸여 접두사 후 subslice 반환 &lt;code&gt;Some&lt;/code&gt; . 경우 &lt;code&gt;prefix&lt;/code&gt; 비어, 단순히 원래의 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">소켓이 연결되어 있지 않으면 &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; 오류 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 끝나지 않는 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문자열이 &lt;code&gt;suffix&lt;/code&gt; 끝나지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 시작하지 않으면 &lt;code&gt;prefix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문자열이 &lt;code&gt;prefix&lt;/code&gt; 시작하지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">패턴과 문자열의 끝 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;Some&lt;/code&gt; 접미사가 제거 된 문자열로 반환됩니다. &lt;code&gt;trim_end_matches&lt;/code&gt; 와 달리 메서드는 접미사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">문자열이 &lt;code&gt;suffix&lt;/code&gt; 패턴으로 끝나는 경우 &lt;code&gt;Some&lt;/code&gt; 에 래핑 된 접미사 앞의 하위 문자열을 반환합니다 . &lt;code&gt;trim_end_matches&lt;/code&gt; 와 달리이 메서드는 접미사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">문자열이 &lt;code&gt;prefix&lt;/code&gt; 패턴으로 시작 하면 &lt;code&gt;Some&lt;/code&gt; 은 접두사가 제거 된 부분 문자열과 함께 반환됩니다. &lt;code&gt;trim_start_matches&lt;/code&gt; 와 달리 메서드는 접두사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">문자열이 &lt;code&gt;prefix&lt;/code&gt; 패턴으로 시작하면 &lt;code&gt;Some&lt;/code&gt; 에 래핑 된 접두사 뒤의 부분 문자열을 반환합니다 . &lt;code&gt;trim_start_matches&lt;/code&gt; 와 달리이 메서드는 접두사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 특성 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어진 경우 해당 유형의 객체를 확실히 반환 하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">특성 &lt;code&gt;Trait&lt;/code&gt; 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어 졌기 때문에 괜찮습니다. 형식이 해당 형식의 개체를 확실히 반환 .</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">특성에 수명 한계가없는 경우 수명은 표현식에서 유추되며 &lt;code&gt;'static&lt;/code&gt; 표현식 외부에서 정적 입니다.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">특성이 단일 수명 &lt;em&gt;한계&lt;/em&gt; 로 정의 &lt;em&gt;된&lt;/em&gt; 경우 해당 한계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">trait 객체가 제네릭 형식의 형식 인수로 사용되는 경우 포함 형식을 먼저 사용하여 바운드를 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 유형 중 하나로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 문법에 의해 생성되는 유형으로 제한됩니다 (여기서 &lt;code&gt;'lt&lt;/code&gt; 임의의 수명을 나타냄).</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">실수로 형식 매개 변수가 포함 된 경우 아래에 표시된 것처럼 형식 매개 변수를 간단히 제거하면이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;code&gt;Unpin&lt;/code&gt; , &lt;code&gt;Pin::get_mut&lt;/code&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 작성 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 액세스 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 쓰기 시간을 지원하지 않으면 반환 된 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 지정되지 않은 꼬리면 가 다음 :</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">사용자가 선호하는 색상을 지정하면 해당 색상이 배경색입니다. 오늘이 화요일이면 배경색이 녹색입니다. 사용자가 나이를 문자열로 지정하고 숫자로 구문 분석 할 수있는 경우 숫자 값에 따라 색상이 자주색 또는 주황색입니다. 이러한 조건 중 어느 것도 해당되지 않으면 배경색이 파란색입니다.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">사용자가 고강도 운동을 원한다면 몇 가지 추가 논리가 있습니다. 앱에서 생성 된 난수 값이 3이면 앱은 휴식과 수화를 권장합니다. 그렇지 않으면 복잡한 알고리즘을 기반으로 몇 분 동안 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌린 다음 이동해야하는 경우 범위가 지정된 블록을 사용하여 빌림의 수명을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌려야하는 경우 범위가 지정된 블록을 사용하여 빌려주기를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값이 발견 되면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우 정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">패턴 가드에서 값을 사용하는 경우 복제본을 사용해도 소유권이 이동하지 않으므로 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">벡터가 정렬되면 모든 복제본이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="translated">여러 유형이 관련된 경우, 이들과 상호 작용하는 유일한 방법은 트레이 트의 인터페이스를 통하는 것이며, 동적 디스패치에 의존해야하는 것도 허용 가능 &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;합니다&lt;/a&gt; . &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; 또는 &lt;code&gt;Arc&lt;/code&gt; 와 같은 다른 컨테이너 유형과 .</target>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="translated">다른 것이 없다면 &lt;code&gt;Rc&lt;/code&gt; 이 할당에 대한 Rc 포인터&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 대한 포인터는 연결 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">이 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 없으면 이 값에 대한 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터의 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 새 할당을 만들고 내부 값에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 하여 고유 한 소유권을 보장합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가 &lt;code&gt;make_mut&lt;/code&gt; 는 고유 한 소유권을 보장하기 위해 내부 값에서 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 새 할당에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 있으면 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 방식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b165be9cc0b432064e92ddc4e5e166f180e45c19" translate="yes" xml:space="preserve">
          <source>If there is a panic, the already cloned elements will be dropped.</source>
          <target state="translated">패닉이 발생하면 이미 복제 된 요소가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">단일 유형이 관련된 경우 &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">포함 유형에서 고유 한 경계가있는 경우 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">매개 변수에 사용 된 수명이 정확히 하나 (필요한지 여부) 인 경우 해당 수명은 &lt;em&gt;모든&lt;/em&gt; 생략 된 출력 수명에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">포함 유형에서 둘 이상의 바운드가있는 경우 명시 적 바운드를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">첨부 데이터가없는 경우에 &lt;em&gt;임의의&lt;/em&gt; 열거의 변형 후 판별 직접 선택 및 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 가 삭제 될 때 버퍼에 여전히 부분 라인이 있으면 해당 내용을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt; &lt;code&gt;last_os_error&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt; &lt;code&gt;from_raw_os_error&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;last_os_error&lt;/code&gt; 또는 &lt;code&gt;from_raw_os_error&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환하고, 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 소문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 대문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 소문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 대문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 가 특별한 고려 사항 (예 : 다중 &lt;code&gt;char&lt;/code&gt; )을 필요로하는 경우 반복기 는 &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; 에&lt;/a&gt; 의해 제공된 &lt;code&gt;char&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장이 여러분의 관심을 불러 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;일으켰고&lt;/a&gt; 자신 만의 스마트 포인터를 구현하고 싶다면 &amp;ldquo;The Rustonomicon&amp;rdquo; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장에서 관심을 끌고 자신 만의 스마트 포인터를 구현하려는 경우 &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;Rustonomicon&amp;rdquo;&lt;/a&gt; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;을 발견하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">이 함수에 임의의 I / O 형식 또는 기타 오류가 발생하면 오류 변형이 반환됩니다. 오류가 리턴되면 읽은 바이트가 없음을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;code&gt;Ok(0)&lt;/code&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">이 함수가 오류를 반환하면 읽은 바이트 수는 지정되지 않지만 버퍼를 완전히 채우는 데 필요한 것보다 더 이상 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">이것이 버퍼링 된 채널 인 경우, 현재 버퍼가 가득 찼습니다. 이것이 버퍼링 된 채널이 아닌 경우 , 데이터를 획득 할 수있는 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">이것이 옵션이 아닌 경우 유형 매개 변수를 다른 특성 오브젝트로 바꾸는 것을 고려하십시오 (예 &lt;code&gt;T: OtherTrait&lt;/code&gt; 인 경우 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). 이 방법에 제공하려는 유형의 수가 제한되어 있으면 다른 유형의 방법을 수동으로 나열 해보십시오.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">이번이 처음 인 경우 표준 라이브러리에 대한 문서가 우연히 사용되도록 작성되었습니다. 재미있는 것을 클릭하면 일반적으로 흥미로운 장소로 연결됩니다. 여전히 놓치고 싶지 않은 중요한 것들이 있으므로 표준 라이브러리와 설명서를 둘러보십시오.</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 리턴 하면 메모리 블록의 소유권이이 할당 자에게 전송되지 않고 메모리 블록의 내용이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Ok(addr)&lt;/code&gt; 리턴하면 , 리턴 된 &lt;code&gt;addr&lt;/code&gt; 은 &lt;code&gt;layout&lt;/code&gt; 인스턴스를 보유하기에 적합한 스토리지 블록을 가리키는 널이 아닌 주소 입니다.</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 널을 리턴하면, 메모리 블록의 소유권이이 할당 자로 전송되지 않았으며 메모리 블록의 내용은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">이로 인해 여러 후보가 발생하면 오류가 발생하며 수신자는 메소드를 호출하기 위해 적절한 수신자 유형 으로 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;변환&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">이것이 &lt;code&gt;Err&lt;/code&gt; 을 리턴하면 , 메모리 블록은 여전히 ​​원래 (더 큰) &lt;code&gt;layout&lt;/code&gt; 나타내는 것으로 간주됩니다 . 다른 곳에서 재사용하기 위해 블록을 조각하지 않았으며 메모리 블록의 소유권이 이전되지 않았으며 메모리 블록의 내용이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조되는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 해제되었거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 메소드의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 반환하면 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자로 전송 된 것입니다. 메모리는 해제되거나 해제되지 않았을 수 있으며이 메서드의 반환 값을 통해 호출자에게 다시 전송되지 않는 한 사용할 수없는 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 , 그 크기의 레이아웃과 &lt;code&gt;layout&lt;/code&gt; 과 같은 정렬의 데이터를 전달하는데 사용될 수 있다고 주장했다 . (할당자는 후속 블록 또는 가상 메모리 트릭을 포함하도록 메모리 블록을 확장하는 등의 작업을 수행하기 위해 노력을 기울일 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 따라서 더 작은 레이아웃의 데이터를 전달하는 데만 사용될 수 있다고 주장했습니다 . (할당자는이를 활용하여 다른 곳에서 재사용 할 수 있도록 블록의 일부를 잘라낼 수 있습니다.) 더 작은 레이아웃 내에서 블록의 잘린 내용은 변경되지 않으며 블록의 소유권이 이전되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면, &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 할당 해제되었거나 할당되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 방법의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자로 전송 된 것입니다. 메모리는 할당 해제되거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주되어야합니다 (물론이 메서드의 반환 값을 통해 호출자에게 다시 전송되지 않는 한). 새 메모리 블록은 &lt;code&gt;layout&lt;/code&gt; 으로 할당 되지만 &lt;code&gt;size&lt;/code&gt; 는 &lt;code&gt;new_size&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="translated">이 슬라이스가 분할되지 않은 경우이 메서드는 일종의 이진 검색을 수행하므로 반환 된 결과는 지정되지 않고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구문을 사용하는 경우 인쇄 할 문자 수가 실제 오브젝트보다 형식화되기 때문에 문자 수는 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하는 경우이 함수는 패닉, 래핑 또는 포화 상태가 될 수 있습니다. 제안 된 동작은 디버그 어설 션이 활성화되면 패닉 상태가되고 그렇지 않으면 래핑되거나 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">일치하는 두 요소가 바로 인접 해 있으면 그 사이에 빈 조각이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="translated">두 시퀀스에 동일한 요소가 있고 길이가 같은 경우 시퀀스는 사 전적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">우리가하면 &lt;em&gt;않는&lt;/em&gt; 깊이의 힙 데이터를 복사 할 &lt;code&gt;String&lt;/code&gt; 뿐 아니라 스택 데이터, 우리라는 일반적인 방법 사용할 수 있습니다 &lt;code&gt;clone&lt;/code&gt; . 5 장에서 메소드 구문에 대해 설명하지만 메소드는 많은 프로그래밍 언어에서 공통적 인 기능이므로 이전에 본 적이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">이 코드를 지금 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">오류를 계속 읽으면 다음과 같은 유용한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">유형의 정의를 제어하면 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 직접 &lt;code&gt;Clone&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">여기에 형식 주석을 추가하지 않으면 Rust에 다음 오류가 표시됩니다. 이는 컴파일러가 사용하려는 형식을 알기 위해 더 많은 정보가 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 함수를 &lt;code&gt;Copy&lt;/code&gt; 특성 을 구현하는 유형 으로 제한하지 않으려면 &lt;code&gt;T&lt;/code&gt; 대신 &lt;code&gt;Copy&lt;/code&gt; 대신 특성 바인딩 &lt;code&gt;Clone&lt;/code&gt; 를 갖도록 지정할 수 있습니다. 그런 다음 &lt;code&gt;largest&lt;/code&gt; 함수가 소유권을 갖기를 원할 때 슬라이스의 각 값을 복제 할 수 있습니다. 은 Using &lt;code&gt;clone&lt;/code&gt; 우리가 잠재적으로 같은 자신의 힙 데이터 것을 유형의 경우 더 힙 할당을 만들고있어 기능 수단을 &lt;code&gt;String&lt;/code&gt; 우리는 많은 양의 데이터로 작업하는 경우, 힙 할당이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">수명 주석을 잊어 버리고이 함수를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">뮤텍스를 잠그면 &lt;code&gt;recv&lt;/code&gt; 를 호출 하여 채널에서 &lt;code&gt;Job&lt;/code&gt; 을 수신합니다 . 최종 &lt;code&gt;unwrap&lt;/code&gt; 은 여기에서도 오류를지나 이동 합니다. 수신 측이 종료되면 &lt;code&gt;send&lt;/code&gt; 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 반환 하는 방식과 유사하게 채널의 송신 측을 보유하는 스레드가 종료 된 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 행 사용을 나열하지 않은 경우이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 줄을 넣지 않았다면 이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">더 복잡한 키가있는 경우 &lt;code&gt;insert&lt;/code&gt; 호출 은 키 값을 업데이트하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">문자열 슬라이스가 있으면 직접 전달할 수 있습니다. 우리가 &lt;code&gt;String&lt;/code&gt; 을 가지고 있다면 , 우리는 전체 &lt;code&gt;String&lt;/code&gt; 의 슬라이스를 전달할 수 있습니다 . 대신에 대한 참조의 캐릭터 조각 걸릴하는 함수를 정의하는 &lt;code&gt;String&lt;/code&gt; 어떤 기능을 잃지 않고 우리의 API가 더 일반적이고 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">키와 값을 해시 맵에 삽입 한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연관된 값이 대체됩니다. Listing 8-24 호출의 코드가 두 번 &lt;code&gt;insert&lt;/code&gt; 되지만 해시 맵에는 Blue 팀 키 값을 두 번 삽입하기 때문에 하나의 키 / 값 쌍만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">값에 대한 참조를 해시 맵에 삽입하면 값이 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 한 유효해야합니다. 이러한 문제에 대해서는 10 장의 &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;평생 검증 참조&quot;&lt;/a&gt; 섹션에서 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Devanagari 스크립트로 작성된 힌디어 단어 &quot;नमस्ते&quot; 를 보면 다음과 같은 &lt;code&gt;u8&lt;/code&gt; 값 으로 구성된 벡터로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">여러 문자열을 연결 해야하는 경우 &lt;code&gt;+&lt;/code&gt; 연산자 의 동작 이 다루기 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">앞에서 본 것처럼 인수를 전달하지 않고 테스트를 실행하면 모든 테스트가 동시에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">&lt;em&gt;hello.txt&lt;/em&gt; 파일 &lt;em&gt;없이이&lt;/em&gt; 코드를 실행 하면 &lt;code&gt;panic!&lt;/code&gt; 에서 오류 메시지가 나타납니다 ! 것을 전화 &lt;code&gt;unwrap&lt;/code&gt; 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">이 코드를 실행하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">&lt;code&gt;takes_ownership&lt;/code&gt; 호출 한 후 &lt;code&gt;s&lt;/code&gt; 를 사용하려고하면 Rust에서 컴파일 타임 오류가 발생합니다. 이러한 정적 검사는 실수로부터 우리를 보호합니다. &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 를 사용 하는 코드를 &lt;code&gt;main&lt;/code&gt; 에 추가하여 코드를 사용할 수있는 위치와 소유권 규칙으로 인해 코드를 사용할 수없는 위치를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">&lt;code&gt;assert_eq!(5, y);&lt;/code&gt; 를 쓰려고하면 ! (5, y); 대신이 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">범위가 끝난 후 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 액세스하려고 하면 &lt;code&gt;None&lt;/code&gt; 을 다시 얻 습니다. 프로그램의 끝에서, &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;leaf&lt;/code&gt; 변수에 있기 때문에, (1)의 강한 카운트 0 약함 카운트를 갖는 &lt;code&gt;leaf&lt;/code&gt; 이제 유일한 기준이다 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 다시.</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Listing 15-15와 같이 Listing 15-14에서 &lt;code&gt;main&lt;/code&gt; 함수를 수정 하여 &lt;code&gt;Drop&lt;/code&gt; 특성의 &lt;code&gt;drop&lt;/code&gt; 메소드를 수동으로 호출하려고 하면 컴파일러 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Listing 15-3에서 코드를 컴파일하려고하면 Listing 15-4에 표시된 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Listing 10-21에 나와있는 것처럼 &lt;code&gt;longest&lt;/code&gt; 함수 를 구현하려고하면 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">참조와 마찬가지로 컴파일러 오류가 발생하지 않고 이러한 규칙을 위반하려고하면 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 구현이 런타임시 패닉 상태가됩니다. Listing 15-23은 Listing 15-22 의 &lt;code&gt;send&lt;/code&gt; 구현 수정을 보여준다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 인해 런타임 시이 작업을 수행 할 수 없음 을 설명하기 위해 동일한 범위에 대해 두 개의 변경 가능한 차용을 의도적으로 작성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; 대신 &lt;code&gt;None&lt;/code&gt; 을 사용하는 경우 컴파일러 가 &lt;code&gt;None&lt;/code&gt; 값만 보고 &lt;code&gt;Some&lt;/code&gt; 변형이 보유 할 유형을 유추 할 수 없으므로 Rust에 어떤 유형의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 있는지 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">벡터의 각 요소에 차례로 액세스하려면 인덱스를 사용하여 한 번에 하나씩 액세스하는 대신 모든 요소를 ​​반복 할 수 있습니다. Listing 8-8은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용하여 &lt;code&gt;i32&lt;/code&gt; 값으로 구성된 벡터의 각 요소에 대한 불변 참조를 가져 와서 인쇄하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">경로에 정의 된 &lt;em&gt;모든&lt;/em&gt; 공개 항목을 범위 로 가져 오려면 해당 경로 다음에 glob 연산자 인 &lt;code&gt;*&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도 보려면 &lt;code&gt;--nocapture&lt;/code&gt; 플래그 를 사용하여 출력 캡처 동작을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도보고 싶다면 마지막에 &lt;code&gt;--show-output&lt;/code&gt; 을 사용하여 성공한 테스트의 출력을 보여 주도록 Rust에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">이 함수가 &lt;code&gt;item1&lt;/code&gt; 과 &lt;code&gt;item2&lt;/code&gt; 가 다른 유형을 갖도록하려면 &lt;code&gt;impl Trait&lt;/code&gt; 을 사용하는 것이 적절합니다 (두 유형이 &lt;code&gt;Summary&lt;/code&gt; 를 구현하는 한 ). 두 매개 변수를 모두 같은 유형으로 만들려면 다음과 같이 특성 바운드를 사용하여 표현하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">튜플에서 하나 이상의 값을 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;무시&lt;/a&gt; 하려면 &quot;패턴의 값 무시&quot; 섹션 에서 볼 수 있듯이 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 을 사용할 수 있습니다 . 문제가 패턴에 너무 많은 변수가있는 경우, 해결책은 변수를 제거하여 유형을 일치시켜 변수의 수가 튜플의 요소 수와 같도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">이 코드를 실행할 수 있다면 스폰 된 스레드가 전혀 실행되지 않고 즉시 백그라운드에 놓일 수 있습니다. 스폰 된 스레드는 &lt;code&gt;v&lt;/code&gt; 내부에 대한 참조를 갖지만 주 스레드 는 15 장에서 설명한 &lt;code&gt;drop&lt;/code&gt; 함수를 사용하여 즉시 &lt;code&gt;v&lt;/code&gt; 를 삭제 합니다. 그런 다음 스폰 된 스레드가 실행되기 시작하면 &lt;code&gt;v&lt;/code&gt; 는 더 이상 유효하지 않으므로 이에 대한 참조는 또한 유효하지 않습니다. 아뇨!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">우리는 전화로한다면 &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , &lt;code&gt;coin&lt;/code&gt; 것 &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . 해당 값을 각 일치 팔과 비교할 때 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 도달 할 때까지 일치하지 않습니다 . 이 시점에서 &lt;code&gt;state&lt;/code&gt; 바인딩은 &lt;code&gt;UsState::Alaska&lt;/code&gt; 값이됩니다 . 그런 다음 &lt;code&gt;println!&lt;/code&gt; 에서 해당 바인딩을 사용할 수 있습니다 ! 따라서 &lt;code&gt;Quarter&lt;/code&gt; 의 &lt;code&gt;Coin&lt;/code&gt; 열거 형 변형 에서 내부 상태 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">상태 패턴을 사용하지 않는 대체 구현을 작성하는 경우 &lt;code&gt;Post&lt;/code&gt; 의 메소드 또는 게시물 의 상태를 확인하고 해당 위치의 동작을 변경 하는 &lt;code&gt;main&lt;/code&gt; 코드 에서 &lt;code&gt;match&lt;/code&gt; 표현식을 대신 사용할 수 있습니다. 즉, 게시 된 상태에있는 게시물의 모든 의미를 이해하려면 여러 곳을 살펴 봐야합니다! 이것은 우리가 추가 한 상태를 증가시킬뿐입니다. 각각의 &lt;code&gt;match&lt;/code&gt; 표현에는 다른 팔이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 상자 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 한 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 우리가 목록 2-4의 추측 게임에서 가졌던 다음 두 개의 &lt;code&gt;use&lt;/code&gt; 문은 &lt;code&gt;std&lt;/code&gt; 에서 항목 을 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 패키지 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 자체 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 추측 게임의 목록 2-4에있는 이 두 가지 &lt;code&gt;use&lt;/code&gt; 문장은 &lt;code&gt;std&lt;/code&gt; 에서 범위로 항목을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">당신이 경우 &lt;em&gt;어떻게&lt;/em&gt; 녹에, 컴파일러는 당신에게 (에 의해 제어 기본적으로 경고를 줄 것이다 쓰기 &lt;code&gt;unused_must_use&lt;/code&gt; 의 보풀).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">찾고있는 이름을 이미 알고 있다면 가장 빠른 방법은 페이지 상단의 검색 창을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">자체 스마트 포인터 유형을 정의하고 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST 강제 변환 시스템&lt;/a&gt; 을 사용 하여 크기가 조정되지 않은 유형에서 크기가 조정되지 않은 유형으로 변환 하려면 &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">타입을 잘 생각한다면 &lt;code&gt;map()&lt;/code&gt; 과 같이 생각할 수 있습니다 : &lt;code&gt;A&lt;/code&gt; 타입 의 요소를 제공 하는 반복자가 있고 다른 &lt;code&gt;B&lt;/code&gt; 타입의 반복자를 원한다면 &lt;code&gt;map()&lt;/code&gt; 사용할 수 있습니다 &lt;code&gt;A&lt;/code&gt; 를 가져 오고 &lt;code&gt;B&lt;/code&gt; 를 반환 하는 클로저를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 변환 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 함수의 안전하지 않은 버전이 있습니다.이 함수 는 동작이 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 null이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 반환하는 일종의 &lt;code&gt;as_mut_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 널이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;T&lt;/code&gt; 를 리턴하는 일종의 &lt;code&gt;as_ref_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">숫자 유형을 bool로 캐스트하려는 경우 대신 0과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">속기 필드 패턴을 사용하지만 다른 이름으로 구조체 필드를 참조하려는 경우 명시 적으로 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">속기 필드 패턴을 사용하고 있지만 다른 이름으로 struct 필드를 참조하려면 명시 적으로 이름을 변경해야합니다. 구조체 필드는 콜론 전에 사용 된 이름에 의해 식별됩니다 &lt;code&gt;:&lt;/code&gt; 구조체 패턴이 구조체 형식의 선언이 일치되고 유사합니다 그래서.</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">기존 파일 형식을 처리 할 프로그램을 작성하는 경우이 기능을 사용하기 전에 해당 형식의 공백 정의를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">예를 들어 권한 오류로 인해 파일이 포함 된 디렉토리에 액세스 할 수 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 전략을 사용할 수없는 경우 유형 이 메소드가없는 &lt;code&gt;Eq&lt;/code&gt; 를 구현하도록 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">안전한 코드로 액세스 할 수 있는 수명 &lt;code&gt;'a&lt;/code&gt; ( &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 참조) 로 안전한 참조를 작성하는 경우 (예를 들어 리턴했기 때문에) 해당 참조와 모순되는 방식으로 데이터에 액세스하면 안됩니다 &lt;code&gt;'a&lt;/code&gt; 의 나머지 . 예를 들어,이 방법은 당신이 가지고 있다고하면 &lt;code&gt;*mut T&lt;/code&gt; 에서 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 와에 캐스팅 &lt;code&gt;&amp;amp;T&lt;/code&gt; 다음의 데이터를, &lt;code&gt;T&lt;/code&gt; 는 (모든 모듈로 불변 유지해야 &lt;code&gt;UnsafeCell&lt;/code&gt; 의 데이터 내에서 발견 &lt;code&gt;T&lt;/code&gt; 해당 참조의 수명까지 물론,) 만료됩니다. 마찬가지로 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 생성하면안전 코드로 해제 된 참조가 있으면 해당 참조가 만료 될 때까지 &lt;code&gt;UnsafeCell&lt;/code&gt; 내의 데이터에 액세스하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">변수를 만들지 만 아무데도 사용하지 않으면 Rust는 일반적으로 버그가 될 수 있으므로 경고를 표시합니다. 그러나 때로는 프로토 타입을 만들거나 프로젝트를 시작할 때와 같이 아직 사용하지 않는 변수를 만드는 것이 유용합니다. 이 상황에서 변수 이름을 밑줄로 시작하여 사용하지 않는 변수에 대해 경고하지 않도록 Rust에 지시 할 수 있습니다. Listing 18-20에서는 사용하지 않는 두 개의 변수를 작성하지만이 코드를 실행할 때 그 중 하나에 대한 경고 만 표시된다.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="translated">트레이 트 객체를 사용하기로 결정한 경우 컴파일러는 컴파일 도중이 아니라 &lt;em&gt;런타임&lt;/em&gt; 에 호출 할 메서드를 파악하는 코드를 생성해야하므로 성능에 영향을주는 &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;동적 디스패치에&lt;/a&gt; 의존한다는 점에 유의 하십시오 . 특성 개체를 사용하여 성능을 위해 유연성을 거래하고 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="translated">당신이없는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 하지만, 단지 &lt;code&gt;&amp;amp;U&lt;/code&gt; 있도록 &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (예 : &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt; ), 당신은 사용할 수 있습니다 &lt;code&gt;iter().any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &quot;적어도&quot;동작을 원하지 않으면 &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 호출하지 않으면 프로그램이 컴파일되지만 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">테스트를 병렬로 실행하지 않거나 사용 된 스레드 수를보다 세밀하게 제어하려면 &lt;code&gt;--test-threads&lt;/code&gt; 플래그와 사용하려는 스레드 수를 테스트에 보낼 수 있습니다 이진. 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아주 ​​가능성이 높음) 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아마도) 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Rust의 기본 사항을 모르는 경우 Rust Book을 방문하여 시작할 수 있습니다. https://doc.rust-lang.org/book/</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="translated">Rust의 기초를 모르신다면 &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; 에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">이름을 한정하지 않으면 코드는 &quot;GET&quot;및 &quot;POST&quot;라는 새 변수를 대신 바인딩합니다. 이 동작은 원하는 것이 &lt;code&gt;rustc&lt;/code&gt; 있으므로 rustc 는 이러한 상황이 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">이 오류가 발생하면 입력 유형의 가능한 모든 값이 일치하도록 패턴을 변경해야합니다. 열거 형과 같이 변형이 적은 유형의 경우 모든 경우를 명시 적으로 다루어야합니다. 또는 밑줄 &lt;code&gt;_&lt;/code&gt; 와일드 카드 패턴을 &quot;다른 것&quot;과 일치시키기 위해 다른 모든 패턴 뒤에 추가 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">이 오류가 발생하면 당신은 아마 사용할 필요가 &lt;code&gt;match&lt;/code&gt; 하거나 &lt;code&gt;if let&lt;/code&gt; 실패의 가능성을 처리 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">C 또는 C ++ 배경이 있다면 &lt;code&gt;gcc&lt;/code&gt; 또는 &lt;code&gt;clang&lt;/code&gt; 과 유사하다는 것을 알 수 있습니다. 성공적으로 컴파일 한 후 Rust는 바이너리 실행 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 목록 이있는 경우 &lt;code&gt;collect()&lt;/code&gt; 를 사용 하여 실패한 것이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있다면 일반적으로 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 불변입니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경되거나 변경되지 않고 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 될 수 없다는 제한을 해결하는 유일한 핵심 언어 기능 입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 변경을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서도 앨리어싱 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 을 얻을 수있는 합법적 인 방법 은 &lt;em&gt;없습니다.&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있으면 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 변경할 수 없습니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 가능하게 별명 지정되거나 변경되지 않았으며 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는이 제한을 해결하는 유일한 핵심 언어 기능입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 가변성을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">프로그램에 &lt;code&gt;match&lt;/code&gt; 를 사용하여 표현하기에 너무 장황한 논리가 있는 &lt;code&gt;if let&lt;/code&gt; 이 Rust 도구 상자에도 있다는 것을 기억 하십시오.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;String&lt;/code&gt; 을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 여기 에서 &lt;code&gt;String&lt;/code&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">유효한 UTF-8 바이트의 벡터가 있으면 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 만들 수 있습니다 . 당신도 반대를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&lt;/code&gt; 의 소유권이 있다면 , 대신 &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">컨테이너의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값에 대한 소유권이있는 경우에는 대신 &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">당신은 구현하는 뭔가가있는 경우 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , 당신이 사용할 수있는 &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 의 유형을&lt;/a&gt; 로를 설정하는 &lt;code&gt;BufRead&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">변경하지 않고 즉시 &lt;code&gt;cargo build&lt;/code&gt; 다시 실행 하면 &lt;code&gt;Finished&lt;/code&gt; 라인 에서 다른 출력을 얻을 수 없습니다 . Cargo는 이미 종속성을 다운로드하여 컴파일 &lt;em&gt;했음을 알고 있으며 Cargo.toml&lt;/em&gt; 파일 에서 관련 항목을 변경하지 않았습니다 . Cargo는 또한 코드에 대해 아무것도 변경하지 않았으므로 다시 컴파일하지도 않는다는 것을 알고 있습니다. 할 일이 없으면 단순히 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 대신 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 필요한 경우 &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">널 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">nul 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대신 &lt;code&gt;String&lt;/code&gt; 이 필요한 경우 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 이 소멸 될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 물론 &lt;code&gt;Hash&lt;/code&gt; 특성을 직접 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 여러 개 필요한 경우 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 여러 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">기능이 필요한 경우 야간 릴리스의 컴파일러를 사용해야합니다 (하지만 나중에 기능이 제거되거나 변경 될 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">이것이 필요한 경우, 무언가 잘못하고있을 가능성이 큽니다. Rust는 다른 구조체의 레이아웃에 대해 많은 것을 보증하지 않습니다 (동일한 선언을 가진 두 구조체는 다른 레이아웃을 가질 수 있음). 변환을 완전히 피하는 해결책이 있다면 대신 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">객체 경계를 넘어야하는 경우 포인터를 정수로 캐스팅하고 거기에서 산술을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">&lt;em&gt;많은&lt;/em&gt; 스트림 의 길이를 가져와야하고 탐색 위치를 신경 쓰지 않는 경우 &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; 를 호출 하고 반환 값을 사용하여 탐색 조작 수를 줄일 수 있습니다. 또한 스트림 길이입니다).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">개별 유니 코드 스칼라 값에 대한 작업을 수행해야하는 경우 &lt;code&gt;chars&lt;/code&gt; 메서드 를 사용하는 것이 가장 좋습니다 . &quot;नमस्ते&quot;에서 &lt;code&gt;chars&lt;/code&gt; 를 호출 하면 &lt;code&gt;char&lt;/code&gt; 유형의 6 개 값이 분리되어 반환 되며 결과를 반복하여 각 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">네임 스페이스 만 가져 오려면 직접 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">&lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 열고 사소한 변경을 한 다음 저장하고 다시 빌드하면 두 줄의 출력 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">원하는 경우 스크립트를 다운로드하여 실행하기 전에 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">작업 공간의 상자를 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에 게시하는 경우 작업 공간의 각 상자를 별도로 게시해야합니다. &lt;code&gt;cargo publish&lt;/code&gt; 명령은 없습니다 &lt;code&gt;--all&lt;/code&gt; 플래그 또는 &lt;code&gt;-p&lt;/code&gt; 각 상자의 디렉토리 및 실행으로 변경해야합니다, 그래서 깃발을 &lt;code&gt;cargo publish&lt;/code&gt; 나무 상자를 게시하는 작업 공간에 각각의 상자에.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">전역 변경 가능 상태를 원하면 &lt;code&gt;static mut&lt;/code&gt; 변경 또는 전역 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">이 코드를 실행하고 기본 스레드의 출력 만 보거나 겹치지 않으면 범위에서 숫자를 늘려서 운영 체제가 스레드간에 전환 할 수있는 기회를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">버전 번호가 표시되면 가지고 있습니다! &lt;code&gt;command not found&lt;/code&gt; 과 같은 오류가 표시되는 경우 설치 방법에 대한 설명서를보고 Cargo를 별도로 설치하는 방법을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 표시되면 Rust가 성공적으로 설치된 것입니다! 이 정보가 표시되지 않고 Windows에있는 경우 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하십시오 . 이것이 모두 정확하고 Rust가 여전히 작동하지 않으면 도움을 얻을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 거기서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 자신이라고 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 유용한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 및 &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;스택 오버플로가 있습니다.&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 보이면 Rust를 성공적으로 설치 한 것입니다! 이 정보가 보이지 않고 Windows를 사용하고 있다면 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하세요 . 모든 것이 맞고 Rust가 여전히 작동하지 않는다면 도움을받을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 그곳에서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 스스로 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 훌륭한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">우리가 &quot;Hello, world!&quot;에서했던 것처럼 Cargo를 사용하지 않는 프로젝트를 시작했다면 프로젝트에서 Cargo를 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리 로 이동하고 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Cargo를 사용하지 않는 프로젝트를 시작했다면 Hello, world! 프로젝트에서화물을 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리로 &lt;em&gt;옮기고&lt;/em&gt; 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="translated">여전히 열거 형에 &lt;code&gt;Default&lt;/code&gt; 를 구현 하려면 &quot;직접&quot;수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">외부 크레이트의 모듈을 사용하려고했고 Rust 2015를 사용하고 있다면, 외부 &lt;code&gt;extern crate&lt;/code&gt; 선언 (보통 크레이트 루트에 위치)을 놓쳤을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">당신이 구현하려고하면 &lt;code&gt;Copy&lt;/code&gt; 비 포함하는 구조체 또는 열거에 &lt;code&gt;Copy&lt;/code&gt; 된 데이터를, 당신은 오류 얻을 것이다 &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">마지막 &lt;code&gt;println!&lt;/code&gt; 주석을 해제하면 ! 프로그램을 실행, 녹으로이주기를 인쇄하려고합니다 를 가리키는 &lt;code&gt;b&lt;/code&gt; 가리키는 등이 스택 오버 플로우 때까지. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 속성에서 제공하는 것과 다른 동작을 원할 경우 수동으로 구현하는 방법에 대한 자세한 내용은 각 특성에 대한 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">다른 사용자가 모듈에서 변형을 직접 가져올 수있게하려면 &lt;code&gt;pub use&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">이 필드에 액세스하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소멸자를 실행하여 값을 올바르게 처리하려면 &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">클로저가 환경에서 사용하는 값의 소유권을 갖도록하려면 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이 기술은 데이터를 새 스레드가 소유하도록 데이터를 이동하기 위해 새 스레드에 클로저를 전달할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">명령 행 인수를 얻으려면 &lt;code&gt;std::env::args&lt;/code&gt; . 지정된 종료 코드로 종료하려면 &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="translated">정렬 순서를 유지하면서 정렬 된 &lt;code&gt;VecDeque&lt;/code&gt; 에 항목을 삽입 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="translated">정렬 순서를 유지하면서 정렬 된 벡터에 항목을 삽입하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">첫 번째 &lt;code&gt;String&lt;/code&gt; 을 계속 사용하려면 이를 복제하고 대신 복제본에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리를 누출하려면 &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 과 일치 시키려면 가드를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="translated">메서드에서 반환 된 값과 일치 시키려면 먼저 값을 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리에 대한 원시 포인터를 얻으려면 &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최대 값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최소값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">현재 오류를 생략하고 해당 소스 만 사용하려면 &lt;code&gt;skip(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">초기 오류를 생략하고 해당 소스 만 처리하려면 &lt;code&gt;skip(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">특정 옵션을 무시하고 다른 기본값을 계속 유지하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 변수의 값을 바꾸려면 &lt;a href=&quot;fn.swap&quot;&gt; &lt;code&gt;swap&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 대신 전달 된 값으로 바꾸려면 replace를 참조 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55dde3b0a389df6438eee8ef5e4606e7a78527fd" translate="yes" xml:space="preserve">
          <source>If you want to stick to a standard style across Rust projects, you can use an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; to format your code in a particular style. The Rust team has included this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;, so it should already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">Rust 프로젝트에서 표준 스타일을 고수하려면 &lt;code&gt;rustfmt&lt;/code&gt; 라는 자동 포맷터 도구 를 사용하여 코드를 특정 스타일로 포맷 할 수 있습니다. Rust 팀은이 도구를 &lt;code&gt;rustc&lt;/code&gt; 와 같은 표준 Rust 배포판에 포함 시켰 으므로 이미 컴퓨터에 설치되어있을 것입니다! 자세한 내용은 온라인 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 또는 더미 값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전달 된 값으로 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 이전 값을 반환하려면 replace를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">SPDX에 나타나지 않는 라이센스를 사용하려면 해당 라이센스의 텍스트를 파일에 넣고 프로젝트에 파일을 포함시킨 다음 &lt;code&gt;license-file&lt;/code&gt; 을 사용하여 해당 파일의 이름을 대신 지정해야합니다. 사용 &lt;code&gt;license&lt;/code&gt; 키</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">메소드를 사용하려면 메소드 뒤에 &lt;code&gt;()&lt;/code&gt; 를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.4.0&lt;/code&gt; 또는 &lt;code&gt;0.4.x&lt;/code&gt; 시리즈의 버전 을 사용 하려면 다음과 같이 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 업데이트해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">당신이 사용하고자하는 경우 &lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.6.0&lt;/code&gt; 시작 또는 모든 버전 &lt;code&gt;0.6.x&lt;/code&gt; 시리즈를, 당신은 업데이트해야 할 것 &lt;em&gt;Cargo.toml의&lt;/em&gt; 대신이 같은 모습에 파일을 :</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">이 속성을 impl의 모든 메소드에 적용하려면 각 메소드에 수동으로 주석을 답니다. 전체 impl에 &lt;code&gt;#[inline]&lt;/code&gt; 으로 주석을 달 수 없습니다 . 속성으로 .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="translated">Rust의 소유권에 대해 더 알고 싶다면 책의 &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;소유권 이해&lt;/a&gt; 장에서 시작 하십시오.</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Rust의 소유권에 대해 더 배우려면 다음 장에서 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Windows API로 작업하는 경우 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">내 보낸 매크로를 모두 가져 오려면 인수없이 &lt;code&gt;macro_use&lt;/code&gt; 를 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Ruby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙한 경우 별도의 단계로 프로그램을 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다. Rust는 &lt;em&gt;미리 컴파일 된&lt;/em&gt; 언어로, 프로그램을 컴파일하고 다른 사람에게 실행 파일을 제공 할 수 있으며 Rust를 설치하지 않아도 실행할 수 있습니다. 누군가에게 &lt;em&gt;.rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; 또는 &lt;em&gt;.js&lt;/em&gt; 파일을 제공하는 경우 루비, 파이썬 또는 JavaScript 구현이 (각각) 설치되어 있어야합니다. 그러나 이러한 언어에서는 프로그램을 컴파일하고 실행하기위한 명령이 하나만 필요합니다. 모든 것은 언어 디자인의 절충입니다.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">문제가 발생하면 Listing 20-15의 코드를보기 전에 이러한 변경 사항을 직접 구현해보십시오.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Linux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 하나가 아닌 두 개의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Rust 베타 또는 안정적인 릴리스를 사용하는 경우 기능 플래그를 사용할 수 없습니다. 이것이 우리가 새로운 기능을 영원히 안정적으로 선언하기 전에 새로운 기능을 실제로 사용할 수있게하는 열쇠입니다. 최첨단 기술을 선택하려는 사람들은 그렇게 할 수 있으며, 견고한 경험을 원하는 사람들은 안정을 유지하고 코드가 깨지지 않을 것임을 알 수 있습니다. 정체없는 안정성.</target>
        </trans-unit>
        <trans-unit id="c4d2404277922b45ce332d5f67f5f097fe76da77" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 으로&lt;/a&gt; 작업하는 경우 &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 로&lt;/a&gt; 작업하는 경우 &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 파일 시스템 경로를 사용하는 경우 &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">다른 언어로 작업하는 동안 &lt;em&gt;얕은 복사&lt;/em&gt; 와 &lt;em&gt;깊은 복사&lt;/em&gt; 라는 용어를 들었다면 데이터를 복사하지 않고 포인터, 길이 및 용량을 복사하는 개념은 얕은 복사를하는 것처럼 들릴 것입니다. 그러나 Rust는 얕은 카피 라 불리는 대신 첫 번째 변수를 무효화하기 때문에 &lt;em&gt;이동이라고&lt;/em&gt; 합니다. 이 예제에서, 우리는 말할 것 &lt;code&gt;s1&lt;/code&gt; 되었다 &lt;em&gt;이동&lt;/em&gt; 에 &lt;code&gt;s2&lt;/code&gt; . 실제 상황은 그림 4-4에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">값의 소멸자를 명시 적으로 호출하려면 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">컬렉션을 만드는 경우 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 를 구현 하면 컬렉션을 &lt;code&gt;for&lt;/code&gt; 루프 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">당신은 부작용의 일종을하고 있다면, 선호 &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">당신이 이것을 반환하고 &lt;code&gt;SUCCESS&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; 에서 &lt;code&gt;Err(_)&lt;/code&gt; 및 &lt;code&gt;Ok(())&lt;/code&gt; 각각 대신 반환하는 것을 고려 하십시오.이 코드는 동일한 코드를 반환하지만 오류를 &lt;code&gt;eprintln!&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">보푸라기 검사를 무시하려면 &lt;code&gt;forbid&lt;/code&gt; 를 변경할 수 있습니다 를 &lt;code&gt;deny&lt;/code&gt; 하거나 &lt;code&gt;forbid&lt;/code&gt; 설정이 명령 줄 옵션으로 제공된 경우 &lt;code&gt;-F&lt;/code&gt; 대신 &lt;code&gt;-D&lt;/code&gt; 를 사용하여 내부 보푸라기 검사 속성을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 별도의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">야간 버전의 rustc를 사용하는 경우 해당 기능을 추가하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">rustc의 안정 버전 또는 베타 버전을 사용하는 경우 불안정한 기능을 사용할 수 없습니다. 이렇게하려면 야간 버전의 rustc (rustup 사용)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">당신이 쓰고 있다면 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; &lt;code&gt;for&lt;/code&gt; 루프와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="translated">상자 이름을 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">어떤 종류의 컬렉션으로 자신을 발견하고 해당 컬렉션의 요소에 대한 작업을 수행 해야하는 경우 신속하게 '반복자'가 발생합니다. 반복자는 관용적 Rust 코드에서 많이 사용되므로 익숙해 질 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">구조체가 실제로 &lt;code&gt;T&lt;/code&gt; 유형의 데이터를 &lt;em&gt;소유&lt;/em&gt; 하지 않으면 다음 과 같은 참조 유형을 사용하는 것이 좋습니다 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (이상적으로) 또는 &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (생명이 적용되지 않는 경우 ) 소유권을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">유형이 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt; &lt;code&gt;partial_cmp&lt;/code&gt; &lt;/a&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">유형이 &lt;code&gt;Ord&lt;/code&gt; 인 경우 구현할 수 있습니다 &lt;code&gt;partial_cmp()&lt;/code&gt; &lt;code&gt;cmp()&lt;/code&gt; 를 사용하여 partial_cmp () 를 .</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 고정을 사용하는 경우 (예 : 위의 두 가지 예) &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현할 때주의해야합니다 . &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 하지만,이 호출된다 &lt;em&gt;당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 컴파일러가 자동으로 &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt; &lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt; &lt;/a&gt; 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">유형에 고정 (예 : 위의 두 예)을 사용하는 경우 &lt;code&gt;Drop&lt;/code&gt; 구현시주의해야합니다 . &lt;code&gt;drop&lt;/code&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 만이라고&lt;em&gt; 당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 마치 컴파일러가 자동으로 &lt;code&gt;get_unchecked_mut&lt;/code&gt; 을 호출 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">대신 클로저가 &lt;code&gt;self.vec&lt;/code&gt; 를 직접 사용하는 경우에는 &lt;code&gt;self&lt;/code&gt; 캡처를 시도합니다. 하는 경우 변경 가능한 참조로 . 그러나 &lt;code&gt;self.set&lt;/code&gt; 이 이미 반복되어 빌려 지기 때문에 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">의 나머지 필드를 무시합니다 &lt;code&gt;person&lt;/code&gt; . 나머지 필드는 값을 가질 수 있으며 변수에 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; 가 중첩 된 값의 일부 무시</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">와 값의 나머지 부분을 무시 &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">특별히 요청하지 않는 한 일부 테스트 무시</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">패턴에서 값 무시</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; 로 전체 값 무시</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; 로 이름을 시작하여 사용하지 않는 변수 무시</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">거실에서 TV로 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 상상해보십시오 . 한 사람이 TV를 보려고 들어 오면 TV가 켜집니다. 다른 사람들은 방에 들어 와서 TV를 볼 수 있습니다. 마지막 사람이 방을 나가면 더 이상 TV를 사용하지 않기 때문에 TV를 끕니다. 다른 사람이 여전히 TV를보고있는 동안 누군가 TV를 끄면 나머지 TV 시청자로부터 큰소리가 들릴 것입니다!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 원시 항목은 사용이 매우 제한적입니다. 대신 &lt;code&gt;raw_entry_mut&lt;/code&gt; 을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">불변 슬라이스 반복자</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다. 값이 현재 변경 가능한 경우에는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Impl 블록은 수명 매개 변수를 별도로 선언합니다. 수명 매개 변수가 고유 한 유형을 구현하는 경우 수명 매개 변수를 impl 블록에 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">특성 증폭</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">구현 &lt;code&gt;unsafe&lt;/code&gt; &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">유형에 대한 일부 기능을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">저렴한 가변 변환 가능 변환을 위해 &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">저렴한 참조 참조 변환을위한 &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">가치에서 가치로의 전환을 소비하기위한 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">현재 상자 외부의 유형으로 값-값 변환을 사용하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 특성을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">유형에 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현에서는 당황하거나 중단하지 않고 메모리 소진시 &lt;code&gt;Err&lt;/code&gt; 을 반환하도록 권장 되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 중단되지 않고 메모리 소진시 널을 리턴하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 당황하거나 중단하는 대신 메모리 소진시 null을 반환하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">구현에는 &lt;code&gt;impl&lt;/code&gt; 키워드 앞에 외부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 과 관련 항목이 포함 된 괄호 안에있는 내부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 이 포함될 수 있습니다. 내부 속성은 관련 항목보다 먼저 와야합니다. 여기서 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; . 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현&lt;em&gt;&lt;/em&gt; 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; &lt;code&gt;a == b&lt;/code&gt; 이고 모든 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 대해 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 경우에만 동일 합니다 . 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="translated">의 구현은 호출자로 대체되지 않는 한 수명 동안 동일한 변경 가능한 참조를 반환해야합니다. 호출자는 반복을 중지 한 경우에만 참조를 교체하고 소스를 추출한 후 반복기 파이프 라인을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">운영자 특성의 구현은 일반적인 의미와 &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;운영자 우선 순위&lt;/a&gt; 를 염두에두고 각각의 상황에서 놀랍지 않아야합니다 . 예를 들어, &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; 을&lt;/a&gt; 구현할 때 연산은 곱셈과 유사해야하며 연관성과 같은 예상 속성을 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대해 &lt;code&gt;Eq&lt;/code&gt; 와 같은 것들을 구현 합니다. 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대한 &lt;code&gt;Eq&lt;/code&gt; 와 같은 구현 . 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="translated">이 특성의 구현은 &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; 에 대한 인수가 안전한 참조이면 결과도 마찬가지 라고 약속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">외국 유형에 대한 구현</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">&lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 수동 구현 은 안전하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Add&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Binary&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 뒤에있는 데이터에 편리하게 액세스 할 수 &lt;code&gt;Deref&lt;/code&gt; 를 구현할 수 있습니다 . 반면에 &lt;code&gt;Deref&lt;/code&gt; 및 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 에 관한 규칙 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이 때문에 혼란을 피하기 &lt;strong&gt;위해 스마트 포인터에만 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; 를 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터 용 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현 하면 뒤에있는 데이터를 편리하게 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현할 수 있습니다 . 반면, &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;DerefMut&lt;/code&gt; 에 관한 규칙은 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이것 때문에,&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/strong&gt;혼란을 피하기&lt;strong&gt; 위해 스마트 포인터&lt;/strong&gt; 에&lt;strong&gt; 대해서만 &lt;/strong&gt;&lt;strong&gt;DerefMut&lt;/strong&gt;&lt;strong&gt; 을 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">구현 &lt;code&gt;Display&lt;/code&gt; 유형에 디스플레이 :</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">구현 &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;FromIterator&lt;/code&gt; 유형에 맞는 FromIterator :</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">구현 &lt;code&gt;Into&lt;/code&gt; 외부 유형 변환에</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="translated">이전 버전의 Rust에서 외부 유형으로 변환하기 위해 &lt;code&gt;Into&lt;/code&gt; 구현 하기</target>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;IntoIterator&lt;/code&gt; 유형에 맞는 IntoIterator :</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerExp&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Octal&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">타입에 대한 &lt;code&gt;Pointer&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Sub&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TryInto&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperExp&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;split_at_mut&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">반복자 구현</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">다른 유형으로의 변환으로 전환 구현</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">유형에 대한 특성 구현</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">유형에 특성을 구현하는 것은 일반 메소드를 구현하는 것과 유사합니다. 차이점은 &lt;code&gt;impl&lt;/code&gt; 후에 구현하려는 특성 이름을 입력 한 다음 &lt;code&gt;for&lt;/code&gt; 키워드 를 사용 하고 특성을 구현하려는 유형의 이름을 지정한다는 것입니다. &lt;code&gt;impl&lt;/code&gt; 블록 내에서 특성 정의가 정의한 메소드 서명을 넣습니다. 각 서명 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 특성의 메소드가 특정 유형에 대해 원하는 특정 동작으로 메소드 본문을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;안전하지 않은 특성&lt;/a&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">객체 지향 디자인 패턴 구현</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; 메소드 구현</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">&lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 함수 구현</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">이행 &lt;code&gt;Deref&lt;/code&gt; 특성 것은 당신의 행동 사용자 정의 할 수 있습니다 &lt;em&gt;참조 연산자&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; 을 (곱셈 또는 글로브 연산자 반대). 스마트 포인터를 일반 참조처럼 취급 할 수있는 방식으로 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 참조에서 작동하는 코드를 작성하고 해당 코드를 스마트 포인터로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 대한 &lt;code&gt;Unpin&lt;/code&gt; 특성을 구현하면 유형 고정의 제한이 해제 되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 함수 를 사용하여 &lt;code&gt;T&lt;/code&gt; 를 &lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 밖으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">특성 구현</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">이러한 특성을 구현하면 특정 운영자에게 과부하를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="translated">이 방법을 구현한다는 것은 어댑터가 소스에 대한 개인 전용 액세스를 포기하고 메소드 수신자 유형을 기반으로 한 보장에만 의존 할 수 있음을 의미합니다. 제한된 액세스가 없기 때문에 어댑터가 내부에 액세스 할 수있는 경우에도 소스의 공용 API를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성을 구현하면 유형 고정의 제한이 해제되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 기능으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 특성의 구현 자를 '리더'라고합니다.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">&lt;code&gt;Write&lt;/code&gt; 특성의 구현 자는 때때로 '작가'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 배열 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 배열 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="translated">사전 식으로 배열 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 벡터 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 벡터 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 벡터 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;사전 식&lt;/a&gt; 으로 벡터 비교를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">문자열에 대한 비교 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">문자열 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">사 &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;전적으로&lt;/a&gt; 벡터의 순서를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">사 &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;전적으로&lt;/a&gt; 벡터의 순서를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">두 문자열을 연결하기위한 &lt;code&gt;+&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 에 추가하기위한 &lt;code&gt;+=&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">암시 적 차용</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">함수와 메소드를 사용한 암시 적 역 참조 강제</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">암시 적 차용은 다음과 같은 표현으로 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">암시 적으로 활성화</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">다른 상자 나 모듈에서 항목을 가져 오거나 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="translated">이름에 바인딩하지 않고 트레이 트의 메서드 만 가져 오기 위해 &lt;code&gt;_&lt;/code&gt; 로 가져 오기 (예 : 충돌 방지) : &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">변수 선언 및 표현식 문과 같이 항목이 아닌 문 뒤에는 가져 오기 ( &lt;code&gt;use&lt;/code&gt; 문)를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">스레드 풀을 사용하여 서버의 처리량을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">I / O 프로젝트 개선</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">스레드 풀로 처리량 개선</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">오류 메시지 개선</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 사용 &lt;code&gt;for&lt;/code&gt; 생성하는 루프 카운터 &lt;code&gt;id&lt;/code&gt; 새로 만드는 &lt;code&gt;Worker&lt;/code&gt; 그와 &lt;code&gt;id&lt;/code&gt; , 그리고 벡터에 노동자를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는 우리의 새로운 채널을 생성하고 풀 보류에게 보내는 끝이있다. 이것은 여전히 ​​경고와 함께 성공적으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는의 채널의 수신 측 넣어 &lt;code&gt;Arc&lt;/code&gt; 와 &lt;code&gt;Mutex&lt;/code&gt; . 각각의 새 작업자에 대해 우리는 &lt;code&gt;Arc&lt;/code&gt; 를 복제하여 참조 횟수를 늘려 작업자가 수신 엔드의 소유권을 공유 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 전화를 &lt;code&gt;Dog::baby_name&lt;/code&gt; 정의 관련 함수를 호출 기능, &lt;code&gt;Dog&lt;/code&gt; 직접. 이 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서는 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 두 인스턴스를 &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 다음 생성 된 CustomSmartPointer 를 인쇄 합니다. . 의 끝에서 &lt;code&gt;main&lt;/code&gt; , 우리의 경우 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 는 범위의 외출 것이며, 녹 우리가에 넣어 코드 호출 &lt;code&gt;drop&lt;/code&gt; 우리의 마지막 메시지를 인쇄하는 방법. &lt;code&gt;drop&lt;/code&gt; 메소드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리의 두 인스턴스 생성 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 을 누른 다음 인쇄 &lt;code&gt;CustomSmartPointers created&lt;/code&gt; . &lt;code&gt;main&lt;/code&gt; 이 끝날 때 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 인스턴스는 범위 를 벗어나고 Rust는 &lt;code&gt;drop&lt;/code&gt; 메소드에 넣은 코드를 호출하여 최종 메시지를 인쇄합니다. &lt;code&gt;drop&lt;/code&gt; 메서드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 새로운 문을 추가했습니다 : &lt;code&gt;fs::read_to_string&lt;/code&gt; 합니다 &lt;code&gt;filename&lt;/code&gt; 해당 파일을 엽니하고, 반환 &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; 파일의 내용.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리가 정의한 &lt;code&gt;Point&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;5&lt;/code&gt; )와 &lt;code&gt;f64&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (값 &lt;code&gt;10.4&lt;/code&gt; ). &lt;code&gt;p2&lt;/code&gt; 변수 A는 &lt;code&gt;Point&lt;/code&gt; 의 문자열 슬라이스 갖는 구조체 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) 및 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (가치와 &lt;code&gt;c&lt;/code&gt; ). 호출 &lt;code&gt;mixup&lt;/code&gt; 에 &lt;code&gt;p1&lt;/code&gt; 인수하여 &lt;code&gt;p2&lt;/code&gt; 우리가 제공 &lt;code&gt;p3&lt;/code&gt; 이되는, &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;p1&lt;/code&gt; 에서 왔기 때문 입니다. &lt;code&gt;p3&lt;/code&gt; 변수는있을 것이다 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; 로 하기 때문에, &lt;code&gt;y&lt;/code&gt; 는 온 &lt;code&gt;p2&lt;/code&gt; . &lt;code&gt;println!&lt;/code&gt; 매크로 호출은 &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">에서 &lt;code&gt;match&lt;/code&gt; 표현, 당신은을 사용하여 여러 패턴을 일치시킬 수 있습니다 &lt;code&gt;|&lt;/code&gt; 구문 수단 &lt;em&gt;또는&lt;/em&gt; . 예를 들어, 다음 코드는 &lt;code&gt;x&lt;/code&gt; 값과 일치 팔을 비교합니다. 첫 번째는 &lt;em&gt;또는&lt;/em&gt; 옵션이 있습니다. 즉 &lt;code&gt;x&lt;/code&gt; 값이 해당 팔의 값 중 하나와 일치하면 해당 팔의 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">C 및 C ++에서는 메소드 호출에 두 개의 다른 연산자가 사용됩니다 &lt;code&gt;.&lt;/code&gt; 객체에서 직접 메소드를 호출하는 경우 &lt;code&gt;-&amp;gt;&lt;/code&gt; 객체 에 대한 포인터에서 메소드를 호출하는 경우 먼저 포인터를 역 참조해야하는 경우 즉, &lt;code&gt;object&lt;/code&gt; 가 포인터 인 경우 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; 은 &lt;code&gt;(*object).something()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="translated">C에서 데이터 구조의 끝을 넘어서 읽으려는 시도는 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리의 위치에있는 모든 것을 얻을 수 있습니다. 이를 &lt;em&gt;버퍼 오버 읽기&lt;/em&gt; 라고하며 공격자가 데이터 구조 이후에 저장된 데이터를 읽을 수 없도록 인덱스를 조작 할 수있는 경우 보안 취약성을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">1 장에서는 &lt;code&gt;cargo new&lt;/code&gt; 가 에디션에 대한 약간의 메타 데이터를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 추가하는 것을 보았습니다 . 이 부록은 그 의미에 대해 이야기합니다!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;유형에 대한 특성 구현&amp;rdquo;&lt;/a&gt; 섹션의 10 장 에서 특성 또는 유형이 상자에 국한된 유형에 대한 특성을 구현할 수 있다는 고아 규칙을 언급했습니다. 튜플 구조체에서 새 유형을 만드는 &lt;em&gt;newtype pattern을&lt;/em&gt; 사용하여 이러한 제한을 &lt;em&gt;해결할 수&lt;/em&gt; 있습니다. ( 5 장의 &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&quot;명명 된 필드가없는 튜플 구조 사용&quot;&lt;/a&gt; 섹션에서 튜플 구조를 다루었습니다 . 튜플 구조에는 하나의 필드가 있고 특성을 구현하려는 유형 주위에 얇은 래퍼가됩니다. 그런 다음 포장지 유형은 상자에 국한되며 포장지에 특성을 구현할 수 있습니다. &lt;em&gt;신형&lt;/em&gt;하스켈 프로그래밍 언어에서 유래 한 용어입니다. 이 패턴을 사용하면 런타임 성능이 저하되지 않으며 컴파일시 래퍼 유형이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">10 장에서는 구조체에 참조를 저장할 수 있도록 이러한 오류를 수정하는 방법에 대해 설명하지만 지금 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 과 같은 참조 대신 &lt;code&gt;String&lt;/code&gt; 과 같은 소유 유형을 사용하여 이와 같은 오류를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">12 장에서 바이너리 상자와 라이브러리 상자가 포함 된 패키지를 만들었습니다. 프로젝트가 개발됨에 따라 라이브러리 상자가 계속 커지고 패키지를 여러 라이브러리 상자로 더 분할하려고 할 수 있습니다. 이 상황에서 Cargo는 &lt;em&gt;작업 영역&lt;/em&gt; 이라는 기능을 제공하여 함께 개발 된 여러 관련 패키지를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">13 장에서는 클로저가 환경에서 사용하는 값의 소유권을 갖도록 클로저의 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있다고 언급 했습니다. 이 기법은 한 스레드에서 다른 스레드로 값 소유권을 이전하기 위해 새 스레드를 작성할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">15 장에서는 스마트 포인터 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 참조 계수 값을 생성 하여 여러 소유자에게 값을 제공했습니다. 여기서도 똑같이하고 무슨 일이 일어나는지 봅시다. Listing 16-14의 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 랩핑하고 소유권을 스레드로 이동하기 전에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 복제한다 . 이제 오류를 보았으므로 &lt;code&gt;for&lt;/code&gt; 루프를 다시 사용하도록 전환 하고 &lt;code&gt;move&lt;/code&gt; 키워드를 클로저 로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">16 장에서는 다양한 동시 프로그래밍 모델을 살펴보고 Rust가 여러 스레드에서 두려움없이 프로그래밍하는 방법에 대해 설명합니다. 17 장에서는 Rust 관용구가 익숙한 객체 지향 프로그래밍 원칙과 어떻게 비교되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">16 장에서는 이 사용 사례에 적합한 &lt;em&gt;채널 (&lt;/em&gt; 두 스레드 간 통신하는 간단한 방법)에 대해 배웠습니다 . 채널을 사용하여 작업 대기열로 작동하고, &lt;code&gt;execute&lt;/code&gt; 하면 &lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code&gt;Worker&lt;/code&gt; 인스턴스로 작업을 보내면 작업이 스레드로 전송됩니다. 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">2 장에서는 &lt;code&gt;rand&lt;/code&gt; 라는 외부 패키지를 사용하여 임의의 숫자를 얻는 추측 게임 프로젝트를 프로그래밍했습니다 . 프로젝트에서 &lt;code&gt;rand&lt;/code&gt; 를 사용 하기 &lt;em&gt;위해이&lt;/em&gt; 행을 &lt;em&gt;Cargo.toml에&lt;/em&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">20 장에서는 저수준 멀티 스레드 웹 서버를 구현할 프로젝트를 완성 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">제 3 장에서 우리는 언급 &lt;code&gt;for&lt;/code&gt; 루프가 녹 코드에서 가장 일반적인 루프 구조이지만, 우리가 아직 그 패턴을 설명하지 않은 &lt;code&gt;for&lt;/code&gt; 소요됩니다. (A)에 &lt;code&gt;for&lt;/code&gt; 루프 패턴 직접 키워드 다음 값인 &lt;code&gt;for&lt;/code&gt; 너무에서 &lt;code&gt;for x in y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 패턴된다.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">4 장의 &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Dangling References&quot;&lt;/a&gt; 섹션에서 컴파일러는 참조가 항상 유효한지 확인한다고 언급했습니다. 안전하지 않은 녹에는 참조와 유사한 &lt;em&gt;원시 포인터&lt;/em&gt; 라는 두 가지 새로운 유형이 있습니다 . 참조와 마찬가지로 원시 포인터는 변경 불가능하거나 변경 가능하며 각각 &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 로 작성됩니다. 별표는 역 참조 연산자가 아닙니다. 유형 이름의 일부입니다. 원시 포인터의 맥락에서, &lt;em&gt;불변&lt;/em&gt; 은 의미가 역 참조 된 후 포인터를 직접 할당 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">5 장, 리스팅 5-15에서, 우리는 &lt;code&gt;Rectangle&lt;/code&gt; 구조체와 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 사용했다. 이것은 Listing 11-5에서 반복된다. 이 코드를 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에 넣고 &lt;code&gt;assert!&lt;/code&gt; 사용하여 테스트를 &lt;em&gt;해보자 &lt;/em&gt;! 매크로.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">6 장에서 우리는 &lt;code&gt;if let&lt;/code&gt; 식이 주로 하나의 경우에만 일치 하는 &lt;code&gt;match&lt;/code&gt; 을 작성하는 더 짧은 방법으로 사용하는 방법에 대해 논의했습니다 . 선택적으로, &lt;code&gt;if let&lt;/code&gt; 해당 할 수 있습니다 &lt;code&gt;else&lt;/code&gt; 실행 포함 된 코드를에서 패턴 경우 &lt;code&gt;if let&lt;/code&gt; 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">7 장에서는 &lt;code&gt;mod&lt;/code&gt; 키워드를 사용하여 코드를 모듈로 구성 하는 방법, &lt;code&gt;pub&lt;/code&gt; 키워드를 사용하여 항목을 공개 하는 방법 및 &lt;code&gt;use&lt;/code&gt; 키워드를 사용 하여 항목을 범위로 가져 오는 방법에 대해 설명했습니다 . 그러나 상자를 개발하는 동안 귀하에게 적합한 구조는 사용자에게별로 편리하지 않을 수 있습니다. 여러 수준을 포함하는 계층 구조에서 구조체를 구성하려고 할 수 있지만 계층에서 깊게 정의한 형식을 사용하려는 사람들은 해당 형식이 있는지 찾는 데 어려움이있을 수 있습니다. 그들은 또한 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; 을 입력 해야하는 것에 짜증이 날 수도 있습니다 . &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; 하지 말고 ; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">7 장에서는 Rust의 모듈 시스템과 코드 및 공개 API (Application Programming Interface) 구성을위한 개인 정보 보호 규칙에 대해 설명합니다. 8 장에서는 벡터, 문자열 및 해시 맵과 같은 표준 라이브러리가 제공하는 공통 컬렉션 데이터 구조에 대해 설명합니다. 9 장은 Rust의 오류 처리 철학과 기술을 탐구합니다.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">8 장에서 벡터의 한 가지 제한은 벡터가 한 가지 유형의 요소 만 저장할 수 있다는 것입니다. Listing 8-10에서 정수, 부동 수 및 텍스트를 보유하는 변형이 있는 &lt;code&gt;SpreadsheetCell&lt;/code&gt; 열거 형을 정의한 해결 방법을 만들었습니다 . 즉, 각 셀에 서로 다른 유형의 데이터를 저장할 수 있으며 셀 행을 나타내는 벡터를 계속 가질 수 있습니다. 이것은 상호 교환 가능한 항목이 코드 컴파일 시점을 알고있는 고정 된 유형의 세트 일 때 완벽하게 좋은 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">열거 형 정의에서</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">함수 정의에서</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">목록 10-3, 우리라는 이름의 함수로 가장 큰 수를 발견 한 코드 추출 &lt;code&gt;largest&lt;/code&gt; . 하나의 특정 목록에서만 가장 큰 숫자를 찾을 수있는 Listing 10-1의 코드와 달리이 프로그램은 두 개의 다른 목록에서 가장 큰 숫자를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">Listing 11-7에서 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성하여 매개 변수에 &lt;code&gt;2&lt;/code&gt; 를 더하고 결과를 리턴한다. 그런 다음 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">Listing 12-6에서 우리는 &lt;code&gt;String&lt;/code&gt; 값 의 슬라이스를 가져와 슬라이스 로 인덱싱하고 값을 복제하여 &lt;code&gt;Config&lt;/code&gt; 구조체 의 인스턴스를 생성하는 코드를 추가 하여 &lt;code&gt;Config&lt;/code&gt; 구조체가 해당 값을 소유 할 수있게했다 . Listing 13-24에서는 Listing 12-23에서와 같이 &lt;code&gt;Config::new&lt;/code&gt; 함수 의 구현을 재현했다 .</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">Listing 12-8에서 인덱스 1과 2에 액세스하기 전에 슬라이스가 충분히 길다는 것을 확인하는 &lt;code&gt;new&lt;/code&gt; 함수에 점검을 추가 한다. 슬라이스가 충분히 길지 않으면 프로그램은 패닉 상태가되고 더 나은 오류 메시지를 표시한다. &lt;code&gt;index out of bounds&lt;/code&gt; 메시지 색인 .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">Listing 13-18에서는 호출에서 반환 된 반복자를 반복 하여 벡터 로 &lt;code&gt;map&lt;/code&gt; 한 결과를 수집한다 . 이 벡터는 원래 벡터의 각 항목을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">Listing 13-19에서는 환경에서 &lt;code&gt;shoe_size&lt;/code&gt; 변수 를 캡처하여 &lt;code&gt;Shoe&lt;/code&gt; 구조체 인스턴스 컬렉션을 반복 하는 클로저와 함께 &lt;code&gt;filter&lt;/code&gt; 를 사용한다 . 지정된 크기의 신발 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">Listing 15-19에서 &lt;code&gt;main&lt;/code&gt; 을 변경 하여 list &lt;code&gt;c&lt;/code&gt; 주위에 내부 범위를 갖도록한다 . &lt;code&gt;c&lt;/code&gt; 가 범위를 벗어날 때 참조 카운트가 어떻게 변하는 지 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">Listing 15-26에서는 Listing 15-25의 정의를 사용 하는 &lt;code&gt;main&lt;/code&gt; 함수를 추가하고있다 . 이 코드의 목록을 작성 및 예약리스트 &lt;code&gt;b&lt;/code&gt; 의 목록에 그 점 &lt;code&gt;a&lt;/code&gt; . 그런 다음의 목록을 수정 를 가리 &lt;code&gt;b&lt;/code&gt; 기준주기를 생성. &lt;code&gt;println!&lt;/code&gt; 이 있습니다 ! 이 과정에서 참조 카운트가 다양한 지점에있는 것을 보여주는 방법 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">Listing 16-8에서 우리는 메인 스레드에서 채널의 수신단으로부터 값을 얻을 것이다. 이것은 강 끝의 물에서 고무 오리를 검색하거나 채팅 메시지를받는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">Listing 18-11에서 패턴 가드 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했다. 새로운 변수는 패턴 내부에서 생성 된 리콜 &lt;code&gt;match&lt;/code&gt; 외부 변수를 사용하는 대신에 식 &lt;code&gt;match&lt;/code&gt; . 새로운 변수는 외부 변수의 값에 대해 테스트 할 수 없음을 의미했습니다. Listing 18-27은이 문제를 해결하기 위해 매치 가드를 사용하는 방법을 보여준다.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">목록 7-11에서, 우리는 가져 &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; 의 범위에 모듈을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 의 우리가 단지 지정해야하므로 기능 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 통화에 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 에서 기능을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">Listing 7-11에서 왜 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 을 지정한 다음 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수에 &lt;code&gt;use&lt;/code&gt; 경로를 지정 하여 동일한 결과를 얻기 보다는 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; :: add_to_waitlist 를 호출 한 이유가 궁금 할 것이다 . 목록 7-13에서와 같이.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">분석법 정의에서</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">Rust 1.3에서는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156에&lt;/a&gt; 설명 된대로 기본 객체 수명 범위가 변경 될 것으로 예상됩니다 . 컴파일러가이 변경으로 인해 코드에 컴파일 오류가 발생할 수 있다고 생각하기 때문에 경고 메시지가 표시됩니다. 가능하지는 않지만 이것이 잘못된 경보 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="translated">Rust 2015에서 &lt;code&gt;use&lt;/code&gt; 구문의 경로 는 크레이트 루트에 상대적입니다. 현재 및 부모 모듈과 관련된 항목을 가져 오려면 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사를 각각 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="translated">Rust 2018에서는 &lt;code&gt;extern crate&lt;/code&gt; 선언이 필요하지 않으며 대신 &lt;code&gt;use&lt;/code&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="translated">Rust 2018에서 &lt;code&gt;use&lt;/code&gt; 명령문의 경로 는 상자 이름 또는 리터럴 &lt;code&gt;crate::&lt;/code&gt; 시작하지 않는 한 현재 모듈에 상대적 입니다.이 경우 상자 루트에서 시작합니다. Rust 2015 코드에서와 같이 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사는 각각 현재 및 부모 모듈을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">Rust에서 함수는 패닉 상태에 빠지거나 전 이적으로 패닉 상태에있는 함수를 호출하면 &quot;반환&quot;할 수 있습니다. 이러한 종류의 제어 흐름이 항상 예상되는 것은 아니며 두 가지 중요한 구성 요소의 조합을 통해 미묘한 버그가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">Rust에서 &lt;em&gt;릴리스 프로파일&lt;/em&gt; 은 서로 다른 구성으로 사전 정의되고 사용자 정의 가능한 프로파일로, 프로그래머가 코드 컴파일을위한 다양한 옵션을보다 효과적으로 제어 할 수 있습니다. 각 프로파일은 다른 프로파일과 독립적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 주석은 두 개의 슬래시로 시작하여 줄 끝까지 계속되어야합니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">Rust에서는 전역 변수를 &lt;em&gt;정적&lt;/em&gt; 변수 라고 합니다. Listing 19-9는 문자열 슬라이스를 값으로 사용하여 정적 변수를 선언하고 사용하는 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">Rust에서 통합 테스트는 라이브러리 외부에 있습니다. 라이브러리는 다른 코드와 같은 방식으로 라이브러리를 사용하므로 라이브러리의 공용 API에 속하는 함수 만 호출 할 수 있습니다. 이들의 목적은 라이브러리의 많은 부분이 올바르게 작동하는지 테스트하는 것입니다. 자체적으로 올바르게 작동하는 코드 단위는 통합시 문제가 발생할 수 있으므로 통합 코드의 테스트 범위도 중요합니다. 통합 테스트를 작성하려면 먼저 &lt;em&gt;tests&lt;/em&gt; 디렉토리 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">Rust에서는 다른 사용 사례에 대해 다른 유형의 표현을 제공하는 것이 일반적입니다. 예를 들어, 값에 대한 저장 위치 및 관리는 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 유형을 통해 특정 용도에 적합하게 선택 될 수 있습니다 . 모든 유형에 사용할 수있는 이러한 일반 래퍼 외에도 일부 유형은 선택적인 패싯을 제공하여 잠재적으로 비용이 많이 드는 기능을 제공합니다. 이러한 유형에 대한 예는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 기본 문자열을 확장 할 수있는 기능이 추가되는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . 단순하고 불변 인 문자열에는 추가 정보를 불필요하게 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하려는 경우 벡터가 아닌 슬라이스로 슬라이스를 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하고 싶을 때 슬라이스를 벡터보다는 인수로 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">Rust에서 이터레이터는 &lt;em&gt;게으르다&lt;/em&gt; . 즉, 이터레이터를 사용하기 위해 이터레이터를 소비하는 메소드를 호출 할 때까지 효과가 없다. 예를 들어, 목록 13-13의 코드는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정의 된 &lt;code&gt;iter&lt;/code&gt; 메소드 를 호출하여 벡터 &lt;code&gt;v1&lt;/code&gt; 의 항목에 대해 반복자를 작성합니다 . 이 코드 자체는 유용한 기능을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 단순 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 지정하거나 인수로 전달하면 수신자가 사본을 가져 와서 원래 값을 그대로 둡니다. 이러한 유형은 복사 할 때 할당 할 필요가없고 종료자가 없습니다 (즉, 소유 한 상자가 없거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ). 따라서 컴파일러는 복사가 저렴하고 안전하다고 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성을 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 규칙에 따라 명시 적으로 복사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 간단한 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 할당하거나 인수로 전달할 때 수신자는 원래 값을 그대로두고 사본을 얻습니다. 이러한 유형은 복사 할 할당이 필요하지 않으며 종료자가 없으므로 (즉, 소유 된 상자를 포함하지 않거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ) 컴파일러는 복사하기에 저렴하고 안전한 것으로 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 는 Clone 트레이 트를 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 명시 적으로 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">Rust에서 일부 유형은 컴파일 타임에 알려진 크기를 갖지 않습니다. 예를 들어, &lt;code&gt;[u32]&lt;/code&gt; 와 같은 슬라이스 유형 에서는 요소 수를 컴파일 타임에 알 수 없으므로 전체 크기를 계산할 수 없습니다. 결과적으로, 이러한 유형은 참조 (예 : &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 또는 다른 포인터 유형 (예 : &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; )을 통해서만 조작 할 수 있습니다 . 대신 참조로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">Rust에서 문자열은 항상 유효한 UTF-8이며 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">Rust에서 컴파일러는 값이 변하지 않는다고 말할 때 실제로 변하지 않도록 보장합니다. 즉, 코드를 읽고 쓸 때 값이 어떻게, 어디서 변경 될 수 있는지 추적 할 필요가 없습니다. 따라서 코드를 쉽게 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 관용적 주석 스타일은 두 개의 슬래시로 주석을 시작하고 주석은 줄 끝까지 계속됩니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">Rust에서 배열로 들어가는 값은 대괄호 안에 쉼표로 구분 된 목록으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">소유권과 차용의 개념을 사용하는 Rust에서 참조와 스마트 포인터의 추가 차이점은 참조는 데이터 만 빌리는 포인터라는 점입니다. 대조적으로, 많은 경우에, 스마트 포인터 는 그들이 가리키는 데이터를 &lt;em&gt;소유&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">Rust에서는 컴파일 타임에 크기가 알려진 경우에만 값을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">구조 정의에서</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">터키어에서 라틴어의 'i'는 두 가지 형식 대신 다섯 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">A의 &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 정의하고 관련 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 유형, 평생에만 반환 유형이 아닌 인수 유형에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 형, 수명은 인수 유형 만 반환 형식에 표시하지.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 프로그램에서 표준 라이브러리에는 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의해 사용되는 하나의 &quot;전역&quot;메모리 할당자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">일치 표현식에서는 숫자와 문자 만 범위와 일치시킬 수 있습니다. 컴파일러가 컴파일 타임에 범위가 비어 있지 않은지 확인하고 임의 비교 함수를 평가할 수 없기 때문입니다. 두 엔드 포인트 사이에서 주문 가능한 유형의 값을 캡처하려는 경우 가드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">보다 이상적인 세계에서는 주어진 유형이 (1.) &lt;code&gt;StructuralPartialEq&lt;/code&gt; 특성 &lt;em&gt;과&lt;/em&gt; (2.) &lt;code&gt;Eq&lt;/code&gt; 특성을 모두 구현하는지 확인하여 해당 요구 사항을 확인할 수 있습니다 . 그러나 &lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt; 를 &lt;em&gt;수행하는&lt;/em&gt; ADT를 가질 수 있으며 컴파일러가 받아들이기를 원하지만 상수의 유형이 &lt;code&gt;Eq&lt;/code&gt; 를 구현하지 못하는 경우가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebeafd71108fc97e3607fbd0638300cd9c65eab5" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">더 이상 세계에서 우리가 확인하여 해당 요구 사항을 확인할 수 있습니다 지정된 형태를 구현 모두 그 &lt;code&gt;StructuralPartialEq&lt;/code&gt; 의 특성 &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;Eq&lt;/code&gt; 특징. 그러나 &lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt; 를 &lt;em&gt;수행하는&lt;/em&gt; ADT를 가질 수 있으며 컴파일러가 받아들이기를 원하지만 상수의 유형이 &lt;code&gt;Eq&lt;/code&gt; 를 구현하지 못하는 경우가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">패턴에서 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하지 않는 모든 값 은 동일한 방식으로 바인딩되어야합니다. 여기서 목표는 이동 및 참조에 의한 바인딩을 동시에 피하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">패턴에서 : 포괄적 인 범위 패턴</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 비슷한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 하면 다시 호출하면 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; 을&lt;/a&gt; 다시 반환 할 수도 있고 반환하지 않을 수도 있습니다 . 이 목적을 위해 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 은 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 유사한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;code&gt;next_back()&lt;/code&gt; 에서 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 다시 호출하면 &lt;code&gt;Some&lt;/code&gt; 을 다시 반환하거나 반환하지 않을 수 있습니다 . &lt;code&gt;next()&lt;/code&gt; 와 &lt;code&gt;next_back()&lt;/code&gt; 은이 목적을 위해 상호 교환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">어떤 방식 으로든 모든 프로그래밍 언어의 채널은 단일 소유권과 유사합니다. 일단 채널로 값을 전송하면 더 이상 해당 값을 사용하지 않아야합니다. 공유 메모리 동시성은 다중 소유권과 같습니다. 여러 스레드가 동시에 동일한 메모리 위치에 액세스 할 수 있습니다. 스마트 포인터가 다중 소유권을 가능하게하는 15 장에서 보았 듯이, 서로 다른 소유자가 관리해야하기 때문에 다중 소유권이 복잡성을 추가 할 수 있습니다. Rust의 유형 시스템 및 소유권 규칙은 이러한 관리를 올바르게 수행하는 데 크게 도움이됩니다. 예를 들어, 공유 메모리에 대한 가장 일반적인 동시성 기본 요소 중 하나 인 뮤텍스를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">변경 불가능한 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 많은 상황에서 컴파일러가 &lt;code&gt;Deref&lt;/code&gt; 를 암시 적으로 사용합니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 변경 가능한 컨텍스트에서는 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">가변 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 &lt;code&gt;DerefMut&lt;/code&gt; 은 많은 환경에서 컴파일러에 의해 암시 적으로 사용됩니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 불변의 문맥에서는 &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">코드가 예상 한 올바른 값을 반환하는지 확인하는 것 외에도 코드가 예상 한대로 오류 조건을 처리하는지 확인하는 것이 중요합니다. 예를 들어, 9 장, 목록 9-10에서 만든 &lt;code&gt;Guess&lt;/code&gt; 유형을 고려하십시오 . 용도가 다른 코드를 &lt;code&gt;Guess&lt;/code&gt; 하는 보증에 따라 &lt;code&gt;Guess&lt;/code&gt; 경우 우리는 것을 보장이 만들려고하는 테스트를 작성할 수 1과 100 사이의 값만 포함됩니다 &lt;code&gt;Guess&lt;/code&gt; 범위 패닉 그 값 외부와 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">패턴 일치를 통해 구조를 제거하는 것 외에도 마침표 ( &lt;code&gt;.&lt;/code&gt; )와 액세스하려는 값의 색인을 사용하여 튜플 요소에 직접 액세스 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">메모리 블록 피팅 외에도 &lt;code&gt;layout&lt;/code&gt; 의 배향의 &lt;code&gt;layout&lt;/code&gt; 메모리의 블록을 할당하는 데 사용되는 정렬과 일치한다.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">그룹화 기능 외에도 구현 세부 정보를 캡슐화하면 코드를 더 높은 수준에서 재사용 할 수 있습니다. 작업을 구현 한 후에는 다른 코드가 구현 방식을 알지 않고도 코드의 공용 인터페이스를 통해 해당 코드를 호출 할 수 있습니다. 코드를 작성하는 방법은 다른 코드에 사용할 공용 파트와 변경 권한을 보유한 프라이빗 구현 세부 사항을 정의합니다. 이것은 머리에 유지해야 할 세부 사항의 양을 제한하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">&lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; 형식으로 고정 유형을 제공하는 것 외에도 함수는 유형 특성 목록을 특성 범위와 함께 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 외에도 Rust는 사용자가 주어진 범위 내에서만 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 이외에도 Rust를 사용하면 지정된 범위 내에서 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Clone&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Copy&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">또한받는 &lt;code&gt;#[cfg]&lt;/code&gt; 속성이 매크로 구성 플래그 논리식 평가를 허용하도록 제공된다. 이로 인해 코드 중복이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">서명에 따라 다양한 기능 포인터가 제공됩니다. 함수 포인터는 안전과 안전하지 않은 두 가지 방식으로 제공됩니다. 일반 &lt;code&gt;fn()&lt;/code&gt; 함수 포인터는 안전 함수 만 가리킬 수 있지만 &lt;code&gt;unsafe fn()&lt;/code&gt; 함수 포인터는 안전 또는 안전하지 않은 함수를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">또한, &lt;code&gt;unsafe&lt;/code&gt; 블록이 반드시 위험 내부의 코드를 의미하지 않거나 확실히 메모리 안전 문제가있는 것 : 의도는 프로그래머로, 당신은 내부의 코드를 확인합니다 것입니다 &lt;code&gt;unsafe&lt;/code&gt; 유효한 방법으로 블록 의지 액세스 메모리 .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">또한,의 함수 포인터 &lt;em&gt;어떤&lt;/em&gt; 서명, ABI, 또는 안전은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , 모든 &lt;em&gt;안전&lt;/em&gt; 함수 포인터 구현 &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; 을&lt;/a&gt; . 이러한 특성은 컴파일러에 특별히 알려져 있기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">또한 이것에 의해 암시 된 설계 선택이 있습니다. Rust는 자동으로 데이터의 &quot;심층&quot;사본을 자동으로 생성하지 않습니다. 따라서 &lt;em&gt;자동&lt;/em&gt; 복사는 런타임 성능 측면에서 저렴한 것으로 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">또한, 우리는 다룰 &lt;em&gt;내부 가변성&lt;/em&gt; 불변의 유형은 내부 값을 돌연변이에 대한 API를 노출 패턴. 또한 &lt;em&gt;참조주기&lt;/em&gt; , 메모리 누수 방법 및 방지 방법에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">다른 모든 경우 ( &lt;code&gt;setting_value&lt;/code&gt; 또는 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 ) 두 번째 암 의 &lt;code&gt;_&lt;/code&gt; 패턴으로 표시되면 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;setting_value&lt;/code&gt; 가되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">다른 모든 경우에는 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류 에서 &lt;code&gt;Dragon&lt;/code&gt; 열거 형 에서 &lt;code&gt;Born&lt;/code&gt; 변형 을 반환하려면 변형이 아닌 열거 형을 반환하도록 함수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류에서 우리 는 불가능한 &lt;code&gt;Mordor&lt;/code&gt; 모듈 을 인스턴스화하려고했습니다 . 모듈 내에서 유형을 인스턴스화하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">이중 연결 목록에서 컬렉션은 실제로 요소 자체에 메모리를 할당하지 않습니다. 할당은 클라이언트에 의해 제어되며 요소는 컬렉션보다 수명이 짧은 스택 프레임에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서는 중첩 된 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 사람들이 필요로하는 별도의 &lt;code&gt;use&lt;/code&gt; 문 수를 줄일 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서 중첩 된 경로를 사용하여 동일한 패키지 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 부분에서 필요한 개별 &lt;code&gt;use&lt;/code&gt; 문 수가 줄어들 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="translated">두 경우 모두 변수 ( &lt;code&gt;_&lt;/code&gt; 라고 함 )를 선언 하고 유형을 지정합니다. 그러나 &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; 및 &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; 는 유형이 아니므로 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">이 두 가지 예에서 '&amp;szlig;'는 인코딩하는 데 2 ​​바이트가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">이 두 가지 예에서 '𝕊'은 인코딩하는 데 두 개의 &lt;code&gt;u16&lt;/code&gt; 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특별한 동작을 호출하는 데 사용됩니다 (아래 &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; 및 &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt; 에서 설명 ). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치 및 전사됩니다. 예외는 matcher의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 &lt;code&gt;(())&lt;/code&gt; 는 &lt;code&gt;{()}&lt;/code&gt; 와 일치 하지만 &lt;code&gt;{{}}&lt;/code&gt; 와는 일치 하지 않습니다 . &lt;code&gt;$&lt;/code&gt; 문자 는 일치하거나 문자 그대로 기록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특수한 동작을 호출하는 데 사용됩니다 (아래의 &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions 참조&lt;/a&gt; ). 이러한 호출에 포함되지 않은 토큰은 문자 그대로 일치하고 기록됩니다 (단, 예외). 단, 매처의 외부 분리 문자는 모든 분리 문자 쌍과 일치합니다. 따라서, 예를 들어, 정규가 &lt;code&gt;(())&lt;/code&gt; 일치 &lt;code&gt;{()}&lt;/code&gt; 하지만 &lt;code&gt;{{}}&lt;/code&gt; . 문자 &lt;code&gt;$&lt;/code&gt; 는 문자 그대로 일치하거나 전사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">matcher와 transcriber에서 반복은 &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 안에 반복 될 토큰을 배치 한 후 반복 연산자를 선택적으로 선택하고 선택적으로 사이에 분리기 토큰이 있습니다. 분리기 토큰은 분리 기호 또는 반복 연산자 중 하나 이외의 임의의 토큰 일 수 있지만 &lt;code&gt;;&lt;/code&gt; 그리고 &lt;code&gt;,&lt;/code&gt; 가장 일반적이다. 예를 들어 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 는 쉼표로 구분 된 여러 식별자를 나타냅니다. 중첩 반복이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 크기의 종류 (얇은) 포인터에 대해, 이것은 단순한 과제와 동일한 효과를 가지고, 반면 크기를 지정하지 않은 형태로 (FAT) 포인터는,이 동작은, 포인터의 일부에 영향을 미칠 것이다.</target>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 변형의 경우 내부 오류를 검색합니다. &lt;code&gt;try!&lt;/code&gt; 그런 다음 &lt;code&gt;From&lt;/code&gt; 을 사용하여 변환을 수행합니다 . 이것은 특수 오류와보다 일반적인 오류 사이의 자동 변환을 제공합니다. 결과 오류가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">항목이 &lt;code&gt;impl&lt;/code&gt; 내부의 함수 인 경우 개인 도우미 함수를 정의하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="translated">문서 주석 다음에 항목을 문서화하려는 경우 외부 문서 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">중첩 모듈이 많은 경우 &lt;code&gt;pub use&lt;/code&gt; 하여 최상위 수준에서 유형을 다시 내 보내면 상자를 사용하는 사람들의 경험에 큰 차이가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">경우에 따라 Rust에 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 강제 변환 이라고하는이 변환을 수행하기에 충분한 정보가 없습니다 . 다음 예제에서 문자열 슬라이스 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; 은 특성 &lt;code&gt;TraitExample&lt;/code&gt; 을 구현하고 &lt;code&gt;example_func&lt;/code&gt; 함수 는 특성을 구현하는 모든 것을 취합니다. 이 경우 Rust는 두 가지 암시 적 변환을 수행해야하는데, Rust는이를 수행 할 수단이 없습니다. 따라서 다음 예제는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">경우에 따라 하위 바인딩이 메모리 안전을 위반할 수 있습니다. 차후 버전의 Rust에서 차용 검사기를 업데이트하면이 제한이 제거 될 수 있지만 현재는 패턴을 하위 바인딩없이 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">이에 비해 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 는 잠금을 획득 한 리더 또는 기록기를 구분하지 않으므로 잠금을 사용할 수있을 때까지 기다리는 스레드를 차단합니다. 라이터가 잠금을 보유하지 않는 한 &lt;code&gt;RwLock&lt;/code&gt; 을 사용하면 여러 독자가 잠금을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">결론 : 항상 원하는 색인이 실제로 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">반대로 열거 형을 공개하면 모든 변형이 공개됩니다. 우리는 단지 필요 &lt;code&gt;pub&lt;/code&gt; 전과 &lt;code&gt;enum&lt;/code&gt; 목록 7-10에서와 같이 키워드.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">대조적으로, Rust의 문장은 &lt;em&gt;대부분&lt;/em&gt; 시퀀스 표현 평가를 포함하고 명시 적으로 제공하는 역할 을합니다.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">반대로, 목록 19-7에서 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 을 사용하면 슬라이스를 사용할 때 충돌이 발생할 수 있습니다. 이 코드는 임의의 메모리 위치를 취하고 10,000 항목 길이의 슬라이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="translated">이러한 각 경우에는 시작이 알려지지 않은 일부 대상 유형 &lt;code&gt;T_t&lt;/code&gt; 로 상호 강제 변환 될 유형 &lt;code&gt;T0..Tn&lt;/code&gt; 세트가 있습니다 . LUB 강제 계산은 반복적으로 수행됩니다. 대상 유형 &lt;code&gt;T_t&lt;/code&gt; 는 유형 &lt;code&gt;T0&lt;/code&gt; 으로 시작합니다 . 각각의 새로운 유형 &lt;code&gt;Ti&lt;/code&gt; 에 대해 다음 여부를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="translated">위의 두 시나리오 중 하나에서 패턴 일치에서 이러한 상수 사용을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">본질적으로 &lt;code&gt;*const c_void&lt;/code&gt; 는 C의 &lt;code&gt;const void*&lt;/code&gt; 와 &lt;code&gt;*mut c_void&lt;/code&gt; 는 C의 &lt;code&gt;void*&lt;/code&gt; 와 같습니다 . 즉, Rust의 &lt;code&gt;()&lt;/code&gt; 유형 인 C의 &lt;code&gt;void&lt;/code&gt; 반환 유형 과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">함수 시그니처에서 각 매개 변수의 유형을 선언 &lt;em&gt;해야합니다&lt;/em&gt; . 이것은 Rust 디자인에서 의도적으로 결정한 것입니다. 함수 정의에 타입 주석이 필요하다는 것은 컴파일러가 코드의 다른 곳에서이를 사용하여 의미를 파악할 필요가 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">일반적으로 &lt;code&gt;--crate-type=bin&lt;/code&gt; 또는 &lt;code&gt;--crate-type=lib&lt;/code&gt; 는 모든 컴파일 요구에 충분해야하며 상자의 출력 형식에 대해보다 세밀한 제어가 필요한 경우 다른 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">일반적으로 C ++ 구현은 오버 헤드 제로 원칙을 준수합니다. 사용하지 않는 것은 지불하지 않습니다. 그리고 더 : 당신이 사용하는 것, 당신은 더 나은 코딩을 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">일반적으로 형식을 지정하여 수행 할 수있는 모든 캐스트는 &lt;code&gt;as&lt;/code&gt; 를 사용하여 수행 할 수도 있으므로 &lt;code&gt;let x: u32 = 123&lt;/code&gt; 을 쓰는 대신 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 쓸 수 있습니다 (참고 : &lt;code&gt;let x: u32 = 123&lt;/code&gt; 은 그 상황에서 최고입니다). 그러나 다른 방향에서는 동일하지 않지만, 명시 적으로 &lt;code&gt;as&lt;/code&gt; 를 사용하면 원시 포인터의 유형을 변경하거나 클로저를 원시 포인터로 바꾸는 것과 같이 암시 적으로 허용되지 않는 몇 가지 강제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">일반적으로 유형 지정을 통해 수행 할 수있는 모든 캐스트는 &lt;code&gt;as&lt;/code&gt; 를 사용하여 수행 할 수도 있으므로 &lt;code&gt;let x: u32 = 123&lt;/code&gt; 을 작성하는 대신 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 작성할 수 있습니다 (참고 : &lt;code&gt;let x: u32 = 123&lt;/code&gt; 은 그 상황에서 최고가 되십시오). 그러나 다른 방향에서도 마찬가지입니다. 명시 적으로 &lt;code&gt;as&lt;/code&gt; 를 사용하면 원시 포인터의 유형을 변경하거나 클로저를 원시 포인터로 바꾸는 것과 같이 암시 적으로 허용되지 않는 몇 가지 추가 강제 변환이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">일반적으로이 기능은 패닉 상태 일 수 있으므로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 소문자를 명시 적으로 처리하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">일반적으로 정규화 된 구문은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">일반적으로 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값 을 사용하려면 각 변형을 처리 할 코드가 필요합니다. &lt;code&gt;Some(T)&lt;/code&gt; 값 이있는 경우에만 실행되는 일부 코드를 원하며이 코드 는 내부 &lt;code&gt;T&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 값이 있고 해당 코드에 사용 가능한 &lt;code&gt;T&lt;/code&gt; 값 이없는 경우 다른 코드를 실행하려고 합니다. &lt;code&gt;match&lt;/code&gt; 표현식 열거 사용할 때 단지이를 수행하는 제어 흐름 구조이다 그것이 갖는 ENUM 어떤 변형에 따라 다양한 코드를 실행하고, 그 코드가 일치하는 값 안의 데이터를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">일반적으로 유형의 크기는 컴파일에서 안정적이지 않지만 프리미티브와 같은 특정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">일반적으로이 책은 앞뒤로 순서대로 읽고 있다고 가정합니다. 이후의 장은 이전 장의 개념을 바탕으로하며, 이전 장에서는 주제에 대한 자세한 내용을 다루지 않을 수 있습니다. 우리는 일반적으로 이후 장에서 주제를 다시 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">일반적으로 반박과 반박 할 수없는 패턴의 차이에 대해 걱정할 필요는 없습니다. 그러나 오류 메시지에 표시 될 때 응답 할 수 있도록 반품 성 개념에 익숙해야합니다. 이 경우 코드의 의도 된 동작에 따라 패턴 또는 패턴을 사용하는 구문을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">여기에서 &lt;code&gt;jon_snow&lt;/code&gt; 는 이미 &lt;code&gt;nights_watch&lt;/code&gt; 참조에 의해 빌려 &lt;code&gt;starks&lt;/code&gt; 동시에 스타크 폐쇄에 의해 빌릴 수 없습니다 . 이 문제를 해결하려면 차용이 끝난 후 마감을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 변경할 수 없으므로 &lt;code&gt;y&lt;/code&gt; 에서 변경 가능하게 빌리려고 하면 실패합니다. 이 오류를 해결하려면 &lt;code&gt;x&lt;/code&gt; 를 변경 가능 하게 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">여기에서 &lt;code&gt;y&lt;/code&gt; 는 내부 범위의 끝에서 삭제되지만 &lt;code&gt;println&lt;/code&gt; 까지 &lt;code&gt;x&lt;/code&gt; 에 의해 빌려집니다 . 이전 예제를 수정하려면 println 이후까지 &lt;code&gt;y&lt;/code&gt; 가 떨어지지 않도록 범위를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstra는 1972 년의&amp;ldquo;The Humble Programmer&amp;rdquo;에세이에서&amp;ldquo;프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법 일 수 있지만 그들의 부재를 보여주기에는 부적절하다&amp;rdquo;고 말했다. 그렇다고 테스트를 최대한 많이 시도해서는 안된다는 의미는 아닙니다!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">2009 년 발표에서&amp;ldquo;Null References : Billion Dollar Mistake&amp;rdquo;는 null 발명가 인 Tony Hoare가 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">불변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">스레드에서 &lt;code&gt;Worker&lt;/code&gt; 는 채널의 수신 측을 반복하고 수신 작업의 폐쇄를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">표준 라이브러리에서 반복자를 제공하지 않는 언어의 경우 인덱스 0에서 변수를 시작하고 해당 변수를 사용하여 벡터로 색인하여 값을 가져오고 루프에서 변수 값을 증가 시켜서 동일한 기능을 작성할 수 있습니다. 벡터의 총 항목 수에 도달 할 때까지</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">포인터가있는 언어에서는 다른 메모리에 포인터를 유지하면서 메모리를 확보하여 다른 사람에게 제공되었을 수있는 메모리의 위치를 ​​참조 하는 &lt;em&gt;댕글 링 포인터&lt;/em&gt; 를 잘못 만드는 것이 쉽습니다 . 이와 대조적으로 Rust에서는 컴파일러가 참조가 참조에 매달려 있지 않도록 보장합니다. 일부 데이터에 대한 참조가있는 경우 컴파일러는 데이터에 대한 참조가 데이터를 참조하기 전에 데이터가 범위를 벗어나지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">다른 많은 프로그래밍 언어에서 색인으로 참조하여 문자열의 개별 문자에 액세스하는 것은 유효하고 일반적인 작업입니다. 그러나 Rust에서 인덱싱 구문을 사용하여 &lt;code&gt;String&lt;/code&gt; 일부에 액세스하려고 하면 오류가 발생합니다. 목록 8-19의 유효하지 않은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">많은 프로그래밍 언어에서 스택과 힙에 대해 자주 생각할 필요가 없습니다. 그러나 Rust와 같은 시스템 프로그래밍 언어에서 값이 스택에 있는지 또는 힙에 있는지는 언어의 작동 방식과 특정 결정을 내리는 이유에 더 많은 영향을 미칩니다. 소유권의 일부는이 장의 뒷부분에서 스택 및 힙과 관련하여 설명되므로 준비에 대한 간단한 설명이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 블록 내의 메소드 시그니처 에서 참조는 구조체의 필드에있는 참조의 수명과 연관되거나 독립적 일 수 있습니다. 또한 수명 제거 규칙을 사용하면 메서드 서명에 수명 주석이 필요하지 않은 경우가 많습니다. Listing 10-25에서 정의한 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 라는 구조체를 사용하여 몇 가지 예를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">메소드 서명에는 다른 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입 한 후 저장하려는 값의 유형을 종종 유추 할 수 있으므로이 유형 주석을 수행 할 필요가 거의 없습니다. 초기 값을 갖는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 생성하는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 제공합니다 ! 편의상 매크로. 매크로는 사용자가 제공 한 값을 보유한 새 벡터를 생성합니다. Listing 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입하면 저장하려는 값의 유형을 추론 할 수 있으므로이 유형 주석을 거의 수행 할 필요가 없습니다. 초기 값이 있는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 만드는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 편의를 위해 매크로. 매크로는 사용자가 제공 한 값을 보유하는 새 벡터를 생성합니다. 목록 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 . 정수 유형은 3 장의 &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;데이터 유형&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기본 정수 유형이므로 &lt;code&gt;i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="translated">대부분의 경우 (모두는 아니지만) 하나의 표현 힌트 만 사용하면 충분합니다. 현재 아키텍처에 따라 표현 힌트를 &lt;code&gt;cfg_attr&lt;/code&gt; 려면 cfg_attr을 사용 하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">대부분의 경우 더 이상 특정 함수 매개 변수가 필요하지 않은 경우 서명을 변경하여 사용하지 않는 매개 변수가 포함되지 않도록합니다. 함수 매개 변수를 무시하면 특정 유형 서명이 필요하지만 구현의 함수 본문에 매개 변수 중 하나가 필요하지 않은 경우 특성을 구현할 때와 같이 일부 경우에 특히 유용 할 수 있습니다. 그러면 컴파일러는 이름을 대신 사용했을 때와 같이 사용하지 않는 함수 매개 변수에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="translated">대부분의 경우 잊혀진 가져 오기 또는 오타입니다. 그러나 이러한 유형을 가질 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">대부분의 경우 참조는 원래 값과 매우 유사하게 사용할 수 있습니다. 필드 액세스, 메소드 호출 및 인덱싱은 동일하게 작동합니다 (물론 변경 규칙 저장). 또한 비교 연산자는 참조의 구현을 투명하게 참조하여 참조 값을 소유 한 값과 동일하게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">대부분의 최신 운영 체제에서 실행 된 프로그램의 코드는 &lt;em&gt;프로세스&lt;/em&gt; 에서 실행되며 운영 체제는 여러 프로세스를 한 번에 관리합니다. 프로그램 내에서 동시에 실행되는 독립 부품을 가질 수도 있습니다. 이러한 독립 부품을 실행하는 기능을 &lt;em&gt;스레드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">대부분의 경우 컴파일되지 않은 올바른 코드 버전으로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">가변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">변경 가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">한 번의 컴파일 세션에서 컴파일러는 명령 행 플래그 또는 &lt;code&gt;crate_type&lt;/code&gt; 속성을 사용하여 여러 아티팩트를 생성 할 수 있습니다 . 하나 이상의 명령 행 플래그가 지정된 경우, 모든 &lt;code&gt;crate_type&lt;/code&gt; 속성은 명령 행으로 지정된 아티팩트 만 빌드하기 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">한 가지 방법으로이 프로그램이 더 좋습니다. 튜플을 사용하면 약간의 구조를 추가 할 수 있으며 이제는 하나의 인수 만 전달합니다. 그러나 다른 방식으로,이 버전은 덜 명확합니다. 튜플은 해당 요소의 이름을 지정하지 않으므로 튜플의 일부를 인덱싱해야하기 때문에 계산이 더 혼란스러워졌습니다.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">유형이이 특성을 구현하려면 모든 메소드에 대한 구현을 제공해야 할뿐만 아니라 유형 &lt;code&gt;E&lt;/code&gt; 를 지정해야합니다 . 표준 라이브러리 유형 &lt;code&gt;Vec&lt;/code&gt; 에 대한 &lt;code&gt;Container&lt;/code&gt; 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 작성 하려면 &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 생성하려면 &lt;a href=&quot;struct.openoptions#method.write&quot;&gt; &lt;code&gt;OpenOptions::write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.openoptions#method.append&quot;&gt; &lt;code&gt;OpenOptions::append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Rust의 전역 유형 유추가 없음을 일관성있게 유지하기 위해 항목 서명의 디자인으로 유형 및 const 자리 표시자가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="translated">요구 사항을 &lt;code&gt;'static&lt;/code&gt; 에서 인수에서 파생 된 수명 으로 변경하려면 익명 수명 &lt;code&gt;'_&lt;/code&gt; 또는 적절한 명명 된 수명에 명시 적 경계를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="translated">이러한 종류의 제약 조건을 인코딩하려면 &lt;code&gt;where&lt;/code&gt; 절과 새로운 유형 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제네릭 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 할 수있는 모든 인수를 취하기를 원한다는 것을 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 경계를 사용할 수 있습니다 . 예 : &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 로 변환 할 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일반 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 될 수있는 모든 인수를 취하도록 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 범위를 사용할 수 있습니다 . 예를 들어, &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 로 변환 될 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">이 오류를 해결하려면 사용중인 유형이 특성을 구현하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">이 오류를 해결하려면 &lt;code&gt;pub&lt;/code&gt; 키워드 를 사용하여 항목을 공개해야 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">컴파일 타임에 내장 함수를 사용 &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;하려면 https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; 에서 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 로 구현을 복사해야합니다. /interpret/intrinsics.rs 및 내장 함수에 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">컴파일 타임에 내장 함수를 사용하려면 https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs에서 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 로 구현을 복사해야합니다. /interpret/intrinsics.rs는 추가 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 극한한다.</target>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴을보다 인체 공학적으로 만들기 위해 &lt;a href=&quot;types/function-item&quot;&gt;함수 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;클로저 특성&lt;/a&gt; 서명 에서 수명 인수를 &lt;em&gt;생략&lt;/em&gt; 할 수 있습니다 . 다음 규칙은 생략 된 수명에 대한 수명 매개 변수를 유추하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; ' 도 동일한 방식으로 수명을 추정하는 데 사용할 수 있습니다. 경로의 수명 동안 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴이 더 인체 공학적으로 만들기 위해, 평생 인수 할 수있다 &lt;em&gt;생략&lt;/em&gt; 의 &lt;a href=&quot;types/function-item&quot;&gt;기능 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;폐쇄 형질&lt;/a&gt; 서명. 다음 규칙은 제거 된 수명에 대한 수명 매개 변수를 추론하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; 은 동일한 방식으로 수명을 추론하는 데 사용할 수도 있습니다. 경로의 수명의 경우 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="translated">C 표현 레이아웃 &lt;code&gt;repr(C)&lt;/code&gt; 를 일치 &lt;code&gt;pad_to_align&lt;/code&gt; 려면 레이아웃을 모든 필드로 확장 한 후 pad_to_align 을 호출해야 합니다. (지정되지 않았기 때문에 기본 Rust 표현 레이아웃 &lt;code&gt;repr(Rust)&lt;/code&gt; 와 일치하는 방법은 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">사용하기 쉽고 사용자에게 필요한 내용 만 노출하는 잘 구성된 API를 사용자에게 제공하기 위해 이제 Rust의 모듈을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">즉, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; 이다 &lt;em&gt;하지&lt;/em&gt; 같은 &lt;code&gt;y&lt;/code&gt; , 그것을하지 않는 정의되지 않은 동작 간접 참조 인 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 로 포인트 동일한 할당 된 개체.</target>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">다시 말해서, 모든 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 는&lt;/a&gt; 자신을 반환함으로써 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 이것은 두 가지를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">즉, 각 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;park&lt;/code&gt; 및 &lt;code&gt;unpark&lt;/code&gt; 를 사용하여 잠 그거나 잠금을 해제 할 수있는 스핀 락과 같은 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">다시 말해, 크기가 0 인 포인터가 할당 자에서 흘러 나올 수 있으면 할당자는 마찬가지로 해당 포인터가 할당 해제 및 재 할당 방법으로 다시 흐르는 포인터를 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">즉, 두 키가 같으면 해시도 같아야합니다. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 은&lt;/a&gt; 모두이 동작에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">즉, 두 키가 같으면 해시가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="translated">즉, 위의 예에서 &lt;code&gt;Drop::drop&lt;/code&gt; 을 명시 적으로 호출하려고 하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">즉, 두 반복기를 체인으로 연결합니다. 🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">즉, &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 레이어를 자동으로 제거합니다 . 매핑이 이미 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환하고 건너 뛰려는 경우&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 의 다음 &lt;code&gt;filter_map&lt;/code&gt; 사용에 훨씬 좋네요 훨씬이다.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">즉, 두 개의 이터레이터를 하나로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">즉, &lt;code&gt;f(c)&lt;/code&gt; 와 같은 모든 문자 &lt;code&gt;c&lt;/code&gt; 를 제거하십시오. 가 &lt;code&gt;false&lt;/code&gt; 를 반환 . 이 방법은 원래 순서대로 각 문자를 한 번만 방문하여 유지되며 유지되는 문자의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="translated">즉, 모든 요소가 제거 &lt;code&gt;e&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; . 요소는 정렬되지 않은 (및 지정되지 않은) 순서로 방문됩니다.</target>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; . 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거 하여 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; false를 돌려 준다. 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, 모든 쌍을 제거 &lt;code&gt;(k, v)&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, 모든 쌍 제거 &lt;code&gt;(k, v)&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">즉, 결과는 &lt;code&gt;self / rhs&lt;/code&gt; 정수로 반올림 &lt;code&gt;n&lt;/code&gt; 되도록 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . 경우 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; 이 제로 (녹 기본값)쪽으로 둥근 같다; 만약 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; 이 무한대를 향하여 +/- 라운드 같다.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">다시 말해 여기에는 두 가지 중요한 시점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">다시 말해, Rust에게 &lt;code&gt;search&lt;/code&gt; 함수에 의해 반환 된 데이터 는 &lt;code&gt;contents&lt;/code&gt; 인수 에서 &lt;code&gt;search&lt;/code&gt; 함수에 전달 된 데이터가 존재하는 한 지속될 것이라고 Rust에 알려줍니다 . 이건 중요하다! 슬라이스가 참조 &lt;em&gt;하는&lt;/em&gt; 데이터 는 참조가 유효해야합니다. 컴파일러는 우리의 문자열 조각을 만들고 있어요 가정하면 &lt;code&gt;query&lt;/code&gt; 보다는 &lt;code&gt;contents&lt;/code&gt; &lt;em&gt;&lt;/em&gt; 안전성 검사가 잘못 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">즉, &lt;code&gt;match&lt;/code&gt; 하는 구문 설탕으로 생각 &lt;code&gt;if let&lt;/code&gt; 값이 하나의 패턴과 일치하는 실행 코드와 다른 모든 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">즉, 당신은 변환해야 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; A와 &lt;code&gt;T&lt;/code&gt; 수행하기 전에 &lt;code&gt;T&lt;/code&gt; 의 그것으로 작업을. 일반적으로 이것은 null과 관련하여 가장 일반적인 문제 중 하나를 포착하는 데 도움이됩니다. 실제로는 무언가가 null이 아니라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">다시 말해서 : t &amp;isin; FOLLOW (M) 토큰 시퀀스가 ​​존재하는 경우에만 (잠재적으로 비어 있음) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; 여기서 :</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">그러나 잘못된 예에서는 단일 콘크리트 유형을 참조하고 있습니다. 우리는 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현 한다는 것을 알고 있기 때문에 &lt;code&gt;where&lt;/code&gt; 절 에도이를 지정할 이유가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; 및 &lt;code&gt;Hash&lt;/code&gt; 는 차용 및 소유 값과 동일해야합니다. &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; 는 &lt;code&gt;x == y&lt;/code&gt; 와 동일한 결과를 제공해야합니다. .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="translated">특히, 함수 포인터에 &lt;code&gt;#[track_caller]&lt;/code&gt; 를 사용하여 함수를 강제하면 관찰자가 속성 함수의 정의 사이트에서 호출 된 것처럼 보이는 shim이 생성되어 가상 호출에서 실제 호출자 정보가 손실됩니다. 이 강제의 일반적인 예는 메서드가 속성을 갖는 특성 개체의 생성입니다.</target>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">특히, 하나의 소정의 할당을 통해 할당 된 메모리 블록이 있는지 레이아웃 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;a.usable_size(k)&lt;/code&gt; 를 반환 &lt;code&gt;(l, u)&lt;/code&gt; 다음 하나의 해당 블록을 전달할 수 &lt;code&gt;a.dealloc()&lt;/code&gt; 크기에 레이아웃을 범위 [l, u]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="translated">특히, 이전 코드 예제에서와 같이 레지스터 제약 조건의 닫는 대괄호를 잊은 경우 (문제 # 51430 참조) 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">특히 레지스터 제약 조건의 닫는 괄호를 잊어 버린 경우 발생할 수 있습니다 (문제 # 51430 참조).</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">특히, 원시 항목을 초기화하는 데 사용 된 해시는 여전히 항목에 저장된 키의 해시와 일치해야합니다. 크기를 조정할 때 HashMap 구현에서 키만 사용 가능한 해시를 다시 계산해야 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">특히 결과 포인터는 &lt;code&gt;self&lt;/code&gt; 가 가리키는 동일한 할당 된 개체에 연결된 상태로 유지 됩니다. 다른 할당 된 개체에 액세스하는 데 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; . Rust에서 모든 (스택 할당) 변수는 별도의 할당 된 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">특히, 리턴 값 &lt;code&gt;r&lt;/code&gt; 은 대부분의 경우 &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; 를 충족시킵니다 . 그러나, 부동 소수점에 의한 반올림 에러는 발생할 수있다 &lt;code&gt;r == rhs.abs()&lt;/code&gt; 경우 수학적 정의를 위반 &lt;code&gt;self&lt;/code&gt; 보다 훨씬 작다 &lt;code&gt;rhs.abs()&lt;/code&gt; 크기와의 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . 이 결과는 함수의 공동 도메인 요소가 아니지만 실수에서 가장 가까운 부동 소수점 수이므로 &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 속성을 대략적으로 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="translated">특히이 반복기가 구성되는 내부 부분에 대해 &lt;code&gt;fold()&lt;/code&gt; 호출을 시도 하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">특히, 이 반복자가 구성된 내부 부분에서 &lt;code&gt;try_fold()&lt;/code&gt; 호출을 시도 하십시오. 여러 번의 통화가 필요한 경우 &lt;code&gt;?&lt;/code&gt; 연산자는 누산기 값을 연결하는 데 편리하지만 초기 반품 전에 유지해야하는 불변량을주의하십시오. 이것은 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 메소드이므로 오류가 발생한 후 반복을 재개 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">드문 경우이지만 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 대신 패닉이 발생하는 코드를 작성하는 것이 더 적절합니다 . 예제, 프로토 타입 코드 및 테스트에서 패닉이 적절한 이유를 살펴 보겠습니다. 그런 다음 컴파일러가 실패가 불가능하다고 말할 수는 없지만 사람이 할 수있는 상황에 대해 논의합니다. 이 장은 라이브러리 코드에서 패닉 상태를 결정하는 방법에 대한 일반적인 지침으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">간단히 말해 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 모든 유형일 수 있음)는 다른 유형이므로 컴파일러는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값을 마치 유효한 값인 것처럼 사용할 수 없게 합니다. 예를 들어,이 코드는 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; &lt;code&gt;i8&lt;/code&gt; 을 추가하려고하기 때문에 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">단일 스레드 시나리오에서는 신호 처리기 또는 특정 종류의 저수준 코드를 작성할 때 문제가 발생할 수 있습니다. 이 순서를 방지 하려면 &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;컴파일러 펜스&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="translated">일부 컨텍스트에서 컴파일러는 가장 일반적인 유형을 찾으려고 시도하고 찾기 위해 여러 유형을 함께 강제해야합니다. 이를 &quot;Least Upper Bound&quot;강제라고합니다. LUB 강제는 다음과 같은 상황에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">일부 언어에서는 프로그래머가 스마트 포인터 인스턴스 사용을 마칠 때마다 메모리 나 리소스를 비우려면 코드를 호출해야합니다. 잊어 버린 경우 시스템이 과부하되어 충돌 할 수 있습니다. Rust에서는 값이 범위를 벗어날 때마다 특정 코드 비트가 실행되도록 지정할 수 있으며 컴파일러는이 코드를 자동으로 삽입합니다. 결과적으로 특정 유형의 인스턴스가 완료된 프로그램의 어느 곳에 나 정리 코드를 배치 할 때주의 할 필요가 없습니다. 여전히 리소스가 누출되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="translated">일부 프로그래밍 언어에서 문자열 형식화 함수의 동작은 운영 체제의 로케일 설정에 따라 다릅니다. Rust의 표준 라이브러리에서 제공하는 형식 함수는 로케일 개념이 없으며 사용자 구성에 관계없이 모든 시스템에서 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 유형 조합이 모호 할 수 있습니다. 모호성을 피하기 위해 유형 주위에 괄호를 사용하십시오. 예를 들어, &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;참조 유형&lt;/a&gt; 내의 &lt;a href=&quot;trait-bounds&quot;&gt;유형 경계에&lt;/a&gt; 대한 &lt;code&gt;+&lt;/code&gt; 연산자 는 경계가 적용되는 위치가 확실하지 않으므로 괄호를 사용해야합니다. 이 명확성을 요구하는 문법 규칙 은 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; 대신 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; 규칙을 사용합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">경우에 따라 유효한 부동 소수점을 만들어야하는 일부 문자열은 대신 오류를 반환합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;이슈 # 31407&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;let x = 5;&lt;/code&gt; 와 같은 문장에서 ; 의 변수 이름 &lt;code&gt;PATTERN&lt;/code&gt; 의 슬롯 변수 이름은 패턴의 특히 단순한 형태이다. Rust는 표현식을 패턴과 비교하고 찾은 이름을 지정합니다. 따라서 &lt;code&gt;let x = 5;&lt;/code&gt; 예를 들어, &lt;code&gt;x&lt;/code&gt; 는 &quot;여기에 일치하는 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미하는 패턴입니다 . &lt;code&gt;x&lt;/code&gt; 라는 이름 은 전체 패턴이므로이 패턴은 &quot; 값에 관계없이 모든 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">이 경우 컴파일러는 다음과 같은 상황에서 &lt;code&gt;foo()&lt;/code&gt; 의 반환 유형을 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">요약하면 코드를 Listing 10-2에서 Listing 10-3으로 변경하기 위해 취한 단계는 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">면에서는 &lt;a href=&quot;../sync/atomic/index&quot;&gt;원자 메모리 순서화&lt;/a&gt; , 연관된 스레드의 완성이 함수 리턴과 동기화한다. 즉, 해당 스레드가 수행하는 모든 작업은 &lt;code&gt;join&lt;/code&gt; 반환 된 후 발생하는 모든 작업보다 먼저 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="translated">특성에 필요하지 않은 2015 년 판 매개 변수 패턴 :</target>
        </trans-unit>
        <trans-unit id="95c17fb8e8e9e84f4aa64abfe2139c371569ca73" translate="yes" xml:space="preserve">
          <source>In the 2015 edition the parameters pattern was not needed for traits:</source>
          <target state="translated">2015 년 판에서는 특성에 매개 변수 패턴이 필요하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">2015 년판에서 &lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt; 은 유형 위치에 사용될 때 키워드이며 &lt;code&gt;::&lt;/code&gt; 로 시작하지 않는 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">2015 년판에서 특성 함수 또는 메소드 매개 변수의 패턴은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">2018 년 판에서, 범위 내 아이템이 외부 상자와 이름이 같은 &lt;code&gt;use&lt;/code&gt; , 해당 상자 이름 을 사용 하려면 &lt;code&gt;::&lt;/code&gt; 를 사용하여 상자 이름을 명확하게 선택해야합니다. 이는 잠재적 인 향후 변경 사항과의 호환성을 유지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;유니 코드 표준&lt;/a&gt; , 제 4 장 (문자 속성) 일반적으로 케이스 매핑에 대해 설명하고 3 장 (준수)의 경우 변환을위한 기본 알고리즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">에서 &lt;a href=&quot;index&quot;&gt;모듈 수준의 문서&lt;/a&gt; , 우리는 구현 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . &lt;code&gt;ExactSizeIterator&lt;/code&gt; 도 구현해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">에서 &lt;a href=&quot;index&quot;&gt;모듈 수준의 문서&lt;/a&gt; , 우리는 구현 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . &lt;code&gt;ExactSizeIterator&lt;/code&gt; 도 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">Listing 5-1 의 &lt;code&gt;User&lt;/code&gt; 구조체 정의에서 &lt;code&gt;&amp;amp;str&lt;/code&gt; 문자열 슬라이스 타입 대신 소유 한 &lt;code&gt;String&lt;/code&gt; 타입을 사용했다 . 이 구조체의 인스턴스가 모든 데이터를 소유하고 전체 구조체가 유효한 한 해당 데이터가 유효하기를 원하기 때문에 이것은 신중한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">에서 &lt;code&gt;handle_connection&lt;/code&gt; 의 기능, 우리는했습니다 &lt;code&gt;stream&lt;/code&gt; 변경 가능한 매개 변수입니다. 그 이유는 &lt;code&gt;TcpStream&lt;/code&gt; 인스턴스가 어떤 데이터를 내부적으로 반환했는지 추적하기 때문입니다. 요청한 것보다 많은 데이터를 읽고 다음에 데이터를 요청할 때 해당 데이터를 저장할 수 있습니다. 따라서 내부 상태가 변경 될 수 있으므로 &lt;code&gt;mut&lt;/code&gt; 해야합니다 . 일반적으로&amp;ldquo;읽기&amp;rdquo;는 돌연변이가 필요없는 것으로 생각하지만이 경우에는 &lt;code&gt;mut&lt;/code&gt; 키워드 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 시맨틱 버전 지정자 &lt;code&gt;0.3.14&lt;/code&gt; 로 &lt;code&gt;rand&lt;/code&gt; 상자를 지정합니다 . Cargo 는 버전 번호 작성 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전 관리&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )를 이해 합니다. 숫자 &lt;code&gt;0.3.14&lt;/code&gt; 는 실제로 &lt;code&gt;^0.3.14&lt;/code&gt; 약자입니다 . &quot;0.3.14 버전과 호환되는 공개 API가있는 모든 버전&quot;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 의미 론적 버전 지정자 &lt;code&gt;0.5.5&lt;/code&gt; 를 사용하여 &lt;code&gt;rand&lt;/code&gt; crate를 지정합니다 . Cargo 는 버전 번호 작성을위한 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )을 이해 합니다. 숫자 &lt;code&gt;0.5.5&lt;/code&gt; 는 실제로 &lt;code&gt;^0.5.5&lt;/code&gt; 약칭 이며 , 이는 '버전 0.5.5와 호환되는 공개 API가있는 모든 버전'을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3eddcd6a499d2c2be1d503ec8a0e525837574e9f" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means any version that is at least &lt;code&gt;0.5.5&lt;/code&gt; but below &lt;code&gt;0.6.0&lt;/code&gt;. Cargo considers these versions to have public APIs compatible with version &lt;code&gt;0.5.5&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 의미 론적 버전 지정자 &lt;code&gt;0.5.5&lt;/code&gt; 를 사용하여 &lt;code&gt;rand&lt;/code&gt; crate를 지정합니다 . Cargo 는 버전 번호 작성을위한 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )을 이해 합니다. 수 &lt;code&gt;0.5.5&lt;/code&gt; 은 속기 실제로 &lt;code&gt;^0.5.5&lt;/code&gt; 적어도 어떤 버전 수단 &lt;code&gt;0.5.5&lt;/code&gt; 그러나 아래 &lt;code&gt;0.6.0&lt;/code&gt; 을&lt;em&gt;&lt;/em&gt;. Cargo는 이러한 버전이 버전 &lt;code&gt;0.5.5&lt;/code&gt; 와 호환되는 공용 API를 가지고 있다고 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">에 &lt;em&gt;추가 한 / SRC / lib.rs의&lt;/em&gt; 파일의는 추가 할 수 &lt;code&gt;add_one&lt;/code&gt; 의 기능 :</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">위의 예 에서 컴파일러는 &lt;code&gt;T&lt;/code&gt; 를 알 수 없습니다. 이 문제를 해결하려면 생성기를 구성 할 수 있도록 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;String&lt;/code&gt; 과 같은 콘크리트 유형에 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">절대 경로에서 우리는 상자의 모듈 트리의 루트 인 &lt;code&gt;crate&lt;/code&gt; 로 시작 합니다. 그런 다음 &lt;code&gt;front_of_house&lt;/code&gt; 모듈은 크레이트 루트에 정의됩니다. &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈 공개 아니지만 때문에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 함수와 같은 모듈에 정의 &lt;code&gt;front_of_house&lt;/code&gt; (이라고 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 와 &lt;code&gt;front_of_house&lt;/code&gt; 형제이다), 우리는 참조 할 수 &lt;code&gt;front_of_house&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; . 다음은 &lt;code&gt;pub&lt;/code&gt; 으로 표시된 &lt;code&gt;hosting&lt;/code&gt; 모듈 입니다. &lt;code&gt;hosting&lt;/code&gt; 의 상위 모듈에 액세스 할 수 있으므로 액세스 할 수 있습니다 . 마지막으로 &lt;code&gt;hosting&lt;/code&gt; &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수는 &lt;code&gt;pub&lt;/code&gt; 으로 표시되며 부모 모듈에 액세스 할 수 있으므로이 함수 호출이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 본문 에서보다 큼 ( &lt;code&gt;&amp;gt;&lt;/code&gt; ) 연산자를 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 두 값을 비교하려고했습니다 . 이 연산자는 표준 라이브러리 특성 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 에서 기본 메소드로 정의 되므로 &lt;code&gt;T&lt;/code&gt; 의 특성 경계에 &lt;code&gt;PartialOrd&lt;/code&gt; 를 지정해야 &lt;code&gt;largest&lt;/code&gt; 함수가 비교할 수있는 모든 유형의 슬라이스에서 작동 할 수 있습니다. &lt;code&gt;PartialOrd&lt;/code&gt; 가 서곡에 포함되어 있으므로 범위 내로 가져올 필요가 없습니다 . &lt;code&gt;largest&lt;/code&gt; 서명 을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">본문에 &lt;code&gt;shoes_in_my_size&lt;/code&gt; , 우리는 전화 &lt;code&gt;into_iter&lt;/code&gt; 벡터의 소유권을 반복자를 만들 수 있습니다. 그런 다음 &lt;code&gt;filter&lt;/code&gt; 를 호출 하여 해당 반복자를 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 요소 만 포함하는 새 반복기에 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">일반 함수의 본문에서 &lt;code&gt;Trait&lt;/code&gt; 의 메소드는 &lt;code&gt;Ty&lt;/code&gt; 값에서 호출 될 수 있습니다 . 마찬가지로 &lt;code&gt;Trait&lt;/code&gt; 의 관련 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 에 연관된 &lt;code&gt;break&lt;/code&gt; 가있는 경우 분기되는 것으로 간주되지 않으며 &lt;code&gt;loop&lt;/code&gt; 는 각 &lt;code&gt;break&lt;/code&gt; 표현식 과 호환되는 유형이어야합니다 . &lt;code&gt;break&lt;/code&gt; 발현없이가 동일 간주 &lt;code&gt;break&lt;/code&gt; 식 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 의 경우 블록과 표현식의 범위는 동일한 범위입니다.</target>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">문자열 리터럴의 경우 컴파일 타임에 내용을 알고 있으므로 텍스트는 최종 실행 파일에 직접 하드 코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 그러나 이러한 속성은 문자열 리터럴의 불변성에서만 발생합니다. 불행히도 컴파일 타임에 크기를 알 수없고 프로그램을 실행하는 동안 크기가 변할 수있는 각 텍스트 조각에 대해 바이너리 메모리에 메모리를 넣을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">내재적으로 랩핑 된 오버 플로우의 경우, 구현은 2의 보수 오버 플로우 규칙을 사용하여 잘 정의 된 (아직 잘못된 것으로 간주 되더라도) 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">경우 &lt;code&gt;File::open&lt;/code&gt; 성공의 변수의 값 &lt;code&gt;f&lt;/code&gt; 의 인스턴스가 될 것입니다 &lt;code&gt;Ok&lt;/code&gt; 파일 핸들이 포함되어 있습니다. 실패한 경우 &lt;code&gt;f&lt;/code&gt; 의 값 은 발생한 오류 종류에 대한 자세한 정보가 포함 된 &lt;code&gt;Err&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">위의 코드에서 함수는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 에서 빌린 데이터를 반환 하지만 &lt;code&gt;'a&lt;/code&gt; 주석은 &lt;code&gt;x&lt;/code&gt; 에서만 데이터를 반환한다는 것을 나타냅니다 . 오류를 해결하려면 서명과 본문이 일치해야합니다. 일반적으로 이것은 기능 서명을 업데이트하여 수행됩니다. 따라서이 경우에는 다음과 같이 &lt;code&gt;y&lt;/code&gt; 유형 을 &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">목록 9-7과 관련하여 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;File::open&lt;/code&gt; 호출 의 끝 에서 &lt;code&gt;Ok&lt;/code&gt; 안의 값 을 변수 &lt;code&gt;f&lt;/code&gt; 로 반환합니다 . 오류가 발생하면 &lt;code&gt;?&lt;/code&gt; 연산자는 전체 함수에서 일찍 반환 하고 호출 코드에 &lt;code&gt;Err&lt;/code&gt; 값을 제공합니다 . 같은 것이 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 호출 끝에 .</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결국, 이것은 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt; 유형, 일반적으로 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 쌍으로 묶어야 할 수도 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">위의 잘못된 코드 예제에서 잘못된 이름이 제공되었으므로 올바른 이름으로 변경하면 오류가 해결됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">위의 예에서 &lt;code&gt;closure&lt;/code&gt; 는 &lt;code&gt;FnOnce&lt;/code&gt; 클로저 인 반면 &lt;code&gt;bar&lt;/code&gt; 함수는 &lt;code&gt;Fn&lt;/code&gt; 클로저를 예상했습니다 . 이 경우 문제를 해결하는 것이 간단합니다 &lt;code&gt;struct X&lt;/code&gt; 에서 &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Clone&lt;/code&gt; 특성 을 구현 하면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="translated">아래의 예에서, &lt;code&gt;name&lt;/code&gt; 밖으로 이동하는 &lt;code&gt;person&lt;/code&gt; 사용하려고, &lt;code&gt;person&lt;/code&gt; 전체 또는 &lt;code&gt;person.name&lt;/code&gt; 때문에 오류가 발생 할 &lt;em&gt;부분 이동&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;Point&lt;/code&gt; 유형을 구현합니다 . 두 개의 정수만 저장하기 때문에 우리는 &lt;code&gt;Copy&lt;/code&gt; 의 소유권 의미를 옵트 아웃 합니다. 그런 다음 &lt;code&gt;p1&lt;/code&gt; 을 이동 하지 않고 &lt;code&gt;let p2 = p1&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">이 예제에서 유형은 크기를 잘 정의 할 수 없습니다. 왜냐하면 임의적으로 커야하기 때문입니다 ( &lt;code&gt;ListNode&lt;/code&gt; 를 모든 깊이 에 중첩 할 수 있기 때문입니다 ). 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우, 출력 수명은 고유 한 입력 수명과 동일한 것으로 추론됩니다. 두 번째 경우, 수명은 &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 의 수명과 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">첫 번째 코드 예제에서 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형이 무엇인지 추론 할 수 없습니다 . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 은 모두 적합한 후보입니다. 사용할 유형을 지정하려면 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (마지막 문자는 급성 악센트 &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;조합 문자&lt;/a&gt; ). 문자열의 다른 문자와 달리 결합 문자는 대문자 변형으로 매핑되지 않으므로 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; 합니다. 두 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (마지막 문자는 'e'를 강조하는 단일 유니 코드 문자입니다). 마지막 문자는 ASCII 범위 밖에서 정의되므로 대문자 변형에 매핑되지 않으므로 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">첫 번째 일치 표현식에서 값이 복사 (또는 이동)됩니다. 두 번째 일치에서는 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 하위 패턴을 파괴 할 때 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자를 값 필드에 적용 할 수 없으므로이 구문이 필요 합니다. 예를 들어 다음은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;call_from_c&lt;/code&gt; 함수를 공유 라이브러리로 컴파일하고 C에서 링크 한 후 C 코드에서 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;outline_print&lt;/code&gt; 의 구현 에서 &lt;code&gt;Display&lt;/code&gt; 특성의 기능 을 사용하려고 합니다. 따라서 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성이 &lt;code&gt;Display&lt;/code&gt; 를 구현 하고 &lt;code&gt;OutlinePrint&lt;/code&gt; 에 필요한 기능을 제공하는 유형에 대해서만 작동 하도록 지정 해야합니다. 특성 정의에서 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 를 지정하여 이를 수행 할 수 있습니다 . 이 기법은 특성에 바인딩 된 특성을 추가하는 것과 유사합니다. Listing 19-22는 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성 의 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">범위없이 변수를 지정한 마지막 팔에서 팔의 코드에서 &lt;code&gt;id&lt;/code&gt; 라는 변수에 사용할 수있는 값이 있습니다 . 그 이유는 구조체 필드 속기 구문을 사용했기 때문입니다. 그러나 처음 두 팔과 마찬가지로이 팔 의 &lt;code&gt;id&lt;/code&gt; 필드 값에 대한 테스트를 적용하지 않았습니다 . 모든 값이이 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">메인 스레드에서 모든 조인 핸들을 수집합니다. 그런 다음 Listing 16-2에서와 같이 각 핸들에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 모든 스레드가 완료되도록합니다. 이 시점에서 메인 스레드는 잠금을 획득하고이 프로그램의 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">메인 스레드에서는 더 이상 &lt;code&gt;recv&lt;/code&gt; 함수를 명시 적으로 호출하지 않습니다. 대신 &lt;code&gt;rx&lt;/code&gt; 를 반복자로 취급 합니다. 받은 각 값에 대해 인쇄하고 있습니다. 채널이 닫히면 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">대부분의 경우 소유권은 분명합니다. 주어진 값을 소유 한 변수를 정확히 알고 있습니다. 그러나 단일 값에 여러 소유자가있을 수 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 모서리는 동일한 노드를 가리키고 해당 노드는 해당 노드를 가리키는 모든 모서리가 개념적으로 소유합니다. 가장자리를 가리 키지 않는 한 노드를 정리해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">이 코드의 일치 표현식에서 다음과 같은 변수를 추가합니다 &lt;code&gt;state&lt;/code&gt; 변형 &lt;code&gt;Coin::Quarter&lt;/code&gt; 값과 일치하는 패턴에 . 때 &lt;code&gt;Coin::Quarter&lt;/code&gt; 경기는 &lt;code&gt;state&lt;/code&gt; 변수는 해당 분기의 상태의 값에 바인딩됩니다. 그런 다음 해당 팔의 코드에서 &lt;code&gt;state&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">매처에서 &lt;code&gt;$&lt;/code&gt; &lt;em&gt; name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt; 는 지정된 종류의 Rust 구문 조각과 일치하여 메타 변수 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name에&lt;/em&gt; 바인딩합니다 . 유효한 조각 지정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">다음 장에서는 깔끔하게 정리 된 코드에서 사용할 수있는 표준 라이브러리의 컬렉션 데이터 구조를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서, 역 추적의 12 번째 줄은 프로젝트에서 &lt;em&gt;src / main.rs의&lt;/em&gt; 4 번째 줄을 &lt;em&gt;가리킨다&lt;/em&gt; . 프로그램이 패닉 상태에 빠지지 않게하려면 첫 번째 줄이 가리키는 파일이 언급 된 위치는 조사를 시작해야하는 위치입니다. 역 추적을 사용하는 방법을 보여주기 위해 공황에 빠질 코드를 작성했던 Listing 9-1에서 공황을 수정하는 방법은 3 개의 항목 만 포함하는 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 미래에 코드 패닉이 발생하면 패닉을 유발하는 값으로 코드가 수행하는 작업과 대신 코드가 수행해야 할 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서 ​​역 추적의 17 행은 문제를 일으키는 프로젝트의 라인 ( &lt;em&gt;src / main.rs의&lt;/em&gt; 4 행)을 &lt;em&gt;가리 킵니다&lt;/em&gt; . 프로그램이 당황하지 않도록하려면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치를 조사를 시작해야합니다. 역 추적을 사용하는 방법을 보여주기 위해 의도적으로 패닉되는 코드를 작성한 목록 9-1에서 패닉을 수정하는 방법은 3 개 항목 만 포함 된 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 나중에 코드가 패닉 상태가되면 코드가 어떤 값을 사용하여 패닉을 유발하고 코드가 대신 수행해야하는 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a7555618db6cec5efbdcd91e0e2567f5d19799c" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 6 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서 ​​backtrace의 6 행은 문제를 일으키는 프로젝트의 line 4 of &lt;em&gt;src / main.rs를 가리 킵니다&lt;/em&gt; . 프로그램이 당황하지 않도록하려면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치를 조사를 시작해야합니다. 역 추적을 사용하는 방법을 보여주기 위해 의도적으로 패닉되는 코드를 작성한 목록 9-1에서 패닉을 수정하는 방법은 3 개 항목 만 포함 된 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 나중에 코드가 패닉 상태가되면 코드가 어떤 값을 사용하여 패닉을 유발하고 코드가 대신 수행해야하는 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;IpAddr&lt;/code&gt; 열거 형을 사용하여 Rust의 유형 시스템을 사용하여 데이터를 프로그램에 더 많은 정보로 인코딩 . 이 섹션에서는 표준 라이브러리에 의해 정의 된 또 다른 열거 형인 &lt;code&gt;Option&lt;/code&gt; 에 대한 사례 연구를 살펴 봅니다. &lt;code&gt;Option&lt;/code&gt; 은 값이 뭔가 할 수있는 매우 일반적인 시나리오를 암호화하거나 아무 것도 없을 수 있기 때문에 유형은 여러 곳에서 사용된다. 타입 시스템 측면에서이 개념을 표현한다는 것은 컴파일러가 처리해야 할 모든 경우를 처리했는지 여부를 확인할 수 있다는 의미입니다. 이 기능은 다른 프로그래밍 언어에서 매우 일반적인 버그를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 사용할 때 &lt;code&gt;Some&lt;/code&gt; 경우 에서 내부 &lt;code&gt;T&lt;/code&gt; 값 을 가져오고 싶었습니다 . &lt;code&gt;Coin&lt;/code&gt; 했던 것처럼 &lt;code&gt;match&lt;/code&gt; 를 사용하여 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 를 처리 할 수도 있습니다 열거 형에서 ! 코인을 비교하는 대신 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 의 변형을 비교 하지만 &lt;code&gt;match&lt;/code&gt; 표현식의 작동 방식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">상대 경로에서 논리는 첫 번째 단계를 제외하고 절대 경로와 동일합니다. 상자 루트에서 시작하지 않고 경로는 &lt;code&gt;front_of_house&lt;/code&gt; 에서 시작합니다 . &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈과 같은 모듈 내에 정의 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 상대 경로가되는 모듈에서 시작되도록 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 작동 정의된다. 그런 다음 &lt;code&gt;hosting&lt;/code&gt; 하고 &lt;code&gt;add_to_waitlist&lt;/code&gt; 가 &lt;code&gt;pub&lt;/code&gt; 로 표시 되므로 나머지 경로가 작동 하며이 함수 호출이 유효합니다!</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">식당 산업에서 식당의 일부는 &lt;em&gt; 는 집 앞&lt;/em&gt; , 다른 곳 &lt;em&gt;은 집 뒤라고&lt;/em&gt; 합니다. 집 앞은 고객이있는 곳입니다. 이곳은 주최자가 고객을 앉히고, 서버가 주문과 지불을하고, 바텐더가 음료를 만드는 곳입니다. 집 뒤는 요리사와 요리사가 주방에서 일하고 식기 세척기를 청소하며 관리자가 관리 작업을 수행하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">두 번째에서 &lt;code&gt;use&lt;/code&gt; 문, 우리는 새로운 이름을 선택 &lt;code&gt;IoResult&lt;/code&gt; 에 대한 &lt;code&gt;std::io::Result&lt;/code&gt; 에 입력하는하지 않습니다 충돌 &lt;code&gt;Result&lt;/code&gt; 은 &lt;code&gt;std::fmt&lt;/code&gt; . 리스팅 7-15와 리스팅 7-16은 관용으로 간주되므로 선택은 귀하에게 달려 있습니다!</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">패턴에 지정된 범위 만있는 두 번째 팔에서 팔과 관련된 코드에는 &lt;code&gt;id&lt;/code&gt; 필드 의 실제 값을 포함하는 변수가 없습니다 . &lt;code&gt;id&lt;/code&gt; 필드의 값은 10, 11, 또는 12 수 있었다,하지만 패턴으로가는 코드는 어떤 알 수 없습니다. 변수에 &lt;code&gt;id&lt;/code&gt; 값을 저장하지 않았기 때문에 패턴 코드는 &lt;code&gt;id&lt;/code&gt; 필드 의 값을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">두 번째 경우, 현재 모듈과 그 하위 항목에 의해 개인 항목에 액세스 할 수 있다고 언급하지만 항목에 액세스하는 정확한 의미는 항목이 무엇인지에 따라 다릅니다. 예를 들어 모듈에 액세스하면 더 많은 항목을 가져 오기 위해 내부를 살펴볼 수 있습니다. 반면에 함수에 액세스하면 함수가 호출됩니다. 또한 경로 표현식 및 가져 오기 명령문은 대상이 현재 가시성 범위에있는 경우에만 가져 오기 / 표현이 유효하다는 의미에서 항목에 액세스하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="translated">두 번째 오류에서는 &lt;code&gt;Jak&lt;/code&gt; 열거 형을 직접 바인딩하려고했지만 불가능합니다. 변형 중 하나만 바인딩 할 수 있습니다. 그렇게하려면 :</target>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="translated">두 번째 오류에서는 항목에 무언가를 구현할 수없고 유형에만 구현할 수 있습니다. 비슷한 작업을하려면 새 유형을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">두 번째에서는 단순히 &lt;code&gt;'b&lt;/code&gt; 를 제거하여 둘 다 'a &lt;code&gt;'a&lt;/code&gt; 사용하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 의 서명에서 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 사용합니다 . Rust는 이 메소드가 &lt;code&gt;impl Rectangle&lt;/code&gt; 컨텍스트 안에 있기 때문에 &lt;code&gt;self&lt;/code&gt; 의 유형 이 &lt;code&gt;Rectangle&lt;/code&gt; 임을 알고 있기 때문에 &amp;amp; Rectangle 입니다. &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 에서 와 마찬가지로 여전히 &lt;code&gt;self&lt;/code&gt; 앞에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용해야합니다 . 방법의 소유권이 걸릴 수 있습니다 &lt;code&gt;self&lt;/code&gt; 빌려 &lt;code&gt;self&lt;/code&gt; 우리가 여기했던대로 변함 또는 차용 &lt;code&gt;self&lt;/code&gt; 단지 그들이 다른 매개 변수를 가능한 한, mutably.</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형은 일반적으로 구조적 고정이 없으므로 고정 투영을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 사실, 심지어 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 항상 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 같은 이유로, 자신 : 그 내용합니다 ( &lt;code&gt;T&lt;/code&gt; )가 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 콘텐츠가 고정되어 있는지 여부를 피닝하는 의미이고, 포인터가 고정되어 있는지 여부를 완전히 무관 &lt;em&gt;하지&lt;/em&gt; 구조체.</target>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형에는 일반적으로 구조적 고정이 없으므로 고정 돌출을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 실제로 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 조차도 같은 이유로 항상 &lt;code&gt;Unpin&lt;/code&gt; . 내용 ( &lt;code&gt;T&lt;/code&gt; )은 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내용이 고정되어 있는지 여부를 나타내는 Box &amp;lt;T&amp;gt; 및 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 포인터가 고정되어 있는지 여부와 완전히 독립적이므로 고정이 구조적 &lt;em&gt;이지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;LimitTracker&lt;/code&gt; 가 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;max&lt;/code&gt; 값 의 75 % 이상 으로 설정하라는 메시지 가 표시 될 때 발생하는 상황을 테스트하고 있습니다. 먼저 비어있는 메시지 목록으로 시작 하는 새로운 &lt;code&gt;MockMessenger&lt;/code&gt; 를 만듭니다 . 그리고 우리는 새로운 만들 &lt;code&gt;LimitTracker&lt;/code&gt; 을 하고 그것에게 새에 대한 참조를 제공 &lt;code&gt;MockMessenger&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 우리는 전화 (100)의 값 &lt;code&gt;set_value&lt;/code&gt; 온 방법 &lt;code&gt;LimitTracker&lt;/code&gt; 을 (100)의 75 % 이상이 우리가 주장 그리고 80의 값과를 메시지 목록 &lt;code&gt;MockMessenger&lt;/code&gt; 가 추적 가 하나 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="translated">세 번째 경우 에는 불가능한 &lt;code&gt;Wizard&lt;/code&gt; 열거 형 의 한 가지 변형 만 예상하려고했습니다 . 이 작업을 수행하려면 &lt;code&gt;Wizard&lt;/code&gt; 열거 형에 대해 패턴 일치를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">전 사기에서 metavariables는 조각 종류가 matcher에 지정되어 있으므로 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 간단히 참조됩니다 . 메타 변수는 일치하는 구문 요소로 대체됩니다. 키워드 메타 변수 &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . Metavariables는 두 번 이상 복사되거나 전혀 복사되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">transcriber에서 metavariables는 조각 유형이 매처에 지정되어 있기 때문에 간단히 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 참조됩니다 . 메타 변수는 해당 구문 요소로 대체됩니다. 키워드 metavariable &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . 메타 변수는 두 번 이상 또는 전혀 기록되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">운동 생성기 예제에서는 클로저를 인라인 익명 함수로 사용했습니다. 그러나 클로저에는 기능에없는 추가 기능이 있습니다. 즉, 환경을 캡처하고 정의 된 범위에서 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">최악의 경우, 알고리즘 은 슬라이스의 길이를 &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; 임시 스토리지를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;ba*&lt;/code&gt; 유형은 LUB 강제 변환에 의해 발견됩니다. 그리고 컴파일러는 &lt;code&gt;foo&lt;/code&gt; 함수를 처리 할 때 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 의 LUB 강제 변환 결과 가 &lt;code&gt;i32&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">이 부록에서는 표준 라이브러리에서 &lt;code&gt;derive&lt;/code&gt; 하여 사용할 수있는 모든 특성에 대한 참조를 제공합니다. . 각 섹션은 다음을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">이 부록에서는 Rust 프로젝트가 제공하는 유용한 개발 도구에 대해 설명합니다. 자동 서식, 경고 수정을 적용하는 빠른 방법, 린터 및 IDE와의 통합에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">이 경우 &lt;code&gt;Foo&lt;/code&gt; 는 정의되지 않았으므로 본질적으로 아무것도 아니며 구조체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">이 경우, &lt;code&gt;Question&lt;/code&gt; 은 &lt;code&gt;std::ops::Not&lt;/code&gt; 특성 을 구현해야 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 그 위에. 그것을 구현하자 :</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="translated">이 경우, &lt;code&gt;c_double&lt;/code&gt; 는 같은 크기가 &lt;code&gt;f64&lt;/code&gt; 우리가 직접 사용할 수 있도록를 :</target>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">이 경우 &lt;code&gt;foo&lt;/code&gt; 가 정의되었지만 구조체가 아니므로 Rust에서이를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">이 경우 &lt;code&gt;len&lt;/code&gt; 은 4가되며 문자열 &quot;Hola&quot;를 저장하는 벡터의 길이는 4 바이트입니다. 이러한 문자는 UTF-8로 인코딩 될 때 1 바이트를 사용합니다. 그러나 다음 줄은 어떻습니까? (이 문자열은 아라비아 숫자 3이 아닌 대문자 키릴 문자 Ze로 시작합니다.)</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">이 경우, 대출 &lt;code&gt;x&lt;/code&gt; 때문 mutably 것은 불가능 &lt;code&gt;x&lt;/code&gt; 가 아니다 &lt;code&gt;mut&lt;/code&gt; . 그러나 동시에 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 참조가 고유하지 않을 수 있으므로 x를 불변으로 하면 할당이 불법이 될 수 있으므로 값을 안전하게 수정하는 데 사용할 수 없습니다. 따라서 고유의 불변의 차용이 사용됩니다. &lt;code&gt;x&lt;/code&gt; 를 불변으로 차용 하지만 변경 가능한 차용과 마찬가지로 고유해야합니다. 위의 예에서, &lt;code&gt;y&lt;/code&gt; 의 선언을 주석 해제하면 &lt;code&gt;x&lt;/code&gt; 의 클로저 빌림 고유성을 위반하기 때문에 오류가 발생합니다 . z의 선언은 블록의 끝에서 클로저의 수명이 만료되어 빌려주기 때문에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">이 경우 참조 사이클을 생성 한 직후 프로그램이 종료됩니다. 이주기의 결과는 그리 심각하지 않습니다. 그러나보다 복잡한 프로그램이주기에 많은 양의 메모리를 할당하고 오랫동안 보유한 경우 프로그램은 필요한 것보다 많은 메모리를 사용하고 시스템을 압도하여 사용 가능한 메모리가 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">이 경우 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형을 유추 할 수 없습니다. . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 이 모두 적합한 후보입니다. 사용할 유형을 지정하기 위해 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">이 경우 표시된 행은 코드의 일부이며 해당 행으로 이동하면 &lt;code&gt;panic!&lt;/code&gt; 이 발생합니다. 매크로 호출. 다른 경우에, &lt;code&gt;panic!&lt;/code&gt; call은 코드에서 호출하는 코드에있을 수 있으며 오류 메시지에 의해보고 된 파일 이름과 줄 번호는 &lt;code&gt;panic!&lt;/code&gt; 발생하는 다른 사람의 코드입니다 ! 매크로는 코드의 라인이 아니라 결국 &lt;code&gt;panic!&lt;/code&gt; 요구. &lt;code&gt;panic!&lt;/code&gt; 함수의 역 추적을 사용할 수 있습니다 ! 문제의 원인이되는 코드의 일부를 파악하기 위해 전화가 왔습니다. 다음에는 역 추적에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="translated">이 경우 오류를 수정하려면 &lt;code&gt;chocolate&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">이 장과 책 전체에서 터미널에서 사용되는 몇 가지 명령을 보여줍니다. 터미널에 입력해야하는 줄은 모두 &lt;code&gt;$&lt;/code&gt; 로 시작 합니다. &lt;code&gt;$&lt;/code&gt; 문자 를 입력 할 필요는 없습니다 . 각 명령의 시작을 나타냅니다. 로 시작하지 않는 줄 &lt;code&gt;$&lt;/code&gt; 로 일반적으로 이전 명령의 출력을 보여줍니다. 또한 PowerShell 관련 예제는 &lt;code&gt;$&lt;/code&gt; 대신 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서 우리는 &lt;em&gt;enums&lt;/em&gt; 라고도하는 &lt;em&gt;enumeration&lt;/em&gt; 을 살펴볼 것 입니다. 열거 형을 사용하면 가능한 &lt;em&gt;변형&lt;/em&gt; 을 열거하여 유형을 정의 할 수 있습니다 . 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, 값이 무언가가 될 수도 있고 없을 수도 있음을 나타내는 &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다 . 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리하는 데 사용할 수있는 또 다른 편리하고 간결한 관용구 인지 살펴 보겠습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서는 &lt;em&gt;enum&lt;/em&gt; 이라고도하는 &lt;em&gt;열거를&lt;/em&gt; 살펴 보겠습니다 . 열거 형을 사용하면 가능한 값을 열거하여 형식을 정의 할 수 있습니다. 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다.이 열거 형 은 값이 무엇이든 또는 아무것도 아닐 수 있음을 나타냅니다. 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리 할 수있는 또 다른 편리하고 간결한 관용구 인 방법을 다룰 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">이 장에서는 함수형 프로그래밍이 무엇인지에 대한 문제를 논의하지 않고, 종종 기능적이라고하는 많은 언어의 기능과 유사한 Rust의 일부 기능에 대해 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">이 장에서는 이러한 모든 기능을 다루고, 기능이 상호 작용하는 방법에 대해 설명하고, 기능을 사용하여 범위를 관리하는 방법에 대해 설명합니다. 결국, 당신은 모듈 시스템에 대해 잘 이해하고 전문가와 같은 범위에서 일할 수 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">이 장에서는 다음 내용을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">이 코드에서 첫 번째 값과 마지막 값이 &lt;code&gt;first&lt;/code&gt; 값과 일치합니다 및 &lt;code&gt;last&lt;/code&gt; 합니다. 그만큼 &lt;code&gt;..&lt;/code&gt; 일치 중간에 모든 것을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">이 코드 에서 Listing 19-26 의 &lt;code&gt;match&lt;/code&gt; 에서 와 같은 일이 발생한다 . Rust는 &lt;code&gt;val&lt;/code&gt; 이 타입 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;panic!&lt;/code&gt; 가지고 있음을 본다 ! 유형이 있습니다 &lt;code&gt;!&lt;/code&gt; 전체 &lt;code&gt;match&lt;/code&gt; 표현식 의 결과 는 &lt;code&gt;T&lt;/code&gt; 입니다. 이 코드는 &lt;code&gt;panic!&lt;/code&gt; 하기 때문에 작동합니다 !가치를 창출하지 않습니다. 프로그램을 종료합니다. 에 &lt;code&gt;None&lt;/code&gt; 경우, 우리는에서 값을 반환하지 않습니다 &lt;code&gt;unwrap&lt;/code&gt; 이 코드가 유효하므로.</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="translated">이 코드에는이 문제를 해결하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">이러한 맥락에서 &lt;em&gt; 런타임&lt;/em&gt; 이란 언어에 의해 모든 바이너리에 포함 된 코드를 의미합니다. 이 코드는 언어에 따라 크거나 작을 수 있지만 모든 비 조립 언어에는 일정량의 런타임 코드가 있습니다. 이러한 이유로 구어 적으로 사람들이 언어에 &quot;런타임 없음&quot;이 있다고 말하면 종종 &quot;작은 런타임&quot;을 의미합니다. 런타임이 작을수록 기능은 적지 만 바이너리가 작다는 장점이 있으므로 더 많은 컨텍스트에서 언어를 다른 언어와 쉽게 결합 할 수 있습니다. 더 많은 기능을 제공하기 위해 런타임 크기를 늘려서 많은 언어를 사용할 수 있지만 Rust는 런타임이 거의 필요하지 않으며 성능을 유지하기 위해 C를 호출 할 수있는 기능을 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="translated">이 예에서 &lt;code&gt;2&lt;/code&gt; 는 할당 직후에 삭제 됩니다. 즉, &lt;code&gt;ptr&lt;/code&gt; 은 이제 사용할 수없는 위치를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="translated">이 예에서 &lt;code&gt;BoxCar&lt;/code&gt; 에는 &lt;code&gt;Vehicle&lt;/code&gt; 과 &lt;code&gt;Box&lt;/code&gt; 라는 두 가지 슈퍼 특성이 있습니다. 이 두 특성 모두 연관된 유형 &lt;code&gt;Color&lt;/code&gt; 를 정의합니다 . &lt;code&gt;BoxCar&lt;/code&gt; 는 두 슈퍼 트레이 트 에서 그 이름을 가진 두 가지 유형을 상속합니다. 이 때문에 &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt; 중 적절한 &lt;code&gt;Color&lt;/code&gt; 관련 유형 을 참조하기 위해 정규화 된 경로 구문을 사용해야 하지만이 구문은 사용할 수 없습니다. 함수 서명에서.</target>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 예에서 &lt;code&gt;Cat&lt;/code&gt; 은 &lt;em&gt;구조체와 유사한 열거 형 변형&lt;/em&gt; 인 반면 &lt;code&gt;Dog&lt;/code&gt; 는 간단히 열거 형 변형이라고합니다. ENUM 각 인스턴스는 보유 &lt;em&gt;판별&lt;/em&gt; 이 보유하는 변이체를 결정하는 데 사용되는 그와 연관된 정수이다. 이 판별에 대한 불투명 한 참조는 &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Foo&lt;/code&gt; 는 연관된 유형 &lt;code&gt;A&lt;/code&gt; 를 정의합니다 . &lt;code&gt;Bar&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 에서 해당 유형을 상속 하고 동일한 이름의 다른 연관된 유형을 정의합니다. 결과적으로 &lt;code&gt;Self::A&lt;/code&gt; 를 사용하려고 할 때 &lt;code&gt;Foo&lt;/code&gt; 에 의해 정의 된 &lt;code&gt;A&lt;/code&gt; 를 의미하는지 또는에 의해 정의 된 것을 의미하는지는 모호합니다. &lt;code&gt;Bar&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">이 예에서 &lt;code&gt;Y&lt;/code&gt; 는 여기서 &lt;code&gt;X&lt;/code&gt; 를 참조 할 수 없습니다 . 이를 수정하기 위해 값을 const로 추출한 다음 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;string1&lt;/code&gt; 은 외부 범위 가 끝날 때까지 유효 하고 &lt;code&gt;string2&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효하며 &lt;code&gt;result&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효한 것을 참조합니다. 이 코드를 실행하면 차용 검사기가이 코드를 승인 함을 알 수 있습니다. 그것은 컴파일하고 인쇄 할 &lt;code&gt;The longest string is long string is long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">이 예에서, &lt;code&gt;value&lt;/code&gt; 은 차용에 의해 변경 가능하게 &lt;code&gt;borrow&lt;/code&gt; 되며 &lt;code&gt;sum&lt;/code&gt; 계산에 사용될 수 없습니다 . 이것은 Rust의 가변성 규칙을 위반하기 때문에 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">이 예제에서, &lt;code&gt;x&lt;/code&gt; 가 패턴 &lt;code&gt;(0, _)&lt;/code&gt; 과 일치 하면 두 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;(_, 0)&lt;/code&gt; 과 일치 하면 첫 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . 모든 경우에 &lt;code&gt;y&lt;/code&gt; 는 어떤 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">이 예에서 &lt;code&gt;'SnowWhite&lt;/code&gt; 수명은 &lt;code&gt;'kiss&lt;/code&gt; 수명 보다 오래 지속되지만 &lt;code&gt;Prince&lt;/code&gt; 구조체 의 선언은이를 강제하지 않습니다. 이 문제를 해결하려면 다음을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="translated">이 예에서 클로저는 &lt;code&gt;'static&lt;/code&gt; 수명 제약 조건 '을 충족하지 않습니다 . 이 오류를 수정하려면 유형의 수명을 다시 확인해야합니다. 여기에서 &lt;code&gt;s&lt;/code&gt; 에 정적 수명 을 제공하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이 예에서 모듈 &lt;code&gt;quux&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 두 개의 공개 이름을 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">이 예에서, 생성 된 스레드는 현재 스레드에서 &quot;분리&quot;됩니다. 이것은이 부모가 메인 스레드가 아니라면 부모 (스폰 한 스레드)보다 오래 지속될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">이 예제에서 특성 &lt;code&gt;Foo&lt;/code&gt; 및 특성 메소드 &lt;code&gt;do_something_else&lt;/code&gt; 는 모두 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 정의합니다 . 메소드가 유형 매개 변수를 정의하려면 다른 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;Printable&lt;/code&gt; 특성은 &lt;code&gt;print&lt;/code&gt; 의 유형 서명 과 &lt;code&gt;main&lt;/code&gt; 의 캐스트 표현식 모두에서 특성 오브젝트로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">이 예에서 값 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 0으로 포함 하여 두 번째 팔과 일치하므로이 코드는 &lt;code&gt;On the y axis at 7&lt;/code&gt; 인쇄 합니다 .</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">이 예제에서 &lt;code&gt;first&lt;/code&gt; 라는 변수 는 값 &lt;code&gt;1&lt;/code&gt; 을 얻습니다 . 이는 배열의 인덱스 &lt;code&gt;[0]&lt;/code&gt; 에있는 값이기 때문입니다 . &lt;code&gt;second&lt;/code&gt; 라는 변수 는 배열의 인덱스 &lt;code&gt;[1]&lt;/code&gt; 에서 값 &lt;code&gt;2&lt;/code&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;Foo&lt;/code&gt; 의 소멸자가 &lt;code&gt;X&lt;/code&gt; 유형의 데이터에 액세스하지 않으며 프로그램의 전반적인 안전을 위해이 어설 션이 참이어야한다고 주장합니다. 컴파일러는 현재이 어설 션을 확인하려고 시도하지 않습니다. 따라서이 &lt;code&gt;impl&lt;/code&gt; 을 안전하지 않은 것으로 태그 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">이 예에서는 상위 함수 인수를 받는 함수 &lt;code&gt;ten_times&lt;/code&gt; 를 정의한 다음 클로저 표현식을 인수로 호출 한 다음 환경에서 값을 이동시키는 클로저 표현식을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="65cd159213dbe5caf10e5067fe9f06a95f76f236" translate="yes" xml:space="preserve">
          <source>In this example, we have to instantiate &lt;code&gt;'x&lt;/code&gt;, and we don't know what lifetime to instantiate it with. To fix this, spell out the precise lifetimes involved. Example:</source>
          <target state="translated">이 예에서 우리는 &lt;code&gt;'x&lt;/code&gt; 를 인스턴스화해야하며 인스턴스화 할 수명을 알지 못합니다. 이 문제를 해결하려면 관련된 정확한 수명을 설명하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="translated">이 예에서, 우리는 (또 하나 호환 수명이 값을 설정하려고 &lt;code&gt;'long&lt;/code&gt; 무관 &lt;code&gt;'short&lt;/code&gt; ). 이 문제는 두 가지 방법으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="translated">이 예에서 우리 는 &lt;code&gt;Hello&lt;/code&gt; 특성 의 존재하지 않는 연관 유형 &lt;code&gt;You&lt;/code&gt; 를 사용하려고했습니다 . 이 오류를 수정하려면 기존 관련 유형을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">이 예제에서, 우리는 평생 매개 변수를 지정한 &lt;code&gt;'a&lt;/code&gt; 매개 변수에 대한 &lt;code&gt;x&lt;/code&gt; 및 반환 형식,하지만 매개 변수에 대한 &lt;code&gt;y&lt;/code&gt; 로 의 수명 때문에, &lt;code&gt;y&lt;/code&gt; 는 의 수명과 어떤 관계가없는 &lt;code&gt;x&lt;/code&gt; 또는 반환 값을.</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">이 예제에서 정수 값 5를 &lt;code&gt;x&lt;/code&gt; 에 할당하면 컴파일러에 일반 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스에 대한 정수임을 알립니다 . 그런 다음 &lt;code&gt;x&lt;/code&gt; 와 동일한 유형을 갖도록 정의한 &lt;code&gt;y&lt;/code&gt; 에 4.0을 지정하면 다음 과 같은 유형 불일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 가 불변 구조체 내부에서 돌연변이를 활성화 한다는 것을 알 수 있습니다 . 즉, &quot;내부 돌연변이&quot;를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">이 구현 에서 &lt;code&gt;Display&lt;/code&gt; 구현이 오류를 반환 하면 &lt;code&gt;to_string&lt;/code&gt; 메소드가 패닉 상태 가됩니다. &lt;code&gt;fmt::Write for String&lt;/code&gt; 은 오류 자체를 반환하지 않으므로 잘못된 &lt;code&gt;Display&lt;/code&gt; 구현을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f07445d5d52a84f1a2b08af97ac8fb5214288938" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;&quot;not enough arguments&quot;&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">이 목록에서는 이전에 다루지 않은 메서드 인 &lt;code&gt;unwrap_or_else&lt;/code&gt; 를 사용했습니다. unwrap_or_else 는 표준 라이브러리에 의해 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 에 정의되어 있습니다. 사용 &lt;code&gt;unwrap_or_else&lt;/code&gt; 것은 우리는 일부 사용자 지정, 비 정의 할 수 있습니다 &lt;code&gt;panic!&lt;/code&gt; 오류 처리. 는 IF &lt;code&gt;Result&lt;/code&gt; 입니다 &lt;code&gt;Ok&lt;/code&gt; 값이이 방법의 행동과 유사한 &lt;code&gt;unwrap&lt;/code&gt; : 그것은 내부 값 반환 &lt;code&gt;Ok&lt;/code&gt; 포장입니다. 그러나 값이 &lt;code&gt;Err&lt;/code&gt; 값이면이 메서드는 우리가 정의하고 &lt;code&gt;unwrap_or_else&lt;/code&gt; 에 인수로 전달하는 익명 함수 인 &lt;em&gt;클로저&lt;/em&gt; 의 코드를 호출합니다 . 클로저에 대해서는 다음에서 자세히 다룰 것입니다.&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; . 지금은 &lt;code&gt;unwrap_or_else&lt;/code&gt; 가 &lt;code&gt;Err&lt;/code&gt; 의 내부 값을 전달할 것임을 알아야합니다 .이 경우 에는 Listing 12-9에서 추가 한 정적 문자열 &lt;code&gt;&quot;not enough arguments&quot;&lt;/code&gt; 이 나타나는 인수 &lt;code&gt;err&lt;/code&gt; 의 클로저에 전달 됩니다. 수직 파이프 사이. 그런 다음 클로저의 코드가 실행될 때 &lt;code&gt;err&lt;/code&gt; 값 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">이 목록에서는 이전에 다루지 않은 &lt;code&gt;unwrap_or_else&lt;/code&gt; 메소드를 사용 했는데 , 이는 표준 라이브러리에 의해 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 에 정의되어 있습니다. 사용 &lt;code&gt;unwrap_or_else&lt;/code&gt; 것은 우리는 일부 사용자 지정, 비 정의 할 수 있습니다 &lt;code&gt;panic!&lt;/code&gt; 오류 처리. 는 IF &lt;code&gt;Result&lt;/code&gt; 입니다 &lt;code&gt;Ok&lt;/code&gt; 값이이 방법의 행동과 유사한 &lt;code&gt;unwrap&lt;/code&gt; : 그것은 내부 값 반환 &lt;code&gt;Ok&lt;/code&gt; 포장입니다. 그러나 값이 &lt;code&gt;Err&lt;/code&gt; 값인 경우이 메소드는 &lt;em&gt;클로저&lt;/em&gt; 에서 코드를 호출합니다.이 함수는 우리가 &lt;code&gt;unwrap_or_else&lt;/code&gt; 에 인수로 정의하고 전달하는 익명 함수 입니다. 우리는 폐쇄를 더 자세히 다룰 것입니다.&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; . 지금, 당신은 알아야합니다 &lt;code&gt;unwrap_or_else&lt;/code&gt; 가 의 내부 값을 전달합니다 &lt;code&gt;Err&lt;/code&gt; 이 경우에는 정적 문자열, &lt;code&gt;not enough arguments&lt;/code&gt; 우리가 인수에 우리의 폐쇄, 목록 12-9에 추가 한 &lt;code&gt;err&lt;/code&gt; 그 사이에 나타납니다 수직 파이프. 클로저의 코드는 실행될 때 &lt;code&gt;err&lt;/code&gt; 값 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">이보다 복잡한 예에서는 &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 를 사용합니다 ! 및 &lt;code&gt;.debug_set()&lt;/code&gt; 일치 팔의 목록을 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">다음 예제에서, &lt;code&gt;init_after_if&lt;/code&gt; 는 &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; 표현식&lt;/a&gt; 이후에 초기화 되지만 &lt;code&gt;uninit_after_if&lt;/code&gt; 는 &lt;code&gt;else&lt;/code&gt; 경우에 초기화되지 않기 때문에 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">이 프로세스에서 컴파일러는 Listing 10-5에서 일반 함수를 작성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 일반 코드가 호출되는 모든 위치를보고 일반 코드가 호출되는 구체적인 유형에 대한 코드를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">이 섹션에서는 TDD (Test-driven development) 프로세스를 사용하여 &lt;code&gt;minigrep&lt;/code&gt; 프로그램에 검색 로직을 추가합니다 . 이 소프트웨어 개발 기술은 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">이 섹션에서는 모듈 및 모듈 시스템의 다른 부분, 즉 항목 이름을 지정할 수있는 &lt;em&gt;경로에&lt;/em&gt; 대해 설명합니다. &lt;code&gt;use&lt;/code&gt; 범위에 대한 경로를 제공 키워드; 그리고 &lt;code&gt;pub&lt;/code&gt; 키워드는 항목을 공개합니다. 또한 &lt;code&gt;as&lt;/code&gt; 키워드, 외부 패키지 및 glob 연산자에 대해서도 설명합니다 . 지금은 모듈에 집중하자!</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">이 경우 빌린 컨텐츠를 이동할 수 없으므로 &lt;code&gt;ref&lt;/code&gt; 키워드로 도 해결할 수 없습니다. 이 문제는 일반적으로 해결할 수 없습니다. 값을 복제 할 수 있으면 다음과 같이 구체적이지 않은 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">이 특정한 경우에는 변환 음이 무해 할 가능성이 높습니다 (그러나 Rust가이를 보증하지는 않습니다). 그러나 정렬 및 열거 최적화가 그림에 나타날 때 크기가 다른 유형 매개 변수 대체와 일치하거나 일치하지 않을 수 있습니다. 가능한 &lt;em&gt;모든&lt;/em&gt; 유형에 대해 이것을 확인할 수는 없으므로 &lt;code&gt;transmute()&lt;/code&gt; 는 대체 되지 않은 유형 매개 변수가없는 유형 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">이 제안에서 &quot;간접&quot;은 값을 직접 저장하는 대신 값에 대한 포인터를 저장하여 값을 간접적으로 저장하도록 데이터 구조를 변경한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">이런 식으로 표현 구조는 실행 구조를 나타냅니다. 블록은 또 다른 종류의 표현식이므로 블록, 명령문, 표현식 및 블록은 다시 재귀 적으로 서로 깊이있게 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="translated">이 경우 유형을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">특성 선언에서 &lt;a href=&quot;items/traits#supertraits&quot;&gt;수퍼&lt;/a&gt; 특성으로 : &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; 은 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;관련 유형&lt;/a&gt; 에 대한 경계로서 특성 선언에서 : &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; 는 &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; 와 동일합니다 . 여기서 Self :: B : Copy {type B; } .</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="translated">트레이 트에서 &lt;code&gt;type&lt;/code&gt; 은 &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;연관된 유형&lt;/a&gt; 을 선언하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 괄호를 사용해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 종종 괄호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">이 책의 여러 곳에서 &lt;code&gt;derive&lt;/code&gt; 속성을 논의했습니다.이 속성은 구조체 또는 열거 정의에 적용 할 수 있습니다. &lt;code&gt;derive&lt;/code&gt; 속성을 사용하면 주석 한 유형에 대한 자신의 디폴트의 구현과 특성 구현하는 코드 생성 &lt;code&gt;derive&lt;/code&gt; 구문을.</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="translated">매우 드문 경우에이 문제는 &lt;code&gt;core&lt;/code&gt; 또는 &lt;code&gt;std&lt;/code&gt; 를 두 번 로드 할 때 발생할 수 있습니다 . 한 번은 메타 데이터 를 &lt;code&gt;check&lt;/code&gt; 하고 한 번은 메타 데이터 를 &lt;code&gt;build&lt;/code&gt; 합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;# 75176을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합 될 수 없습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="translated">대역 내 수명은 &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;Fn&lt;/code&gt; 구문 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합되었습니다.</target>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="translated">UTF-8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">바이트 배열에 대한 참조로 파일을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">utf8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">모든 확장 특성과 일부 중요한 유형 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">잘못된 바이트 :</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="translated">잘못된 사용법</target>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="translated">제공된 포인터와 연결된 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 의 강력한 참조 수를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">배열 및 슬라이스의 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">지수 식, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 또는 &lt;a href=&quot;types/slice&quot;&gt;슬라이스&lt;/a&gt; A를 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">인덱스는 원래 슬라이스의 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">인덱스는 UTF-8 시퀀스 경계에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">문자열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">문자열 인덱싱 연산의 반환 유형이 바이트 값, 문자, 그래 핀 클러스터 또는 문자열 슬라이스인지 명확하지 않기 때문에 문자열 인덱싱은 종종 나쁜 생각입니다. 따라서 Rust는 인덱스를 사용하여 문자열 슬라이스를 만들어야하는 경우 더 구체적으로 요구합니다. 인덱싱에서보다 구체적 으로 설명하고 단일 숫자로 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 인덱싱하는 대신 문자열 슬라이스를 원한다는 것을 나타내 려면 범위와 함께 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 상수 시간 작업을위한 것이지만 UTF-8 인코딩을 사용하면이 작업을 수행 할 수 없습니다. 또한 인덱스가 어떤 종류의 바이트, 코드 포인트 또는 grapheme 클러스터를 반환해야하는지 명확하지 않습니다. &lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 일정한 시간 작업을위한 것이지만 UTF-8 인코딩은이를 허용하지 않습니다. 게다가 인덱스가 어떤 종류의 것을 반환해야하는지 (바이트, 코드 포인트 또는 자소 클러스터)가 명확하지 않습니다. &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">객체 의 끝을지나 1 바이트를 제외 하고 &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 사용하여 객체의 경계 외부에서 인덱싱 합니다.</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">버퍼를 초기화해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">모든 상위 디렉토리를 작성하여 디렉토리를 반복적으로 작성해야 함을 나타냅니다. 존재하지 않는 부모는 동일한 보안 및 권한 설정으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">스레드가 종료 된 방식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">이 소켓에 대한 발신 멀티 캐스트 패킷의 유효 기간 값을 나타냅니다. 기본값은 1입니다. 즉, 멀티 캐스트 패킷은 명시 적으로 요청하지 않는 한 로컬 네트워크를 떠나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">완료되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="translated">&quot;구현되지 않음&quot;이라는 메시지와 함께 당황하여 구현되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">연결할 수없는 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">값을 사용할 수 있는지 또는 현재 작업이 웨이크 업을 받도록 예약되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">내용이 중앙 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">내용이 왼쪽 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">내용이 올바르게 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">인덱스는 배열과 슬라이스에 대해 0부터 시작합니다. 배열 액세스는 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 이므로 컴파일 타임에 상수 인덱스 값으로 경계를 확인할 수 있습니다. 그렇지 않으면 스레드 가 실패한 경우 스레드를 &lt;em&gt;패닉 상태로&lt;/em&gt; 만드는 검사가 런타임에 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 개의 &lt;code&gt;Arc&lt;/code&gt; 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="translated">항목에 적용된 절차 적 매크로 속성에서 사용하는 비활성 도우미 속성도 허용되지만 이러한 비활성 속성을 최종 &lt;code&gt;TokenStream&lt;/code&gt; 에 포함하지 않도록주의하세요 .</target>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">완벽한 오류</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">유추 된 유형</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 와 같은 무한 반복기 는 종종 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용되어 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 과 같은 무한 반복자 는 종종이를 한정하기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 반복자 는 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용하여 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 이터레이터 는 종종 그것들을 유한하게 만들기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">무한 루프</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">무한대 (&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f32::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f64::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">코드에서이 지점에 도달 할 수 없음을 컴파일러에 알리고 추가 최적화를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">조건이 항상 참임을 옵티 마이저에게 알립니다. 조건이 거짓이면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">고유 한 구현</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">고유 한 연관된 ​​유형은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195의&lt;/a&gt; 일부 이지만 아직 구현되지 않았습니다. 이 구현 상태에 대한 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;추적 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">고유 구현</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">고유 한 구현 (특성을 구현하지 않지만 유형과 연관된 메소드를 제공하는 구현)은 안전하지 않은 특성을 구현하지 않기 때문에 항상 안전합니다. 고유 구현에서 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 제거하면 이 오류가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">고유 구현은 포함 된 항목을 구현 유형에 연관시킵니다. 고유 구현에는 &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;관련 함수&lt;/a&gt; (메소드 포함) 및 &lt;a href=&quot;associated-items#associated-constants&quot;&gt;관련 상수&lt;/a&gt; 가 포함될 수 있습니다 . 연관된 유형 별명을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">고유 한 방법</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 대해 stdin / stdout / stderr를 상속 하지만 &lt;code&gt;output&lt;/code&gt; 위한 파이프를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">현재 프로세스 환경 상속</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">현재 프로세스의 작업 디렉토리 상속</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">타입 시스템과 코드 공유로서의 상속</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">상속은 최근에 필요한 것보다 많은 코드를 공유 할 위험이 있기 때문에 많은 프로그래밍 언어에서 프로그래밍 디자인 솔루션으로 선호되지 않습니다. 서브 클래스가 항상 부모 클래스의 모든 특성을 공유하지는 않지만 상속을 통해 그렇게해야합니다. 이로 인해 프로그램 디자인의 유연성이 떨어질 수 있습니다. 또한 이해가되지 않거나 서브 클래스에 적용되지 않기 때문에 오류를 발생시키는 서브 클래스에서 메소드를 호출 할 가능성도 소개합니다. 또한 일부 언어는 서브 클래스가 한 클래스에서만 상속 할 수 있도록하여 프로그램 디자인의 유연성을 더욱 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">초기화와 파괴</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">불변 초기화</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">초기화 동적으로 최초의 호출시에 수행 &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 스레드 내에서 구현할 값 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 할 때 스레드가 종료를 파괴 얻을. 아래에 설명 된 일부 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="translated">유니온 초기화</target>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">정적 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 값의 초기화 값입니다 .</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">루프 전에 결과를 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">필요한 경우 버퍼를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">필드별로 구조체 초기화</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">요소별로 배열 초기화</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">처음에 Rust 팀은 메모리 안전을 보장하고 동시성 문제를 방지하는 것이 서로 다른 방법으로 해결해야 할 두 가지 과제라고 생각했습니다. 시간이 지남에 따라 팀은 소유권 및 유형 시스템이 메모리 안전 &lt;em&gt;및&lt;/em&gt;동시성 문제! 소유권과 유형 검사를 활용함으로써 많은 동시성 오류는 런타임 오류가 아닌 Rust의 컴파일 타임 오류입니다. 따라서 런타임 동시성 버그가 발생하는 정확한 상황을 재현하기 위해 많은 시간을 소비하지 않고 잘못된 코드는 컴파일을 거부하고 문제를 설명하는 오류를 나타냅니다. 결과적으로 코드를 프로덕션에 제공 한 후 작업하지 않고 작업하는 동안 코드를 수정할 수 있습니다. 우리는 Rust &lt;em&gt;fearless &lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt; 의 이러한 측면을 별명으로 지정했습니다 . Fearless Concurrency를 사용하면 미묘한 버그가없고 새로운 버그를 도입하지 않고 리팩토링하기 쉬운 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="translated">인라인 어셈블리.</target>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">내부 속성</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">내부 블록 문서 주석</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="translated">내부 문서는 항목 앞에만 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">내부 함수는 포함 된 환경에 액세스 할 수 없습니다. 이 오류를 수정하려면 함수를 클로저로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">내부 항목은 포함 된 함수에서 유형 또는 const 매개 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">내부 문서 주석</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">삽입 및 복잡한 키</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">가장 큰 원소를 삽입하고 터지는 것은 &lt;code&gt;O(log n)&lt;/code&gt; 시간 복잡성을 갖는다. 가장 큰 요소를 확인하는 것은 &lt;code&gt;O(1)&lt;/code&gt; 입니다. 벡터를 이진 힙으로 변환하는 작업은 제자리에서 수행 할 수 있으며 &lt;code&gt;O(n)&lt;/code&gt; 복잡도를 갖습니다 . 이진 힙을 정렬 된 벡터로 변환하여 &lt;code&gt;O(n log n)&lt;/code&gt; 인플레 이스 힙 정렬에 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="translated">가장 큰 요소를 삽입하고 팝하는 데는 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; )) 시간 복잡도가 있습니다. 가장 큰 요소를 확인하는 것은 &lt;em&gt;O&lt;/em&gt; (1)입니다. 벡터를 이진 힙으로 변환하는 것은 제자리에서 수행 할 수 있으며 복잡성 은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; )입니다. 바이너리 힙은 내부에서 정렬 된 벡터로 변환되어 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 내부 힙 정렬에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;v&lt;/code&gt; 를 옵션에 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 옵션에 &lt;code&gt;v&lt;/code&gt; 를 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 옵션에 &lt;code&gt;value&lt;/code&gt; 을 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="translated">옵션에 &lt;code&gt;value&lt;/code&gt; 을 삽입 한 다음 변경 가능한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">바이트 위치 에서이 &lt;code&gt;String&lt;/code&gt; 에 문자를 삽입합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
