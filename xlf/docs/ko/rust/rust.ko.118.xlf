<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">컬렉션을 만드는 경우 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 를 구현 하면 컬렉션을 &lt;code&gt;for&lt;/code&gt; 루프 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">당신은 부작용의 일종을하고 있다면, 선호 &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">당신이 이것을 반환하고 &lt;code&gt;SUCCESS&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; 에서 &lt;code&gt;Err(_)&lt;/code&gt; 및 &lt;code&gt;Ok(())&lt;/code&gt; 각각 대신 반환하는 것을 고려 하십시오.이 코드는 동일한 코드를 반환하지만 오류를 &lt;code&gt;eprintln!&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">보푸라기 검사를 무시하려면 &lt;code&gt;forbid&lt;/code&gt; 를 변경할 수 있습니다 를 &lt;code&gt;deny&lt;/code&gt; 하거나 &lt;code&gt;forbid&lt;/code&gt; 설정이 명령 줄 옵션으로 제공된 경우 &lt;code&gt;-F&lt;/code&gt; 대신 &lt;code&gt;-D&lt;/code&gt; 를 사용하여 내부 보푸라기 검사 속성을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 별도의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">야간 버전의 rustc를 사용하는 경우 해당 기능을 추가하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">rustc의 안정 버전 또는 베타 버전을 사용하는 경우 불안정한 기능을 사용할 수 없습니다. 이렇게하려면 야간 버전의 rustc (rustup 사용)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">당신이 쓰고 있다면 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; &lt;code&gt;for&lt;/code&gt; 루프와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="translated">상자 이름을 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">어떤 종류의 컬렉션으로 자신을 발견하고 해당 컬렉션의 요소에 대한 작업을 수행 해야하는 경우 신속하게 '반복자'가 발생합니다. 반복자는 관용적 Rust 코드에서 많이 사용되므로 익숙해 질 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">구조체가 실제로 &lt;code&gt;T&lt;/code&gt; 유형의 데이터를 &lt;em&gt;소유&lt;/em&gt; 하지 않으면 다음 과 같은 참조 유형을 사용하는 것이 좋습니다 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (이상적으로) 또는 &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (생명이 적용되지 않는 경우 ) 소유권을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">유형이 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt; &lt;code&gt;partial_cmp&lt;/code&gt; &lt;/a&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">유형이 &lt;code&gt;Ord&lt;/code&gt; 인 경우 구현할 수 있습니다 &lt;code&gt;partial_cmp()&lt;/code&gt; &lt;code&gt;cmp()&lt;/code&gt; 를 사용하여 partial_cmp () 를 .</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 고정을 사용하는 경우 (예 : 위의 두 가지 예) &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현할 때주의해야합니다 . &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 하지만,이 호출된다 &lt;em&gt;당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 컴파일러가 자동으로 &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt; &lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt; &lt;/a&gt; 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">유형에 고정 (예 : 위의 두 예)을 사용하는 경우 &lt;code&gt;Drop&lt;/code&gt; 구현시주의해야합니다 . &lt;code&gt;drop&lt;/code&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 만이라고&lt;em&gt; 당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 마치 컴파일러가 자동으로 &lt;code&gt;get_unchecked_mut&lt;/code&gt; 을 호출 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">대신 클로저가 &lt;code&gt;self.vec&lt;/code&gt; 를 직접 사용하는 경우에는 &lt;code&gt;self&lt;/code&gt; 캡처를 시도합니다. 하는 경우 변경 가능한 참조로 . 그러나 &lt;code&gt;self.set&lt;/code&gt; 이 이미 반복되어 빌려 지기 때문에 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">의 나머지 필드를 무시합니다 &lt;code&gt;person&lt;/code&gt; . 나머지 필드는 값을 가질 수 있으며 변수에 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; 가 중첩 된 값의 일부 무시</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">와 값의 나머지 부분을 무시 &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">특별히 요청하지 않는 한 일부 테스트 무시</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">패턴에서 값 무시</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; 로 전체 값 무시</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; 로 이름을 시작하여 사용하지 않는 변수 무시</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">거실에서 TV로 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 상상해보십시오 . 한 사람이 TV를 보려고 들어 오면 TV가 켜집니다. 다른 사람들은 방에 들어 와서 TV를 볼 수 있습니다. 마지막 사람이 방을 나가면 더 이상 TV를 사용하지 않기 때문에 TV를 끕니다. 다른 사람이 여전히 TV를보고있는 동안 누군가 TV를 끄면 나머지 TV 시청자로부터 큰소리가 들릴 것입니다!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 원시 항목은 사용이 매우 제한적입니다. 대신 &lt;code&gt;raw_entry_mut&lt;/code&gt; 을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">불변 슬라이스 반복자</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다. 값이 현재 변경 가능한 경우에는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Impl 블록은 수명 매개 변수를 별도로 선언합니다. 수명 매개 변수가 고유 한 유형을 구현하는 경우 수명 매개 변수를 impl 블록에 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">특성 증폭</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">구현 &lt;code&gt;unsafe&lt;/code&gt; &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">유형에 대한 일부 기능을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">저렴한 가변 변환 가능 변환을 위해 &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">저렴한 참조 참조 변환을위한 &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">가치에서 가치로의 전환을 소비하기위한 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">현재 상자 외부의 유형으로 값-값 변환을 사용하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 특성을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">유형에 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현에서는 당황하거나 중단하지 않고 메모리 소진시 &lt;code&gt;Err&lt;/code&gt; 을 반환하도록 권장 되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 중단되지 않고 메모리 소진시 널을 리턴하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 당황하거나 중단하는 대신 메모리 소진시 null을 반환하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">구현에는 &lt;code&gt;impl&lt;/code&gt; 키워드 앞에 외부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 과 관련 항목이 포함 된 괄호 안에있는 내부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 이 포함될 수 있습니다. 내부 속성은 관련 항목보다 먼저 와야합니다. 여기서 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; . 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현&lt;em&gt;&lt;/em&gt; 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; &lt;code&gt;a == b&lt;/code&gt; 이고 모든 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 대해 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 경우에만 동일 합니다 . 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">운영자 특성의 구현은 일반적인 의미와 &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;운영자 우선 순위&lt;/a&gt; 를 염두에두고 각각의 상황에서 놀랍지 않아야합니다 . 예를 들어, &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; 을&lt;/a&gt; 구현할 때 연산은 곱셈과 유사해야하며 연관성과 같은 예상 속성을 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대해 &lt;code&gt;Eq&lt;/code&gt; 와 같은 것들을 구현 합니다. 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대한 &lt;code&gt;Eq&lt;/code&gt; 와 같은 구현 . 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="translated">이 특성의 구현은 &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; 에 대한 인수가 안전한 참조이면 결과도 마찬가지 라고 약속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">외국 유형에 대한 구현</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">&lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 수동 구현 은 안전하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Add&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Binary&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 뒤에있는 데이터에 편리하게 액세스 할 수 &lt;code&gt;Deref&lt;/code&gt; 를 구현할 수 있습니다 . 반면에 &lt;code&gt;Deref&lt;/code&gt; 및 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 에 관한 규칙 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이 때문에 혼란을 피하기 &lt;strong&gt;위해 스마트 포인터에만 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; 를 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터 용 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현 하면 뒤에있는 데이터를 편리하게 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현할 수 있습니다 . 반면, &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;DerefMut&lt;/code&gt; 에 관한 규칙은 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이것 때문에,&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/strong&gt;혼란을 피하기&lt;strong&gt; 위해 스마트 포인터&lt;/strong&gt; 에&lt;strong&gt; 대해서만 &lt;/strong&gt;&lt;strong&gt;DerefMut&lt;/strong&gt;&lt;strong&gt; 을 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">구현 &lt;code&gt;Display&lt;/code&gt; 유형에 디스플레이 :</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">구현 &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;FromIterator&lt;/code&gt; 유형에 맞는 FromIterator :</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">구현 &lt;code&gt;Into&lt;/code&gt; 외부 유형 변환에</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="translated">이전 버전의 Rust에서 외부 유형으로 변환하기 위해 &lt;code&gt;Into&lt;/code&gt; 구현 하기</target>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;IntoIterator&lt;/code&gt; 유형에 맞는 IntoIterator :</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerExp&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Octal&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">타입에 대한 &lt;code&gt;Pointer&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Sub&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TryInto&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperExp&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;split_at_mut&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">반복자 구현</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">다른 유형으로의 변환으로 전환 구현</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">유형에 대한 특성 구현</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">유형에 특성을 구현하는 것은 일반 메소드를 구현하는 것과 유사합니다. 차이점은 &lt;code&gt;impl&lt;/code&gt; 후에 구현하려는 특성 이름을 입력 한 다음 &lt;code&gt;for&lt;/code&gt; 키워드 를 사용 하고 특성을 구현하려는 유형의 이름을 지정한다는 것입니다. &lt;code&gt;impl&lt;/code&gt; 블록 내에서 특성 정의가 정의한 메소드 서명을 넣습니다. 각 서명 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 특성의 메소드가 특정 유형에 대해 원하는 특정 동작으로 메소드 본문을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;안전하지 않은 특성&lt;/a&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">객체 지향 디자인 패턴 구현</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; 메소드 구현</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">&lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 함수 구현</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">이행 &lt;code&gt;Deref&lt;/code&gt; 특성 것은 당신의 행동 사용자 정의 할 수 있습니다 &lt;em&gt;참조 연산자&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; 을 (곱셈 또는 글로브 연산자 반대). 스마트 포인터를 일반 참조처럼 취급 할 수있는 방식으로 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 참조에서 작동하는 코드를 작성하고 해당 코드를 스마트 포인터로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 대한 &lt;code&gt;Unpin&lt;/code&gt; 특성을 구현하면 유형 고정의 제한이 해제 되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 함수 를 사용하여 &lt;code&gt;T&lt;/code&gt; 를 &lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 밖으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">특성 구현</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">이러한 특성을 구현하면 특정 운영자에게 과부하를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성을 구현하면 유형 고정의 제한이 해제되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 기능으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 특성의 구현 자를 '리더'라고합니다.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">&lt;code&gt;Write&lt;/code&gt; 특성의 구현 자는 때때로 '작가'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="translated">사전 식으로 배열 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">문자열에 대한 비교 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">문자열 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">두 문자열을 연결하기위한 &lt;code&gt;+&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 에 추가하기위한 &lt;code&gt;+=&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">암시 적 차용</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">함수와 메소드를 사용한 암시 적 역 참조 강제</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">암시 적 차용은 다음과 같은 표현으로 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">암시 적으로 활성화</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">다른 상자 나 모듈에서 항목을 가져 오거나 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="translated">이름에 바인딩하지 않고 트레이 트의 메서드 만 가져 오기 위해 &lt;code&gt;_&lt;/code&gt; 로 가져 오기 (예 : 충돌 방지) : &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">변수 선언 및 표현식 문과 같이 항목이 아닌 문 뒤에는 가져 오기 ( &lt;code&gt;use&lt;/code&gt; 문)를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">스레드 풀을 사용하여 서버의 처리량을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">I / O 프로젝트 개선</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">스레드 풀로 처리량 개선</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">오류 메시지 개선</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 사용 &lt;code&gt;for&lt;/code&gt; 생성하는 루프 카운터 &lt;code&gt;id&lt;/code&gt; 새로 만드는 &lt;code&gt;Worker&lt;/code&gt; 그와 &lt;code&gt;id&lt;/code&gt; , 그리고 벡터에 노동자를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는 우리의 새로운 채널을 생성하고 풀 보류에게 보내는 끝이있다. 이것은 여전히 ​​경고와 함께 성공적으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는의 채널의 수신 측 넣어 &lt;code&gt;Arc&lt;/code&gt; 와 &lt;code&gt;Mutex&lt;/code&gt; . 각각의 새 작업자에 대해 우리는 &lt;code&gt;Arc&lt;/code&gt; 를 복제하여 참조 횟수를 늘려 작업자가 수신 엔드의 소유권을 공유 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 전화를 &lt;code&gt;Dog::baby_name&lt;/code&gt; 정의 관련 함수를 호출 기능, &lt;code&gt;Dog&lt;/code&gt; 직접. 이 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서는 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 두 인스턴스를 &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 다음 생성 된 CustomSmartPointer 를 인쇄 합니다. . 의 끝에서 &lt;code&gt;main&lt;/code&gt; , 우리의 경우 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 는 범위의 외출 것이며, 녹 우리가에 넣어 코드 호출 &lt;code&gt;drop&lt;/code&gt; 우리의 마지막 메시지를 인쇄하는 방법. &lt;code&gt;drop&lt;/code&gt; 메소드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리의 두 인스턴스 생성 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 을 누른 다음 인쇄 &lt;code&gt;CustomSmartPointers created&lt;/code&gt; . &lt;code&gt;main&lt;/code&gt; 이 끝날 때 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 인스턴스는 범위 를 벗어나고 Rust는 &lt;code&gt;drop&lt;/code&gt; 메소드에 넣은 코드를 호출하여 최종 메시지를 인쇄합니다. &lt;code&gt;drop&lt;/code&gt; 메서드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 새로운 문을 추가했습니다 : &lt;code&gt;fs::read_to_string&lt;/code&gt; 합니다 &lt;code&gt;filename&lt;/code&gt; 해당 파일을 엽니하고, 반환 &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; 파일의 내용.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리가 정의한 &lt;code&gt;Point&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;5&lt;/code&gt; )와 &lt;code&gt;f64&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (값 &lt;code&gt;10.4&lt;/code&gt; ). &lt;code&gt;p2&lt;/code&gt; 변수 A는 &lt;code&gt;Point&lt;/code&gt; 의 문자열 슬라이스 갖는 구조체 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) 및 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (가치와 &lt;code&gt;c&lt;/code&gt; ). 호출 &lt;code&gt;mixup&lt;/code&gt; 에 &lt;code&gt;p1&lt;/code&gt; 인수하여 &lt;code&gt;p2&lt;/code&gt; 우리가 제공 &lt;code&gt;p3&lt;/code&gt; 이되는, &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;p1&lt;/code&gt; 에서 왔기 때문 입니다. &lt;code&gt;p3&lt;/code&gt; 변수는있을 것이다 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; 로 하기 때문에, &lt;code&gt;y&lt;/code&gt; 는 온 &lt;code&gt;p2&lt;/code&gt; . &lt;code&gt;println!&lt;/code&gt; 매크로 호출은 &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">에서 &lt;code&gt;match&lt;/code&gt; 표현, 당신은을 사용하여 여러 패턴을 일치시킬 수 있습니다 &lt;code&gt;|&lt;/code&gt; 구문 수단 &lt;em&gt;또는&lt;/em&gt; . 예를 들어, 다음 코드는 &lt;code&gt;x&lt;/code&gt; 값과 일치 팔을 비교합니다. 첫 번째는 &lt;em&gt;또는&lt;/em&gt; 옵션이 있습니다. 즉 &lt;code&gt;x&lt;/code&gt; 값이 해당 팔의 값 중 하나와 일치하면 해당 팔의 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">C 및 C ++에서는 메소드 호출에 두 개의 다른 연산자가 사용됩니다 &lt;code&gt;.&lt;/code&gt; 객체에서 직접 메소드를 호출하는 경우 &lt;code&gt;-&amp;gt;&lt;/code&gt; 객체 에 대한 포인터에서 메소드를 호출하는 경우 먼저 포인터를 역 참조해야하는 경우 즉, &lt;code&gt;object&lt;/code&gt; 가 포인터 인 경우 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; 은 &lt;code&gt;(*object).something()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="translated">C에서 데이터 구조의 끝을 넘어서 읽으려는 시도는 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리의 위치에있는 모든 것을 얻을 수 있습니다. 이를 &lt;em&gt;버퍼 오버 읽기&lt;/em&gt; 라고하며 공격자가 데이터 구조 이후에 저장된 데이터를 읽을 수 없도록 인덱스를 조작 할 수있는 경우 보안 취약성을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">1 장에서는 &lt;code&gt;cargo new&lt;/code&gt; 가 에디션에 대한 약간의 메타 데이터를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 추가하는 것을 보았습니다 . 이 부록은 그 의미에 대해 이야기합니다!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;유형에 대한 특성 구현&amp;rdquo;&lt;/a&gt; 섹션의 10 장 에서 특성 또는 유형이 상자에 국한된 유형에 대한 특성을 구현할 수 있다는 고아 규칙을 언급했습니다. 튜플 구조체에서 새 유형을 만드는 &lt;em&gt;newtype pattern을&lt;/em&gt; 사용하여 이러한 제한을 &lt;em&gt;해결할 수&lt;/em&gt; 있습니다. ( 5 장의 &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&quot;명명 된 필드가없는 튜플 구조 사용&quot;&lt;/a&gt; 섹션에서 튜플 구조를 다루었습니다 . 튜플 구조에는 하나의 필드가 있고 특성을 구현하려는 유형 주위에 얇은 래퍼가됩니다. 그런 다음 포장지 유형은 상자에 국한되며 포장지에 특성을 구현할 수 있습니다. &lt;em&gt;신형&lt;/em&gt;하스켈 프로그래밍 언어에서 유래 한 용어입니다. 이 패턴을 사용하면 런타임 성능이 저하되지 않으며 컴파일시 래퍼 유형이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">10 장에서는 구조체에 참조를 저장할 수 있도록 이러한 오류를 수정하는 방법에 대해 설명하지만 지금 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 과 같은 참조 대신 &lt;code&gt;String&lt;/code&gt; 과 같은 소유 유형을 사용하여 이와 같은 오류를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">12 장에서 바이너리 상자와 라이브러리 상자가 포함 된 패키지를 만들었습니다. 프로젝트가 개발됨에 따라 라이브러리 상자가 계속 커지고 패키지를 여러 라이브러리 상자로 더 분할하려고 할 수 있습니다. 이 상황에서 Cargo는 &lt;em&gt;작업 영역&lt;/em&gt; 이라는 기능을 제공하여 함께 개발 된 여러 관련 패키지를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">13 장에서는 클로저가 환경에서 사용하는 값의 소유권을 갖도록 클로저의 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있다고 언급 했습니다. 이 기법은 한 스레드에서 다른 스레드로 값 소유권을 이전하기 위해 새 스레드를 작성할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">15 장에서는 스마트 포인터 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 참조 계수 값을 생성 하여 여러 소유자에게 값을 제공했습니다. 여기서도 똑같이하고 무슨 일이 일어나는지 봅시다. Listing 16-14의 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 랩핑하고 소유권을 스레드로 이동하기 전에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 복제한다 . 이제 오류를 보았으므로 &lt;code&gt;for&lt;/code&gt; 루프를 다시 사용하도록 전환 하고 &lt;code&gt;move&lt;/code&gt; 키워드를 클로저 로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">16 장에서는 다양한 동시 프로그래밍 모델을 살펴보고 Rust가 여러 스레드에서 두려움없이 프로그래밍하는 방법에 대해 설명합니다. 17 장에서는 Rust 관용구가 익숙한 객체 지향 프로그래밍 원칙과 어떻게 비교되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">16 장에서는 이 사용 사례에 적합한 &lt;em&gt;채널 (&lt;/em&gt; 두 스레드 간 통신하는 간단한 방법)에 대해 배웠습니다 . 채널을 사용하여 작업 대기열로 작동하고, &lt;code&gt;execute&lt;/code&gt; 하면 &lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code&gt;Worker&lt;/code&gt; 인스턴스로 작업을 보내면 작업이 스레드로 전송됩니다. 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">2 장에서는 &lt;code&gt;rand&lt;/code&gt; 라는 외부 패키지를 사용하여 임의의 숫자를 얻는 추측 게임 프로젝트를 프로그래밍했습니다 . 프로젝트에서 &lt;code&gt;rand&lt;/code&gt; 를 사용 하기 &lt;em&gt;위해이&lt;/em&gt; 행을 &lt;em&gt;Cargo.toml에&lt;/em&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">20 장에서는 저수준 멀티 스레드 웹 서버를 구현할 프로젝트를 완성 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">제 3 장에서 우리는 언급 &lt;code&gt;for&lt;/code&gt; 루프가 녹 코드에서 가장 일반적인 루프 구조이지만, 우리가 아직 그 패턴을 설명하지 않은 &lt;code&gt;for&lt;/code&gt; 소요됩니다. (A)에 &lt;code&gt;for&lt;/code&gt; 루프 패턴 직접 키워드 다음 값인 &lt;code&gt;for&lt;/code&gt; 너무에서 &lt;code&gt;for x in y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 패턴된다.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">4 장의 &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Dangling References&quot;&lt;/a&gt; 섹션에서 컴파일러는 참조가 항상 유효한지 확인한다고 언급했습니다. 안전하지 않은 녹에는 참조와 유사한 &lt;em&gt;원시 포인터&lt;/em&gt; 라는 두 가지 새로운 유형이 있습니다 . 참조와 마찬가지로 원시 포인터는 변경 불가능하거나 변경 가능하며 각각 &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 로 작성됩니다. 별표는 역 참조 연산자가 아닙니다. 유형 이름의 일부입니다. 원시 포인터의 맥락에서, &lt;em&gt;불변&lt;/em&gt; 은 의미가 역 참조 된 후 포인터를 직접 할당 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">5 장, 리스팅 5-15에서, 우리는 &lt;code&gt;Rectangle&lt;/code&gt; 구조체와 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 사용했다. 이것은 Listing 11-5에서 반복된다. 이 코드를 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에 넣고 &lt;code&gt;assert!&lt;/code&gt; 사용하여 테스트를 &lt;em&gt;해보자 &lt;/em&gt;! 매크로.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">6 장에서 우리는 &lt;code&gt;if let&lt;/code&gt; 식이 주로 하나의 경우에만 일치 하는 &lt;code&gt;match&lt;/code&gt; 을 작성하는 더 짧은 방법으로 사용하는 방법에 대해 논의했습니다 . 선택적으로, &lt;code&gt;if let&lt;/code&gt; 해당 할 수 있습니다 &lt;code&gt;else&lt;/code&gt; 실행 포함 된 코드를에서 패턴 경우 &lt;code&gt;if let&lt;/code&gt; 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">7 장에서는 &lt;code&gt;mod&lt;/code&gt; 키워드를 사용하여 코드를 모듈로 구성 하는 방법, &lt;code&gt;pub&lt;/code&gt; 키워드를 사용하여 항목을 공개 하는 방법 및 &lt;code&gt;use&lt;/code&gt; 키워드를 사용 하여 항목을 범위로 가져 오는 방법에 대해 설명했습니다 . 그러나 상자를 개발하는 동안 귀하에게 적합한 구조는 사용자에게별로 편리하지 않을 수 있습니다. 여러 수준을 포함하는 계층 구조에서 구조체를 구성하려고 할 수 있지만 계층에서 깊게 정의한 형식을 사용하려는 사람들은 해당 형식이 있는지 찾는 데 어려움이있을 수 있습니다. 그들은 또한 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; 을 입력 해야하는 것에 짜증이 날 수도 있습니다 . &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; 하지 말고 ; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">7 장에서는 Rust의 모듈 시스템과 코드 및 공개 API (Application Programming Interface) 구성을위한 개인 정보 보호 규칙에 대해 설명합니다. 8 장에서는 벡터, 문자열 및 해시 맵과 같은 표준 라이브러리가 제공하는 공통 컬렉션 데이터 구조에 대해 설명합니다. 9 장은 Rust의 오류 처리 철학과 기술을 탐구합니다.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">8 장에서 벡터의 한 가지 제한은 벡터가 한 가지 유형의 요소 만 저장할 수 있다는 것입니다. Listing 8-10에서 정수, 부동 수 및 텍스트를 보유하는 변형이 있는 &lt;code&gt;SpreadsheetCell&lt;/code&gt; 열거 형을 정의한 해결 방법을 만들었습니다 . 즉, 각 셀에 서로 다른 유형의 데이터를 저장할 수 있으며 셀 행을 나타내는 벡터를 계속 가질 수 있습니다. 이것은 상호 교환 가능한 항목이 코드 컴파일 시점을 알고있는 고정 된 유형의 세트 일 때 완벽하게 좋은 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">열거 형 정의에서</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">함수 정의에서</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">목록 10-3, 우리라는 이름의 함수로 가장 큰 수를 발견 한 코드 추출 &lt;code&gt;largest&lt;/code&gt; . 하나의 특정 목록에서만 가장 큰 숫자를 찾을 수있는 Listing 10-1의 코드와 달리이 프로그램은 두 개의 다른 목록에서 가장 큰 숫자를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">Listing 11-7에서 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성하여 매개 변수에 &lt;code&gt;2&lt;/code&gt; 를 더하고 결과를 리턴한다. 그런 다음 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">Listing 12-6에서 우리는 &lt;code&gt;String&lt;/code&gt; 값 의 슬라이스를 가져와 슬라이스 로 인덱싱하고 값을 복제하여 &lt;code&gt;Config&lt;/code&gt; 구조체 의 인스턴스를 생성하는 코드를 추가 하여 &lt;code&gt;Config&lt;/code&gt; 구조체가 해당 값을 소유 할 수있게했다 . Listing 13-24에서는 Listing 12-23에서와 같이 &lt;code&gt;Config::new&lt;/code&gt; 함수 의 구현을 재현했다 .</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">Listing 12-8에서 인덱스 1과 2에 액세스하기 전에 슬라이스가 충분히 길다는 것을 확인하는 &lt;code&gt;new&lt;/code&gt; 함수에 점검을 추가 한다. 슬라이스가 충분히 길지 않으면 프로그램은 패닉 상태가되고 더 나은 오류 메시지를 표시한다. &lt;code&gt;index out of bounds&lt;/code&gt; 메시지 색인 .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">Listing 13-18에서는 호출에서 반환 된 반복자를 반복 하여 벡터 로 &lt;code&gt;map&lt;/code&gt; 한 결과를 수집한다 . 이 벡터는 원래 벡터의 각 항목을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">Listing 13-19에서는 환경에서 &lt;code&gt;shoe_size&lt;/code&gt; 변수 를 캡처하여 &lt;code&gt;Shoe&lt;/code&gt; 구조체 인스턴스 컬렉션을 반복 하는 클로저와 함께 &lt;code&gt;filter&lt;/code&gt; 를 사용한다 . 지정된 크기의 신발 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">Listing 15-19에서 &lt;code&gt;main&lt;/code&gt; 을 변경 하여 list &lt;code&gt;c&lt;/code&gt; 주위에 내부 범위를 갖도록한다 . &lt;code&gt;c&lt;/code&gt; 가 범위를 벗어날 때 참조 카운트가 어떻게 변하는 지 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">Listing 15-26에서는 Listing 15-25의 정의를 사용 하는 &lt;code&gt;main&lt;/code&gt; 함수를 추가하고있다 . 이 코드의 목록을 작성 및 예약리스트 &lt;code&gt;b&lt;/code&gt; 의 목록에 그 점 &lt;code&gt;a&lt;/code&gt; . 그런 다음의 목록을 수정 를 가리 &lt;code&gt;b&lt;/code&gt; 기준주기를 생성. &lt;code&gt;println!&lt;/code&gt; 이 있습니다 ! 이 과정에서 참조 카운트가 다양한 지점에있는 것을 보여주는 방법 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">Listing 16-8에서 우리는 메인 스레드에서 채널의 수신단으로부터 값을 얻을 것이다. 이것은 강 끝의 물에서 고무 오리를 검색하거나 채팅 메시지를받는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">Listing 18-11에서 패턴 가드 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했다. 새로운 변수는 패턴 내부에서 생성 된 리콜 &lt;code&gt;match&lt;/code&gt; 외부 변수를 사용하는 대신에 식 &lt;code&gt;match&lt;/code&gt; . 새로운 변수는 외부 변수의 값에 대해 테스트 할 수 없음을 의미했습니다. Listing 18-27은이 문제를 해결하기 위해 매치 가드를 사용하는 방법을 보여준다.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">목록 7-11에서, 우리는 가져 &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; 의 범위에 모듈을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 의 우리가 단지 지정해야하므로 기능 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 통화에 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 에서 기능을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">Listing 7-11에서 왜 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 을 지정한 다음 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수에 &lt;code&gt;use&lt;/code&gt; 경로를 지정 하여 동일한 결과를 얻기 보다는 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; :: add_to_waitlist 를 호출 한 이유가 궁금 할 것이다 . 목록 7-13에서와 같이.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">분석법 정의에서</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">Rust 1.3에서는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156에&lt;/a&gt; 설명 된대로 기본 객체 수명 범위가 변경 될 것으로 예상됩니다 . 컴파일러가이 변경으로 인해 코드에 컴파일 오류가 발생할 수 있다고 생각하기 때문에 경고 메시지가 표시됩니다. 가능하지는 않지만 이것이 잘못된 경보 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="translated">Rust 2015에서 &lt;code&gt;use&lt;/code&gt; 구문의 경로 는 크레이트 루트에 상대적입니다. 현재 및 부모 모듈과 관련된 항목을 가져 오려면 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사를 각각 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="translated">Rust 2018에서는 &lt;code&gt;extern crate&lt;/code&gt; 선언이 필요하지 않으며 대신 &lt;code&gt;use&lt;/code&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="translated">Rust 2018에서 &lt;code&gt;use&lt;/code&gt; 명령문의 경로 는 상자 이름 또는 리터럴 &lt;code&gt;crate::&lt;/code&gt; 시작하지 않는 한 현재 모듈에 상대적 입니다.이 경우 상자 루트에서 시작합니다. Rust 2015 코드에서와 같이 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사는 각각 현재 및 부모 모듈을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">Rust에서 함수는 패닉 상태에 빠지거나 전 이적으로 패닉 상태에있는 함수를 호출하면 &quot;반환&quot;할 수 있습니다. 이러한 종류의 제어 흐름이 항상 예상되는 것은 아니며 두 가지 중요한 구성 요소의 조합을 통해 미묘한 버그가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">Rust에서 &lt;em&gt;릴리스 프로파일&lt;/em&gt; 은 서로 다른 구성으로 사전 정의되고 사용자 정의 가능한 프로파일로, 프로그래머가 코드 컴파일을위한 다양한 옵션을보다 효과적으로 제어 할 수 있습니다. 각 프로파일은 다른 프로파일과 독립적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 주석은 두 개의 슬래시로 시작하여 줄 끝까지 계속되어야합니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">Rust에서는 전역 변수를 &lt;em&gt;정적&lt;/em&gt; 변수 라고 합니다. Listing 19-9는 문자열 슬라이스를 값으로 사용하여 정적 변수를 선언하고 사용하는 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">Rust에서 통합 테스트는 라이브러리 외부에 있습니다. 라이브러리는 다른 코드와 같은 방식으로 라이브러리를 사용하므로 라이브러리의 공용 API에 속하는 함수 만 호출 할 수 있습니다. 이들의 목적은 라이브러리의 많은 부분이 올바르게 작동하는지 테스트하는 것입니다. 자체적으로 올바르게 작동하는 코드 단위는 통합시 문제가 발생할 수 있으므로 통합 코드의 테스트 범위도 중요합니다. 통합 테스트를 작성하려면 먼저 &lt;em&gt;tests&lt;/em&gt; 디렉토리 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">Rust에서는 다른 사용 사례에 대해 다른 유형의 표현을 제공하는 것이 일반적입니다. 예를 들어, 값에 대한 저장 위치 및 관리는 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 유형을 통해 특정 용도에 적합하게 선택 될 수 있습니다 . 모든 유형에 사용할 수있는 이러한 일반 래퍼 외에도 일부 유형은 선택적인 패싯을 제공하여 잠재적으로 비용이 많이 드는 기능을 제공합니다. 이러한 유형에 대한 예는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 기본 문자열을 확장 할 수있는 기능이 추가되는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . 단순하고 불변 인 문자열에는 추가 정보를 불필요하게 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하려는 경우 벡터가 아닌 슬라이스로 슬라이스를 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하고 싶을 때 슬라이스를 벡터보다는 인수로 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">Rust에서 이터레이터는 &lt;em&gt;게으르다&lt;/em&gt; . 즉, 이터레이터를 사용하기 위해 이터레이터를 소비하는 메소드를 호출 할 때까지 효과가 없다. 예를 들어, 목록 13-13의 코드는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정의 된 &lt;code&gt;iter&lt;/code&gt; 메소드 를 호출하여 벡터 &lt;code&gt;v1&lt;/code&gt; 의 항목에 대해 반복자를 작성합니다 . 이 코드 자체는 유용한 기능을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 단순 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 지정하거나 인수로 전달하면 수신자가 사본을 가져 와서 원래 값을 그대로 둡니다. 이러한 유형은 복사 할 때 할당 할 필요가없고 종료자가 없습니다 (즉, 소유 한 상자가 없거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ). 따라서 컴파일러는 복사가 저렴하고 안전하다고 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성을 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 규칙에 따라 명시 적으로 복사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 간단한 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 할당하거나 인수로 전달할 때 수신자는 원래 값을 그대로두고 사본을 얻습니다. 이러한 유형은 복사 할 할당이 필요하지 않으며 종료자가 없으므로 (즉, 소유 된 상자를 포함하지 않거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ) 컴파일러는 복사하기에 저렴하고 안전한 것으로 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 는 Clone 트레이 트를 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 명시 적으로 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">Rust에서 일부 유형은 컴파일 타임에 알려진 크기를 갖지 않습니다. 예를 들어, &lt;code&gt;[u32]&lt;/code&gt; 와 같은 슬라이스 유형 에서는 요소 수를 컴파일 타임에 알 수 없으므로 전체 크기를 계산할 수 없습니다. 결과적으로, 이러한 유형은 참조 (예 : &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 또는 다른 포인터 유형 (예 : &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; )을 통해서만 조작 할 수 있습니다 . 대신 참조로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">Rust에서 문자열은 항상 유효한 UTF-8이며 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">Rust에서 컴파일러는 값이 변하지 않는다고 말할 때 실제로 변하지 않도록 보장합니다. 즉, 코드를 읽고 쓸 때 값이 어떻게, 어디서 변경 될 수 있는지 추적 할 필요가 없습니다. 따라서 코드를 쉽게 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 관용적 주석 스타일은 두 개의 슬래시로 주석을 시작하고 주석은 줄 끝까지 계속됩니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">Rust에서 배열로 들어가는 값은 대괄호 안에 쉼표로 구분 된 목록으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">소유권과 차용의 개념을 사용하는 Rust에서 참조와 스마트 포인터의 추가 차이점은 참조는 데이터 만 빌리는 포인터라는 점입니다. 대조적으로, 많은 경우에, 스마트 포인터 는 그들이 가리키는 데이터를 &lt;em&gt;소유&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">Rust에서는 컴파일 타임에 크기가 알려진 경우에만 값을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">구조 정의에서</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">터키어에서 라틴어의 'i'는 두 가지 형식 대신 다섯 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">A의 &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 정의하고 관련 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 유형, 평생에만 반환 유형이 아닌 인수 유형에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 형, 수명은 인수 유형 만 반환 형식에 표시하지.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 프로그램에서 표준 라이브러리에는 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의해 사용되는 하나의 &quot;전역&quot;메모리 할당자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">일치 표현식에서는 숫자와 문자 만 범위와 일치시킬 수 있습니다. 컴파일러가 컴파일 타임에 범위가 비어 있지 않은지 확인하고 임의 비교 함수를 평가할 수 없기 때문입니다. 두 엔드 포인트 사이에서 주문 가능한 유형의 값을 캡처하려는 경우 가드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">패턴에서 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하지 않는 모든 값 은 동일한 방식으로 바인딩되어야합니다. 여기서 목표는 이동 및 참조에 의한 바인딩을 동시에 피하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">패턴에서 : 포괄적 인 범위 패턴</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 비슷한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 하면 다시 호출하면 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; 을&lt;/a&gt; 다시 반환 할 수도 있고 반환하지 않을 수도 있습니다 . 이 목적을 위해 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 은 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 유사한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;code&gt;next_back()&lt;/code&gt; 에서 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 다시 호출하면 &lt;code&gt;Some&lt;/code&gt; 을 다시 반환하거나 반환하지 않을 수 있습니다 . &lt;code&gt;next()&lt;/code&gt; 와 &lt;code&gt;next_back()&lt;/code&gt; 은이 목적을 위해 상호 교환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">어떤 방식 으로든 모든 프로그래밍 언어의 채널은 단일 소유권과 유사합니다. 일단 채널로 값을 전송하면 더 이상 해당 값을 사용하지 않아야합니다. 공유 메모리 동시성은 다중 소유권과 같습니다. 여러 스레드가 동시에 동일한 메모리 위치에 액세스 할 수 있습니다. 스마트 포인터가 다중 소유권을 가능하게하는 15 장에서 보았 듯이, 서로 다른 소유자가 관리해야하기 때문에 다중 소유권이 복잡성을 추가 할 수 있습니다. Rust의 유형 시스템 및 소유권 규칙은 이러한 관리를 올바르게 수행하는 데 크게 도움이됩니다. 예를 들어, 공유 메모리에 대한 가장 일반적인 동시성 기본 요소 중 하나 인 뮤텍스를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">변경 불가능한 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 많은 상황에서 컴파일러가 &lt;code&gt;Deref&lt;/code&gt; 를 암시 적으로 사용합니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 변경 가능한 컨텍스트에서는 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">가변 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 &lt;code&gt;DerefMut&lt;/code&gt; 은 많은 환경에서 컴파일러에 의해 암시 적으로 사용됩니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 불변의 문맥에서는 &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">코드가 예상 한 올바른 값을 반환하는지 확인하는 것 외에도 코드가 예상 한대로 오류 조건을 처리하는지 확인하는 것이 중요합니다. 예를 들어, 9 장, 목록 9-10에서 만든 &lt;code&gt;Guess&lt;/code&gt; 유형을 고려하십시오 . 용도가 다른 코드를 &lt;code&gt;Guess&lt;/code&gt; 하는 보증에 따라 &lt;code&gt;Guess&lt;/code&gt; 경우 우리는 것을 보장이 만들려고하는 테스트를 작성할 수 1과 100 사이의 값만 포함됩니다 &lt;code&gt;Guess&lt;/code&gt; 범위 패닉 그 값 외부와 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">패턴 일치를 통해 구조를 제거하는 것 외에도 마침표 ( &lt;code&gt;.&lt;/code&gt; )와 액세스하려는 값의 색인을 사용하여 튜플 요소에 직접 액세스 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">메모리 블록 피팅 외에도 &lt;code&gt;layout&lt;/code&gt; 의 배향의 &lt;code&gt;layout&lt;/code&gt; 메모리의 블록을 할당하는 데 사용되는 정렬과 일치한다.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">그룹화 기능 외에도 구현 세부 정보를 캡슐화하면 코드를 더 높은 수준에서 재사용 할 수 있습니다. 작업을 구현 한 후에는 다른 코드가 구현 방식을 알지 않고도 코드의 공용 인터페이스를 통해 해당 코드를 호출 할 수 있습니다. 코드를 작성하는 방법은 다른 코드에 사용할 공용 파트와 변경 권한을 보유한 프라이빗 구현 세부 사항을 정의합니다. 이것은 머리에 유지해야 할 세부 사항의 양을 제한하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">&lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; 형식으로 고정 유형을 제공하는 것 외에도 함수는 유형 특성 목록을 특성 범위와 함께 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 외에도 Rust는 사용자가 주어진 범위 내에서만 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 이외에도 Rust를 사용하면 지정된 범위 내에서 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Clone&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Copy&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">또한받는 &lt;code&gt;#[cfg]&lt;/code&gt; 속성이 매크로 구성 플래그 논리식 평가를 허용하도록 제공된다. 이로 인해 코드 중복이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">서명에 따라 다양한 기능 포인터가 제공됩니다. 함수 포인터는 안전과 안전하지 않은 두 가지 방식으로 제공됩니다. 일반 &lt;code&gt;fn()&lt;/code&gt; 함수 포인터는 안전 함수 만 가리킬 수 있지만 &lt;code&gt;unsafe fn()&lt;/code&gt; 함수 포인터는 안전 또는 안전하지 않은 함수를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">또한, &lt;code&gt;unsafe&lt;/code&gt; 블록이 반드시 위험 내부의 코드를 의미하지 않거나 확실히 메모리 안전 문제가있는 것 : 의도는 프로그래머로, 당신은 내부의 코드를 확인합니다 것입니다 &lt;code&gt;unsafe&lt;/code&gt; 유효한 방법으로 블록 의지 액세스 메모리 .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">또한,의 함수 포인터 &lt;em&gt;어떤&lt;/em&gt; 서명, ABI, 또는 안전은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , 모든 &lt;em&gt;안전&lt;/em&gt; 함수 포인터 구현 &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; 을&lt;/a&gt; . 이러한 특성은 컴파일러에 특별히 알려져 있기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">또한 이것에 의해 암시 된 설계 선택이 있습니다. Rust는 자동으로 데이터의 &quot;심층&quot;사본을 자동으로 생성하지 않습니다. 따라서 &lt;em&gt;자동&lt;/em&gt; 복사는 런타임 성능 측면에서 저렴한 것으로 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">또한, 우리는 다룰 &lt;em&gt;내부 가변성&lt;/em&gt; 불변의 유형은 내부 값을 돌연변이에 대한 API를 노출 패턴. 또한 &lt;em&gt;참조주기&lt;/em&gt; , 메모리 누수 방법 및 방지 방법에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">다른 모든 경우 ( &lt;code&gt;setting_value&lt;/code&gt; 또는 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 ) 두 번째 암 의 &lt;code&gt;_&lt;/code&gt; 패턴으로 표시되면 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;setting_value&lt;/code&gt; 가되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">다른 모든 경우에는 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류 에서 &lt;code&gt;Dragon&lt;/code&gt; 열거 형 에서 &lt;code&gt;Born&lt;/code&gt; 변형 을 반환하려면 변형이 아닌 열거 형을 반환하도록 함수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류에서 우리 는 불가능한 &lt;code&gt;Mordor&lt;/code&gt; 모듈 을 인스턴스화하려고했습니다 . 모듈 내에서 유형을 인스턴스화하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">이중 연결 목록에서 컬렉션은 실제로 요소 자체에 메모리를 할당하지 않습니다. 할당은 클라이언트에 의해 제어되며 요소는 컬렉션보다 수명이 짧은 스택 프레임에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서는 중첩 된 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 사람들이 필요로하는 별도의 &lt;code&gt;use&lt;/code&gt; 문 수를 줄일 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서 중첩 된 경로를 사용하여 동일한 패키지 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 부분에서 필요한 개별 &lt;code&gt;use&lt;/code&gt; 문 수가 줄어들 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="translated">두 경우 모두 변수 ( &lt;code&gt;_&lt;/code&gt; 라고 함 )를 선언 하고 유형을 지정합니다. 그러나 &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; 및 &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; 는 유형이 아니므로 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">이 두 가지 예에서 '&amp;szlig;'는 인코딩하는 데 2 ​​바이트가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">이 두 가지 예에서 '𝕊'은 인코딩하는 데 두 개의 &lt;code&gt;u16&lt;/code&gt; 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특별한 동작을 호출하는 데 사용됩니다 (아래 &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; 및 &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt; 에서 설명 ). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치 및 전사됩니다. 예외는 matcher의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 &lt;code&gt;(())&lt;/code&gt; 는 &lt;code&gt;{()}&lt;/code&gt; 와 일치 하지만 &lt;code&gt;{{}}&lt;/code&gt; 와는 일치 하지 않습니다 . &lt;code&gt;$&lt;/code&gt; 문자 는 일치하거나 문자 그대로 기록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특수한 동작을 호출하는 데 사용됩니다 (아래의 &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions 참조&lt;/a&gt; ). 이러한 호출에 포함되지 않은 토큰은 문자 그대로 일치하고 기록됩니다 (단, 예외). 단, 매처의 외부 분리 문자는 모든 분리 문자 쌍과 일치합니다. 따라서, 예를 들어, 정규가 &lt;code&gt;(())&lt;/code&gt; 일치 &lt;code&gt;{()}&lt;/code&gt; 하지만 &lt;code&gt;{{}}&lt;/code&gt; . 문자 &lt;code&gt;$&lt;/code&gt; 는 문자 그대로 일치하거나 전사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">matcher와 transcriber에서 반복은 &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 안에 반복 될 토큰을 배치 한 후 반복 연산자를 선택적으로 선택하고 선택적으로 사이에 분리기 토큰이 있습니다. 분리기 토큰은 분리 기호 또는 반복 연산자 중 하나 이외의 임의의 토큰 일 수 있지만 &lt;code&gt;;&lt;/code&gt; 그리고 &lt;code&gt;,&lt;/code&gt; 가장 일반적이다. 예를 들어 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 는 쉼표로 구분 된 여러 식별자를 나타냅니다. 중첩 반복이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 크기의 종류 (얇은) 포인터에 대해, 이것은 단순한 과제와 동일한 효과를 가지고, 반면 크기를 지정하지 않은 형태로 (FAT) 포인터는,이 동작은, 포인터의 일부에 영향을 미칠 것이다.</target>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 변형의 경우 내부 오류를 검색합니다. &lt;code&gt;try!&lt;/code&gt; 그런 다음 &lt;code&gt;From&lt;/code&gt; 을 사용하여 변환을 수행합니다 . 이것은 특수 오류와보다 일반적인 오류 사이의 자동 변환을 제공합니다. 결과 오류가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">항목이 &lt;code&gt;impl&lt;/code&gt; 내부의 함수 인 경우 개인 도우미 함수를 정의하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="translated">문서 주석 다음에 항목을 문서화하려는 경우 외부 문서 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">중첩 모듈이 많은 경우 &lt;code&gt;pub use&lt;/code&gt; 하여 최상위 수준에서 유형을 다시 내 보내면 상자를 사용하는 사람들의 경험에 큰 차이가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">경우에 따라 Rust에 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 강제 변환 이라고하는이 변환을 수행하기에 충분한 정보가 없습니다 . 다음 예제에서 문자열 슬라이스 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; 은 특성 &lt;code&gt;TraitExample&lt;/code&gt; 을 구현하고 &lt;code&gt;example_func&lt;/code&gt; 함수 는 특성을 구현하는 모든 것을 취합니다. 이 경우 Rust는 두 가지 암시 적 변환을 수행해야하는데, Rust는이를 수행 할 수단이 없습니다. 따라서 다음 예제는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">경우에 따라 하위 바인딩이 메모리 안전을 위반할 수 있습니다. 차후 버전의 Rust에서 차용 검사기를 업데이트하면이 제한이 제거 될 수 있지만 현재는 패턴을 하위 바인딩없이 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">이에 비해 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 는 잠금을 획득 한 리더 또는 기록기를 구분하지 않으므로 잠금을 사용할 수있을 때까지 기다리는 스레드를 차단합니다. 라이터가 잠금을 보유하지 않는 한 &lt;code&gt;RwLock&lt;/code&gt; 을 사용하면 여러 독자가 잠금을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">결론 : 항상 원하는 색인이 실제로 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">반대로 열거 형을 공개하면 모든 변형이 공개됩니다. 우리는 단지 필요 &lt;code&gt;pub&lt;/code&gt; 전과 &lt;code&gt;enum&lt;/code&gt; 목록 7-10에서와 같이 키워드.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">대조적으로, Rust의 문장은 &lt;em&gt;대부분&lt;/em&gt; 시퀀스 표현 평가를 포함하고 명시 적으로 제공하는 역할 을합니다.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">반대로, 목록 19-7에서 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 을 사용하면 슬라이스를 사용할 때 충돌이 발생할 수 있습니다. 이 코드는 임의의 메모리 위치를 취하고 10,000 항목 길이의 슬라이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">본질적으로 &lt;code&gt;*const c_void&lt;/code&gt; 는 C의 &lt;code&gt;const void*&lt;/code&gt; 와 &lt;code&gt;*mut c_void&lt;/code&gt; 는 C의 &lt;code&gt;void*&lt;/code&gt; 와 같습니다 . 즉, Rust의 &lt;code&gt;()&lt;/code&gt; 유형 인 C의 &lt;code&gt;void&lt;/code&gt; 반환 유형 과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">함수 시그니처에서 각 매개 변수의 유형을 선언 &lt;em&gt;해야합니다&lt;/em&gt; . 이것은 Rust 디자인에서 의도적으로 결정한 것입니다. 함수 정의에 타입 주석이 필요하다는 것은 컴파일러가 코드의 다른 곳에서이를 사용하여 의미를 파악할 필요가 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">일반적으로 &lt;code&gt;--crate-type=bin&lt;/code&gt; 또는 &lt;code&gt;--crate-type=lib&lt;/code&gt; 는 모든 컴파일 요구에 충분해야하며 상자의 출력 형식에 대해보다 세밀한 제어가 필요한 경우 다른 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">일반적으로 C ++ 구현은 오버 헤드 제로 원칙을 준수합니다. 사용하지 않는 것은 지불하지 않습니다. 그리고 더 : 당신이 사용하는 것, 당신은 더 나은 코딩을 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">일반적으로 형식을 지정하여 수행 할 수있는 모든 캐스트는 &lt;code&gt;as&lt;/code&gt; 를 사용하여 수행 할 수도 있으므로 &lt;code&gt;let x: u32 = 123&lt;/code&gt; 을 쓰는 대신 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 쓸 수 있습니다 (참고 : &lt;code&gt;let x: u32 = 123&lt;/code&gt; 은 그 상황에서 최고입니다). 그러나 다른 방향에서는 동일하지 않지만, 명시 적으로 &lt;code&gt;as&lt;/code&gt; 를 사용하면 원시 포인터의 유형을 변경하거나 클로저를 원시 포인터로 바꾸는 것과 같이 암시 적으로 허용되지 않는 몇 가지 강제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">일반적으로이 기능은 패닉 상태 일 수 있으므로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 소문자를 명시 적으로 처리하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">일반적으로 정규화 된 구문은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">일반적으로 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값 을 사용하려면 각 변형을 처리 할 코드가 필요합니다. &lt;code&gt;Some(T)&lt;/code&gt; 값 이있는 경우에만 실행되는 일부 코드를 원하며이 코드 는 내부 &lt;code&gt;T&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 값이 있고 해당 코드에 사용 가능한 &lt;code&gt;T&lt;/code&gt; 값 이없는 경우 다른 코드를 실행하려고 합니다. &lt;code&gt;match&lt;/code&gt; 표현식 열거 사용할 때 단지이를 수행하는 제어 흐름 구조이다 그것이 갖는 ENUM 어떤 변형에 따라 다양한 코드를 실행하고, 그 코드가 일치하는 값 안의 데이터를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">일반적으로 유형의 크기는 컴파일에서 안정적이지 않지만 프리미티브와 같은 특정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">일반적으로이 책은 앞뒤로 순서대로 읽고 있다고 가정합니다. 이후의 장은 이전 장의 개념을 바탕으로하며, 이전 장에서는 주제에 대한 자세한 내용을 다루지 않을 수 있습니다. 우리는 일반적으로 이후 장에서 주제를 다시 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">일반적으로 반박과 반박 할 수없는 패턴의 차이에 대해 걱정할 필요는 없습니다. 그러나 오류 메시지에 표시 될 때 응답 할 수 있도록 반품 성 개념에 익숙해야합니다. 이 경우 코드의 의도 된 동작에 따라 패턴 또는 패턴을 사용하는 구문을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">여기에서 &lt;code&gt;jon_snow&lt;/code&gt; 는 이미 &lt;code&gt;nights_watch&lt;/code&gt; 참조에 의해 빌려 &lt;code&gt;starks&lt;/code&gt; 동시에 스타크 폐쇄에 의해 빌릴 수 없습니다 . 이 문제를 해결하려면 차용이 끝난 후 마감을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 변경할 수 없으므로 &lt;code&gt;y&lt;/code&gt; 에서 변경 가능하게 빌리려고 하면 실패합니다. 이 오류를 해결하려면 &lt;code&gt;x&lt;/code&gt; 를 변경 가능 하게 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">여기에서 &lt;code&gt;y&lt;/code&gt; 는 내부 범위의 끝에서 삭제되지만 &lt;code&gt;println&lt;/code&gt; 까지 &lt;code&gt;x&lt;/code&gt; 에 의해 빌려집니다 . 이전 예제를 수정하려면 println 이후까지 &lt;code&gt;y&lt;/code&gt; 가 떨어지지 않도록 범위를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstra는 1972 년의&amp;ldquo;The Humble Programmer&amp;rdquo;에세이에서&amp;ldquo;프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법 일 수 있지만 그들의 부재를 보여주기에는 부적절하다&amp;rdquo;고 말했다. 그렇다고 테스트를 최대한 많이 시도해서는 안된다는 의미는 아닙니다!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">2009 년 발표에서&amp;ldquo;Null References : Billion Dollar Mistake&amp;rdquo;는 null 발명가 인 Tony Hoare가 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">불변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">스레드에서 &lt;code&gt;Worker&lt;/code&gt; 는 채널의 수신 측을 반복하고 수신 작업의 폐쇄를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">표준 라이브러리에서 반복자를 제공하지 않는 언어의 경우 인덱스 0에서 변수를 시작하고 해당 변수를 사용하여 벡터로 색인하여 값을 가져오고 루프에서 변수 값을 증가 시켜서 동일한 기능을 작성할 수 있습니다. 벡터의 총 항목 수에 도달 할 때까지</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">포인터가있는 언어에서는 다른 메모리에 포인터를 유지하면서 메모리를 확보하여 다른 사람에게 제공되었을 수있는 메모리의 위치를 ​​참조 하는 &lt;em&gt;댕글 링 포인터&lt;/em&gt; 를 잘못 만드는 것이 쉽습니다 . 이와 대조적으로 Rust에서는 컴파일러가 참조가 참조에 매달려 있지 않도록 보장합니다. 일부 데이터에 대한 참조가있는 경우 컴파일러는 데이터에 대한 참조가 데이터를 참조하기 전에 데이터가 범위를 벗어나지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">다른 많은 프로그래밍 언어에서 색인으로 참조하여 문자열의 개별 문자에 액세스하는 것은 유효하고 일반적인 작업입니다. 그러나 Rust에서 인덱싱 구문을 사용하여 &lt;code&gt;String&lt;/code&gt; 일부에 액세스하려고 하면 오류가 발생합니다. 목록 8-19의 유효하지 않은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">많은 프로그래밍 언어에서 스택과 힙에 대해 자주 생각할 필요가 없습니다. 그러나 Rust와 같은 시스템 프로그래밍 언어에서 값이 스택에 있는지 또는 힙에 있는지는 언어의 작동 방식과 특정 결정을 내리는 이유에 더 많은 영향을 미칩니다. 소유권의 일부는이 장의 뒷부분에서 스택 및 힙과 관련하여 설명되므로 준비에 대한 간단한 설명이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 블록 내의 메소드 시그니처 에서 참조는 구조체의 필드에있는 참조의 수명과 연관되거나 독립적 일 수 있습니다. 또한 수명 제거 규칙을 사용하면 메서드 서명에 수명 주석이 필요하지 않은 경우가 많습니다. Listing 10-25에서 정의한 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 라는 구조체를 사용하여 몇 가지 예를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">메소드 서명에는 다른 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입 한 후 저장하려는 값의 유형을 종종 유추 할 수 있으므로이 유형 주석을 수행 할 필요가 거의 없습니다. 초기 값을 갖는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 생성하는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 제공합니다 ! 편의상 매크로. 매크로는 사용자가 제공 한 값을 보유한 새 벡터를 생성합니다. Listing 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입하면 저장하려는 값의 유형을 추론 할 수 있으므로이 유형 주석을 거의 수행 할 필요가 없습니다. 초기 값이 있는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 만드는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 편의를 위해 매크로. 매크로는 사용자가 제공 한 값을 보유하는 새 벡터를 생성합니다. 목록 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 . 정수 유형은 3 장의 &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;데이터 유형&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기본 정수 유형이므로 &lt;code&gt;i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="translated">대부분의 경우 (모두는 아니지만) 하나의 표현 힌트 만 사용하면 충분합니다. 현재 아키텍처에 따라 표현 힌트를 &lt;code&gt;cfg_attr&lt;/code&gt; 려면 cfg_attr을 사용 하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">대부분의 경우 더 이상 특정 함수 매개 변수가 필요하지 않은 경우 서명을 변경하여 사용하지 않는 매개 변수가 포함되지 않도록합니다. 함수 매개 변수를 무시하면 특정 유형 서명이 필요하지만 구현의 함수 본문에 매개 변수 중 하나가 필요하지 않은 경우 특성을 구현할 때와 같이 일부 경우에 특히 유용 할 수 있습니다. 그러면 컴파일러는 이름을 대신 사용했을 때와 같이 사용하지 않는 함수 매개 변수에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="translated">대부분의 경우 잊혀진 가져 오기 또는 오타입니다. 그러나 이러한 유형을 가질 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">대부분의 경우 참조는 원래 값과 매우 유사하게 사용할 수 있습니다. 필드 액세스, 메소드 호출 및 인덱싱은 동일하게 작동합니다 (물론 변경 규칙 저장). 또한 비교 연산자는 참조의 구현을 투명하게 참조하여 참조 값을 소유 한 값과 동일하게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">대부분의 최신 운영 체제에서 실행 된 프로그램의 코드는 &lt;em&gt;프로세스&lt;/em&gt; 에서 실행되며 운영 체제는 여러 프로세스를 한 번에 관리합니다. 프로그램 내에서 동시에 실행되는 독립 부품을 가질 수도 있습니다. 이러한 독립 부품을 실행하는 기능을 &lt;em&gt;스레드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">대부분의 경우 컴파일되지 않은 올바른 코드 버전으로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">가변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">변경 가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">한 번의 컴파일 세션에서 컴파일러는 명령 행 플래그 또는 &lt;code&gt;crate_type&lt;/code&gt; 속성을 사용하여 여러 아티팩트를 생성 할 수 있습니다 . 하나 이상의 명령 행 플래그가 지정된 경우, 모든 &lt;code&gt;crate_type&lt;/code&gt; 속성은 명령 행으로 지정된 아티팩트 만 빌드하기 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">한 가지 방법으로이 프로그램이 더 좋습니다. 튜플을 사용하면 약간의 구조를 추가 할 수 있으며 이제는 하나의 인수 만 전달합니다. 그러나 다른 방식으로,이 버전은 덜 명확합니다. 튜플은 해당 요소의 이름을 지정하지 않으므로 튜플의 일부를 인덱싱해야하기 때문에 계산이 더 혼란스러워졌습니다.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">유형이이 특성을 구현하려면 모든 메소드에 대한 구현을 제공해야 할뿐만 아니라 유형 &lt;code&gt;E&lt;/code&gt; 를 지정해야합니다 . 표준 라이브러리 유형 &lt;code&gt;Vec&lt;/code&gt; 에 대한 &lt;code&gt;Container&lt;/code&gt; 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 작성 하려면 &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 생성하려면 &lt;a href=&quot;struct.openoptions#method.write&quot;&gt; &lt;code&gt;OpenOptions::write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.openoptions#method.append&quot;&gt; &lt;code&gt;OpenOptions::append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Rust의 전역 유형 유추가 없음을 일관성있게 유지하기 위해 항목 서명의 디자인으로 유형 및 const 자리 표시자가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="translated">요구 사항을 &lt;code&gt;'static&lt;/code&gt; 에서 인수에서 파생 된 수명 으로 변경하려면 익명 수명 &lt;code&gt;'_&lt;/code&gt; 또는 적절한 명명 된 수명에 명시 적 경계를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="translated">이러한 종류의 제약 조건을 인코딩하려면 &lt;code&gt;where&lt;/code&gt; 절과 새로운 유형 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제네릭 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 할 수있는 모든 인수를 취하기를 원한다는 것을 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 경계를 사용할 수 있습니다 . 예 : &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 로 변환 할 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일반 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 될 수있는 모든 인수를 취하도록 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 범위를 사용할 수 있습니다 . 예를 들어, &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 로 변환 될 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">이 오류를 해결하려면 사용중인 유형이 특성을 구현하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">이 오류를 해결하려면 &lt;code&gt;pub&lt;/code&gt; 키워드 를 사용하여 항목을 공개해야 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">컴파일 타임에 내장 함수를 사용하려면 https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs에서 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 로 구현을 복사해야합니다. /interpret/intrinsics.rs는 추가 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 극한한다.</target>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴을보다 인체 공학적으로 만들기 위해 &lt;a href=&quot;types/function-item&quot;&gt;함수 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;클로저 특성&lt;/a&gt; 서명 에서 수명 인수를 &lt;em&gt;생략&lt;/em&gt; 할 수 있습니다 . 다음 규칙은 생략 된 수명에 대한 수명 매개 변수를 유추하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; ' 도 동일한 방식으로 수명을 추정하는 데 사용할 수 있습니다. 경로의 수명 동안 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴이 더 인체 공학적으로 만들기 위해, 평생 인수 할 수있다 &lt;em&gt;생략&lt;/em&gt; 의 &lt;a href=&quot;types/function-item&quot;&gt;기능 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;폐쇄 형질&lt;/a&gt; 서명. 다음 규칙은 제거 된 수명에 대한 수명 매개 변수를 추론하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; 은 동일한 방식으로 수명을 추론하는 데 사용할 수도 있습니다. 경로의 수명의 경우 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="translated">C 표현 레이아웃 &lt;code&gt;repr(C)&lt;/code&gt; 를 일치 &lt;code&gt;pad_to_align&lt;/code&gt; 려면 레이아웃을 모든 필드로 확장 한 후 pad_to_align 을 호출해야 합니다. (지정되지 않았기 때문에 기본 Rust 표현 레이아웃 &lt;code&gt;repr(Rust)&lt;/code&gt; 와 일치하는 방법은 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">사용하기 쉽고 사용자에게 필요한 내용 만 노출하는 잘 구성된 API를 사용자에게 제공하기 위해 이제 Rust의 모듈을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">즉, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; 이다 &lt;em&gt;하지&lt;/em&gt; 같은 &lt;code&gt;y&lt;/code&gt; , 그것을하지 않는 정의되지 않은 동작 간접 참조 인 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 로 포인트 동일한 할당 된 개체.</target>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">다시 말해서, 모든 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 는&lt;/a&gt; 자신을 반환함으로써 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 이것은 두 가지를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">즉, 각 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;park&lt;/code&gt; 및 &lt;code&gt;unpark&lt;/code&gt; 를 사용하여 잠 그거나 잠금을 해제 할 수있는 스핀 락과 같은 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">다시 말해, 크기가 0 인 포인터가 할당 자에서 흘러 나올 수 있으면 할당자는 마찬가지로 해당 포인터가 할당 해제 및 재 할당 방법으로 다시 흐르는 포인터를 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">즉, 두 키가 같으면 해시도 같아야합니다. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 은&lt;/a&gt; 모두이 동작에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">즉, 두 키가 같으면 해시가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="translated">즉, 위의 예에서 &lt;code&gt;Drop::drop&lt;/code&gt; 을 명시 적으로 호출하려고 하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">즉, 두 반복기를 체인으로 연결합니다. 🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">즉, &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 레이어를 자동으로 제거합니다 . 매핑이 이미 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환하고 건너 뛰려는 경우&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 의 다음 &lt;code&gt;filter_map&lt;/code&gt; 사용에 훨씬 좋네요 훨씬이다.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">즉, 두 개의 이터레이터를 하나로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">즉, &lt;code&gt;f(c)&lt;/code&gt; 와 같은 모든 문자 &lt;code&gt;c&lt;/code&gt; 를 제거하십시오. 가 &lt;code&gt;false&lt;/code&gt; 를 반환 . 이 방법은 원래 순서대로 각 문자를 한 번만 방문하여 유지되며 유지되는 문자의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="translated">즉, 모든 요소가 제거 &lt;code&gt;e&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; . 요소는 정렬되지 않은 (및 지정되지 않은) 순서로 방문됩니다.</target>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; . 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거 하여 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; false를 돌려 준다. 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, 모든 쌍 제거 &lt;code&gt;(k, v)&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">즉, 결과는 &lt;code&gt;self / rhs&lt;/code&gt; 정수로 반올림 &lt;code&gt;n&lt;/code&gt; 되도록 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . 경우 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; 이 제로 (녹 기본값)쪽으로 둥근 같다; 만약 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; 이 무한대를 향하여 +/- 라운드 같다.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">다시 말해 여기에는 두 가지 중요한 시점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">다시 말해, Rust에게 &lt;code&gt;search&lt;/code&gt; 함수에 의해 반환 된 데이터 는 &lt;code&gt;contents&lt;/code&gt; 인수 에서 &lt;code&gt;search&lt;/code&gt; 함수에 전달 된 데이터가 존재하는 한 지속될 것이라고 Rust에 알려줍니다 . 이건 중요하다! 슬라이스가 참조 &lt;em&gt;하는&lt;/em&gt; 데이터 는 참조가 유효해야합니다. 컴파일러는 우리의 문자열 조각을 만들고 있어요 가정하면 &lt;code&gt;query&lt;/code&gt; 보다는 &lt;code&gt;contents&lt;/code&gt; &lt;em&gt;&lt;/em&gt; 안전성 검사가 잘못 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">즉, &lt;code&gt;match&lt;/code&gt; 하는 구문 설탕으로 생각 &lt;code&gt;if let&lt;/code&gt; 값이 하나의 패턴과 일치하는 실행 코드와 다른 모든 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">즉, 당신은 변환해야 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; A와 &lt;code&gt;T&lt;/code&gt; 수행하기 전에 &lt;code&gt;T&lt;/code&gt; 의 그것으로 작업을. 일반적으로 이것은 null과 관련하여 가장 일반적인 문제 중 하나를 포착하는 데 도움이됩니다. 실제로는 무언가가 null이 아니라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">다시 말해서 : t &amp;isin; FOLLOW (M) 토큰 시퀀스가 ​​존재하는 경우에만 (잠재적으로 비어 있음) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; 여기서 :</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">그러나 잘못된 예에서는 단일 콘크리트 유형을 참조하고 있습니다. 우리는 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현 한다는 것을 알고 있기 때문에 &lt;code&gt;where&lt;/code&gt; 절 에도이를 지정할 이유가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; 및 &lt;code&gt;Hash&lt;/code&gt; 는 차용 및 소유 값과 동일해야합니다. &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; 는 &lt;code&gt;x == y&lt;/code&gt; 와 동일한 결과를 제공해야합니다. .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="translated">특히, 함수 포인터에 &lt;code&gt;#[track_caller]&lt;/code&gt; 를 사용하여 함수를 강제하면 관찰자가 속성 함수의 정의 사이트에서 호출 된 것처럼 보이는 shim이 생성되어 가상 호출에서 실제 호출자 정보가 손실됩니다. 이 강제의 일반적인 예는 메서드가 속성을 갖는 특성 개체의 생성입니다.</target>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">특히, 하나의 소정의 할당을 통해 할당 된 메모리 블록이 있는지 레이아웃 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;a.usable_size(k)&lt;/code&gt; 를 반환 &lt;code&gt;(l, u)&lt;/code&gt; 다음 하나의 해당 블록을 전달할 수 &lt;code&gt;a.dealloc()&lt;/code&gt; 크기에 레이아웃을 범위 [l, u]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="translated">특히, 이전 코드 예제에서와 같이 레지스터 제약 조건의 닫는 대괄호를 잊은 경우 (문제 # 51430 참조) 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">특히 레지스터 제약 조건의 닫는 괄호를 잊어 버린 경우 발생할 수 있습니다 (문제 # 51430 참조).</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">특히, 원시 항목을 초기화하는 데 사용 된 해시는 여전히 항목에 저장된 키의 해시와 일치해야합니다. 크기를 조정할 때 HashMap 구현에서 키만 사용 가능한 해시를 다시 계산해야 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">특히 결과 포인터는 &lt;code&gt;self&lt;/code&gt; 가 가리키는 동일한 할당 된 개체에 연결된 상태로 유지 됩니다. 다른 할당 된 개체에 액세스하는 데 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; . Rust에서 모든 (스택 할당) 변수는 별도의 할당 된 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">특히, 리턴 값 &lt;code&gt;r&lt;/code&gt; 은 대부분의 경우 &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; 를 충족시킵니다 . 그러나, 부동 소수점에 의한 반올림 에러는 발생할 수있다 &lt;code&gt;r == rhs.abs()&lt;/code&gt; 경우 수학적 정의를 위반 &lt;code&gt;self&lt;/code&gt; 보다 훨씬 작다 &lt;code&gt;rhs.abs()&lt;/code&gt; 크기와의 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . 이 결과는 함수의 공동 도메인 요소가 아니지만 실수에서 가장 가까운 부동 소수점 수이므로 &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 속성을 대략적으로 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="translated">특히이 반복기가 구성되는 내부 부분에 대해 &lt;code&gt;fold()&lt;/code&gt; 호출을 시도 하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">특히, 이 반복자가 구성된 내부 부분에서 &lt;code&gt;try_fold()&lt;/code&gt; 호출을 시도 하십시오. 여러 번의 통화가 필요한 경우 &lt;code&gt;?&lt;/code&gt; 연산자는 누산기 값을 연결하는 데 편리하지만 초기 반품 전에 유지해야하는 불변량을주의하십시오. 이것은 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 메소드이므로 오류가 발생한 후 반복을 재개 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">드문 경우이지만 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 대신 패닉이 발생하는 코드를 작성하는 것이 더 적절합니다 . 예제, 프로토 타입 코드 및 테스트에서 패닉이 적절한 이유를 살펴 보겠습니다. 그런 다음 컴파일러가 실패가 불가능하다고 말할 수는 없지만 사람이 할 수있는 상황에 대해 논의합니다. 이 장은 라이브러리 코드에서 패닉 상태를 결정하는 방법에 대한 일반적인 지침으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">간단히 말해 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 모든 유형일 수 있음)는 다른 유형이므로 컴파일러는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값을 마치 유효한 값인 것처럼 사용할 수 없게 합니다. 예를 들어,이 코드는 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; &lt;code&gt;i8&lt;/code&gt; 을 추가하려고하기 때문에 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">단일 스레드 시나리오에서는 신호 처리기 또는 특정 종류의 저수준 코드를 작성할 때 문제가 발생할 수 있습니다. 이 순서를 방지 하려면 &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;컴파일러 펜스&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">일부 언어에서는 프로그래머가 스마트 포인터 인스턴스 사용을 마칠 때마다 메모리 나 리소스를 비우려면 코드를 호출해야합니다. 잊어 버린 경우 시스템이 과부하되어 충돌 할 수 있습니다. Rust에서는 값이 범위를 벗어날 때마다 특정 코드 비트가 실행되도록 지정할 수 있으며 컴파일러는이 코드를 자동으로 삽입합니다. 결과적으로 특정 유형의 인스턴스가 완료된 프로그램의 어느 곳에 나 정리 코드를 배치 할 때주의 할 필요가 없습니다. 여전히 리소스가 누출되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="translated">일부 프로그래밍 언어에서 문자열 형식화 함수의 동작은 운영 체제의 로케일 설정에 따라 다릅니다. Rust의 표준 라이브러리에서 제공하는 형식 함수는 로케일 개념이 없으며 사용자 구성에 관계없이 모든 시스템에서 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 유형 조합이 모호 할 수 있습니다. 모호성을 피하기 위해 유형 주위에 괄호를 사용하십시오. 예를 들어, &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;참조 유형&lt;/a&gt; 내의 &lt;a href=&quot;trait-bounds&quot;&gt;유형 경계에&lt;/a&gt; 대한 &lt;code&gt;+&lt;/code&gt; 연산자 는 경계가 적용되는 위치가 확실하지 않으므로 괄호를 사용해야합니다. 이 명확성을 요구하는 문법 규칙 은 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; 대신 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; 규칙을 사용합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">경우에 따라 유효한 부동 소수점을 만들어야하는 일부 문자열은 대신 오류를 반환합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;이슈 # 31407&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;let x = 5;&lt;/code&gt; 와 같은 문장에서 ; 의 변수 이름 &lt;code&gt;PATTERN&lt;/code&gt; 의 슬롯 변수 이름은 패턴의 특히 단순한 형태이다. Rust는 표현식을 패턴과 비교하고 찾은 이름을 지정합니다. 따라서 &lt;code&gt;let x = 5;&lt;/code&gt; 예를 들어, &lt;code&gt;x&lt;/code&gt; 는 &quot;여기에 일치하는 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미하는 패턴입니다 . &lt;code&gt;x&lt;/code&gt; 라는 이름 은 전체 패턴이므로이 패턴은 &quot; 값에 관계없이 모든 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">이 경우 컴파일러는 다음과 같은 상황에서 &lt;code&gt;foo()&lt;/code&gt; 의 반환 유형을 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">요약하면 코드를 Listing 10-2에서 Listing 10-3으로 변경하기 위해 취한 단계는 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">면에서는 &lt;a href=&quot;../sync/atomic/index&quot;&gt;원자 메모리 순서화&lt;/a&gt; , 연관된 스레드의 완성이 함수 리턴과 동기화한다. 즉, 해당 스레드가 수행하는 모든 작업은 &lt;code&gt;join&lt;/code&gt; 반환 된 후 발생하는 모든 작업보다 먼저 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="translated">특성에 필요하지 않은 2015 년 판 매개 변수 패턴 :</target>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">2015 년판에서 &lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt; 은 유형 위치에 사용될 때 키워드이며 &lt;code&gt;::&lt;/code&gt; 로 시작하지 않는 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">2015 년판에서 특성 함수 또는 메소드 매개 변수의 패턴은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">2018 년 판에서, 범위 내 아이템이 외부 상자와 이름이 같은 &lt;code&gt;use&lt;/code&gt; , 해당 상자 이름 을 사용 하려면 &lt;code&gt;::&lt;/code&gt; 를 사용하여 상자 이름을 명확하게 선택해야합니다. 이는 잠재적 인 향후 변경 사항과의 호환성을 유지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;유니 코드 표준&lt;/a&gt; , 제 4 장 (문자 속성) 일반적으로 케이스 매핑에 대해 설명하고 3 장 (준수)의 경우 변환을위한 기본 알고리즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">에서 &lt;a href=&quot;index&quot;&gt;모듈 수준의 문서&lt;/a&gt; , 우리는 구현 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . &lt;code&gt;ExactSizeIterator&lt;/code&gt; 도 구현해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">Listing 5-1 의 &lt;code&gt;User&lt;/code&gt; 구조체 정의에서 &lt;code&gt;&amp;amp;str&lt;/code&gt; 문자열 슬라이스 타입 대신 소유 한 &lt;code&gt;String&lt;/code&gt; 타입을 사용했다 . 이 구조체의 인스턴스가 모든 데이터를 소유하고 전체 구조체가 유효한 한 해당 데이터가 유효하기를 원하기 때문에 이것은 신중한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">에서 &lt;code&gt;handle_connection&lt;/code&gt; 의 기능, 우리는했습니다 &lt;code&gt;stream&lt;/code&gt; 변경 가능한 매개 변수입니다. 그 이유는 &lt;code&gt;TcpStream&lt;/code&gt; 인스턴스가 어떤 데이터를 내부적으로 반환했는지 추적하기 때문입니다. 요청한 것보다 많은 데이터를 읽고 다음에 데이터를 요청할 때 해당 데이터를 저장할 수 있습니다. 따라서 내부 상태가 변경 될 수 있으므로 &lt;code&gt;mut&lt;/code&gt; 해야합니다 . 일반적으로&amp;ldquo;읽기&amp;rdquo;는 돌연변이가 필요없는 것으로 생각하지만이 경우에는 &lt;code&gt;mut&lt;/code&gt; 키워드 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 시맨틱 버전 지정자 &lt;code&gt;0.3.14&lt;/code&gt; 로 &lt;code&gt;rand&lt;/code&gt; 상자를 지정합니다 . Cargo 는 버전 번호 작성 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전 관리&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )를 이해 합니다. 숫자 &lt;code&gt;0.3.14&lt;/code&gt; 는 실제로 &lt;code&gt;^0.3.14&lt;/code&gt; 약자입니다 . &quot;0.3.14 버전과 호환되는 공개 API가있는 모든 버전&quot;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 의미 론적 버전 지정자 &lt;code&gt;0.5.5&lt;/code&gt; 를 사용하여 &lt;code&gt;rand&lt;/code&gt; crate를 지정합니다 . Cargo 는 버전 번호 작성을위한 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )을 이해 합니다. 숫자 &lt;code&gt;0.5.5&lt;/code&gt; 는 실제로 &lt;code&gt;^0.5.5&lt;/code&gt; 약칭 이며 , 이는 '버전 0.5.5와 호환되는 공개 API가있는 모든 버전'을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">에 &lt;em&gt;추가 한 / SRC / lib.rs의&lt;/em&gt; 파일의는 추가 할 수 &lt;code&gt;add_one&lt;/code&gt; 의 기능 :</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">위의 예 에서 컴파일러는 &lt;code&gt;T&lt;/code&gt; 를 알 수 없습니다. 이 문제를 해결하려면 생성기를 구성 할 수 있도록 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;String&lt;/code&gt; 과 같은 콘크리트 유형에 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">절대 경로에서 우리는 상자의 모듈 트리의 루트 인 &lt;code&gt;crate&lt;/code&gt; 로 시작 합니다. 그런 다음 &lt;code&gt;front_of_house&lt;/code&gt; 모듈은 크레이트 루트에 정의됩니다. &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈 공개 아니지만 때문에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 함수와 같은 모듈에 정의 &lt;code&gt;front_of_house&lt;/code&gt; (이라고 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 와 &lt;code&gt;front_of_house&lt;/code&gt; 형제이다), 우리는 참조 할 수 &lt;code&gt;front_of_house&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; . 다음은 &lt;code&gt;pub&lt;/code&gt; 으로 표시된 &lt;code&gt;hosting&lt;/code&gt; 모듈 입니다. &lt;code&gt;hosting&lt;/code&gt; 의 상위 모듈에 액세스 할 수 있으므로 액세스 할 수 있습니다 . 마지막으로 &lt;code&gt;hosting&lt;/code&gt; &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수는 &lt;code&gt;pub&lt;/code&gt; 으로 표시되며 부모 모듈에 액세스 할 수 있으므로이 함수 호출이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 본문 에서보다 큼 ( &lt;code&gt;&amp;gt;&lt;/code&gt; ) 연산자를 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 두 값을 비교하려고했습니다 . 이 연산자는 표준 라이브러리 특성 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 에서 기본 메소드로 정의 되므로 &lt;code&gt;T&lt;/code&gt; 의 특성 경계에 &lt;code&gt;PartialOrd&lt;/code&gt; 를 지정해야 &lt;code&gt;largest&lt;/code&gt; 함수가 비교할 수있는 모든 유형의 슬라이스에서 작동 할 수 있습니다. &lt;code&gt;PartialOrd&lt;/code&gt; 가 서곡에 포함되어 있으므로 범위 내로 가져올 필요가 없습니다 . &lt;code&gt;largest&lt;/code&gt; 서명 을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">본문에 &lt;code&gt;shoes_in_my_size&lt;/code&gt; , 우리는 전화 &lt;code&gt;into_iter&lt;/code&gt; 벡터의 소유권을 반복자를 만들 수 있습니다. 그런 다음 &lt;code&gt;filter&lt;/code&gt; 를 호출 하여 해당 반복자를 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 요소 만 포함하는 새 반복기에 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">일반 함수의 본문에서 &lt;code&gt;Trait&lt;/code&gt; 의 메소드는 &lt;code&gt;Ty&lt;/code&gt; 값에서 호출 될 수 있습니다 . 마찬가지로 &lt;code&gt;Trait&lt;/code&gt; 의 관련 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 에 연관된 &lt;code&gt;break&lt;/code&gt; 가있는 경우 분기되는 것으로 간주되지 않으며 &lt;code&gt;loop&lt;/code&gt; 는 각 &lt;code&gt;break&lt;/code&gt; 표현식 과 호환되는 유형이어야합니다 . &lt;code&gt;break&lt;/code&gt; 발현없이가 동일 간주 &lt;code&gt;break&lt;/code&gt; 식 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 의 경우 블록과 표현식의 범위는 동일한 범위입니다.</target>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">문자열 리터럴의 경우 컴파일 타임에 내용을 알고 있으므로 텍스트는 최종 실행 파일에 직접 하드 코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 그러나 이러한 속성은 문자열 리터럴의 불변성에서만 발생합니다. 불행히도 컴파일 타임에 크기를 알 수없고 프로그램을 실행하는 동안 크기가 변할 수있는 각 텍스트 조각에 대해 바이너리 메모리에 메모리를 넣을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">내재적으로 랩핑 된 오버 플로우의 경우, 구현은 2의 보수 오버 플로우 규칙을 사용하여 잘 정의 된 (아직 잘못된 것으로 간주 되더라도) 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">경우 &lt;code&gt;File::open&lt;/code&gt; 성공의 변수의 값 &lt;code&gt;f&lt;/code&gt; 의 인스턴스가 될 것입니다 &lt;code&gt;Ok&lt;/code&gt; 파일 핸들이 포함되어 있습니다. 실패한 경우 &lt;code&gt;f&lt;/code&gt; 의 값 은 발생한 오류 종류에 대한 자세한 정보가 포함 된 &lt;code&gt;Err&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">위의 코드에서 함수는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 에서 빌린 데이터를 반환 하지만 &lt;code&gt;'a&lt;/code&gt; 주석은 &lt;code&gt;x&lt;/code&gt; 에서만 데이터를 반환한다는 것을 나타냅니다 . 오류를 해결하려면 서명과 본문이 일치해야합니다. 일반적으로 이것은 기능 서명을 업데이트하여 수행됩니다. 따라서이 경우에는 다음과 같이 &lt;code&gt;y&lt;/code&gt; 유형 을 &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">목록 9-7과 관련하여 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;File::open&lt;/code&gt; 호출 의 끝 에서 &lt;code&gt;Ok&lt;/code&gt; 안의 값 을 변수 &lt;code&gt;f&lt;/code&gt; 로 반환합니다 . 오류가 발생하면 &lt;code&gt;?&lt;/code&gt; 연산자는 전체 함수에서 일찍 반환 하고 호출 코드에 &lt;code&gt;Err&lt;/code&gt; 값을 제공합니다 . 같은 것이 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 호출 끝에 .</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결국, 이것은 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt; 유형, 일반적으로 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 쌍으로 묶어야 할 수도 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">위의 잘못된 코드 예제에서 잘못된 이름이 제공되었으므로 올바른 이름으로 변경하면 오류가 해결됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">위의 예에서 &lt;code&gt;closure&lt;/code&gt; 는 &lt;code&gt;FnOnce&lt;/code&gt; 클로저 인 반면 &lt;code&gt;bar&lt;/code&gt; 함수는 &lt;code&gt;Fn&lt;/code&gt; 클로저를 예상했습니다 . 이 경우 문제를 해결하는 것이 간단합니다 &lt;code&gt;struct X&lt;/code&gt; 에서 &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Clone&lt;/code&gt; 특성 을 구현 하면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;Point&lt;/code&gt; 유형을 구현합니다 . 두 개의 정수만 저장하기 때문에 우리는 &lt;code&gt;Copy&lt;/code&gt; 의 소유권 의미를 옵트 아웃 합니다. 그런 다음 &lt;code&gt;p1&lt;/code&gt; 을 이동 하지 않고 &lt;code&gt;let p2 = p1&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">이 예제에서 유형은 크기를 잘 정의 할 수 없습니다. 왜냐하면 임의적으로 커야하기 때문입니다 ( &lt;code&gt;ListNode&lt;/code&gt; 를 모든 깊이 에 중첩 할 수 있기 때문입니다 ). 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우, 출력 수명은 고유 한 입력 수명과 동일한 것으로 추론됩니다. 두 번째 경우, 수명은 &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 의 수명과 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">첫 번째 코드 예제에서 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형이 무엇인지 추론 할 수 없습니다 . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 은 모두 적합한 후보입니다. 사용할 유형을 지정하려면 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (마지막 문자는 급성 악센트 &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;조합 문자&lt;/a&gt; ). 문자열의 다른 문자와 달리 결합 문자는 대문자 변형으로 매핑되지 않으므로 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; 합니다. 두 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (마지막 문자는 'e'를 강조하는 단일 유니 코드 문자입니다). 마지막 문자는 ASCII 범위 밖에서 정의되므로 대문자 변형에 매핑되지 않으므로 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">첫 번째 일치 표현식에서 값이 복사 (또는 이동)됩니다. 두 번째 일치에서는 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 하위 패턴을 파괴 할 때 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자를 값 필드에 적용 할 수 없으므로이 구문이 필요 합니다. 예를 들어 다음은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;call_from_c&lt;/code&gt; 함수를 공유 라이브러리로 컴파일하고 C에서 링크 한 후 C 코드에서 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;outline_print&lt;/code&gt; 의 구현 에서 &lt;code&gt;Display&lt;/code&gt; 특성의 기능 을 사용하려고 합니다. 따라서 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성이 &lt;code&gt;Display&lt;/code&gt; 를 구현 하고 &lt;code&gt;OutlinePrint&lt;/code&gt; 에 필요한 기능을 제공하는 유형에 대해서만 작동 하도록 지정 해야합니다. 특성 정의에서 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 를 지정하여 이를 수행 할 수 있습니다 . 이 기법은 특성에 바인딩 된 특성을 추가하는 것과 유사합니다. Listing 19-22는 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성 의 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">범위없이 변수를 지정한 마지막 팔에서 팔의 코드에서 &lt;code&gt;id&lt;/code&gt; 라는 변수에 사용할 수있는 값이 있습니다 . 그 이유는 구조체 필드 속기 구문을 사용했기 때문입니다. 그러나 처음 두 팔과 마찬가지로이 팔 의 &lt;code&gt;id&lt;/code&gt; 필드 값에 대한 테스트를 적용하지 않았습니다 . 모든 값이이 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">메인 스레드에서 모든 조인 핸들을 수집합니다. 그런 다음 Listing 16-2에서와 같이 각 핸들에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 모든 스레드가 완료되도록합니다. 이 시점에서 메인 스레드는 잠금을 획득하고이 프로그램의 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">메인 스레드에서는 더 이상 &lt;code&gt;recv&lt;/code&gt; 함수를 명시 적으로 호출하지 않습니다. 대신 &lt;code&gt;rx&lt;/code&gt; 를 반복자로 취급 합니다. 받은 각 값에 대해 인쇄하고 있습니다. 채널이 닫히면 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">대부분의 경우 소유권은 분명합니다. 주어진 값을 소유 한 변수를 정확히 알고 있습니다. 그러나 단일 값에 여러 소유자가있을 수 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 모서리는 동일한 노드를 가리키고 해당 노드는 해당 노드를 가리키는 모든 모서리가 개념적으로 소유합니다. 가장자리를 가리 키지 않는 한 노드를 정리해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">이 코드의 일치 표현식에서 다음과 같은 변수를 추가합니다 &lt;code&gt;state&lt;/code&gt; 변형 &lt;code&gt;Coin::Quarter&lt;/code&gt; 값과 일치하는 패턴에 . 때 &lt;code&gt;Coin::Quarter&lt;/code&gt; 경기는 &lt;code&gt;state&lt;/code&gt; 변수는 해당 분기의 상태의 값에 바인딩됩니다. 그런 다음 해당 팔의 코드에서 &lt;code&gt;state&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">매처에서 &lt;code&gt;$&lt;/code&gt; &lt;em&gt; name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt; 는 지정된 종류의 Rust 구문 조각과 일치하여 메타 변수 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name에&lt;/em&gt; 바인딩합니다 . 유효한 조각 지정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">다음 장에서는 깔끔하게 정리 된 코드에서 사용할 수있는 표준 라이브러리의 컬렉션 데이터 구조를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서, 역 추적의 12 번째 줄은 프로젝트에서 &lt;em&gt;src / main.rs의&lt;/em&gt; 4 번째 줄을 &lt;em&gt;가리킨다&lt;/em&gt; . 프로그램이 패닉 상태에 빠지지 않게하려면 첫 번째 줄이 가리키는 파일이 언급 된 위치는 조사를 시작해야하는 위치입니다. 역 추적을 사용하는 방법을 보여주기 위해 공황에 빠질 코드를 작성했던 Listing 9-1에서 공황을 수정하는 방법은 3 개의 항목 만 포함하는 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 미래에 코드 패닉이 발생하면 패닉을 유발하는 값으로 코드가 수행하는 작업과 대신 코드가 수행해야 할 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서 ​​역 추적의 17 행은 문제를 일으키는 프로젝트의 라인 ( &lt;em&gt;src / main.rs의&lt;/em&gt; 4 행)을 &lt;em&gt;가리 킵니다&lt;/em&gt; . 프로그램이 당황하지 않도록하려면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치를 조사를 시작해야합니다. 역 추적을 사용하는 방법을 보여주기 위해 의도적으로 패닉되는 코드를 작성한 목록 9-1에서 패닉을 수정하는 방법은 3 개 항목 만 포함 된 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 나중에 코드가 패닉 상태가되면 코드가 어떤 값을 사용하여 패닉을 유발하고 코드가 대신 수행해야하는 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;IpAddr&lt;/code&gt; 열거 형을 사용하여 Rust의 유형 시스템을 사용하여 데이터를 프로그램에 더 많은 정보로 인코딩 . 이 섹션에서는 표준 라이브러리에 의해 정의 된 또 다른 열거 형인 &lt;code&gt;Option&lt;/code&gt; 에 대한 사례 연구를 살펴 봅니다. &lt;code&gt;Option&lt;/code&gt; 은 값이 뭔가 할 수있는 매우 일반적인 시나리오를 암호화하거나 아무 것도 없을 수 있기 때문에 유형은 여러 곳에서 사용된다. 타입 시스템 측면에서이 개념을 표현한다는 것은 컴파일러가 처리해야 할 모든 경우를 처리했는지 여부를 확인할 수 있다는 의미입니다. 이 기능은 다른 프로그래밍 언어에서 매우 일반적인 버그를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 사용할 때 &lt;code&gt;Some&lt;/code&gt; 경우 에서 내부 &lt;code&gt;T&lt;/code&gt; 값 을 가져오고 싶었습니다 . &lt;code&gt;Coin&lt;/code&gt; 했던 것처럼 &lt;code&gt;match&lt;/code&gt; 를 사용하여 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 를 처리 할 수도 있습니다 열거 형에서 ! 코인을 비교하는 대신 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 의 변형을 비교 하지만 &lt;code&gt;match&lt;/code&gt; 표현식의 작동 방식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">상대 경로에서 논리는 첫 번째 단계를 제외하고 절대 경로와 동일합니다. 상자 루트에서 시작하지 않고 경로는 &lt;code&gt;front_of_house&lt;/code&gt; 에서 시작합니다 . &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈과 같은 모듈 내에 정의 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 상대 경로가되는 모듈에서 시작되도록 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 작동 정의된다. 그런 다음 &lt;code&gt;hosting&lt;/code&gt; 하고 &lt;code&gt;add_to_waitlist&lt;/code&gt; 가 &lt;code&gt;pub&lt;/code&gt; 로 표시 되므로 나머지 경로가 작동 하며이 함수 호출이 유효합니다!</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">식당 산업에서 식당의 일부는 &lt;em&gt; 는 집 앞&lt;/em&gt; , 다른 곳 &lt;em&gt;은 집 뒤라고&lt;/em&gt; 합니다. 집 앞은 고객이있는 곳입니다. 이곳은 주최자가 고객을 앉히고, 서버가 주문과 지불을하고, 바텐더가 음료를 만드는 곳입니다. 집 뒤는 요리사와 요리사가 주방에서 일하고 식기 세척기를 청소하며 관리자가 관리 작업을 수행하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">두 번째에서 &lt;code&gt;use&lt;/code&gt; 문, 우리는 새로운 이름을 선택 &lt;code&gt;IoResult&lt;/code&gt; 에 대한 &lt;code&gt;std::io::Result&lt;/code&gt; 에 입력하는하지 않습니다 충돌 &lt;code&gt;Result&lt;/code&gt; 은 &lt;code&gt;std::fmt&lt;/code&gt; . 리스팅 7-15와 리스팅 7-16은 관용으로 간주되므로 선택은 귀하에게 달려 있습니다!</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">패턴에 지정된 범위 만있는 두 번째 팔에서 팔과 관련된 코드에는 &lt;code&gt;id&lt;/code&gt; 필드 의 실제 값을 포함하는 변수가 없습니다 . &lt;code&gt;id&lt;/code&gt; 필드의 값은 10, 11, 또는 12 수 있었다,하지만 패턴으로가는 코드는 어떤 알 수 없습니다. 변수에 &lt;code&gt;id&lt;/code&gt; 값을 저장하지 않았기 때문에 패턴 코드는 &lt;code&gt;id&lt;/code&gt; 필드 의 값을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">두 번째 경우, 현재 모듈과 그 하위 항목에 의해 개인 항목에 액세스 할 수 있다고 언급하지만 항목에 액세스하는 정확한 의미는 항목이 무엇인지에 따라 다릅니다. 예를 들어 모듈에 액세스하면 더 많은 항목을 가져 오기 위해 내부를 살펴볼 수 있습니다. 반면에 함수에 액세스하면 함수가 호출됩니다. 또한 경로 표현식 및 가져 오기 명령문은 대상이 현재 가시성 범위에있는 경우에만 가져 오기 / 표현이 유효하다는 의미에서 항목에 액세스하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="translated">두 번째 오류에서는 &lt;code&gt;Jak&lt;/code&gt; 열거 형을 직접 바인딩하려고했지만 불가능합니다. 변형 중 하나만 바인딩 할 수 있습니다. 그렇게하려면 :</target>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="translated">두 번째 오류에서는 항목에 무언가를 구현할 수없고 유형에만 구현할 수 있습니다. 비슷한 작업을하려면 새 유형을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">두 번째에서는 단순히 &lt;code&gt;'b&lt;/code&gt; 를 제거하여 둘 다 'a &lt;code&gt;'a&lt;/code&gt; 사용하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 의 서명에서 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 사용합니다 . Rust는 이 메소드가 &lt;code&gt;impl Rectangle&lt;/code&gt; 컨텍스트 안에 있기 때문에 &lt;code&gt;self&lt;/code&gt; 의 유형 이 &lt;code&gt;Rectangle&lt;/code&gt; 임을 알고 있기 때문에 &amp;amp; Rectangle 입니다. &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 에서 와 마찬가지로 여전히 &lt;code&gt;self&lt;/code&gt; 앞에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용해야합니다 . 방법의 소유권이 걸릴 수 있습니다 &lt;code&gt;self&lt;/code&gt; 빌려 &lt;code&gt;self&lt;/code&gt; 우리가 여기했던대로 변함 또는 차용 &lt;code&gt;self&lt;/code&gt; 단지 그들이 다른 매개 변수를 가능한 한, mutably.</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형은 일반적으로 구조적 고정이 없으므로 고정 투영을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 사실, 심지어 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 항상 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 같은 이유로, 자신 : 그 내용합니다 ( &lt;code&gt;T&lt;/code&gt; )가 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 콘텐츠가 고정되어 있는지 여부를 피닝하는 의미이고, 포인터가 고정되어 있는지 여부를 완전히 무관 &lt;em&gt;하지&lt;/em&gt; 구조체.</target>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형에는 일반적으로 구조적 고정이 없으므로 고정 돌출을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 실제로 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 조차도 같은 이유로 항상 &lt;code&gt;Unpin&lt;/code&gt; . 내용 ( &lt;code&gt;T&lt;/code&gt; )은 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내용이 고정되어 있는지 여부를 나타내는 Box &amp;lt;T&amp;gt; 및 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 포인터가 고정되어 있는지 여부와 완전히 독립적이므로 고정이 구조적 &lt;em&gt;이지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;LimitTracker&lt;/code&gt; 가 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;max&lt;/code&gt; 값 의 75 % 이상 으로 설정하라는 메시지 가 표시 될 때 발생하는 상황을 테스트하고 있습니다. 먼저 비어있는 메시지 목록으로 시작 하는 새로운 &lt;code&gt;MockMessenger&lt;/code&gt; 를 만듭니다 . 그리고 우리는 새로운 만들 &lt;code&gt;LimitTracker&lt;/code&gt; 을 하고 그것에게 새에 대한 참조를 제공 &lt;code&gt;MockMessenger&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 우리는 전화 (100)의 값 &lt;code&gt;set_value&lt;/code&gt; 온 방법 &lt;code&gt;LimitTracker&lt;/code&gt; 을 (100)의 75 % 이상이 우리가 주장 그리고 80의 값과를 메시지 목록 &lt;code&gt;MockMessenger&lt;/code&gt; 가 추적 가 하나 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="translated">세 번째 경우 에는 불가능한 &lt;code&gt;Wizard&lt;/code&gt; 열거 형 의 한 가지 변형 만 예상하려고했습니다 . 이 작업을 수행하려면 &lt;code&gt;Wizard&lt;/code&gt; 열거 형에 대해 패턴 일치를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">전 사기에서 metavariables는 조각 종류가 matcher에 지정되어 있으므로 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 간단히 참조됩니다 . 메타 변수는 일치하는 구문 요소로 대체됩니다. 키워드 메타 변수 &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . Metavariables는 두 번 이상 복사되거나 전혀 복사되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">transcriber에서 metavariables는 조각 유형이 매처에 지정되어 있기 때문에 간단히 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 참조됩니다 . 메타 변수는 해당 구문 요소로 대체됩니다. 키워드 metavariable &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . 메타 변수는 두 번 이상 또는 전혀 기록되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">운동 생성기 예제에서는 클로저를 인라인 익명 함수로 사용했습니다. 그러나 클로저에는 기능에없는 추가 기능이 있습니다. 즉, 환경을 캡처하고 정의 된 범위에서 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">최악의 경우, 알고리즘 은 슬라이스의 길이를 &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; 임시 스토리지를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">이 부록에서는 표준 라이브러리에서 &lt;code&gt;derive&lt;/code&gt; 하여 사용할 수있는 모든 특성에 대한 참조를 제공합니다. . 각 섹션은 다음을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">이 부록에서는 Rust 프로젝트가 제공하는 유용한 개발 도구에 대해 설명합니다. 자동 서식, 경고 수정을 적용하는 빠른 방법, 린터 및 IDE와의 통합에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">이 경우 &lt;code&gt;Foo&lt;/code&gt; 는 정의되지 않았으므로 본질적으로 아무것도 아니며 구조체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">이 경우, &lt;code&gt;Question&lt;/code&gt; 은 &lt;code&gt;std::ops::Not&lt;/code&gt; 특성 을 구현해야 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 그 위에. 그것을 구현하자 :</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="translated">이 경우, &lt;code&gt;c_double&lt;/code&gt; 는 같은 크기가 &lt;code&gt;f64&lt;/code&gt; 우리가 직접 사용할 수 있도록를 :</target>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">이 경우 &lt;code&gt;foo&lt;/code&gt; 가 정의되었지만 구조체가 아니므로 Rust에서이를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">이 경우 &lt;code&gt;len&lt;/code&gt; 은 4가되며 문자열 &quot;Hola&quot;를 저장하는 벡터의 길이는 4 바이트입니다. 이러한 문자는 UTF-8로 인코딩 될 때 1 바이트를 사용합니다. 그러나 다음 줄은 어떻습니까? (이 문자열은 아라비아 숫자 3이 아닌 대문자 키릴 문자 Ze로 시작합니다.)</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">이 경우, 대출 &lt;code&gt;x&lt;/code&gt; 때문 mutably 것은 불가능 &lt;code&gt;x&lt;/code&gt; 가 아니다 &lt;code&gt;mut&lt;/code&gt; . 그러나 동시에 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 참조가 고유하지 않을 수 있으므로 x를 불변으로 하면 할당이 불법이 될 수 있으므로 값을 안전하게 수정하는 데 사용할 수 없습니다. 따라서 고유의 불변의 차용이 사용됩니다. &lt;code&gt;x&lt;/code&gt; 를 불변으로 차용 하지만 변경 가능한 차용과 마찬가지로 고유해야합니다. 위의 예에서, &lt;code&gt;y&lt;/code&gt; 의 선언을 주석 해제하면 &lt;code&gt;x&lt;/code&gt; 의 클로저 빌림 고유성을 위반하기 때문에 오류가 발생합니다 . z의 선언은 블록의 끝에서 클로저의 수명이 만료되어 빌려주기 때문에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">이 경우 참조 사이클을 생성 한 직후 프로그램이 종료됩니다. 이주기의 결과는 그리 심각하지 않습니다. 그러나보다 복잡한 프로그램이주기에 많은 양의 메모리를 할당하고 오랫동안 보유한 경우 프로그램은 필요한 것보다 많은 메모리를 사용하고 시스템을 압도하여 사용 가능한 메모리가 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">이 경우 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형을 유추 할 수 없습니다. . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 이 모두 적합한 후보입니다. 사용할 유형을 지정하기 위해 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">이 경우 표시된 행은 코드의 일부이며 해당 행으로 이동하면 &lt;code&gt;panic!&lt;/code&gt; 이 발생합니다. 매크로 호출. 다른 경우에, &lt;code&gt;panic!&lt;/code&gt; call은 코드에서 호출하는 코드에있을 수 있으며 오류 메시지에 의해보고 된 파일 이름과 줄 번호는 &lt;code&gt;panic!&lt;/code&gt; 발생하는 다른 사람의 코드입니다 ! 매크로는 코드의 라인이 아니라 결국 &lt;code&gt;panic!&lt;/code&gt; 요구. &lt;code&gt;panic!&lt;/code&gt; 함수의 역 추적을 사용할 수 있습니다 ! 문제의 원인이되는 코드의 일부를 파악하기 위해 전화가 왔습니다. 다음에는 역 추적에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="translated">이 경우 오류를 수정하려면 &lt;code&gt;chocolate&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">이 장과 책 전체에서 터미널에서 사용되는 몇 가지 명령을 보여줍니다. 터미널에 입력해야하는 줄은 모두 &lt;code&gt;$&lt;/code&gt; 로 시작 합니다. &lt;code&gt;$&lt;/code&gt; 문자 를 입력 할 필요는 없습니다 . 각 명령의 시작을 나타냅니다. 로 시작하지 않는 줄 &lt;code&gt;$&lt;/code&gt; 로 일반적으로 이전 명령의 출력을 보여줍니다. 또한 PowerShell 관련 예제는 &lt;code&gt;$&lt;/code&gt; 대신 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서 우리는 &lt;em&gt;enums&lt;/em&gt; 라고도하는 &lt;em&gt;enumeration&lt;/em&gt; 을 살펴볼 것 입니다. 열거 형을 사용하면 가능한 &lt;em&gt;변형&lt;/em&gt; 을 열거하여 유형을 정의 할 수 있습니다 . 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, 값이 무언가가 될 수도 있고 없을 수도 있음을 나타내는 &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다 . 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리하는 데 사용할 수있는 또 다른 편리하고 간결한 관용구 인지 살펴 보겠습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서는 &lt;em&gt;enum&lt;/em&gt; 이라고도하는 &lt;em&gt;열거를&lt;/em&gt; 살펴 보겠습니다 . 열거 형을 사용하면 가능한 값을 열거하여 형식을 정의 할 수 있습니다. 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다.이 열거 형 은 값이 무엇이든 또는 아무것도 아닐 수 있음을 나타냅니다. 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리 할 수있는 또 다른 편리하고 간결한 관용구 인 방법을 다룰 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">이 장에서는 함수형 프로그래밍이 무엇인지에 대한 문제를 논의하지 않고, 종종 기능적이라고하는 많은 언어의 기능과 유사한 Rust의 일부 기능에 대해 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">이 장에서는 이러한 모든 기능을 다루고, 기능이 상호 작용하는 방법에 대해 설명하고, 기능을 사용하여 범위를 관리하는 방법에 대해 설명합니다. 결국, 당신은 모듈 시스템에 대해 잘 이해하고 전문가와 같은 범위에서 일할 수 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">이 장에서는 다음 내용을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">이 코드에서 첫 번째 값과 마지막 값이 &lt;code&gt;first&lt;/code&gt; 값과 일치합니다 및 &lt;code&gt;last&lt;/code&gt; 합니다. 그만큼 &lt;code&gt;..&lt;/code&gt; 일치 중간에 모든 것을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">이 코드 에서 Listing 19-26 의 &lt;code&gt;match&lt;/code&gt; 에서 와 같은 일이 발생한다 . Rust는 &lt;code&gt;val&lt;/code&gt; 이 타입 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;panic!&lt;/code&gt; 가지고 있음을 본다 ! 유형이 있습니다 &lt;code&gt;!&lt;/code&gt; 전체 &lt;code&gt;match&lt;/code&gt; 표현식 의 결과 는 &lt;code&gt;T&lt;/code&gt; 입니다. 이 코드는 &lt;code&gt;panic!&lt;/code&gt; 하기 때문에 작동합니다 !가치를 창출하지 않습니다. 프로그램을 종료합니다. 에 &lt;code&gt;None&lt;/code&gt; 경우, 우리는에서 값을 반환하지 않습니다 &lt;code&gt;unwrap&lt;/code&gt; 이 코드가 유효하므로.</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="translated">이 코드에는이 문제를 해결하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">이러한 맥락에서 &lt;em&gt; 런타임&lt;/em&gt; 이란 언어에 의해 모든 바이너리에 포함 된 코드를 의미합니다. 이 코드는 언어에 따라 크거나 작을 수 있지만 모든 비 조립 언어에는 일정량의 런타임 코드가 있습니다. 이러한 이유로 구어 적으로 사람들이 언어에 &quot;런타임 없음&quot;이 있다고 말하면 종종 &quot;작은 런타임&quot;을 의미합니다. 런타임이 작을수록 기능은 적지 만 바이너리가 작다는 장점이 있으므로 더 많은 컨텍스트에서 언어를 다른 언어와 쉽게 결합 할 수 있습니다. 더 많은 기능을 제공하기 위해 런타임 크기를 늘려서 많은 언어를 사용할 수 있지만 Rust는 런타임이 거의 필요하지 않으며 성능을 유지하기 위해 C를 호출 할 수있는 기능을 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="translated">이 예에서 &lt;code&gt;2&lt;/code&gt; 는 할당 직후에 삭제 됩니다. 즉, &lt;code&gt;ptr&lt;/code&gt; 은 이제 사용할 수없는 위치를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="translated">이 예에서 &lt;code&gt;BoxCar&lt;/code&gt; 에는 &lt;code&gt;Vehicle&lt;/code&gt; 과 &lt;code&gt;Box&lt;/code&gt; 라는 두 가지 슈퍼 특성이 있습니다. 이 두 특성 모두 연관된 유형 &lt;code&gt;Color&lt;/code&gt; 를 정의합니다 . &lt;code&gt;BoxCar&lt;/code&gt; 는 두 슈퍼 트레이 트 에서 그 이름을 가진 두 가지 유형을 상속합니다. 이 때문에 &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt; 중 적절한 &lt;code&gt;Color&lt;/code&gt; 관련 유형 을 참조하기 위해 정규화 된 경로 구문을 사용해야 하지만이 구문은 사용할 수 없습니다. 함수 서명에서.</target>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 예에서 &lt;code&gt;Cat&lt;/code&gt; 은 &lt;em&gt;구조체와 유사한 열거 형 변형&lt;/em&gt; 인 반면 &lt;code&gt;Dog&lt;/code&gt; 는 간단히 열거 형 변형이라고합니다. ENUM 각 인스턴스는 보유 &lt;em&gt;판별&lt;/em&gt; 이 보유하는 변이체를 결정하는 데 사용되는 그와 연관된 정수이다. 이 판별에 대한 불투명 한 참조는 &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Foo&lt;/code&gt; 는 연관된 유형 &lt;code&gt;A&lt;/code&gt; 를 정의합니다 . &lt;code&gt;Bar&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 에서 해당 유형을 상속 하고 동일한 이름의 다른 연관된 유형을 정의합니다. 결과적으로 &lt;code&gt;Self::A&lt;/code&gt; 를 사용하려고 할 때 &lt;code&gt;Foo&lt;/code&gt; 에 의해 정의 된 &lt;code&gt;A&lt;/code&gt; 를 의미하는지 또는에 의해 정의 된 것을 의미하는지는 모호합니다. &lt;code&gt;Bar&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">이 예에서 &lt;code&gt;Y&lt;/code&gt; 는 여기서 &lt;code&gt;X&lt;/code&gt; 를 참조 할 수 없습니다 . 이를 수정하기 위해 값을 const로 추출한 다음 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;string1&lt;/code&gt; 은 외부 범위 가 끝날 때까지 유효 하고 &lt;code&gt;string2&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효하며 &lt;code&gt;result&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효한 것을 참조합니다. 이 코드를 실행하면 차용 검사기가이 코드를 승인 함을 알 수 있습니다. 그것은 컴파일하고 인쇄 할 &lt;code&gt;The longest string is long string is long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">이 예에서, &lt;code&gt;value&lt;/code&gt; 은 차용에 의해 변경 가능하게 &lt;code&gt;borrow&lt;/code&gt; 되며 &lt;code&gt;sum&lt;/code&gt; 계산에 사용될 수 없습니다 . 이것은 Rust의 가변성 규칙을 위반하기 때문에 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">이 예제에서, &lt;code&gt;x&lt;/code&gt; 가 패턴 &lt;code&gt;(0, _)&lt;/code&gt; 과 일치 하면 두 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;(_, 0)&lt;/code&gt; 과 일치 하면 첫 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . 모든 경우에 &lt;code&gt;y&lt;/code&gt; 는 어떤 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">이 예에서 &lt;code&gt;'SnowWhite&lt;/code&gt; 수명은 &lt;code&gt;'kiss&lt;/code&gt; 수명 보다 오래 지속되지만 &lt;code&gt;Prince&lt;/code&gt; 구조체 의 선언은이를 강제하지 않습니다. 이 문제를 해결하려면 다음을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="translated">이 예에서 클로저는 &lt;code&gt;'static&lt;/code&gt; 수명 제약 조건 '을 충족하지 않습니다 . 이 오류를 수정하려면 유형의 수명을 다시 확인해야합니다. 여기에서 &lt;code&gt;s&lt;/code&gt; 에 정적 수명 을 제공하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이 예에서 모듈 &lt;code&gt;quux&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 두 개의 공개 이름을 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">이 예에서, 생성 된 스레드는 현재 스레드에서 &quot;분리&quot;됩니다. 이것은이 부모가 메인 스레드가 아니라면 부모 (스폰 한 스레드)보다 오래 지속될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">이 예제에서 특성 &lt;code&gt;Foo&lt;/code&gt; 및 특성 메소드 &lt;code&gt;do_something_else&lt;/code&gt; 는 모두 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 정의합니다 . 메소드가 유형 매개 변수를 정의하려면 다른 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;Printable&lt;/code&gt; 특성은 &lt;code&gt;print&lt;/code&gt; 의 유형 서명 과 &lt;code&gt;main&lt;/code&gt; 의 캐스트 표현식 모두에서 특성 오브젝트로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">이 예에서 값 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 0으로 포함 하여 두 번째 팔과 일치하므로이 코드는 &lt;code&gt;On the y axis at 7&lt;/code&gt; 인쇄 합니다 .</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">이 예제에서 &lt;code&gt;first&lt;/code&gt; 라는 변수 는 값 &lt;code&gt;1&lt;/code&gt; 을 얻습니다 . 이는 배열의 인덱스 &lt;code&gt;[0]&lt;/code&gt; 에있는 값이기 때문입니다 . &lt;code&gt;second&lt;/code&gt; 라는 변수 는 배열의 인덱스 &lt;code&gt;[1]&lt;/code&gt; 에서 값 &lt;code&gt;2&lt;/code&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;Foo&lt;/code&gt; 의 소멸자가 &lt;code&gt;X&lt;/code&gt; 유형의 데이터에 액세스하지 않으며 프로그램의 전반적인 안전을 위해이 어설 션이 참이어야한다고 주장합니다. 컴파일러는 현재이 어설 션을 확인하려고 시도하지 않습니다. 따라서이 &lt;code&gt;impl&lt;/code&gt; 을 안전하지 않은 것으로 태그 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">이 예에서는 상위 함수 인수를 받는 함수 &lt;code&gt;ten_times&lt;/code&gt; 를 정의한 다음 클로저 표현식을 인수로 호출 한 다음 환경에서 값을 이동시키는 클로저 표현식을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="translated">이 예에서, 우리는 (또 하나 호환 수명이 값을 설정하려고 &lt;code&gt;'long&lt;/code&gt; 무관 &lt;code&gt;'short&lt;/code&gt; ). 이 문제는 두 가지 방법으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="translated">이 예에서 우리 는 &lt;code&gt;Hello&lt;/code&gt; 특성 의 존재하지 않는 연관 유형 &lt;code&gt;You&lt;/code&gt; 를 사용하려고했습니다 . 이 오류를 수정하려면 기존 관련 유형을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">이 예제에서, 우리는 평생 매개 변수를 지정한 &lt;code&gt;'a&lt;/code&gt; 매개 변수에 대한 &lt;code&gt;x&lt;/code&gt; 및 반환 형식,하지만 매개 변수에 대한 &lt;code&gt;y&lt;/code&gt; 로 의 수명 때문에, &lt;code&gt;y&lt;/code&gt; 는 의 수명과 어떤 관계가없는 &lt;code&gt;x&lt;/code&gt; 또는 반환 값을.</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">이 예제에서 정수 값 5를 &lt;code&gt;x&lt;/code&gt; 에 할당하면 컴파일러에 일반 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스에 대한 정수임을 알립니다 . 그런 다음 &lt;code&gt;x&lt;/code&gt; 와 동일한 유형을 갖도록 정의한 &lt;code&gt;y&lt;/code&gt; 에 4.0을 지정하면 다음 과 같은 유형 불일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 가 불변 구조체 내부에서 돌연변이를 활성화 한다는 것을 알 수 있습니다 . 즉, &quot;내부 돌연변이&quot;를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">이 구현 에서 &lt;code&gt;Display&lt;/code&gt; 구현이 오류를 반환 하면 &lt;code&gt;to_string&lt;/code&gt; 메소드가 패닉 상태 가됩니다. &lt;code&gt;fmt::Write for String&lt;/code&gt; 은 오류 자체를 반환하지 않으므로 잘못된 &lt;code&gt;Display&lt;/code&gt; 구현을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">이 목록에서는 이전에 다루지 않은 &lt;code&gt;unwrap_or_else&lt;/code&gt; 메소드를 사용 했는데 , 이는 표준 라이브러리에 의해 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 에 정의되어 있습니다. 사용 &lt;code&gt;unwrap_or_else&lt;/code&gt; 것은 우리는 일부 사용자 지정, 비 정의 할 수 있습니다 &lt;code&gt;panic!&lt;/code&gt; 오류 처리. 는 IF &lt;code&gt;Result&lt;/code&gt; 입니다 &lt;code&gt;Ok&lt;/code&gt; 값이이 방법의 행동과 유사한 &lt;code&gt;unwrap&lt;/code&gt; : 그것은 내부 값 반환 &lt;code&gt;Ok&lt;/code&gt; 포장입니다. 그러나 값이 &lt;code&gt;Err&lt;/code&gt; 값인 경우이 메소드는 &lt;em&gt;클로저&lt;/em&gt; 에서 코드를 호출합니다.이 함수는 우리가 &lt;code&gt;unwrap_or_else&lt;/code&gt; 에 인수로 정의하고 전달하는 익명 함수 입니다. 우리는 폐쇄를 더 자세히 다룰 것입니다.&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; . 지금, 당신은 알아야합니다 &lt;code&gt;unwrap_or_else&lt;/code&gt; 가 의 내부 값을 전달합니다 &lt;code&gt;Err&lt;/code&gt; 이 경우에는 정적 문자열, &lt;code&gt;not enough arguments&lt;/code&gt; 우리가 인수에 우리의 폐쇄, 목록 12-9에 추가 한 &lt;code&gt;err&lt;/code&gt; 그 사이에 나타납니다 수직 파이프. 클로저의 코드는 실행될 때 &lt;code&gt;err&lt;/code&gt; 값 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">이보다 복잡한 예에서는 &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 를 사용합니다 ! 및 &lt;code&gt;.debug_set()&lt;/code&gt; 일치 팔의 목록을 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">다음 예제에서, &lt;code&gt;init_after_if&lt;/code&gt; 는 &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; 표현식&lt;/a&gt; 이후에 초기화 되지만 &lt;code&gt;uninit_after_if&lt;/code&gt; 는 &lt;code&gt;else&lt;/code&gt; 경우에 초기화되지 않기 때문에 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">이 프로세스에서 컴파일러는 Listing 10-5에서 일반 함수를 작성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 일반 코드가 호출되는 모든 위치를보고 일반 코드가 호출되는 구체적인 유형에 대한 코드를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">이 섹션에서는 TDD (Test-driven development) 프로세스를 사용하여 &lt;code&gt;minigrep&lt;/code&gt; 프로그램에 검색 로직을 추가합니다 . 이 소프트웨어 개발 기술은 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">이 섹션에서는 모듈 및 모듈 시스템의 다른 부분, 즉 항목 이름을 지정할 수있는 &lt;em&gt;경로에&lt;/em&gt; 대해 설명합니다. &lt;code&gt;use&lt;/code&gt; 범위에 대한 경로를 제공 키워드; 그리고 &lt;code&gt;pub&lt;/code&gt; 키워드는 항목을 공개합니다. 또한 &lt;code&gt;as&lt;/code&gt; 키워드, 외부 패키지 및 glob 연산자에 대해서도 설명합니다 . 지금은 모듈에 집중하자!</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">이 경우 빌린 컨텐츠를 이동할 수 없으므로 &lt;code&gt;ref&lt;/code&gt; 키워드로 도 해결할 수 없습니다. 이 문제는 일반적으로 해결할 수 없습니다. 값을 복제 할 수 있으면 다음과 같이 구체적이지 않은 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">이 특정한 경우에는 변환 음이 무해 할 가능성이 높습니다 (그러나 Rust가이를 보증하지는 않습니다). 그러나 정렬 및 열거 최적화가 그림에 나타날 때 크기가 다른 유형 매개 변수 대체와 일치하거나 일치하지 않을 수 있습니다. 가능한 &lt;em&gt;모든&lt;/em&gt; 유형에 대해 이것을 확인할 수는 없으므로 &lt;code&gt;transmute()&lt;/code&gt; 는 대체 되지 않은 유형 매개 변수가없는 유형 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">이 제안에서 &quot;간접&quot;은 값을 직접 저장하는 대신 값에 대한 포인터를 저장하여 값을 간접적으로 저장하도록 데이터 구조를 변경한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">이런 식으로 표현 구조는 실행 구조를 나타냅니다. 블록은 또 다른 종류의 표현식이므로 블록, 명령문, 표현식 및 블록은 다시 재귀 적으로 서로 깊이있게 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="translated">이 경우 유형을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">특성 선언에서 &lt;a href=&quot;items/traits#supertraits&quot;&gt;수퍼&lt;/a&gt; 특성으로 : &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; 은 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;관련 유형&lt;/a&gt; 에 대한 경계로서 특성 선언에서 : &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; 는 &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; 와 동일합니다 . 여기서 Self :: B : Copy {type B; } .</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="translated">트레이 트에서 &lt;code&gt;type&lt;/code&gt; 은 &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;연관된 유형&lt;/a&gt; 을 선언하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 괄호를 사용해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 종종 괄호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">이 책의 여러 곳에서 &lt;code&gt;derive&lt;/code&gt; 속성을 논의했습니다.이 속성은 구조체 또는 열거 정의에 적용 할 수 있습니다. &lt;code&gt;derive&lt;/code&gt; 속성을 사용하면 주석 한 유형에 대한 자신의 디폴트의 구현과 특성 구현하는 코드 생성 &lt;code&gt;derive&lt;/code&gt; 구문을.</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="translated">매우 드문 경우에이 문제는 &lt;code&gt;core&lt;/code&gt; 또는 &lt;code&gt;std&lt;/code&gt; 를 두 번 로드 할 때 발생할 수 있습니다 . 한 번은 메타 데이터 를 &lt;code&gt;check&lt;/code&gt; 하고 한 번은 메타 데이터 를 &lt;code&gt;build&lt;/code&gt; 합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;# 75176을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합 될 수 없습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="translated">대역 내 수명은 &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;Fn&lt;/code&gt; 구문 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합되었습니다.</target>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="translated">UTF-8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">바이트 배열에 대한 참조로 파일을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">utf8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">모든 확장 특성과 일부 중요한 유형 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">잘못된 바이트 :</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="translated">잘못된 사용법</target>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="translated">제공된 포인터와 연결된 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 의 강력한 참조 수를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">배열 및 슬라이스의 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">지수 식, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 또는 &lt;a href=&quot;types/slice&quot;&gt;슬라이스&lt;/a&gt; A를 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">인덱스는 원래 슬라이스의 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">인덱스는 UTF-8 시퀀스 경계에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">문자열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">문자열 인덱싱 연산의 반환 유형이 바이트 값, 문자, 그래 핀 클러스터 또는 문자열 슬라이스인지 명확하지 않기 때문에 문자열 인덱싱은 종종 나쁜 생각입니다. 따라서 Rust는 인덱스를 사용하여 문자열 슬라이스를 만들어야하는 경우 더 구체적으로 요구합니다. 인덱싱에서보다 구체적 으로 설명하고 단일 숫자로 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 인덱싱하는 대신 문자열 슬라이스를 원한다는 것을 나타내 려면 범위와 함께 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 상수 시간 작업을위한 것이지만 UTF-8 인코딩을 사용하면이 작업을 수행 할 수 없습니다. 또한 인덱스가 어떤 종류의 바이트, 코드 포인트 또는 grapheme 클러스터를 반환해야하는지 명확하지 않습니다. &lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 일정한 시간 작업을위한 것이지만 UTF-8 인코딩은이를 허용하지 않습니다. 게다가 인덱스가 어떤 종류의 것을 반환해야하는지 (바이트, 코드 포인트 또는 자소 클러스터)가 명확하지 않습니다. &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">객체 의 끝을지나 1 바이트를 제외 하고 &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 사용하여 객체의 경계 외부에서 인덱싱 합니다.</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">버퍼를 초기화해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">모든 상위 디렉토리를 작성하여 디렉토리를 반복적으로 작성해야 함을 나타냅니다. 존재하지 않는 부모는 동일한 보안 및 권한 설정으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">스레드가 종료 된 방식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">이 소켓에 대한 발신 멀티 캐스트 패킷의 유효 기간 값을 나타냅니다. 기본값은 1입니다. 즉, 멀티 캐스트 패킷은 명시 적으로 요청하지 않는 한 로컬 네트워크를 떠나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">완료되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="translated">&quot;구현되지 않음&quot;이라는 메시지와 함께 당황하여 구현되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">연결할 수없는 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">값을 사용할 수 있는지 또는 현재 작업이 웨이크 업을 받도록 예약되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">내용이 중앙 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">내용이 왼쪽 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">내용이 올바르게 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">인덱스는 배열과 슬라이스에 대해 0부터 시작합니다. 배열 액세스는 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 이므로 컴파일 타임에 상수 인덱스 값으로 경계를 확인할 수 있습니다. 그렇지 않으면 스레드 가 실패한 경우 스레드를 &lt;em&gt;패닉 상태로&lt;/em&gt; 만드는 검사가 런타임에 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 개의 &lt;code&gt;Arc&lt;/code&gt; 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="translated">항목에 적용된 절차 적 매크로 속성에서 사용하는 비활성 도우미 속성도 허용되지만 이러한 비활성 속성을 최종 &lt;code&gt;TokenStream&lt;/code&gt; 에 포함하지 않도록주의하세요 .</target>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">완벽한 오류</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">유추 된 유형</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 와 같은 무한 반복기 는 종종 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용되어 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 과 같은 무한 반복자 는 종종이를 한정하기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 반복자 는 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용하여 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 이터레이터 는 종종 그것들을 유한하게 만들기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">무한 루프</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">무한대 (&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f32::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f64::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">코드에서이 지점에 도달 할 수 없음을 컴파일러에 알리고 추가 최적화를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">조건이 항상 참임을 옵티 마이저에게 알립니다. 조건이 거짓이면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">고유 한 구현</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">고유 한 연관된 ​​유형은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195의&lt;/a&gt; 일부 이지만 아직 구현되지 않았습니다. 이 구현 상태에 대한 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;추적 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">고유 구현</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">고유 한 구현 (특성을 구현하지 않지만 유형과 연관된 메소드를 제공하는 구현)은 안전하지 않은 특성을 구현하지 않기 때문에 항상 안전합니다. 고유 구현에서 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 제거하면 이 오류가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">고유 구현은 포함 된 항목을 구현 유형에 연관시킵니다. 고유 구현에는 &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;관련 함수&lt;/a&gt; (메소드 포함) 및 &lt;a href=&quot;associated-items#associated-constants&quot;&gt;관련 상수&lt;/a&gt; 가 포함될 수 있습니다 . 연관된 유형 별명을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">고유 한 방법</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 대해 stdin / stdout / stderr를 상속 하지만 &lt;code&gt;output&lt;/code&gt; 위한 파이프를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">현재 프로세스 환경 상속</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">현재 프로세스의 작업 디렉토리 상속</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">타입 시스템과 코드 공유로서의 상속</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">상속은 최근에 필요한 것보다 많은 코드를 공유 할 위험이 있기 때문에 많은 프로그래밍 언어에서 프로그래밍 디자인 솔루션으로 선호되지 않습니다. 서브 클래스가 항상 부모 클래스의 모든 특성을 공유하지는 않지만 상속을 통해 그렇게해야합니다. 이로 인해 프로그램 디자인의 유연성이 떨어질 수 있습니다. 또한 이해가되지 않거나 서브 클래스에 적용되지 않기 때문에 오류를 발생시키는 서브 클래스에서 메소드를 호출 할 가능성도 소개합니다. 또한 일부 언어는 서브 클래스가 한 클래스에서만 상속 할 수 있도록하여 프로그램 디자인의 유연성을 더욱 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">초기화와 파괴</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">불변 초기화</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">초기화 동적으로 최초의 호출시에 수행 &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 스레드 내에서 구현할 값 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 할 때 스레드가 종료를 파괴 얻을. 아래에 설명 된 일부 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="translated">유니온 초기화</target>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">정적 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 값의 초기화 값입니다 .</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">루프 전에 결과를 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">필요한 경우 버퍼를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">필드별로 구조체 초기화</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">요소별로 배열 초기화</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">처음에 Rust 팀은 메모리 안전을 보장하고 동시성 문제를 방지하는 것이 서로 다른 방법으로 해결해야 할 두 가지 과제라고 생각했습니다. 시간이 지남에 따라 팀은 소유권 및 유형 시스템이 메모리 안전 &lt;em&gt;및&lt;/em&gt;동시성 문제! 소유권과 유형 검사를 활용함으로써 많은 동시성 오류는 런타임 오류가 아닌 Rust의 컴파일 타임 오류입니다. 따라서 런타임 동시성 버그가 발생하는 정확한 상황을 재현하기 위해 많은 시간을 소비하지 않고 잘못된 코드는 컴파일을 거부하고 문제를 설명하는 오류를 나타냅니다. 결과적으로 코드를 프로덕션에 제공 한 후 작업하지 않고 작업하는 동안 코드를 수정할 수 있습니다. 우리는 Rust &lt;em&gt;fearless &lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt; 의 이러한 측면을 별명으로 지정했습니다 . Fearless Concurrency를 사용하면 미묘한 버그가없고 새로운 버그를 도입하지 않고 리팩토링하기 쉬운 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="translated">인라인 어셈블리.</target>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">내부 속성</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">내부 블록 문서 주석</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="translated">내부 문서는 항목 앞에만 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">내부 함수는 포함 된 환경에 액세스 할 수 없습니다. 이 오류를 수정하려면 함수를 클로저로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">내부 항목은 포함 된 함수에서 유형 또는 const 매개 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">내부 문서 주석</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">삽입 및 복잡한 키</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">가장 큰 원소를 삽입하고 터지는 것은 &lt;code&gt;O(log n)&lt;/code&gt; 시간 복잡성을 갖는다. 가장 큰 요소를 확인하는 것은 &lt;code&gt;O(1)&lt;/code&gt; 입니다. 벡터를 이진 힙으로 변환하는 작업은 제자리에서 수행 할 수 있으며 &lt;code&gt;O(n)&lt;/code&gt; 복잡도를 갖습니다 . 이진 힙을 정렬 된 벡터로 변환하여 &lt;code&gt;O(n log n)&lt;/code&gt; 인플레 이스 힙 정렬에 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="translated">가장 큰 요소를 삽입하고 팝하는 데는 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; )) 시간 복잡도가 있습니다. 가장 큰 요소를 확인하는 것은 &lt;em&gt;O&lt;/em&gt; (1)입니다. 벡터를 이진 힙으로 변환하는 것은 제자리에서 수행 할 수 있으며 복잡성 은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; )입니다. 바이너리 힙은 내부에서 정렬 된 벡터로 변환되어 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 내부 힙 정렬에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;v&lt;/code&gt; 를 옵션에 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 옵션에 &lt;code&gt;v&lt;/code&gt; 를 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">바이트 위치 에서이 &lt;code&gt;String&lt;/code&gt; 에 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0a96531a2ad16ab4c68e8dd30a04fcb8b88d0c9e" translate="yes" xml:space="preserve">
          <source>Inserts a key-value pair into the map.</source>
          <target state="translated">키-값 쌍을 맵에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="bc42a512a6b6856f7f8d324cb00ee4762d1d8f2a" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f7ad47cd6a43af311ed7238acb4e8855c0abcd" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f07650e645ae306862b323d418b09fad3b7f7a0" translate="yes" xml:space="preserve">
          <source>Inserts a string slice into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">바이트 위치 에서이 &lt;code&gt;String&lt;/code&gt; 에 문자열 슬라이스를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="7d8655d30bbaeaee48aa3f55378c0fe2a4d62e4c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 옵션에 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf859e7e91bd94533ccef650a59dbaf129cf0d1c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 옵션에 삽입 한 다음 포함 된 값에 대한 가변 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd878e1d7609b46228a7e1a93fb6e8fa8ab178e1" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the set if the given &lt;code&gt;value&lt;/code&gt; is not present, then returns a reference to the value in the set.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 이 없으면 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 집합에 삽입 한 다음 집합의 값에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4c367e5c15ba31d0f216cb7099e2418408fa476" translate="yes" xml:space="preserve">
          <source>Inserts all new key-values from the iterator and replaces values with existing keys with new values returned from the iterator.</source>
          <target state="translated">반복기에서 모든 새 키-값을 삽입하고 값을 반복기에서 반환 된 새 값으로 기존 키로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="033e5469d3495f120ca34f88432068fa89f314f7" translate="yes" xml:space="preserve">
          <source>Inserts an element at &lt;code&gt;index&lt;/code&gt; within the &lt;code&gt;VecDeque&lt;/code&gt;, shifting all elements with indices greater than or equal to &lt;code&gt;index&lt;/code&gt; towards the back.</source>
          <target state="translated">요소에 삽입 &lt;code&gt;index&lt;/code&gt; 내의 &lt;code&gt;VecDeque&lt;/code&gt; 보다 큰 인덱스 모든 요소를 시프 팅 또는 동일한 &lt;code&gt;index&lt;/code&gt; 뒤쪽.</target>
        </trans-unit>
        <trans-unit id="12d5beb4f208ab2afd01a906d06c0928be9bf9f4" translate="yes" xml:space="preserve">
          <source>Inserts an element at position &lt;code&gt;index&lt;/code&gt; within the vector, shifting all elements after it to the right.</source>
          <target state="translated">벡터 내의 위치 &lt;code&gt;index&lt;/code&gt; 요소를 삽입하고 모든 요소를 ​​오른쪽으로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="9bb4759e4324e0dbf38962bc28c2aed1b8022c83" translate="yes" xml:space="preserve">
          <source>Inserts an owned copy of the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 의 소유 된 복사본 이없는 경우 집합에 삽입 한 다음 집합의 값에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32004441f1f355a905cf795d20839963739fd9b1" translate="yes" xml:space="preserve">
          <source>Inserts or updates an environment variable mapping.</source>
          <target state="translated">환경 변수 매핑을 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d407882b4597c3f9cc373c79e663633b3651a26e" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f751f427f5a00ba1f4ba152bfd16fef910d4b118" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec935fc4eff4c401230b5e9494768220ac04ae85" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">지정된 &lt;code&gt;value&lt;/code&gt; 이없는 경우 세트에 주어진 값 을 삽입 한 다음 세트의 값에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="10a95bea4ce01379ab8d7b752bb3fe35f6abf8b1" translate="yes" xml:space="preserve">
          <source>Inserts the given element just after the element most recently returned by &lt;code&gt;.next()&lt;/code&gt;. The inserted element does not appear in the iteration.</source>
          <target state="translated">&lt;code&gt;.next()&lt;/code&gt; 가장 최근에 반환 한 요소 바로 뒤에 주어진 요소를 삽입합니다 . 삽입 된 요소가 반복에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af470e35471ccbf3c83cd6c715dc2e1540c10617" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;for&lt;/code&gt; loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using &lt;code&gt;s.len()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 안에서 바이트 리터럴 구문을 사용하여 공백을 나타내는 바이트를 검색합니다. 공간을 찾으면 위치를 반환합니다. 그렇지 않으면 &lt;code&gt;s.len()&lt;/code&gt; 을 사용하여 문자열의 길이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49f499d15e7cb0aca0c18bf8de68e4d96c591f23" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;main&lt;/code&gt; function is the following code:</source>
          <target state="translated">내부 &lt;code&gt;main&lt;/code&gt; 기능은 다음 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="743099d758832aebc06d09f96504a2db95574113" translate="yes" xml:space="preserve">
          <source>Inside the function signature and body, the name of the type parameter can be used as a type name. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the &lt;code&gt;where&lt;/code&gt; syntax:</source>
          <target state="translated">함수 시그니처 및 본문 내에서 type 매개 변수의 이름을 유형 이름으로 사용할 수 있습니다. 유형 &lt;a href=&quot;traits&quot;&gt;특성에 대해 특성&lt;/a&gt; 한계를 지정하여 해당 특성을 가진 메소드를 해당 유형의 값에서 호출 할 수 있습니다. 이것은 &lt;code&gt;where&lt;/code&gt; 구문을 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="82ab79e7a84c19ee615f55de9576c57f6039cbaf" translate="yes" xml:space="preserve">
          <source>Inspect::all</source>
          <target state="translated">Inspect::all</target>
        </trans-unit>
        <trans-unit id="af62c7ee7c236c7e17a30a78c2b4fcf9f79c0b4b" translate="yes" xml:space="preserve">
          <source>Inspect::any</source>
          <target state="translated">Inspect::any</target>
        </trans-unit>
        <trans-unit id="b077905231123238f4a7bb9fcc60ce75f6089a93" translate="yes" xml:space="preserve">
          <source>Inspect::borrow</source>
          <target state="translated">Inspect::borrow</target>
        </trans-unit>
        <trans-unit id="dac186ed9d0b7d57d599f5ce890d1950aca83d7e" translate="yes" xml:space="preserve">
          <source>Inspect::borrow_mut</source>
          <target state="translated">Inspect::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eff030734cfa782924c1060ba45ae2c9617ddff7" translate="yes" xml:space="preserve">
          <source>Inspect::by_ref</source>
          <target state="translated">Inspect::by_ref</target>
        </trans-unit>
        <trans-unit id="c6e04f66ee740f870c7db51ddce5c394c1f5b366" translate="yes" xml:space="preserve">
          <source>Inspect::chain</source>
          <target state="translated">Inspect::chain</target>
        </trans-unit>
        <trans-unit id="af5a3161569b3cc4b1af16e096368ee36af988fd" translate="yes" xml:space="preserve">
          <source>Inspect::clone</source>
          <target state="translated">Inspect::clone</target>
        </trans-unit>
        <trans-unit id="4b8f1150495fa883babb18b3738d6b381ca35719" translate="yes" xml:space="preserve">
          <source>Inspect::clone_from</source>
          <target state="translated">Inspect::clone_from</target>
        </trans-unit>
        <trans-unit id="f20fee187ea64cd2682fd76ef634f46c65ea7337" translate="yes" xml:space="preserve">
          <source>Inspect::clone_into</source>
          <target state="translated">Inspect::clone_into</target>
        </trans-unit>
        <trans-unit id="91d60f6fbbeb3649b6191055cd46e14268f30490" translate="yes" xml:space="preserve">
          <source>Inspect::cloned</source>
          <target state="translated">Inspect::cloned</target>
        </trans-unit>
        <trans-unit id="85a2573bc9e0fcf94624c4b800d4b5742004e819" translate="yes" xml:space="preserve">
          <source>Inspect::cmp</source>
          <target state="translated">Inspect::cmp</target>
        </trans-unit>
        <trans-unit id="bb80987b9610829409c7cf311bd83c99cafb9358" translate="yes" xml:space="preserve">
          <source>Inspect::collect</source>
          <target state="translated">Inspect::collect</target>
        </trans-unit>
        <trans-unit id="6c4755e22c04a1a561bd40c8f7ed7cc9e14afdd5" translate="yes" xml:space="preserve">
          <source>Inspect::copied</source>
          <target state="translated">Inspect::copied</target>
        </trans-unit>
        <trans-unit id="d91465c1eb8c20ff2aaf256018f191b4b51027db" translate="yes" xml:space="preserve">
          <source>Inspect::count</source>
          <target state="translated">Inspect::count</target>
        </trans-unit>
        <trans-unit id="f6a3530affc366af3c3031653f04c92d94544c6f" translate="yes" xml:space="preserve">
          <source>Inspect::cycle</source>
          <target state="translated">Inspect::cycle</target>
        </trans-unit>
        <trans-unit id="2ef8727649c440036fbfd895887f256337974360" translate="yes" xml:space="preserve">
          <source>Inspect::enumerate</source>
          <target state="translated">Inspect::enumerate</target>
        </trans-unit>
        <trans-unit id="90d29ac40ce8f2f13585d9242b559870d571b0d2" translate="yes" xml:space="preserve">
          <source>Inspect::eq</source>
          <target state="translated">Inspect::eq</target>
        </trans-unit>
        <trans-unit id="3c8af74b0f8d034e93cc2689eb1582aea35cd194" translate="yes" xml:space="preserve">
          <source>Inspect::filter</source>
          <target state="translated">Inspect::filter</target>
        </trans-unit>
        <trans-unit id="0c1d967d962d5542a61729409b6700ebf061e41a" translate="yes" xml:space="preserve">
          <source>Inspect::filter_map</source>
          <target state="translated">Inspect::filter_map</target>
        </trans-unit>
        <trans-unit id="ef11d99b08eee4456cbbcf30c8d5eaf30c8a59bd" translate="yes" xml:space="preserve">
          <source>Inspect::find</source>
          <target state="translated">Inspect::find</target>
        </trans-unit>
        <trans-unit id="de75c9aaf20b405a1c60fd94f4dbe93e04bb79b9" translate="yes" xml:space="preserve">
          <source>Inspect::find_map</source>
          <target state="translated">Inspect::find_map</target>
        </trans-unit>
        <trans-unit id="4bdd706bdfb04e01d1c9af213d5586e2748a2444" translate="yes" xml:space="preserve">
          <source>Inspect::flat_map</source>
          <target state="translated">Inspect::flat_map</target>
        </trans-unit>
        <trans-unit id="adc62575b9ec6c48f327e8e73d67dd12a37fd54f" translate="yes" xml:space="preserve">
          <source>Inspect::flatten</source>
          <target state="translated">Inspect::flatten</target>
        </trans-unit>
        <trans-unit id="bf64f53f8ddafacb88390ac8654fa5e287a73a7c" translate="yes" xml:space="preserve">
          <source>Inspect::fmt</source>
          <target state="translated">Inspect::fmt</target>
        </trans-unit>
        <trans-unit id="e1203b82ecf5e7d86eeb57728448c3072c4d31ca" translate="yes" xml:space="preserve">
          <source>Inspect::fold</source>
          <target state="translated">Inspect::fold</target>
        </trans-unit>
        <trans-unit id="e36f213246f9d2f573670ffad6151bd06e3fa586" translate="yes" xml:space="preserve">
          <source>Inspect::for_each</source>
          <target state="translated">Inspect::for_each</target>
        </trans-unit>
        <trans-unit id="e7c3f5132be9e5287630addcdee29ef7865ef06d" translate="yes" xml:space="preserve">
          <source>Inspect::from</source>
          <target state="translated">Inspect::from</target>
        </trans-unit>
        <trans-unit id="fe4bfacc82f6be56fbd2cbdacbd9f9c98dbeb4d0" translate="yes" xml:space="preserve">
          <source>Inspect::fuse</source>
          <target state="translated">Inspect::fuse</target>
        </trans-unit>
        <trans-unit id="18e6f5734f2efd739f3505c74a0c0d087a45dc44" translate="yes" xml:space="preserve">
          <source>Inspect::ge</source>
          <target state="translated">Inspect::ge</target>
        </trans-unit>
        <trans-unit id="51b9499c2f6bcf728ec327afb3eadb4e80054ef7" translate="yes" xml:space="preserve">
          <source>Inspect::gt</source>
          <target state="translated">Inspect::gt</target>
        </trans-unit>
        <trans-unit id="df78def6e9a15f9326fc866aa7162363317dfe3c" translate="yes" xml:space="preserve">
          <source>Inspect::inspect</source>
          <target state="translated">Inspect::inspect</target>
        </trans-unit>
        <trans-unit id="cde84bc6a1ac6acfa3ca27e39148f1683f7a639a" translate="yes" xml:space="preserve">
          <source>Inspect::into</source>
          <target state="translated">Inspect::into</target>
        </trans-unit>
        <trans-unit id="0c85f8b299a3868a074eadb647478881cca1f5f2" translate="yes" xml:space="preserve">
          <source>Inspect::into_iter</source>
          <target state="translated">Inspect::into_iter</target>
        </trans-unit>
        <trans-unit id="93bdbca2f9e35d0382950f48be8119f4c4cd8c39" translate="yes" xml:space="preserve">
          <source>Inspect::is_empty</source>
          <target state="translated">Inspect::is_empty</target>
        </trans-unit>
        <trans-unit id="6cb061e34832197156e0eae9b796318c52eae21c" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted</source>
          <target state="translated">Inspect::is_sorted</target>
        </trans-unit>
        <trans-unit id="0b700978aa9715e5aeabd053030f7e06e5dfdbe8" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by</source>
          <target state="translated">Inspect::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="01522e5b03123c9816813cfbecb670d36dcf9bae" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by_key</source>
          <target state="translated">Inspect::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="97c7968340cdbfc55e6279e63210f8319602c3b1" translate="yes" xml:space="preserve">
          <source>Inspect::last</source>
          <target state="translated">Inspect::last</target>
        </trans-unit>
        <trans-unit id="1641c5ab204a86bd76b52647b967fa3844ee555e" translate="yes" xml:space="preserve">
          <source>Inspect::le</source>
          <target state="translated">Inspect::le</target>
        </trans-unit>
        <trans-unit id="8fedbf984d9131a9c32910d0dd8cd507c9ae41f1" translate="yes" xml:space="preserve">
          <source>Inspect::len</source>
          <target state="translated">Inspect::len</target>
        </trans-unit>
        <trans-unit id="2aae13f70bf251eedf4d622e3c8e8d7ebe509466" translate="yes" xml:space="preserve">
          <source>Inspect::lt</source>
          <target state="translated">Inspect::lt</target>
        </trans-unit>
        <trans-unit id="3c10daeba2bb0af4fb652f56b13c4f712081ee60" translate="yes" xml:space="preserve">
          <source>Inspect::map</source>
          <target state="translated">Inspect::map</target>
        </trans-unit>
        <trans-unit id="d7ab985e5175dcb4007a24ad2073cd92e1ee725b" translate="yes" xml:space="preserve">
          <source>Inspect::max</source>
          <target state="translated">Inspect::max</target>
        </trans-unit>
        <trans-unit id="5548cb84f4f36e68e97b0766437c90e71bec388e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by</source>
          <target state="translated">Inspect::max_by</target>
        </trans-unit>
        <trans-unit id="dce539004497e98e80382919f2b44ac4f343a42e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by_key</source>
          <target state="translated">Inspect::max_by_key</target>
        </trans-unit>
        <trans-unit id="588f749d074427554e4d2614e02fff13ad9cd053" translate="yes" xml:space="preserve">
          <source>Inspect::min</source>
          <target state="translated">Inspect::min</target>
        </trans-unit>
        <trans-unit id="60fe678c3fd98d803d7a0a967cf63b451cdaf79c" translate="yes" xml:space="preserve">
          <source>Inspect::min_by</source>
          <target state="translated">Inspect::min_by</target>
        </trans-unit>
        <trans-unit id="2487d43ef493a331b1b717bc22f40361c1ef635a" translate="yes" xml:space="preserve">
          <source>Inspect::min_by_key</source>
          <target state="translated">Inspect::min_by_key</target>
        </trans-unit>
        <trans-unit id="ffc55c77a0a3cf78936319f186df9927df3e0ccd" translate="yes" xml:space="preserve">
          <source>Inspect::ne</source>
          <target state="translated">Inspect::ne</target>
        </trans-unit>
        <trans-unit id="a43fcb5b031c0ce3926f10977d7f6a10a43f6208" translate="yes" xml:space="preserve">
          <source>Inspect::next</source>
          <target state="translated">Inspect::next</target>
        </trans-unit>
        <trans-unit id="6febe3467ee6ea45f701752f64651a80fe8404ab" translate="yes" xml:space="preserve">
          <source>Inspect::next_back</source>
          <target state="translated">Inspect::next_back</target>
        </trans-unit>
        <trans-unit id="0f9d290f3781cb4ac95ed05a1829eb899359b7f9" translate="yes" xml:space="preserve">
          <source>Inspect::nth</source>
          <target state="translated">Inspect::nth</target>
        </trans-unit>
        <trans-unit id="633dbdd78d8cdd2854d53a34adbb447ab4e90331" translate="yes" xml:space="preserve">
          <source>Inspect::nth_back</source>
          <target state="translated">Inspect::nth_back</target>
        </trans-unit>
        <trans-unit id="fc4ec8ac3236397826a770a15ac100842f901223" translate="yes" xml:space="preserve">
          <source>Inspect::partial_cmp</source>
          <target state="translated">Inspect::partial_cmp</target>
        </trans-unit>
        <trans-unit id="40853e163585e56c8285d38aa5808ca70dc06c35" translate="yes" xml:space="preserve">
          <source>Inspect::partition</source>
          <target state="translated">Inspect::partition</target>
        </trans-unit>
        <trans-unit id="9434c28e5a571fffcf6e901ec452b5ae6a98ab38" translate="yes" xml:space="preserve">
          <source>Inspect::peekable</source>
          <target state="translated">Inspect::peekable</target>
        </trans-unit>
        <trans-unit id="43968189a660c3e4fac603b379bde0cd86ad697c" translate="yes" xml:space="preserve">
          <source>Inspect::position</source>
          <target state="translated">Inspect::position</target>
        </trans-unit>
        <trans-unit id="89b4972ffab1f05ea2fbde1d69c01d599123b156" translate="yes" xml:space="preserve">
          <source>Inspect::product</source>
          <target state="translated">Inspect::product</target>
        </trans-unit>
        <trans-unit id="0443653aa8a5d69a1b0d33c9f17e2c9254f5f5d7" translate="yes" xml:space="preserve">
          <source>Inspect::rev</source>
          <target state="translated">Inspect::rev</target>
        </trans-unit>
        <trans-unit id="7cb21ca083cda72535e929cef63f871b4f3cf651" translate="yes" xml:space="preserve">
          <source>Inspect::rfind</source>
          <target state="translated">Inspect::rfind</target>
        </trans-unit>
        <trans-unit id="f79e10ec84996051e8312ada6ac965fccb6846de" translate="yes" xml:space="preserve">
          <source>Inspect::rfold</source>
          <target state="translated">Inspect::rfold</target>
        </trans-unit>
        <trans-unit id="f78976291c9758ab5955ca36b2caedb636e425a2" translate="yes" xml:space="preserve">
          <source>Inspect::rposition</source>
          <target state="translated">Inspect::rposition</target>
        </trans-unit>
        <trans-unit id="2392835414c1e0b5afa2ace3b96de2ef5ff9083c" translate="yes" xml:space="preserve">
          <source>Inspect::scan</source>
          <target state="translated">Inspect::scan</target>
        </trans-unit>
        <trans-unit id="3e468495e996e3f520360765bb1983040761bf4d" translate="yes" xml:space="preserve">
          <source>Inspect::size_hint</source>
          <target state="translated">Inspect::size_hint</target>
        </trans-unit>
        <trans-unit id="65d5d88728cb3772dee70aa6ae26fe906858cdfa" translate="yes" xml:space="preserve">
          <source>Inspect::skip</source>
          <target state="translated">Inspect::skip</target>
        </trans-unit>
        <trans-unit id="e4df02a7fa585f7bf67e2c2e7620ec2b27bf223a" translate="yes" xml:space="preserve">
          <source>Inspect::skip_while</source>
          <target state="translated">Inspect::skip_while</target>
        </trans-unit>
        <trans-unit id="81611aac4ee662fdf8e1bb6309a5396db2852250" translate="yes" xml:space="preserve">
          <source>Inspect::step_by</source>
          <target state="translated">Inspect::step_by</target>
        </trans-unit>
        <trans-unit id="333ad3419c346fac8b8d3c0fd4cc6a07785ed3a9" translate="yes" xml:space="preserve">
          <source>Inspect::sum</source>
          <target state="translated">Inspect::sum</target>
        </trans-unit>
        <trans-unit id="07c4846ffa005c2b497a796ecdc14a564003a4a8" translate="yes" xml:space="preserve">
          <source>Inspect::take</source>
          <target state="translated">Inspect::take</target>
        </trans-unit>
        <trans-unit id="4f28a1534dff8b2e2c944f0bfaafe96286e1baaa" translate="yes" xml:space="preserve">
          <source>Inspect::take_while</source>
          <target state="translated">Inspect::take_while</target>
        </trans-unit>
        <trans-unit id="2a423ad3eae2fec9385b69311ba93e53244f0ad5" translate="yes" xml:space="preserve">
          <source>Inspect::to_owned</source>
          <target state="translated">Inspect::to_owned</target>
        </trans-unit>
        <trans-unit id="a6362c52c757937e435b1eeef2d9ab055596b389" translate="yes" xml:space="preserve">
          <source>Inspect::try_fold</source>
          <target state="translated">Inspect::try_fold</target>
        </trans-unit>
        <trans-unit id="b44f87043be8c6e37fe81b5e52b558de6e2af9af" translate="yes" xml:space="preserve">
          <source>Inspect::try_for_each</source>
          <target state="translated">Inspect::try_for_each</target>
        </trans-unit>
        <trans-unit id="2933e22002dc23a223d51ac3b5541e6507691dd0" translate="yes" xml:space="preserve">
          <source>Inspect::try_from</source>
          <target state="translated">Inspect::try_from</target>
        </trans-unit>
        <trans-unit id="b21cad5abb074d64e5dc5deb026a557335ea6176" translate="yes" xml:space="preserve">
          <source>Inspect::try_into</source>
          <target state="translated">Inspect::try_into</target>
        </trans-unit>
        <trans-unit id="1fd81bf07a71bc1209ac8f8b1e33f27ed1378a45" translate="yes" xml:space="preserve">
          <source>Inspect::try_rfold</source>
          <target state="translated">Inspect::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e9b8b3f317cc849ace42df081dd27ff57c0541e" translate="yes" xml:space="preserve">
          <source>Inspect::type_id</source>
          <target state="translated">Inspect::type_id</target>
        </trans-unit>
        <trans-unit id="41140164c66c290cc48804ad982a4e7115e22da9" translate="yes" xml:space="preserve">
          <source>Inspect::unzip</source>
          <target state="translated">Inspect::unzip</target>
        </trans-unit>
        <trans-unit id="fe0d4b72621d75d8a76f592b0efd07f85c74dca9" translate="yes" xml:space="preserve">
          <source>Inspect::zip</source>
          <target state="translated">Inspect::zip</target>
        </trans-unit>
        <trans-unit id="8a955d8f62cddda7e4b47eb2772b795f5ac4e929" translate="yes" xml:space="preserve">
          <source>Inspecting a foreign C string:</source>
          <target state="translated">외래 C 문자열 검사 :</target>
        </trans-unit>
        <trans-unit id="24c028aad5e4f71eb7323a7fdf907c77523124b6" translate="yes" xml:space="preserve">
          <source>Inspection and manipulation of the process's environment.</source>
          <target state="translated">공정 환경의 점검 및 조작.</target>
        </trans-unit>
        <trans-unit id="2cc2859dfe537be8955a457d12a963c9483cf55a" translate="yes" xml:space="preserve">
          <source>Inspects an environment variable at compile time.</source>
          <target state="translated">컴파일 타임에 환경 변수를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="da805945f5409d032b925fa086323fea9942dc3f" translate="yes" xml:space="preserve">
          <source>Install binaries from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에서 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="27807feadc6086bb00cc2f2fc11c34f918ce0b35" translate="yes" xml:space="preserve">
          <source>Install the latest stable version of Rust using &lt;code&gt;rustup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; 을 사용하여 최신 안정 버전의 Rust 설치</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8bc95ab544ffc801a72a650102cb1b4b0031b02c" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; on Linux or macOS</source>
          <target state="translated">Linux 또는 macOS에 &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; 설치</target>
        </trans-unit>
        <trans-unit id="d41546865affb2f20149c73fe77f1fc24d402ca2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; on Windows</source>
          <target state="translated">Windows에 &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; 설치</target>
        </trans-unit>
        <trans-unit id="e19f38815d4acff6e4f527222a8aef2789228129" translate="yes" xml:space="preserve">
          <source>Installing Binaries from Crates.io with &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt; 와 함께 Crates.io에서 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="b810516d3307cdf27a35ee79c057d48b6aa21230" translate="yes" xml:space="preserve">
          <source>Installing Rust on Linux, macOS, and Windows</source>
          <target state="translated">Linux, macOS 및 Windows에 Rust 설치</target>
        </trans-unit>
        <trans-unit id="2c30b9b10b587e1e4e3853ef85ec4740848abbd7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.</source>
          <target state="translated">상태를 변경하지 않고 &lt;code&gt;Fn&lt;/code&gt; 인스턴스를 반복해서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1322a032825805d3a73d3fe7e3a12985cf1de692" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnMut&lt;/code&gt; can be called repeatedly and may mutate state.</source>
          <target state="translated">&lt;code&gt;FnMut&lt;/code&gt; 인스턴스는 반복적으로 호출 될 수 있으며 상태를 변경시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bc8df98d67671ea9af2ebbd9472094277d62c7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnOnce&lt;/code&gt; can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements &lt;code&gt;FnOnce&lt;/code&gt;, it can only be called once.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; 의 인스턴스는 호출 할 수 있지만 여러 번 호출 할 수는 없습니다. 이 때문에 타입에 대해 알려진 유일한 것이 &lt;code&gt;FnOnce&lt;/code&gt; 를 구현 한다는 것이라면 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9d31413b772c5dc3e318115ee395c8ad114636" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Hasher&lt;/code&gt; usually represent state that is changed while hashing data.</source>
          <target state="translated">&lt;code&gt;Hasher&lt;/code&gt; 인스턴스는 일반적으로 데이터를 해시하는 동안 변경되는 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21ec3e515a993282791572f7098d9de91b54a575" translate="yes" xml:space="preserve">
          <source>Instances of this &lt;code&gt;struct&lt;/code&gt; can be obtained by matching against the &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt; variant&lt;/a&gt; on &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 인스턴스 &lt;code&gt;struct&lt;/code&gt; 대해 매칭시킴으로써 얻을 수있다 &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; 변이체&lt;/a&gt; 에 &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5dd7083ff5f07cec7b9b34c02884013f777ac05" translate="yes" xml:space="preserve">
          <source>Instant</source>
          <target state="translated">Instant</target>
        </trans-unit>
        <trans-unit id="b5ac78fce22209b999309e8a7436e97b10622104" translate="yes" xml:space="preserve">
          <source>Instant::add</source>
          <target state="translated">Instant::add</target>
        </trans-unit>
        <trans-unit id="e5c83578445bb46f2191fb87fb2e970bfde98993" translate="yes" xml:space="preserve">
          <source>Instant::add_assign</source>
          <target state="translated">Instant::add_assign</target>
        </trans-unit>
        <trans-unit id="0c8c3b63eb155a52c73bfac3155d0197dd1a085d" translate="yes" xml:space="preserve">
          <source>Instant::borrow</source>
          <target state="translated">Instant::borrow</target>
        </trans-unit>
        <trans-unit id="f0f79568d43ec6cff172ef06950242a1e38ab9d4" translate="yes" xml:space="preserve">
          <source>Instant::borrow_mut</source>
          <target state="translated">Instant::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2e29432f378f62b734e945a4acd41b7defd436d4" translate="yes" xml:space="preserve">
          <source>Instant::checked_add</source>
          <target state="translated">Instant::checked_add</target>
        </trans-unit>
        <trans-unit id="eb4f8d11d037399c427f9a46cdb4e74b0b9fb310" translate="yes" xml:space="preserve">
          <source>Instant::checked_duration_since</source>
          <target state="translated">Instant::checked_duration_since</target>
        </trans-unit>
        <trans-unit id="f623e63718dd7f5e08fc4822d3ea1e552e483468" translate="yes" xml:space="preserve">
          <source>Instant::checked_sub</source>
          <target state="translated">Instant::checked_sub</target>
        </trans-unit>
        <trans-unit id="f7961f96937c07d9b42758cbb78758eeb1202726" translate="yes" xml:space="preserve">
          <source>Instant::clamp</source>
          <target state="translated">Instant::clamp</target>
        </trans-unit>
        <trans-unit id="a221c46ded2b61b64dcb1f60bfcb2b2993a3a5c9" translate="yes" xml:space="preserve">
          <source>Instant::clone</source>
          <target state="translated">Instant::clone</target>
        </trans-unit>
        <trans-unit id="0e4e4ec37ffa30c7418b3d4c01f925199339bd78" translate="yes" xml:space="preserve">
          <source>Instant::clone_from</source>
          <target state="translated">Instant::clone_from</target>
        </trans-unit>
        <trans-unit id="8b5bc24c2667bb02ad8d0c988c0c260c44857a92" translate="yes" xml:space="preserve">
          <source>Instant::clone_into</source>
          <target state="translated">Instant::clone_into</target>
        </trans-unit>
        <trans-unit id="e2495f5ad07793d7e77643dd4f486d02627866e1" translate="yes" xml:space="preserve">
          <source>Instant::cmp</source>
          <target state="translated">Instant::cmp</target>
        </trans-unit>
        <trans-unit id="5bb91176ea9d1de93e298e46888f1699788ffa0c" translate="yes" xml:space="preserve">
          <source>Instant::duration_since</source>
          <target state="translated">Instant::duration_since</target>
        </trans-unit>
        <trans-unit id="afcae638aa376f5908f1f30bd28087f8ac6046bd" translate="yes" xml:space="preserve">
          <source>Instant::elapsed</source>
          <target state="translated">Instant::elapsed</target>
        </trans-unit>
        <trans-unit id="243a247fce13eeb9a4a84c1d5fb1dac67574f6d1" translate="yes" xml:space="preserve">
          <source>Instant::eq</source>
          <target state="translated">Instant::eq</target>
        </trans-unit>
        <trans-unit id="c0e9c53ccf6d3d28525b5acc190c32004eb85ec8" translate="yes" xml:space="preserve">
          <source>Instant::fmt</source>
          <target state="translated">Instant::fmt</target>
        </trans-unit>
        <trans-unit id="91e13bb77c7e58f374e2d3daa91a9fc513ccb0bb" translate="yes" xml:space="preserve">
          <source>Instant::from</source>
          <target state="translated">Instant::from</target>
        </trans-unit>
        <trans-unit id="666400c2a2e214fcba1e53bc6d351d576dedbf88" translate="yes" xml:space="preserve">
          <source>Instant::ge</source>
          <target state="translated">Instant::ge</target>
        </trans-unit>
        <trans-unit id="e1545f7a496f8f598ffee1a4b219bdc08ac325eb" translate="yes" xml:space="preserve">
          <source>Instant::gt</source>
          <target state="translated">Instant::gt</target>
        </trans-unit>
        <trans-unit id="41c216d5664a8a7e6d226c8c88076fb379772e86" translate="yes" xml:space="preserve">
          <source>Instant::hash</source>
          <target state="translated">Instant::hash</target>
        </trans-unit>
        <trans-unit id="754e2486a3657aa16f85c8a3399792e46fc3859e" translate="yes" xml:space="preserve">
          <source>Instant::hash_slice</source>
          <target state="translated">Instant::hash_slice</target>
        </trans-unit>
        <trans-unit id="77b8dcf93181fdfb9c2ccd019961362f091bc10d" translate="yes" xml:space="preserve">
          <source>Instant::into</source>
          <target state="translated">Instant::into</target>
        </trans-unit>
        <trans-unit id="27c580d98c20ea09e90f23c4e7129dd284f1e540" translate="yes" xml:space="preserve">
          <source>Instant::le</source>
          <target state="translated">Instant::le</target>
        </trans-unit>
        <trans-unit id="077dca8f66a9fddef8fd3afcd25ba70cba946a7c" translate="yes" xml:space="preserve">
          <source>Instant::lt</source>
          <target state="translated">Instant::lt</target>
        </trans-unit>
        <trans-unit id="5f279b9b945d564222473676176af94a42a66352" translate="yes" xml:space="preserve">
          <source>Instant::max</source>
          <target state="translated">Instant::max</target>
        </trans-unit>
        <trans-unit id="1fef472f05cd2b320ab2c2019b4644689c5cb2f0" translate="yes" xml:space="preserve">
          <source>Instant::min</source>
          <target state="translated">Instant::min</target>
        </trans-unit>
        <trans-unit id="2607167b08c7b923c8543daeccd1a89c638f791c" translate="yes" xml:space="preserve">
          <source>Instant::ne</source>
          <target state="translated">Instant::ne</target>
        </trans-unit>
        <trans-unit id="2e89ed9eeb6e6fedfd76e029598f95d52ac89e9c" translate="yes" xml:space="preserve">
          <source>Instant::now</source>
          <target state="translated">Instant::now</target>
        </trans-unit>
        <trans-unit id="ef217fe283814eb7e0d5fb84203270e40f97b8d2" translate="yes" xml:space="preserve">
          <source>Instant::partial_cmp</source>
          <target state="translated">Instant::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bf1b8520fb2822b3f5cb83bccfd646a516fffcbf" translate="yes" xml:space="preserve">
          <source>Instant::saturating_duration_since</source>
          <target state="translated">Instant::saturating_duration_since</target>
        </trans-unit>
        <trans-unit id="9ed1ccf1a589fe42420c89b940730dc8b7982f7d" translate="yes" xml:space="preserve">
          <source>Instant::sub</source>
          <target state="translated">Instant::sub</target>
        </trans-unit>
        <trans-unit id="57ade0b6d4dcc1517fdb9cf85b73a61857e80559" translate="yes" xml:space="preserve">
          <source>Instant::sub_assign</source>
          <target state="translated">Instant::sub_assign</target>
        </trans-unit>
        <trans-unit id="bdec0c97db20d86ebdd661571569d5a69a65be45" translate="yes" xml:space="preserve">
          <source>Instant::to_owned</source>
          <target state="translated">Instant::to_owned</target>
        </trans-unit>
        <trans-unit id="0901e5a9482040c503269599b849e7e300181ba0" translate="yes" xml:space="preserve">
          <source>Instant::try_from</source>
          <target state="translated">Instant::try_from</target>
        </trans-unit>
        <trans-unit id="5df3e1f653d0b4e8c037a1c9641f59e6a8cbc24c" translate="yes" xml:space="preserve">
          <source>Instant::try_into</source>
          <target state="translated">Instant::try_into</target>
        </trans-unit>
        <trans-unit id="69f76dc23d56db8a52e6e54a74ec2db10116eb78" translate="yes" xml:space="preserve">
          <source>Instant::type_id</source>
          <target state="translated">Instant::type_id</target>
        </trans-unit>
        <trans-unit id="001172aad080d8306d5d4d1b5dc437b8d68f3a48" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to () in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="translated">열거 형 변형 인스턴스화는 열거 형 이름을 네임 스페이스로 명시 적으로 사용하고 변형 중 하나를 사용합니다. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; 가 위의 예입니다. 데이터가 녹의 내장 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 유형 과 같은 변형과 함께 오는 경우, 데이터는 유형이 설명하는대로 추가됩니다 &lt;code&gt;Option::Some(123)&lt;/code&gt; 예 : Option :: Some (123)) . &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt; 와 같은 구조체 유사 변형이 있습니다. 빈 열거 형은 인스턴스화 할 수 없다는 점에서 ()와 유사하며 주로 흥미로운 방식으로 형식 시스템을 망칠 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c525f735dffbb0093cdbc000d1e1854b0b45f32" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to &lt;a href=&quot;primitive.never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d417c0066da918ab986006990b8c13e4a1c9d4" translate="yes" xml:space="preserve">
          <source>Instantiation</source>
          <target state="translated">Instantiation</target>
        </trans-unit>
        <trans-unit id="b9d10d744d3b830949e2bf595c80e084be4f440a" translate="yes" xml:space="preserve">
          <source>Instantiations of struct or variant fields</source>
          <target state="translated">구조체 또는 변형 필드의 인스턴스화</target>
        </trans-unit>
        <trans-unit id="052f953d4dc163101293e43033ca426c81cc5b70" translate="yes" xml:space="preserve">
          <source>Instantiations of struct, union, or enum variant fields</source>
          <target state="translated">구조체, 공용체 또는 열거 형 변형 필드의 인스턴스화</target>
        </trans-unit>
        <trans-unit id="f7b4faec33775d5b4afedfc919179e22bbcfd3c9" translate="yes" xml:space="preserve">
          <source>Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.</source>
          <target state="translated">인스턴트는 항상 생성시 이전에 측정 한 인스턴트보다 항상 보장되며, 벤치 마크 측정 또는 작업 소요 시간 타이밍과 같은 작업에 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="283f4073d67eb71b9aee283558af89f84e2066b3" translate="yes" xml:space="preserve">
          <source>Instants are opaque types that can only be compared to one another. There is no method to get &quot;the number of seconds&quot; from an instant. Instead, it only allows measuring the duration between two instants (or comparing two instants).</source>
          <target state="translated">인스턴트는 서로 비교할 수있는 불투명 한 유형입니다. 순간에서 &quot;초 수&quot;를 얻는 방법은 없습니다. 대신 두 순간 사이의 지속 시간 만 측정하거나 두 순간을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61804bc8442fc7d7bb4e71e306aef5c0aea1b60a" translate="yes" xml:space="preserve">
          <source>Instead it is used to prevent moves through the type system, by controlling the behavior of pointers &lt;code&gt;P&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper, which &quot;pin&quot; the type in place by not allowing it to be moved out of them. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin module&lt;/code&gt;&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">대신에 포인터 &lt;code&gt;P&lt;/code&gt; 에 포함 된 포인터의 동작을 제어하여 형식 시스템을 통한 이동을 방지하는 데 사용됩니다 .&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 래퍼에래퍼는 형식을 이동시킬 수 없도록하여 형식을 &quot;고정&quot;시킵니다. 고정에 대한 자세한내용은&lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin module&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3589fb3ebd4ad6821bd6d9b7e8dfdf86bb935287" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ok&lt;/code&gt;, the line &lt;code&gt;test tests::another&lt;/code&gt; shows &lt;code&gt;FAILED&lt;/code&gt;. Two new sections appear between the individual results and the summary: the first section displays the detailed reason for each test failure. In this case, &lt;code&gt;another&lt;/code&gt; failed because it &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt;, which happened on line 10 in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we&amp;rsquo;ll talk more about ways to run tests in the &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 대신 line &lt;code&gt;test tests::another&lt;/code&gt; 는 &lt;code&gt;FAILED&lt;/code&gt; 를 표시 합니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션에는 각 테스트 실패에 대한 자세한 이유가 표시됩니다. 이 경우 &lt;code&gt;another&lt;/code&gt; &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt; 했기 때문에 실패했습니다.&lt;em&gt; src / lib.rs&lt;/em&gt; 파일의 10 번째 줄 . 다음 섹션에는 모든 실패한 테스트의 이름 만 나열되어 있으며 많은 테스트와 자세한 실패한 테스트 출력이있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 테스트를 더 쉽게 디버그하기 위해 해당 테스트 만 실행할 수 있습니다. &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;테스트 실행 방법 제어&quot;&lt;/a&gt; 섹션 에서 테스트를 실행하는 방법에 대해 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="1a520d0103dd9e1e65d5d07eb5562a910a387f00" translate="yes" xml:space="preserve">
          <source>Instead of a concrete type for the &lt;code&gt;item&lt;/code&gt; parameter, we specify the &lt;code&gt;impl&lt;/code&gt; keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of &lt;code&gt;notify&lt;/code&gt;, we can call any methods on &lt;code&gt;item&lt;/code&gt; that come from the &lt;code&gt;Summary&lt;/code&gt; trait, such as &lt;code&gt;summarize&lt;/code&gt;. We can call &lt;code&gt;notify&lt;/code&gt; and pass in any instance of &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt;. Code that calls the function with any other type, such as a &lt;code&gt;String&lt;/code&gt; or an &lt;code&gt;i32&lt;/code&gt;, won&amp;rsquo;t compile because those types don&amp;rsquo;t implement &lt;code&gt;Summary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 매개 변수 의 구체적 유형 대신 &lt;code&gt;impl&lt;/code&gt; 키워드와 특성 이름을 지정합니다 . 이 매개 변수는 지정된 특성을 구현하는 모든 유형을 승인합니다. 본문에 &lt;code&gt;notify&lt;/code&gt; , 우리는 어떠한 방법을 호출 할 수 있습니다 &lt;code&gt;item&lt;/code&gt; 으로부터 온 &lt;code&gt;Summary&lt;/code&gt; 과 같은 특성, &lt;code&gt;summarize&lt;/code&gt; . 우리는 &lt;code&gt;NewsArticle&lt;/code&gt; 또는 &lt;code&gt;Tweet&lt;/code&gt; 의 어떤 경우에도 &lt;code&gt;notify&lt;/code&gt; 하고 전달할 수 있습니다 . &lt;code&gt;String&lt;/code&gt; 또는 다른 유형과 같은 다른 유형으로 함수를 호출하는 코드 &lt;code&gt;i32&lt;/code&gt; 해당 유형이 &lt;code&gt;Summary&lt;/code&gt; 를 구현하지 않기 때문에 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c586c2da19eaf29595cd7783a0bdd1aaa4af1f4c" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;assert!&lt;/code&gt; macro as we&amp;rsquo;ve done here, we could make &lt;code&gt;new&lt;/code&gt; return a &lt;code&gt;Result&lt;/code&gt; like we did with &lt;code&gt;Config::new&lt;/code&gt; in the I/O project in Listing 12-9. But we&amp;rsquo;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you&amp;rsquo;re feeling ambitious, try to write a version of &lt;code&gt;new&lt;/code&gt; with the following signature to compare both versions:</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 을 추가하는 대신 ! 매크로 우리가 여기서했던, 우리가 만들 수있는 &lt;code&gt;new&lt;/code&gt; 수익을 &lt;code&gt;Result&lt;/code&gt; 우리가했던 것처럼 &lt;code&gt;Config::new&lt;/code&gt; 목록 12-9의 I / O 프로젝트이다. 그러나이 경우 스레드없이 스레드 풀을 만들려고하면 복구 할 수없는 오류가되어야한다고 결정했습니다. 야심이 있다면 다음 서명을 사용하여 &lt;code&gt;new&lt;/code&gt; 버전을 작성하여 두 버전을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="9745bfc2f2927dceb9288ed29cf395b852078f44" translate="yes" xml:space="preserve">
          <source>Instead of always calling the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function before the &lt;code&gt;if&lt;/code&gt; blocks, we can define a closure and store the &lt;em&gt;closure&lt;/em&gt; in a variable rather than storing the result of the function call, as shown in Listing 13-5. We can actually move the whole body of &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; within the closure we&amp;rsquo;re introducing here.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록 전에 항상 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수를 호출하는 대신 , Listing 13-5에 표시된 것처럼 함수 호출의 결과를 저장하는 대신 &lt;em&gt;클로저&lt;/em&gt; 를 정의 하고 변수에 클로저를 저장할 수 있습니다 . 우리는 여기에서 소개하는 클로저 내에서 실제로 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 전신을 옮길 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae67e98f84394870dad9c2dee4383fa199b41a3d" translate="yes" xml:space="preserve">
          <source>Instead of comparing the iterator's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">반복자의 요소를 직접 비교하는 대신이 함수는 &lt;code&gt;f&lt;/code&gt; 에 의해 결정된대로 요소의 키를 비교합니다 . 그 외에도 &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f4a03c266892c8db13bbe1ed2f70b65c01aa093" translate="yes" xml:space="preserve">
          <source>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">슬라이스의 요소를 직접 비교하는 대신이 함수는 &lt;code&gt;f&lt;/code&gt; 에 의해 결정된대로 요소의 키를 비교합니다 . 그 외에는 다음과 같습니다.&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab414c3f0e8d06ac0d388f321dffd0ec64ba1540" translate="yes" xml:space="preserve">
          <source>Instead of defining an inherent implementation on a reference, you could also move the reference inside the implementation:</source>
          <target state="translated">참조에 고유 한 구현을 정의하는 대신 구현 내에서 참조를 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf669630673f131e83096baf2080a7fff2853dbb" translate="yes" xml:space="preserve">
          <source>Instead of saving the closure in a variable directly, we save a new instance of &lt;code&gt;Cacher&lt;/code&gt; that holds the closure. Then, in each place we want the result, we call the &lt;code&gt;value&lt;/code&gt; method on the &lt;code&gt;Cacher&lt;/code&gt; instance. We can call the &lt;code&gt;value&lt;/code&gt; method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</source>
          <target state="translated">클로저를 변수에 직접 저장하는 대신 클로저 를 보유 하는 새로운 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스를 저장합니다 . 그런 다음 각 위치에서 결과를 원할 때 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스 의 &lt;code&gt;value&lt;/code&gt; 메소드를 호출합니다 . 우리는 &lt;code&gt;value&lt;/code&gt; 원하는만큼 value 메소드를 호출하거나 전혀 호출하지 않을 수 있으며 값 비싼 계산은 최대 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="007ce9d48190918926ae8e5decfb3ba7fb1ee115" translate="yes" xml:space="preserve">
          <source>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the &lt;em&gt;target/debug&lt;/em&gt; directory.</source>
          <target state="translated">Cargo는 빌드 결과를 코드와 동일한 디렉토리에 저장하는 대신 &lt;em&gt; 대상 / 디버그&lt;/em&gt; 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="12c9e09de719f2e7a3f500e0f9b7335d3a4a658d" translate="yes" xml:space="preserve">
          <source>Instead of stopping at &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever.</source>
          <target state="translated">에 멈추지 않고 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에서반복자가 처음부터 다시 시작됩니다. 다시 반복하면 처음부터 다시 시작됩니다. 다시 한번. 다시 한번. 영원히.</target>
        </trans-unit>
        <trans-unit id="57207c003495c85f3158cd50928c0d6b80c8565c" translate="yes" xml:space="preserve">
          <source>Instead of storing a vector of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances in the thread pool, we&amp;rsquo;ll store instances of the &lt;code&gt;Worker&lt;/code&gt; struct. Each &lt;code&gt;Worker&lt;/code&gt; will store a single &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instance. Then we&amp;rsquo;ll implement a method on &lt;code&gt;Worker&lt;/code&gt; that will take a closure of code to run and send it to the already running thread for execution. We&amp;rsquo;ll also give each worker an &lt;code&gt;id&lt;/code&gt; so we can distinguish between the different workers in the pool when logging or debugging.</source>
          <target state="translated">스레드 풀 에 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 인스턴스 의 벡터를 저장하는 대신 &lt;code&gt;Worker&lt;/code&gt; 구조체의 인스턴스를 저장합니다 . 각 &lt;code&gt;Worker&lt;/code&gt; 는 단일 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 인스턴스를 저장 합니다. 그런 다음 &lt;code&gt;Worker&lt;/code&gt; 에서 코드를 실행하여 실행을 위해 이미 실행중인 스레드로 전송 하는 메소드를 구현합니다 . 우리는 또한 각 근로자에게 &lt;code&gt;id&lt;/code&gt; 하여 로깅 또는 디버깅시 풀의 여러 작업자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e496da216bd15fab37b8868b5d0249983379dbc2" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; 를 사용하는 대신 이 함수는 주어진 &lt;code&gt;compare&lt;/code&gt; 함수를 사용하여 두 요소의 순서를 결정합니다. 그 외에는 다음과 같습니다.&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c10b23d92f193b5b7c4a31db6e9dd35bde4c84df" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; 를 사용하는 대신 이 함수는 주어진 &lt;code&gt;compare&lt;/code&gt; 함수를 사용하여 두 요소의 순서를 결정합니다. 그 외에도&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78836dae939176c5518d6cb16a8bc88f88e60ed0" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;get&lt;/code&gt; method is generic over the type of the underlying key data, called &lt;code&gt;Q&lt;/code&gt; in the method signature above. It states that &lt;code&gt;K&lt;/code&gt; borrows as a &lt;code&gt;Q&lt;/code&gt; by requiring that &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt;. By additionally requiring &lt;code&gt;Q: Hash + Eq&lt;/code&gt;, it signals the requirement that &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; have implementations of the &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; traits that produce identical results.</source>
          <target state="translated">대신, &lt;code&gt;get&lt;/code&gt; 메소드는 위의 메소드 서명에서 &lt;code&gt;Q&lt;/code&gt; 라고하는 기본 키 데이터 유형에 대해 일반적 입니다. 그것은한다고 &lt;code&gt;K&lt;/code&gt; 가 A와 차용 &lt;code&gt;Q&lt;/code&gt; 것을 요구함으로써 &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt; . 추가적으로 요구함으로써 &lt;code&gt;Q: Hash + Eq&lt;/code&gt; , 그 요구 신호 &lt;code&gt;K&lt;/code&gt; 와 &lt;code&gt;Q&lt;/code&gt; 가 의 구현이 &lt;code&gt;Hash&lt;/code&gt; 및 &lt;code&gt;Eq&lt;/code&gt; 동일한 결과를 생성 Eq 특성을 .</target>
        </trans-unit>
        <trans-unit id="878f7237ad30bf50b95fb9667897fe778bbcf6bb" translate="yes" xml:space="preserve">
          <source>Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it&amp;rsquo;s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-10 shows one way to define a &lt;code&gt;Guess&lt;/code&gt; type that will only create an instance of &lt;code&gt;Guess&lt;/code&gt; if the &lt;code&gt;new&lt;/code&gt; function receives a value between 1 and 100.</source>
          <target state="translated">대신, 우리는 새로운 유형을 만들고 유효성 검사를 함수에 넣어서 모든 곳에서 유효성 검사를 반복하지 않고 유형의 인스턴스를 만들 수 있습니다. 그렇게하면 함수가 서명에서 새 유형을 사용하고 자신이받는 값을 자신있게 사용하는 것이 안전합니다. 리스팅 9-10은 &lt;code&gt;new&lt;/code&gt; 경우 에만 &lt;code&gt;Guess&lt;/code&gt; 인스턴스를 생성하는 &lt;code&gt;Guess&lt;/code&gt; 유형 을 정의하는 한 가지 방법을 보여줍니다. 함수가 1에서 100 사이의 값을 수신하는 .</target>
        </trans-unit>
        <trans-unit id="4262f2636f484912c23478cb754110e371d9c5c5" translate="yes" xml:space="preserve">
          <source>Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.</source>
          <target state="translated">대신 중첩 된 경로를 사용하여 동일한 항목을 한 줄로 범위 내로 가져올 수 있습니다. 경로의 공통 부분과 두 개의 콜론, 그리고 경로의 부분 목록 주위에 중괄호를 지정하여 목록 7-18에 표시된 것처럼이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5890f5912d1fb9403515b5a5574c224c2a726c72" translate="yes" xml:space="preserve">
          <source>Instead, we could write this in a shorter way using &lt;code&gt;if let&lt;/code&gt;. The following code behaves the same as the &lt;code&gt;match&lt;/code&gt; in Listing 6-6:</source>
          <target state="translated">대신 &lt;code&gt;if let&lt;/code&gt; 을 사용하여 더 짧은 방법으로 작성할 수 있습니다. 다음 코드는 &lt;code&gt;match&lt;/code&gt; 하는 것과 동일하게 동작합니다 는 Listing 6-6 .</target>
        </trans-unit>
        <trans-unit id="f97c87a1b2b6afb4bd47b58a7850a17ba4dcea9b" translate="yes" xml:space="preserve">
          <source>Instead, we get the following error that talks about lifetimes:</source>
          <target state="translated">대신 수명에 대해 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e71162b50e657665aeaa9b501b8264cb1685df94" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll change our definition of &lt;code&gt;List&lt;/code&gt; to use &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in place of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, as shown in Listing 15-18. Each &lt;code&gt;Cons&lt;/code&gt; variant will now hold a value and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; pointing to a &lt;code&gt;List&lt;/code&gt;. When we create &lt;code&gt;b&lt;/code&gt;, instead of taking ownership of &lt;code&gt;a&lt;/code&gt;, we&amp;rsquo;ll clone the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that &lt;code&gt;a&lt;/code&gt; is holding, thereby increasing the number of references from one to two and letting &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; share ownership of the data in that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll also clone &lt;code&gt;a&lt;/code&gt; when creating &lt;code&gt;c&lt;/code&gt;, increasing the number of references from two to three. Every time we call &lt;code&gt;Rc::clone&lt;/code&gt;, the reference count to the data within the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; will increase, and the data won&amp;rsquo;t be cleaned up unless there are zero references to it.</source>
          <target state="translated">대신 Listing 15-18에 표시된 것처럼 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하도록 &lt;code&gt;List&lt;/code&gt; 정의를 변경한다 . 각 &lt;code&gt;Cons&lt;/code&gt; 변형은 이제 &lt;code&gt;List&lt;/code&gt; 를 가리키는 값과 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 보유합니다 . 우리가 만들 때 &lt;code&gt;b&lt;/code&gt; 대신 소유권 복용, &lt;code&gt;a&lt;/code&gt; , 우리는 복제 할 수 있습니다 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 것을 들고함으로써이 하나에서 참조의 수를 증가시키는되고 와 &lt;code&gt;b&lt;/code&gt; 에서 데이터의 공유 소유권을 것을 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; . 우리는 복제도거야 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 를 만들 때참조 수를 2 개에서 3 개로 늘 렸습니다. &lt;code&gt;Rc::clone&lt;/code&gt; 을 호출 할 때마다 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 내의 데이터에 대한 참조 횟수 가 증가하며, 참조가없는 경우 데이터가 정리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2890fe24db6f7388a46470ac6834b80784db6337" translate="yes" xml:space="preserve">
          <source>Instructions can execute in a different order from the one we define, due to various reasons:</source>
          <target state="translated">명령어는 다양한 이유로 인해 정의한 것과 다른 순서로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74294f827b0d4541ba12662271114a470d6d7a4" translate="yes" xml:space="preserve">
          <source>IntErrorKind</source>
          <target state="translated">IntErrorKind</target>
        </trans-unit>
        <trans-unit id="80fb7220d8146322b259aee21dfef8944e427bb7" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow</source>
          <target state="translated">IntErrorKind::borrow</target>
        </trans-unit>
        <trans-unit id="bb7aa40e4b4db6e736d2b09e30f31443f1c9b44c" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow_mut</source>
          <target state="translated">IntErrorKind::borrow_mut</target>
        </trans-unit>
        <trans-unit id="86f2a2b8f3ab0b9d3e18ee8e7279ac3646f5e5b6" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone</source>
          <target state="translated">IntErrorKind::clone</target>
        </trans-unit>
        <trans-unit id="dd987594d4a6731556fb4db2a25b883f8e6e834a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_from</source>
          <target state="translated">IntErrorKind::clone_from</target>
        </trans-unit>
        <trans-unit id="8f1809c6588a2cc665ccd543289e14a938828a70" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_into</source>
          <target state="translated">IntErrorKind::clone_into</target>
        </trans-unit>
        <trans-unit id="a5e2ed2cdfa8d2140437ae0a8783a450793b17a2" translate="yes" xml:space="preserve">
          <source>IntErrorKind::eq</source>
          <target state="translated">IntErrorKind::eq</target>
        </trans-unit>
        <trans-unit id="92fce40d27d225b47d39433e8ff156d8c2c93e18" translate="yes" xml:space="preserve">
          <source>IntErrorKind::fmt</source>
          <target state="translated">IntErrorKind::fmt</target>
        </trans-unit>
        <trans-unit id="cd16b5df7c131824209cf18f2e5abfbebb79b75a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::from</source>
          <target state="translated">IntErrorKind::from</target>
        </trans-unit>
        <trans-unit id="e6625420510ba7fab278784b2593fb38c7566390" translate="yes" xml:space="preserve">
          <source>IntErrorKind::into</source>
          <target state="translated">IntErrorKind::into</target>
        </trans-unit>
        <trans-unit id="9d0115c16bd4f87138d516953bbe461d1bf9ec02" translate="yes" xml:space="preserve">
          <source>IntErrorKind::ne</source>
          <target state="translated">IntErrorKind::ne</target>
        </trans-unit>
        <trans-unit id="14958c3a69f5e70cdde8bcf9555c598ab9bb336b" translate="yes" xml:space="preserve">
          <source>IntErrorKind::to_owned</source>
          <target state="translated">IntErrorKind::to_owned</target>
        </trans-unit>
        <trans-unit id="6415d36e18efe91e53b209d52b6293cb58ff6bfa" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_from</source>
          <target state="translated">IntErrorKind::try_from</target>
        </trans-unit>
        <trans-unit id="03f332b4c41b3659819ff1f646ef37a2e67d10fd" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_into</source>
          <target state="translated">IntErrorKind::try_into</target>
        </trans-unit>
        <trans-unit id="b726776952bee36d5bafae04149385980bc0b309" translate="yes" xml:space="preserve">
          <source>IntErrorKind::type_id</source>
          <target state="translated">IntErrorKind::type_id</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="65424b5083b7bb599ce3d3b760be23e671c074b2" translate="yes" xml:space="preserve">
          <source>Integer Overflow</source>
          <target state="translated">정수 오버플로</target>
        </trans-unit>
        <trans-unit id="dee2f95e5c81fdaa601cb7ca5b7396c9d7532488" translate="yes" xml:space="preserve">
          <source>Integer Types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="6977c92d9e82d5b8f471a2623681e1d1d400b4fb" translate="yes" xml:space="preserve">
          <source>Integer and floating point literals are stringified in order to be concatenated.</source>
          <target state="translated">정수 및 부동 소수점 리터럴은 연결하기 위해 문자열 화됩니다.</target>
        </trans-unit>
        <trans-unit id="eea9a8e4af8d6805a657b383a298ba05a67ec8a4" translate="yes" xml:space="preserve">
          <source>Integer is too large to store in target integer type.</source>
          <target state="translated">정수가 너무 커서 대상 정수 유형에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25419a68a3cc357926618f13c044ff7b1347aa8b" translate="yes" xml:space="preserve">
          <source>Integer is too small to store in target integer type.</source>
          <target state="translated">정수가 너무 작아 대상 정수 유형에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="13c9f1f069c2155e025409b7880e9bda6c11b765" translate="yes" xml:space="preserve">
          <source>Integer literals</source>
          <target state="translated">정수 리터럴</target>
        </trans-unit>
        <trans-unit id="f64049bb9bdfd33c50813111908ece46c327c630" translate="yes" xml:space="preserve">
          <source>Integer operators will panic when they overflow when compiled in debug mode. The &lt;code&gt;-C debug-assertions&lt;/code&gt; and &lt;code&gt;-C overflow-checks&lt;/code&gt; compiler flags can be used to control this more directly. The following things are considered to be overflow:</source>
          <target state="translated">정수 연산자는 디버그 모드에서 컴파일 될 때 오버 플로우 될 때 패닉 상태가됩니다. &lt;code&gt;-C debug-assertions&lt;/code&gt; 및 &lt;code&gt;-C overflow-checks&lt;/code&gt; 컴파일러 플래그보다 직접 제어하는데 사용될 수있다. 다음은 오버플로로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="16d3c89b38e84e433e4fbd3b3a5bad55571258af" translate="yes" xml:space="preserve">
          <source>Integer or Float type</source>
          <target state="translated">정수 또는 실수 유형</target>
        </trans-unit>
        <trans-unit id="3a26a4e37ae1b89c4b86a6d96e9ccef63b9ca764" translate="yes" xml:space="preserve">
          <source>Integer overflow</source>
          <target state="translated">정수 오버플로</target>
        </trans-unit>
        <trans-unit id="60c11385ec83a73512788efd527bda9740331202" translate="yes" xml:space="preserve">
          <source>Integer suffixes</source>
          <target state="translated">정수 접미사</target>
        </trans-unit>
        <trans-unit id="f59b20cbbdd5ddf3c9bd85fd552a52f66ae334d9" translate="yes" xml:space="preserve">
          <source>Integer type</source>
          <target state="translated">정수형</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="19f28971f5db0ac7dee3fee9af716d1da8917af3" translate="yes" xml:space="preserve">
          <source>Integer types (u8, i8, u16, i16, usize, isize, etc.).</source>
          <target state="translated">정수 유형 (u8, i8, u16, i16, usize, isize 등).</target>
        </trans-unit>
        <trans-unit id="a83667e8fbc7d07069b4ce287d78c06adec56630" translate="yes" xml:space="preserve">
          <source>Integers and other types implementing &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; are unaffected by &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 를 구현하는 정수 및 기타 유형 은 &lt;code&gt;drop&lt;/code&gt; 의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="036a5d47efaf84af91b96bca27d0e3394108b032" translate="yes" xml:space="preserve">
          <source>Integration Tests</source>
          <target state="translated">통합 테스트</target>
        </trans-unit>
        <trans-unit id="d9b3c69227b8b09ee6557a63d6eadc1309909958" translate="yes" xml:space="preserve">
          <source>Integration Tests for Binary Crates</source>
          <target state="translated">이진 상자에 대한 통합 테스트</target>
        </trans-unit>
        <trans-unit id="22d0f1d4f5d8a4b65c3ed4d1e121eaf3dc6e87d2" translate="yes" xml:space="preserve">
          <source>Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.</source>
          <target state="translated">힙에 할당하는 것 (Error :: new를 통한 일반 구성의 경우)이 너무 비싸기 때문에 사용자에게 노출되지 않은 오류에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b67f9d330a2d3ef64e53c30ab32b2a3ac9f06b6" translate="yes" xml:space="preserve">
          <source>Intense! In effect, this error message means that Rust doesn&amp;rsquo;t understand how to add an &lt;code&gt;i8&lt;/code&gt; and an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;, because they&amp;rsquo;re different types. When we have a value of a type like &lt;code&gt;i8&lt;/code&gt; in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (or whatever type of value we&amp;rsquo;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</source>
          <target state="translated">심한! 실제로이 오류 메시지는 Rust가 유형이 다르기 때문에 &lt;code&gt;i8&lt;/code&gt; 및 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; 을 추가하는 방법을 이해하지 못했음을 의미합니다 . Rust에 &lt;code&gt;i8&lt;/code&gt; 과 같은 유형의 값이 있으면 컴파일러는 항상 유효한 값을 갖습니다. 해당 값을 사용하기 전에 null을 확인하지 않고도 자신있게 진행할 수 있습니다. &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (또는 우리가 사용하는 모든 유형의 값)이 있을 때만 값을 가질 가능성에 대해 걱정해야하며 컴파일러는 값을 사용하기 전에 해당 경우를 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ffafe2f71610dfdf28d74f6f54bc9015fbb24203" translate="yes" xml:space="preserve">
          <source>Interestingly, the Rust language has &lt;em&gt;very&lt;/em&gt; few concurrency features. Almost every concurrency feature we&amp;rsquo;ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</source>
          <target state="translated">흥미롭게도 Rust 언어에는 동시성 기능 이 &lt;em&gt;거의&lt;/em&gt; 없습니다. 이 장에서 지금까지 이야기 한 거의 모든 동시성 기능은 언어가 아니라 표준 라이브러리의 일부입니다. 동시성 처리 옵션은 언어 나 표준 라이브러리로 제한되지 않습니다. 자체 동시성 기능을 작성하거나 다른 사람이 작성한 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bdfe87f76bf3a6413dde02708bb83e04770512" translate="yes" xml:space="preserve">
          <source>Interior Mutability</source>
          <target state="translated">내부 돌연변이</target>
        </trans-unit>
        <trans-unit id="88bf37967a115d0f3e4ede63c58d62ebf4f74d5a" translate="yes" xml:space="preserve">
          <source>Interior Mutability: A Mutable Borrow to an Immutable Value</source>
          <target state="translated">내부 돌연변이 성 : 불변 가치에 대한 가변 차용</target>
        </trans-unit>
        <trans-unit id="bb56d65f2c6cb59165a8429fad875c4b21a44fc9" translate="yes" xml:space="preserve">
          <source>Interior mutability is required.</source>
          <target state="translated">내부 돌연변이가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca7ba6473fcf9f5318db96e54bb8153323ab66d4" translate="yes" xml:space="preserve">
          <source>Internal Representation</source>
          <target state="translated">내부 대표</target>
        </trans-unit>
        <trans-unit id="951194525a57d9119eb003c4910a0f82fea56f08" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.max&quot;&gt;&lt;code&gt;Ord::max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;trait.ord#method.max&quot;&gt; &lt;code&gt;Ord::max&lt;/code&gt; &lt;/a&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="acf9ba348896a745b094371c98fa0f28a4195e87" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.min&quot;&gt;&lt;code&gt;Ord::min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;trait.ord#method.min&quot;&gt; &lt;code&gt;Ord::min&lt;/code&gt; &lt;/a&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f8e983bc961f2f79520b6f7bb3705df394320c6d" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::max&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Ord::max&lt;/code&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="944d65bab4f9ee9f9e2c120271148593d01f1819" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::min&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Ord::min&lt;/code&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="068003ac53324bf3f0b64c29929ac10bbe1c05ab" translate="yes" xml:space="preserve">
          <source>Internet socket addresses consist of an &lt;a href=&quot;enum.ipaddr&quot;&gt;IP address&lt;/a&gt;, a 16-bit port number, as well as possibly some version-dependent additional information. See &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;'s respective documentation for more details.</source>
          <target state="translated">인터넷 소켓 주소는 &lt;a href=&quot;enum.ipaddr&quot;&gt;IP 주소&lt;/a&gt; , 16 비트 포트 번호 및 버전 별 추가 정보로 구성됩니다. 자세한 내용은 &lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt; 의 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff358fd17c71b9310a296d32bf0fad9d3ef93b34" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;src&lt;/code&gt; as having type &lt;code&gt;&amp;amp;U&lt;/code&gt;, and then reads &lt;code&gt;src&lt;/code&gt; without moving the contained value.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 를 &lt;code&gt;&amp;amp;U&lt;/code&gt; 유형으로 해석 한 다음 포함 된 값을 이동하지 않고 &lt;code&gt;src&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6a36b9396eb19f7860ffbd9cb812832709b1a0ee" translate="yes" xml:space="preserve">
          <source>Interrupted operations can typically be retried.</source>
          <target state="translated">중단 된 작업은 일반적으로 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="d937d21f811516b74380ee512b99e31251a84531" translate="yes" xml:space="preserve">
          <source>Into</source>
          <target state="translated">Into</target>
        </trans-unit>
        <trans-unit id="5bfe78f7766048c0532cc66994c73d1126acb835" translate="yes" xml:space="preserve">
          <source>Into::into</source>
          <target state="translated">Into::into</target>
        </trans-unit>
        <trans-unit id="44f9db19d74f7cdef0547d820fed0d75c60f0beb" translate="yes" xml:space="preserve">
          <source>IntoFuture</source>
          <target state="translated">IntoFuture</target>
        </trans-unit>
        <trans-unit id="77f5dd8de42c3fb03062223e3c47c92129133f82" translate="yes" xml:space="preserve">
          <source>IntoInnerError</source>
          <target state="translated">IntoInnerError</target>
        </trans-unit>
        <trans-unit id="3f3157b39d55c6291f5fe8213b30cc7d15253d48" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow</source>
          <target state="translated">IntoInnerError::borrow</target>
        </trans-unit>
        <trans-unit id="8dfa8d9b4ac06c1a6626ce8031f10e6de0dc0387" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow_mut</source>
          <target state="translated">IntoInnerError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7c332dec4b157cd5d25efcbb73292737fbcafa2a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::cause</source>
          <target state="translated">IntoInnerError::cause</target>
        </trans-unit>
        <trans-unit id="824ab9811aae7de9a48a47b240a825897e788412" translate="yes" xml:space="preserve">
          <source>IntoInnerError::description</source>
          <target state="translated">IntoInnerError::description</target>
        </trans-unit>
        <trans-unit id="83d6a8f5f81bfae0852073773b72a21c220d1541" translate="yes" xml:space="preserve">
          <source>IntoInnerError::error</source>
          <target state="translated">IntoInnerError::error</target>
        </trans-unit>
        <trans-unit id="b1804b3db5a18e0f8ea6f6cff9edd76e45db12ed" translate="yes" xml:space="preserve">
          <source>IntoInnerError::fmt</source>
          <target state="translated">IntoInnerError::fmt</target>
        </trans-unit>
        <trans-unit id="74ec382ed3daa2186fca394930d62ea36a8c17d2" translate="yes" xml:space="preserve">
          <source>IntoInnerError::from</source>
          <target state="translated">IntoInnerError::from</target>
        </trans-unit>
        <trans-unit id="f77ca8c3b2a09378cb7ab11a7034bfe301502366" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into</source>
          <target state="translated">IntoInnerError::into</target>
        </trans-unit>
        <trans-unit id="b64935fe113c6776466d9f925b72b58f10a95d0a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into_inner</source>
          <target state="translated">IntoInnerError::into_inner</target>
        </trans-unit>
        <trans-unit id="b98cd1e7eff5f2d406e34cac12fb4fec6a0205d4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::source</source>
          <target state="translated">IntoInnerError::source</target>
        </trans-unit>
        <trans-unit id="b27666ff3803b78aee0d747dc0d776b1f36b641a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::to_string</source>
          <target state="translated">IntoInnerError::to_string</target>
        </trans-unit>
        <trans-unit id="0b54c908cc8363881d303f189af2d3a384fbe644" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_from</source>
          <target state="translated">IntoInnerError::try_from</target>
        </trans-unit>
        <trans-unit id="496358b49c2805d5e6526e43d48129b6eb94e5f4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_into</source>
          <target state="translated">IntoInnerError::try_into</target>
        </trans-unit>
        <trans-unit id="b48124715dd42f1aa190750b7aa9535327b5b2db" translate="yes" xml:space="preserve">
          <source>IntoInnerError::type_id</source>
          <target state="translated">IntoInnerError::type_id</target>
        </trans-unit>
        <trans-unit id="d5bc3a63a8bde6cc5fb0c0c11c8f6e6a2d150f75" translate="yes" xml:space="preserve">
          <source>IntoIter</source>
          <target state="translated">IntoIter</target>
        </trans-unit>
        <trans-unit id="169272921e3355905d2215419cf69783d5e1115d" translate="yes" xml:space="preserve">
          <source>IntoIter::all</source>
          <target state="translated">IntoIter::all</target>
        </trans-unit>
        <trans-unit id="a15574f60107e9d0464eff7cacee4bccf74dd72e" translate="yes" xml:space="preserve">
          <source>IntoIter::any</source>
          <target state="translated">IntoIter::any</target>
        </trans-unit>
        <trans-unit id="51c36bf4138559f11f65b74500f686e06c1f07c6" translate="yes" xml:space="preserve">
          <source>IntoIter::as_mut_slice</source>
          <target state="translated">IntoIter::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="375d884ce90ecd76e63b6eebc5d52f38165f98ea" translate="yes" xml:space="preserve">
          <source>IntoIter::as_slice</source>
          <target state="translated">IntoIter::as_slice</target>
        </trans-unit>
        <trans-unit id="945728e84b93878ccde99bc6b6c902e3add25ce9" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow</source>
          <target state="translated">IntoIter::borrow</target>
        </trans-unit>
        <trans-unit id="4db752fa4ec7a9c0d095aaf0baac141df030f531" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow_mut</source>
          <target state="translated">IntoIter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="aaf973384105c3d31f532c4ad4e6dc925ca8038e" translate="yes" xml:space="preserve">
          <source>IntoIter::by_ref</source>
          <target state="translated">IntoIter::by_ref</target>
        </trans-unit>
        <trans-unit id="bcd8f637007c65386e7e2794c338143218170c6f" translate="yes" xml:space="preserve">
          <source>IntoIter::chain</source>
          <target state="translated">IntoIter::chain</target>
        </trans-unit>
        <trans-unit id="4b7971718173fafccbf11a50c2db440035e10f18" translate="yes" xml:space="preserve">
          <source>IntoIter::clone</source>
          <target state="translated">IntoIter::clone</target>
        </trans-unit>
        <trans-unit id="cdb70f02920a7096b80eae8222a39e9acc9946ce" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_from</source>
          <target state="translated">IntoIter::clone_from</target>
        </trans-unit>
        <trans-unit id="a82a0721b8481c0815dcd502e84574a2073e6632" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_into</source>
          <target state="translated">IntoIter::clone_into</target>
        </trans-unit>
        <trans-unit id="50371856061d6c57455d0ce1dfd33e8f9cb33e2b" translate="yes" xml:space="preserve">
          <source>IntoIter::cloned</source>
          <target state="translated">IntoIter::cloned</target>
        </trans-unit>
        <trans-unit id="e8ad516621215eb3804081635021e01bb0d15b51" translate="yes" xml:space="preserve">
          <source>IntoIter::cmp</source>
          <target state="translated">IntoIter::cmp</target>
        </trans-unit>
        <trans-unit id="8fbe1060e2b348d75cd8e260134f4152fb629580" translate="yes" xml:space="preserve">
          <source>IntoIter::collect</source>
          <target state="translated">IntoIter::collect</target>
        </trans-unit>
        <trans-unit id="49b1597675bf50c85b1e156757a3fba15d6379b2" translate="yes" xml:space="preserve">
          <source>IntoIter::copied</source>
          <target state="translated">IntoIter::copied</target>
        </trans-unit>
        <trans-unit id="1b07d7fdfbcbc77dd6f739fc3349c3f2c936082e" translate="yes" xml:space="preserve">
          <source>IntoIter::count</source>
          <target state="translated">IntoIter::count</target>
        </trans-unit>
        <trans-unit id="abc24391b60331e5b16547b639bace5c08a577cf" translate="yes" xml:space="preserve">
          <source>IntoIter::cycle</source>
          <target state="translated">IntoIter::cycle</target>
        </trans-unit>
        <trans-unit id="076c1a1b603e193e4eb4e0757f8c8cf292b8dfb5" translate="yes" xml:space="preserve">
          <source>IntoIter::drop</source>
          <target state="translated">IntoIter::drop</target>
        </trans-unit>
        <trans-unit id="c4d617218636a45df4ca846f67499ffba56d0009" translate="yes" xml:space="preserve">
          <source>IntoIter::enumerate</source>
          <target state="translated">IntoIter::enumerate</target>
        </trans-unit>
        <trans-unit id="203a6dcfb8a13fd0add782bc832058504307c28c" translate="yes" xml:space="preserve">
          <source>IntoIter::eq</source>
          <target state="translated">IntoIter::eq</target>
        </trans-unit>
        <trans-unit id="c908d336a9125db6fbd5e895b62999e14ef83fab" translate="yes" xml:space="preserve">
          <source>IntoIter::filter</source>
          <target state="translated">IntoIter::filter</target>
        </trans-unit>
        <trans-unit id="dffdf83b64aeaec0f8093868f1a7bbb32780e9ca" translate="yes" xml:space="preserve">
          <source>IntoIter::filter_map</source>
          <target state="translated">IntoIter::filter_map</target>
        </trans-unit>
        <trans-unit id="ab410a5d7b7cbc92b7134e524269b1fa848fc30b" translate="yes" xml:space="preserve">
          <source>IntoIter::find</source>
          <target state="translated">IntoIter::find</target>
        </trans-unit>
        <trans-unit id="27ee1265a09c796da003def69a36560ceff2b181" translate="yes" xml:space="preserve">
          <source>IntoIter::find_map</source>
          <target state="translated">IntoIter::find_map</target>
        </trans-unit>
        <trans-unit id="eddd95067e023ebec6158e4fd0749c395bbce3b5" translate="yes" xml:space="preserve">
          <source>IntoIter::flat_map</source>
          <target state="translated">IntoIter::flat_map</target>
        </trans-unit>
        <trans-unit id="24f22711986263a8d0e02c113bb93328c331ce4c" translate="yes" xml:space="preserve">
          <source>IntoIter::flatten</source>
          <target state="translated">IntoIter::flatten</target>
        </trans-unit>
        <trans-unit id="e538b5a92b4ad8916bfeef8710693a5e5266e987" translate="yes" xml:space="preserve">
          <source>IntoIter::fmt</source>
          <target state="translated">IntoIter::fmt</target>
        </trans-unit>
        <trans-unit id="d818332c13e9dac3c39cfd50a50265cfaea983ac" translate="yes" xml:space="preserve">
          <source>IntoIter::fold</source>
          <target state="translated">IntoIter::fold</target>
        </trans-unit>
        <trans-unit id="ebce24dad77f86422316868125c1ce1b1376c47d" translate="yes" xml:space="preserve">
          <source>IntoIter::for_each</source>
          <target state="translated">IntoIter::for_each</target>
        </trans-unit>
        <trans-unit id="63d5fee827e27caa7f9e5b809ff35ace75693193" translate="yes" xml:space="preserve">
          <source>IntoIter::from</source>
          <target state="translated">IntoIter::from</target>
        </trans-unit>
        <trans-unit id="d10213dec7222893569b1e32a4313a41a6aaecb0" translate="yes" xml:space="preserve">
          <source>IntoIter::fuse</source>
          <target state="translated">IntoIter::fuse</target>
        </trans-unit>
        <trans-unit id="2c8a9a1c31b0f9b10030a7c20db1f8dae0614589" translate="yes" xml:space="preserve">
          <source>IntoIter::ge</source>
          <target state="translated">IntoIter::ge</target>
        </trans-unit>
        <trans-unit id="104a30acd770869920244c22e6c1a727cdee6dae" translate="yes" xml:space="preserve">
          <source>IntoIter::gt</source>
          <target state="translated">IntoIter::gt</target>
        </trans-unit>
        <trans-unit id="ab8d2e8c457b63ffae7769711a00e1a87b2a56eb" translate="yes" xml:space="preserve">
          <source>IntoIter::inspect</source>
          <target state="translated">IntoIter::inspect</target>
        </trans-unit>
        <trans-unit id="c0c222348756fc6dca4ff42b109916a4d5aa1041" translate="yes" xml:space="preserve">
          <source>IntoIter::into</source>
          <target state="translated">IntoIter::into</target>
        </trans-unit>
        <trans-unit id="00014741248dda82e6a92af65524e8bc527d5270" translate="yes" xml:space="preserve">
          <source>IntoIter::into_iter</source>
          <target state="translated">IntoIter::into_iter</target>
        </trans-unit>
        <trans-unit id="5136432030a36a1b23033a0d753895604b4149ac" translate="yes" xml:space="preserve">
          <source>IntoIter::is_empty</source>
          <target state="translated">IntoIter::is_empty</target>
        </trans-unit>
        <trans-unit id="cf791dcb18f1b7d93faf9bdd64add013d8076499" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted</source>
          <target state="translated">IntoIter::is_sorted</target>
        </trans-unit>
        <trans-unit id="5c6daaffe95fe047d7827bfe50f3fd317d40c563" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by</source>
          <target state="translated">IntoIter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9f7c1ed14fd6d8b0ea5624c99850ff1ba4ac8f4c" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by_key</source>
          <target state="translated">IntoIter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e39349aed40aa6fcfd458252b9c0e111206b7d16" translate="yes" xml:space="preserve">
          <source>IntoIter::last</source>
          <target state="translated">IntoIter::last</target>
        </trans-unit>
        <trans-unit id="965a66efe77546764045f5f96e42028dbb177b19" translate="yes" xml:space="preserve">
          <source>IntoIter::le</source>
          <target state="translated">IntoIter::le</target>
        </trans-unit>
        <trans-unit id="22be990e0e582b87c69cd8c67de2cfd9920d77cd" translate="yes" xml:space="preserve">
          <source>IntoIter::len</source>
          <target state="translated">IntoIter::len</target>
        </trans-unit>
        <trans-unit id="8440a9053eaee6916d3cec75da248b9b8410507f" translate="yes" xml:space="preserve">
          <source>IntoIter::lt</source>
          <target state="translated">IntoIter::lt</target>
        </trans-unit>
        <trans-unit id="e3e2d404675aba8735567f55b57c588d0c0c351a" translate="yes" xml:space="preserve">
          <source>IntoIter::map</source>
          <target state="translated">IntoIter::map</target>
        </trans-unit>
        <trans-unit id="181026e325e14528b026dfe68716b7b26ecd2d2d" translate="yes" xml:space="preserve">
          <source>IntoIter::max</source>
          <target state="translated">IntoIter::max</target>
        </trans-unit>
        <trans-unit id="dd9a47d87f8a0e2db21c65ae146ddcfdf6e0f952" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by</source>
          <target state="translated">IntoIter::max_by</target>
        </trans-unit>
        <trans-unit id="32723c1a1514dde11ed20c922fc56eff6425fcc8" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by_key</source>
          <target state="translated">IntoIter::max_by_key</target>
        </trans-unit>
        <trans-unit id="c528958b5dc23955203383c2f66331a5a91f6f86" translate="yes" xml:space="preserve">
          <source>IntoIter::min</source>
          <target state="translated">IntoIter::min</target>
        </trans-unit>
        <trans-unit id="390fd21e220a5da046b34c827add37c65b895f97" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by</source>
          <target state="translated">IntoIter::min_by</target>
        </trans-unit>
        <trans-unit id="05a738d3c9912a808e8d6c464d2a7c6d5e602efc" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by_key</source>
          <target state="translated">IntoIter::min_by_key</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
