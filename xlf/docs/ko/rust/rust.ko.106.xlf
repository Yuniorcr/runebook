<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">벡터는 또한 &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt; 특성을 통해 인덱싱을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">벡터는 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 이상을 할당하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">벡터에는 &lt;code&gt;O(1)&lt;/code&gt; 인덱싱, &lt;code&gt;O(1)&lt;/code&gt; 푸시 (끝) 및 &lt;code&gt;O(1)&lt;/code&gt; 팝 (끝)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">벡터, 문자열 및 해시 맵은 데이터를 저장, 액세스 및 수정해야 할 때 프로그램에 필요한 많은 기능을 제공합니다. 다음은 해결해야 할 몇 가지 연습입니다.</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Verbatim UNC 접두사는 &lt;code&gt;\?\UNC\&lt;/code&gt; 바로 뒤에 서버의 호스트 이름과 공유 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">축 어적 UNC 접두사는 &lt;code&gt;\\?\UNC\&lt;/code&gt; 바로 뒤에 서버의 호스트 이름과 공유 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 디스크 접두사, 예를 들어, &lt;code&gt;\?\C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="translated">축 어적 디스크 접두사, 예 : &lt;code&gt;\\?\C:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">완전 디스크 접두사는 &lt;code&gt;\?\&lt;/code&gt; 바로 다음에 드라이브 문자와 &lt;code&gt;:\&lt;/code&gt; 로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">축 어적 디스크 접두사는 &lt;code&gt;\\?\&lt;/code&gt; 바로 뒤에 드라이브 문자와 &lt;code&gt;:&lt;/code&gt; 으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사 윈도우 '를 사용하여 &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N은&lt;/strong&gt; aming &lt;strong&gt;C의&lt;/strong&gt; onvention를&lt;/em&gt; 예를 들면, &lt;code&gt;\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사 윈도우 '를 사용하여 &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N은&lt;/strong&gt; aming &lt;strong&gt;C의&lt;/strong&gt; onvention을&lt;/em&gt; 예를 들어, &lt;code&gt;\\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사, 예를 들면, &lt;code&gt;\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">축 어적 접두사, 예 : &lt;code&gt;\\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">동사 접두사는 &lt;code&gt;\?\&lt;/code&gt; 바로 뒤에 주어진 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">축 어적 접두사는 &lt;code&gt;\\?\&lt;/code&gt; 바로 뒤에 주어진 구성 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">필드 이름을 잘못 입력하지 않았거나 필드가 존재하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">변경 불가능한 참조를 통해 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 읽기 전용으로 프로그램의 여러 부분간에 데이터를 공유 할 수 있습니다. 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 너무 여러 변경 가능한 참조를 가질 수, 당신은 제 4 장에서 논의 된 차입 규칙 중 하나를 위반할 수 : 같은 장소에 여러 개의 가변 차용 데이터 인종과 불일치가 발생할 수 있습니다. 그러나 데이터를 변경하는 것은 매우 유용합니다! 다음 섹션에서는 이러한 불변성 제한을 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 위해 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용할 수 있는 내부 변이 패턴과 RefCell &amp;lt;T&amp;gt; 유형에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">기본 데이터를 원본 데이터의 하위 슬라이스로 봅니다.</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 등의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 등의 문제가 발생할 수 있습니다. 예를 들어 , 포인터에서 C &lt;code&gt;char&lt;/code&gt; 배열 및 &lt;code&gt;size_t&lt;/code&gt; 에 대한 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 을 작성하는 &lt;strong&gt;것은&lt;/strong&gt; 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 것과 같은 문제가 발생할 수 있습니다. 예를 들어, 길이가 &lt;code&gt;size_t&lt;/code&gt; 인 C &lt;code&gt;char&lt;/code&gt; 배열에 대한 포인터에서 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 을 빌드하는 &lt;strong&gt;것은&lt;/strong&gt; 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 할당자가 정렬에 관심이 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 두 가지 유형이 서로 다른 정렬을 갖기 때문에 Vec &amp;lt;u16&amp;gt; 및 해당 길이 에서 하나를 빌드하는 것도 안전하지 않습니다 . 버퍼는 정렬 2 ( &lt;code&gt;u16&lt;/code&gt; 의 경우 ) 로 할당 되었지만 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 로 바꾼 후 정렬 1로 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">가시성 및 개인 정보</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="translated">가시성은 현재 항목의 조상이 아닌 모듈로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 있지만 &lt;code&gt;other&lt;/code&gt; 것은 아닌 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 있지만 &lt;code&gt;other&lt;/code&gt; 것은 아닌 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">교차점을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 에있는 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">교차점을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 에있는 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">대칭 차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 이지만 둘 다 아닌 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">대칭 차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 이지만 둘 다 아닌 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">합집합을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 모든 값을 중복없이 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">합집합을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 의 모든 값을 중복없이 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; 및 &lt;code&gt;weak_count&lt;/code&gt; 의 변경 사항 시각화</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">휘발성 작업은 I / O 메모리에서 작동하도록 만들어졌으며 다른 휘발성 작업에서 컴파일러에 의해 제거되거나 재정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">&lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; 핸들을 사용하여 모든 스레드가 완료되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">시간 종료가 완료되기를 기다리는 중 :</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">연관된 스레드가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">자식이 완전히 종료 될 때까지 기다렸다가 종료 한 상태를 반환합니다. 이 함수는 한 번 이상 호출 된 후에도 동일한 반환 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">지정된 기간이 지나면 시간이 초과되어 알림을 받기 위해이 조건 변수를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">지정된 기간이 지나면 시간이 초과되어 알림을 받기 위해이 조건 변수를 기다립니다. 가짜 깨우기는이 기능을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">이와 관련된 작업 일어나 &lt;code&gt;Waker&lt;/code&gt; 소비없이 &lt;code&gt;Waker&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Waker&lt;/code&gt; 와 연관된 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">이 condvar의 모든 차단 스레드를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">이 condvar에서 하나의 차단 된 스레드를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">경고 : &lt;code&gt;hash_builder&lt;/code&gt; 는 일반적으로 무작위로 생성되며 HashMaps 가 많은 충돌과 성능 저하를 유발하는 공격에 저항 할 수 있도록 설계되었습니다. 이 기능을 사용하여 수동으로 설정하면 DoS 공격 경로가 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">경고 : &lt;code&gt;hasher&lt;/code&gt; 는 일반적으로 무작위로 생성되며 &lt;code&gt;HashSet&lt;/code&gt; 이 많은 충돌과 성능 저하를 유발하는 공격에 저항 할 수 있도록 설계되었습니다 . 이 기능을 사용하여 수동으로 설정하면 DoS 공격 경로가 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">경고 : 임의로 설정 한 구성 옵션이 컴파일러 설정 구성 옵션과 동일한 값을 가질 수 있습니다. 예를 들어, Windows 대상으로 컴파일하는 동안 &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; 를 수행하고 &lt;code&gt;unix&lt;/code&gt; 및 &lt;code&gt;windows&lt;/code&gt; 구성 옵션을 동시에 설정할 수 있습니다. 실제로 이렇게하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">경고 : 사이의 중요한 차이가 있습니다 &lt;code&gt;enum&lt;/code&gt; C 언어와 녹의 &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;현장 덜 열거&lt;/a&gt; 이 표현으로는. C 의 &lt;code&gt;enum&lt;/code&gt; 은 대부분 &lt;code&gt;typedef&lt;/code&gt; 와 일부 명명 된 상수입니다. 즉, &lt;code&gt;enum&lt;/code&gt; 유형 의 객체는 모든 정수 값을 보유 할 수 있습니다. 예를 들어, 이것은 종종 &lt;code&gt;C&lt;/code&gt; 의 비트 플래그에 사용됩니다 . 대조적으로, Rust의 &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enum&lt;/a&gt; 은 합법적으로 불분명 한 값을 보유 할 수 있으며 다른 모든 것은 &lt;a href=&quot;behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. 따라서 FFI에서 필드없는 열거를 사용하여 C &lt;code&gt;enum&lt;/code&gt; 을 모델링하는 것은 종종 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">경고 : C 언어의 열거 형과이 표현으로 Rust의 C와 같은 열거 &lt;code&gt;enum&lt;/code&gt; 간에는 중요한 차이점 이 있습니다. C 의 &lt;code&gt;enum&lt;/code&gt; 은 대부분 &lt;code&gt;typedef&lt;/code&gt; 와 이름이 지정된 상수입니다. 즉, &lt;code&gt;enum&lt;/code&gt; 형 의 객체는 모든 정수 값을 보유 할 수 있습니다. 예를 들어, 이것은 종종 &lt;code&gt;C&lt;/code&gt; 의 비트 플래그에 사용됩니다 . 대조적으로 Rust의 C와 같은 열거 형은 법적으로 만 판별 가능한 값을 보유 할 수 있으며 다른 모든 것은 정의되지 않은 동작입니다. 따라서, C의 모델에 C와 같은 FFI에 열거를 사용하여 &lt;code&gt;enum&lt;/code&gt; 종종 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">경고 :이 책은 불완전합니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 설명되어 있지 않은 내용은 &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">경고 :이 책은 불완전합니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 설명되지 않은 내용은 &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">경고 : 이것은 경고 예입니다.</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경고 :이 의사 코드는 명확성을 위해 오버플로 문제를 무시하는 순진한 알고리즘을 사용합니다. 실제 코드에서 메모리 레이아웃 계산을 수행하려면 &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">경고 : &lt;code&gt;no_std&lt;/code&gt; 를 사용해도 표준 라이브러리가 연결되지 않습니다. &lt;code&gt;extern crate std;&lt;/code&gt; 를 넣는 것은 여전히 ​​유효합니다 . 상자에 의존하고 종속성도 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">언어에서 소리가 나지 않거나 언어 기능의 혼란스러운 상호 작용을 나타내는 경고는 특별한 경고 상자에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">해지에 성공 했습니까? 신호 종료는 성공으로 간주되지 않으며 성공은 제로 종료 상태로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">변수 및 데이터 상호 작용 방법 : 복제</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">변수 및 데이터 상호 작용 방법 : 이동</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">&lt;code&gt;use minigrep::Config&lt;/code&gt; 행을 추가 하여 &lt;code&gt;Config&lt;/code&gt; 유형을 라이브러리 상자에서 이진 상자 범위 로 가져오고 &lt;code&gt;run&lt;/code&gt; 함수 앞에 상자 이름을 붙입니다. 이제 모든 기능이 연결되어 작동해야합니다. &lt;code&gt;cargo run&lt;/code&gt; 프로그램을 실행 하고 모든 것이 올바르게 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">빈 문자열 슬라이스를 반환하는 &lt;code&gt;content&lt;/code&gt; 메소드에 대한 기본 구현을 추가합니다 . 즉 , &lt;code&gt;Draft&lt;/code&gt; 및 &lt;code&gt;PendingReview&lt;/code&gt; 구조체 에 &lt;code&gt;content&lt;/code&gt; 를 구현할 필요가 없습니다 . &lt;code&gt;Published&lt;/code&gt; 구조체는 우선합니다 &lt;code&gt;content&lt;/code&gt; 방법과에서 값을 반환 &lt;code&gt;post.content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">우리는 추가 &lt;code&gt;approve&lt;/code&gt; 받는 방법을 &lt;code&gt;State&lt;/code&gt; 특성과 새로운 구조체를 추가 구현 &lt;code&gt;State&lt;/code&gt; 의 &lt;code&gt;Published&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">매개 변수의 유형을 나타 내기 위해 &lt;code&gt;Fn&lt;/code&gt; 특성 바인딩 에 유형을 추가 하고 클로저가이 특성 바인딩과 일치해야하는 값을 반환합니다. 이 경우, 우리의 폐쇄 형의 매개 변수가 &lt;code&gt;u32&lt;/code&gt; 하고 반환 &lt;code&gt;u32&lt;/code&gt; 우리가 지정 바인딩 특성이 있으므로, &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">쿼리 문자열이 포함 된 줄을 저장하는 방법도 필요합니다. 이를 &lt;code&gt;for&lt;/code&gt; 루프 전에 가변 벡터를 만들고 &lt;code&gt;push&lt;/code&gt; 메서드를 호출 하여 벡터에 &lt;code&gt;line&lt;/code&gt; 을 저장할 수 있습니다 . 애프터 &lt;code&gt;for&lt;/code&gt; 12-19 목록과 같이 루프, 우리는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">이 테스트를 실행할 수 없으며 테스트가 컴파일되지 않았기 때문에 실패합니다. &lt;code&gt;search&lt;/code&gt; 기능이 아직 존재하지 않습니다! 이제 Listing 12-16에 표시된 것처럼 항상 빈 벡터를 반환하는 &lt;code&gt;search&lt;/code&gt; 함수 의 정의를 추가하여 테스트를 컴파일하고 실행할 수 있도록 충분한 코드를 추가 할 것이다 . 그런 다음 빈 벡터가 &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt; 줄을 포함하는 벡터와 일치하지 않으므로 테스트가 컴파일 및 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field_name&lt;/code&gt; 및 &lt;code&gt;field_value&lt;/code&gt; 변수 는 &lt;code&gt;insert&lt;/code&gt; 호출로 해시 맵으로 이동 한 후에 는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">우리는 사용에 허용되지 않습니다 &lt;code&gt;v1_iter&lt;/code&gt; 에 대한 호출 후 &lt;code&gt;sum&lt;/code&gt; 때문에 &lt;code&gt;sum&lt;/code&gt; 우리에 전화 반복자의 소유권을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;execute&lt;/code&gt; 에 대한 매개 변수로 아무것도 수행하지 않습니다 . 우리가 원하는 동작으로 이러한 함수의 본문을 구현합시다. 시작하려면 &lt;code&gt;new&lt;/code&gt; . 이전에 우리는 &lt;code&gt;size&lt;/code&gt; 매개 변수에 대해 서명되지 않은 유형을 선택했습니다 . 음수 스레드가있는 풀은 의미가 없기 때문입니다. 그러나 스레드가 0 인 풀도 의미가 없지만 0은 완벽하게 유효한 &lt;code&gt;usize&lt;/code&gt; 입니다. &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스를 반환하기 전에 &lt;code&gt;size&lt;/code&gt; 가 0보다 큰지 확인하는 코드를 추가 하고 &lt;code&gt;assert!&lt;/code&gt; 매크로 (Listing 20-13).</target>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">우리는 열거 형의 각 변형에 데이터를 직접 첨부하므로 추가 구조체가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; 을 표현식 &lt;code&gt;guess.trim().parse()&lt;/code&gt; 바인딩 합니다. 표현식 의 &lt;code&gt;guess&lt;/code&gt; 은 입력 이 포함 된 &lt;code&gt;String&lt;/code&gt; 원래 &lt;code&gt;guess&lt;/code&gt; 을 나타냅니다 . &lt;code&gt;String&lt;/code&gt; 인스턴스 의 &lt;code&gt;trim&lt;/code&gt; 메소드 는 시작과 끝에서 공백을 제거합니다. &lt;code&gt;u32&lt;/code&gt; 는 숫자 만 포함 할 수 있지만 , 사용자는 &lt;code&gt;read_line&lt;/code&gt; 을 충족시키기 위해 enter를 눌러야 합니다. 사용자가 Enter 키를 누르면 줄 바꿈 문자가 문자열에 추가됩니다. 예를 들어, 사용자가 5를 입력하고 Enter 키를 누르면 다음과 같이 &lt;code&gt;guess&lt;/code&gt; . &lt;code&gt;5\n&lt;/code&gt; . &lt;code&gt;\n&lt;/code&gt; Enter 키를 누른 결과 인 &quot;newline&quot;을 나타냅니다. &lt;code&gt;trim&lt;/code&gt; 방법 제거해 &lt;code&gt;\n&lt;/code&gt; 단지의 결과로 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">&lt;code&gt;std::io::prelude&lt;/code&gt; 를 범위 내로 가져 와서 스트림에서 읽고 쓸 수있는 특정 특성에 액세스 할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수 의 &lt;code&gt;for&lt;/code&gt; 루프에서 연결을했다는 메시지를 인쇄하는 대신 새로운 &lt;code&gt;handle_connection&lt;/code&gt; 함수를 호출 하고 &lt;code&gt;stream&lt;/code&gt; 을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">우리는 함수 매개 변수를 &lt;em&gt;빌리&lt;/em&gt; 는 참조라고 부릅니다 . 실생활에서와 같이, 사람이 무언가를 소유하고 있다면 그들에게서 빌릴 수 있습니다. 완료되면 돌려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">우리 는 값의 소유권이 아닌 &lt;code&gt;Option&lt;/code&gt; 내부의 값에 대한 참조를 원하기 때문에 &lt;code&gt;Option&lt;/code&gt; 에서 &lt;code&gt;as_ref&lt;/code&gt; 메소드를 호출합니다 . 때문에 &lt;code&gt;state&lt;/code&gt; 입니다 &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 우리가 호출 할 때, &lt;code&gt;as_ref&lt;/code&gt; , &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 반환됩니다. &lt;code&gt;as_ref&lt;/code&gt; 를 호출하지 않으면 함수 매개 변수 의 빌린 &lt;code&gt;&amp;amp;self&lt;/code&gt; 에서 &lt;code&gt;state&lt;/code&gt; 를 이동할 수 없으므로 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">또한 다른 특성을 구현하는 모든 유형의 특성을 조건부로 구현할 수도 있습니다. 특성 한계를 충족시키는 모든 유형의 특성의 &lt;em&gt;구현을 담요 구현&lt;/em&gt; 이라고 하며 Rust 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어 표준 라이브러리 는 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형 에서 &lt;code&gt;ToString&lt;/code&gt; 특성을 구현합니다 . 표준 라이브러리 의 &lt;code&gt;impl&lt;/code&gt; 블록은 다음 코드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">경로 시작시 &lt;code&gt;super&lt;/code&gt; 를 사용하여 상위 모듈에서 시작하는 상대 경로를 구성 할 수도 있습니다 . 이것은 &lt;code&gt;..&lt;/code&gt; 구문 으로 파일 시스템 경로를 시작하는 것과 같습니다 . 왜 우리가 이것을하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 구문을 사용하여 하나 이상의 필드에서 일반 유형 매개 변수를 사용하도록 구조체를 정의 할 수도 있습니다 . 코드 10-6은 모든 유형의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 좌표 값 을 보유 하도록 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체 를 정의하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">모든 필드에 대한 변수를 생성하는 대신 구조체 패턴의 일부로 리터럴 값으로 구조를 변경할 수도 있습니다. 그렇게하면 특정 필드에 대해 일부 필드를 테스트하면서 다른 필드를 구조화하기위한 변수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">또한 모든 요소를 ​​변경하기 위해 변경 가능한 벡터의 각 요소에 대한 변경 가능한 참조를 반복 할 수 있습니다. 목록 8-9 의 &lt;code&gt;for&lt;/code&gt; 루프는 각 요소 에 &lt;code&gt;50&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; 플래그 를 사용하고 테스트하려는 상자의 이름을 지정 하여 최상위 디렉토리의 작업 공간에서 특정 상자에 대한 테스트를 실행할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">하나 이상의 특성 바운드를 지정할 수도 있습니다. 우리가 원하는 말 &lt;code&gt;notify&lt;/code&gt; 에 서식 사용 디스플레이 &lt;code&gt;item&lt;/code&gt; 뿐만 아니라 &lt;code&gt;summarize&lt;/code&gt; (가)에서 우리는 지정 방법 &lt;code&gt;notify&lt;/code&gt; 것을 정의 &lt;code&gt;item&lt;/code&gt; 모두 구현해야 &lt;code&gt;Display&lt;/code&gt; 및 &lt;code&gt;Summary&lt;/code&gt; . &lt;code&gt;+&lt;/code&gt; 구문을 사용하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">또한 I / O 프로젝트 의 &lt;code&gt;search&lt;/code&gt; 기능에서 반복자를 활용할 수 있는데,이 목록은 Listing 12-19에서와 같이 Listing 13-28에서 재현된다.</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">또한 다른 패턴 안에 &lt;code&gt;_&lt;/code&gt; 를 사용 하여 값의 일부만 무시할 수 있습니다 (예 : 값의 일부만 테스트하려고하지만 실행하려는 해당 코드에서 다른 부분은 사용하지 않는 경우). 목록 18-18은 설정 값을 관리하는 코드를 보여줍니다. 비즈니스 요구 사항은 사용자가 기존 설정의 사용자 지정을 덮어 쓸 수 없어야하지만 설정을 해제하고 현재 설정되어 있지 않은 경우 값을 제공 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 을 사용하여 다른 언어가 Rust 함수를 호출 할 수있는 인터페이스를 만들 수도 있습니다 . &lt;code&gt;extern&lt;/code&gt; 블록 대신 &lt;code&gt;extern&lt;/code&gt; 키워드를 추가 하고 &lt;code&gt;fn&lt;/code&gt; 키워드 바로 앞에 사용할 ABI를 지정합니다 . 또한 Rust 컴파일러에게이 함수의 이름을 &lt;code&gt;#[no_mangle]&lt;/code&gt; 하지 말라고 알리려면 # [no_mangle] 주석 을 추가해야 합니다. &lt;em&gt;맹 글링&lt;/em&gt;컴파일러가 이름을 변경하면 컴파일 프로세스의 다른 부분에 대해 더 많은 정보를 포함하지만 사람이 읽을 수없는 다른 정보로 함수에 이름을 부여했습니다. 모든 프로그래밍 언어 컴파일러는 이름을 약간 다르게 조정하므로 Rust 함수의 이름을 다른 언어로 지정할 수 있으려면 Rust 컴파일러의 이름 조작을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 을 사용 하여 구조체와 열거 형을 공용으로 지정할 수도 있지만 몇 가지 추가 정보가 있습니다. 구조체 정의 전에 &lt;code&gt;pub&lt;/code&gt; 를 사용 하면 구조체를 공개하지만 구조체의 필드는 여전히 비공개입니다. 각 필드를 사례별로 공개하거나 공개하지 않을 수 있습니다. 목록 7-9에서 우리는 공공 정의한 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 공개와 구조체 &lt;code&gt;toast&lt;/code&gt; 가 아니고 개인 &lt;code&gt;seasonal_fruit&lt;/code&gt; 을들. 고객이 식사와 함께 제공되는 빵 종류를 선택할 수있는 식당에서 사례를 모델링하지만 요리사는 계절과 재고에 따라 어떤 과일이 식사와 함께 제공되는지 결정합니다. 사용 가능한 과일이 빠르게 바뀌므로 고객은 과일을 선택하거나 과일을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">클로저는 13 장에서 설명한 것처럼 함수와 비슷하기 때문에 함수 파라미터 목록과 같은 방식으로 클로저 파라미터 목록에 패턴을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">패턴을 사용하여 구조체, 열거 형, 튜플 및 참조를 재구성하여 이러한 값의 다른 부분을 사용할 수 있습니다. 각 값을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">리턴 위치에서 &lt;code&gt;impl Trait&lt;/code&gt; 구문을 사용하여 다음 과 같이 특성을 구현하는 일부 유형의 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">우리는 또한 기능을 사용할 수있는 &lt;code&gt;String::from&lt;/code&gt; 만들 &lt;code&gt;String&lt;/code&gt; 문자열 리터럴에서합니다. Listing 8-13의 코드는 &lt;code&gt;to_string&lt;/code&gt; 을 사용하는 Listing 8-12의 코드와 동일하다 .</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">특정 패턴을 무시하기 위해 한 패턴 내에서 여러 위치에 밑줄을 사용할 수도 있습니다. Listing 18-19는 5 개 항목의 튜플에서 두 번째 및 네 번째 값을 무시하는 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; 또는 &lt;code&gt;cargo check&lt;/code&gt; 사용하여 프로젝트를 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; 사용하여 프로젝트를 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo check&lt;/code&gt; 사용하여 오류를 확인하기 위해 바이너리를 생성하지 않고 프로젝트를 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo run&lt;/code&gt; 사용하여 한 단계로 프로젝트를 빌드하고 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">이름 뒤에 일련의 괄호를 입력하여 정의한 함수를 호출 할 수 있습니다. 프로그램에서 &lt;code&gt;another_function&lt;/code&gt; 이 정의 되었으므로 &lt;code&gt;main&lt;/code&gt; 함수 내부에서 호출 할 수 있습니다 . 우리가 정의합니다 &lt;code&gt;another_function&lt;/code&gt; 을&lt;em&gt;한 후 &lt;/em&gt; &lt;code&gt;main&lt;/code&gt; 소스 코드의 기능; 우리는 그것을 전에도 정의 할 수있었습니다. Rust는 함수를 정의하는 위치를 신경 쓰지 않고 어딘가에 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">&lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; 와 같이 문자열 슬라이스를 인자로 사용 하여 &lt;code&gt;hello&lt;/code&gt; 함수를 호출 할 수 있습니다 . 예를 들어. 참조 강제 변환을 사용하면 목록 15-12에 표시된대로 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 유형의 값에 대한 참조로 &lt;code&gt;hello&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">반복자 에서 &lt;code&gt;next&lt;/code&gt; 메소드를 직접 호출 할 수 있습니다. Listing 13-15는 반복 호출 에서 벡터에서 생성 된 반복자 에서 &lt;code&gt;next&lt;/code&gt; 값으로 리턴되는 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">Listing 15-2 의 &lt;code&gt;List&lt;/code&gt; 열거 형 정의 와 Listing 15-3 의 &lt;code&gt;List&lt;/code&gt; 사용법을 Listing 15-5의 코드로 변경하면 컴파일된다.</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 을 모든 종류의 포인터와 결합 할 수 있습니다 ( 예 : &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; . 사실, 이전에는이 ​​점을 보았지만 동적으로 크기가 다른 유형 인 특성이 있습니다. 모든 특성은 특성의 이름을 사용하여 참조 할 수있는 동적 크기 유형입니다. 17 장 &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;다른 유형의 값을 허용하는 특성 개체 사용&amp;rdquo;&lt;/a&gt; 섹션에서 특성을 특성 개체로 사용하려면 &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; 또는 &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; ( &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 도 작동합니다).</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 과 같이 IpAddrKind 의 두 가지 변형 각각의 인스턴스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">&lt;code&gt;[starting_index..ending_index]&lt;/code&gt; 를 지정하여 괄호 안의 범위를 사용하여 슬라이스를 만들 수 있습니다 . 여기서 &lt;code&gt;starting_index&lt;/code&gt; 는 슬라이스의 첫 번째 위치이고 &lt;code&gt;ending_index&lt;/code&gt; 는 슬라이스 의 마지막 위치보다 하나 더 많습니다. 내부적으로 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이를 저장하며, 이는 &lt;code&gt;ending_index&lt;/code&gt; 빼기 &lt;code&gt;starting_index&lt;/code&gt; 에 해당합니다 . 따라서 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; 는 길이 값이 5 인 &lt;code&gt;s&lt;/code&gt; 의 7 번째 바이트 (1에서 계산)에 대한 포인터를 포함하는 슬라이스입니다 .</target>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">&lt;code&gt;[starting_index..ending_index]&lt;/code&gt; 를 지정하여 괄호 안에 범위를 사용하여 슬라이스를 만들 수 있습니다 . 여기서 &lt;code&gt;starting_index&lt;/code&gt; 는 슬라이스의 첫 번째 위치이고 &lt;code&gt;ending_index&lt;/code&gt; 는 슬라이스 의 마지막 위치보다 하나 더 큽니다. 내부적으로 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이를 저장하며, 이는 &lt;code&gt;ending_index&lt;/code&gt; 에서 &lt;code&gt;starting_index&lt;/code&gt; 를 뺀 값에 해당합니다 . 따라서 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; 의 7 바이트에 대한 포인터가 포함 된 슬라이스 것 &lt;code&gt;s&lt;/code&gt; 5의 길이 값을.</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 열거 를 정의 하고 IP 주소가 &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; 일 수있는 가능한 종류를 나열 하여이 개념을 코드로 표현할 수 있습니다 . 이들은 열거 형 의 &lt;em&gt;변형&lt;/em&gt; 으로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 열거 형 을 정의 하고 가능한 IP 주소 종류 ( &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; )를 나열 하여이 개념을 코드로 표현할 수 있습니다 . 다음은 열거 형의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">Listing 4-6의 코드에서 약간의 수정만으로 오류를 수정할 수있다.</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">&lt;code&gt;thread::spawn&lt;/code&gt; 의 반환 값을 변수 에 저장하여 스폰 된 스레드가 실행되지 않거나 완전히 실행되지 않는 문제를 해결할 수 있습니다 . &lt;code&gt;thread::spawn&lt;/code&gt; 의 반환 유형 은 &lt;code&gt;JoinHandle&lt;/code&gt; 입니다. &lt;code&gt;JoinHandle&lt;/code&gt; 는 우리가 전화 할 때, 소유 한 값 &lt;code&gt;join&lt;/code&gt; 그것을 방법, 마무리의 스레드를 기다립니다. Listing 16-2는 Listing 16-1에서 만든 스레드 의 &lt;code&gt;JoinHandle&lt;/code&gt; 을 사용하고 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 &lt;code&gt;main&lt;/code&gt; 종료 전에 생성 된 스레드가 완료되도록 하는 방법을 보여준다 .</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">목록 8-23에 표시된 것처럼 &lt;code&gt;get&lt;/code&gt; 메소드에 키를 제공하여 해시 맵에서 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">우리는 성장할 수있는 &lt;code&gt;String&lt;/code&gt; 사용하여 &lt;code&gt;push_str&lt;/code&gt; 의 8-15 목록과 같이 문자열 슬라이스를 추가하는 방법을.</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">struct와 enum에 메소드를 구현할 수 있고 (5 장에서했던 것처럼) 정의에 일반 타입을 사용할 수도 있습니다. Listing 10-9는 Listing 10-6에서 정의한 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체를 &lt;code&gt;x&lt;/code&gt; 라는 메소드로 구현 한 것이다.</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 과 함께 &lt;code&gt;else&lt;/code&gt; 를 포함시킬 수 있습니다 . 로가는 코드의 블록 &lt;code&gt;else&lt;/code&gt; 와 함께 갈 것 코드 블록과 동일 &lt;code&gt;_&lt;/code&gt; 의 경우 &lt;code&gt;match&lt;/code&gt; 받는 것과 동일 표현 &lt;code&gt;if let&lt;/code&gt; 와 &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;Quarter&lt;/code&gt; 변형이 &lt;code&gt;UsState&lt;/code&gt; 값을 보유한 Listing 6-4 의 &lt;code&gt;Coin&lt;/code&gt; 열거 형 정의를 상기 하자 . 쿼터가 아닌 모든 코인을 세고 쿼터의 상태를 알리면서 다음과 같은 &lt;code&gt;match&lt;/code&gt; 표현식을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">대신 성공적인 경우 &lt;code&gt;Config&lt;/code&gt; 인스턴스를 포함 하고 오류 경우의 문제점을 설명 하는 &lt;code&gt;Result&lt;/code&gt; 값을 리턴 할 수 있습니다 . &lt;code&gt;Config::new&lt;/code&gt; 가 &lt;code&gt;main&lt;/code&gt; 과 통신 할 때 &lt;code&gt;Result&lt;/code&gt; 유형을 사용하여 문제가 있음을 알릴 수 있습니다 . 그런 다음 &lt;code&gt;main&lt;/code&gt; 을 변경 하여 &lt;code&gt;thread 'main'&lt;/code&gt; 및 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 에 대한 주변 텍스트없이 &lt;code&gt;panic!&lt;/code&gt; 대한 호출 없이 &lt;code&gt;Err&lt;/code&gt; 변형을보다 실용적인 오류로 변환 할 수 있습니다 ! 원인.</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프를 사용하여 벡터와 비슷한 방식으로 해시 맵에서 각 키 / 값 쌍을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">더 복잡한 방식으로 파괴 패턴을 혼합, 일치 및 중첩 할 수 있습니다. 다음 예제는 구조체와 튜플을 튜플 내부에 중첩하고 모든 기본 값을 구성 해제하는 복잡한 구조화를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">이제 &lt;code&gt;use rand;&lt;/code&gt; 추가 할 수 있습니다 . 받는 &lt;em&gt;추가 한 / SRC / lib.rs의&lt;/em&gt; 파일을 실행하여 전체 작업 공간을 구축 &lt;code&gt;cargo build&lt;/code&gt; 에 &lt;em&gt;추가&lt;/em&gt; 로 가져오고 컴파일 디렉토리 &lt;code&gt;rand&lt;/code&gt; 상자를 :</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">모든 테스트 기능의 이름을 &lt;code&gt;cargo test&lt;/code&gt; 에 전달하여 해당 테스트 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">우리는 아마도 이것이 무엇을하고 있는지 추측 할 수있을 것입니다.&amp;ldquo;값 &lt;code&gt;5&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에 바인딩 ; 그런 다음 &lt;code&gt;x&lt;/code&gt; 에 값을 복사 하여 &lt;code&gt;y&lt;/code&gt; 에 바인딩합니다 .&amp;rdquo; 이제 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 두 변수가 있고 모두 &lt;code&gt;5&lt;/code&gt; 입니다. 정수는 알려진 고정 크기의 단순 값이고이 두 &lt;code&gt;5&lt;/code&gt; 개의 값이 스택으로 푸시 되기 때문에 실제로 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">데이터를 각 열거 형 변형에 직접 넣어서 구조체 내부의 열거 형이 아닌 열거 형 만 사용하여 동일한 개념을 더 간결한 방식으로 나타낼 수 있습니다. &lt;code&gt;IpAddr&lt;/code&gt; 열거 형 에 대한이 새로운 정의에 따르면 &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; 변형은 모두 연관된 &lt;code&gt;String&lt;/code&gt; 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">참조 대신 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하도록 Listing 15-6의 코드를 다시 작성할 수있다 . 역 참조 연산자는 목록 15-7에 표시된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">우리가 볼 수있는 그 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 1의 초기 참조 횟수를 가지고; &lt;code&gt;clone&lt;/code&gt; 을 호출 할 때마다 카운트가 1 씩 증가합니다. &lt;code&gt;c&lt;/code&gt; 가 범위를 벗어나면 카운트가 1만큼 감소합니다. &lt;code&gt;Rc::clone&lt;/code&gt; 를 호출해야하는 것처럼 참조 카운트를 줄이기 위해 함수를 호출 할 필요는 없습니다. 클론 은 참조 카운트를 증가시킵니다 : &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 범위를 벗어날 때 &lt;code&gt;Drop&lt;/code&gt; 특성 의 구현은 참조 카운트를 자동으로 감소시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">테스트 결과에서 실제로 얻은 값을 볼 수 있는데, 예상했던 결과 대신 발생한 결과를 디버그하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">테스트 이름의 일부를 지정할 수 있으며 해당 값과 이름이 같은 테스트가 실행됩니다. 예를 들어 테스트 이름 중 두 개에 &lt;code&gt;add&lt;/code&gt; 가 포함되어 있으므로 &lt;code&gt;cargo test add&lt;/code&gt; 를 실행하여 두 개를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">우리는 여전히 이것보다 더 잘할 수 있습니다! 이들은 모두 문자열이므로 &lt;code&gt;From::from&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">테스트 함수의 이름을 &lt;code&gt;cargo test&lt;/code&gt; 의 인수로 지정하여 특정 통합 테스트 함수를 계속 실행할 수 있습니다 . 특정 통합 테스트 파일에서 모든 테스트를 실행하려면 &lt;code&gt;cargo test&lt;/code&gt; 의 &lt;code&gt;--test&lt;/code&gt; 인수와 파일 이름을 차례로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">&lt;code&gt;parse_config&lt;/code&gt; 함수를 더 향상시키기 위해 또 다른 작은 단계를 취할 수 있습니다 . 현재 튜플을 반환하지만 즉시 해당 튜플을 개별 부분으로 다시 나눕니다. 이것은 아마도 우리가 아직 올바른 추상화를 가지고 있지 않다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 를 사용 하여 한 번에 한 줄씩 쓸 수 있으므로 파일에 대한 실제 쓰기 횟수가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">경로의 어느 수준에서나 중첩 된 경로를 사용할 수 있으며, 이는 하위 경로를 공유하는 두 개의 &lt;code&gt;use&lt;/code&gt; 문을 결합 할 때 유용합니다 . 예를 들어, 목록 7-19는 &lt;code&gt;std::io&lt;/code&gt; 를 범위로 가져오고 &lt;code&gt;std::io::Write&lt;/code&gt; 를 범위 로 가져 오는 두 가지 &lt;code&gt;use&lt;/code&gt; 설명을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">제네릭을 사용하여 함수 시그너처 또는 구조체와 같은 항목에 대한 정의를 생성 할 수 있으며,이를 통해 다양한 콘크리트 데이터 유형과 함께 사용할 수 있습니다. 먼저 제네릭을 사용하여 함수, 구조체, 열거 형 및 메서드를 정의하는 방법을 살펴 보겠습니다. 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">예를 들어 &lt;code&gt;add_two&lt;/code&gt; 함수에 &lt;code&gt;3&lt;/code&gt; 을 전달할 때 반환되는 값은 &lt;code&gt;5&lt;/code&gt; 라는 테스트를 작성할 수 있습니다 . 코드가 변경 될 때마다 이러한 테스트를 실행하여 기존의 올바른 동작이 변경되지 않았는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">반복자 어댑터 메소드를 사용하여이 코드를보다 간결하게 작성할 수 있습니다. 그렇게하면 변경 가능한 중간 &lt;code&gt;results&lt;/code&gt; 벡터를 피할 수 있습니다 . 함수형 프로그래밍 스타일은 코드를 더 명확하게하기 위해 변경 가능한 상태의 양을 최소화하는 것을 선호합니다. 변경 가능한 상태를 제거하면 &lt;code&gt;results&lt;/code&gt; 벡터에 대한 동시 액세스를 관리 할 필요가 없으므로 검색 기능이 동시에 향상 될 수 있도록 향후 향상 될 수 있습니다 . Listing 13-29는 이러한 변화를 보여준다 :</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">값이 범위를 벗어나면 &lt;code&gt;drop&lt;/code&gt; 자동 삽입을 비활성화 할 수 없으며 &lt;code&gt;drop&lt;/code&gt; 메서드를 명시 적으로 호출 할 수 없습니다 . 따라서 값을 일찍 정리해야하는 경우 &lt;code&gt;std::mem::drop&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">우리는 함수로 똑같이 할 수 없습니다. 다음 예제를 시도하면 코드가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">안전한 녹만 사용하여이 기능을 구현할 수 없습니다. 시도는 컴파일되지 않는 Listing 19-5와 같다. 간단하게하기 위해 &lt;code&gt;split_at_mut&lt;/code&gt; 를 메소드가 아닌 함수로 구현 하고 일반 유형이 아닌 &lt;code&gt;i32&lt;/code&gt; 값의 슬라이스에 대해서만 구현 합니다. &lt;code&gt;T&lt;/code&gt; 가 합니다.</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 메소드는 &lt;code&gt;self&lt;/code&gt; 에 대한 불변의 참조를 &lt;code&gt;MockMessenger&lt;/code&gt; 때문에 메시지를 추적하기 위해 MockMessenger 를 수정할 수 없습니다 . 또한 &lt;code&gt;send&lt;/code&gt; 의 서명이 &lt;code&gt;Messenger&lt;/code&gt; 특성 정의 의 서명과 일치하지 않기 때문에 오류 텍스트에서 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 대신 사용하라는 제안을 취할 수 없습니다 (자신의 오류 메시지를 확인하고 시도하십시오).</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">이 방법으로 여러 테스트의 이름을 지정할 수 없습니다. &lt;code&gt;cargo test&lt;/code&gt; 주어진 첫 번째 값만 사용됩니다. 그러나 여러 테스트를 실행할 수있는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;Foo&lt;/code&gt; 유형의 오브젝트를 작성할 수 없습니다 .이 경우 &lt;code&gt;Self&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;Sized&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">음수의 스레드가 의미가 없다는 것을 알기 때문에 &lt;code&gt;size&lt;/code&gt; 매개 변수 의 유형으로 &lt;code&gt;usize&lt;/code&gt; 를 선택했습니다 . 또한이 정수를 스레드 컬렉션의 요소 수로 사용한다는 것을 알고 있습니다. 이는 &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;정수 유형&amp;rdquo;&lt;/a&gt; 에서 설명한대로 사용 유형 의 &lt;code&gt;usize&lt;/code&gt; 입니다. 장 3 절.</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">우리 는 &lt;code&gt;leaf&lt;/code&gt; 에 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 를 복제하고 그것을 &lt;code&gt;branch&lt;/code&gt; 에 저장합니다 . 이는 &lt;code&gt;leaf&lt;/code&gt; 의 &lt;code&gt;Node&lt;/code&gt; 에 이제 &lt;code&gt;leaf&lt;/code&gt; 와 &lt;code&gt;branch&lt;/code&gt; 의 두 소유자가 있음을 의미합니다 . 우리는에서 얻을 수있는 &lt;code&gt;branch&lt;/code&gt; 에 &lt;code&gt;leaf&lt;/code&gt; 을 통해 &lt;code&gt;branch.children&lt;/code&gt; 만에서 얻을 수있는 방법은 없습니다 &lt;code&gt;leaf&lt;/code&gt; 으로 &lt;code&gt;branch&lt;/code&gt; . 그 이유는 &lt;code&gt;leaf&lt;/code&gt; 은 &lt;code&gt;branch&lt;/code&gt; 대한 언급이 없으며 관련이 있다는 것을 모르기 때문입니다. 우리는 &lt;code&gt;leaf&lt;/code&gt; 이 &lt;code&gt;branch&lt;/code&gt; 가 부모 라는 것을 알고 싶어 합니다. 다음에 해보겠습니다.</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">우리는 또한 &lt;code&gt;vec!&lt;/code&gt; 사용할 수 있습니다 ! 2 개의 정수로 구성된 벡터 또는 5 개의 문자열 슬라이스로 구성된 벡터를 만드는 매크로입니다. 값의 수 또는 유형을 미리 알 수 없으므로 함수를 사용하여 동일한 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">대신 참조를 보유하도록 &lt;code&gt;Cons&lt;/code&gt; 의 정의를 변경할 수 있지만 수명 매개 변수를 지정해야합니다. 수명 매개 변수를 지정하면 목록의 모든 요소가 최소한 전체 목록만큼 지속되도록 지정합니다. 빌리 체커는 컴파일을 &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; 하지 않습니다 let a = Cons (10, &amp;amp; Nil); 임시 때문에 예를 들어, &lt;code&gt;Nil&lt;/code&gt; 값이 전에 삭제 될 것입니다 &lt;code&gt;a&lt;/code&gt; 는 에 대한 참조 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">우리는 여기서 더 할 수 있습니다! 이 프로젝트를 계속 향상 시키려면 다음과 같은 아이디어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; &lt;code&gt;a.clone()&lt;/code&gt; 대신 a.clone () 을 호출 할 수 있지만 Rust의 규칙은 이 경우 &lt;code&gt;Rc::clone&lt;/code&gt; 을 사용하는 것 입니다. &lt;code&gt;Rc::clone&lt;/code&gt; 의 구현은 대부분의 유형의 &lt;code&gt;clone&lt;/code&gt; 구현처럼 모든 데이터의 딥 카피를 만들지는 않습니다 . &lt;code&gt;Rc::clone&lt;/code&gt; 호출 하면 참조 횟수 만 증가하므로 시간이 많이 걸리지 않습니다. 깊은 데이터 사본에는 많은 시간이 걸릴 수 있습니다. 참조 카운트에 &lt;code&gt;Rc::clone&lt;/code&gt; 을 사용 하면 딥 카피 종류의 클론과 참조 횟수를 증가시키는 클론의 종류를 시각적으로 구별 할 수 있습니다. 코드에서 성능 문제를 찾을 때 딥 카피 클론 만 고려하면되고 호출은 무시해도됩니다 &lt;code&gt;Rc::clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 데이터는 여러 가지 방법으로 관리 할 수 있지만 가장 비효율적이지만 가장 효율적인 방법은 값에 대해 &lt;code&gt;clone&lt;/code&gt; 메서드 를 호출하는 것 입니다. 이렇게하면 &lt;code&gt;Config&lt;/code&gt; 인스턴스 의 데이터 전체 를 소유하게되므로 문자열 데이터에 대한 참조를 저장하는 것보다 시간과 메모리가 더 많이 걸립니다. 그러나 데이터를 복제하면 참조의 수명을 관리 할 필요가 없으므로 코드가 매우 간단 해집니다. 이 상황에서 단순성을 얻기 위해 약간의 성능을 포기하는 것은 가치있는 트레이드 오프입니다.</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">운동 프로그램을 여러 가지 방식으로 재구성 할 수있었습니다. 먼저, Listing 13-4에서 보여 지듯이, &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수에 대한 복제 된 호출을 변수로 추출해 보도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 제네릭 형식의 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스가 아닌 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 인스턴스 에서만 메서드를 구현할 수 있습니다 . Listing 10-10에서 우리는 구체적 타입 &lt;code&gt;f32&lt;/code&gt; 를 사용한다 . 즉, &lt;code&gt;impl&lt;/code&gt; 뒤에 어떤 타입도 선언하지 않는다 .</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">이 장에서는 많은 내용을 다루었습니다! 이제 일반 유형 매개 변수, 특성 및 특성 경계 및 일반 수명 매개 변수에 대해 알게되었으므로 다양한 상황에서 작동하는 반복없이 코드를 작성할 수 있습니다. 제네릭 형식 매개 변수를 사용하면 코드를 다른 형식에 적용 할 수 있습니다. 특성 및 특성 범위는 유형이 일반이지만 코드에 필요한 동작을 갖도록합니다. 이 유연한 코드에 매달려있는 참조가 없도록 평생 주석을 사용하는 방법을 배웠습니다. 이 모든 분석은 컴파일 타임에 수행되며 런타임 성능에는 영향을 미치지 않습니다!</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">Listing 16-12에서와 같이 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 안에 &lt;code&gt;i32&lt;/code&gt; 를 보유하는 &lt;code&gt;counter&lt;/code&gt; 변수를 만든다 . 다음으로, 다양한 숫자를 반복하여 10 개의 스레드를 만듭니다. 우리가 사용하는 &lt;code&gt;thread::spawn&lt;/code&gt; 하고 모든 스레드에게 같은 폐쇄, 스레드에 카운터를 이동에 잠금을 획득 한 줄 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 호출에 의해 &lt;code&gt;lock&lt;/code&gt; 방법을 다음 뮤텍스의 값에 1을 추가합니다. 스레드가 클로저 실행을 마치면 &lt;code&gt;num&lt;/code&gt; 이 범위를 벗어나고 다른 스레드가이를 획득 할 수 있도록 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">프로젝트 디렉토리의 최상위 레벨 인 &lt;em&gt;src&lt;/em&gt; 옆에 &lt;em&gt;tests&lt;/em&gt; 디렉토리를 만듭니다 . Cargo는이 디렉토리에서 통합 테스트 파일을 찾습니다. 그런 다음이 디렉토리에서 원하는만큼 테스트 파일을 만들 수 있으며, Cargo는 각 파일을 개별 상자로 컴파일합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 함수를 사용하여 새 채널을 만듭니다 . &lt;code&gt;mpsc&lt;/code&gt; 는 &lt;em&gt;여러 생산자, 단일 소비자를&lt;/em&gt; 나타냅니다 . 간단히 말해서 Rust의 표준 라이브러리가 채널을 구현하는 방식은 채널이 값을 생성하는 여러 &lt;em&gt;송신&lt;/em&gt; 엔드를 가질 수 있지만 해당 값을 소비하는 &lt;em&gt;수신&lt;/em&gt; 엔드는 하나만 가질 수 있다는 것을 의미 합니다. 하나의 큰 강으로 여러 개의 개울이 함께 흐른다 고 상상해보십시오. 지금은 단일 제작자로 시작하지만이 예제가 작동하면 여러 생산자를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">괄호 안에 쉼표로 구분 된 값 목록을 작성하여 튜플을 만듭니다. 튜플의 각 위치에는 유형이 있으며 튜플의 서로 다른 값의 유형이 같을 필요는 없습니다. 이 예제에서는 선택적 유형 주석을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">우리의 인스턴스 값을 만들 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 와라는 변수에 저장 &lt;code&gt;value&lt;/code&gt; 우리가 직접 나중에 액세스 할 수 있도록합니다. 그런 다음 우리는 만들 &lt;code&gt;List&lt;/code&gt; 에 A의 &lt;code&gt;Cons&lt;/code&gt; 보유 변형 &lt;code&gt;value&lt;/code&gt; . 우리는 &lt;code&gt;value&lt;/code&gt; 를 복제해야 합니다. 따라서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 모두 소유권을 &lt;code&gt;value&lt;/code&gt; 에서 &lt;code&gt;a&lt;/code&gt; 로 또는 &lt;code&gt;value&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 차용 하지 않고 내부 &lt;code&gt;5&lt;/code&gt; 가치의 소유권을 갖도록해야 합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">&lt;code&gt;one_borrow&lt;/code&gt; 에서 반환 된 &lt;code&gt;borrow_mut&lt;/code&gt; &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터 에 대해 one_borrow 변수 를 만듭니다 . 그런 다음 변수 &lt;code&gt;two_borrow&lt;/code&gt; 에서 같은 방식으로 다른 가변 차용을 작성 합니다. 이렇게하면 같은 범위에서 두 개의 변경 가능한 참조가 만들어 지므로 허용되지 않습니다. 라이브러리에 대한 테스트를 실행하면 Listing 15-23의 코드가 오류없이 컴파일되지만 테스트는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; 라는 변수를 만듭니다 . 그러나 잠깐, 프로그램에 &lt;code&gt;guess&lt;/code&gt; 라는 변수가 이미 없습니까? 하지만 Rust를 사용 하면 이전 &lt;code&gt;guess&lt;/code&gt; 값을 새로운 것으로 &lt;em&gt;그림자를&lt;/em&gt; 만들 수 있습니다 . 이 기능은 한 유형에서 다른 유형으로 값을 변환하려는 상황에서 자주 사용됩니다. 섀도 잉을 사용하면 &lt;code&gt;guess_str&lt;/code&gt; 및 &lt;code&gt;guess&lt;/code&gt; 와 같은 두 가지 고유 변수를 만들지 않고 &lt;code&gt;guess&lt;/code&gt; 변수 이름을 재사용 할 수 있습니다 . 3 장에서는 섀도 잉에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">초기 값 이 &lt;code&gt;5, Nil&lt;/code&gt; 변수 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;List&lt;/code&gt; 값을 보유 하는 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 인스턴스를 만듭니다 . 우리는 다음 만들 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 다른 지주 예 &lt;code&gt;List&lt;/code&gt; 변수의 가치 &lt;code&gt;b&lt;/code&gt; 의 목록에 값 10 점을 포함 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 키워드 로 시작하여 모듈을 정의한 다음 모듈 이름 (이 경우 &lt;code&gt;front_of_house&lt;/code&gt; )을 지정하고 모듈 본문 주위에 중괄호를 넣 습니다. 모듈 내부에는이 경우와 같이 모듈을 &lt;code&gt;hosting&lt;/code&gt; 하고 &lt;code&gt;serving&lt;/code&gt; 다른 모듈이있을 수 있습니다 . 모듈은 구조체, 열거 형, 상수, 특성 또는 함수 (목록 7-1에서와 같이)와 같은 다른 항목에 대한 정의를 보유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">&lt;code&gt;MyBox&lt;/code&gt; 라는 구조체를 정의 하고 형식이 모든 형식의 값을 보유하기를 원하기 때문에 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 선언합니다 . &lt;code&gt;MyBox&lt;/code&gt; 의 타입 타입의 한 요소 튜플 구조체 인 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;MyBox::new&lt;/code&gt; 기능은 유형의 하나 개의 매개 변수 소요 &lt;code&gt;T&lt;/code&gt; 를 하고 반환 &lt;code&gt;MyBox&lt;/code&gt; 에 전달 된 값을 보유 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">변수 &lt;code&gt;b&lt;/code&gt; 를 정의하여 값이 &lt;code&gt;5&lt;/code&gt; 를 가리키는 &lt;code&gt;Box&lt;/code&gt; 값을 갖도록 지정합니다.이 값은 힙에 할당됩니다. 이 프로그램은 &lt;code&gt;b = 5&lt;/code&gt; 를 인쇄합니다 . 이 경우이 데이터가 스택에있는 경우와 유사한 방식으로 상자의 데이터에 액세스 할 수 있습니다. 소유 한 값과 마찬가지로 상자가 범위를 벗어나면 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;main&lt;/code&gt; 의 끝에서 와 같이 할당이 해제됩니다. 할당 취소는 스택 (스택에 저장 됨)과 그것이 가리키는 (힙에 저장 됨) 데이터에 대해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">우리는 해냈다! 우리는 0에서 10까지 세 었는데, 그다지 인상적이지는 않지만 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 와 스레드 안전성에 대해 많은 것을 가르쳐주었습니다 . 이 프로그램의 구조를 사용하여 카운터를 늘리는 것보다 더 복잡한 작업을 수행 할 수도 있습니다. 이 전략을 사용하면 계산을 독립 부품으로 나누고 해당 부품을 스레드간에 분할 한 다음 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 각 스레드가 최종 결과를 해당 부품으로 업데이트하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">우리는 &lt;code&gt;None&lt;/code&gt; 케이스를 처리하지 않았으므로이 코드는 버그를 일으킬 것입니다. 다행히 Rust가 잡는 방법을 알고있는 버그입니다. 이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">7 장에서 캡슐화를 제어하는 ​​방법에 대해 논의했습니다. &lt;code&gt;pub&lt;/code&gt; 키워드를 사용하여 코드에서 어떤 모듈, 유형, 함수 및 메소드를 공개해야하는지 결정할 수 있으며 기본적으로 다른 모든 것은 비공개입니다. 예를 들어, &lt;code&gt;i32&lt;/code&gt; 값 의 벡터를 포함하는 필드가있는 구조체 &lt;code&gt;AveragedCollection&lt;/code&gt; 을 정의 할 수 있습니다 . 구조체에는 벡터의 평균 값을 포함하는 필드가있을 수 있습니다. 즉, 필요할 때마다 필요할 때 평균을 계산할 필요가 없습니다. 즉, &lt;code&gt;AveragedCollection&lt;/code&gt; 은 계산 된 평균을 캐시합니다. Listing 17-1에는 &lt;code&gt;AveragedCollection&lt;/code&gt; 구조체 의 정의가있다 :</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">테스트 함수에 다른 속성 &lt;code&gt;should_panic&lt;/code&gt; 을 추가하여이를 수행합니다. 이 속성은 함수 내부의 코드가 패닉 상태 인 경우 테스트를 통과합니다. 함수 내부의 코드가 패닉하지 않으면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">이 경우에는 매우 유용한 메시지가 나타나지 않지만 테스트 함수를 보면 &lt;code&gt;#[should_panic]&lt;/code&gt; 로 주석이 달린 것을 볼 수 있습니다 . 우리가 얻은 실패는 테스트 함수의 코드가 패닉을 유발하지 않았다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">우리는 어떤 코드에 주석 할 필요가 없습니다 &lt;em&gt;테스트 / integration_test.rs을&lt;/em&gt; 함께 &lt;code&gt;#[cfg(test)]&lt;/code&gt; . 카고는 &lt;code&gt;tests&lt;/code&gt; 디렉토리를 특별하게 취급하고 &lt;code&gt;cargo test&lt;/code&gt; 실행할 때만이 디렉토리의 파일을 컴파일합니다 . 지금 &lt;code&gt;cargo test&lt;/code&gt; 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">우리는이 임의의 위치에 메모리를 소유하지 &lt;code&gt;i32&lt;/code&gt; 코드가 생성하는 슬라이스에 유효한 i32 값 이 포함되어 있다고 보장 할 수 없습니다 . &lt;code&gt;slice&lt;/code&gt; 가 유효한 슬라이스 인 것처럼 슬라이스 를 사용하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">우리는 &lt;code&gt;Trait&lt;/code&gt; 의 모든 메소드의 모든 구현에 대한 테이블을 만들 필요가 없으며 &lt;code&gt;foo()&lt;/code&gt; 공급되는 각기 다른 유형에 대해 이러한 테이블을 만들어야합니다 . 이 경우 이것은 (10 유형의 &lt;code&gt;Trait&lt;/code&gt; 구현 ) * (3 유형이 &lt;code&gt;foo()&lt;/code&gt; ) = 30 구현으로 나타납니다!</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">우리는 다른 출력으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">&lt;code&gt;deref&lt;/code&gt; 메소드 의 본문을 &lt;code&gt;&amp;amp;self.0&lt;/code&gt; 따라서 &lt;code&gt;deref&lt;/code&gt; 는 &lt;code&gt;*&lt;/code&gt; 연산자 로 액세스하려는 값에 대한 참조를 반환합니다 . Listing 15-9 의 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 값 에서 &lt;code&gt;*&lt;/code&gt; 를 호출 하는 &lt;code&gt;main&lt;/code&gt; 함수가 이제 컴파일되고 어설 션이 전달된다!</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">우리는 10 장의 &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;특성 : 공유 행동 정의&amp;rdquo;&lt;/a&gt; 섹션 에서 먼저 특성을 다루었 지만, 평생과 마찬가지로 더 세부적인 내용은 다루지 않았습니다. 이제 Rust에 대해 더 많이 알았으니, 우리는 핵심에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">우리는이 책 전체에서 여러 가지 작은 오류를 수정하고 부정확 한 표현을했습니다. 보도 한 독자들에게 감사합니다!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">&lt;code&gt;ast.ident&lt;/code&gt; 를 사용하여 주석이 달린 유형의 이름 (식별자)을 포함 하는 &lt;code&gt;Ident&lt;/code&gt; 구조체 인스턴스를 얻습니다 . Listing 19-32의 구조체는 &lt;code&gt;impl_hello_macro&lt;/code&gt; 목록 19-30의 코드에 기능은 &lt;code&gt;ident&lt;/code&gt; 우리가 얻을 수는있을 것이다 &lt;code&gt;ident&lt;/code&gt; 값으로 필드를 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; . 따라서 Listing 19-33 의 &lt;code&gt;name&lt;/code&gt; 변수에는 인쇄 될 때 Listing 19-30의 구조체 이름 인 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; 문자열 인 &lt;code&gt;Ident&lt;/code&gt; 구조체 인스턴스 가 포함된다 .</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">&lt;code&gt;Display&lt;/code&gt; 가 필요하지만 구현되지 않았다는 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">공백의 첫 번째 항목을 찾아서 목록 4-7에서와 같은 방식으로 단어 끝의 색인을 얻습니다. 공백을 찾으면 문자열의 시작과 공백의 색인을 시작 및 끝 색인으로 사용하여 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; 에 &lt;code&gt;request_review&lt;/code&gt; 라는 공개 메소드를 제공합니다 &lt;code&gt;self&lt;/code&gt; 에 변경 가능한 참조를 취할 합니다. 그런 다음 &lt;code&gt;Post&lt;/code&gt; 의 현재 상태에서 내부 &lt;code&gt;request_review&lt;/code&gt; 메소드를 호출 하고이 두 번째 &lt;code&gt;request_review&lt;/code&gt; 메소드는 현재 상태를 소비하고 새 상태를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">우리는 특성과 그 기능을 가지고 있습니다. 이 시점에서 크레이트 사용자는 원하는 기능을 달성하기 위해 특성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">우리는 tuple 구조체와 tuple-struct 열거 형 변형의 구현 세부 사항을 이용하는 또 다른 유용한 패턴을 가지고 있습니다. 이러한 유형은 &lt;code&gt;()&lt;/code&gt; 를 초기화 구문으로 사용 하며 함수 호출처럼 보입니다. 이니셜 라이저는 실제로 인수로 구성된 인스턴스를 반환하는 함수로 구현됩니다. 이러한 초기화 함수를 클로저 특성을 구현하는 함수 포인터로 사용할 수 있습니다. 즉, 초기화 함수를 클로저를 취하는 메소드의 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">현재 대부분의 게임이 작동하고 있지만 사용자는 한 번만 추측 할 수 있습니다. 루프를 추가하여 변경해 봅시다!</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">&lt;code&gt;Millimeters&lt;/code&gt; 와 &lt;code&gt;Meters&lt;/code&gt; 라는 두 개의 구조체가 있으며 다른 단위로 값을 보유합니다. 미터 단위의 값에 밀리미터 단위의 값을 추가하고 &lt;code&gt;Add&lt;/code&gt; 를 구현 하여 변환을 올바르게 수행 하려고 합니다. &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; 를 구현할 수 있습니다Listing 19-15와 같이 &lt;code&gt;RHS&lt;/code&gt; 로 &lt;code&gt;Meters&lt;/code&gt; 를 사용하여 를 .</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">두 개의 구조체, &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; 가 있으며 다른 단위로 값을 유지합니다. 우리는 밀리미터 단위의 값을 미터 단위의 값에 &lt;code&gt;Add&lt;/code&gt; 구현이 올바르게 변환하도록 하고 싶습니다 . 목록 19-15에 표시된 것처럼 &lt;code&gt;Rhs&lt;/code&gt; 로 &lt;code&gt;Meters&lt;/code&gt; 를 사용하여 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="translated">스레드 사용과 비교하여 async / await 및 트레이드 오프를 자세히 설명 하는 &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;비동기 책&lt;/a&gt; 을 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">이 예제는 컴파일되지 않을 것이라고 암시했습니다. 이제 왜 그런지 알아 봅시다!</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 메소드 를 정의 하여 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현 했으므로 이제 모든 &lt;code&gt;Iterator&lt;/code&gt; 를 사용할 수 있습니다 표준 라이브러리에 정의 된대로 특성 메소드의 기본 구현을 사용할 수 있습니다. 모두 &lt;code&gt;next&lt;/code&gt; 메소드의 기능을 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; 로 프로젝트를 빌드 하고 &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; 로 프로젝트를 실행 했지만, &lt;code&gt;cargo run&lt;/code&gt; 을 사용하여 코드를 컴파일 한 다음 결과 실행 파일을 모두 하나의 명령으로 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; 인덱스가 슬라이스 내에 있다는 주장을 유지합니다 . 그런 다음 안전하지 않은 코드에 도달합니다. &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 함수는 원시 포인터와 길이를 가져 와서 슬라이스를 만듭니다. 이 함수를 사용하여 &lt;code&gt;ptr&lt;/code&gt; 에서 시작 하고 &lt;code&gt;mid&lt;/code&gt; 항목 길이 인 슬라이스를 만듭니다 . 그런 다음 우리는 전화 &lt;code&gt;add&lt;/code&gt; 에 대한 방법 &lt;code&gt;ptr&lt;/code&gt; 함께 &lt;code&gt;mid&lt;/code&gt; 에서 시작하는 원시 포인터를 얻기 위해 인수로 &lt;code&gt;mid&lt;/code&gt; , 우리는 그 포인터를 사용하여 조각과 후 항목의 나머지 수를 만들 &lt;code&gt;mid&lt;/code&gt; 길이로한다.</target>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; 인덱스가 슬라이스 내에 있다고 주장합니다 . 그런 다음 안전하지 않은 코드를 얻습니다. &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 함수는 원시 포인터와 길이를 가져 와서 슬라이스를 만듭니다. 이 함수를 사용하여 &lt;code&gt;ptr&lt;/code&gt; 에서 시작 하고 &lt;code&gt;mid&lt;/code&gt; 항목 길이 인 슬라이스를 만듭니다 . 그런 다음 우리는 전화 &lt;code&gt;offset&lt;/code&gt; 에 방법 &lt;code&gt;ptr&lt;/code&gt; 함께 &lt;code&gt;mid&lt;/code&gt; 원시 포인터를 얻기 위해 인수로 그에서 시작 &lt;code&gt;mid&lt;/code&gt; , 우리는 그 포인터를 사용하여 조각과 후 항목의 나머지 수를 만들 &lt;code&gt;mid&lt;/code&gt; 길이로한다.</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">우리는 메소드를 정의하고 싶다는 것을 알고 있으므로 &lt;code&gt;impl Rectangle&lt;/code&gt; 블록 내에 있습니다 . 메소드 이름은 &lt;code&gt;can_hold&lt;/code&gt; 가 되고 , 다른 &lt;code&gt;Rectangle&lt;/code&gt; 을 매개 변수로 변경할 수 없습니다 . &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; 는 &lt;code&gt;&amp;amp;rect2&lt;/code&gt; 전달되는 rect1.can_hold (&amp;amp; rect2) 는 &lt;code&gt;Rectangle&lt;/code&gt; 의 인스턴스 인 &lt;code&gt;rect2&lt;/code&gt; 에 대한 불변의 차용인 매개 변수의 유형을 알 수 있습니다 . 이것은 쓰기보다는 &lt;code&gt;rect2&lt;/code&gt; 만 읽어야하기 때문에 의미가 있으며, 이는 변경 가능한 차용이 필요할 원합니다 &lt;code&gt;main&lt;/code&gt; 의 소유권을 유지하기 &lt;code&gt;rect2&lt;/code&gt; 을 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 호출 한 후 다시 사용할 수 있습니다 . &lt;code&gt;can_hold&lt;/code&gt; 의 반환 값은 부울이되고 구현시 &lt;code&gt;self&lt;/code&gt; 의 너비와 높이가 각각 다른 &lt;code&gt;Rectangle&lt;/code&gt; 의 너비와 높이보다 큰지 여부를 확인합니다 . Listing 5-15에 표시된 Listing 5-13 의 &lt;code&gt;impl&lt;/code&gt; 블록에 새로운 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 추가하자 .</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">우리는 &lt;code&gt;list&lt;/code&gt; 과 &lt;code&gt;average&lt;/code&gt; 필드를 비공개로 유지하므로 외부 코드가 &lt;code&gt;list&lt;/code&gt; 필드에 직접 항목을 추가하거나 제거 할 수있는 방법이 없습니다 . 그렇지 않으면 &lt;code&gt;list&lt;/code&gt; 변경 될 때 &lt;code&gt;average&lt;/code&gt; 필드가 동기화되지 않을 수 있습니다 . &lt;code&gt;average&lt;/code&gt; 방법은의 값을 반환 &lt;code&gt;average&lt;/code&gt; 외부 코드를 읽을 수 있도록 필드 &lt;code&gt;average&lt;/code&gt; 그러나 그것을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">스레드 생성과 관련하여 Listing 20-14 의 &lt;code&gt;for&lt;/code&gt; 루프에 주석을 남겼다 . 여기에서는 실제로 스레드를 만드는 방법을 살펴 보겠습니다. 표준 라이브러리는 &lt;code&gt;thread::spawn&lt;/code&gt; 를 생성하는 방법으로 thread :: spawn 을 제공 하며 , &lt;code&gt;thread::spawn&lt;/code&gt; 은 스레드가 생성 되 자마자 스레드가 실행해야하는 코드를 가져옵니다. 그러나 우리의 경우 스레드를 작성하고 나중에 보낼 코드를 &lt;em&gt;기다리&lt;/em&gt; 도록합니다. 표준 라이브러리의 스레드 구현에는 그러한 방법이 포함되어 있지 않습니다. 수동으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값을 나열한 다음 &lt;code&gt;..&lt;/code&gt; 패턴 만 포함합니다 . &lt;code&gt;y: _&lt;/code&gt; 및 &lt;code&gt;z: _&lt;/code&gt; 를 나열하는 것보다 빠릅니다 . 특히 하나 또는 두 개의 필드 만 관련되는 상황에서 많은 필드를 가진 구조체로 작업 할 때 .</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">두 개의 스레드를 만들고 두 번째 스레드와 함께 사용되는 변수 이름을 &lt;code&gt;handle2&lt;/code&gt; 및 &lt;code&gt;num2&lt;/code&gt; 로 변경 합니다. 이번에 코드를 실행할 때 컴파일하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">우리는 프로덕션 코드에서 &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 에 바이트를 쓰고 싶을 수도 있지만 테스트에서는 인 메모리 버퍼를 사용합니다. 우리는 이것을 &lt;code&gt;Cursor&lt;/code&gt; 로 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">우리는 수정 &lt;code&gt;a&lt;/code&gt; 가 가리키는 있도록 &lt;code&gt;b&lt;/code&gt; 대신 &lt;code&gt;Nil&lt;/code&gt; 순환을 만들어. 우리는 &lt;code&gt;tail&lt;/code&gt; 메소드를 사용 하여 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 대한 참조를 얻습니다. 에 &lt;code&gt;a&lt;/code&gt; 변수 &lt;code&gt;link&lt;/code&gt; 넣습니다 . 다음 우리는 사용 &lt;code&gt;borrow_mut&lt;/code&gt; 의 온 방법 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 에서 내부 값을 변경 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 보유 &lt;code&gt;Nil&lt;/code&gt; 받는 값 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 별도의 블록 내 에서 &lt;code&gt;dangerous&lt;/code&gt; 기능을 호출해야합니다 . &lt;code&gt;unsafe&lt;/code&gt; 상태에서 &lt;code&gt;dangerous&lt;/code&gt; 부르려고하면 블록 고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 호출 할 때 전자 메일 또는 문자 메시지를 보내는 대신 보내는 메시지 만 추적 하는 모의 객체가 필요합니다 . 우리는 생성, 모의 개체의 새 인스턴스를 만들 수 있습니다 &lt;code&gt;LimitTracker&lt;/code&gt; , mock 객체를 사용하는 전화 &lt;code&gt;set_value&lt;/code&gt; 에 방법 &lt;code&gt;LimitTracker&lt;/code&gt; 을 하고 mock 객체는 우리가 기대하는 메시지를 가지고 있는지 확인하십시오. Listing 15-21은이를 위해 mock 객체를 구현하려는 시도를 보여 주지만 빌리 체커는이를 허용하지 않는다.</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 작업을 마쳤을 때 할당 자에게이 메모리를 반환하는 방법이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;String&lt;/code&gt; 이 끝나면이 메모리를 운영 체제로 반환하는 방법이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 가 서문에 포함되지 않으므로 범위에 들어가 려면 &lt;code&gt;use&lt;/code&gt; 문 을 추가해야합니다 . &lt;code&gt;main&lt;/code&gt; 에서는 5와 10을 포함하는 목록을 만들고 새 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 저장 &lt;code&gt;a&lt;/code&gt; . 그런 다음 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 를 만들 때 &lt;code&gt;Rc::clone&lt;/code&gt; 함수를 호출하고 인수로 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 참조를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; returns 값에 따라 다른 조치를 취하려면 Listing 9-3의 코드에 추가해야한다 . 목록 9-4는 기본 도구 인 &lt;code&gt;match&lt;/code&gt; 하는 &lt;code&gt;Result&lt;/code&gt; 사용 하여 결과 를 처리하는 한 가지 방법을 보여줍니다. 6 장에서 논의한 표현식 인 .</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="translated">목록 20-23에 표시된 것처럼 &lt;code&gt;Job&lt;/code&gt; 유형이 아닌 &lt;code&gt;Message&lt;/code&gt; 유형의 값을 사용하도록 채널을 조정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">Listing 20-24에 표시된 것처럼 &lt;code&gt;Job&lt;/code&gt; 유형이 아닌 &lt;code&gt;Message&lt;/code&gt; 유형의 값을 사용하도록 채널을 조정해야한다 .</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 상자를 절차 적 매크로 상자로 선언해야합니다 . 우리는 또한 기능이 필요합니다 &lt;code&gt;syn&lt;/code&gt; 잠시 후에 알 수 있듯이 syn 및 &lt;code&gt;quote&lt;/code&gt; 상자 하므로 종속성으로 추가해야합니다. 에 다음을 추가 &lt;em&gt;Cargo.toml에&lt;/em&gt; 대한 파일 &lt;code&gt;hello_macro_derive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">우리는 설정해야합니다 &lt;code&gt;state&lt;/code&gt; 에 &lt;code&gt;None&lt;/code&gt; 일시적이 아닌 다음과 같은 코드로 직접 설정 &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; &lt;code&gt;state&lt;/code&gt; 값의 소유권을 얻습니다 . 이렇게하면 &lt;code&gt;Post&lt;/code&gt; 가 새 상태로 변환 한 후 이전 &lt;code&gt;state&lt;/code&gt; 값을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">매개 변수 &lt;code&gt;args&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 요소 가있는 슬라이스가 있기 때문에 여기에 &lt;code&gt;clone&lt;/code&gt; 필요 했지만 &lt;code&gt;new&lt;/code&gt; 함수에는 &lt;code&gt;args&lt;/code&gt; 가 없습니다 . &lt;code&gt;Config&lt;/code&gt; 인스턴스의 소유권을 반환하기 위해 구성 인스턴스의 값을 복제해야했습니다. &lt;code&gt;query&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 의 필드 &lt;code&gt;Config&lt;/code&gt; 그렇게 &lt;code&gt;Config&lt;/code&gt; 인스턴스가 값을 소유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">컴파일러는 &lt;code&gt;String&lt;/code&gt; 대한 참조 가 유효하게 유지 되도록하기 때문에 엉망이되기 어려운 간단한 API를 가지고 있습니다 . 첫 번째 단어의 끝까지 색인을 받았지만 색인을 무효화하여 문자열을 지울 때 Listing 4-8의 프로그램 버그를 기억 하는가? 이 코드는 논리적으로 올바르지 않지만 즉각적인 오류는 표시하지 않았습니다. 빈 문자열로 첫 번째 단어 색인을 계속 사용하면 문제가 나중에 나타납니다. 슬라이스는이 버그를 불가능하게하고 코드에 더 빨리 문제가 있음을 알려줍니다. &lt;code&gt;first_word&lt;/code&gt; 슬라이스 버전을 사용하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">이제 문자열에서 첫 번째 단어의 끝 색인을 찾는 방법이 있지만 문제가 있습니다. 우리는 자체적 으로 &lt;code&gt;usize&lt;/code&gt; 를 반환 하지만 &lt;code&gt;&amp;amp;String&lt;/code&gt; 의 맥락에서 의미있는 숫자 일뿐입니다. 입니다. 즉, &lt;code&gt;String&lt;/code&gt; 과 는 별도의 값 이므로 앞으로도 여전히 유효하다는 보장은 없습니다. 목록 4-7 의 &lt;code&gt;first_word&lt;/code&gt; 함수 를 사용하는 목록 4-8의 프로그램을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">이제 새 특성 &lt;code&gt;FnBox&lt;/code&gt; 를 구현하는 모든 것의 &lt;code&gt;Box&lt;/code&gt; 가되기 위해 &lt;code&gt;Job&lt;/code&gt; 유형 별명이 필요합니다 . 이를 통해 클로저를 직접 호출하는 대신 &lt;code&gt;Job&lt;/code&gt; 값 을 얻을 때 &lt;code&gt;Worker&lt;/code&gt; 에서 &lt;code&gt;call_box&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;FnOnce()&lt;/code&gt; 클로저에 &lt;code&gt;FnBox&lt;/code&gt; 특성을 구현 한다는 것은 채널을 통해 전송하는 실제 값에 대해 아무것도 변경할 필요가 없음을 의미합니다. 이제 Rust는 우리가하고 싶은 것이 괜찮다는 것을 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 함수가 해당 값을 읽고 호출 여부를 결정할 수 있도록 &lt;code&gt;case_sensitive&lt;/code&gt; 변수 의 값을 &lt;code&gt;Config&lt;/code&gt; 인스턴스에 전달합니다. &lt;code&gt;search&lt;/code&gt; 또는 &lt;code&gt;search_case_insensitive&lt;/code&gt; 12-22에서 구현 한대로 .</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">우리는 &lt;code&gt;#[should_panic]&lt;/code&gt; 애프터 속성을 &lt;code&gt;#[test]&lt;/code&gt; 속성과 테스트 기능 전에 문서의 정보는 다음의 제품에 적용됩니다. 이 테스트를 통과했을 때의 결과를 보자.</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">우리의 전체 내용을로드하여 벤치 마크를 실행 &lt;em&gt;셜록 홈즈의 모험&lt;/em&gt; 에 아서 코난 도일을 &lt;code&gt;String&lt;/code&gt; 단어를 찾고 내용이다. 다음 버전에 대한 벤치 마크의 결과입니다 &lt;code&gt;search&lt;/code&gt; 사용 &lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;/em&gt; 루프를 버전과 반복자 .</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">우리는이 정의를 다음과 같이 읽습니다 : &lt;code&gt;largest&lt;/code&gt; 함수 는 어떤 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 일반적 입니다. 이 함수에는 &lt;code&gt;T&lt;/code&gt; 유형 값의 조각 인 &lt;code&gt;list&lt;/code&gt; 라는 매개 변수가 하나 있습니다. &lt;code&gt;largest&lt;/code&gt; 함수는 동일한 타입의 값에 대한 참조를 반환 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">우리는이 정의를 다음과 같이 읽습니다. &lt;code&gt;largest&lt;/code&gt; 함수 는 일부 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 일반 입니다. 이 함수에는 &lt;code&gt;list&lt;/code&gt; 라는 하나의 매개 변수 가 있으며 이는 &lt;code&gt;T&lt;/code&gt; 유형의 값 조각입니다 . &lt;code&gt;largest&lt;/code&gt; 기능은 같은 타입의 값을 돌려줍니다 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">반복자에 대한 관련 &lt;code&gt;Item&lt;/code&gt; 유형을 &lt;code&gt;u32&lt;/code&gt; 로 설정하여 반복자가 반환 함을 의미합니다. &lt;code&gt;u32&lt;/code&gt; 값 합니다. 다시 한 번, 연관된 유형에 대해 걱정하지 마십시오. 19 장에서 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">테스트 스레드 수를 &lt;code&gt;1&lt;/code&gt; 로 설정했습니다. 프로그램에 병렬 처리를 사용하지 않도록 지시했습니다. 하나의 스레드를 사용하여 테스트를 실행하면 병렬로 실행하는 것보다 시간이 오래 걸리지 만 상태를 공유하는 경우 테스트가 서로 간섭하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">대문자를 가진&amp;ldquo;to&amp;rdquo;를 포함하는 줄을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">&lt;code&gt;Post::new&lt;/code&gt; 사용하여 초안 상태에서 새 게시물을 작성 하고 게시물의 내용에 텍스트를 추가 할 수 있습니다. 그러나 빈 문자열을 반환하는 초안 게시물에 &lt;code&gt;content&lt;/code&gt; 방법을 사용하는 대신 초안 게시물에 &lt;code&gt;content&lt;/code&gt; 방법 이 전혀 없도록 만들 것 입니다. 이렇게하면 초안 게시물의 내용을 가져 오려고하면 메소드가 존재하지 않는다는 컴파일러 오류가 발생합니다. 결과적으로 프로덕션에서 초안 게시물 컨텐츠를 실수로 표시 할 수 없습니다. 해당 코드는 컴파일되지 않기 때문입니다. Listing 17-19는 &lt;code&gt;Post&lt;/code&gt; 구조체와 &lt;code&gt;DraftPost&lt;/code&gt; 의 정의를 보여준다. 구조체 각각에 대한 메소드를 :</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">여전히 &lt;code&gt;Post::new&lt;/code&gt; 함수가 있지만 &lt;code&gt;Post&lt;/code&gt; 인스턴스를 리턴하는 대신 &lt;code&gt;DraftPost&lt;/code&gt; 인스턴스를 리턴합니다 . 때문에 &lt;code&gt;content&lt;/code&gt; 개인이며, 반환 어떤 기능이없는 &lt;code&gt;Post&lt;/code&gt; , 그것의 인스턴스를 만들 수는 없습니다 &lt;code&gt;Post&lt;/code&gt; 지금.</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">우리는 여전히 &lt;code&gt;()&lt;/code&gt; 이 &lt;code&gt;FnOnce&lt;/code&gt; 는 매개 변수를 사용하지 않고 값을 반환하지 않는 클로저를 나타내 므로 &lt;code&gt;FnOnce&lt;/code&gt; 뒤에 . 함수 정의와 마찬가지로 반환 유형은 서명에서 생략 할 수 있지만 매개 변수가 없어도 여전히 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">이 &lt;code&gt;FnOnce&lt;/code&gt; 는 매개 변수를받지 않고 단위 유형 &lt;code&gt;()&lt;/code&gt; 을 반환하는 클로저를 나타 내기 때문에 &lt;code&gt;FnOnce&lt;/code&gt; 뒤에 &lt;code&gt;()&lt;/code&gt; 를 계속 사용합니다 . 함수 정의와 마찬가지로 반환 유형은 서명에서 생략 할 수 있지만 매개 변수가 없더라도 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="translated">구현되지 않은 메서드에 도달하면 프로그램 실행을 중지하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">우리는 4 장에서 줄에 대해 이야기했지만 지금은 더 자세히 살펴볼 것입니다. 새로운 Rustaceans는 일반적으로 세 가지 이유의 조합으로 문자열에 고정됩니다. 가능한 오류를 노출하는 Rust의 성향, 많은 프로그래머가 제공하는 것보다 더 복잡한 데이터 구조 인 문자열 및 UTF-8. 이러한 요소는 다른 프로그래밍 언어에서 올 때 어려워 보일 수있는 방식으로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">코드가 의도 한대로 작동하고 있음을 증명하기 위해 이러한 변수의 값을 임시로 인쇄합니다. 인수 &lt;code&gt;test&lt;/code&gt; 로이 프로그램을 다시 실행 해 봅시다 및 &lt;code&gt;sample.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">그런 다음 &lt;code&gt;unwrap&lt;/code&gt; 메소드 를 호출합니다. 이 패닉은 결코 패닉하지 않습니다. &lt;code&gt;Post&lt;/code&gt; 의 메소드는 해당 메소드가 수행 될 때 &lt;code&gt;state&lt;/code&gt; 항상 &lt;code&gt;Some&lt;/code&gt; 값이 포함 되도록 보장하기 때문 입니다. 이것은 &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;컴파일러보다 더 많은 정보를 가지고있는 사례&amp;rdquo;&lt;/a&gt; 에서 우리가 이야기 한 사례 중 하나입니다. 컴파일러가 이해할 수 없어도 &lt;code&gt;None&lt;/code&gt; 값이 절대 불가능 하다는 것을 알 때 9 장의 섹션 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">그런 다음 &lt;code&gt;macro_rules!&lt;/code&gt; 매크로 정의를 시작합니다 ! 우리가 정의 &lt;em&gt;하지 않은&lt;/em&gt; 매크로의 이름&lt;em&gt;&lt;/em&gt;느낌표 . 이름 (이 경우 &lt;code&gt;vec&lt;/code&gt; ) 뒤에는 매크로 정의의 본문을 나타내는 중괄호가옵니다.</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">우리는 사용 &lt;code&gt;ThreadPool::new&lt;/code&gt; 이 경우 사에, 스레드 구성 번호와 새 스레드 풀을 만들 수 있습니다. 그런 다음 &lt;code&gt;for&lt;/code&gt; 루프에서 &lt;code&gt;pool.execute&lt;/code&gt; 는 각 스트림에 대해 풀을 실행해야한다는 점에서 &lt;code&gt;thread::spawn&lt;/code&gt; 과 유사한 인터페이스를 갖습니다 . 구현해야합니다 &lt;code&gt;pool.execute&lt;/code&gt; 하여 클로저를 가져 와서 풀의 스레드에 실행합니다. 이 코드는 아직 컴파일되지 않지만 컴파일러가이를 수정하는 방법을 안내 할 수 있도록 시도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">우리 는 파일 핸들을 반환하거나 &lt;code&gt;panic!&lt;/code&gt; 호출하기 위해 &lt;code&gt;unwrap&lt;/code&gt; 과 같은 방식으로 &lt;code&gt;expect&lt;/code&gt; 를 사용 합니다 ! 매크로. &lt;code&gt;panic!&lt;/code&gt; 호출 할 때 &lt;code&gt;expect&lt;/code&gt; 되는 오류 메시지 !기본 &lt;code&gt;panic!&lt;/code&gt; 아니라 &lt;code&gt;expect&lt;/code&gt; 하는 매개 변수가됩니다 ! 메시지 &lt;code&gt;unwrap&lt;/code&gt; 사용 . 그 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unwrap_or_else&lt;/code&gt; 대신 &lt;code&gt;if let&lt;/code&gt; 사용 하면 &lt;code&gt;run&lt;/code&gt; 이 &lt;code&gt;Err&lt;/code&gt; 값을 반환 하는지 확인 하고 &lt;code&gt;process::exit(1)&lt;/code&gt; 호출 합니다 . &lt;code&gt;run&lt;/code&gt; 기능에 우리가 원하는 값을 반환하지 않는 &lt;code&gt;unwrap&lt;/code&gt; 같은 방식으로한다는 점에서 &lt;code&gt;Config::new&lt;/code&gt; 반환 &lt;code&gt;Config&lt;/code&gt; 인스턴스입니다. &lt;code&gt;run&lt;/code&gt; 돌아 오기 때문에 &lt;code&gt;()&lt;/code&gt; 우리는 필요가 없습니다 성공의 경우에, 우리는 오류를 감지 신경 &lt;code&gt;unwrap_or_else&lt;/code&gt; 단지가 될 것이기 때문에 풀어 값을 반환 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">우리는 데이터를 레이블링하여 의미를 추가하기 위해 구조체를 사용합니다. 우리가 사용하는 튜플을 목록 5-10에 표시된 것처럼 전체 이름과 부품 이름을 가진 데이터 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">우리는 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 프로그램의 여러 부분이 읽을 힙에 일부 데이터를 할당하려고 할 때 Rc &amp;lt;T&amp;gt; 유형을 사용하며 컴파일 타임에 어떤 부분이 마지막으로 데이터 사용을 완료할지 결정할 수 없습니다. 어떤 부분이 마지막으로 끝날지 알면 해당 부분을 데이터 소유자로 만들 수 있으며 컴파일시 적용되는 일반 소유권 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">우리는 &lt;code&gt;enumerate&lt;/code&gt; 메서드를 사용하여 튜플에 배치 된 반복자에서 값과 해당 값의 색인을 생성하도록 반복자를 조정합니다. &lt;code&gt;enumerate&lt;/code&gt; 위한 첫 번째 호출 은 튜플 &lt;code&gt;(0, 'a')&lt;/code&gt; 합니다. 이 값은 패턴에 일치하는 경우 &lt;code&gt;(index, value)&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 것이다 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;value&lt;/code&gt; 것 &lt;code&gt;'a'&lt;/code&gt; , 출력의 첫 번째 라인을 인쇄.</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">우리는 속기 ANYTOKEN을 사용하여 모든 토큰 세트 (단순 NT 포함)를 나타냅니다. 예를 들어, 매처 M 다음에 유효한 토큰이 있으면 FOLLOW (M) = ANYTOKEN입니다.</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">Listing 14-1 의 &lt;code&gt;# Examples&lt;/code&gt; Markdown 제목을 사용하여 제목이 &quot;Examples&quot;인 HTML 섹션을 만들었습니다. 상자 제작자가 일반적으로 문서에서 사용하는 다른 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">&lt;code&gt;Cacher&lt;/code&gt; 는 호출 코드가 잠재적으로 이러한 필드의 값을 직접 변경하지 않고 구조체 필드의 값을 관리하기를 원 하므로 이러한 필드는 개인용입니다.</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">우리는 원하는 &lt;code&gt;Node&lt;/code&gt; 아이를 소유하고, 우리는 우리가 서로에 액세스 할 수 있도록 변수 소유권을 공유 할 &lt;code&gt;Node&lt;/code&gt; 직접 트리에. 이를 위해 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 항목을 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 유형의 값으로 정의합니다 . 또한 어떤 노드가 다른 노드의 하위 노드인지 수정하려고하므로 &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 주위의 &lt;code&gt;children&lt;/code&gt; 노드에 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">반복기가 현재 상태에 1을 더하기를 원하므로 &lt;code&gt;count&lt;/code&gt; 를 0으로 초기화 하여 1을 먼저 반환합니다. &lt;code&gt;count&lt;/code&gt; 값 이 5보다 작 으면 &lt;code&gt;next&lt;/code&gt; 는 &lt;code&gt;count&lt;/code&gt; 를 증가 시키고 &lt;code&gt;Some&lt;/code&gt; 에 래핑 된 현재 값을 반환합니다 . &lt;code&gt;count&lt;/code&gt; 가 5가 되면 반복기가 &lt;code&gt;count&lt;/code&gt; 증가를 중지 하고 항상 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">반복자가 현재 상태에 1을 추가하기를 원하므로 &lt;code&gt;count&lt;/code&gt; 를 0으로 초기화 하여 1을 먼저 반환합니다. &lt;code&gt;count&lt;/code&gt; 값 이 6보다 작 으면 &lt;code&gt;next&lt;/code&gt; 는 &lt;code&gt;Some&lt;/code&gt; 에 싸여진 현재 값을 반환 하지만 &lt;code&gt;count&lt;/code&gt; 가 6 이상이면 이터레이터는 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">절차 적 매크로가 사용자가 주석을 단 유형 에 대한 &lt;code&gt;HelloMacro&lt;/code&gt; 특성 의 구현을 생성하기를 원합니다 . &lt;code&gt;#name&lt;/code&gt; 을 사용하여 얻을 수 있습니다 . trait 구현에는 &lt;code&gt;hello_macro&lt;/code&gt; 라는 함수가 있는데 , 본문에는 우리가 제공하려는 기능이 포함되어 있습니다. &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; 주석이 달린 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">스레드 풀이 비슷하고 친숙한 방식으로 작동하기 때문에 스레드에서 스레드 풀로 전환 할 때 API를 사용하는 코드를 크게 변경할 필요가 없습니다. Listing 20-12는 &lt;code&gt;thread::spawn&lt;/code&gt; 대신 사용하고자 하는 &lt;code&gt;ThreadPool&lt;/code&gt; 구조체 의 가상 인터페이스를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">방금 생성 한 &lt;code&gt;Worker&lt;/code&gt; 구조체가 &lt;code&gt;ThreadPool&lt;/code&gt; 에 보관 된 대기열에서 실행할 코드를 가져 와서 해당 코드를 스레드로 보내 실행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">환경 변수가 켜져있을 때 호출 할 새로운 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수 를 추가하려고합니다 . 계속해서 TDD 프로세스를 따르므로 첫 번째 단계는 다시 실패한 테스트를 작성하는 것입니다. 새로운 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수에 대한 새로운 테스트를 추가 하고 이전 테스트의 이름 을 &lt;code&gt;case_sensitive&lt;/code&gt; 에서 &lt;code&gt;one_result&lt;/code&gt; 로 변경 하여 목록 12-20에 표시된 것처럼 두 테스트의 차이점을 명확히합니다.</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">사용자가 &lt;code&gt;Post::new&lt;/code&gt; 로 새 초안 블로그 게시물을 만들 수있게하려고합니다 . 그런 다음 초안 상태에있는 동안 블로그 게시물에 텍스트를 추가 할 수 있습니다. 승인 전에 게시물의 내용을 즉시 가져 오려고하면 게시물이 아직 초안이므로 아무 일도 일어나지 않아야합니다. &lt;code&gt;assert_eq!&lt;/code&gt; 추가했습니다 ! 데모 목적으로 코드에서. 이에 대한 훌륭한 단위 테스트는 초안 블로그 게시물이 &lt;code&gt;content&lt;/code&gt; 메소드 에서 빈 문자열을 리턴한다고 주장하는 것이지만이 예제에 대해서는 테스트를 작성하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">우리는 프로그램에서 한곳에서 코드를 정의하려고하지만 실제로 결과가 필요한 곳 에서만 해당 코드를 &lt;em&gt;실행&lt;/em&gt; 합니다. 클로저 사용 사례입니다!</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">우리는 &lt;code&gt;Some(3)&lt;/code&gt; 매치로 무언가를하고 싶지만 다른 &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; 와는 아무 것도하지 않습니다 &amp;lt;u8&amp;gt; 값이나 &lt;code&gt;None&lt;/code&gt; 값으로 . &lt;code&gt;match&lt;/code&gt; 표현식 을 만족시키기 위해서는 하나의 변형 만 처리 한 후 &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; 를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">우리는 Foo가 &lt;code&gt;'a&lt;/code&gt; 과 같이 지적하기 때문에 Foo가 수명을 다하지 않아야한다는 제약을 표현하려고합니다. &lt;code&gt;T&lt;/code&gt; 는 그 수명에 대해서만 유효합니다. 문제는 &lt;code&gt;'a&lt;/code&gt; 의 실제 사용이 없다는 것 입니다. PhantomData 유형을 구조체에 추가하여이 구조체를 사용하여 구조체에 빌린 참조 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 포함 된 것처럼 작동하도록 컴파일러에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="translated">우리는 'MyStruct'에 대해 &lt;code&gt;Foo&lt;/code&gt; 를 구현하고 싶지만 어떤 이유로 &lt;code&gt;bar()&lt;/code&gt; 함수 를 구현하는 것이 합리적 입니다. &lt;code&gt;baz()&lt;/code&gt; 및 &lt;code&gt;qux()&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 구현에서 정의해야 하지만 &lt;code&gt;unimplemented!&lt;/code&gt; 사용할 수 있습니다 ! 코드를 컴파일 할 수 있도록 정의합니다.</target>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">우리는 유형 중 하나에 &lt;code&gt;Foo&lt;/code&gt; 를 구현 하고 싶지만 &lt;code&gt;bar()&lt;/code&gt; 먼저 . 코드를 컴파일하려면 &lt;code&gt;baz()&lt;/code&gt; 를 구현해야 하므로 &lt;code&gt;todo!&lt;/code&gt; 를 사용할 수 있습니다 ! :</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">우리는 유형 중 하나에 &lt;code&gt;Foo&lt;/code&gt; 를 구현 하고 싶지만 &lt;code&gt;bar()&lt;/code&gt; 에서도 작업하고 싶습니다. 먼저 . 코드를 컴파일하려면 &lt;code&gt;baz()&lt;/code&gt; 를 구현해야하므로 구현 &lt;code&gt;unimplemented!&lt;/code&gt; 사용할 수 있습니다 ! :</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">&lt;code&gt;NewsArticle&lt;/code&gt; 또는 &lt;code&gt;Tweet&lt;/code&gt; 에 저장 될 수있는 데이터 요약을 표시 할 수있는 미디어 애그리 게이터 라이브러리를 만들고 싶습니다. 인스턴스에 . 이를 위해서는 각 유형의 요약이 필요 하며 인스턴스 에서 &lt;code&gt;summarize&lt;/code&gt; 메소드를 호출하여 해당 요약을 요청해야 합니다. 목록 10-12는 이 동작을 표현 하는 &lt;code&gt;Summary&lt;/code&gt; 특성 의 정의를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">우리는 모든 종류의 기여를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">우리는 matcher를 나타내는 변수 &quot;M&quot;, 임의의 개별 토큰의 경우 변수 &quot;t&quot;및 &quot;u&quot;, 임의의 토큰 트리의 경우 변수 &quot;tt&quot;및 &quot;uu&quot;를 사용하는 경향이 있습니다. ( &quot;tt&quot;의 사용은 단편 지정자로서의 추가 역할과 함께 잠재적 인 모호성을 나타내지 만 어떤 해석이 의미되는지는 문맥에서 명확 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">우리는이 예제를 위해 본격적인 GUI 라이브러리를 구현하지는 않지만 조각들이 어떻게 어울리는지를 보여줄 것입니다. 라이브러리를 작성할 때 다른 프로그래머가 만들고자하는 모든 유형을 알고 정의 할 수 없습니다. 그러나 &lt;code&gt;gui&lt;/code&gt; 는 다양한 유형의 많은 값을 추적해야하며 이러한 서로 다른 유형의 값 각각에 대해 &lt;code&gt;draw&lt;/code&gt; 메서드 를 호출해야 한다는 것을 알고 있습니다. &lt;code&gt;draw&lt;/code&gt; 메소드를 호출 할 때 어떤 일이 발생하는지 정확히 알 필요는 없습니다 . 단지 값에 해당 메소드를 호출 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">터미널에 대한 출력이 표시되지 않으며 &lt;em&gt;output.txt에&lt;/em&gt; 결과가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">우리는리스트 &lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 감싸서 리스트 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 를 만들 때 , 둘 다 &lt;code&gt;a&lt;/code&gt; 를 참조 할 수 있다 . 이것은 Listing 15-18에서 한 것이다.</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">또한 &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; 장 과 &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; 장 에서 자세히 다루는 클로저, 이터레이터 및 특성 객체에 대해 간략하게 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">Listing 12-24 에있는 &lt;code&gt;main&lt;/code&gt; 기능 의 시작 부분 을 Listing 13-25의 코드로 변경한다. &lt;code&gt;Config::new&lt;/code&gt; 도 업데이트 할 때까지 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">Listing 12-10에서 &lt;code&gt;Config::new&lt;/code&gt; 와 비슷한 기법을 사용하여 오류를 확인하고 처리 하지만 약간의 차이가있다.</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">우리는 다시 &lt;code&gt;panic!&lt;/code&gt; 다시 올 것이다 ! 그리고 우리가 &lt;code&gt;panic!&lt;/code&gt; 사용하거나 사용하지 않아야 할 때 ! 에 오류 조건을 처리하기 &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&quot;를 &lt;code&gt;panic!&lt;/code&gt; 또는 &lt;code&gt;panic!&lt;/code&gt; 하지 마십시오! &quot;&lt;/a&gt; 이 장의 섹션 이상. 다음으로 &lt;code&gt;Result&lt;/code&gt; 사용하여 오류를 복구하는 방법을 살펴 보겠습니다. .</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;execute&lt;/code&gt; 매개 변수로 작업을 수행하지 않으므로 경고 메시지가 계속 표시됩니다 . 원하는 동작으로 이러한 함수의 본문을 구현해 봅시다. 시작하려면 &lt;code&gt;new&lt;/code&gt; 에 대해 생각해 봅시다 . 스레드 수가 음수 인 풀은 의미가 없기 때문에 &lt;code&gt;size&lt;/code&gt; 매개 변수에 부호없는 유형을 선택했습니다 . 그러나 스레드가 0 인 풀도 의미가 없지만 0은 완벽하게 유효한 &lt;code&gt;usize&lt;/code&gt; 입니다. &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스를 반환하기 전에 &lt;code&gt;size&lt;/code&gt; 가 0보다 큰지 확인하는 코드를 추가 하고 &lt;code&gt;assert!&lt;/code&gt; 를 사용하여 0을 받으면 프로그램이 패닉 상태가되도록합니다 ! 매크로 (목록 20-13 참조)</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">채널을 보내려는 클로저를 보유 할 새로운 &lt;code&gt;Job&lt;/code&gt; 구조체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">우리는 목록 만듭니다 (5)를 포함하고 10 그럼 우리가 두 개 더 목록을 만들 수 있습니다 : &lt;code&gt;b&lt;/code&gt; 3으로 시작하는 &lt;code&gt;c&lt;/code&gt; 4 두와 함께 시작하는 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 목록은 다음 첫 번째에 계속 (5)를 포함하는 목록 즉, 두 목록 모두 5와 10을 포함하는 첫 번째 목록을 공유합니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code&gt;execute&lt;/code&gt; 메소드를 정의하여 클로저를 매개 변수로 사용합니다. 로부터 리콜 &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&quot;일반 매개 변수와 사용, 보관 폐쇄 &lt;/a&gt; &lt;code&gt;Fn&lt;/code&gt; 특색&quot; 우리가 세 가지 다른 특성을 가진 매개 변수로 클로저를 취할 수있는 장 13 절 &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; 및 &lt;code&gt;FnOnce&lt;/code&gt; 을 . 여기서 사용할 클로저 종류를 결정해야합니다. 우리는 우리가 표준 라이브러리 비슷한 일을하게 될 겁니다 알고 &lt;code&gt;thread::spawn&lt;/code&gt; 그래서 우리의 서명 경계 무엇을 볼 수, 구현을 &lt;code&gt;thread::spawn&lt;/code&gt; 그 매개 변수에 미치는합니다. 설명서는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">&lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&quot;상자로 재귀 유형 사용&quot;&lt;/a&gt; 섹션 에서 첫 번째 상황을 설명합니다 . 두 번째 경우, 데이터가 스택에서 복사되기 때문에 대량의 데이터 소유권을 이전하는 데 시간이 오래 걸릴 수 있습니다. 이 상황에서 성능을 향상시키기 위해 많은 양의 데이터를 힙에 상자에 저장할 수 있습니다. 그런 다음 적은 양의 포인터 데이터 만 스택에 복사되고 참조하는 데이터는 힙의 한 곳에 유지됩니다. 세 번째 경우는 &lt;em&gt;특성 객체&lt;/em&gt; 라고하며, 17 장에서는 &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;다른 유형의 값을 허용하는 특성 객체 사용&amp;rdquo;&lt;/a&gt; 이라는 주제 전체를 주제별로 설명합니다. 여기서 배우는 내용은 17 장에서 다시 적용됩니다!</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">벡터, 문자열 및 해시 맵을 만들고 업데이트하는 방법과 각각을 특별하게 만드는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">반복자에 대해서는 13 장에서 더 자세히 설명 할 것입니다. 지금은 &lt;code&gt;iter&lt;/code&gt; 가 컬렉션의 각 요소를 반환하고 &lt;code&gt;iter&lt;/code&gt; 의 결과 를 &lt;code&gt;enumerate&lt;/code&gt; 하고 대신 각 요소를 튜플의 일부로 반환하는 메서드 라는 것을 알고 있습니다 . &lt;code&gt;enumerate&lt;/code&gt; 에서 반환 된 튜플의 첫 번째 요소는 인덱스이고 두 번째 요소는 요소에 대한 참조입니다. 이것은 인덱스 자체를 계산하는 것보다 조금 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">실제로 코드를 테스트하지 않고 생성 된 템플릿 테스트를 실험하여 테스트 작동 방식의 일부 측면을 살펴 보겠습니다. 그런 다음 작성한 코드를 호출하는 실제 테스트를 작성하고 해당 동작이 올바른지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">인수를 구문 분석하기위한 기능을 &lt;code&gt;main&lt;/code&gt; 이 명령 줄 구문 분석 논리를 &lt;em&gt;src / lib.rs&lt;/em&gt; 로 이동하기 위해 호출 할 함수로 추출합니다 . Listing 12-5는 새로운 함수 &lt;code&gt;parse_config&lt;/code&gt; 를 호출하는 새로운 &lt;code&gt;main&lt;/code&gt; 시작을 보여줍니다. parse_config 는 &lt;em&gt;src / main.rs&lt;/em&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">먼저 &lt;em&gt;string&lt;/em&gt; 이라는 용어의 의미를 정의 &lt;em&gt;합니다&lt;/em&gt; . Rust는 핵심 언어의 문자열 유형을 하나만 가지고 있으며, 일반적으로 빌린 &lt;code&gt;&amp;amp;str&lt;/code&gt; 형식으로 표시 되는 문자열 슬라이스 &lt;code&gt;str&lt;/code&gt; 입니다 . 4 장에서는 다른 곳에 저장된 UTF-8로 인코딩 된 문자열 데이터에 대한 참조 인 &lt;em&gt;문자열 슬라이스에&lt;/em&gt; 대해 이야기했습니다 . 예를 들어 문자열 리터럴은 프로그램의 이진에 저장되므로 문자열 슬라이스입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;Draw&lt;/code&gt; 특성을 구현하지 않기 때문에이 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">이 섹션에서는 해시 맵의 기본 API를 살펴 보지만 표준 라이브러리에 의해 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 에 정의 된 함수에는 더 많은 장점이 숨겨져 있습니다. 항상 그렇듯이 자세한 내용은 표준 라이브러리 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">동시성에 대해 이야기 할 때 16 장에 더 많은 &lt;code&gt;move&lt;/code&gt; 클로저 예제가 있습니다. 지금, Listing 13-12의 코드는 &lt;code&gt;move&lt;/code&gt; 키워드가 클로저 정의에 추가되고 정수 대신 벡터를 사용하는 정수입니다. 정수는 이동하지 않고 복사 될 수 있기 때문입니다. 이 코드는 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">점진적으로 블로그 게시물 워크 플로를 구현합니다. 블로그의 최종 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">우리는 고전적인 초보자 프로그래밍 문제인 추측 게임을 구현할 것입니다. 작동 방식은 다음과 같습니다. 프로그램은 1에서 100 사이의 임의의 정수를 생성합니다. 그런 다음 플레이어에게 추측을 입력하라는 메시지가 표시됩니다. 추측이 입력 된 후 프로그램은 추측이 너무 낮거나 높은지 표시합니다. 추측이 맞으면 게임은 축하 메시지를 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 과이 새로운 동작을 관리 할 스레드 사이에 새로운 데이터 구조를 도입하여이 동작을 구현할 것입니다. 풀링 구현에서 흔히 사용되는 이 데이터 구조 &lt;code&gt;Worker&lt;/code&gt; 라고합니다 . 식당의 주방에서 일하는 사람들을 생각해보십시오. 직원은 고객의 주문이 들어올 때까지 기다렸다가 주문을 받아서 채울 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; 에 &lt;code&gt;content&lt;/code&gt; 메소드를 그대로두고 빈 문자열 슬라이스를 리턴합니다. 이제 &lt;code&gt;PendingReview&lt;/code&gt; 상태와 &lt;code&gt;Draft&lt;/code&gt; 상태 에서 &lt;code&gt;Post&lt;/code&gt; 를 가질 수 있지만 &lt;code&gt;PendingReview&lt;/code&gt; 상태 에서 동일한 동작을 원합니다 . Listing 17-11은 이제 10 행까지 작동합니다!</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">서비스 거부 (DoS) 공격으로부터 보호하기 위해 풀의 스레드 수를 작은 수로 제한합니다. 우리가 프로그램에 들어올 때마다 요청마다 새로운 스레드를 만들도록했다면, 서버에 1,000 만 건의 요청을하는 사람은 서버의 모든 리소스를 사용하고 요청 처리를 중단하여 혼란을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">느리게 처리되는 요청이 현재 서버 구현에 대한 다른 요청에 어떻게 영향을 미치는지 살펴 보겠습니다. Listing 20-10 은 시뮬레이션 된 느린 응답 으로 &lt;em&gt;/ sleep&lt;/em&gt; 요청을 처리 하여 서버가 응답하기 전에 5 초 동안 휴면 상태가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 값이 여전히 &lt;code&gt;_s&lt;/code&gt; 로 이동 하여 &lt;code&gt;s&lt;/code&gt; 를 다시 사용할 수 없으므로 오류가 발생 합니다. 그러나 밑줄을 단독으로 사용한다고해서 그 가치에 구속되는 것은 아닙니다. &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;_&lt;/code&gt; 로 이동하지 않기 때문에 Listing 18-22는 오류없이 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 특성과이를 사용자 정의 유형과 함께 사용하는 방법 에 대해 설명하여이 장을 마무리 하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">우리는 다른 상충 관계를 얻기 위해 상태 패턴을 재고하는 방법을 보여줄 것입니다. 외부 코드가 그 상태를 알지 못하도록 상태와 전이를 완전히 캡슐화하지 않고 상태를 다른 유형으로 인코딩합니다. 따라서 Rust의 유형 검사 시스템은 컴파일러 오류를 발행하여 게시 된 게시물 만 허용되는 초안 게시물을 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">Listing 13-1에 표시된 가상 함수 인 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 된 _expensive_calculation을 사용하여이 가상 알고리즘을 호출하는 것을 시뮬레이트 할 것이다.이 함수 는 &lt;code&gt;calculating slowly...&lt;/code&gt; 하는 것을 인쇄 하고 2 초 동안 기다린 다음 전달한 숫자를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">단일 스레드 웹 서버를 작동시키는 것으로 시작하겠습니다. 시작하기 전에 웹 서버 구축과 관련된 프로토콜에 대한 간단한 개요를 살펴 보겠습니다. 이 프로토콜의 세부 사항은이 책의 범위를 벗어나지 만 간략한 개요는 필요한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">우리는 이들 각각에 대해 차례로 이야기 할 것이지만, 먼저 함수가있을 때 매크로가 필요한 이유를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">실제로 파일 내용에서 쿼리 문자열을 검색하고 쿼리와 일치하는 행 목록을 생성하는 기능의 구현을 테스트합니다. 이 기능을 &lt;code&gt;search&lt;/code&gt; 라는 함수에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">여기서는 &lt;code&gt;String&lt;/code&gt; 을 예로 사용 하고 소유권과 관련된 &lt;code&gt;String&lt;/code&gt; 부분에 중점 을 둘 것입니다. 이러한 측면은 표준 라이브러리에서 제공하고 사용자가 생성 한 다른 복잡한 데이터 유형에도 적용됩니다. 우리는 8 장에서 &lt;code&gt;String&lt;/code&gt; 에 대해 더 깊이 논의 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">여기서는 &lt;code&gt;String&lt;/code&gt; 을 예제로 사용 하고 소유권과 관련된 &lt;code&gt;String&lt;/code&gt; 부분에 집중할 것입니다 . 이러한 측면은 표준 라이브러리에서 제공하거나 사용자가 생성 한 다른 복잡한 데이터 유형에도 적용됩니다. 8 장에서 &lt;code&gt;String&lt;/code&gt; 에 대해 더 깊이 논의 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">Listing 12-24의 코드를 사용하여 오류 메시지가 인쇄되는 방식을 변경한다. 이 장의 앞부분에서 수행 한 리팩토링으로 인해 오류 메시지를 인쇄하는 모든 코드는 &lt;code&gt;main&lt;/code&gt; 함수 하나에 있습니다 . 표준 라이브러리는 &lt;code&gt;eprintln!&lt;/code&gt; 제공합니다 ! 매크로를 표준 오류 스트림으로 인쇄하므로 &lt;code&gt;println!&lt;/code&gt; 이라고 부르는 두 곳을 변경해 봅시다 ! &lt;code&gt;eprintln!&lt;/code&gt; 을 사용하여 오류를 인쇄합니다 ! 대신에.</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 가 사용될 때 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;5&lt;/code&gt; 에서 &lt;code&gt;6&lt;/code&gt; 으로 바인딩 되는 값을 변경할 수 있습니다 . 경우에 따라서는 불변 변수 만있는 것보다 코드를 작성하는 것이 더 편리하기 때문에 변수를 변경 가능하게 만들고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">하드 코드 된 문자열을 구문 분석 하여 &lt;code&gt;IpAddr&lt;/code&gt; 인스턴스를 작성 중 입니다. 우리는 것을 알 수 있습니다 &lt;code&gt;127.0.0.1&lt;/code&gt; 이 그것을 사용하는 것이 허용 그래서, 유효한 IP 주소입니다 &lt;code&gt;unwrap&lt;/code&gt; 여기. 그러나,의 반환 형식이 변경되지 않는 하드 코딩, 유효한 문자열 가진 &lt;code&gt;parse&lt;/code&gt; 방법을 우리는 아직도 얻을 &lt;code&gt;Result&lt;/code&gt; 값을, 컴파일러는 여전히 우리가 처리 할 것입니다 &lt;code&gt;Result&lt;/code&gt; 는 IF로 &lt;code&gt;Err&lt;/code&gt; 변형 가능성 때문에 컴파일러 ISN ' 이 문자열이 항상 유효한 IP 주소임을 알기에 충분합니다. IP 주소 문자열이 때문에 오히려 프로그램으로 하드 코딩되지 않고 사용자로부터 온 경우 &lt;em&gt;한&lt;/em&gt; 실패의 가능성이있다, 우리는 확실히 처리 할 것 &lt;code&gt;Result&lt;/code&gt; 대신보다 강력한 방식으로 결과를 얻 습니다.</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">우리는 작업이 실패 할 수있는보다 복잡한 프로그램을 사용하고 있으므로 오류 처리에 대해 논의하기에 완벽한시기입니다. 다음에 할게요!</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">우리는이 코드 라인을 가지고 있지 않습니다. 지금까지 논의한 내용은 한 줄의 텍스트이지만, 하나의 논리적 코드 줄의 첫 번째 부분입니다. 두 번째 부분은이 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">우리는 이제 두 번 작업자를 반복합니다. 한 번은 각 작업자 에게 하나의 &lt;code&gt;Terminate&lt;/code&gt; 메시지 를 보내고 한 번은 각 작업자의 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 합니다. 메시지를 보내고 동일한 루프에서 즉시 &lt;code&gt;join&lt;/code&gt; 하려고 하면 현재 반복의 작업자가 채널에서 메시지를 가져 오는 사람임을 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">우리는 Rust에 꺾쇠 괄호 안에 유형 주석을 제공하고 있는데, &lt;code&gt;Dog&lt;/code&gt; 에 구현 된대로 &lt;code&gt;Animal&lt;/code&gt; 특성 에서 &lt;code&gt;baby_name&lt;/code&gt; 메소드 를 호출 하여 &lt;code&gt;Dog&lt;/code&gt; 유형 을이 함수 호출 의 &lt;code&gt;Animal&lt;/code&gt; 로 취급하고 싶다는 것을 나타 냅니다. 이 코드는 이제 우리가 원하는 것을 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">우리는 지금 경고 만 받고 있습니다. 즉 컴파일됩니다! 그러나 &lt;code&gt;cargo run&lt;/code&gt; 을 시도 하고 브라우저에서 요청하면 장의 시작 부분에서 본 브라우저의 오류가 표시됩니다. 우리 라이브러리는 실제로 &lt;code&gt;execute&lt;/code&gt; 을 위해 전달 된 클로저를 호출하지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">우리는 여전히 명령 줄 인수를 벡터로 수집하지만 인덱스 1의 인수 값을 변수 &lt;code&gt;query&lt;/code&gt; 에 할당하고 인덱스 2의 인수 값을 변수 &lt;code&gt;filename&lt;/code&gt; 내의 변수 파일 이름 에 할당하는 대신 &lt;code&gt;main&lt;/code&gt; 함수 전체 벡터를 &lt;code&gt;parse_config&lt;/code&gt; 함수. &lt;code&gt;parse_config&lt;/code&gt; 의 기능은 어느 인자를 결정하는 변수는 꺼지고 값으로 다시 전달하는 로직을 가지고 &lt;code&gt;main&lt;/code&gt; . 우리는 여전히 &lt;code&gt;main&lt;/code&gt; 에 &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;filename&lt;/code&gt; 변수를 생성 하지만 &lt;code&gt;main&lt;/code&gt; 더 이상 명령 줄 인수와 변수가 어떻게 일치하는지 결정해야 할 책임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">우리는 여전히 &lt;code&gt;search&lt;/code&gt; 에서 각 줄을 반환 하고 인쇄하기 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="translated">우리는 여전히이 코드 줄을 작업 중입니다. 이제 세 번째 텍스트 줄에 대해 논의하고 있지만 여전히 단일 논리적 코드 줄의 일부입니다. 다음 부분은이 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">Listing 15-5 의 다른 &lt;code&gt;List&lt;/code&gt; 정의 변형을 사용하고있다 . &lt;code&gt;Cons&lt;/code&gt; 변형 의 두 번째 요소 는 이제 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; . 즉, &lt;code&gt;i32&lt;/code&gt; , Listing 15-24에서와 같이 i32 값 &lt;code&gt;Cons&lt;/code&gt; 변형이 가리키는 &lt;code&gt;List&lt;/code&gt; 값 을 수정하려고합니다. 에. 또한 &lt;code&gt;Cons&lt;/code&gt; 변형 이있는 경우 두 번째 항목에 편리하게 액세스 할 수 있도록 &lt;code&gt;tail&lt;/code&gt; 메소드를 추가하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">우리는 사용하고 &lt;code&gt;is_err&lt;/code&gt; 온 방법을 &lt;code&gt;Result&lt;/code&gt; 그것이 의미 오류 때문에 해제,인지 확인 &lt;em&gt;해야&lt;/em&gt; 소문자 구분 검색을 수행. 는 IF &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 의 환경 변수가 무엇으로 설정되어 &lt;code&gt;is_err&lt;/code&gt; false를 반환하고 프로그램은 대소 문자를 구분 검색을 수행합니다. 우리는 상관하지 않습니다&lt;em&gt;&lt;/em&gt; 환경 변수&lt;em&gt; 값&lt;/em&gt; 은 설정 또는 설정 해제 여부에 &lt;code&gt;is_err&lt;/code&gt; 쓰지 않으므로 &lt;code&gt;unwrap&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; 또는 &lt;code&gt;Result&lt;/code&gt; 에서 본 다른 메소드를 사용하는 대신 is_err을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">우리는 실제로 문장과 표현을 사용했습니다. &lt;em&gt;명령문&lt;/em&gt; 은 일부 조치를 수행하고 값을 리턴하지 않는 지시 사항입니다. &lt;em&gt;식은&lt;/em&gt; 결과 값으로 평가됩니다. 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">단위 테스트에서는 필요하지 않은 &lt;code&gt;use adder&lt;/code&gt; 를 코드 맨 위에 추가했습니다 . 그 이유는 &lt;code&gt;tests&lt;/code&gt; 디렉토리의 각 파일 이 별도의 상자이기 때문에 라이브러리를 각 테스트 상자의 범위로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">우리는 단위 테스트에서 필요하지 않은 코드 상단에 &lt;code&gt;use adder&lt;/code&gt; 를 추가했습니다 . 그 이유는 &lt;code&gt;tests&lt;/code&gt; 디렉토리의 각 테스트 는 별도의 상자이므로 라이브러리를 각 테스트 상자의 범위로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">표준 라이브러리의 파일 시스템 모듈을 범위 내로 가져 오기 위해 맨 위에 줄을 추가했습니다. 파일의 내용을 문자열로 읽는 코드는 익숙해야합니다. Listing 12-4에서 I / O 프로젝트의 파일 내용을 읽을 때 12 장에서 사용했다.</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">표준 라이브러리에서 범위로 &lt;code&gt;process&lt;/code&gt; 를 가져 오는 새로운 &lt;code&gt;use&lt;/code&gt; 라인을 추가했습니다 . 오류 사례에서 실행될 클로저의 코드는 두 줄입니다. &lt;code&gt;err&lt;/code&gt; 값을 인쇄 한 다음 &lt;code&gt;process::exit&lt;/code&gt; . &lt;code&gt;process::exit&lt;/code&gt; 기능은 프로그램을 즉시 중지하고 종료 상태 코드로 전달 된 수를 반환합니다. 이것은 &lt;code&gt;panic!&lt;/code&gt; 과 비슷합니다 ! 우리는 Listing 12-8에서 사용한 처리를 기반으로하지만 더 이상 추가 출력을 얻지 못한다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; 이라는 필드를 갖도록 정의 된 &lt;code&gt;Config&lt;/code&gt; 라는 구조체를 추가했습니다 . &lt;code&gt;parse_config&lt;/code&gt; 의 서명은 이제 &lt;code&gt;Config&lt;/code&gt; 값을 반환 함을 나타냅니다 . &lt;code&gt;args&lt;/code&gt; 의 &lt;code&gt;String&lt;/code&gt; 값 을 참조하는 문자열 슬라이스를 반환하는 데 사용되는 &lt;code&gt;parse_config&lt;/code&gt; 본문 에서 소유 한 &lt;code&gt;String&lt;/code&gt; 값 을 포함하도록 &lt;code&gt;Config&lt;/code&gt; 를 정의 합니다. 그만큼 &lt;code&gt;args&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; args 변수 는 인수 값의 소유자이며 &lt;code&gt;parse_config&lt;/code&gt; 함수가 빌려주 는 것만 허용 합니다. 이는 &lt;code&gt;Config&lt;/code&gt; 인 경우 Rust의 빌리기 규칙을 위반 함을 의미합니다 &lt;code&gt;args&lt;/code&gt; 의 값을 소유하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">우리는 문서 주석과 함께 &lt;code&gt;ThreadPool&lt;/code&gt; 에 대한 문서를 추가했습니다 . 14 장에서 논의한 바와 같이 함수가 패닉 상태가 될 수있는 섹션을 추가하여 훌륭한 문서 관행을 따랐다는 점에 주목하십시오. &lt;code&gt;cargo doc --open&lt;/code&gt; 을 실행 하고 &lt;code&gt;ThreadPool&lt;/code&gt; 구조체를 클릭 하여 생성 된 문서가 &lt;code&gt;new&lt;/code&gt; 모양에 대해 무엇인지 확인하십시오. 처럼!</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; 메소드를 &lt;code&gt;State&lt;/code&gt; 특성에 추가했습니다 . 특성을 구현하는 모든 유형은 이제 &lt;code&gt;request_review&lt;/code&gt; 메소드 를 구현해야합니다 . 메소드의 첫 번째 매개 변수로 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 를 갖는 대신 , &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 있습니다. 이 구문 은 유형이 들어 있는 &lt;code&gt;Box&lt;/code&gt; 에서 호출 된 경우에만 메소드가 유효 함을 의미합니다 . 이 구문은 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; 가져서 이전 상태를 무효화하므로 &lt;code&gt;Post&lt;/code&gt; 의 상태 값이 새로운 상태로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">이 책에서 이미 &lt;code&gt;String&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터라고 부르지는 않았지만 8 장의 Vec &amp;lt;T&amp;gt; . 이 두 가지 유형 모두 메모리를 소유하고 조작 할 수 있기 때문에 스마트 포인터로 계산됩니다. 또한 메타 데이터 (예 : 용량) 및 추가 기능 또는 보증 (예 : 데이터가 항상 유효한 UTF-8인지 확인하는 &lt;code&gt;String&lt;/code&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">우리는 이미 문자열 리터럴을 보았습니다. 문자열 리터럴은 프로그램에 하드 코딩되어 있습니다. 문자열 리터럴은 편리하지만 텍스트를 사용하려는 모든 상황에 적합하지는 않습니다. 한 가지 이유는 불변이기 때문입니다. 또 다른 코드는 코드를 작성할 때 모든 문자열 값을 알 수 없다는 것입니다. 예를 들어 사용자 입력을 받아 저장하려면 어떻게해야합니까? 이러한 상황에서 Rust에는 두 번째 문자열 유형 인 &lt;code&gt;String&lt;/code&gt; 이 있습니다. 이 유형은 힙에 할당되므로 컴파일 타임에 알려지지 않은 양의 텍스트를 저장할 수 있습니다. &lt;code&gt;String&lt;/code&gt; 만들 수 있습니다 &lt;code&gt;from&lt;/code&gt; 함수를 사용하여 문자열 리터럴에서 을 .</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;thread::JoinHandle&lt;/code&gt; 사용하기 때문에 &lt;code&gt;std::thread&lt;/code&gt; 를 라이브러리 상자의 범위로 가져 왔습니다. &lt;code&gt;ThreadPool&lt;/code&gt; 에서 벡터의 항목 유형으로 을 .</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">우리는에있는 필드의 이름을 변경 한 &lt;code&gt;ThreadPool&lt;/code&gt; 의 에서 &lt;code&gt;threads&lt;/code&gt; 에 &lt;code&gt;workers&lt;/code&gt; 지금 잡고 있기 때문에 &lt;code&gt;Worker&lt;/code&gt; 대신 인스턴스 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 인스턴스. &lt;code&gt;for&lt;/code&gt; 루프 의 카운터 를 &lt;code&gt;Worker::new&lt;/code&gt; 대한 인수로 사용하고 각각의 새로운 &lt;code&gt;Worker&lt;/code&gt; 를 벡터라는 벡터에 저장합니다. &lt;code&gt;workers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">우리는 함수 버전에서 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 을 사용한 것과 같은 이유로 &lt;code&gt;&amp;amp;self&lt;/code&gt; 선택했습니다 . 우리는 소유권을 원하지 않고 구조체의 데이터를 읽고 쓰지 않고 싶어합니다. 메소드의 일부로 메소드를 호출 한 인스턴스를 변경하려면 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 를 첫 번째 매개 변수로 사용합니다. &lt;code&gt;self&lt;/code&gt; 를 사용하여 인스턴스 소유권을 얻는 방법 를 첫 번째 매개 변수로 것은 드문 일입니다. 이 기술은 일반적으로 메소드가 다른 것으로 &lt;code&gt;self&lt;/code&gt; 을 변환하고 변환 후 호출자가 원래 인스턴스를 사용하지 못하게하려는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">우리는 사용하여 원시 포인터를 만들었습니다. &lt;code&gt;as&lt;/code&gt; 를 불변 및 변경 가능한 참조를 해당 원시 포인터 유형으로 캐스트 . 우리는 유효한 것으로 보장 된 참조에서 직접 생성했기 때문에 이러한 특정 원시 포인터가 유효하다는 것을 알고 있지만 원시 포인터에 대해서만 가정 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">우리는 어떤 유형의 인수 든 원하는 수의 매크로를 정의했으며 지정된 요소를 포함하는 벡터를 생성하는 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">이 장의 대부분의 고급 기능은 거의 필요하지 않은 것으로 설명했습니다. 연관된 유형은 중간에 있습니다.이 책의 나머지 부분에서 설명하는 기능보다는 드물게 사용되지만이 장에서 논의 된 다른 많은 기능보다 더 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">이 책의 앞부분에서 열거 형을 구조화했습니다. 예를 들어, 6 장의 목록 6-5에서 &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; 를 구조화 할 때 명시 적으로 언급하지 않은 세부 사항은 열거 형을 구조화하는 패턴이 방식과 일치해야한다는 것입니다 열거 형 내에 저장된 데이터가 정의됩니다. 예를 들어, Listing 18-15 에서 Listing 6-2 의 &lt;code&gt;Message&lt;/code&gt; enum을 사용하고 &lt;code&gt;match&lt;/code&gt; 작성한다 각 내부 값을 패턴 을 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">우리는 코드를 제공했습니다! 이 코드는 완벽하게 유효하지만 오류 없이는 반박 할 수없는 패턴을 사용할 수 없습니다. 우리는주는 경우에 &lt;code&gt;if let&lt;/code&gt; 등 항상 일치하는 패턴, &lt;code&gt;x&lt;/code&gt; 목록 18-10에서와 같이를, 그것은 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="translated">코드가 나왔습니다! 이 코드는 오류를받지 않고는 반박 할 수없는 패턴을 사용할 수 없지만 완벽하게 유효합니다. Listing 18-10에 표시된 것처럼 &lt;code&gt;x&lt;/code&gt; 와 같이 항상 일치하는 패턴을 &lt;code&gt;if let&lt;/code&gt; 제공 하면 컴파일러는 경고를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">우리는 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 변수 를 10으로, 그리고 &lt;code&gt;simulated_random_number&lt;/code&gt; 변수 를 7 로 하드 코딩했습니다 . 실제 프로그램에서는 앱 프론트 엔드에서 강도 번호를 얻습니다 . 2 장의 추측 게임 예제에서와 같이 &lt;code&gt;rand&lt;/code&gt; 상자를 사용하여 난수를 생성합니다. &lt;code&gt;main&lt;/code&gt; 함수는 &lt;code&gt;generate_workout&lt;/code&gt; 함수를 호출 합니다. 시뮬레이션 된 입력 값으로.</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; , &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; 라는 세 개의 새로운 상자가 도입되었습니다 . &lt;code&gt;proc_macro&lt;/code&gt; 우리의 종속성이를 추가 할 필요가 없었다, 그래서 상자는 녹 함께 제공 &lt;em&gt;Cargo.toml&lt;/em&gt; . &lt;code&gt;proc_macro&lt;/code&gt; 상자는 우리가 읽고 우리의 코드에서 녹 코드를 조작 할 수 있습니다 컴파일러의 API입니다.</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 키워드 , 필드 및 &lt;code&gt;new&lt;/code&gt; 메소드 및 &lt;code&gt;run&lt;/code&gt; 함수 에서 &lt;code&gt;pub&lt;/code&gt; 키워드를 자유롭게 사용 했습니다 . 이제 테스트 할 수있는 공개 API가있는 라이브러리 상자가 있습니다!</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">우리는 작고 간단한 변경을했습니다 : 채널의 수신 끝을 &lt;code&gt;Worker::new&lt;/code&gt; 로 전달합니다. 다음 클로저 내부에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">여기에서 세 가지 중요한 변경 사항이 있습니다. 먼저 &lt;code&gt;run&lt;/code&gt; 함수 의 반환 유형 을 &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; . 이 함수는 이전에 단위 유형 &lt;code&gt;()&lt;/code&gt; 을 반환했으며 &lt;code&gt;Ok&lt;/code&gt; 경우에 반환 된 값으로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 기능 의 본문에서 두 가지가 변경되었습니다 : &lt;code&gt;panic!&lt;/code&gt; 을 호출하는 대신 ! 사용자가 충분한 인수를 전달하지 않으면 이제 &lt;code&gt;Err&lt;/code&gt; 값을 반환 하고 &lt;code&gt;Config&lt;/code&gt; 반환 값을 &lt;code&gt;Ok&lt;/code&gt; 에 래핑했습니다 . 이러한 변경으로 함수가 새로운 유형 서명을 준수하게됩니다.</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">Rust에서는 다른 언어의 객체와 구별하기 위해 구조체 및 열거 형 &quot;객체&quot;를 호출하지 않는다고 언급했습니다. 구조체 또는 열거 형에서는 구조체 필드의 데이터와 &lt;code&gt;impl&lt;/code&gt; 블록 의 동작 이 분리되는 반면 다른 언어에서는 하나의 개념으로 결합 된 데이터와 동작이 종종 개체로 표시됩니다. 그러나 특성 개체 &lt;em&gt;는&lt;/em&gt; 데이터와 동작을 결합한다는 점에서 다른 언어의 개체와 더 비슷합니다. 그러나 특성 개체는 특성 개체에 데이터를 추가 할 수 없다는 점에서 기존 개체와 다릅니다. 특성 객체는 다른 언어의 객체만큼 일반적으로 유용하지 않습니다. 특정 목적은 공통된 동작에 대한 추상화를 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">우리는 새의 창조 이동 한 &lt;code&gt;String&lt;/code&gt; 에서 &lt;code&gt;s&lt;/code&gt; 함수의 시작 부분을; 그 부분은 바뀌지 않았습니다. 변수 &lt;code&gt;f&lt;/code&gt; 를 만드는 대신 &lt;code&gt;read_to_string&lt;/code&gt; 호출을 &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; 의 결과에 직접 연결 했습니까? . 우리는 여전히 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 호출 이 끝날 때 &lt;code&gt;File::open&lt;/code&gt; 및 &lt;code&gt;read_to_string&lt;/code&gt; 이 모두 오류를 반환하지 않고 성공 하면 &lt;code&gt;s&lt;/code&gt; 에 사용자 이름을 포함 하는 &lt;code&gt;Ok&lt;/code&gt; 값을 반환합니다. 기능은 목록 9-6 및 목록 9-7과 동일합니다. 이것은 다른 인체 공학적 방식으로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">테스트의 이름을 &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; 지정하고 필요한 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스 두 개를 만들었습니다 . 그런 다음 우리는 &lt;code&gt;assert!&lt;/code&gt; 불렀습니다 ! 매크로를 작성하고 &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; 를 호출 한 결과를 전달했습니다 . 이 표현식은 &lt;code&gt;true&lt;/code&gt; 를 반환 해야하므로 테스트를 통과해야합니다. 알아 보자!</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">이제 열거 형을 사용하여 열거 된 값 집합 중 하나 일 수있는 사용자 지정 유형을 만드는 방법을 설명했습니다. 표준 라이브러리의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 유형 시스템을 사용하여 오류를 방지 하는 방법을 보여주었습니다 . 열거 값이 그 안에서 데이터가있는 경우, 당신이 사용할 수있는 &lt;code&gt;match&lt;/code&gt; 하거나 &lt;code&gt;if let&lt;/code&gt; 추출하고 처리 할 필요가 얼마나 많은 경우에 따라 그 값을 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">우리는 Rust가 객체 지향 디자인 패턴을 구현할 수 있음에도 불구하고 타입 시스템에 상태를 인코딩하는 것과 같은 다른 패턴도 Rust에서 사용 가능하다는 것을 알았습니다. 이러한 패턴에는 다른 상충 관계가 있습니다. 객체 지향 패턴에 대해 잘 알고 있지만 Rust의 기능을 활용하기 위해 문제를 다시 생각하면 컴파일시 일부 버그를 방지하는 등의 이점이 있습니다. 객체 지향 패턴은 소유권과 같은 객체 지향 언어에없는 특정 기능으로 인해 Rust에서 항상 최상의 솔루션은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">버전 4 및 버전 6 IP 주소를 저장하기 위해 데이터 구조를 정의하는 여러 가지 방법을 보여주었습니다. 그러나 IP 주소를 저장하고 어떤 종류의 IP 주소를 인코딩하길 원하는지는 매우 일반적인 것으로 &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;표준 라이브러리에 사용할 수있는 정의가 있습니다!&lt;/a&gt; 표준 라이브러리가 &lt;code&gt;IpAddr&lt;/code&gt; 을 정의하는 방법을 살펴 보겠습니다 . 우리가 정의하고 사용한 정확한 열거 형과 변형이 있지만 각 변형에 대해 다르게 정의 된 두 개의 다른 구조체 형태로 변형에 주소 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">우리는 Rust가 객체 지향 상태 패턴을 구현하여 게시물이 각 상태에서 가져야하는 다양한 종류의 행동을 캡슐화 할 수 있음을 보여주었습니다. &lt;code&gt;Post&lt;/code&gt; 의 메소드 는 다양한 동작에 대해 아무것도 모릅니다. 우리가 코드를 구성하는 방식에서는 게시 된 게시물이 동작 할 수있는 다른 방법, 즉 &lt;code&gt;Published&lt;/code&gt; 구조체 에 대한 &lt;code&gt;State&lt;/code&gt; 특성 의 구현을 알기 위해 한 곳에서만 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">벡터에서 &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;into_iter&lt;/code&gt; 또는 &lt;code&gt;iter_mut&lt;/code&gt; 을 호출하여 반복자를 만들 수 있음을 보여 주었습니다 . 표준 라이브러리의 다른 컬렉션 유형 (예 : 해시 맵)에서 반복자를 만들 수 있습니다. &lt;code&gt;Iterator&lt;/code&gt; 특성을 고유 한 유형 으로 구현하여 원하는 것을 수행하는 반복자를 작성할 수도 있습니다 . 앞에서 언급했듯이, 정의를 제공해야하는 유일한 방법은 &lt;code&gt;next&lt;/code&gt; 방법입니다. 일단 완료하면 &lt;code&gt;Iterator&lt;/code&gt; 특성에서 제공하는 기본 구현을 가진 다른 모든 메소드를 사용할 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">클로저를 함수에 전달하는 방법에 대해 이야기했습니다. 정규 함수를 함수에 전달할 수도 있습니다! 이 기법은 새 클로저를 정의하지 않고 이미 정의한 함수를 전달할 때 유용합니다. 함수 포인터로이를 수행하면 함수를 다른 함수의 인수로 사용할 수 있습니다. 함수 는 &lt;code&gt;Fn&lt;/code&gt; 클로저 특성 과 혼동되지 않도록 유형 &lt;code&gt;fn&lt;/code&gt; (소문자 f로)을 강제합니다 . &lt;code&gt;fn&lt;/code&gt; 유형은 호출 &lt;em&gt;함수 포인터&lt;/em&gt; . 매개 변수를 함수 포인터로 지정하는 구문은 목록 19-27에 표시된대로 클로저와 유사합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 을 업데이트 하여 &lt;code&gt;parse_config&lt;/code&gt; 에서 반환 된 &lt;code&gt;Config&lt;/code&gt; 인스턴스를 &lt;code&gt;config&lt;/code&gt; 라는 변수 에 배치 하고 이전에 별도의 &lt;code&gt;query&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 변수를 사용한 코드를 업데이트 하여 &lt;code&gt;Config&lt;/code&gt; 구조체 의 필드를 대신 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">우리는 업데이트 한 &lt;code&gt;main&lt;/code&gt; 우리가 호출 된 곳 &lt;code&gt;parse_config&lt;/code&gt; 대신 호출 &lt;code&gt;Config::new&lt;/code&gt; . 우리의 이름을 변경 한 &lt;code&gt;parse_config&lt;/code&gt; 을 에 &lt;code&gt;new&lt;/code&gt; 와 내에서 이동 &lt;code&gt;impl&lt;/code&gt; 어소 블록, &lt;code&gt;new&lt;/code&gt; 와 기능 &lt;code&gt;Config&lt;/code&gt; . 이 코드를 다시 컴파일하여 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">우리는 사용했습니다 &lt;code&gt;recv&lt;/code&gt; 단순이 예에서, 메인 스레드가 메시지를 기다리는 것 외에 다른 작업을 수행하지 않으므로 메인 스레드를 차단하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">우리는 &lt;code&gt;println!&lt;/code&gt; 과 같은 매크로를 사용했습니다 ! 이 책 전체에 걸쳐서, 우리는 매크로가 무엇이며 어떻게 작동하는지에 대해 완전히 탐구하지 않았습니다. &lt;em&gt;매크로&lt;/em&gt; 라는 용어 는 Rust의 기능 군을 나타냅니다 : &lt;code&gt;macro_rules!&lt;/code&gt; &lt;em&gt;선언적&lt;/em&gt; 매크로 ! 그리고 세 종류의 &lt;em&gt;절차 적&lt;/em&gt; 매크로 :</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">우리는 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io의&lt;/a&gt; 패키지를 프로젝트의 의존성으로 사용 했지만 자신의 패키지를 게시하여 다른 사람들과 코드를 공유 할 수도 있습니다. &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 의 crate registry는 패키지의 소스 코드를 배포하므로 주로 오픈 소스 코드를 호스팅합니다.</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">밑줄 ( &lt;code&gt;_&lt;/code&gt; )을 임의의 값과 일치하지만 값에 바인딩하지 않는 와일드 카드 패턴으로 사용했습니다. 밑줄 &lt;code&gt;_&lt;/code&gt; 패턴은 특히 &lt;code&gt;match&lt;/code&gt; 표현식 의 마지막 팔로 유용 하지만, 목록 18-17에 표시된 것처럼 함수 매개 변수를 포함한 모든 패턴에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">우리는 2 장에서 이미 Rust 프로그램의 예제를 살펴 보았습니다. 이제 기본 구문을 지나갔 으므로 예제에 모든 &lt;code&gt;fn main() {&lt;/code&gt; 코드를 포함하지는 않을 것입니다. 다음 예제를 &lt;code&gt;main&lt;/code&gt; 함수 안에 수동으로 넣어야합니다 . 결과적으로 예제는 좀 더 간결 해지며, 상용구 코드가 아닌 실제 세부 사항에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">약한 키워드</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&lt;em&gt;녹 프로그래밍 언어&lt;/em&gt; 책에 오신 것을 환영합니다 ! 이 버전의 텍스트는 Rust 2018 Edition 관용구를 사용하기 위해 모든 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 과 함께 Rust 1.31.0 이상을 사용한다고 가정합니다 . 참고 항목 &lt;a href=&quot;book/ch01-01-installation&quot;&gt;제 1 장 &quot;설치&quot;섹션&lt;/a&gt; 설치하거나 녹를 업데이트하고 새로운 볼 수있는 &lt;a href=&quot;book/appendix-05-editions&quot;&gt;부록 E&lt;/a&gt; 녹의 버전이 무엇인지에 대한 정보를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&lt;em&gt;녹 프로그래밍 언어&lt;/em&gt; 책에 오신 것을 환영합니다 ! 이 버전의 텍스트는 Rust 2018 Edition 관용구를 사용하기 위해 모든 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 과 함께 Rust 1.31.0 이상을 사용한다고 가정합니다 . 참고 항목 &lt;a href=&quot;ch01-01-installation&quot;&gt;제 1 장 &quot;설치&quot;섹션&lt;/a&gt; 설치하거나 녹를 업데이트하고 새로운 볼 수있는 &lt;a href=&quot;appendix-05-editions&quot;&gt;부록 E&lt;/a&gt; 녹의 버전이 무엇인지에 대한 정보를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">&lt;em&gt;Rust&lt;/em&gt; 에 대한 입문 서적 인 &lt;em&gt;Rust Programming Language에&lt;/em&gt; 오신 것을 환영합니다 . Rust 프로그래밍 언어를 사용하면보다 빠르고 안정적인 소프트웨어를 작성할 수 있습니다. 높은 수준의 인체 공학과 낮은 수준의 제어는 프로그래밍 언어 설계에서 종종 상충됩니다. 그 충돌에 녹이 발생합니다. Rust는 강력한 기술 용량과 뛰어난 개발자 경험의 균형을 통해 전통적으로 이러한 제어와 관련된 번거 로움없이 낮은 수준의 세부 정보 (예 : 메모리 사용)를 제어 할 수있는 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">잘 했어! 당신은 책의 끝까지 그것을 만들었습니다! 이번 Rust 투어에 참여해 주셔서 감사합니다. 이제 자신 만의 Rust 프로젝트를 구현하고 다른 사람들의 프로젝트를 도울 준비가되었습니다. Rust 여정에서 당신이 겪고있는 어려움에 대해 당신을 돕기를 원하는 다른 Rustaceans의 환영하는 공동체가 있다는 것을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">무엇 &lt;em id=&quot;what-the-reference-is-not&quot;&gt;참조가&lt;/em&gt; 되지이다</target>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">무엇 &lt;em&gt;참조가&lt;/em&gt; 되지이다</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">소유권이란?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">문자열이란?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 조건이 &lt;a href=&quot;keyword.false&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; 로 평가 될 때 평가할 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">어떻게 된 거예요? &lt;code&gt;mod hosting&lt;/code&gt; 앞에 &lt;code&gt;pub&lt;/code&gt; 키워드를 추가하면 모듈이 공개됩니다. 이 변경으로 &lt;code&gt;front_of_house&lt;/code&gt; 에 액세스 할 수 있으면 &lt;code&gt;hosting&lt;/code&gt; 액세스 할 수 있습니다 . 그러나 &lt;em&gt;내용&lt;/em&gt; 의 &lt;code&gt;hosting&lt;/code&gt; 여전히 개인 있습니다; 모듈을 공개한다고해서 내용이 공개되지는 않습니다. 모듈 의 &lt;code&gt;pub&lt;/code&gt; 키워드는 상위 모듈의 코드 만 참조 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">배열의 끝을지나 배열의 요소에 액세스하려고하면 어떻게됩니까? 예제를 다음 코드로 변경하면 컴파일 할 때 컴파일되지만 오류가 발생하면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">특성을 구현하는 것이 유형에 대해 의미하는 것</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;UnwindSafe&lt;/code&gt; 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">표준 라이브러리 문서에는 무엇이 있습니까?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">안전 해제 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">이 특성을 이끌어내는 연산자와 방법</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">&lt;code&gt;answer&lt;/code&gt; 의 가치는 무엇인가 ? 첫 글자 인 &lt;code&gt;З&lt;/code&gt; 여야합니까 ? UTF-8 인코딩 할 때의 첫 번째 바이트 &lt;code&gt;З&lt;/code&gt; 가 있다 &lt;code&gt;208&lt;/code&gt; 와 두 번째는 &lt;code&gt;151&lt;/code&gt; 그래서 &lt;code&gt;answer&lt;/code&gt; 실제로되어야 &lt;code&gt;208&lt;/code&gt; 만, &lt;code&gt;208&lt;/code&gt; 자체에 유효한 문자 아니다. &lt;code&gt;208&lt;/code&gt; 을 반환 하는 것은 사용자가이 문자열의 첫 글자를 요구하면 원하는 것이 아닐 것입니다. 그러나 Rust가 바이트 인덱스 0에 가지고있는 유일한 데이터입니다. 문자열에 라틴 문자 만 포함되어 있어도 사용자는 일반적으로 바이트 값을 반환하지 않습니다. &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; 이 바이트 값을 반환하는 유효한 코드 인 경우 &lt;code&gt;104&lt;/code&gt; 를 반환합니다. &lt;code&gt;h&lt;/code&gt; 가 아니라 . 예기치 않은 값이 반환되지 않고 즉시 발견되지 않을 수있는 버그가 발생하지 않도록 Rust는이 코드를 전혀 컴파일하지 않으며 개발 프로세스 초기에 오해를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">무엇에 의해 제공되는 특성의 구현 &lt;code&gt;derive&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이는 &lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt; 특성 을 구현하는 모든 유형의 인수를 &lt;code&gt;{:b}&lt;/code&gt; 로 형식화 할 수 있음을 의미합니다 . 표준 라이브러리에 의해 다수의 기본 유형에 대한 이러한 특성에 대한 구현도 제공됩니다. 형식을 지정하지 않으면 ( &lt;code&gt;{}&lt;/code&gt; 또는 &lt;code&gt;{:6}&lt;/code&gt; 과 같이 ) 사용 된 형식 특성은 &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성입니다.</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 조건이 유지되지 않을 때 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">우리가이 예에서 볼 수없는 것은 때이다 &lt;code&gt;b&lt;/code&gt; 다음과가 의 끝에서 범위의 외출 &lt;code&gt;main&lt;/code&gt; , 카운트가 다음 0이고, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 그 시점에서 완전하게 정리되어있다. 사용 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 하나의 값이 여러 소유자를 가질 수 있으며, 값이 긴 소유자 중 하나가 여전히 존재하는 유효한 유지 카운트 보장합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">메모리를 공유함으로써 의사 소통은 어떻게 생겼습니까? 또한 메시지 전달 애호가가 왜 메시지를 사용하지 않고 반대의 행동을합니까?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">&lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; 사용하면 어떻게 됩니까? 대답 : Rust는 벡터에서 유효하지 않은 인덱스에 액세스 한 것과 같은 방식으로 런타임에 패닉합니다.</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 클로저를 사용하면 &lt;code&gt;drop&lt;/code&gt; 이라는 메인 스레드가있는 Listing 16-4의 코드는 어떻게됩니까? 시겠습니까 &lt;code&gt;move&lt;/code&gt; 하는 경우 그 수정을? 불행하게도; Listing 16-4에서 시도한 작업이 다른 이유로 허용되지 않기 때문에 다른 오류가 발생한다. 클로저 에 &lt;code&gt;move&lt;/code&gt; 을 추가하면 &lt;code&gt;v&lt;/code&gt; 를 클로저 환경으로 이동 하고 더 이상 메인 스레드에서 &lt;code&gt;drop&lt;/code&gt; 을 호출 할 수 없습니다 . 대신이 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 와 &lt;code&gt;Clone&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="translated">경우 &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; 생략 &lt;code&gt;FunctionQualifiers&lt;/code&gt; 기능 항목에서, ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; 할당된다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">때는 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 최대 값보다 큰 값을 만들거나 적은 저장 될 수있는 최소 값보다. 이 단항 포함 &lt;code&gt;-&lt;/code&gt; 어떤 부호있는 정수 타입의 가장 작은 값에.</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">때 &lt;code&gt;Trait2&lt;/code&gt; 가 의 subtrait입니다 &lt;code&gt;Trait1&lt;/code&gt; 은 (예를 들어, &lt;code&gt;Trait2&lt;/code&gt; 이 같은 정의가 &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; )가 구현 할 수 없습니다 &lt;code&gt;Trait1&lt;/code&gt; 을 위한 &lt;code&gt;Trait2&lt;/code&gt; . &lt;code&gt;Trait2&lt;/code&gt; 는 이미 정의에 따라 &lt;code&gt;Trait1&lt;/code&gt; 을 구현하고 있기 때문에 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">때 &lt;code&gt;Trait&lt;/code&gt; 유형으로 처리, 유형은 특별한 구현하지 않는 &lt;code&gt;Sized&lt;/code&gt; 유형이 컴파일 타임에 알려진 크기를 가지고 있지 않고, 단지 포인터 뒤에 액세스 할 수 있기 때문에, 특성을. 따라서 다음과 같은 특성이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="translated">때 &lt;code&gt;bar&lt;/code&gt; 함수의 이름은 다음 식 &lt;code&gt;bar&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 함수 포인터. 오히려 함수 &lt;code&gt;bar&lt;/code&gt; 를 고유하게 식별하는 이름없는 유형의 값을 나타냅니다 . 유형이 이미 함수를 식별하므로 값의 크기는 0입니다. 이것은 값을 &quot;호출&quot;( &lt;code&gt;Fn*&lt;/code&gt; 특성을 구현 함 ) 할 때 동적 디스패치를 ​​필요로하지 않는다는 장점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">시 &lt;code&gt;break&lt;/code&gt; 발생 연관된 루프 본체의 실행은 즉시, 예를 들어, 종료한다 :</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="translated">때 &lt;code&gt;break&lt;/code&gt; 발생, 관련 루프 본문의 실행은 즉시 종료된다.</target>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="translated">때 &lt;code&gt;continue&lt;/code&gt; 발생, 현재 반복은 일반적으로 다음 반복을 계속 루프 헤드에 제어를 반환 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">때 &lt;code&gt;continue&lt;/code&gt; 발생, 관련 루프 본문의 현재 반복은 즉시 루프로 제어를 반환 종료 &lt;em&gt;머리를&lt;/em&gt; . &lt;code&gt;while&lt;/code&gt; 루프 의 경우 헤드는 루프를 제어하는 ​​조건식입니다. &lt;code&gt;for&lt;/code&gt; 루프 의 경우 헤드는 루프를 제어하는 ​​호출 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="translated">하면 &lt;code&gt;f&lt;/code&gt; 다른 기인 함수에 의해 호출된다 &lt;code&gt;g&lt;/code&gt; 호출 차례에 &lt;code&gt;calls_g&lt;/code&gt; 모두, 부호 &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;g&lt;/code&gt; 관찰 &lt;code&gt;g&lt;/code&gt; 의 callsite 내의 &lt;code&gt;calls_g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="translated">때 &lt;code&gt;f&lt;/code&gt; 직접 호출 &lt;code&gt;calls_f&lt;/code&gt; , 코드 &lt;code&gt;f&lt;/code&gt; 내 callsite을 관찰 &lt;code&gt;calls_f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;g&lt;/code&gt; 는 다른 기인 함수에 의해 호출되는 &lt;code&gt;h&lt;/code&gt; 호출 차례에 &lt;code&gt;calls_h&lt;/code&gt; , 모든 코드 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;h&lt;/code&gt; 관찰 &lt;code&gt;h&lt;/code&gt; 이내의 callsite을 &lt;code&gt;calls_h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;outer&lt;/code&gt; 범위를 벗어나 상기 &lt;code&gt;drop&lt;/code&gt; 방법 제 촉구한다 &lt;code&gt;Outer&lt;/code&gt; 다음 들면, &lt;code&gt;Inner&lt;/code&gt; . 따라서, &lt;code&gt;main&lt;/code&gt; 프린트는 &lt;code&gt;Dropping Outer!&lt;/code&gt; 그리고 &lt;code&gt;Dropping Inner!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">시 &lt;code&gt;s&lt;/code&gt; 온다 &lt;em&gt;범위로&lt;/em&gt; , 그것은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;security_qos_flags&lt;/code&gt; 가 설정되지는 명명 된 파이프를 개방으로 속여, 개구 사용자가 지정한 경로를 허용하면 악성 프로그램 특권 녹 공정의 승온 권한을 얻을 수있다. 따라서 임의의 경로를 열 때 &lt;code&gt;security_qos_flags&lt;/code&gt; 도 설정해야합니다. 그러나 비트는 다른 플래그, 특히 &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; 과 충돌 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;security_qos_flags&lt;/code&gt; 가 설정되지는 명명 된 파이프를 개방으로 속여, 개구 사용자가 지정한 경로를 허용 할 때, 악성 프로그램은 특권 녹 공정의 승온 권한을 얻을 수있다. 따라서 임의의 경로를 열 때 &lt;code&gt;security_qos_flags&lt;/code&gt; 도 설정해야합니다. 그러나 비트는 다른 플래그, 특히 &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; 과 충돌 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">언제 내 유형을 &lt;code&gt;Copy&lt;/code&gt; 할 &lt;em&gt;수&lt;/em&gt; 없습니까?</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">내 유형 &lt;em&gt;은&lt;/em&gt; 언제 &lt;code&gt;Copy&lt;/code&gt; &lt;em&gt;해야&lt;/em&gt; 합니까?</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">Rust가이 코드를 컴파일 할 때 단일 변형을 수행합니다. 이 프로세스 동안 컴파일러는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 에 사용 된 값을 읽고 두 종류의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 식별합니다 . 하나는 &lt;code&gt;i32&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;f64&lt;/code&gt; 입니다. 따라서 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 의 일반 정의 를 &lt;code&gt;Option_i32&lt;/code&gt; 및 &lt;code&gt;Option_f64&lt;/code&gt; 로 확장하여 일반 정의를 특정 정의로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">언제 어떤 컬렉션을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">클로저는 환경에서 값을 캡처 할 때 메모리를 사용하여 클로저 바디에 사용할 값을 저장합니다. 이러한 메모리 사용은 환경을 캡처하지 않는 코드를 실행하려는 더 일반적인 경우에 지불하고 싶지 않은 오버 헤드입니다. 함수는 환경을 캡처 할 수 없으므로 함수를 정의하고 사용하면이 오버 헤드가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">함수가 적절한 정렬을 요구할 때, 액세스가 크기가 0 인 경우, 즉 메모리가 실제로 접촉되지 않은 경우에도 그렇게합니다. 이러한 경우 &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">함수가 &lt;code&gt;Pending&lt;/code&gt; 을 반환 하면 함수 &lt;em&gt;는&lt;/em&gt; 진행률이있을 때 현재 작업이 해제되도록 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">미래가 아직 준비되지 않은 경우 &lt;code&gt;poll&lt;/code&gt; 은 &lt;code&gt;Poll::Pending&lt;/code&gt; 반환 하고 현재 &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 에서 복사 된 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 복제본을 저장합니다 . 이 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 는 미래가 발전 할 수있게되면 깨어납니다. 예를 들어, 나중에 소켓을 읽을 수있게되기를 기다리는 경우 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;.clone()&lt;/code&gt; 을 호출 하여 저장합니다. 소켓을 읽을 수 있음을 나타내는 신호가 도착하면 &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt; 가 호출되고 소켓의 미래 작업이 해제됩니다. 작업이 깨어 난 후에는 미래를 다시 &lt;code&gt;poll&lt;/code&gt; 하려고 시도해야 하며 이는 최종 값을 생성하거나 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">일반 함수가 참조 될 때 해당 함수의 유형은 참조 컨텍스트에 따라 인스턴스화됩니다. 예를 들어 여기 에서 &lt;code&gt;foo&lt;/code&gt; 함수를 호출하면</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">매크로를 내보낼 때 &lt;code&gt;#[macro_export]&lt;/code&gt; 속성에 &lt;code&gt;local_inner_macros&lt;/code&gt; 키워드를 추가하여 포함 된 모든 매크로 호출에 &lt;code&gt;$crate::&lt;/code&gt; 를 자동으로 추가 할 수 있습니다 . 이는 Rust 2018의 경로 기반 매크로 가져 오기 작업을 위해 &lt;code&gt;$crate&lt;/code&gt; 가 언어에 추가 되기 전에 작성된 코드를 마이그레이션하는 도구로 주로 사용됩니다 . 새로운 코드에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">규정되지 않은 식별자 (여러 부분 경로의 일부가 아님)에 의해 매크로가 호출되면, 텍스트 범위에서 먼저 조회됩니다. 이렇게해도 결과가 나오지 않으면 경로 기반 범위에서 검색됩니다. 매크로 이름이 경로로 규정 된 경우, 경로 기반 범위에서만 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">매크로가 호출되면 매크로 확장기는 이름별로 매크로 호출을 찾고 각 매크로 규칙을 차례로 시도합니다. 그것은 첫 번째 성공적인 경기를 기록합니다. 이로 인해 오류가 발생하면 향후 일치가 시도되지 않습니다. 일치하면 미리보기가 수행되지 않습니다. 컴파일러가 매크로 호출을 한 번에 하나의 토큰을 구문 분석하는 방법을 명확하게 결정할 수 없으면 오류입니다. 다음 예제에서 컴파일러는 식별자를 지나서 다음 토큰이 &lt;code&gt;)&lt;/code&gt; 인지 확인하지 않고 호출을 명확하게 구문 분석 할 수는 있지만 :</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">장소 표현식이 값 표현식 컨텍스트에서 평가되거나 패턴의 값으로 바인드 &lt;em&gt;되면&lt;/em&gt; 해당 메모리 위치에 보유 &lt;em&gt;된&lt;/em&gt; 값을 나타냅니다 . 해당 값의 유형이 &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현 하면 값이 복사됩니다. 나머지 상황에서 해당 유형이 &lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 이면 값을 이동할 수 있습니다. 다음 장소 표현식 만 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">프로그래머가 잠재적으로 안전하지 않은 작업 시퀀스가 ​​실제로 안전하다는 확신이 충분하면 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에 해당 시퀀스 (전체적으로 수행됨)를 캡슐화 할 수 있습니다 . 컴파일러는 주변 환경에서 이러한 코드의 안전한 사용을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">스택 프레임이 종료되면 로컬 할당이 모두 해제되고 상자에 대한 참조가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">그러나 &lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 선언에&lt;/a&gt; 할당 된 임시 값 표현식을 작성하는 경우, 대신 둘러싸 &lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 선언&lt;/a&gt; 을 사용하는 것이 보장 된 오류이므로 임시 블록이 사용되는 대신 대체 블록의 수명으로 임시가 작성됩니다 (임시 포인터가 변수에 저장되지만 변수를 사용하려면 임시 변수가 해제됩니다). 컴파일러는 간단한 구문 규칙을 사용하여 &lt;code&gt;let&lt;/code&gt; 바인딩 에 할당 할 값을 결정 하므로 더 긴 임시 수명이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">공구를 사용하지 않을 때는 공구 속성이 경고없이 적용됩니다. 도구가 사용 중일 때 도구는 해당 속성의 처리 및 해석을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="translated">특성 객체가 제네릭 유형의 유형 인수로 사용될 때 Rust는 지정되지 않은 경우 수명을 추론하려고합니다. 그러나 포함하는 형식에 수명 제한이 두 개 이상있는 경우에는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="translated">유형이 특성의 관련 함수를 구현할 때 동일한 서명을 사용해야합니다. 따라서이 경우 &lt;code&gt;Foo::foo&lt;/code&gt; 는 인수를 취하지 않고 아무것도 반환하지 않으므로 &lt;code&gt;Bar&lt;/code&gt; 에서의 구현 은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="translated">유형이 특성의 관련 함수를 구현할 때 동일한 서명을 사용해야합니다. 따라서이 경우 &lt;code&gt;Foo::foo&lt;/code&gt; 는 &lt;code&gt;self&lt;/code&gt; 를 인수로 사용하고 아무것도 반환하지 않으므로 &lt;code&gt;Bar&lt;/code&gt; 에서의 구현 은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">사용자가 &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; 호출 하면지도에서 키를 검색 한 후 &lt;code&gt;Entry&lt;/code&gt; 열거 형 의 변형을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">값이 범위를 벗어나 면 유형이 &lt;code&gt;Drop&lt;/code&gt; 을 구현하는 경우 &lt;code&gt;drop&lt;/code&gt; 메소드가 호출됩니다 . 그런 다음 값에 포함 된 모든 필드도 재귀 적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="translated">값이 더 이상 필요하지 않으면 Rust는 해당 값에 대해 &quot;소멸자&quot;를 실행합니다. 값이 더 이상 필요하지 않은 가장 일반적인 방법은 범위를 벗어날 때입니다. 소멸자는 여전히 다른 상황에서 실행될 수 있지만 여기서는 예제의 범위에 초점을 맞출 것입니다. 다른 경우에 대해 알아 보려면 소멸자에 &lt;a href=&quot;../../reference/destructors&quot;&gt;대한 참조&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">변수를 변경할 수없는 경우 값이 이름에 바인딩되면 해당 값을 변경할 수 없습니다. 이를 설명하기 위해 &lt;code&gt;cargo new variables&lt;/code&gt; 를 사용 하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리에 &lt;em&gt;variables&lt;/em&gt; 라는 새 프로젝트를 생성 해 봅시다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">때 &lt;a href=&quot;glossary#initialized&quot;&gt;초기화 된 &lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 녹의 범위를 벗어나거나 &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;일시적으로는&lt;/a&gt; 더 이상 필요하지 않습니다 자사의 &lt;em&gt;소멸자가&lt;/em&gt; 실행됩니다. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;할당&lt;/a&gt; 은 초기화되지 않은 변수가 아닌 한 왼쪽 피연산자의 소멸자를 실행합니다. 경우 &lt;a href=&quot;types/struct&quot;&gt;구조체&lt;/a&gt; 변수가 부분적으로 초기화 된 만의 초기화 필드는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">때 &lt;a href=&quot;glossary#initialized&quot;&gt;초기화 &lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 또는 &lt;a href=&quot;expressions#temporaries&quot;&gt;일시적가&lt;/a&gt; 의 외출 &lt;a href=&quot;#drop-scopes&quot;&gt;범위&lt;/a&gt; 의 &lt;em&gt;소멸자가&lt;/em&gt; 실행, 또는됩니다 &lt;em&gt;떨어졌다&lt;/em&gt; . &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;할당&lt;/a&gt; 은 또한 초기화 된 경우 왼쪽 피연산자의 소멸자를 실행합니다. 변수가 부분적으로 초기화 된 경우 초기화 된 필드 만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">&lt;code&gt;ChildStderr&lt;/code&gt; 인스턴스 가 &lt;a href=&quot;../ops/trait.drop&quot;&gt;삭제&lt;/a&gt; 되면 &lt;code&gt;ChildStderr&lt;/code&gt; 의 기본 파일 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">&lt;code&gt;ChildStdin&lt;/code&gt; 인스턴스 가 &lt;a href=&quot;../ops/trait.drop&quot;&gt;삭제&lt;/a&gt; 되면 &lt;code&gt;ChildStdin&lt;/code&gt; 의 기본 파일 핸들이 닫힙니다. 하위 프로세스가 삭제되기 전에 입력에서 차단 된 경우 삭제 후 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">&lt;code&gt;ChildStdout&lt;/code&gt; 인스턴스 가 &lt;a href=&quot;../ops/trait.drop&quot;&gt;삭제&lt;/a&gt; 되면 &lt;code&gt;ChildStdout&lt;/code&gt; 의 기본 파일 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">함수에서 수명에 주석을 달 때 주석은 함수 본문이 아니라 함수 서명에 들어갑니다. Rust는 도움없이 함수 내에서 코드를 분석 할 수 있습니다. 그러나 함수가 해당 함수 외부의 코드를 참조하거나 코드에서 참조하는 경우 Rust가 매개 변수의 수명을 파악하거나 자체적으로 값을 반환하는 것은 거의 불가능합니다. 함수가 호출 될 때마다 수명이 다를 수 있습니다. 그렇기 때문에 수명에 수동으로 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">많은 양의 원소가 유입 될 것을 예상 할 때, &lt;code&gt;reserve&lt;/code&gt; 군은 수집품이 다가올 품목에 얼마나 많은 공간을 확보해야하는지 암시하는 데 사용될 수 있습니다. &lt;code&gt;with_capacity&lt;/code&gt; 와 마찬가지로 이러한 메소드의 정확한 동작은 관심있는 콜렉션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적용 가능한 경우, 불안정한 정렬은 일반적으로 안정적인 정렬보다 빠르며 보조 메모리를 할당하지 않기 때문에 선호됩니다. &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적용 가능한 경우, 불안정한 정렬은 일반적으로 안정적인 정렬보다 빠르며 보조 메모리를 할당하지 않기 때문에 선호됩니다. &lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적용 가능한 경우, 불안정한 정렬은 일반적으로 안정적인 정렬보다 빠르며 보조 메모리를 할당하지 않기 때문에 선호됩니다. &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 블록의 함수에 적용될 때 속성은 연결된 모든 구현에도 적용되어야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다. 에게 제공되는 함수에 적용될 때 &lt;code&gt;extern&lt;/code&gt; 블록은 선언의 &lt;code&gt;extern&lt;/code&gt; 블록도 특성, 달리 정의되지 않은 동작 결과를 가져야한다.</target>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 값에 적용되면 &lt;code&gt;None&lt;/code&gt; 을 전파 합니다. 값이 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 에 적용하면 &lt;code&gt;Some(x)&lt;/code&gt; , 그것은을 평가하는 값 랩을 해제 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 유형의 값에 적용되면 오류가 전파됩니다. 값이 &lt;code&gt;Err(e)&lt;/code&gt; 이면 엔 클로징 함수 또는 클로저 &lt;code&gt;Err(From::from(e))&lt;/code&gt; 을 반환 합니다. 인가하면 &lt;code&gt;Ok(x)&lt;/code&gt; , 그런 다음에 평가 값을 푸는 것 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">상자 안에 적용되는 경우, 상자의 다운 스트림 사용자는 열거 형을 일치시킬 때 &lt;code&gt;_&lt;/code&gt; 패턴 을 사용하고 구조체를 일치시킬 때 &lt;code&gt;..&lt;/code&gt; 패턴을 사용해야합니다 . 다운 스트림 크레이트는 전체가 아닌 열거 형 변형과 일치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">이 경고는 언제 오류로 바뀝니 까?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 와 연결되면 break 표현식을 사용하여 해당 루프에서 값을 반환 할 수 있습니다. 이것은 &lt;code&gt;loop&lt;/code&gt; 에서만 유효하며 다른 유형의 루프 에서는 유효 하지 않습니다. 값을 지정하지 않으면 &lt;code&gt;break;&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; 을 반환합니다 . 루프 내의 모든 &lt;code&gt;break&lt;/code&gt; 은 동일한 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 와 연관 될 때 break 표현식은 &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; 형식 중 하나를 통해 루프에서 값을 리턴하는 데 사용될 수 있습니다 . 여기서 &lt;code&gt;EXPR&lt;/code&gt; 은 &lt;code&gt;loop&lt;/code&gt; 에서 결과가 리턴되는 표현식입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="translated">const 컨텍스트에서 호출되면 컴파일 타임에 컴파일러가 함수를 해석합니다. 해석은 호스트가 아닌 컴파일 대상 환경에서 발생합니다. 따라서 &lt;code&gt;usize&lt;/code&gt; 는 &lt;code&gt;32&lt;/code&gt; 비트 시스템 에 대해 컴파일하는 경우 &lt;code&gt;32&lt;/code&gt; 비트이며 &lt;code&gt;64&lt;/code&gt; 비트 또는 &lt;code&gt;32&lt;/code&gt; 비트 시스템 에서 빌드하는지 여부와 관계가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">&lt;code&gt;product()&lt;/code&gt; 호출 하고 기본 정수 유형이 리턴 될 때 계산 오버 플로우 및 디버그 어설 션이 사용 가능한 경우 메소드가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">&lt;code&gt;sum()&lt;/code&gt; 호출 하고 기본 정수 유형이 리턴 될 때 계산 오버 플로우 및 디버그 어설 션이 사용 가능한 경우이 메소드가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">이름이 같은 메소드를 호출 할 때 Rust에 사용하려는 메소드를 알려야합니다. 우리는 두 가지 특성, 정의한 목록 19-16의 코드 고려 &lt;code&gt;Pilot&lt;/code&gt; 와 &lt;code&gt;Wizard&lt;/code&gt; 모두 호출하는 방법이 있는지, &lt;code&gt;fly&lt;/code&gt; . 그런 다음 &lt;code&gt;fly&lt;/code&gt; 이라는 메소드가 이미 구현 된 &lt;code&gt;Human&lt;/code&gt; 유형에 두 특성을 구현합니다. 각 &lt;code&gt;fly&lt;/code&gt; 방법은 서로 다른 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="translated">이 메서드를 호출 할 때, 당신은 보장해야 &lt;em&gt;하나&lt;/em&gt; 포인터가 NULL &lt;em&gt;또는&lt;/em&gt; 다음의 모든 사실이다 :</target>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="translated">이 메서드를 호출 할 때 다음 사항이 모두 참인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">이 메소드를 호출 할 때 포인터가 NULL이 아닌 경우 포인터가 올바르게 정렬되고 ( &lt;code&gt;T&lt;/code&gt; 의 전체 크기에 대해) 참조 불가능 하며 초기화 된 &lt;code&gt;T&lt;/code&gt; 인스턴스를 가리키는 지 확인해야합니다 . 이 방법의 결과를 사용하지 않더라도 적용됩니다! (초기화에 대한 부분은 아직 완전히 결정되지 않았지만 그것이 유일한 안전한 접근법이 될 때까지는 실제로 초기화되도록하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">이 메소드를 호출 할 때 포인터가 NULL이 아닌 경우 포인터가 올바르게 정렬되고 ( &lt;code&gt;T&lt;/code&gt; 의 전체 크기에 대해) 참조 불가능 하며 초기화 된 &lt;code&gt;T&lt;/code&gt; 인스턴스를 가리키는 지 확인해야합니다 . 이 방법의 결과를 사용하지 않더라도 적용됩니다! (초기화에 대한 부분은 아직 완전히 결정되지는 않았지만, 그것이 결정될 때까지 유일한 안전한 접근 방식은 실제로 초기화되도록하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">언제 내 유형을 &lt;code&gt;Copy&lt;/code&gt; 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">캐스팅 할 때는 기본 유형 만 서로 캐스팅 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">포인터를 비교할 때는 포인터가 가리키는 것이 아니라 주소를 기준으로 비교됩니다. 포인터를 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적 크기의 유형&lt;/a&gt; 과 비교할 때 추가 데이터도 비교합니다.</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="translated">원시 포인터를 비교할 때 가리키는 것이 아니라 주소로 비교됩니다. 원시 포인터를 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적 크기 유형&lt;/a&gt; 과 비교할 때 추가 데이터도 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">비교가 불가능한 경우 :</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">로드와 결합 될 때로드 된 값이 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; (또는 더 강력한) 순서 가있는 저장 작업에 의해 기록 된 경우 모든 후속 작업은 해당 저장 이후에 순서가 지정됩니다. 특히 이후의 모든로드에는 저장소 이전에 기록 된 데이터가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">로드와 결합 될 때로드 된 값이 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; (또는 더 강한) 순서 로 저장 조작에 의해 기록 된 경우 , 모든 후속 조작은 ​​해당 저장 후에 주문됩니다. 특히, 모든 후속로드에는 상점 이전에 기록 된 데이터가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">상점과 결합되면 이전의 모든 작업은 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (또는 더 강력한) 주문 으로이 값이로드되기 전에 주문됩니다. 특히, 이전의 모든 쓰기 는이 값 의 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (또는 더 강력한)로드 를 수행하는 모든 스레드에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">상점과 결합되면 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (또는 더 강한) 주문 으로이 값을로드하기 전에 모든 이전 조작이 주문됩니다. 특히, 이전의 모든 쓰기 는이 값 의 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (또는 더 강한)로드 를 수행하는 모든 스레드에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">불변 및 변경 가능한 참조를 만들 때 각각 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 구문을 사용합니다 . 함께 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , 우리는 사용 &lt;code&gt;borrow&lt;/code&gt; 및 &lt;code&gt;borrow_mut&lt;/code&gt; 에 속하는 안전 API의 일부입니다 방법, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;borrow&lt;/code&gt; 방법은 스마트 포인터 타입 반환 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;borrow_mut&lt;/code&gt; 반환 스마트 포인터 타입 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; . 두 유형 모두 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하므로 일반 참조처럼 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">절차 식 매크로를 만들 때 정의는 특수 상자 유형의 자체 상자에 있어야합니다. 이는 복잡한 기술적 인 이유 때문에 향후에 제거하기를 희망합니다. 절차 적 매크로 를 사용하는 것은 Listing 19-29의 코드와 비슷하다. 여기서 &lt;code&gt;some_attribute&lt;/code&gt; 는 특정 매크로를 사용하는 자리 표시 자이다.</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">제네릭을 사용하는 함수를 정의 할 때 일반적으로 매개 변수의 데이터 유형과 반환 값을 지정하는 함수의 서명에 제네릭을 배치합니다. 그렇게하면 코드가 더 유연 해지고 함수 호출자에게 더 많은 기능을 제공하면서 코드 중복을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">재귀 구조체 또는 열거를 정의 할 때 정의 내부에서 정의되는 유형의 사용은 &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 포인터 뒤에서 발생해야합니다 . 이는 구조체와 열거 형의 크기가 잘 정의되어 있어야하며 포인터가 없으면 형식의 크기를 제한하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">재귀 구조체 또는 열거 형을 정의 할 때 정의 내에서 정의되는 유형의 모든 사용은 포인터 (예 : &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; ) 뒤에서 발생해야합니다 . 이는 구조체와 열거 형이 잘 정의 된 크기를 가져야하고 포인터가 없으면 형식의 크기가 제한되지 않아야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">구조체에서 파생 될 때 &lt;code&gt;PartialOrd&lt;/code&gt; 는 필드가 구조체 정의에 나타나는 순서대로 각 필드의 값을 비교하여 두 인스턴스를 비교합니다. 열거 형에서 파생 된 경우 열거 형 정의에서 앞서 선언 된 열거 형의 변형은 나중에 나열된 변형보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">활성화되면이 소켓은 브로드 캐스트 주소로 패킷을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">블록 표현식을 평가할 때 항목 선언문을 제외한 각 명령문이 순차적으로 실행됩니다. 그런 다음 주어진 경우 최종 표현식이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">일치하는 프래그먼트를 다른 매크로별로 전달할 때 두 번째 매크로의 매처는 프래그먼트 유형의 불투명 한 AST를 보게됩니다. 두 번째 매크로는 리터럴 토큰을 사용하여 매처의 조각을 일치시킬 수 없으며 동일한 유형의 조각 지정자 만 사용할 수 있습니다. &lt;code&gt;ident&lt;/code&gt; , &lt;code&gt;lifetime&lt;/code&gt; 및 &lt;code&gt;tt&lt;/code&gt; 단편 유형은 예외이고, &lt;em&gt;수&lt;/em&gt; 문자 토큰 일치한다. 다음은이 제한 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="translated">&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; combinator를 구현할 때 , &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 을 호출하기 위해 고정 된 참조를 얻어야하기 때문에 일반적으로 중첩 된 future에 대한 구조적 고정이 필요합니다 . 그러나 combinator에 고정 할 필요가없는 다른 데이터가 포함되어있는 경우 해당 필드를 구조적이지 않게 만들 수 있으므로 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 만있는 경우에도 변경 가능한 참조를 사용하여 자유롭게 액세스 할 수 있습니다 (예 : 자체 &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 구현 ).</target>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 콤비 네이터를 구현할 때는 일반적으로 &lt;code&gt;poll&lt;/code&gt; 을 호출하기 위해 고정 된 참조를 가져와야하기 때문에 중첩 된 미래에 대한 구조적 고정이 필요합니다 . 그러나 결합기에 고정 할 필요가없는 다른 데이터가 포함 된 경우 해당 필드를 구조적으로 만들 수 없으므로 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 가있는 경우에도 (예 : 자체 &lt;code&gt;poll&lt;/code&gt; 구현 에서) 가변 참조로 자유롭게 액세스 할 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="translated">외부 유형에 대한 외부 특성을 구현할 때 특성에는 하나 이상의 유형 매개 변수가 있어야합니다. 유형 매개 변수를 사용하기 전에 상자에 로컬 유형이 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">자신의 형식에 맞는 형식 특성을 구현할 때는 서명 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">&lt;code&gt;ExactSizeIterator&lt;/code&gt; 를 구현할 때 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 도 구현해야합니다 . 그렇게 할 때 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; 구현은 반복자 의 정확한 크기를 반환 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">&lt;code&gt;ExactSizeIterator&lt;/code&gt; 를 구현할 때는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 도 구현해야합니다 . 그렇게 할 때 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt; 의 구현은 반복자의 정확한 크기를 반환 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 와 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 를&lt;/a&gt; 모두 구현할 때는 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 에&lt;/a&gt; 대해이 특성을 구현할 때 &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 유형을 선택해야합니다 . 문자열을 문자열로 변환해도 오류가 발생하지 않으므로 적절한 유형은 &lt;code&gt;!&lt;/code&gt; . (현재 실제로 사용되는 유형은 변형이없는 열거 형이지만 나중에 Rust에 &lt;code&gt;!&lt;/code&gt; 가 추가되었으므로 나중에 변경 될 수 있기 때문 입니다 .) &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 유형이 &lt;code&gt;!&lt;/code&gt; , 어떤 이유로 &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt; 을 호출 해야하는 경우 결과는 다음 과 같이 압축을 풀 수있는 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Slice&lt;/code&gt; 를 초기화 할 때 단순히 &lt;code&gt;phantom&lt;/code&gt; 필드에 &lt;code&gt;PhantomData&lt;/code&gt; 값을 제공하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">명명 된 (그러나 번호) 필드를 가지는 데이터 구조 (구조체 ENUM, 연합)를 초기화하는 경우,이 기록시킨다 &lt;code&gt;fieldname&lt;/code&gt; 에 대한 속기로서 &lt;code&gt;fieldname: fieldname&lt;/code&gt; . 이를 통해 중복이 적은 간결한 구문이 가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">호출 표기법을 사용하여 함수 특성 &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; 또는 &lt;code&gt;FnOnce&lt;/code&gt; 의 클로저 또는 기타 구현을 호출 할 때 함수에 전달 된 매개 변수의 수는 해당 정의와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">특성에 대한 구현을 찾을 때 컴파일러는 T가 모든 유형 인 &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; 와 &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; 대한 impl MyTrait를 모두 찾습니다 . 특성을 여러 번 구현할 수 없으므로 이는 오류입니다. 당신이 쓸 때 :</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">메소드 호출을 검색 할 때 수신자는 메소드를 호출하기 위해 자동으로 역 참조되거나 빌려 올 수 있습니다. 호출 할 수있는 메소드가 많을 수 있으므로 다른 함수보다 복잡한 조회 프로세스가 필요합니다. 다음 절차가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">범위와 일치하는 경우 컴파일러는 범위가 비어 있지 않은지 확인합니다. 범위 패턴에는 두 끝 점이 모두 포함되므로 범위의 시작이 범위의 끝보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">배타적 범위와 일치하는 경우 컴파일러는 범위가 비어 있지 않은지 확인합니다. 배타적 범위 패턴에는 시작 지점이 포함되지만 종료 지점은 포함되지 않으므로 범위의 시작이 범위의 끝보다 작아야하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="translated">변수와 일치 할 때 일치 가드에서 변경 될 수 없습니다. 일치가 완전하지 않게 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">변수에서 일치하는 경우 일치 가드에서 변경 될 수 없습니다. 이로 인해 일치가 완전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">Rust 상자의 이름을 지정할 때 하이픈이 허용되지 않습니다. 그러나화물 패키지는이를 사용할 수 있습니다. 이러한 경우에, 때 &lt;code&gt;Cargo.toml&lt;/code&gt; 는 나무 상자 이름을 지정하지 않는,화물은 투명하게 대체 할 것이다 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;_&lt;/code&gt; (참조 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">단일 스레드 만 관련되면 결과는 예상대로입니다. &lt;code&gt;7 4 4&lt;/code&gt; 행 이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">콘솔에서 작동 할 때이 스트림의 Windows 구현은 비 UTF-8 바이트 시퀀스를 지원하지 않습니다. UTF-8이 아닌 바이트를 읽으려고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">콘솔에서 작동 할 때이 스트림의 Windows 구현은 비 UTF-8 바이트 시퀀스를 지원하지 않습니다. UTF-8이 아닌 바이트를 쓰려고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">경로를 구문 분석 할 때 약간의 정규화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">개인 항목을 다시 내보낼 때는 네임 스페이스 계층 구조를 통과하지 않고 다시 내보내기를 통해 &quot;개인 정보 체인&quot;을 단락시키는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">참조 할 때, &lt;em&gt;함수&lt;/em&gt; 는 호출 될 때 함수에 대한 직접 호출로 평가되는 해당하는 크기가 0 인 &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;함수 항목 유형&lt;/em&gt;&lt;/a&gt; 의 1 급 &lt;em&gt;값&lt;/em&gt; 을 생성 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">함수 항목 또는 튜플과 유사한 구조체 또는 열거 변형의 생성자는 &lt;em&gt;함수 항목 유형&lt;/em&gt; 의 크기가 0 인 값을 생성합니다 . 이 유형은 이름, 유형 인수 및 초기 바인딩 수명 인수 (함수를 호출 할 때만 할당되는 지연 바인딩 수명 인수는 아님)를 명시 적으로 식별하여 값을 포함 할 필요가 없습니다. 실제 함수 포인터이며, 함수가 호출 될 때 간접적 인 지시가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">반복이 포함되면 규칙은 구분 기호를 고려하여 가능한 모든 확장 횟수에 적용됩니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">인수가 특정 유형으로 형식화되도록 요청하면 실제로는 특정 특성에 대한 인수를 요구합니다. 이를 통해 여러 실제 유형을 &lt;code&gt;{:x}&lt;/code&gt; 를 통해 형식화 할 수 있습니다 (예 : &lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; ). 특성에 대한 유형의 현재 맵핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">반환 값이 오버플로되면 (즉, &lt;code&gt;uN&lt;/code&gt; 유형의 경우 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; 디버그 모드에서 패닉 상태가되고 해제 모드에서 반환 값이 0으로 줄어 듭니다 (메소드가 메서드를 0으로 반환 할 수있는 유일한 상황). .</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">리턴 값이 오버 플로우되면 (즉, &lt;code&gt;uN&lt;/code&gt; 유형의 경우 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; &lt;code&gt;2^N = 0&lt;/code&gt; 오버 플로우됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">함수에서 참조를 반환 할 때 반환 유형의 수명 매개 변수는 매개 변수 중 하나의 수명 매개 변수와 일치해야합니다. 리턴 된 참조가 매개 변수 중 하나를 참조 하지 &lt;em&gt;않으면&lt;/em&gt; 이 함수 내에서 작성된 값을 참조해야합니다.이 값은 함수 끝에서 범위를 벗어나기 때문에 매달려있는 참조가됩니다. 컴파일되지 않는 &lt;code&gt;longest&lt;/code&gt; 함수의 구현을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">Listing 16-10의 코드를 실행할 때 각 줄 사이에 1 초의 일시 중지가있는 다음 출력이 표시되어야한다.</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">그러나 맵에서 값을 검색 할 때 검색 키로 &lt;code&gt;K&lt;/code&gt; 에 대한 참조를 제공 해야하는 경우 항상 이러한 소유 값을 작성해야합니다. 문자열 키의 경우 &lt;code&gt;str&lt;/code&gt; 만 사용할 수 있는 경우를 검색하기 위해 &lt;code&gt;String&lt;/code&gt; 값을 작성해야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">언제 &lt;code&gt;UnwindSafe&lt;/code&gt; 를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">배열이 아닌 슬라이스에서 시작할 때 오류 변환 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;monospace&lt;/code&gt; 글꼴로 된 이러한 문자열 이 문법 내에서 발생하면 해당 문자열 테이블 생성의 단일 멤버에 대한 암시 적 참조입니다. 자세한 내용은 &lt;a href=&quot;tokens&quot;&gt;토큰&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="translated">때 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 삭제되고, 그 버퍼의 내용을 폐기한다. 동일한 스트림에 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 의 여러 인스턴스를 생성 하면 데이터가 손실 될 수 있습니다. &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt; &lt;code&gt;BufReader::into_inner&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 을 언 래핑 한 후 기본 판독기에서 읽는 것도 데이터 손실을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">때 &lt;code&gt;BufReader&lt;/code&gt; 가 삭제되고 그 버퍼의 내용을 폐기한다. 동일한 스트림 에서 &lt;code&gt;BufReader&lt;/code&gt; 의 여러 인스턴스를 작성 하면 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">때 &lt;code&gt;BufWriter&lt;/code&gt; 이 삭제되고 버퍼의 내용을 기입한다. 그러나 기록기가 삭제 될 때 버퍼를 플러시하는 과정에서 발생하는 모든 오류는 무시됩니다. 이러한 오류를 처리하려는 코드 는 기록기를 삭제하기 전에 수동으로 &lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">때 &lt;code&gt;Deref&lt;/code&gt; 특징이 포함 된 유형에 대해 정의 된, 녹 유형을 분석하고 사용 &lt;code&gt;Deref::deref&lt;/code&gt; 매개 변수의 유형과 일치하는 참조를 얻기 위해 필요한만큼 여러 번. &lt;code&gt;Deref::deref&lt;/code&gt; 를 삽입 해야하는 횟수 는 컴파일 타임에 해결되므로 deref 강제를 이용하면 런타임 패널티가 없습니다!</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">때 &lt;code&gt;get&lt;/code&gt; 방법은 벡터 외부에있는 인덱스를 전달, 그것은 반환 &lt;code&gt;None&lt;/code&gt; 공황 상태 않고. 벡터의 범위를 벗어난 요소에 액세스하는 것이 정상적인 상황에서 가끔 발생하는 경우이 방법을 사용합니다. 그러면 코드는 6 장에서 논의한 것처럼 &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 을 처리하는 논리를 갖습니다 . 예를 들어, 색인은 숫자를 입력 한 사람이 올 수 있습니다. 실수로 너무 큰 숫자를 입력하고 프로그램에서 &lt;code&gt;None&lt;/code&gt; 값을 얻는 경우 현재 벡터에있는 항목 수를 사용자에게 알려주고 유효한 값을 입력 할 수있는 다른 기회를 제공 할 수 있습니다. 오타로 인해 프로그램이 충돌하는 것보다 사용자 친화적입니다!</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식이 실행될 때 결과 값을 각 팔의 패턴과 순서대로 비교합니다. 패턴이 값과 일치하면 해당 패턴과 관련된 코드가 실행됩니다. 해당 패턴이 값과 일치하지 않으면 동전 정렬 시스템에서와 마찬가지로 다음 팔로 계속 실행됩니다. 우리는 필요한만큼의 무기를 가질 수 있습니다 : 목록 6-3에서, 우리의 &lt;code&gt;match&lt;/code&gt; 는 4 개의 무기를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;match&lt;/code&gt; 식을, 그 범위의 끝을 수행하고, 따라서 내부의 범위 않는 &lt;code&gt;y&lt;/code&gt; . 마지막 &lt;code&gt;println!&lt;/code&gt; 생성 &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">관련 기능 형질 선언되면, 함수는 또한 호출 할 수있는 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 형질의 이름이 첨부 된 형질 경로이다. 이 경우 &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">호출 코드는 클로저를 직접 호출하는 대신 클로저 평가 결과가 필요할 때 &lt;code&gt;value&lt;/code&gt; 메소드를 호출합니다 . 우리는 이미의 결과 값이 있는지이 방법을 확인 &lt;code&gt;self.value&lt;/code&gt; A의 &lt;code&gt;Some&lt;/code&gt; ; 그렇게 하면 클로저를 다시 실행하지 않고 &lt;code&gt;Some&lt;/code&gt; 내의 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">명령 줄 구문 분석 로직 시작이 복잡하기 때에서 추출 &lt;em&gt;main.rs&lt;/em&gt; 과로 이동 &lt;em&gt;lib.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">구성 술어가 true 인 경우이 속성은 술어 뒤에 나열된 속성으로 확장됩니다. 예를 들어, 다음 모듈은 대상을 기반으로 &lt;code&gt;linux.rs&lt;/code&gt; 또는 &lt;code&gt;windows.rs&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">초안이 완료되면 게시물 검토가 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">빈 문자열을 구분 기호로 사용하면 문자열의 시작 및 끝과 함께 문자열의 모든 문자가 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">목표가 단순히 소스에서 읽거나 쓰는 것이라면 소스를 테스트하는 가장 신뢰할 수있는 방법은 소스를 여는 것입니다. 만 사용 &lt;code&gt;is_file&lt;/code&gt; 같은 흐름 깰 수 &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; 예컨대 유닉스 시스템을. 자세한 내용은 &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt; &lt;code&gt;fs::File::open&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt; &lt;code&gt;fs::OpenOptions::open&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">목표가 단순히 소스에서 읽거나 쓰는 것이라면 소스를 테스트하는 가장 신뢰할 수있는 방법은 소스를 여는 것입니다. 만 사용 &lt;code&gt;is_file&lt;/code&gt; 같은 흐름 깰 수 &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; 예컨대 유닉스 시스템을. 자세한 내용은 &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">내부 범위가 끝나면 &lt;code&gt;branch&lt;/code&gt; 가 범위를 벗어나고 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 의 강력한 수가 0으로 감소하여 &lt;code&gt;Node&lt;/code&gt; 가 삭제됩니다. &lt;code&gt;leaf.parent&lt;/code&gt; 의 약한 1은 &lt;code&gt;Node&lt;/code&gt; 가 삭제 되었는지 여부와 관련이 없으므로 메모리 누수가 발생하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="translated">반복기 &lt;strong&gt;가&lt;/strong&gt; 삭제 되면 반복기 &lt;strong&gt;가&lt;/strong&gt; 완전히 사용되지 않은 경우에도 범위의 모든 요소가 벡터에서 제거됩니다. 반복기 &lt;strong&gt;가&lt;/strong&gt; 삭제 &lt;strong&gt;되지 않으면&lt;/strong&gt; ( 예 &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; 사용) 제거되는 요소의 수는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">값에 대해 수행 할 논리가 더 복잡한 경우, &lt;code&gt;entry&lt;/code&gt; API를 사용하여 값이 초기화되고 나중에 논리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">Rust 프로그램의 메인 스레드가 종료되면 다른 스레드가 여전히 실행 중이더라도 전체 프로그램이 종료됩니다. 그러나이 모듈은 하위 스레드 (즉, 결합)의 종료를 자동으로 기다리는 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">소유자가 범위를 벗어나면 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">패턴이 일치하지 않는 경우 :</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">패턴이 성공적으로 일치하면 패턴 가드식이 실행됩니다. 식이 true로 평가되면 패턴이 성공적으로 일치하는 것입니다. 그렇지 않으면, 다음을 포함한 다른 패턴과 &lt;code&gt;|&lt;/code&gt; 같은 팔에있는 작업자가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">게시물이 승인되면 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="translated">프로그램에 유효한 참조가있는 경우 차용 검사기는 소유권 및 차용 규칙 (4 장에서 다룹니다)을 적용하여이 참조와 벡터 콘텐츠에 대한 기타 참조가 유효한 상태로 유지되도록합니다. 동일한 범위에서 변경 가능 및 변경 불가능한 참조를 가질 수 없다는 규칙을 상기하십시오. 이 규칙은 목록 8-7에 적용됩니다. 여기서 벡터의 첫 번째 요소에 대한 변경 불가능한 참조를 보유하고 끝에 요소를 추가하려고합니다. 나중에 함수에서 해당 요소를 참조하려고하면 작동하지 않습니다. :</target>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">프로그램에 유효한 참조가있는 경우 차용 검사기는 소유권 및 차용 규칙 (4 장 참조)을 적용하여이 참조 및 벡터의 내용에 대한 다른 참조가 유효하게 유지되도록합니다. 동일한 범위에서 변경 가능하고 변경 불가능한 참조를 가질 수 없다는 규칙을 상기하십시오. 이 규칙은 Listing 8-7에 적용되는데, 여기서 벡터의 첫 번째 요소에 대한 불변 참조를 보유하고 끝에 요소를 추가하려고 시도하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">프로그래머가 &lt;code&gt;debug_assert!&lt;/code&gt; 를 활성화 한 경우! 어설 션 (예 : 최적화되지 않은 빌드 사용)을 구현 하면 오버플로시 &lt;code&gt;panic&lt;/code&gt; 가되는 동적 검사를 삽입해야합니다 . 구현의 재량에 따라 다른 종류의 빌드로 인해 오버플로시 &lt;code&gt;panics&lt;/code&gt; 하거나 자동 래핑 된 값 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">면밀한 표현이 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 표현&lt;/a&gt; 인 경우 일치는 임시 위치를 할당하지 않습니다. 그러나 값별 바인딩은 메모리 위치에서 복사하거나 이동할 수 있습니다. 가능하면 장소 표현식에서 일치하는 것이 좋습니다. 이러한 일치의 수명은 일치 내부로 제한되는 것이 아니라 장소 표현식의 수명을 상속하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">슬라이스 len이 청크 크기로 균등하게 분할되지 않으면 반복의 마지막 슬라이스가 나머지가됩니다.</target>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">슬라이스 len이 청크 크기로 균등하게 분할되지 않은 경우, 최대 &lt;code&gt;chunk_size-1&lt;/code&gt; 요소까지는 생략되지만 &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; 함수에서 반복자에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">슬라이스 len이 청크 크기로 균등하게 분할되지 않으면, 최대 &lt;code&gt;chunk_size-1&lt;/code&gt; 요소까지는 생략되지만 iterator 의 &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt; 함수에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">후미 세미콜론을 생략하면 결과는 type &lt;code&gt;()&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">벡터가 삭제되면 모든 내용도 삭제되므로 벡터가 보유하는 정수가 정리됩니다. 이것은 간단한 점처럼 보일 수 있지만 벡터 요소에 대한 참조를 시작할 때 조금 더 복잡해질 수 있습니다. 다음에 다루겠습니다!</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="translated">때이없는 &lt;code&gt;Self: Sized&lt;/code&gt; 방법에 바인딩하는 방법 수신기의 유형은 다음 중 하나에 해당합니다 :</target>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">이 클로저가 실행되면 stdio 파일 설명자 및 작업 디렉토리와 같은 측면이 성공적으로 변경되었으므로 이러한 위치로의 출력이 의도 한 위치에 나타나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="translated">이 함수가 const 평가 중에 사용되면 런타임에 null로 판명 된 포인터에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다. 특히, 일부 메모리에 대한 포인터가 결과 포인터가 null 인 방식으로 경계를 넘어 오프셋 될 때 함수는 여전히 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. CTFE가 해당 메모리의 절대 위치를 알 수있는 방법이 없으므로 포인터가 null인지 여부를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">이 함수가 반환되면 일부 초기화가 실행 및 완료되었음을 보장합니다 (지정된 클로저가 아닐 수 있음). 또한 실행 된 클로저에 의해 수행 된 모든 메모리 쓰기가이 시점에서 다른 스레드에 의해 확실하게 관찰 될 수 있음을 보장합니다 (반환 후 실행되는 코드와 클로저 사이에 발생하는 관계가 있음).</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">이 메소드가 호출되었을 때, &lt;code&gt;self&lt;/code&gt; 는 아직 할당 해제되지 않았습니다. 그것은 방법이 끝난 후에 만 ​​발생합니다. 그렇지 않은 경우, &lt;code&gt;self&lt;/code&gt; 는 매달려있는 참조가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">이 프로그램이 실행, 그것은 각각 확인할 때 &lt;code&gt;if&lt;/code&gt; 제 체를 차례로 표현 및 실행하는 조건이 성립. 6을 2로 나눌 수 있지만 출력 &lt;code&gt;number is divisible by 2&lt;/code&gt; 없으며 &lt;code&gt;else&lt;/code&gt; 블록 에서 &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; . Rust는 첫 번째 실제 조건에 대해서만 블록을 실행하기 때문에 블록이 발견되면 나머지는 확인하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">안전하지 않은 코드를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">내부 가변성을 선택하는시기</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">일부 유형이 특성 &lt;code&gt;Foo&lt;/code&gt; 를 구현하게 하려면 최소한 &lt;code&gt;Foo&lt;/code&gt; 의 모든 필수 메소드 (기본 구현이없는 메소드를 의미 함) 및 연관된 유형 또는 상수. 예:</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">A와 사용될 때 &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;슬라이싱 인덱스&lt;/a&gt; , &lt;code&gt;RangeTo&lt;/code&gt; 는 인덱스에 의해 표시 전에 모든 배열 요소의 조각 생성 &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">A와 사용될 때 &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;슬라이싱 인덱스&lt;/a&gt; , &lt;code&gt;RangeToInclusive&lt;/code&gt; 는 로 나타내는 지수까지의 모든 배열 요소의 조각 생성 &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">항목 또는 명령문으로 사용될 때 &lt;em&gt;MacroInvocationSemi&lt;/em&gt; 양식은 중괄호를 사용하지 않을 때 끝에 세미콜론이 필요한 경우에 사용됩니다. &lt;a href=&quot;visibility-and-privacy&quot;&gt;가시성 한정자&lt;/a&gt; 는 매크로 호출 또는 &lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt; 정의 전에 절대 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">&lt;a href=&quot;../items/traits&quot;&gt;특성 선언&lt;/a&gt; 에 사용될 때 해당 특성의 &lt;code&gt;unused_must_use&lt;/code&gt; 적 &lt;a href=&quot;../types/impl-trait&quot;&gt;특성&lt;/a&gt; 을 리턴하는 함수 에 대한 &lt;a href=&quot;../statements#expression-statements&quot;&gt;표현식 명령문&lt;/a&gt; 의 &lt;a href=&quot;../expressions/call-expr&quot;&gt;호출 표현식&lt;/a&gt; 은 미사용 _must_use 린트를 위반합니다 .</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">특성 선언의 함수에 사용될 때 호출 표현식이 특성의 구현에서 함수 인 경우에도 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">특성 구현의 함수에 사용될 때 속성은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">함수에 사용하면 경우, &lt;a href=&quot;../expressions&quot;&gt;표현&lt;/a&gt; 의 &lt;a href=&quot;../statements#expression-statements&quot;&gt;표현 문&lt;/a&gt; A는 &lt;a href=&quot;../expressions/call-expr&quot;&gt;호출을 표현&lt;/a&gt; 하는 함수, 다음 &lt;code&gt;unused_must_use&lt;/code&gt; 보풀 위반된다.</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">사용자 정의 복합 형에 사용하면 경우, &lt;a href=&quot;../expressions&quot;&gt;표현&lt;/a&gt; 의 &lt;a href=&quot;../statements#expression-statements&quot;&gt;표현 문은&lt;/a&gt; 그 유형이 다음 &lt;code&gt;unused_must_use&lt;/code&gt; 보풀 위반된다.</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">대체 형식 지정자 &lt;code&gt;#?&lt;/code&gt; 과 함께 사용하면 ? 출력이 예쁘게 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 를 사용할 때 닫힌 변수 중 일부가 해제 안전하지 않은 경우가 있습니다. 예를 들어 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 캡처되면 컴파일러는 해제 안전하지 않다는 경고를 생성합니다. 그러나 풀기 안전을 특별히 고려하면 &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 의 특정 사용으로 인해 실제로 문제가되는 것은 아닙니다 . 이 래퍼 구조체는 변수가 실제로 안전하다는 빠르고 가벼운 주석에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">미래를 사용할 때는 일반적으로 &lt;code&gt;poll&lt;/code&gt; 직접 호출하지 않고 대신 값을 &lt;code&gt;.await&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 와 같은 수명을 유형에 사용할 때는 사용 하기 전에 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="translated">가장 위 식 컨텍스트의 값 표현식을 사용하는 경우, 임시 명명 메모리 위치가있는 경우를 제외하고, 그 값 대신에 해당 위치에 발현 평가하여 초기화하여 생성된다 &lt;a href=&quot;destructors#constant-promotion&quot;&gt;촉진&lt;/a&gt; A를 &lt;code&gt;static&lt;/code&gt; . &lt;a href=&quot;destructors#drop-scopes&quot;&gt;드롭 범위&lt;/a&gt; 임시의 보통 바깥 문의 끝입니다.</target>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용하는 경우 이름이 지정되지 않은 임시 메모리 위치가 해당 값으로 초기화되어 &lt;code&gt;'static&lt;/code&gt; 으로 승격 된 경우를 제외하고 대신 해당 위치로 평가됩니다 . &lt;code&gt;'static&lt;/code&gt; 슬롯 으로 값 표현식 승격 ' 은 표현식이 상수로 작성되고 빌린 다음 런타임 동작을 변경하지 않고 표현식이 원래 작성된 위치에서 빌린 참조를 역 참조 할 수있을 때 발생합니다. 즉, 승격 된 표현식은 컴파일 타임에 평가 될 수 있으며 결과 값에는 &lt;a href=&quot;interior-mutability&quot;&gt;내부 변경 가능성&lt;/a&gt; 또는 &lt;a href=&quot;destructors&quot;&gt;소멸자가&lt;/a&gt; 포함되지 않습니다 (이러한 특성은 가능한 경우 값을 기반으로 결정됩니다. 예를 들어 &lt;code&gt;&amp;amp;None&lt;/code&gt; 항상 유형을 가짐) &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; 에는 허용되지 않는 것이 포함되어 있습니다). 그렇지 않으면 임시 값의 수명은 일반적으로</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="translated">함수 유형에 별칭을 사용하는 경우 예를 들어 매개 변수를 변경 가능한 것으로 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">반복에 포함 범위를 사용하는 경우 반복이 종료 된 후 &lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;end()&lt;/code&gt; 이 지정되지 않습니다. 포함 범위가 비어 있는지 판별하려면 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 를 비교하는 대신 &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">반복에 포함 범위를 사용하는 경우 반복이 종료 된 후 &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;end()&lt;/code&gt; 이 지정되지 않습니다. 포함 범위가 비어 있는지 확인하려면 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 를 비교하는 대신 &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">반복에 포함 범위를 사용하는 경우 반복이 종료 된 후 &lt;code&gt;start()&lt;/code&gt; 및 &lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; 이 지정되지 않습니다. 포함 범위가 비어 있는지 판별하려면 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 를 비교하는 대신 &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">반복에 포함 범위를 사용하는 경우 반복이 종료 된 후 &lt;code&gt;start()&lt;/code&gt; 및 &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; 이 지정되지 않습니다. 포함 범위가 비어 있는지 확인하려면 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 를 비교하는 대신 &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">생성기 (또는 비동기)를 사용할 때 생성기를 구성 할 수 있도록 모든 유형 변수를 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">반복자를 사용할 때 종종 여러 반복자를 연결합니다. 이러한 코드를 작업하는 동안 파이프 라인의 다양한 부분에서 무슨 일이 일어나고 있는지 확인할 수 있습니다. 그렇게하려면 &lt;code&gt;inspect()&lt;/code&gt; 호출을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">튜플 구조체 에서 &lt;code&gt;#[simd]&lt;/code&gt; 속성을 사용하는 경우 튜플 구조체의 구성 요소는 모두 비 제네릭 형식이어야하며 컴파일러에서 SIMD를 사용하는 방법에 대해 추론 할 수 있습니다. 유형이 일반인 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">튜플 구조체 에서 &lt;code&gt;#[simd]&lt;/code&gt; 속성을 사용하는 경우 튜플의 요소는 SIMD 작업을 적용 할 수 있도록 머신 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">사용시 &lt;code&gt;#[simd]&lt;/code&gt; 자동 튜플 구조체에 SIMD 연산을 사용하는 특성, 구조체의 종류는 모두 동일한 유형이어야 또는 컴파일러는이 에러를 유발한다.</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="translated">일반 인수가있는 항목을 사용 / 선언 할 때 정확히 동일한 번호를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 을 &lt;code&gt;s2&lt;/code&gt; 에 할당 하면 &lt;code&gt;String&lt;/code&gt; 데이터가 복사됩니다. 즉 스택에있는 포인터, 길이 및 용량을 복사합니다. 포인터가 참조하는 힙의 데이터는 복사하지 않습니다. 즉, 메모리의 데이터 표현은 그림 4-2와 같습니다.</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 키워드를 사용 하여 이름을 범위로 가져 오면 새 범위에서 사용 가능한 이름은 비공개입니다. 코드를 호출하는 코드가 해당 코드의 범위에 정의 된 것처럼 해당 이름을 참조 할 수 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;pub&lt;/code&gt; 와 use를 결합 할 수 있습니다 . 이 기술을 품목을 범위 내로 가져오고 다른 사람이 해당 범위로 가져올 수 있도록하기 때문에 &lt;em&gt;재수출&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">우리가 호출 할 때 &lt;code&gt;fly&lt;/code&gt; 의 인스턴스에 &lt;code&gt;Human&lt;/code&gt; , 목록 19-17에서와 같이 직접 유형에 구현 된 메소드를 호출하는 컴파일러 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">우리가 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 로이 매크로를 호출 할 때 ! [1, 2, 3]; 는 &lt;code&gt;$x&lt;/code&gt; 패턴은 세 가지 표현으로 3 회 일치 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , 및 &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="translated">이 코드를 컴파일 할 때 다음 핵심 메시지와 함께 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">이 코드를 컴파일하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">이 코드를 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">이 예제를 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Post&lt;/code&gt; 를 생성 할 때 , &lt;code&gt;state&lt;/code&gt; 필드를 &lt;code&gt;Box&lt;/code&gt; 를 보유한 &lt;code&gt;Some&lt;/code&gt; 값으로 설정합니다 . 이 &lt;code&gt;Box&lt;/code&gt; 는 &lt;code&gt;Draft&lt;/code&gt; 구조체 의 새로운 인스턴스를 가리 킵니다 . 이를 통해 &lt;code&gt;Post&lt;/code&gt; 의 새 인스턴스를 만들 때마다 초안으로 시작합니다. &lt;code&gt;Post&lt;/code&gt; 의 &lt;code&gt;state&lt;/code&gt; 필드 는 비공개이므로 다른 상태에서 &lt;code&gt;Post&lt;/code&gt; 를 작성할 수있는 방법이 없습니다 ! 에서 &lt;code&gt;Post::new&lt;/code&gt; 기능, 우리는 설정 &lt;code&gt;content&lt;/code&gt; 비어있는 새에 필드를 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">우리가 만들 때 &lt;code&gt;branch&lt;/code&gt; 노드를, 또한 새로운 것 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 참조 &lt;code&gt;parent&lt;/code&gt; 때문에, 필드 &lt;code&gt;branch&lt;/code&gt; 부모 노드가 없습니다. 우리는 여전히 &lt;code&gt;branch&lt;/code&gt; 의 자녀 중 하나로 &lt;code&gt;leaf&lt;/code&gt; 을 가지고 있습니다 . &lt;code&gt;branch&lt;/code&gt; 에 &lt;code&gt;Node&lt;/code&gt; 인스턴스 가 있으면 &lt;code&gt;leaf&lt;/code&gt; 를 수정 하여 부모에게 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 참조를 제공 할 수 있습니다 . 우리는 사용 &lt;code&gt;borrow_mut&lt;/code&gt; 의 온 방법을 &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 에 &lt;code&gt;parent&lt;/code&gt; 의 필드 &lt;code&gt;leaf&lt;/code&gt; , 그리고 우리가 사용 &lt;code&gt;Rc::downgrade&lt;/code&gt; 를 만드는 기능을 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; 의 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;branch.&lt;/code&gt; 대한 약한 &amp;lt;Node&amp;gt; 참조</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">Listing 15-9에서 &lt;code&gt;*y&lt;/code&gt; 를 입력했을 때 Rust가 실제로이 코드를 실행 한 뒤에서</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">명령을 입력하면 Cargo 는 패키지를 제공 하는 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만들었습니다 . &lt;em&gt;Cargo.toml&lt;/em&gt; 의 내용을 &lt;em&gt;살펴보면&lt;/em&gt; Cargo는 &lt;em&gt;src / main.rs&lt;/em&gt; 가 패키지와 이름이 같은 이진 크레이트의 상자 루트 라는 규칙을 &lt;em&gt;따르기&lt;/em&gt; 때문에 &lt;em&gt;src / main.rs에&lt;/em&gt; 대한 언급이 없습니다 . 마찬가지로 Cargo는 패키지 디렉토리에 &lt;em&gt;src / lib.rs&lt;/em&gt; 가 포함되어 있으면 패키지 와 이름이 같은 라이브러리 상자가 패키지에 포함되며 &lt;em&gt;src / lib.rs&lt;/em&gt; 가 상자 루트 &lt;em&gt;라는 것을 알고&lt;/em&gt; 있습니다. 화물은 크레이트 루트 파일을 &lt;code&gt;rustc&lt;/code&gt; 에 전달하여 라이브러리 또는 바이너리를 빌드합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">우리가 &lt;code&gt;Some&lt;/code&gt; 값 을 가질 때 , 우리는 값이 존재하고 그 값이 &lt;code&gt;Some&lt;/code&gt; 안에 있음을 알고 있습니다. &lt;code&gt;None&lt;/code&gt; 값 을 가질 때 어떤 의미에서는 null과 같은 의미입니다. 유효한 값이 없습니다. 그렇다면 왜 null을 갖는 것보다 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 를 갖는 것이 더 좋을까요?</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">수명이있는 구조체에서 메서드를 구현할 때는 Listing 10-11에 나와있는 일반 형식 매개 변수와 동일한 구문을 사용합니다. 수명 매개 변수를 선언하고 사용하는 위치는 구조체 필드와 관련이 있는지 또는 메서드 매개 변수와 반환 값에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">&lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; 를 구현할 때 두 개의 &lt;code&gt;Point&lt;/code&gt; 인스턴스 를 추가하려고했기 때문에 &lt;code&gt;RHS&lt;/code&gt; 의 기본값을 사용했습니다 . 기본값을 사용하지 않고 &lt;code&gt;RHS&lt;/code&gt; 유형 을 사용자 정의하려는 &lt;code&gt;Add&lt;/code&gt; 특성 을 구현하는 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">&lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; 를 구현할 때 두 개의 &lt;code&gt;Point&lt;/code&gt; 인스턴스 를 추가하기를 원했기 때문에 &lt;code&gt;Rhs&lt;/code&gt; 의 기본값을 사용했습니다 . 기본값을 사용하는 대신 &lt;code&gt;Rhs&lt;/code&gt; 유형 을 사용자 정의하려는 &lt;code&gt;Add&lt;/code&gt; 특성 을 구현하는 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">우리가 볼 때 &lt;em&gt;SRC / main.rs&lt;/em&gt; 다시, 우리는 것을 볼 수 있습니다 &lt;code&gt;cargo fix&lt;/code&gt; 코드를 변경 :</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">Cargo로 새 라이브러리 프로젝트를 만들면 테스트 기능이 포함 된 테스트 모듈이 자동으로 생성됩니다. 이 모듈을 사용하면 테스트 작성을 시작할 수 있으므로 새 프로젝트를 시작할 때마다 테스트 기능의 정확한 구조와 구문을 찾을 필요가 없습니다. 테스트 기능과 테스트 모듈을 원하는만큼 추가 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">구체적인 참조를 &lt;code&gt;longest&lt;/code&gt; 전달할 때 &lt;code&gt;'a&lt;/code&gt; 로 대체되는 구체적인 수명 은 &lt;code&gt;y&lt;/code&gt; 의 범위와 겹치는 &lt;code&gt;x&lt;/code&gt; 의 범위의 일부입니다 . 즉, 일반 수명 &lt;code&gt;'a&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 수명 중 작은 수명과 동일한 구체적인 수명을 얻습니다 . 동일한 수명 매개 변수 &lt;code&gt;'a&lt;/code&gt; 를 사용하여 반환 된 참조에 주석을 달았으므로 반환 된 참조는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 수명 중 작은 길이에 대해서도 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 를 인쇄 하면 모두 5가 아닌 15의 수정 된 값을가집니다.</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;leaf&lt;/code&gt; 의 부모를 다시 인쇄하면 이번에는 &lt;code&gt;Some&lt;/code&gt; 변형 보유 &lt;code&gt;branch&lt;/code&gt; . 이제 &lt;code&gt;leaf&lt;/code&gt; 이 부모에 액세스 할 수 있습니다! 우리는 &lt;code&gt;leaf&lt;/code&gt; 을 인쇄 할 때 Listing 15-26에서와 같이 결국 스택 오버플로로 끝나는주기를 피한다. &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 참고 문헌으로 출력 &lt;code&gt;(Weak)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">&lt;code&gt;cargo doc --open&lt;/code&gt; 을 실행하면 이 주석은 그림 14-2에 표시된 것처럼 상자의 공개 항목 목록 위에있는 &lt;code&gt;my_crate&lt;/code&gt; 에 대한 설명서의 첫 페이지에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">Listing 16-8에서 코드를 실행하면 메인 스레드에서 값이 인쇄 된 것을 볼 수있다.</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">지금 프로그램을 실행하면 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">Listing 11-8에서 테스트를 실행하면 실패한다.</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">테스트를 다시 실행하면 &lt;em&gt;common.rs&lt;/em&gt; 파일 의 테스트 출력 &lt;em&gt;에이&lt;/em&gt; 섹션에 테스트 함수가 포함되어 있지 않거나 어디서나 &lt;code&gt;setup&lt;/code&gt; 함수를 호출하지 않아도 새로운 섹션 이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">&lt;code&gt;--nocapture&lt;/code&gt; 플래그를 사용하여 목록 11-10의 테스트를 다시 실행 하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">&lt;code&gt;--show-output&lt;/code&gt; 플래그를 사용하여 Listing 11-10의 테스트를 다시 실행 하면 다음 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">이 테스트를 &lt;code&gt;cargo test&lt;/code&gt; 로 실행 하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">Listing 5-14 의 &lt;code&gt;main&lt;/code&gt; 함수 로이 코드를 실행하면 원하는 결과를 얻을 수있다. 메소드는 &lt;code&gt;self&lt;/code&gt; 매개 변수 다음에 서명에 추가하는 여러 매개 변수를 취할 수 있으며 이러한 매개 변수는 함수의 매개 변수와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">이 코드를 실행할 때 마지막 &lt;code&gt;println!&lt;/code&gt; 유지하십시오 ! 잠시 동안 주석을 달면 다음과 같은 결과가 나옵니다.</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">이 코드를 실행할 때 첫 번째 &lt;code&gt;[]&lt;/code&gt; 메서드는 존재하지 않는 요소를 참조하기 때문에 프로그램이 패닉 상태가됩니다. 이 방법은 벡터 끝을 지나서 요소에 액세스하려는 경우 프로그램이 중단되도록하려는 경우에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">이 코드를 실행하면이 핵심 메시지에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">이 코드를 실행하면 Listing 3-4와 동일한 결과가 표시된다. 더 중요한 것은 이제 코드의 안전성을 높이고 배열의 끝을 넘어서거나 멀어 지거나 일부 항목이 누락되어 발생할 수있는 버그의 가능성을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">이 프로그램을 실행하면 &lt;code&gt;again!&lt;/code&gt; 보게 됩니다! 프로그램을 수동으로 중지 할 때까지 계속해서 계속해서 인쇄합니다. 대부분의 터미널은 키보드 루프 (ctrl-c)를 지원하여 연속 루프에 걸린 프로그램을 중단시킵니다. 시도 해봐:</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">이 코드를 확인하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">Listing 19-5에서 코드를 컴파일하려고하면 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">이 코드를 컴파일하려고하면 오류가 발생합니다. &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 무기는 호환되지 않는 값 유형이 있고, 녹 어디 프로그램에서 문제를 찾을 수 정확하게 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">함수 본문에서 매개 변수를 사용할 때 서명에서 매개 변수 이름을 선언해야 컴파일러에서 해당 이름의 의미를 알 수 있습니다. 마찬가지로 함수 시그니처에 형식 매개 변수 이름을 사용하는 경우 형식 매개 변수 이름을 사용하기 전에 선언해야합니다. &lt;code&gt;largest&lt;/code&gt; 일반 함수 를 정의하려면 다음과 같이 형식 이름 선언을 함수 이름과 매개 변수 목록 사이에 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 안에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">제네릭 형식 매개 변수를 사용하면 제네릭 형식의 기본 콘크리트 형식을 지정할 수 있습니다. 따라서 기본 유형이 작동하는 경우 특성의 구현자가 구체적 유형을 지정할 필요가 없습니다. 제네릭 형식을 선언 할 때 제네릭 형식의 기본 형식을 지정하는 구문은 &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">특성 오브젝트를 사용할 때 Rust는 동적 디스패치를 ​​사용해야합니다. 컴파일러는 trait 객체를 사용하는 코드와 함께 사용될 수있는 모든 유형을 알지 못하므로 어떤 유형을 어떤 유형으로 호출해야하는지 알 수 없습니다. 대신 런타임시 Rust는 특성 객체 내부의 포인터를 사용하여 호출 할 메소드를 확인합니다. 이 조회가 발생하면 정적 디스패치에서 발생하지 않는 런타임 비용이 있습니다. 동적 디스패치는 컴파일러가 메소드의 코드를 인라인하도록 선택하지 못하게하여 일부 최적화를 방해합니다. 그러나 Listing 17-5에서 작성하고 Listing 17-9에서 지원할 수있는 코드에 유연성이 추가되었으므로 고려해야 할 절충안이다.</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">라이브러리를 작성할 때 누군가가 &lt;code&gt;SelectBox&lt;/code&gt; 유형을 추가 할 수 있다는 것을 &lt;code&gt;SelectBox&lt;/code&gt; 가 &lt;code&gt;Draw&lt;/code&gt; 특성을 구현 하기 때문에 &lt;code&gt;Screen&lt;/code&gt; 구현이 새 유형에서 작동하고 그릴 수 있었습니다 . 이는 &lt;code&gt;draw&lt;/code&gt; 메소드를 구현 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">이 함수를 정의 할 때이 함수에 전달 될 구체적인 값을 알 수 없으므로 &lt;code&gt;if&lt;/code&gt; 케이스 또는 &lt;code&gt;else&lt;/code&gt; 케이스가 실행 될지 여부를 알 수 없습니다 . 우리는 또한 전달 될 레퍼런스의 구체적인 수명을 알지 못하므로 Listing 10-18 및 10-19에서했던 범위를 살펴보면 반환하는 레퍼런스가 항상 유효한지 여부를 판단 할 수 없습니다 . 차용 검사기는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 수명이 반환 값의 수명과 어떤 관련 이 있는지 알지 못하므로이를 확인할 수 없습니다 . 이 오류를 해결하기 위해 차용 검사기가 분석을 수행 할 수 있도록 참조 간의 관계를 정의하는 일반 수명 매개 변수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">고정 된 구조체로 작업 할 때 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 만 취하는 메서드에서 해당 구조체의 필드에 액세스 할 수있는 방법에 대한 의문이 생깁니다 . 일반적인 접근 방식은 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 를 필드에 대한 참조로 바꾸는 도우미 메서드 (소위 &lt;em&gt;프로젝션&lt;/em&gt; ) 를 작성하는 것입니다.하지만 해당 참조에는 어떤 유형이 있어야합니까? 그것은인가 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ? &lt;code&gt;enum&lt;/code&gt; 의 필드 와 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 컨테이너 / 래퍼 유형을 고려할 때도 동일한 질문이 발생합니다.. (이 질문은 변경 가능한 참조와 공유 참조 모두에 적용되며, 여기서는 설명을 위해 변경 가능한 참조의 더 일반적인 경우를 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">고정 된 구조체로 작업 할 때 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 만 취하는 메소드에서 해당 구조체의 필드에 액세스하는 방법에 대한 의문이 제기 됩니다. 일반적인 접근 방식은 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 를 필드에 대한 참조로 바꾸는 도우미 메소드 ( &lt;em&gt;프로젝션&lt;/em&gt; 이라고 함 )를 작성하는 것이지만 해당 참조에는 어떤 유형이 있어야합니까? 그것은인가 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ? &lt;code&gt;enum&lt;/code&gt; 의 필드 와 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 컨테이너 / 래퍼 유형을 고려할 때도 동일한 질문이 발생합니다.. (이 질문은 변경 가능 및 공유 참조 모두에 적용됩니다. 여기서는 더 일반적인 변경 가능 참조 사례를 예로 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">파일 끝을 넘어 쓸 때 파일은 적절하게 확장되고 중간 바이트는 값 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">파일 끝을 넘어 쓸 때 파일은 적절하게 확장되고 중간 바이트는 초기화되지 않은 상태로 남습니다.</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형 을 리턴하는 많은 함수를 호출하는 코드를 작성할 때 오류 처리가 번거로울 수 있습니다. 물음표 연산자 &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;호출 스택에 오류가 전파되는 상용구를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형 을 반환하는 많은 함수를 호출하는 코드를 작성할 때 오류 처리가 지루할 수 있습니다. 물음표 연산자 &lt;a href=&quot;../ops/trait.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;, 호출 스택에 오류를 전파하는 보일러 플레이트 중 일부를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">모듈에 대한 단위 테스트를 작성할 때 테스트 할 모듈의 바로 자식을 &lt;code&gt;mod test&lt;/code&gt; 라고하는 것이 일반적 관용구 입니다. 이 모듈은 두 번째 경우를 통해 상위 모듈의 모든 항목에 액세스 할 수 있습니다. 즉, 내부 구현 세부 사항도 하위 모듈에서 완벽하게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">자신 만의 특성을 쓸 때 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;panic!&lt;/code&gt; 하지 않는 명백한 &lt;code&gt;impl&lt;/code&gt; 이 있을 때마다 &lt;code&gt;impl&lt;/code&gt; 을 가져야합니다 ! . 결과적으로, 대부분의 특성은 &lt;code&gt;impl&lt;/code&gt; 를 가질 수 있습니다 &lt;code&gt;!&lt;/code&gt; . 예를 들어 &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 를 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="translated">자신 만의 특성을 쓸 때 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;panic!&lt;/code&gt; 하지 않는 명백한 &lt;code&gt;impl&lt;/code&gt; 이 있을 때마다 &lt;code&gt;impl&lt;/code&gt; 이 있어야합니다 ! . 그 이유는 함수가 &lt;code&gt;impl Trait&lt;/code&gt; 를 반환하는 곳입니다 &lt;code&gt;!&lt;/code&gt; 유일한 코드 경로로 분기 할 수없는 &lt;code&gt;Trait&lt;/code&gt; 의 &lt;code&gt;impl&lt;/code&gt; 이 없습니다. 즉, 그들은 돌아올 수 없습니다 &lt;code&gt;!&lt;/code&gt; 모든 코드 경로에서. 예를 들어이 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">당신이하면 &lt;em&gt;않는&lt;/em&gt; 나무 상자를 업데이트 할,화물은 다른 명령, 제공하는 &lt;code&gt;update&lt;/code&gt; 무시합니다, &lt;em&gt;Cargo.lock의&lt;/em&gt; 에서 귀하의 사양에 맞게 모든 최신 버전에서 파일 및 그림 &lt;em&gt;Cargo.toml을&lt;/em&gt; . 이것이 작동하면 Cargo는 해당 버전을 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 에 &lt;em&gt;기록&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">&lt;code&gt;.foo()&lt;/code&gt; 구문 으로 메소드를 호출 할 때 긴 줄을 나누는 데 도움이되는 줄 바꿈 및 기타 공백을 도입하는 것이 좋습니다. 이 코드를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">클로저를 만들 때 Rust는 클로저가 환경의 값을 사용하는 방식에 따라 사용할 특성을 추론합니다. 모든 클로저는 &lt;code&gt;FnOnce&lt;/code&gt; 를 구현합니다. FnOnce 는 모두 한 번 이상 호출 할 수 있기 때문입니다. 캡처 된 변수를 이동하지 않는 클로저는 &lt;code&gt;FnMut&lt;/code&gt; 을 구현하고 캡처 된 변수에 대한 변경 가능한 액세스가 필요하지 않은 클로저도 &lt;code&gt;Fn&lt;/code&gt; 을 구현 합니다. 목록 13-12에서 &lt;code&gt;equal_to_x&lt;/code&gt; 의 폐쇄 빌리는 &lt;code&gt;x&lt;/code&gt; (그래서 변함 &lt;code&gt;equal_to_x&lt;/code&gt; 있다 &lt;code&gt;Fn&lt;/code&gt; 폐쇄의 몸은의 값을 읽을 필요가 있기 때문에 특성) &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">많은 양의 데이터가 있고 소유권을 이전하고 싶지만 데이터가 복사되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">컴파일 타임에 크기를 알 수없는 유형이 있고 정확한 크기가 필요한 컨텍스트에서 해당 유형의 값을 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">코드에서 보유한 값의 유형 만 다른 여러 구조체 또는 열거 정의를 사용하여 코드의 상황을 인식하면 대신 일반 유형을 사용하여 중복을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">&lt;code&gt;cargo check&lt;/code&gt; 다시 실행 하면 몇 가지 경고가 더 표시되지만 성공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">실행하면 원래 실행 파일의 경로를 얻지 못하고 하드 링크의 경로를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">여러 테스트를 실행하면 기본적으로 스레드를 사용하여 병렬로 실행됩니다. 즉, 테스트 실행 속도가 빨라 코드 작동 여부에 대한 피드백을 더 빨리 얻을 수 있습니다. 테스트가 동시에 실행되므로 테스트가 현재 작업 디렉토리 또는 환경 변수와 같은 공유 환경을 포함하여 서로 또는 공유 상태에 의존하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">코드를 실행할 때 출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">프로그램을 실행하면 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">이 코드를 실행하면 컴파일되지만 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">&lt;code&gt;clone&lt;/code&gt; 호출이 보이면 임의의 코드가 실행 중이고 해당 코드가 비쌀 수 있습니다. 다른 일이 일어나고 있음을 시각적으로 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">소유권을 이해하면 Rust를 독특하게 만드는 기능을 이해하기위한 견고한 토대를 갖게됩니다. 이 장에서는 매우 일반적인 데이터 구조에 초점을 둔 몇 가지 예인 문자열을 통해 소유권을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">함수가 여러 개의 매개 변수를 가지려면 다음과 같이 매개 변수 선언을 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">가치를 소유하고 싶을 때 특정 유형이 아닌 특정 특성을 구현하는 유형 만 신경 쓰면</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--release&lt;/code&gt; 플래그를 사용하여 릴리스 모드에서 컴파일 할 때 Rust는 패닉을 유발하는 정수 오버플로 검사를 포함 하지 &lt;em&gt;않습니다&lt;/em&gt; . 대신 오버플로가 발생하면 Rust는 &lt;em&gt;2의 보수 래핑을&lt;/em&gt; 수행합니다 . 즉, 유형이 보유 할 수있는 최소값까지 유형을 유지할 수있는 최대 값보다 큰 값입니다. &lt;code&gt;u8&lt;/code&gt; 의 경우 256은 0이되고 257은 1이됩니다. 프로그램은 패닉 상태가되지 않지만 변수는 예상했던 것과 다른 값을 가질 것입니다. 정수 오버플로의 래핑 동작에 의존하는 것은 오류로 간주됩니다. 명시 적으로 줄 바꿈하려면 표준 라이브러리 유형 &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">뮤텍스가 보호하는 데이터가 완료되면 다른 스레드가 잠금을 획득 할 수 있도록 데이터를 잠금 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">계속 진행할 준비가되면 다른 프로그래밍 언어 &lt;em&gt;에는&lt;/em&gt; 일반적으로 존재 &lt;em&gt;하지 않는&lt;/em&gt; Rust의 개념 인 소유권에 대해 이야기하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">이 함수 내에서 오류를 처리하는 대신 구현이 실패 할 수있는 함수를 호출하는 함수를 작성할 때 오류를 호출 코드로 리턴하여 수행 할 조치를 결정할 수 있습니다. 이를 오류 &lt;em&gt;전파&lt;/em&gt; 라고하며 호출 코드를보다 잘 제어 할 수 있습니다. 여기서 코드 컨텍스트에서 사용 가능한 것보다 오류를 처리하는 방법을 지시하는 정보 또는 논리가 더있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">프로그램을 작성할 때 프로그램이 런타임에 벡터에 저장할 수있는 전체 유형 집합을 모르면 열거 형 기술이 작동하지 않습니다. 대신 17 장에서 다룰 특성 개체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">일부 개념을 설명하기 위해 예제를 작성할 때 예제에 강력한 오류 처리 코드가 있으면 예제가 덜 명확해질 수 있습니다. 예를 들어, 패닉이 발생할 수있는 &lt;code&gt;unwrap&lt;/code&gt; 과 같은 메소드에 대한 호출 은 애플리케이션이 오류를 처리하기를 원하는 방식에 대한 자리 표시 자로서 의미되며, 이는 나머지 코드가 수행하는 작업에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">상자를 변경하고 새 버전을 출시 할 준비가되면 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 지정된 &lt;code&gt;version&lt;/code&gt; 값 을 변경 하고 다시 게시하십시오. &lt;a href=&quot;http://semver.org/&quot;&gt;시맨틱 버전 관리 규칙&lt;/a&gt; 을 사용하여 변경 한 종류에 따라 다음 버전 번호를 결정하십시오. 그런 다음 &lt;code&gt;cargo publish&lt;/code&gt; 를 실행 하여 새 버전을 업로드하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">귀하의 경우 &lt;code&gt;Iterator&lt;/code&gt; 구현 &lt;code&gt;TrustedLen&lt;/code&gt; 하고 정확한 크기이며, 하나의 할당이에 대하여 설명한다 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">귀하의 경우 &lt;code&gt;Iterator&lt;/code&gt; 구현 &lt;code&gt;TrustedLen&lt;/code&gt; 하고 정확한 크기이며, 하나의 할당이에 대하여 설명한다 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">코드가 함수를 호출하면 함수에 전달 된 값 (힙의 데이터에 대한 포인터 포함)과 함수의 로컬 변수가 스택으로 푸시됩니다. 함수가 끝나면 해당 값이 스택에서 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">코드에서 값에 대한 작업을 수행 할 때 코드에서 값이 먼저 유효한지 확인하고 값이 유효하지 않으면 패닉 상태가됩니다. 이것은 대부분 안전상의 이유입니다. 유효하지 않은 데이터를 조작하려고하면 코드가 취약해질 수 있습니다. 이것이 표준 라이브러리가 &lt;code&gt;panic!&lt;/code&gt; 이라고 부르는 주된 이유입니다 ! 범위를 벗어난 메모리 액세스를 시도하는 경우 : 현재 데이터 구조에 속하지 않는 메모리에 액세스하는 것은 일반적인 보안 문제입니다. 기능은 종종&lt;em&gt; 계약이 있습니다&lt;/em&gt;: 입력이 특정 요구 사항을 충족하는 경우에만 동작이 보장됩니다. 계약 위반시 당황한 ​​것은 계약 위반이 항상 발신자 측 버그를 나타내며 호출 코드가 명시 적으로 처리해야하는 일종의 오류가 아니기 때문에 의미가 있습니다. 사실, 복구를 위해 코드를 호출하는 합리적인 방법은 없습니다. 호출 &lt;em&gt;프로그래머&lt;/em&gt; 는 코드를 수정해야합니다. 기능 위반, 특히 위반이 패닉을 유발할 경우, 해당 기능에 대한 API 문서에서 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">프로젝트가 출시 될 준비가되면 &lt;code&gt;cargo build --release&lt;/code&gt; 를 사용하여 최적화로 컴파일 할 수 있습니다 . 이 명령은 &lt;em&gt;target / debug&lt;/em&gt; 대신 &lt;em&gt;target / release&lt;/em&gt; 에서 실행 파일을 작성합니다 . 최적화를 통해 Rust 코드를 더 빠르게 실행할 수 있지만이를 켜면 프로그램을 컴파일하는 데 걸리는 시간이 길어집니다. 그렇기 때문에 개발 용, 신속하고 자주 재 구축하려는 경우, 반복적으로 재 구축되지 않고 사용자에게 제공되는 최종 프로그램을 구축하기위한 두 가지 프로파일이 있습니다. 가능한. 코드의 실행 시간을 벤치마킹하는 경우 &lt;code&gt;cargo build --release&lt;/code&gt; 실행하고&lt;em&gt;&lt;/em&gt;&lt;em&gt; target / release&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">임시가 작성 될 때마다 고정 규칙에 따라 자동으로 삭제 (해제)됩니다. 일반적으로 임시 선언문은 엔 클로징 명령문의 끝에 (이 경우 &lt;code&gt;let&lt;/code&gt; 이후) 삭제됩니다 . 이것은 위 예제에서 &lt;code&gt;tmp&lt;/code&gt; 를 보여줌으로써 설명됩니다 블록을 종료 할 때 가 해제 .</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">가능할 때마다 &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; 를&lt;/a&gt; 대신 사용하는 것이 좋습니다. 이렇게하면 ManualDrop &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용이 복제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">가능하다면, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용이 복제되는 것을 방지하는 대신에 &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">가능할 때마다 &lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋으며 , 이는 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 복제하는 것을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">where 절</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">어디있어 &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; 연산자 ?</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">표현식을 평가할 때 하위 표현식을 평가할지 여부</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">아휴! 이제 도구 상자에 자주 사용하지 않는 녹 기능이 있지만 매우 특정한 상황에서 사용할 수 있다는 것을 알게 될 것입니다. 우리는 오류 메시지 제안이나 다른 사람들의 코드에서 발견 될 때 이러한 개념과 구문을 인식 할 수 있도록 몇 가지 복잡한 주제를 소개했습니다. 솔루션을 안내하기 위해이 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">아휴! 그것은 많은 작업 이었지만, 우리는 미래에 성공하기 위해 스스로를 설정했습니다. 이제 오류를 처리하기가 훨씬 쉬워졌으며 코드를 더욱 모듈화했습니다. 우리의 거의 모든 작업은 &lt;em&gt;src / lib.rs&lt;/em&gt; 에서 수행 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">아휴! 우리는 &lt;em&gt;또한&lt;/em&gt; 우리가 불변 일을하면서 변경 가능한 참조를 가질 수 없습니다. 불변의 참조 사용자는 값이 갑자기 그 아래에서 변경 될 것으로 기대하지 않습니다! 그러나 데이터를 읽는 사람은 다른 사람의 데이터 읽기에 영향을 줄 수있는 능력이 없으므로 여러 개의 불변의 참조는 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">설정된 구성 옵션은 크레이트를 컴파일하는 동안 정적으로 결정됩니다. 특정 옵션은 컴파일 관련 데이터를 기반으로 &lt;em&gt;컴파일러 세트&lt;/em&gt; 입니다. 다른 옵션은 코드 외부의 컴파일러에 전달 된 입력을 기반으로 &lt;em&gt;임의로 설정&lt;/em&gt; 됩니다. 컴파일되는 상자의 소스 코드 내에서 구성 옵션을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aec19e71f7245e5468afe6ba28062c55126000f9" translate="yes" xml:space="preserve">
          <source>Which kind of future are we turning this into?</source>
          <target state="translated">우리는 이것을 어떤 미래로 바꾸고 있습니까?</target>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">우리는 이것을 어떤 종류의 반복자로 바꾸고 있습니까?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">어떤 방법이 가장 효과가 좋은지는 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f77bbb1b800fe27a58f9b1a9edd741074b14ca16" translate="yes" xml:space="preserve">
          <source>Which of our two &lt;code&gt;HasDrop&lt;/code&gt; drops first, though? For structs, it's the same order that they're declared: first &lt;code&gt;one&lt;/code&gt;, then &lt;code&gt;two&lt;/code&gt;. If you'd like to try this yourself, you can modify &lt;code&gt;HasDrop&lt;/code&gt; above to contain some data, like an integer, and then use it in the &lt;code&gt;println!&lt;/code&gt; inside of &lt;code&gt;Drop&lt;/code&gt;. This behavior is guaranteed by the language.</source>
          <target state="translated">하지만 두 개의 &lt;code&gt;HasDrop&lt;/code&gt; 중 어느 것이 먼저 떨어질까요? 구조체의 경우 선언 된 순서와 동일합니다 : first &lt;code&gt;one&lt;/code&gt; , then &lt;code&gt;two&lt;/code&gt; . 직접 해보고 싶다면 정수와 같은 일부 데이터를 포함 &lt;code&gt;HasDrop&lt;/code&gt; 위의 HasDrop 을 수정 한 다음 &lt;code&gt;println!&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; 내부 . 이 동작은 언어에 의해 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">하지만 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; , 오류를 제거하기위한 매우 유용합니다 &lt;code&gt;!&lt;/code&gt; 또한 성공을 제거하는 데 사용될 수 있습니다. 우리가 생각한다면 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; &quot;이 함수가 반환 될 때이 오류가 발생한되지 않은 경우,&quot;우리는 매우 직관적 인 아이디어를 얻을로 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 : 함수가 반환하는 경우, 그것은 &lt;em&gt;한&lt;/em&gt; 오류가 발생한.</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">반면 &lt;code&gt;MaybeUninit&lt;/code&gt; 가 있다 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (이 동일한 크기, 정렬을 보장 나타내는 등 ABI &lt;code&gt;T&lt;/code&gt; 이것은 않음) &lt;em&gt;되지&lt;/em&gt; 이전의주의 사항을 변경. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 과 &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 여전히 다른 크기를 가질 수 있으며, &lt;code&gt;T&lt;/code&gt; 유형의 필드를 포함하는 유형 은 해당 필드가 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 경우와 다르게 배치 (및 크기) 될 수 있습니다 . &lt;code&gt;MaybeUninit&lt;/code&gt; 는 공용체 유형이며 공용체의 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 가 불안정합니다 ( &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;추적 문제&lt;/a&gt; 참조 ). 시간이 지남에 따라 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 의 정확한 보증 노동 조합에 대한 은 발전 할 수 있으며 &lt;code&gt;MaybeUninit&lt;/code&gt; 는 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 유지되거나 유지되지 않을 수 있습니다 . 즉, 말했다 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 것입니다 &lt;em&gt;항상&lt;/em&gt; 그와 같은 크기, 정렬 및 ABI가 보장 &lt;code&gt;T&lt;/code&gt; 를 ; &lt;code&gt;MaybeUninit&lt;/code&gt; 이 구현하는 방식 이 보증을 발전시킬 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 는 &lt;code&gt;Hash&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 를 구현 하지만 해시와 순서는 Rust 릴리스마다 다를 수 있습니다. 코드 내부에 의존하는 것에주의하십시오!</target>
        </trans-unit>
        <trans-unit id="6d4c0b858b921a1aa9b09d6f6ffff138728f277d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;mem::forget&lt;/code&gt; can also be used to transfer &lt;em&gt;memory&lt;/em&gt; ownership, doing so is error-prone. &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; should be used instead. Consider, for example, this code:</source>
          <target state="translated">하지만 &lt;code&gt;mem::forget&lt;/code&gt; 또한 전송에 사용할 수있는 &lt;em&gt;메모리&lt;/em&gt; 소유, 이렇게하면 오류가 발생하기 쉬운입니다. 대신 &lt;a href=&quot;struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&lt;/code&gt; &lt;/a&gt; 사용해야합니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">Rust 문자열은 중간에 널 바이트를 포함 할 수 있지만 C 문자열은 문자열을 효과적으로자를 수 없으므로 C 문자열은 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">그러한 문자열을 무손실로 유효한 UTF-16 문자열 (또는 UTF-8)로 변환하는 것이 항상 가능한 것은 아니지만, 이러한 문자열을 Windows API에서 무손실로 왕복 할 수있는 것이 종종 바람직합니다. 예를 들어, 일부 Rust 코드는 &lt;code&gt;WCHAR&lt;/code&gt; 을 전달하여 일부 Windows API를 &quot;브리징&quot;할 수 있습니다. 실제로 문자열을 보지 않고도 해당 API간에 문자열을 .</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">입력을 되돌려주는 함수가 이상하게 보일지 모르지만 흥미로운 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97e4502df2c17c97ddd6625eabaef88cae532a3d" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복하는 동안 환경의 키 또는 값이 유효한 유니 코드가 아니면 반환 된 반복기가 패닉 상태가됩니다. 이것이 바람직하지 않은 경우 &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os()&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">반복하는 동안 환경의 키 또는 값이 유효한 유니 코드가 아닌 경우 반환 된 반복자가 패닉 상태가됩니다. 이것이 바람직하지 않은 경우 &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt; 함수 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">오류 처리를 수행하는 동안 사용자 고유의 오류 유형에 대해 &lt;code&gt;From&lt;/code&gt; 을 구현하는 것이 종종 유용 합니다. 기본 오류 유형을 기본 오류 유형을 캡슐화하는 자체 사용자 정의 오류 유형으로 변환하면 기본 원인에 대한 정보를 잃지 않고 단일 오류 유형을 리턴 할 수 있습니다. '?' 연산자는 &lt;code&gt;From&lt;/code&gt; 을 구현할 때 자동으로 제공되는 &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; 를 호출하여 기본 오류 유형을 사용자 정의 오류 유형으로 자동 변환합니다 . 그런 다음 컴파일러는 사용해야 하는 &lt;code&gt;Into&lt;/code&gt; 구현을 유추 합니다.</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">프리미티브는 컴파일러에 의해 구현되지만 표준 라이브러리는 프리미티브 유형에 직접 메소드를 구현합니다 ( &lt;a href=&quot;#primitives&quot;&gt;프리미티브 섹션에 문서화되어&lt;/a&gt; 있습니다).</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">다음 예제는 소리가 &lt;code&gt;set_len&lt;/code&gt; 호출 전에 내부 벡터가 해제되지 않아 메모리 누수가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c01f6f794efd0c185cdbd0acdeb3770eddfc8772" translate="yes" xml:space="preserve">
          <source>While there could be a more fine-grained scheme in the future that allows mutable references if they are not &quot;leaked&quot; to the final value, a more conservative approach was chosen for now. &lt;code&gt;const fn&lt;/code&gt; do not have this problem, as the borrow checker will prevent the &lt;code&gt;const fn&lt;/code&gt; from returning new mutable references.</source>
          <target state="translated">최종 값으로 &quot;누출&quot;되지 않는 경우 변경 가능한 참조를 허용하는보다 세밀한 계획이 미래에있을 수 있지만 지금은보다 보수적 인 접근 방식이 선택되었습니다. &lt;code&gt;const fn&lt;/code&gt; 에는이 문제가 없습니다. 차용 검사기가 &lt;code&gt;const fn&lt;/code&gt; 이 새로운 변경 가능한 참조를 반환 하는 것을 방지하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">이것들 동안 :</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">이것은 &lt;code&gt;String&lt;/code&gt; 의 길이가 0 임을 의미하지만 용량에 닿지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">이 방법과 변경 가능한 대응 방법은 null 안전에 유용하지만 반환 된 값이 잘못된 메모리를 가리킬 수 있으므로 여전히 안전하지 않은 작업이라는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">이 특성은 불안정하지만 방법은 안정적입니다. &lt;code&gt;SliceConcatExt&lt;/code&gt; 는 &lt;a href=&quot;../prelude/index&quot;&gt;표준 라이브러리 prelude에&lt;/a&gt; 포함되어 있으므로 &lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; 을 마치 &lt;code&gt;[T]&lt;/code&gt; 에있는 것처럼 사용할 수 있습니다 자체 .</target>
        </trans-unit>
        <trans-unit id="3b5f26a246fb02c7cc6b4b29c460a0d1e8dc7640" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the &lt;a href=&quot;../prelude/index&quot;&gt;prelude&lt;/a&gt;'s import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 Rust 스타일은 유형을 직접 가져 오는 것이지만 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 의&lt;/a&gt; 별칭은 유형 을 쉽게 구분하기 위해 그렇지 않은 경우가 많습니다. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 는 일반적으로 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; 간주 되므로이 별칭의 사용자는 일반적으로 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../prelude/index&quot;&gt;전주곡&lt;/a&gt; 가져 오기를 섀도 잉하는 대신 &lt;code&gt;io::Result&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 녹 스타일은 유형을 직접 가져 오는 것이지만 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 별칭은 유형 을 쉽게 구분하기 위해 종종 그렇지 않습니다. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 는 일반적으로 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; 간주 되므로이 별명을 가진 사용자는 일반적으로 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; 의 전주곡 가져 오기를 음영 처리하는 대신 &lt;code&gt;io::Result&lt;/code&gt; 사용합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">그 &lt;code&gt;[-]&lt;/code&gt; 버튼을 보면서 &lt;code&gt;[src]&lt;/code&gt; 버튼도 확인하십시오. Rust의 API 문서는 소스 코드와 함께 제공되며 읽을 것을 권장합니다. 표준 라이브러리 소스는 일반적으로 품질이 높으며 커튼 뒤의 엿보기가 종종 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5bd6985bffedbe45212e5ed4b8d7b10e4e8bfe85" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt;&lt;code&gt;Pattern_White_Space&lt;/code&gt;&lt;/a&gt; Unicode property, namely:</source>
          <target state="translated">공백은 &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt; &lt;code&gt;Pattern_White_Space&lt;/code&gt; &lt;/a&gt; 유니 코드 속성 이있는 문자 만 포함하는 비어 있지 않은 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">공백은 &lt;code&gt;Pattern_White_Space&lt;/code&gt; 유니 코드 속성 이있는 문자 만 포함하는 비어 있지 않은 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">녹의 대상</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">이 책의 대상</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;UnwindSafe&lt;/code&gt; 를 구현하는 사람 ?</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">왜 &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 아닌 &lt;code&gt;filter_map&lt;/code&gt; 인가 입니까? 열쇠는이 부분에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">대출이 필요없는 코드로이 메시지가 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">왜 실행 파일을 원하지 않습니까? 종종 &lt;code&gt;cargo check&lt;/code&gt; 는 실행 파일 생성 단계를 건너 뛰기 때문에 &lt;code&gt;cargo build&lt;/code&gt; 보다 훨씬 빠릅니다 . 코드를 작성하는 동안 지속적으로 작업을 &lt;code&gt;cargo check&lt;/code&gt; 하는 경우 화물 확인 을 사용 하면 프로세스 속도가 빨라집니다! 따라서 많은 Rustaceans 는 프로그램을 작성할 때 정기적으로 &lt;code&gt;cargo check&lt;/code&gt; 실행 하여 컴파일되도록합니다. 그런 다음 실행 파일을 사용할 준비가되면 &lt;code&gt;cargo build&lt;/code&gt; 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">와일드 카드 패턴</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="dd04e2ae06e0c22d6b8a5c4141451a441cf23045" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">항상 동일한 &lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">항상 같은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">각 문자 경계에서 빈 일치 항목을 반환 하여 패턴 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="f2a58ab6d8aaaf56805d5dcc5d08104ca8722e51" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">이 문자열 조각을 원하는 유형으로 구문 분석 할 수없는 경우 &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">&lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 반환합니다이 문자열 슬라이스를 원하는 유형으로 구문 분석 할 수 없으면 합니다.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="17aebcc3873693512f66ff2029c56928afebc898" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows 경로 접두사, 예 &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows 경로 접두어, 예를 들어, &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b25b9078d1c6b5cf7d0c03d87923967058f5d7a" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows는 드라이브 볼륨 (예 &lt;code&gt;C:&lt;/code&gt; :) , 네트워크 공유 폴더 (예 : &lt;code&gt;\\server\share&lt;/code&gt; ) 등에 대한 참조를 포함하여 다양한 경로 접두사 스타일을 사용합니다 . 또한 일부 경로 접두사는 &quot;verbatim&quot;(예 : 접두사 &lt;code&gt;\\?\&lt;/code&gt; )이며,이 경우 &lt;code&gt;/&lt;/code&gt; 는 구분 기호로 처리 &lt;em&gt;되지 않으며&lt;/em&gt; 기본적으로 정규화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows는 드라이브 볼륨 (예 &lt;code&gt;C:&lt;/code&gt; :) , 네트워크 공유 폴더 ( &lt;code&gt;\server\share&lt;/code&gt; 등)에 대한 참조를 포함하여 다양한 경로 접두사 스타일을 사용합니다 . 또한 일부 경로 접두사는 &quot;verbatim&quot;(즉, 접두사 &lt;code&gt;\?\&lt;/code&gt; )이며,이 경우 &lt;code&gt;/&lt;/code&gt; 는 구분 기호로 처리 &lt;em&gt;되지 않으며&lt;/em&gt; 기본적으로 정규화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::fs&lt;/code&gt; 의 기본 요소에 대한 Windows 특정 확장자 모듈 .</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 대한 Windows 별 확장 .</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; 에&lt;/a&gt; 대한 Windows 별 확장 .</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 에&lt;/a&gt; 대한 Windows 특정 확장자 .</target>
        </trans-unit>
        <trans-unit id="8a739bab05e923c90296481bb09cc25239dd40e0" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;fs::File&lt;/code&gt; &lt;/a&gt; 대한 Windows 특정 확장자 .</target>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; 에&lt;/a&gt; 대한 Windows 특정 확장자 .</target>
        </trans-unit>
        <trans-unit id="c379abe31315129f29960307cac5c5a9ebe73ce4" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;fs::FileType&lt;/code&gt; &lt;/a&gt; 대한 Windows 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; 대한 Windows 별 확장 .</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt; 대한 Windows 별 확장 .</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">처리 할 Windows 특정 확장 프로그램 &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6631cb576a83d66476aa6a96c888a47fea46888b" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to general I/O primitives.</source>
          <target state="translated">일반 I / O 프리미티브에 대한 Windows 특정 확장.</target>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">&lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt; 빌더 에 대한 Windows 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::ffi&lt;/code&gt; 모듈 의 프리미티브에 대한 Windows 고유의 확장 입니다.</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">Windows 관련 프리미티브</target>
        </trans-unit>
        <trans-unit id="a29244317dd706a76b2545e981c947b9fe3e3b2c" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives.</source>
          <target state="translated">Windows 관련 기본 요소.</target>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">와 &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;그리고 &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;이 매크로는 개발자에게 소스 내 위치에 대한 디버깅 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">와 &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;그리고 &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;이 매크로는 개발자에게 소스 내 위치에 대한 디버깅 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">와 &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;그리고 &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;이 매크로는 개발자에게 소스 내 위치에 대한 디버깅 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">함께 &lt;code&gt;Infallible&lt;/code&gt; 열거되고,이 코드는 유효합니다. 그러나 &lt;code&gt;Infallible&lt;/code&gt; 이 never 유형의 별칭이되면 두 개의 &lt;code&gt;impl&lt;/code&gt; 이 겹치기 시작하므로 언어의 특성 일관성 규칙에 따라 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">Windows에서 CMD를 사용하면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">Rust의 &lt;code&gt;..&lt;/code&gt; 범위 구문을 사용하면 첫 번째 인덱스 (0)에서 시작하려는 경우 두 기간 전에 값을 삭제할 수 있습니다. 다시 말해, 이들은 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">스레드와 스레드 API에 대한 기본적인 이해를 통해 스레드로 &lt;em&gt;수행&lt;/em&gt; 할 수있는 &lt;em&gt;작업&lt;/em&gt; 을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">메소드 호출로 :</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">경로명으로 :</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">상자, 설명 및 라이센스를 추가 할 때 &lt;code&gt;cargo new&lt;/code&gt; 추가 한 카고 ( &lt;em&gt;cargo.toml)&lt;/em&gt; 파일 은 고유 한 이름, 버전, 작성자 세부 정보를 통해 게시 할 수있는 프로젝트 의 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일이 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">이러한 모든 위험에 대해 왜 원시 포인터를 사용하겠습니까? 다음 섹션 &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;안전하지 않은 함수 또는 메소드 호출&amp;rdquo;&lt;/a&gt; 에서 볼 수 있듯이 C 코드와 인터페이스 할 때 가장 큰 사용 사례입니다 . 또 다른 경우는 빌리 체커가 이해하지 못하는 안전한 추상화를 구축 할 때입니다. 안전하지 않은 기능을 소개하고 안전하지 않은 코드를 사용하는 안전한 추상화의 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">모든 변경 사항이 적용되면 코드가 경고없이 컴파일됩니다. 그러나 나쁜 소식은이 코드가 아직 원하는 방식으로 작동하지 않는다는 것입니다. 핵심은 &lt;code&gt;Worker&lt;/code&gt; 인스턴스 의 스레드에 의해 실행되는 클로저의 논리입니다. 현재 &lt;code&gt;join&lt;/code&gt; 이라고 부르지 만 스레드 는 작업을 영원히 찾기 때문에 &lt;code&gt;loop&lt;/code&gt; 종료하지 않습니다 . 현재 &lt;code&gt;drop&lt;/code&gt; 구현으로 &lt;code&gt;ThreadPool&lt;/code&gt; 을 삭제하려고 하면 주 스레드는 첫 번째 스레드가 끝날 때까지 영원히 대기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">이 모든 다른 종류의 출력에서 ​​크레이트 A가 크레이트 B에 의존하면 컴파일러는 시스템 전체에서 다양한 형태로 B를 찾을 수 있습니다. 그러나 컴파일러가 &lt;code&gt;rlib&lt;/code&gt; 형식 은 rlib 형식과 동적 라이브러리 형식입니다. 종속 라이브러리에 대한이 두 가지 옵션을 사용하면 컴파일러는 어느 시점에서이 두 형식 중에서 선택해야합니다. 이를 염두에두고 컴파일러는 어떤 형식의 종속성을 사용할지 결정할 때 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">이 모든 정보를 염두에두고 슬라이스를 반환하기 위해 &lt;code&gt;first_word&lt;/code&gt; 를 다시 작성 하십시오 . &quot;문자열 슬라이스&quot;를 나타내는 유형은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb10c6677d4a9c4ac3a69e9072ac5b7bbbfc8ab3" translate="yes" xml:space="preserve">
          <source>With an associated type:</source>
          <target state="translated">관련 유형 :</target>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">연관된 유형을 사용하면 유형에 특성을 여러 번 구현할 수 없으므로 유형에 주석을 달 필요가 없습니다. 연관된 유형을 사용하는 정의가있는 Listing 19-12에서는 하나의 &lt;code&gt;impl Iterator for Counter&lt;/code&gt; 만있을 수 있으므로 &lt;code&gt;Item&lt;/code&gt; 유형은 한 번만 선택할 수 있습니다 . 우리는 우리의 반복자 지정할 필요가 없습니다 &lt;code&gt;u32&lt;/code&gt; 우리가 부르는 모든 곳에서 값을 &lt;code&gt;next&lt;/code&gt; 에 &lt;code&gt;Counter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">전역 적으로 액세스 가능한 변경 가능한 데이터를 사용하면 데이터 레이스가 없는지 확인하기가 어렵 기 때문에 Rust는 변경 가능한 정적 변수를 안전하지 않은 것으로 간주합니다. 가능한 경우, 16 장에서 논의한 동시성 기술과 스레드 안전 스마트 포인터를 사용하여 컴파일러가 다른 스레드에서 액세스 한 데이터가 안전하게 수행되는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">반복자에 대한 새로운 지식을 통해 슬라이스를 빌리는 대신 반복자의 소유권을 인수로 사용 하도록 &lt;code&gt;new&lt;/code&gt; 함수를 변경할 수 있습니다 . 슬라이스의 길이를 확인하고 특정 위치로 색인을 생성하는 코드 대신 반복자 기능을 사용합니다. 반복자가 값에 액세스하기 때문에 &lt;code&gt;Config::new&lt;/code&gt; 함수가 수행하는 작업 이 명확 해 집니다.</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">실제 특성으로 인해이 숫자는 급격히 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">참조 및 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하면 차용 규칙의 변형이 컴파일 타임에 시행됩니다. 함께 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 이 불변이 적용된다 &lt;em&gt;런타임에&lt;/em&gt; . 참조를 통해 이러한 규칙을 어기면 컴파일러 오류가 발생합니다. 함께 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 당신이이 규칙을 어기면, 당신의 프로그램은 당황하고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">간단한 프로젝트로 Cargo는 &lt;code&gt;rustc&lt;/code&gt; 만 사용 하는 것 보다 많은 가치를 제공하지는 않지만 프로그램이 복잡해지면 가치가 있음을 입증합니다. 여러 상자로 구성된 복잡한 프로젝트를 사용하면 Cargo가 빌드를 조정하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">stdin으로 :</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">표준 출력으로 :</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형을 사용하면 변경 가능하고 확장 가능한 텍스트 조각을 지원하려면 컴파일 타임에 알 수없는 힙에 메모리를 할당하여 내용을 보유해야합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">위의 사양을 사용하여 특정 매 처가 합법적이며 다른 매 커가 합법적이지 않은 이유에 대한 주장을 제시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">클로저가 정의 된 &lt;code&gt;if&lt;/code&gt; 코드를 실행하고 결과 값을 얻기 위해 클로저를 호출하도록 if 블록 의 코드를 변경할 수 있습니다 . 함수를 수행하는 것처럼 클로저를 호출합니다. 목록 13-6에 표시된 것처럼 클로저 정의를 보유한 변수 이름을 지정하고 사용하려는 인수 값이 포함 된 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">이 트릭을 구현하면 스레드 풀이 작동 상태에 있습니다! 그것에게 부여 &lt;code&gt;cargo run&lt;/code&gt; 하고 몇 가지 요청을 :</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">항목 개념이 공개 또는 개인이라는 개념으로 Rust는 두 가지 경우에 항목 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">나머지 프로그램 로직을 &lt;code&gt;run&lt;/code&gt; 기능 으로 분리하면 Listing 12-9의 &lt;code&gt;Config::new&lt;/code&gt; 에서 와 같이 오류 처리 기능을 향상시킬 수있다 . 대신 프로그램이 호출하여 당황 할 수의 &lt;code&gt;expect&lt;/code&gt; 는 &lt;code&gt;run&lt;/code&gt; 함수가 반환 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 뭔가 잘못되면. 이를 통해 사용자에게 친숙한 방식으로 오류 처리에 대한 논리 를 &lt;code&gt;main&lt;/code&gt; 으로 더욱 통합 할 수 있습니다. Listing 12-12는 시그니처와 &lt;code&gt;run&lt;/code&gt; 본문에 필요한 변경 사항을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">주 패턴으로, &lt;code&gt;Post&lt;/code&gt; 우리가 사용하는 방법과 장소 &lt;code&gt;Post&lt;/code&gt; 필요하지 않습니다 &lt;code&gt;match&lt;/code&gt; 표현을하고, 새로운 상태를 추가, 우리는 하나의 구조체의 특성 방법을 새로운 구조체를 추가하고 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">텍스트가 제자리에 &lt;em&gt;있으면 src / main.rs를&lt;/em&gt; 편집 하고 코드를 추가하여 파일을 읽습니다 (목록 12-4 참조).</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">두 특성의 경계가 지정된으로의 몸 &lt;code&gt;notify&lt;/code&gt; 호출 할 수 있습니다 &lt;code&gt;summarize&lt;/code&gt; 및 사용 &lt;code&gt;{}&lt;/code&gt; 형식으로 &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">이러한 변경으로 코드를 실행하고 요청하겠습니다. 더 이상 터미널에 데이터를 인쇄하지 않으므로 Cargo의 출력 이외의 출력은 표시되지 않습니다. 웹 브라우저에서 &lt;em&gt;127.0.0.1:7878&lt;/em&gt; 을로드 하면 오류 대신 빈 페이지가 나타납니다. 방금 HTTP 요청 및 응답을 직접 코딩했습니다!</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">이러한 변경으로 서버를 다시 실행하십시오. &lt;em&gt;127.0.0.1:7878&lt;/em&gt; 을 요청 하면 &lt;em&gt;hello.html&lt;/em&gt; 의 내용이 반환되고 &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt; 와 같은 다른 요청 은 &lt;em&gt;404.html&lt;/em&gt; 의 오류 HTML을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">이러한 변경으로 코드가 컴파일됩니다! 우리는 거기에 도착하고있다!</target>
        </trans-unit>
        <trans-unit id="64e9859cf60a37b6fd6185bea427eb35dd3442b4" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-20. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-24.</source>
          <target state="translated">이러한 변경으로 코드는 컴파일되고 Listing 20-20 이후와 동일한 방식으로 계속 작동합니다. 그러나 &lt;code&gt;Terminate&lt;/code&gt; 품종의 메시지를 생성하지 않기 때문에 경고가 표시 됩니다. &lt;code&gt;Drop&lt;/code&gt; 구현을 목록 20-24와 같이 변경하여이 경고를 수정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">이러한 변경으로 코드는 Listing 20-21 이후와 동일한 방식으로 컴파일되고 계속 작동합니다. 그러나 &lt;code&gt;Terminate&lt;/code&gt; 품종의 메시지를 작성하지 않으므로 경고가 표시 됩니다. &lt;code&gt;Drop&lt;/code&gt; 구현을 Listing 20-25와 같이 변경하여이 경고를 수정하자 .</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 에 추가 된 몇 줄의 코드를 사용 하여 인수없이 프로그램을 다시 실행하여 오류가 어떻게 나타나는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">이 추가 된 &lt;code&gt;content&lt;/code&gt; 메소드를 사용하면 Listing 17-11의 7 행까지 모든 것이 의도 한대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">이 방법을 사용하면 x와 y는 &lt;code&gt;Rc&lt;/code&gt; (참조 카운트 유형) 를 통해 데이터의 소유권을 공유 합니다. &lt;code&gt;RefCell&lt;/code&gt; 은 기본적으로 런타임 차용 ​​확인을 수행합니다. 최대 한 명의 작성자 또는 여러 명의 독자가 한 번에 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">반복자에 대한이 새로운 지식으로 반복자를 사용하여 코드의 위치를보다 명확하고 간결하게하여 12 장의 I / O 프로젝트를 개선 할 수 있습니다. 반복자가 &lt;code&gt;Config::new&lt;/code&gt; 함수 및 &lt;code&gt;search&lt;/code&gt; 함수 의 구현을 개선하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">이것으로 :</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">타입 어노테이션이 추가되면 클로저 구문은 함수 구문과 비슷해 보입니다. 다음은 매개 변수에 1을 추가하는 함수와 동일한 동작을 갖는 클로저에 대한 정의 구문에 대한 수직 비교입니다. 관련 부품을 정렬 할 공간을 추가했습니다. 다음은 파이프 사용 및 선택적 구문의 양을 제외하고 클로저 구문이 함수 구문과 유사한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">많은 부분이있는 값으로, &lt;code&gt;..&lt;/code&gt; 구문을 사용하여 일부 부분 만 사용하고 나머지는 무시하고 무시 된 각 값에 밑줄을 표시 할 필요가 없습니다. &lt;code&gt;..&lt;/code&gt; 패턴은 우리가 명시 적으로 패턴의 나머지 부분에서 일치하지 않는 것을 값의 어떤 부분을 무시합니다. Listing 18-23 에는 3 차원 공간에서 좌표를 유지하는 &lt;code&gt;Point&lt;/code&gt; 구조체가있다. 에서 &lt;code&gt;match&lt;/code&gt; 식 우리 만에 작동 할 &lt;code&gt;x&lt;/code&gt; 좌표와의 값을 무시하고 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="3392b1d08169948bc18f560cc78f42601ac7de77" translate="yes" xml:space="preserve">
          <source>Within a type definition:</source>
          <target state="translated">유형 정의 내에서 :</target>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 블록 안에는 호출하려는 다른 언어의 외부 함수 이름과 서명이 나열되어 있습니다. &lt;code&gt;&quot;C&quot;&lt;/code&gt; 부분을 정의하는 &lt;em&gt;애플리케이션 바이너리 인터페이스 (ABI)&lt;/em&gt; 외부 기능 용도 다음 ABI는 어셈블리 레벨에서의 기능을 호출하는 방법을 정의한다. &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI는 가장 일반적이고 언어의 ABI 프로그래밍은 C를 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">유형 매개 변수 선언이있는 항목의 본문에서 유형 매개 변수의 이름은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">이 문서의 문법 내에서 &quot;간단한&quot;토큰은 &lt;a href=&quot;notation#string-table-productions&quot;&gt;문자열 테이블 생산&lt;/a&gt; 형태로 제공되며 &lt;code&gt;monospace&lt;/code&gt; 글꼴로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">없이 &lt;code&gt;compiler_fence&lt;/code&gt; 의 &lt;code&gt;assert_eq!&lt;/code&gt; 다음 코드 에서는 단일 스레드에서 발생하는 모든 작업에도 불구하고 성공 &lt;em&gt;하지 않을&lt;/em&gt; 수 있습니다. 이유를 확인하려면 컴파일러가 &lt;code&gt;Ordering::Relaxed&lt;/code&gt; 모두이므로 상점을 &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; 및 &lt;code&gt;IS_READ&lt;/code&gt; 로 자유롭게 교체 할 수 있습니다 . 이 경우 &lt;code&gt;IS_READY&lt;/code&gt; 가 업데이트 된 직후에 신호 처리기가 호출 되면 신호 처리기는 &lt;code&gt;IS_READY=1&lt;/code&gt; 이지만 &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; 이 표시 됩니다. &lt;code&gt;compiler_fence&lt;/code&gt; 를 사용하면 이 상황이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="6823be3ffd83b17bd9d63c393e81d5a41ffc52cc" translate="yes" xml:space="preserve">
          <source>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; only in loops. Example:</source>
          <target state="translated">중단하거나 계속할 루프가 없으면 현명한 조치를 취할 수 없습니다. &lt;code&gt;break&lt;/code&gt; 를 사용 하고 있는지 확인하고 루프에서만 &lt;code&gt;continue&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">경로명이없는 경우 :</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">&lt;code&gt;Deref&lt;/code&gt; 특성이 없으면 컴파일러는 역 참조 &lt;code&gt;&amp;amp;&lt;/code&gt; 참조 만 할 수 있습니다 . &lt;code&gt;deref&lt;/code&gt; 방법은 컴파일러에게 어떤 종류의 그 구현의 값을 취할 수있는 능력을 제공 &lt;code&gt;Deref&lt;/code&gt; 및 전화 &lt;code&gt;deref&lt;/code&gt; 얻을 방법 &lt;code&gt;&amp;amp;&lt;/code&gt; 역 참조를 어떻게 알고 참조.</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">환경 변수 작업</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">Rust에서 raw 포인터로 작업하는 것은 일반적이지 않으며 일반적으로 몇 가지 패턴으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9a40e384f7f263637185bd19da70cd3d69e259e7" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers can be unaligned or &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. However, when a raw pointer is dereferenced (using the &lt;code&gt;*&lt;/code&gt; operator), it must be non-null and aligned.</source>
          <target state="translated">Rust에서 원시 포인터로 작업하는 것은 흔하지 않으며 일반적으로 몇 가지 패턴으로 제한됩니다. 원시 포인터는 정렬되지 않거나 &lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 . 그러나 원시 포인터가 역 참조되면 ( &lt;code&gt;*&lt;/code&gt; 연산자 사용) 널이 아니고 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">와우, 그 오류 메시지는 매우 장황하다! 여기에 중점을 두어야 할 중요한 부분이 있습니다. 첫 번째 인라인 오류는 &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; . 그 이유는 다음에 중점을 두어야 할 오류 메시지입니다. 증류 오류 메시지는 &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; 말합니다 . 다음 섹션에서 &lt;code&gt;Send&lt;/code&gt; 에 대해 이야기하겠습니다 : 스레드와 함께 사용하는 유형이 동시 상황에서 사용되도록 보장하는 특성 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="71aebd97d81f1f2a97e5f18bfd8c471204fa376d" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here&amp;rsquo;s the important part to focus on: &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The compiler is also telling us the reason why: &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">와, 그 오류 메시지는 매우 장황합니다! 집중해야 할 중요한 부분은 다음과 같습니다 &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; . 컴파일러는 또한 그 이유를 알려줍니다 &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt; . 다음 섹션에서 &lt;code&gt;Send&lt;/code&gt; 에 대해 이야기 할 것입니다 . 이것은 스레드와 함께 사용하는 유형이 동시 상황에서 사용되도록 보장하는 특성 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">수동으로 놓을 값을 줄 바꿈하십시오.</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">복합 결과를 구성하려면 OK 값을 줄 바꿈하십시오. 예를 들어 &lt;code&gt;Result::Ok(x)&lt;/code&gt; 및 &lt;code&gt;Result::from_ok(x)&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">복합 결과를 구성하려면 OK 값을 줄 바꿈하십시오. 예를 들어 &lt;code&gt;Result::Ok(x)&lt;/code&gt; 및 &lt;code&gt;Result::from_ok(x)&lt;/code&gt; 는 동일합니다. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">합성 결과를 구성하려면 오류 값을 줄 바꿈하십시오. 예를 들어 &lt;code&gt;Result::Err(x)&lt;/code&gt; 및 &lt;code&gt;Result::from_error(x)&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">합성 결과를 구성하려면 오류 값을 줄 바꿈하십시오. 예를 들어 &lt;code&gt;Result::Err(x)&lt;/code&gt; 및 &lt;code&gt;Result::from_error(x)&lt;/code&gt; 는 동일합니다. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 절대 값. &lt;code&gt;self.abs()&lt;/code&gt; 계산 하여 유형의 경계를 감싸줍니다.</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 추가. &lt;code&gt;self + rhs&lt;/code&gt; 계산 하여 유형의 경계를 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 부문. 유형의 경계를 감싸면서 &lt;code&gt;self / rhs&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">랩핑 (모듈 식) 부문. &lt;code&gt;self / rhs&lt;/code&gt; 계산합니다 . 부호없는 유형의 랩핑 된 분할은 정상적인 분할입니다. 랩핑이 발생할 수있는 방법은 없습니다. 이 기능이 존재하므로 모든 조작이 랩핑 조작에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 지수. &lt;code&gt;self.pow(exp)&lt;/code&gt; 계산 하여 유형의 경계를 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 곱셈. &lt;code&gt;self * rhs&lt;/code&gt; 계산 하여 유형의 경계를 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 부정. 유형의 경계를 감싸면서 &lt;code&gt;-self&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 나머지. 유형의 경계에서 감싸는 &lt;code&gt;self % rhs&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">랩핑 (모듈 식) 나머지. &lt;code&gt;self % rhs&lt;/code&gt; 계산합니다 . 부호없는 유형의 랩핑 된 나머지 계산은 일반적인 나머지 계산입니다. 랩핑이 발생할 수있는 방법은 없습니다. 이 기능이 존재하므로 모든 조작이 랩핑 조작에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">랩핑 (모듈 식) 빼기. 유형의 경계를 감싸면서 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">유클리드 사업부 포장. 유형의 경계를 감싸는 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">유클리드 사업부 포장. &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; 계산합니다 . 부호없는 유형의 랩핑 된 분할은 정상적인 분할입니다. 랩핑이 발생할 수있는 방법은 없습니다. 이 기능이 존재하므로 모든 조작이 랩핑 조작에서 설명됩니다. 양의 정수의 경우 나누기의 모든 공통 정의가 같으 &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; 와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">유클리드 모듈로 포장. &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 계산합니다 . 부호없는 유형에 대한 랩핑 된 모듈로 계산은 일반적인 나머지 계산입니다. 랩핑이 발생할 수있는 방법은 없습니다. 이 기능이 존재하므로 모든 조작이 랩핑 조작에서 설명됩니다. 양의 정수의 경우 나누기의 모든 공통 정의가 같으 &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; 와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">유클리드 나머지 포장. &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 계산 하여 유형의 경계를 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">랩핑 산술은 &lt;code&gt;wrapping_add&lt;/code&gt; 와 같은 메소드를 통해 또는 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; 유형을 통해 달성 될 수 있습니다 . 이는 기본 값에 대한 모든 표준 산술 연산이 랩핑 시맨틱을 갖도록 의도되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">전체 클로저를 감싸는 것은 캡처 된 모든 변수가 안전하지 않다는 담요 주장에 해당합니다. 향후 새로운 캡처가 추가 될 경우 안전하지 않은 것으로 간주 될 수 있다는 단점이 있습니다. 따라서 아래와 같이 개별 캡처 만 래핑하는 것이 좋습니다. 이것은 주석이지만, 안전하지 않은 새 캡처가 추가되면 그 시점에 컴파일 오류가 발생하여 새 캡처가 실제로 버그를 나타내는 지 여부를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">랩핑은 부호있는 유형의 &lt;code&gt;MIN % -1&lt;/code&gt; 에서만 발생 합니다 (여기서 &lt;code&gt;MIN&lt;/code&gt; 은 유형 의 음의 최소값 입니다). 이 경우이 메서드는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">랩핑은 부호있는 유형의 &lt;code&gt;MIN / -1&lt;/code&gt; 에서만 발생 합니다 (여기서 &lt;code&gt;MIN&lt;/code&gt; 은 유형 의 음의 최소값 입니다). 이는 유형으로 표현하기에 너무 큰 양수 값인 &lt;code&gt;-MIN&lt;/code&gt; 과 같습니다 . 이 경우이 메서드는 &lt;code&gt;MIN&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
