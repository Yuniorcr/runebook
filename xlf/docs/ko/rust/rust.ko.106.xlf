<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 참조 안전 코드에 출시 될 수 있으며이 공존 할 수있는 다른과 &lt;code&gt;&amp;amp;T&lt;/code&gt; 아니지만과, 참고 문헌 &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut T&lt;/code&gt; 기준은 어느 다른 제공된 안전한 코드로 방출 될 수있다 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 나 &lt;code&gt;&amp;amp;T&lt;/code&gt; 그것과 공존. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 항상 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 몇 바이트에 대한 포인터와 길이 : 두 가지 구성 요소로 구성되어 있습니다. &lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 몇 바이트에 대한 포인터와 길이 : 두 가지 구성 요소로 구성되어 있습니다. &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 이를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">&lt;code&gt;BarrierWaitResult&lt;/code&gt; 은 에 의해 반환되는 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;Barrier::wait()&lt;/code&gt; &lt;/a&gt; 의 모든 스레드 때 &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt; 랑데부했다.</target>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">&lt;code&gt;BarrierWaitResult&lt;/code&gt; 은 에 의해 반환되는 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 의 모든 스레드 때 &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt; 랑데부했다.</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">&lt;code&gt;BufRead&lt;/code&gt; 은 의 유형입니다 &lt;code&gt;Read&lt;/code&gt; 는 읽기의 추가 방법을 수행 할 수 있도록, 내부 버퍼를 가지고 어.</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">&lt;code&gt;BuildHasher&lt;/code&gt; 는 일반적으로 (기준, 예를 들어 사용 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 만들) &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 때문에, 그들은 서로 독립적으로 해싱하는 각 키에 대한 예들 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 들 상태를 포함한다.</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 을은 바이트 슬라이스 또는 바이트 벡터, 또는 아무것도 중 하나에서 생성되는 구현 &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (예를 들어, 당신이 만들 수 &lt;code&gt;CString&lt;/code&gt; 을을 똑바로 밖으로의 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 모두 그 특성을 구현하기 때문에,).</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 을은 바이트 슬라이스 또는 바이트 벡터, 또는 아무것도 중 하나에서 생성되는 구현 &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (예를 들어, 당신이 만들 수 &lt;code&gt;CString&lt;/code&gt; 을을 똑바로 밖으로의 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 모두 그 특성을 구현하기 때문에,).</target>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 대략 경로 분리기 (문자열 사이에 상당 &lt;code&gt;/&lt;/code&gt; OR).</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 대략 경로 분리기 사이에 해당하는 문자열 ( &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">&lt;code&gt;Cursor&lt;/code&gt; 메모리 내 버퍼 랩과 함께 제공 &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 구현.</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 유형은 일반적으로 시스템 시간 제한에 사용되는 시간의 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Formatter&lt;/code&gt; 포맷과 관련된 다양한 옵션을 의미합니다. 사용자는 &lt;code&gt;Formatter&lt;/code&gt; 를 직접 구성하지 않습니다 . 하나에 대한 변경 가능한 참조는 &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 와 같은 모든 형식화 특성 의 &lt;code&gt;fmt&lt;/code&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">고정 요소 목록이 있는 &lt;code&gt;HashMap&lt;/code&gt; 은 배열에서 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 요소 고정리스트가 배열에서 초기화 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">&lt;code&gt;JoinHandle&lt;/code&gt; 는&lt;em&gt;분리&lt;/em&gt; 가 더 이상 스레드 어떤 핸들 할 수있는 방법이 있다고하는 수단 제거 될 때 관련 스레드 &lt;code&gt;join&lt;/code&gt; 거기에있다.</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LocalKey&lt;/code&gt; 의 초기화는 재귀 자체에 의존하지 수 있으며, 사용 &lt;code&gt;LocalKey&lt;/code&gt; 을 이런 식으로하는 최초의 호출에 무한 같이 Recurse에 초기화 원인이됩니다 &lt;code&gt;with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">&lt;code&gt;Match&lt;/code&gt; 결과 그러나, 전체 매칭 패턴을 포함 할 필요가 &lt;code&gt;Reject&lt;/code&gt; 결과는 임의의 다수의 인접한 조각으로 분할 될 수있다. 두 범위 모두 길이가 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 표현하는 형태가 구현에 검색하는 문자열 패턴으로서 사용될 수 &lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 표현하는 형태가 구현에 검색하는 문자열 패턴으로서 사용될 수 &lt;code&gt;&amp;amp;'a str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">&lt;code&gt;RawWaker&lt;/code&gt; 는 만들기 위해 작업 실행의 구현을 허용 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 사용자 정의 웨이크 업 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 단지의 내용처럼, 크기가 증가 할 수 있으며 그 내용을 변경할 수 있습니다 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , 당신은 더 많은 데이터를 밀어 경우에. 또한 &lt;code&gt;+&lt;/code&gt; 연산자 또는 &lt;code&gt;format!&lt;/code&gt; 편리하게 사용할 수 있습니다 ! &lt;code&gt;String&lt;/code&gt; 값 을 연결하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 이상 래퍼입니다 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; . Listing 8-14에서 올바르게 인코딩 된 UTF-8 예제 문자열 중 일부를 살펴 보자. 첫째, 이것은 :</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 일부 바이트 길이 및 용량에 대한 포인터 : 세 가지 구성 요소로 구성되어 있습니다. 포인터 는 &lt;code&gt;String&lt;/code&gt; 이 데이터를 저장하는 데 사용 하는 내부 버퍼를 가리 킵니다 . 길이는 현재 버퍼에 저장된 바이트 수이고 용량은 버퍼 크기 (바이트)입니다. 따라서 길이는 항상 용량보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">&lt;code&gt;SystemTimeError&lt;/code&gt; 는 로부터 반환 &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;SystemTime::duration_since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;SystemTime::elapsed&lt;/code&gt; &lt;/a&gt; 번째 시스템보다 시간이 시간 이후 지점을 나타내는 방법마다 &lt;code&gt;self&lt;/code&gt; 메소드 호출한다.</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">&lt;code&gt;SystemTimeError&lt;/code&gt; 는 로부터 반환 &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; 번째 시스템보다 시간이 시간 이후 지점을 나타내고마다 &lt;code&gt;self&lt;/code&gt; 메소드 호출한다.</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ThreadId&lt;/code&gt; 는 하나를 생성 스레드마다 고유 한 값을 갖는 불투명 한 객체이다. &lt;code&gt;ThreadId&lt;/code&gt; 는 스레드의 시스템 지정 식별자에 해당하는 것은 아닙니다. &lt;code&gt;ThreadId&lt;/code&gt; 는 으로부터 검색 할 수있는 &lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; A의 방법 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 현재에있는 돌리다 유형에만 사용할 수 있습니다 &lt;code&gt;'static&lt;/code&gt; 하지만,이 제한은 미래에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 유형에 대한 글로벌 고유 식별자를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 변경할 수 있습니다. 반면에 슬라이스는 읽기 전용 개체입니다. &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 를 얻으려면 &lt;a href=&quot;../primitive.reference&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 변경할 수 있습니다. 반면에 슬라이스는 읽기 전용 개체입니다. 슬라이스를 얻으려면 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">&lt;code&gt;Waker&lt;/code&gt; 은 그것을 실행할 준비가되었음을 그 집행을 통지하여 작업을 깨어위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터에 의해 관리 된 배치에 대한 임시 기준 유지에 유용 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 삭제하는 것을 그 내부 값을 예방하지. 상호 소유 참조는 두 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 중 어느 쪽 도 드롭 되지 않도록 허용하므로 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는데도 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로의 강한 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터와 자식에서 부모로 돌아가는 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터에 의해 관리 된 배치에 대한 임시 기준 유지에 유용 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를을&lt;/a&gt; 삭제하는 것을 그 내부 값을 예방하지. 또한 상호 소유 참조는 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 가 삭제되는 것을 허용하지 않으므로 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 간의 순환 참조를 방지하는데도 사용됩니다 . 예를 들어, 트리는 부모 노드에서 자식으로의 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터와 자식에서 부모로 돌아가는 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 수명을 연장하지 않고. 또한 상호 소유하는 참조는 어느 한 쪽의 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 도 삭제할 수 없으므로 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를가&lt;/a&gt; 수명 연장없이. 또한 상호 소유 참조가 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 를 삭제할 수 없기 때문에 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데에도 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 표현은 일반적으로 내측과 연관된 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 루프가 클로징 &lt;code&gt;break&lt;/code&gt; 발현하지만 &lt;a href=&quot;#loop-labels&quot;&gt;라벨&lt;/a&gt; 영향을 둘러싸고있는 루프를 지정하기 위해 사용될 수있다. 예:</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 표현은 일반적으로 내측과 연관된 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 루프가 클로징 &lt;code&gt;break&lt;/code&gt; 발현하지만 &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;라벨&lt;/a&gt; 영향을 둘러싸고있는 루프를 지정하기 위해 사용될 수있다. 예:</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 발현은 루프 본체에서 허용하고, 폼의 한 갖는다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; 또는 ( &lt;a href=&quot;#break-and-loop-values&quot;&gt;아래 참조&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 발현은 루프 본체에서 허용하고, 폼의 한 갖는다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; 또는 ( &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;아래 참조&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">인수가 있는 &lt;code&gt;break&lt;/code&gt; 문은 비 &lt;code&gt;loop&lt;/code&gt; 루프에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 레이블이없는 문은 레이블 블록 내부 나타났다.</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; 하는 그것이 있다는 것을 의미, &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 하지만, 특정 범위 내에서 유일한 사람. &lt;code&gt;MAX&lt;/code&gt; 는 유효한 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value 인&lt;/a&gt; 가장 높은 유효한 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 변경해서는 안 상수 값을 나타냅니다. 상수에 대한 &lt;code&gt;&amp;amp;&lt;/code&gt; 참조를 취하면 값을 포함하는 일부 메모리 위치에 대한 포인터를 가져옵니다. 일반적으로 이것은 완벽하게 좋습니다 : 대부분의 값은 공유 &lt;code&gt;&amp;amp;&lt;/code&gt; 포인터 를 통해 변경할 수 없지만 내부 변경은 허용합니다. 즉, 상수 값이 변경 될 수 있습니다. 반면에 &lt;code&gt;static&lt;/code&gt; 은 명시 적으로 단일 메모리 위치이며 마음대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 표현식의 구현에 의해 제공되는 요소를 반복하는 구문 론적 구조 인 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . 반복자가 값을 생성하면 해당 값에 지정된 이름이 지정되고 루프 본문이 실행 된 후 제어가 &lt;code&gt;for&lt;/code&gt; 루프 의 헤드로 돌아갑니다 . 반복자가 비어 있으면 &lt;code&gt;for&lt;/code&gt; 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 표현식의 구현에 의해 제공되는 요소를 반복하는 구문 론적 구조 인 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . 반복기가 값을 산출하면 해당 값이 반박 할 수없는 패턴과 일치하고 루프 본문이 실행 된 다음 제어가 &lt;code&gt;for&lt;/code&gt; 루프 의 헤드로 돌아갑니다 . 반복기가 비어 있으면 &lt;code&gt;for&lt;/code&gt; 식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 팽창 같이 :</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 표현은 지속적으로 신체의 실행을 반복 : &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 관련이없는 표현 &lt;code&gt;break&lt;/code&gt; 표현 분기와 종류를 가지고있다 &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;. &lt;code&gt;loop&lt;/code&gt; 연관된 함유 식 &lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식 (들)을&lt;/a&gt; 종료 할 수 있으며,의 값에 대응 한 입력해야 &lt;code&gt;break&lt;/code&gt; 식 (S).</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 관련이없는 표현 &lt;code&gt;break&lt;/code&gt; 표현 분기와 종류를 가지고있다 &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;loop&lt;/code&gt; 연관된 함유 식 &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식 (들)을&lt;/a&gt; 종료 할 수 있으며,의 값에 대응 한 입력해야 &lt;code&gt;break&lt;/code&gt; 식 (S).</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 동작합니다 다르게 scrutinee 표현이 있는지 여부에 따라 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 발현 또는 값 표현&lt;/a&gt; . scrutinee 표현식이 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt; 인 경우 먼저 임시 위치로 평가되고 결과 값은 일치하는 것을 찾을 때까지 팔의 패턴과 순차적으로 비교됩니다. 일치하는 패턴이있는 첫 번째 팔이 &lt;code&gt;match&lt;/code&gt; 의 분기 대상으로 선택되고 패턴에 의해 바인딩 된 모든 변수가 팔 블록의 로컬 변수에 할당되고 제어가 블록으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현으로 구성되어 &lt;em&gt;팔&lt;/em&gt; . 팔은 &lt;em&gt;패턴&lt;/em&gt; 과 &lt;code&gt;match&lt;/code&gt; 표현식 의 시작 부분에 제공된 값이 해당 팔의 패턴에 맞는 경우 실행해야하는 코드 로 구성됩니다 . Rust는 주어진 값을 &lt;code&gt;match&lt;/code&gt; 각 팔의 패턴을 차례로 살펴 봅니다. &lt;code&gt;match&lt;/code&gt; 구조와 패턴을 사용하면 코드가 발생하고 당신이 그들 모두를 처리 할 것을 만들 수있는 다양한 상황을 표현하자 녹 강력한 기능입니다. 이러한 기능에 대해서는 6 장과 18 장에 각각 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 타입은 다른 호환 표현 힌트로 주석했다.</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 표시 기능의 실행 경로의 끝 :</target>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , 또는 &lt;code&gt;union&lt;/code&gt; 현재 상자에 정의 하였다. 이는 적용된 형식 인수의 영향을받지 않습니다. &lt;code&gt;struct Foo&lt;/code&gt; 는 로컬로 간주되지만 &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; 은 로컬입니다. 유형 별칭은 지역에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;타입&lt;/em&gt; 착신 다른 종류의 이종 제품 &lt;em&gt;필드&lt;/em&gt; 유형. &lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;타입&lt;/em&gt; 착신 다른 종류의 이종 제품 &lt;em&gt;필드&lt;/em&gt; 유형. &lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 데이터 유형을 구현할 수있는 인터페이스와 같다. 유형이 특성을 구현할 때 제네릭 또는 특성 개체를 사용하여 해당 특성으로 추상적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 현재 상자에 정의 하였다. 특성 정의는 지역적이거나 적용된 유형 인수와 독립적이지 않습니다. 주어 &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt; , &lt;code&gt;Foo&lt;/code&gt; 에 관계없이 대체 유형에 항상 로컬 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 소멸자 필드를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; A와 유사하다 &lt;code&gt;struct&lt;/code&gt; 하지만, 단 하나의 선언 된 필드는 한 번에 특정 인스턴스에 사용됩니다. 공용체는 주로 C 코드에서 공용체와 인터페이스하는 데 사용됩니다. 통합 필드에 액세스하는 것은 Rust가 현재 통합 인스턴스에 저장되고있는 데이터의 유형을 보장 할 수 없기 때문에 안전하지 않습니다. &lt;a href=&quot;../reference/items/unions&quot;&gt;참조&lt;/a&gt; 에서 공용체에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 유사한 외모 &lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 선언의 측면에서,하지만 모든 필드는 서로 겹쳐, 같은 메모리에 존재한다. 예를 들어 우리가 때때로 &lt;code&gt;u32&lt;/code&gt; 로 해석 하고 때로는 &lt;code&gt;f32&lt;/code&gt; 로 해석하는 메모리에 비트를 원한다면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 소멸자 필드로 선언했다.</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프가에 해당 &lt;code&gt;loop&lt;/code&gt; 포함하는 발현 &lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 식을&lt;/a&gt; 다음과 같이.</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프는 의미 상 유사하다 &lt;code&gt;while&lt;/code&gt; 루프는 조건식 대신는 키워드가 예상되지만 &lt;code&gt;let&lt;/code&gt; 패턴, 다음 &lt;code&gt;=&lt;/code&gt; 하는 &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 발현 및 블록 식. scrutinee의 값이 패턴과 일치하면 루프 본문 블록이 실행 된 다음 제어가 패턴 일치 명령문으로 돌아갑니다. 그렇지 않으면 while 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 표현은 조건 루프에 사용됩니다. &lt;code&gt;while&lt;/code&gt; 표현 루프 본문을 실행하기 전에 조건식을 실행 한 후 조건식 평가되는 경우에 루프 본문을 실행하는 &lt;code&gt;true&lt;/code&gt; 또는 기타 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 부울 루프 조건식을 평가하여 시작합니다. 루프 조건식이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 루프 본문 블록이 실행 된 다음 제어가 루프 조건식으로 돌아갑니다. 에 루프 조건식 평가되면 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;while&lt;/code&gt; 표현이 완료.</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 절은에 사용 된 &lt;code&gt;async&lt;/code&gt; 상황.</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24 비트 코드 포인트 탈출&lt;/em&gt; 로 시작 &lt;code&gt;U+0075&lt;/code&gt; ( &lt;code&gt;u&lt;/code&gt; ) 및 여섯까지 이어진다 &lt;em&gt;16 진수&lt;/em&gt; 중괄호 &lt;code&gt;U+007B&lt;/code&gt; ( &lt;code&gt;{&lt;/code&gt; ) 및 &lt;code&gt;U+007D&lt;/code&gt; ( &lt;code&gt;}&lt;/code&gt; ). 제공된 16 진수 값과 동일한 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7 비트 코드 포인트 탈출&lt;/em&gt; 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; 로 값쪽으로 &lt;code&gt;0x7F&lt;/code&gt; 의 . 제공된 16 진 값과 동일한 값을 갖는 ASCII 문자를 나타냅니다. 유니 코드 코드 포인트 또는 바이트 값을 의미하는지 여부가 모호하므로 더 큰 값은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">A는 &lt;em&gt; &lt;code&gt;let&lt;/code&gt; 문&lt;/em&gt; 을 소개합니다에게의 새로운 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; a로 주어진 &lt;a href=&quot;patterns&quot;&gt;패턴을&lt;/a&gt; . 패턴 다음에는 선택적으로 형식 주석이 있고 초기화식이 있습니다. 형식 주석이 제공되지 않으면 컴파일러는 형식을 유추하거나 불충분 한 형식 정보가 명확한 추론에 사용 가능한 경우 오류를 알립니다. 변수 선언에 의해 도입 된 모든 변수는 선언 지점에서 둘러싸는 블록 범위의 끝까지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">A는 &lt;em&gt; &lt;code&gt;let&lt;/code&gt; 문&lt;/em&gt; 을 소개합니다에게의 새로운 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 반박 할 수없는 의해 주어진 &lt;a href=&quot;patterns&quot;&gt;패턴&lt;/a&gt; . 패턴 뒤에는 선택적으로 유형 어노테이션이오고 선택적으로 이니셜 라이저 표현식이옵니다. 유형 주석이 제공되지 않으면 컴파일러는 유형을 추론하거나 명확한 추론에 사용할 수있는 유형 정보가 충분하지 않은 경우 오류 신호를 보냅니다. 변수 선언에 의해 도입 된 모든 변수는 선언 지점에서 둘러싸는 블록 범위가 끝날 때까지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 발현&lt;/em&gt; 패턴에 분기합니다. 일치하는 정확한 형태는 &lt;a href=&quot;../patterns&quot;&gt;패턴에&lt;/a&gt; 따라 다릅니다 . &lt;code&gt;match&lt;/code&gt; 표현식은이 &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 표현&lt;/em&gt; , 패턴을 비교하는 값입니다. 스크 루틴 표현과 패턴은 같은 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;이진 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;0b&lt;/code&gt; ) 및 이진수 및 밑줄 (적어도 한 디지트를 가진) 임의의 혼합물로 계속된다.</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;블록 식&lt;/em&gt; 또는 &lt;em&gt;블록&lt;/em&gt; , 항목 변수 선언하기위한 제어 흐름 식 익명 공간 범위이다. 제어 흐름 표현식으로서 블록은 구성 요소 비 항목 선언문을 순차적으로 실행 한 다음 최종 선택적 표현식을 실행합니다. 익명의 네임 스페이스 범위 인 항목 선언은 블록 자체의 범위에만 있고 &lt;code&gt;let&lt;/code&gt; 문으로 선언 된 변수는 다음 명령문에서 블록 끝까지 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;바이트 이스케이프&lt;/em&gt; 탈출 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; . 제공된 16 진 값과 동일한 바이트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;바이트 리터럴&lt;/em&gt; 합니다 (단일 ASCII 문자 인 &lt;code&gt;U+0000&lt;/code&gt; 에 &lt;code&gt;U+007F&lt;/code&gt; 의 범위) 또는 단일 &lt;em&gt;이스케이프&lt;/em&gt; 문자 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0027&lt;/code&gt; 문자 그래피 (따옴표)을 따라 &lt;code&gt;U+0027&lt;/code&gt; . 문자 &lt;code&gt;U+0027&lt;/code&gt; 이 리터럴 내에 있으면 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 그것은 동등 &lt;code&gt;u8&lt;/code&gt; 부호없는 8 비트 정수 &lt;em&gt;번호 리터럴&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;전화 식은&lt;/em&gt; 괄호 표현 목록 다음 식으로 구성되어 있습니다. 0 개 이상의 입력 변수를 제공하는 함수를 호출합니다. 함수가 결국 리턴하면 표현식이 완료됩니다. 들면 &lt;a href=&quot;../types/function-item&quot;&gt;비 기능 유형&lt;/a&gt; , 식 (F)는 (...) 중 하나의 방법을 사용한다 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt; 특성이든 상이한 이들은 참조, 변경 가능한 참조 또는 유형별로 각각 유형을 취합니다. 필요한 경우 자동 대출이 이루어집니다. Rust는 필요에 따라 자동으로 &lt;code&gt;f&lt;/code&gt; 를 역 참조 합니다. 호출 표현식의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자 리터럴은&lt;/em&gt; 두 가지로 둘러싸인 하나의 유니 코드 문자 &lt;code&gt;U+0027&lt;/code&gt; 를 제외하고 (따옴표) 문자 &lt;code&gt;U+0027&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;폐쇄 식&lt;/em&gt; 클로저를 정의하고, 하나의 식에 값으로 나타낸다. (A 밀폐 식 파이프 심볼 구분이다 &lt;code&gt;|&lt;/code&gt; ) 반박에서 &lt;a href=&quot;../patterns&quot;&gt;패턴을&lt;/a&gt; 표현 하였다. 매개 변수 유형 또는 리턴 유형에 대해 유형 어노테이션을 선택적으로 추가 할 수 있습니다. 리턴 유형이있는 경우 클로저 본문에 사용 된 표현식은 일반 &lt;a href=&quot;block-expr&quot;&gt;블록&lt;/a&gt; 이어야합니다 . 클로저 표현도 함께 시작할 수 있습니다 &lt;code&gt;move&lt;/code&gt; 초기 전에 키워드 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">람다 식 또는 람다라고도 하는 &lt;em&gt;클로저 식은 클로저를&lt;/em&gt; 정의하고 단일 식의 값으로 나타냅니다. 클로저 표현식은 파이프 기호로 구분 된 ( &lt;code&gt;|&lt;/code&gt; ) 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴&lt;/a&gt; 목록과 표현식입니다. 매개 변수 유형 또는 반환 유형에 대해 유형 주석을 선택적으로 추가 할 수 있습니다. 반환 유형이있는 경우 클로저 본문에 사용되는 표현식은 일반 &lt;a href=&quot;block-expr&quot;&gt;블록&lt;/a&gt; 이어야합니다 . 클로저 표현도 함께 시작할 수 있습니다 &lt;code&gt;move&lt;/code&gt; 초기 전에 키워드 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;단점리스트는&lt;/em&gt; 리스프 프로그래밍 언어와 방언에서 제공되는 데이터 구조입니다. Lisp에서 &lt;code&gt;cons&lt;/code&gt; 함수 ( &quot;construct 함수&quot;의 줄임말)는 일반적으로 단일 값과 다른 쌍인 두 인수에서 새 쌍을 구성합니다. 쌍을 포함하는이 쌍은 목록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;CONST 컨텍스트는&lt;/em&gt; 다음 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">&lt;em&gt;CONST의 FN은&lt;/em&gt; 하나가 CONST 컨텍스트에서 호출하도록 허용하는 기능입니다. &lt;code&gt;const&lt;/code&gt; 함수를 선언하는 것은 기존 사용에 영향을 미치지 않으며 인수와 반환 유형이 사용할 수있는 유형 만 제한 할뿐 아니라 다양한 표현식이 그 안에서 사용되는 것을 방지합니다. 일반 함수로 할 수있는 모든 것을 const 함수로 자유롭게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;상수 항목&lt;/em&gt; 임의로라는 &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;일정한 값으로&lt;/a&gt;&lt;/em&gt; 프로그램 내의 특정 메모리 위치에 연관되지 않는다. 상수는 기본적으로 사용되는 곳마다 인라인되어 있으므로 사용시 관련 컨텍스트에 직접 복사됩니다. 동일한 상수에 대한 참조가 반드시 동일한 메모리 주소를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;상수 항목&lt;/em&gt; 임의로라는 &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;일정한 값으로&lt;/a&gt;&lt;/em&gt; 프로그램 내의 특정 메모리 위치에 연관되지 않는다. 상수는 사용되는 위치에 관계없이 본질적으로 인라인됩니다. 즉, 사용될 때 관련 컨텍스트에 직접 복사됩니다. 여기에는 외부 상자의 상수 사용 및 비 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 유형 이 포함됩니다 . 동일한 상수에 대한 참조가 반드시 동일한 메모리 주소를 참조한다고 보장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;상자는&lt;/em&gt; 컴파일 및 링크뿐만 아니라 버전 관리, 유통 및 런타임로드의 단위이다. 상자에는 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 범위 의 &lt;em&gt;트리&lt;/em&gt; 가 있습니다 . 이 트리의 최상위 레벨은 (모듈 내의 경로 관점에서 볼 때 익명의) 모듈이며, 상자 안의 모든 항목 에는 상자의 모듈 트리 내에서 해당 위치를 나타내는 표준 &lt;a href=&quot;paths&quot;&gt;모듈 경로&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;상자는&lt;/em&gt; 컴파일 및 링크뿐만 아니라 버전 관리, 유통, 런타임로드의 단위이다. 상자에는 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 범위 의 &lt;em&gt;트리&lt;/em&gt; 가 있습니다 . 이 트리의 최상위 레벨은 (모듈 내의 경로 관점에서) 익명의 모듈이며 상자 내의 모든 항목 에는 상자의 모듈 트리 내의 위치를 ​​나타내는 표준 &lt;a href=&quot;paths&quot;&gt;모듈 경로&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;소수점 리터럴&lt;/em&gt; 마침표 다음에 &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). 선택적으로 &lt;em&gt;exponent&lt;/em&gt; 가있는 또 다른 10 진 리터럴이 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;진수 문자&lt;/em&gt; 로 시작 &lt;em&gt;소수점 자리수&lt;/em&gt; 와의 임의의 혼합물로 계속 &lt;em&gt;십진수&lt;/em&gt; 와 &lt;em&gt;밑줄&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;선언문은&lt;/em&gt; 하나 또는 그 이상의 도입 하나 &lt;em&gt;이름을&lt;/em&gt; 둘러싸는 문 블록에. 선언 된 이름은 새 변수 또는 새 &lt;a href=&quot;items&quot;&gt;항목을&lt;/a&gt; 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;필드 식은&lt;/em&gt; 단일 점 및 다음 식으로 구성 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 즉시 괄호 표현리스트 다음하지 않을 때, (후자는 항상 인 &lt;a href=&quot;method-call-expr&quot;&gt;메소드 호출의 표현&lt;/a&gt; ). 필드 표현식은 &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 의 필드를 나타냅니다 . 구조체에 저장된 함수를 호출하려면 필드 표현식 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;부동 소수점 리터럴&lt;/em&gt; 두 가지 형태 중 하나가 :</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;기능은&lt;/em&gt; 구성&lt;a href=&quot;../expressions/block-expr&quot;&gt; 블록&lt;/a&gt; 의 이름 및 파라미터들의 세트와 함께,. 이름 이외의 모든 옵션은 선택 사항입니다. 함수는 키워드 &lt;code&gt;fn&lt;/code&gt; 으로 선언됩니다 . 함수는 &lt;em&gt;입력 &lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;변수&lt;/em&gt;&lt;/a&gt; 세트를 매개 &lt;em&gt;변수&lt;/em&gt; 로 선언 할 수 있으며 ,이를 통해 호출자가 인수를 함수에 전달하고, 완료시 함수가 호출자에게 리턴 할 값의 &lt;em&gt;출력 &lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;유형&lt;/em&gt;&lt;/a&gt; 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;일반적인 기능은&lt;/em&gt; 하나 또는 그 이상의 수 &lt;em&gt;매개 변수 유형&lt;/em&gt; 의 서명에 나타납니다. 각 유형 매개 변수는 함수 이름 뒤에 꺾쇠 괄호로 묶고 쉼표로 구분 된 목록으로 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;해시 맵은&lt;/em&gt; 특정 키 값을 연결할 수 있습니다. &lt;em&gt;map&lt;/em&gt; 이라는보다 일반적인 데이터 구조의 특정 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">ㅏ &lt;em&gt;헥스 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;0x&lt;/code&gt; )과 16 진수 밑줄의 임의의 혼합물 (상기 적어도 하나 명의 숫자로)로 계속된다.</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;문자 표현&lt;/em&gt; 의 한 구성 &lt;a href=&quot;../tokens#literals&quot;&gt;문자&lt;/a&gt; 앞에서 설명한 형태. 숫자, 문자, 문자열 또는 부울 값을 직접 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;로컬 변수&lt;/em&gt; (또는 &lt;em&gt;스택 로컬&lt;/em&gt; 할당) 스택의 메모리 내에 할당 직접 값을 보유하고있다. 값은 스택 프레임의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">ㅏ &lt;em&gt;매치 가드&lt;/em&gt; 부가 인 &lt;code&gt;if&lt;/code&gt; 조건 A의 패턴 후 지정된 &lt;code&gt;match&lt;/code&gt; 이 아암 선택 될 수 있도록, 패턴 정합과 함께도 일치해야 아암. 매치 가드는 패턴만으로 허용되는 것보다 복잡한 아이디어를 표현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;메소드 호출은&lt;/em&gt; 식 (이루어져의 &lt;em&gt;수신기&lt;/em&gt; 는 단일 도트 발현 경로 세그먼트, 및 괄호 표현리스트 하였다). 메소드 호출은 연관된 것으로 해석됩니다.&lt;a href=&quot;../items/associated-items#methods&quot;&gt;&lt;/a&gt;왼쪽 의 정확한 &lt;code&gt;self&lt;/code&gt; 유형을 알고있는 경우 메소드에 정적으로 디스패치 하거나 왼쪽 표현식이 간접 &lt;a href=&quot;../types/trait-object&quot;&gt;특성 오브젝트 인&lt;/a&gt; 경우 동적으로 디스패치하는 특정 특성의 메소드 .</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;모듈 항목은&lt;/em&gt; 모듈, 괄호로 둘러싸인이라는 이름을 키워드로 시작입니다 &lt;code&gt;mod&lt;/code&gt; . 모듈 아이템은 상자를 구성하는 모듈 트리에 새로운 이름의 모듈을 도입합니다. 모듈은 임의로 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;숫자 리터럴은&lt;/em&gt; 어느 쪽이다&lt;em&gt; 정수 리터럴&lt;/em&gt; 또는 &lt;em&gt;부동 소수점 리터럴&lt;/em&gt; . 두 종류의 리터럴을 인식하는 문법이 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;경로는&lt;/em&gt; 하나 개 이상의 경로 세그먼트의 서열이다 &lt;em&gt;논리적&lt;/em&gt; 이름 공간 한정자 (의해 분리 &lt;code&gt;::&lt;/code&gt; ). 경로가 하나의 세그먼트로만 구성된 경우 경로는&lt;a href=&quot;items&quot;&gt;&lt;/a&gt; 로컬 제어 범위 항목 또는 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 를 . 경로에 여러 세그먼트가 있으면 항상 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;장소 식&lt;/em&gt; 메모리 위치를 나타내는 식이다. 이 표현식은 로컬 변수, &lt;a href=&quot;items/static-items&quot;&gt;정적 변수&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조&lt;/a&gt; ( &lt;code&gt;*expr&lt;/code&gt; ), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 표현식 ( &lt;code&gt;expr[expr]&lt;/code&gt; ), &lt;a href=&quot;expressions/field-expr&quot;&gt;필드&lt;/a&gt; 를 참조하는 &lt;a href=&quot;expressions/path-expr&quot;&gt;경로 &lt;/a&gt;입니다. 레퍼런스 ( &lt;code&gt;expr.f&lt;/code&gt; ) 및 괄호 장소 식. 다른 모든 표현식은 값 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;포인터&lt;/em&gt; 메모리에 주소를 포함하는 변수에 대한 일반적인 개념이다. 이 주소는 다른 데이터를 가리 킵니다. Rust에서 가장 일반적인 종류의 포인터는 4 장에서 배운 참조입니다. 참조는 &lt;code&gt;&amp;amp;&lt;/code&gt; 기호 로 표시되며 그들이 가리키는 값을 빌립니다. 그들은 데이터를 언급하는 것 외에 특별한 기능이 없습니다. 또한 오버 헤드가 없으며 가장 자주 사용하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;상대 경로는&lt;/em&gt; 현재 모듈 및 용법에서 시작 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; 또는 현재 모듈 식별자.</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">ㅏ &lt;em&gt;스칼라&lt;/em&gt; 타입은 하나의 값을 나타낸다. Rust에는 정수, 부동 소수점 숫자, 부울 및 문자의 네 가지 기본 스칼라 유형이 있습니다. 다른 프로그래밍 언어에서이를 인식 할 수 있습니다. 그들이 Rust에서 어떻게 작동하는지 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;문&lt;/em&gt; (A)의 구성 요소 인 &lt;a href=&quot;expressions/block-expr&quot;&gt;블록&lt;/a&gt; 차례로 외부의 구성 요소, &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt; 또는 &lt;a href=&quot;items/functions&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;정적 항목&lt;/em&gt; A와 비슷 &lt;a href=&quot;constant-items&quot;&gt;상수&lt;/a&gt; 가 프로그램의 정확한 메모리 위치를 나타내는 것을 제외. 정적에 대한 모든 참조는 동일한 메모리 위치를 나타냅니다. 정적 아이템은 &lt;code&gt;static&lt;/code&gt; 수명을 가지며 , 이는 Rust 프로그램에서 다른 모든 수명보다 오래 지속됩니다. &lt;a href=&quot;../interior-mutability&quot;&gt;내부에서 변경할&lt;/a&gt; 수 없는 유형이 포함 된 비 &lt;code&gt;mut&lt;/code&gt; 정적 항목 은 읽기 전용 메모리에 배치 될 수 있습니다. 정적 아이템은 &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 프로그램 끝에서 을 .</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;정적 항목&lt;/em&gt; A와 비슷 &lt;a href=&quot;constant-items&quot;&gt;상수&lt;/a&gt; 가 프로그램의 정확한 메모리 위치를 나타내는 것을 제외. 정적에 대한 모든 참조는 동일한 메모리 위치를 참조합니다. 정적 항목은 Rust 프로그램의 다른 모든 수명보다 오래 지속 되는 &lt;code&gt;static&lt;/code&gt; 수명을 갖습니다 . 정적 항목은 프로그램 끝에서 &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 을 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자열 리터럴&lt;/em&gt; 이 묶여 유니 코드 문자의 순서입니다 &lt;code&gt;U+0022&lt;/code&gt; 를 제외하고, (큰 따옴표) 문자 &lt;code&gt;U+0022&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;문자열 슬라이스&lt;/em&gt; (A)의 일부에 대한 참조입니다 &lt;code&gt;String&lt;/code&gt; , 그것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;문자열은&lt;/em&gt; 문자의 모음입니다. 우리는 &lt;code&gt;String&lt;/code&gt; 언급했습니다 유형에 했지만이 장에서는 이에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;구조체 식&lt;/em&gt; 구조체 또는 조합 값을 생성합니다. &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 에 대한 경로로 구성됩니다. 아이템 아이템 필드의 값으로 구성됩니다. 구조체 표현에는 구조체, 튜플 및 단위의 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/struct&quot;&gt;구조체 형식&lt;/a&gt; 키워드로 정의 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;구조체&lt;/em&gt; , 또는 &lt;em&gt;구조&lt;/em&gt; , 당신은 이름을 지정하고 의미있는 그룹을 만들어 함께 여러 관련 값을 패키징 할 수있는 사용자 정의 데이터 유형입니다. 객체 지향 언어에 익숙하다면 &lt;em&gt;구조체&lt;/em&gt; 는 객체의 데이터 속성과 같습니다. 이 장에서는 튜플을 구조체와 비교 및 ​​대조하고, 구조체를 사용하는 방법을 보여 주며, 구조체의 데이터와 관련된 동작을 지정하는 메서드 및 관련 함수를 정의하는 방법에 대해 설명합니다. Structs와 enum (6 장에서 논의)은 Rust의 컴파일 타임 타입 검사를 최대한 활용하기 위해 프로그램 도메인에서 새로운 타입을 생성하기위한 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;시험은 두 번&lt;/em&gt; 테스트 중에 다른 유형의 장소에서 사용되는 유형에 대한 일반 프로그래밍 개념이다. &lt;em&gt;모의 객체&lt;/em&gt; 는 테스트 중에 발생하는 상황을 기록하는 특정 유형의 테스트 복식으로 올바른 동작이 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;스레드 풀&lt;/em&gt; 기다리고 작업을 처리 할 준비가되어 산란 스레드 그룹입니다. 프로그램이 새 작업을 받으면 풀의 스레드 중 하나를 작업에 할당하면 해당 스레드가 작업을 처리합니다. 풀의 나머지 스레드는 첫 번째 스레드가 처리되는 동안 들어오는 다른 작업을 처리하는 데 사용할 수 있습니다. 첫 번째 스레드가 작업 처리를 완료하면 유휴 스레드 풀로 반환되어 새 작업을 처리 할 수 ​​있습니다. 스레드 풀을 사용하면 연결을 동시에 처리하여 서버의 처리량을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;특성 구현은&lt;/em&gt; 선택 사양 제네릭 형식 선언이 뒤에 것을 제외하고 고유의 구현과 같이 정의 &lt;a href=&quot;traits&quot;&gt;특성&lt;/a&gt; 키워드 다음 &lt;code&gt;for&lt;/code&gt; . 공칭 유형에 대한 경로가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="translated">&lt;em&gt;특성 객체는&lt;/em&gt; 다른 종류의 특성을 구현하는 일련의 불투명 한 값이다. 특성 개체는 지정된 모든 특성과 해당 상위 특성 (있는 경우)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;특성 객체는&lt;/em&gt; 다른 종류의 특성을 구현하는 일련의 불투명 한 값이다. 특성 세트는 &lt;a href=&quot;../items/traits#object-safety&quot;&gt;객체 안전 &lt;/a&gt;&lt;em&gt;기본 특성&lt;/em&gt; 과 여러 &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;자동 특성으로 구성&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 유형을 구현할 수 있다는 추상적 인 인터페이스를 설명합니다. 이 인터페이스는 &lt;a href=&quot;associated-items&quot;&gt;관련 항목으로&lt;/a&gt; 구성 되며 세 가지 유형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 특정 유형이 다른 유형과 공유 할 수있는 기능에 대해 녹 컴파일러를 알려줍니다. 특성을 사용하여 추상적 인 방식으로 공유 동작을 정의 할 수 있습니다. 특성 경계를 사용하여 제네릭이 특정 동작이있는 모든 유형이 될 수 있음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;튜플 인덱스&lt;/em&gt; 하나이고 &lt;code&gt;0&lt;/code&gt; 또는로 시작 &lt;em&gt;비제 소수점 자리수&lt;/em&gt; 와 0 개 이상의 십진수로 계속된다. 튜플 인덱스는 &lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;items/enumerations&quot;&gt;튜플 변형&lt;/a&gt; 의 필드를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;튜플 구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/tuple&quot;&gt;튜플 형식&lt;/a&gt; 또한 키워드를 사용하여 정의, &lt;code&gt;struct&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;튜플 구조체의&lt;/em&gt; 유형은 필드가 익명 것을 제외하고, 단지 구조체 형과 같다.</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;타입 별칭은&lt;/em&gt; 기존의 새 이름을 정의하는 &lt;a href=&quot;../types&quot;&gt;유형&lt;/a&gt; . 유형 별명은 키워드 &lt;code&gt;type&lt;/code&gt; 으로 선언됩니다 . 모든 값에는 하나의 특정 유형이 있지만 여러 가지 특성을 구현하거나 여러 가지 유형 제한 조건과 호환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;형 표현&lt;/em&gt; 에 정의로 &lt;em&gt;입력&lt;/em&gt; 문법 규칙은 전술 한 유형을 참조하는 구문이다. 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;유니온 타입&lt;/em&gt; (A)의 이름 붙이고 공칭 이종 C 형상의 조합 인 &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 아이템&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;유닛 형 구조체&lt;/em&gt; 전체 필드 목록을 남김으로써 정의 된 필드가없는 구조체이다. 이러한 구조체는 동일한 이름을 가진 유형의 상수를 암시 적으로 정의합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;구조체 부 형상&lt;/em&gt; 타입은 어떤 필드가 없다는 것을 제외하고, 구조체의 형태와 같다. 연관된 &lt;a href=&quot;../expressions/struct-expr&quot;&gt;구조체 표현식으로&lt;/a&gt; 구성된 하나의 값 은 이러한 유형에있는 유일한 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;사용 선언은&lt;/em&gt; 다른과 동의어 하나 이상의 로컬 이름 바인딩 생성 &lt;a href=&quot;../paths&quot;&gt;경로를&lt;/a&gt; . 일반적으로 &lt;code&gt;use&lt;/code&gt; 선언은 모듈 항목을 참조하는 데 필요한 경로를 단축하는 데 사용됩니다. 이러한 선언은 일반적으로 맨 위에 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 과 &lt;a href=&quot;../expressions/block-expr&quot;&gt;블록에&lt;/a&gt; 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;값 식은&lt;/em&gt; 실제의 값을 나타내는 식이다.</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;변수는&lt;/em&gt; 스택 프레임의 구성 요소 중 하나라는 함수 파라미터 익명 인 &lt;a href=&quot;expressions#temporaries&quot;&gt;임시&lt;/a&gt; 또는 로컬 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;변수는&lt;/em&gt; 스택 프레임의 구성 요소 중 하나라는 함수 파라미터 익명 인 &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;임시&lt;/a&gt; 또는 로컬 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;벡터&lt;/em&gt; 는 서로 옆에 값의 변수 번호를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; 유니 값들 나타내는) &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) 또는 &lt;code&gt;U+0009&lt;/code&gt; (HT).</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; (가) 값 바이트를 나타내는) &lt;code&gt;0x0A&lt;/code&gt; (ASCII의 LF) &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) 또는 &lt;code&gt;0x09&lt;/code&gt; (ASCII HT ).</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;작업 공간은&lt;/em&gt; 같은 공유 패키지 세트입니다 &lt;em&gt;Cargo.lock&lt;/em&gt; 출력 디렉토리를. 작업 공간을 사용하여 프로젝트를 만들어 봅시다. 간단한 코드를 사용하여 작업 공간의 구조에 집중할 수 있습니다. 작업 공간을 구성하는 방법에는 여러 가지가 있습니다. 우리는 하나의 일반적인 방법을 보여줄 것입니다. 바이너리와 두 개의 라이브러리가 포함 된 작업 공간이 있습니다. 주요 기능을 제공 할 바이너리는 두 라이브러리에 따라 다릅니다. 하나의 라이브러리가 제공됩니다 &lt;code&gt;add_one&lt;/code&gt; 의 기능, 두 번째 라이브러리 &lt;code&gt;add_two&lt;/code&gt; 기능을. 이 3 개의 상자는 동일한 작업 공간의 일부가됩니다. 작업 공간을위한 새로운 디렉토리를 생성하는 것으로 시작하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">다중 하드웨어 스레드를 동시에 실행 하는 &lt;strong&gt;다중 프로세서&lt;/strong&gt; 시스템 : 다중 스레드 시나리오에서는 두 가지 유형의 기본 요소를 사용하여 동기화를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;전송&lt;/strong&gt; 채널의 수신 측이 데이터가 수신되지 않을 수 있음을 암시 분리되면 조작은 실패 할 수 있습니다. 오류는 복구 할 수 있도록 페이로드로 전송되는 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;단일 프로세서&lt;/strong&gt; 명령어 실행 &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;밖으로의 순서를&lt;/a&gt; : 현대 CPU는 할 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;슈퍼 스칼라&lt;/a&gt; , 여러 지침은 기계 코드가 순차적 인 프로세스를 설명에도 불구하고, 동시에 실행 될 수있다 즉 실행.</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">대신 B- 트리는 각 노드에 연속 배열의 B-1 ~ 2B-1 요소를 포함시킵니다. 이를 통해 B 수만큼 할당 수를 줄이고 검색시 캐시 효율성을 향상시킵니다. 그러나 이것은 검색이 평균적으로 &lt;em&gt;더 많은&lt;/em&gt; 비교 를 수행해야 함을 의미합니다 . 정확한 비교 수는 사용 된 노드 검색 전략에 따라 다릅니다. 최적의 캐시 효율성을 위해 노드를 선형으로 검색 할 수 있습니다. 최적의 비교를 위해 이진 검색을 사용하여 노드를 검색 할 수 있습니다. 타협으로, 처음에는 모든 i &lt;sup&gt;번째&lt;/sup&gt; 요소 만 i의 선택을 확인하는 선형 검색을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="translated">C-variadic 유형은 지정된 함수에 정의되지 않은 수의 매개 변수를 제공하는 데 사용됩니다 (예 : C의 &lt;code&gt;printf&lt;/code&gt; ). Rust에서 동등한 것은 매크로를 직접 사용하는 것입니다 (예 : &lt;code&gt;println!&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP 요청 자세히 살펴보기</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">조건 변수</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust 바이너리 또는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">각 공백 요소가 단일 공백 ​​문자와 같은 다른 유효한 공백 요소로 대체되는 경우 Rust 프로그램은 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rust 소스 파일은 현재 상자의 모듈 트리에서 모듈의 이름과 위치를 소스 파일 외부에서 정의 합니다 (참조 소스 파일 의 명시 적 &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;모듈&lt;/em&gt;&lt;/a&gt; 항목 또는 상자 자체. 모든 소스 파일은 모듈이지만 모든 모듈에 고유 한 소스 파일이 필요한 것은 아닙니다. &lt;a href=&quot;items/modules&quot;&gt;모듈 정의&lt;/a&gt; 는 하나의 파일 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">오류 전파를위한 지름길 : &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">연결을 청취하는 TCP 소켓 서버.</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">로컬 소켓과 원격 소켓 사이의 TCP 스트림.</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">리팩토링의 손길</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">녹 표준 도서관 둘러보기</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP 소켓.</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8로 인코딩되고 확장 가능한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">유닉스 데이터 그램 소켓.</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">유닉스 스트림 소켓.</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">내부 돌연변이 성을위한 유스 케이스 : 모의 객체</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows 경로 접두사 (예 &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">윈도우 경로 접두어, 예를 들어, &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">장벽은 여러 스레드가 일부 계산의 시작을 동기화 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">장벽은 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출 한 &lt;code&gt;n&lt;/code&gt; -1 스레드를 차단 한 다음 &lt;code&gt;n&lt;/code&gt; 번째 스레드 호출이 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 할 때 모든 스레드를 한 번에 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">장벽은 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 를 호출하는 &lt;code&gt;n&lt;/code&gt; -1 스레드를 차단 한 다음 &lt;code&gt;n&lt;/code&gt; 번째 스레드가 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 할 때 한 번에 모든 스레드를 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">기본 예 :</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 유형 의 기본 문자열 선언 :</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; 또는 &lt;code&gt;^=&lt;/code&gt; 와 같은 이진 할당 연산자 가이를 지원하지 않는 유형에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="translated">바이너리는 하나의 진입 점 만 가질 수 있으며 기본적으로 해당 진입 점은 &lt;code&gt;main()&lt;/code&gt; 함수입니다. 이 함수의 인스턴스가 여러 개인 경우 그 중 하나의 이름을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">바이너리는 하나의 진입 점 만 가질 수 있으며 기본적으로 진입 점은 함수 &lt;code&gt;main()&lt;/code&gt; 입니다. 이러한 기능이 여러 개인 경우 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="translated">지원하지 않는 유형에서 이진 연산을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">지원하지 않는 유형에서 이진 연산을 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">바인딩은해서는 안되는 것을 숨겼습니다.</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">다른 블록 표현식의 테일 표현식 인 블록 표현식.</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;안전하지 않은 작업&lt;/a&gt; 을 허용하기 위해 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 코드 블록 앞에 붙일 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 함수를 호출 하거나 안전 함수 내에서 원시 포인터를 역 참조 할 수 있도록 &lt;code&gt;unsafe&lt;/code&gt; 키워드 를 코드 블록 앞에 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">블로그 게시물은 빈 초안으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="translated">내부 가변성을 포함하는 상수를 빌리려고했습니다.</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">내부 변이성을 포함하는 상수를 빌리려고 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">스레드 로컬 변수의 차용은 함수의 수명을 초과 한 함수 내부에서 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="translated">차용 한 가치가 밖으로 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="translated">빌린 변수가 클로저에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">빌린 변수가 빌린 변수를 사용했습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="translated">break 표현식은 일반적으로 &lt;code&gt;break&lt;/code&gt; 를 둘러싸는 가장 안쪽 루프와 연관 되지만 레이블을 사용하여 영향을받는 둘러싸는 루프를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스트 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919에&lt;/a&gt; 정의 된대로 모든 옥텟이 255로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">너무 작은 버퍼 :</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap에서 키-값 쌍이 저장되는 위치를 계산하기위한 빌더.</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">다양한 방법으로 디렉토리를 작성하는 데 사용되는 빌더.</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="translated">내장 매크로가 두 번 이상 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="translated">바이 값 &lt;a href=&quot;../primitive.array&quot;&gt;어레이&lt;/a&gt; 반복기.</target>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="translated">바이트 상수가 올바르게 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="translated">이 특별한 &lt;code&gt;Drop&lt;/code&gt; 특성이 해당 유형에 대해 구현 된 경우 해당 값에 대한 &lt;code&gt;Drop::drop&lt;/code&gt; 호출 .</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">를 호출 &lt;code&gt;park&lt;/code&gt; 스레드가 영원히 주차 유지하는 것을 보증하지 않으며, 호출자는이 가능성에 대비해야한다.</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="translated">클로저에서 캡처 된 변수는 충분히 오래 살지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">얇고 뚱뚱한 포인터 사이의 캐스트가 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">에 대한 캐스트 &lt;code&gt;char&lt;/code&gt; 아닌 다른 유형에 시도되었습니다 &lt;code&gt;u8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">크기가 조정되지 않은 유형으로 캐스트를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">프로그래밍 채널에는 송신기와 수신기의 두 부분이 있습니다. 송신기 반은 고무 오리를 강에 넣는 업스트림 위치이고 수신기 반은 고무 오리가 다운 스트림에서 끝나는 곳입니다. 코드의 한 부분은 전송하려는 데이터를 사용하여 송신기에서 메서드를 호출하고 다른 부분은 수신 쪽에서 도착 메시지를 확인합니다. 채널이 &lt;em&gt;폐쇄&lt;/em&gt; 되었다고합니다&lt;em&gt;&lt;/em&gt;송신기 또는 수신기 절반이 떨어지면 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="translated">문자 리터럴이 따옴표로 끝나지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">문자 유형.</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">부동 소수점 숫자의 분류.</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="translated">clobber는 &lt;code&gt;llvm_asm&lt;/code&gt; 매크로 에서 중괄호로 둘러싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">복제시 쓰기 스마트 포인터.</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">클로저 식은 매개 변수 목록을 매개 변수 다음에 오는 식에 매핑하는 함수를 나타냅니다. &lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 바인딩&lt;/a&gt; 처럼 매개 변수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴입니다&lt;/a&gt; 유형이 주석 선택 사항이며 지정하지 않을 경우 문맥에서 추론됩니다. 각 클로저 표현식에는 고유 한 익명 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">클로저는 &lt;code&gt;static&lt;/code&gt; 으로 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">고유 한 불변 또는 변경 가능한 참조로 값을 캡처하지 않고 복사 또는 이동으로 캡처하는 모든 값 이 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고유하지 않은 불변의 참조로 캡처 된 모든 변수가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 이고 고유 한 불변의 또는 변경 가능한 참조, 복사 또는 이동으로 캡처 된 모든 값 이 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">캡처 된 모든 변수 가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">자체 유형을 참조하는 클로저 또는 생성기가 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">클로저가 사용되었지만 예상되는 특성을 구현하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">캡처 된 변수에서 &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 않는 클로저는 FnMut을 구현 하여 변경 가능한 참조로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">캡처 된 변수를 변경하거나 벗어나지 않는 클로저는 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; 을&lt;/a&gt; 구현 하여 공유 참조에 의해 호출 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">강요는 프로그램의 특정 강요 사이트에서만 발생할 수 있습니다. 이들은 일반적으로 원하는 유형이 명시 적이거나 명시 적 유형 (유형 유추없이)에서 전파되어 파생 될 수있는 장소입니다. 가능한 강제 사이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">메시지를 스트림으로 형식화하는 데 필요한 메소드 콜렉션.</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">일반적인 예는 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;collect&lt;/code&gt; 메소드입니다 . &lt;code&gt;FromIterator&lt;/code&gt; 바운드 가있는 제네릭 형식 매개 변수가 있으며 , &lt;code&gt;char&lt;/code&gt; 반복기의 경우 &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 으로 구현됩니다 . 문자열의 문자를 뒤집는 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">유형 클래스에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="translated">유형 그룹에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">일반적인 오해는 &quot;유니 캐스트 링크 로컬 주소는 &lt;code&gt;fe80::&lt;/code&gt; &quot;으로 시작 하지만 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 이라고 생각하는 것입니다. 실제로 다음 주소에 대해보다 엄격한 형식을 정의 .</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">리턴 값을 사용하여 오류를 표시 할 때 일반적으로 발생하는 문제점은 리턴 값을 무시하기 쉽고 오류를 처리하지 못한다는 것입니다. &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;#[must_use]&lt;/code&gt; 속성 이 주석으로 표시되어 결과 값이 무시 될 때 컴파일러가 경고를 발행합니다. 이 차종은 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 오류가 발생할 수 있지만, 그렇지 않으면 유용한 값을 반환하지 않는 기능이 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">객체를 명시 적으로 복제 할 수있는 능력에 대한 일반적인 특징.</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; 의 일반적인 사용 사례 는 동기화 프리미티브의 CAS 루프에서 제한된 낙관적 회전을 구현하는 것입니다. 우선 순위 반전과 같은 문제를 방지하려면 한정된 양의 반복과 적절한 차단 시스템 호출이 이루어진 후에 스핀 루프를 종료하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 의 일반적인 사용 ! 문자열의 연결 및 보간입니다. &lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt; 동일한 규칙이 사용됩니다 ! 그리고 &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;문자열의 대상에 따라 매크로</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">이 기능은 일반적으로 &lt;code&gt;drop&lt;/code&gt; 이 호출 될 때 &lt;code&gt;panicking&lt;/code&gt; 을 확인하여 안전하지 않은 코드를 작성할 때 공유 리소스를 독살하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">기능을 테스트하는 일반적인 방법은 테스트중인 코드의 결과를 코드가 동일한 지 확인하기 위해 반환 할 것으로 예상되는 값과 비교하는 것입니다. 당신은 &lt;code&gt;assert!&lt;/code&gt; 사용하여 이것을 할 수 있습니다 ! &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 표현식을 전달하십시오 . 그러나 이것은 표준 라이브러리가 매크로 쌍인 &lt;code&gt;assert_eq!&lt;/code&gt; 제공하는 일반적인 테스트입니다 . 그리고 &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;이 테스트를보다 편리하게 수행합니다. 이 매크로는 두 가지 인수가 동일한 지 또는 불평등인지를 각각 비교합니다. 또한 어설 션이 실패하면 두 값을 인쇄 하여 테스트가 실패한 &lt;em&gt;이유를&lt;/em&gt; 더 쉽게 확인할 수 있습니다 . 반대로, &lt;code&gt;assert!&lt;/code&gt; 매크로는 &lt;code&gt;false&lt;/code&gt; 나타냅니다. &lt;code&gt;==&lt;/code&gt; 의 값 &lt;code&gt;false&lt;/code&gt; 이끄는 값이 아닌 표현 값.</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 을 사용하는 일반적인 방법 은 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용하는 것 입니다. 리콜 그 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 일부 데이터의 여러 소유자를 할 수 있지만, 해당 데이터에 대한 불변의 액세스를 제공합니다. 당신이있는 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 보유 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 여러 소유자를 가질 수있는 값 얻을 수 있습니다 &lt;em&gt;그리고&lt;/em&gt; 당신은 돌연변이 수를!</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="translated">구조체의 일부 필드를 무시하는 위와 같은 비교는 위험 할 수 있습니다. 부분적 동등성 관계에 대한 요구 사항의 의도하지 않은 위반으로 쉽게 이어질 수 있습니다. , 예를 들어, 우리의 상기 구현 유지 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 대한 &lt;code&gt;BookFormat&lt;/code&gt; 을 하고 구현 첨가 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;Book&lt;/code&gt; (어느 비아 &lt;code&gt;#[derive]&lt;/code&gt; 또는 제 1 예에서 수동 구현을 통한) 결과는 위반 전이성 :</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">환경 변수의 존재 여부에 관계없이이 매크로를 사용할 때 컴파일 시간 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">컴파일러 메모리 펜스</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">컴파일러 전용 메모리 장벽.</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">구성 옵션. 옵션이 설정되어 있으면 true이고 설정되어 있지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">차용 규칙의 결과는 불변의 가치가있을 때 변경할 수 없다는 것입니다. 예를 들어이 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="translated">상수 항목이 상수 표현식이 아닌 것으로 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="translated">상수 값을 평가하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">힙 할당 내용이 있고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성된 연속 확장 가능 배열 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">연속 가능한 확장 가능 배열 유형으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성 되었지만 'vector'로 발음됩니다.</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="translated">제어 흐름식이 const 컨텍스트 내에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">&lt;code&gt;io::Result&lt;/code&gt; 를 호출자에게 버블 링하는 편리한 함수 :</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대한 impl을 위임하는 편리한 impl</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 을 위해 impl에 위임하는 편리한 impl .</target>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">상자는 ECMA-335 CLI 모델 의 &lt;em&gt;어셈블리&lt;/em&gt; , SML / NJ Compilation Manager 의 &lt;em&gt;라이브러리&lt;/em&gt; , Owens and Flatt 모듈 시스템 의 &lt;em&gt;단위&lt;/em&gt; 또는 Mesa 의 &lt;em&gt;구성&lt;/em&gt; 과 다소 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">상자에는 자체적으로 사용할 수있는 전역 &quot;도우미 모듈&quot;이 필요하지만, 도우미 모듈을 공개 API로 노출하고 싶지는 않습니다. 이를 달성하기 위해 크레이트 계층의 루트는 내부적으로 &quot;공용 API&quot;를 갖는 개인 모듈을 갖게됩니다. 전체 상자는 루트의 자손이므로 전체 로컬 상자는 두 번째 경우를 통해이 개인 모듈에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 이 포함 된 상자 는 실행 파일로 컴파일 할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수가 존재 한다면, 인수를 취하지 않아야하며, &lt;a href=&quot;trait-bounds&quot;&gt;특성이나 수명 한계를&lt;/a&gt; 선언 해서는 안되며 &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where 절이&lt;/a&gt; 없어야 합니다. , 리턴 유형은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">크레이트는 관련 기능을 범위 내에서 그룹화하여 여러 프로젝트간에 기능을 쉽게 공유 할 수 있습니다. 예를 들어, &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;2 장&lt;/a&gt; 에서 사용한 &lt;code&gt;rand&lt;/code&gt; 상자는 난수를 생성하는 기능을 제공합니다. &lt;code&gt;rand&lt;/code&gt; 크레이트를 프로젝트 범위로 가져 와서 자체 프로젝트에서 해당 기능을 사용할 수 있습니다 . &lt;code&gt;rand&lt;/code&gt; 상자에서 제공하는 모든 기능 은 상자의 이름 인 &lt;code&gt;rand&lt;/code&gt; 를 통해 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="translated">struct 또는 enum 유형이 아닌 것에 교차 상자 옵트 아웃 특성이 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">교차 상자 옵트 아웃 특성은 구조체 또는 열거 형이 아닌 것으로 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="translated">편집 작업이 있는 &lt;code&gt;LinkedList&lt;/code&gt; 위의 커서 입니다.</target>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 위의 커서 .</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;code&gt;Arc&lt;/code&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">스레드 패닉시 데이터 구조가 일시적으로 유효하지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">기본 구성은 &lt;code&gt;Command::new(program)&lt;/code&gt; 사용하여 생성 할 수 있습니다 . 여기서 &lt;code&gt;program&lt;/code&gt; 은 실행할 프로그램의 경로를 제공합니다. 추가 빌더 메소드를 사용하면 생성 전에 구성을 변경할 수 있습니다 (예 : 인수 추가).</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">구현 된 특성에없는 방법의 정의는 특성 구현에서 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 의 판별 자는 유형 정의에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="translated">판별 값이 두 번 이상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="translated">아무것도 첨부되지 않은 문서 주석이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">아무것도 문서화하지 않은 문서 주석이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">큰 따옴표 바이트 문자열 ( &lt;code&gt;b&quot;&lt;/code&gt; )이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">큰 따옴표 문자열 ( &lt;code&gt;&quot;&lt;/code&gt; )이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">방향이 반전 된 이중 종단 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">확장 가능한 링 버퍼로 구현 된 이중 엔드 큐입니다.</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">소유 한 노드가있는 이중 연결 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목의 배수 반복기 입니다.</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 항목에 대한 배수, 필터링 반복기 .</target>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목에 대한 배수, 필터링 반복기 입니다.</target>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">DST (Dynamic Sized Type)는 정적으로 알려진 크기 나 정렬이없는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">연속적인 순서로 동적으로 크기보기 &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="translated">연속적인 시퀀스에 대한 동적 크기보기, &lt;code&gt;[T]&lt;/code&gt; . 여기서 Contiguous는 모든 요소가 인접 요소와 동일한 거리에 있도록 요소가 배치됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">제거 된 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">컴파일러 명령 행 플래그에서 허용되지 않은 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">최소 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 시맨틱을 갖는 펜스 'A'는 적어도 원자 적 객체 'M'에서 작동하는 X 및 Y 오퍼레이션이 존재하는 경우에만 시맨틱을 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 최소 '시맨틱'을 갖는 펜스 'B'와 동기화됩니다. A는 X보다 먼저 시퀀싱되고, Y는 B보다 먼저 동기화되고 Y는 M에 대한 변화를 관찰합니다. 이는 A와 B 사이의 사전 의존성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">보유 울타리 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 를&lt;/a&gt; 모두 갖는 외에, 순서를 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 다른 프로그램의 글로벌 순서 시멘틱스가 참여를 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 의&lt;/a&gt; 동작 및 / 또는 울타리.</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">필드 액세스는 해당 필드의 위치를 ​​나타내는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 표현&lt;/a&gt; 입니다. 하위 표현식이 &lt;a href=&quot;../expressions#mutability&quot;&gt;변경 가능&lt;/a&gt; 하면 필드 표현식도 변경 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">라인 외부 모듈에 대한 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rust가 문자를 얻기 위해 &lt;code&gt;String&lt;/code&gt; 로 색인을 생성 할 수없는 마지막 이유 는 색인 작업이 항상 일정한 시간 (O (1))이 걸리기 때문입니다. 그러나 Rust는 유효한 문자 수를 결정하기 위해 처음부터 색인까지 내용을 탐색해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 성능을 보장 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">유한 이종 시퀀스 &lt;code&gt;(T, U, ..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">표시 고정 크기 어레이, &lt;code&gt;[T; N]&lt;/code&gt; , 요소 유형에 대한 &lt;code&gt;T&lt;/code&gt; 및 음이 아닌 컴파일 시간 상수 크기 &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">for 루프는 다음 블록 표현식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">모든 인수를 사용하려면 형식 문자열이 필요합니다. 그렇지 않으면 컴파일 타임 오류입니다. 형식 문자열에서 동일한 인수를 두 번 이상 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;ignore&lt;/code&gt; 속성 으로 주석을 달 수도 있습니다 . 는 &lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 속성&lt;/em&gt; 테스트로서 그 기능을 실행하지 않는 테스트 장치를 말한다. 테스트 모드에있을 때는 여전히 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 를 반환 하는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;should_panic&lt;/code&gt; 속성 으로 주석을 달 수 있습니다 . &lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 속성은&lt;/em&gt; 테스트 만하면 실제로 패닉을 통과한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">표현식의 값을 컴파일 타임에 알아야하기 때문에 const의 초기화 표현식에서는 함수 호출이 허용되지 않습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">extern 블록에 선언 된 함수는 암시 적으로 &lt;code&gt;unsafe&lt;/code&gt; . 함수 포인터로 강제 변환되면, extern 블록에 선언 된 함수는 &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 유형을 갖습니다 . 여기서 &lt;code&gt;'l1&lt;/code&gt; , ... &lt;code&gt;'lm&lt;/code&gt; 은 수명 매개 변수, &lt;code&gt;A1&lt;/code&gt; , ..., &lt;code&gt;An&lt;/code&gt; 은 매개 변수의 선언 된 유형이고 &lt;code&gt;R&lt;/code&gt; 은 선언 된 리턴 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="translated">함수가 &lt;code&gt;continue&lt;/code&gt; 키워드를 잘못 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">함수 또는 함수 포인터.</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">함수 시그니처는 함수가 가진 매개 변수의 수와 유형을 선언해야합니다. 반면에 매크로는 가변 개수의 매개 변수를 사용할 수 있습니다 &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; 하나의 인수로 println! ( &quot;hello&quot;) 또는 두 개의 인수로 &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; 을 호출 할 수 있습니다. 또한 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되므로 매크로는 예를 들어 지정된 유형에 특성을 구현할 수 있습니다. 함수는 런타임에 호출되고 특성은 컴파일 타임에 구현되어야하기 때문에 함수를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">매개 변수가 있거나 1에서 100 사이의 숫자 만 반환하는 함수는 서명 에서 &lt;code&gt;i32&lt;/code&gt; 가 아닌 &lt;code&gt;Guess&lt;/code&gt; 를 가져 오거나 반환한다고 선언 할 수 있으며 본문에서 추가 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">옵티 마이저에 대해 불투명 한 기능으로, 벤치 마크에서 출력을 사용하는 척하여 데드 코드 제거를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 속성을 가진 함수가 유형 매개 변수로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="translated">근본적인 특성은 기존 유형에 대한 impl을 추가하는 것이 브레이킹 체인지입니다. &lt;code&gt;Fn&lt;/code&gt; 을 특성과 &lt;code&gt;Sized&lt;/code&gt; 기본이다.</target>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="translated">기본 형식 생성자는 그 위에 &lt;a href=&quot;#blanket-implementation&quot;&gt;블랭킷 구현을 구현&lt;/a&gt; 하는 것이 주요 변경 인 형식입니다. &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut&lt;/code&gt; , &lt;code&gt;Box&lt;/code&gt; 및 &lt;code&gt;Pin&lt;/code&gt; 은 기본입니다.</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">미래는 아직 컴퓨팅을 마치지 못한 가치입니다. 이런 종류의 &quot;비동기 값&quot;은 값을 사용할 수있을 때까지 스레드가 유용한 작업을 계속 수행 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">미래는 비동기 계산을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">빌린 데이터에 대한 &lt;code&gt;Clone&lt;/code&gt; 의 일반화 .</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">일반 함수는 다음과 유사하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="translated">일반 유형은 꺾쇠 괄호 대신 괄호를 사용하여 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">괄호 대신 괄호를 사용하여 일반 유형을 설명했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">하나 이상의 연관된 유형에 특정 지정이있는 일반 유형 (예 : &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">대단한 메모 👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">주어진 매처 M은 FIRST (M), LAST (M) 및 FOLLOW (M)의 세 세트에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">이 기술이 유용한 상황의 좋은 예는 운영자 과부하입니다. &lt;em&gt;연산자 과부하&lt;/em&gt; 는 특정 상황에서 연산자의 동작 (예 : &lt;code&gt;+&lt;/code&gt; )을 사용자 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 제로 초기화를 허용하지 않으면 실행될 수없는 안전하지 않은 기능에 대한 보호 : 이것은 정적으로 패닉 상태가되거나 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 유효하지 않은 비트 패턴이있는 경우 실행할 수없는 안전하지 않은 함수에 대한 가드 : 정적으로 패닉 상태가되거나 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 무인 상태 일 때 실행할 수없는 안전하지 않은 기능에 대한 보호 : 정적으로 패닉 상태이거나 아무 것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">자식 프로세스의 표준 입력 (stdin)에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">자식 프로세스의 표준 출력 (stdout)에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">자식 프로세스의 stderr에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">스레드 핸들.</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">현재 프로세스의 글로벌 표준 출력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">프로세스의 표준 오류 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">프로세스의 표준 입력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">선형 프로빙 및 Robin Hood 버킷 스틸 링으로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">2 차 프로빙 및 SIMD 조회로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;()&lt;/code&gt; 인 &lt;code&gt;HashMap&lt;/code&gt; 으로 구현 된 해시 세트 입니다.</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">해시 가능 유형</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">역순 정렬을위한 도우미 구조체</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">인덱싱 작업에 사용되는 도우미 특성입니다.</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="translated">잘못된 형식의 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">랭 아이템이 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; 가 제공하는 많은 구조는 I / O를 반복하는 다양한 방법을위한 것입니다. 예를 들어 &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt; 은 선 을 분할하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 지연 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 조합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 통합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">라이브러리 개발자는 라이브러리와 링크되는 크레이트에 기능을 노출해야합니다. 첫 번째 경우의 결과로 외부에서 사용할 수있는 것은 루트에서 대상 항목까지 &lt;code&gt;pub&lt;/code&gt; 이어야합니다 . 체인의 모든 개인 품목은 외부 액세스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">수명은 특성에 대한 입력 유형이 아니라 연관된 유형 바인딩에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="translated">특성 구현에 대한 수명이 잘못된 위치에서 캡처되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">수명 한계가 충족되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="translated">주어진 상황에서 수명을 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="translated">일생이 예상했던 것과 일치하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">수명은 트레이 트에 대한 입력 유형이 아닌 연관된 유형 바인딩에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">수명 범위 이름은 동일한 범위에서 두 번 이상 선언 될 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="translated">평생 이름이 다른 평생 이름을 숨기고 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">평생 이름이 다른 평생 이름을 가리고 있습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="translated">동일한 범위에서 수명이 두 번 이상 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="translated">빈 이름으로 링크 이름이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">빈 이름으로 링크 이름이 지정되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="translated">이름 매개 변수없이 링크가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">이름 매개 변수없이 링크가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">보푸라기 검사 속성이 묶는 범위 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 속성으로 설정된 &lt;code&gt;forbid&lt;/code&gt; 지시문 으로 인해 무효화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">린트 검사는 도달 할 수없는 코드 또는 생략 된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴의 이름을 지정합니다. 린트 속성은 &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; 및 &lt;code&gt;forbid&lt;/code&gt; 를 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; 속성이 적용되는 개체에 대한 보풀 수준을 변경 보풀 이름의 목록을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">사용 가능한 외부 랭 항목 목록은 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; 에서 사용할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">사용 가능한 외부 lang 항목 목록은 &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt; 에 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">일반적인 I / O 오류 범주를 지정하는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">각 요소, 즉, 함께 목록 &lt;code&gt;[x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">리터럴은 일련의 토큰이 아닌 단일 토큰으로 구성되는 표현식으로, 이름이나 다른 평가 규칙으로 참조하지 않고 평가하는 값을 즉시 직접 나타냅니다. 리터럴은 &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 의 형태 이므로 컴파일 타임에 (주로) 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">리터럴은 리터럴을 지원하지 않는 내장 속성에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="translated">약간의 알림 : 문서 주석은 문서화 할 항목 앞에 배치해야합니다. 따라서 &lt;code&gt;Island&lt;/code&gt; 특성 을 문서화하려면 내부가 아니라 그 앞에 문서 주석을 추가해야합니다. &lt;code&gt;lost&lt;/code&gt; 방법도 마찬가지입니다 . 문서 주석은 앞에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">잠긴 표준 입력은 &lt;code&gt;BufRead&lt;/code&gt; 를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">루프 표현식은 선택적으로 &lt;em&gt;레이블을&lt;/em&gt; 가질 수 있습니다 . 레이블은 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . 레이블이 있는 경우이 루프 내에 중첩 된 레이블이 지정된 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 표현식은이 루프를 종료하거나 제어를 헤드로 반환 할 수 있습니다. &lt;a href=&quot;#break-expressions&quot;&gt;break 표현식&lt;/a&gt; 및 &lt;a href=&quot;#continue-expressions&quot;&gt;continue 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">루프 표현식은 선택적으로 &lt;em&gt;label을&lt;/em&gt; 가질 수 있습니다 . 레이블은 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; 에서와 같이 루프 표현식 앞에 수명으로 기록됩니다 . } , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . 레이블이 있으면 이 루프 내에 중첩 된 &lt;code&gt;break&lt;/code&gt; 된 break 및 &lt;code&gt;continue&lt;/code&gt; 표현식이이 루프를 종료하거나 제어를 헤드로 리턴 할 수 있습니다. &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;구분 표현식&lt;/a&gt; 및 &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;계속 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="translated">루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )가 클로저 내부에서 사용되었지만 루프 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="translated">루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )가 루프 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 결과를 대체 문자 로 바꾸면 손실이있는 디코더를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="translated">낮은 범위는 높은 범위보다 작지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">매크로 호출은 컴파일 타임에 매크로를 실행하고 호출을 매크로 결과로 대체합니다. 다음과 같은 상황에서 매크로가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">가져 오기 위해 나열된 매크로를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">x86 / x86-64 플랫폼에서 CPU 기능을 사용할 수 있는지 여부 를 &lt;em&gt;런타임&lt;/em&gt; 에 테스트하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">컴파일러의 주요 목표는 라이브러리가 아티팩트에 두 번 이상 나타나지 않도록하는 것입니다. 예를 들어, 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크 된 경우, 두 개의 사본이 있으므로 상자가 B와 C에 연결할 수 없습니다. 컴파일러는 rlib와 dylib 형식을 혼합 할 수 있지만이 제한은 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로하는지도.</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">공유 참조가 안전하지 않은 것으로 간주되는 유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">&lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; 구현에 &lt;a href=&quot;trait.reversesearcher&quot;&gt; &lt;code&gt;ReverseSearcher&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있음 을 나타내는 마커 특성 입니다.</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;DoubleEndedIterator&lt;/code&gt; 구현에 &lt;code&gt;ReverseSearcher&lt;/code&gt; 를 사용할 수 있음 을 나타내는 마커 특성 .</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rust에서 &quot;panic safe&quot;유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 마커 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">단조 비 감소 클록의 측정치입니다. 불투명하고 &lt;code&gt;Duration&lt;/code&gt; 에서만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">파일 시스템이나 다른 프로세스와 같은 외부 엔터티와 통신하는 데 유용한 시스템 클록 측정입니다.</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 을 통해 표준 라이브러리의 기본값으로 등록 할 수있는 메모리 할당 자 .</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 속성을 통해 표준 라이브러리의 기본값으로 등록 할 수있는 메모리 할당 자입니다 .</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">메타 변수는 매처에서와 마찬가지로 전 사기에서 정확히 동일한 수, 종류 및 반복 순서로 나타나야합니다. 따라서 매처 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 의 경우 전사자는 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; , &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 및 &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; 입니다. 모두 불법이지만 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; 는 정확하며 쉼표로 구분 된 식별자 목록을 세미콜론으로 구분 된 목록으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">내부 유형이 완전히 알려지지 않은 원시 포인터에서 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="translated">모호한 숫자 유형에서 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="translated">기본 유형에 메소드가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="translated">다른 특성 항목이 예상 될 때 메서드가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">다른 특성 항목이 예상 될 때 방법이 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">모듈은 &lt;code&gt;std::fmt::Write&lt;/code&gt; 와 &lt;code&gt;std::io::Write&lt;/code&gt; 와 call &lt;code&gt;write!&lt;/code&gt; 모두 가져올 수 있습니다 ! 객체는 일반적으로 둘 다를 구현하지 않으므로 객체를 구현합니다. 그러나 모듈은 이름이 충돌하지 않도록 규정 된 특성을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="translated">모듈을 찾을 수 없으므로 가시성을 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">빌린 데이터 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">프로세스 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">모듈은 0 개 이상의 &lt;a href=&quot;../items&quot;&gt;항목을&lt;/a&gt; 위한 컨테이너입니다 .</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">본문이없는 모듈은 외부 파일에서로드됩니다. 모듈에 &lt;code&gt;path&lt;/code&gt; 속성 이없는 경우 파일 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 는 논리 모듈 경로를 미러링합니다 . 조상 모듈 경로 구성 요소는 디렉토리이며 모듈의 내용은 모듈 이름과 &lt;code&gt;.rs&lt;/code&gt; 확장자를 가진 파일에 있습니다. 예를 들어, 다음 모듈 구조는 해당 파일 시스템 구조를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">더 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">클로저를 사용하는 더 복잡한 패턴 :</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">보다 숙련 된 Rustacean은 대신 &lt;code&gt;&amp;amp;String&lt;/code&gt; 값과 &lt;code&gt;&amp;amp;str&lt;/code&gt; 값 모두에 동일한 함수를 사용할 수 있기 때문에 Listing 4-9에 표시된 서명을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">보다 현실적인 사용법 &lt;code&gt;!&lt;/code&gt; 이 코드에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 작업의보다 사용자 친화적이고 안정적인 버전은 &lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="translated">여러 줄 (doc-) 주석은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">변경 가능한 바인딩, 참조 또는 포인터</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 하위 범위 항목에 대해 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">동적으로 확인 된 대여 규칙이있는 변경 가능한 메모리 위치</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">변경 가능한 메모리 위치.</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut&lt;/code&gt; 하여 변경 가능한 참조를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="translated">상수에 가변 참조가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="translated">가변 변수가 사용되지만 이미 클로저에 의해 캡처되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="translated">가변 변수, 참조 또는 포인터.</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">공유 데이터 보호에 유용한 상호 배제 기본 요소</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">지명 된 주소 :</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="translated">네거티브 impl이 기본 impl로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">부정적인 구현은 유형이 특정 특성을 구현하지 못하게하는 것입니다. 특성을 사용할 수없는 것은 항상 안전한 작업이므로 부정적인 구현은 항상 안전하며 안전하지 않은 것으로 표시 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="translated">부정적인 구현은 안전하지 않은 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">부모와 자식 프로세스를 연결하기 위해 새로운 파이프를 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 유형을 통해 스폰하기 전에 새 스레드를 구성 할 수 있으며 현재 하위 스레드의 이름과 스택 크기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 새로운 스레드를 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">노드는 부모 노드를 참조 할 수 있지만 부모를 소유하지는 않습니다. Listing 15-28 에서이 새로운 정의를 사용하도록 &lt;code&gt;main&lt;/code&gt; 을 업데이트 하여 &lt;code&gt;leaf&lt;/code&gt; 노드가 부모 인 &lt;code&gt;branch&lt;/code&gt; 를 참조하는 방법을 갖도록한다 .</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="translated">비 &lt;code&gt;'static&lt;/code&gt; 수명이 const 제네릭에서 사용되었습니다. 현재 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">상수 표현식에 상수가 아닌 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="translated">기본이 아닌 구현이 이미이 유형에 대해 작성되었으므로 더 이상 전문화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">기본이 아닌 구현이이 유형에서 이미 만들어 졌으므로 더 이상 전문화 할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">경로의 최종 구성 요소가 아닌 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="translated">동일하지 않거나 와일드 카드가 아닌 패턴이 함수 포인터 유형의 매개 변수로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="translated">변경할 수없는 값에 값이 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">비원시 &lt;em&gt;바이트 문자열 리터럴&lt;/em&gt; 은 ASCII 문자 및 &lt;em&gt;이스케이프&lt;/em&gt; 시퀀스이며 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0022&lt;/code&gt; (큰 따옴표) 문자가오고 그 뒤에 &lt;code&gt;U+0022&lt;/code&gt; 문자가옵니다 . 문자 &lt;code&gt;U+0022&lt;/code&gt; 가 리터럴 내에있는 경우 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 또는 바이트 문자열 리터럴은 아래에 정의 된 &lt;em&gt;원시 바이트 문자열 리터럴&lt;/em&gt; 일 수 있습니다. 길이가 &lt;code&gt;n&lt;/code&gt; 인 바이트 문자열 리터럴의 유형 은 &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; n] .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">비 루트 모듈은 다른 상자에서 매크로를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="translated">루트가 아닌 모듈이 다른 상자에서 매크로를 가져 오려고했습니다.</target>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="translated">비 구조적 일치 유형이 const 일반 매개 변수의 유형으로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">존재하지 않는 인터페이스가 요청되었거나 요청 된 주소가 로컬이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">정상 성분, 예 및 &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;a/b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">크기가 0이 아닌 유형과 크기가 0 인 레이아웃에 대한 참고 사항 : &lt;code&gt;Alloc&lt;/code&gt; 특성의 많은 메서드는 할당 요청의 크기가 0이 아니어야합니다. 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="translated">널 &lt;code&gt;fn&lt;/code&gt; 포인터.</target>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="translated">10 진수가 아닌 기수의 숫자에는 숫자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">오버플로시 패닉 :</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="translated">매개 변수 유형에 수명 제약이 없거나 수명이 충분히 오래 지속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="translated">매개 변수 유형에 명시 적 수명 제한이 없으며 충분히 오래 지속되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">매개 변수가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">주어진 경로의 부모가 존재하지 않습니다. (디렉토리와 누락 된 모든 부모를 동시에 작성하려면 &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">특정 인스턴스 &lt;code&gt;RandomState&lt;/code&gt; 는 동일한 인스턴스 생성한다 &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 하지만, 두 가지에 의해 생성 hashers &lt;code&gt;RandomState&lt;/code&gt; 의 인스턴스는 동일한 값에 대해 동일한 결과를 생성 할 가능성이있다.</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">특정 패턴 &lt;code&gt;_&lt;/code&gt; 는 어떤 것과도 일치하지만 변수에 바인딩되지 않으므로 마지막 매치 암에서 종종 사용됩니다. &lt;code&gt;_&lt;/code&gt; 당신은 예를 들어, 지정되지 않은 값을 무시하고자 할 때 패턴이 유용 할 수 있습니다. 우리는 다룰 &lt;code&gt;_&lt;/code&gt; 에서 더 자세히 패턴 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;패턴으로 무시 값&quot;&lt;/a&gt; 섹션이 장 뒷부분을.</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">경로는 두 가지 형태를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">패턴 a &lt;code&gt;..=&lt;/code&gt; b에는 항상 &amp;le; b가 있어야합니다. 예를 들어 범위 패턴 &lt;code&gt;10..=0&lt;/code&gt; 을 갖는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">패턴이 변형에서 잘못된 수의 필드를 추출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="translated">패턴 바인딩은 유형의 변형 중 하나와 동일한 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="translated">구조체의 패턴은 구조체의 모든 필드에 대한 하위 패턴을 지정하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="translated">패턴 가드는 그들이 따르는 패턴 내에 바인딩 된 변수를 참조 할 수 있습니다. 가드를 평가하기 전에 변수가 일치하는 스크 루틴 부분에 대한 공유 참조를 가져옵니다. 가드를 평가하는 동안이 공유 참조는 변수에 액세스 할 때 사용됩니다. 가드가 참으로 평가 될 때만 값이 스크 러틴에서 변수로 이동 또는 복사됩니다. 이를 통해 가드가 일치하지 않을 경우 스크 루틴에서 벗어나지 않고도 가드 내부에서 공유 빌리기를 사용할 수 있습니다. 또한 가드를 평가하는 동안 공유 참조를 유지함으로써 가드 내부의 돌연변이도 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">패턴은 것으로 알려져 &lt;em&gt;논파&lt;/em&gt; 그것이 대해 매칭되는 값에 일치하지 않을 가능성이있는 경우. 반면 &lt;em&gt;반박 할 수없는&lt;/em&gt; 패턴은 항상 일치하는 값과 일치합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="translated">열거 형 변형과 일치하는 데 사용되는 패턴은 열거 형 변형의 각 필드에 대한 하위 패턴을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">열거 형 변형과 일치시키는 데 사용되는 패턴은 열거 형 변형의 각 필드에 대한 하위 패턴을 제공해야합니다. 이 오류는 패턴이 변형에서 잘못된 수의 필드를 추출하려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="translated">패턴이 외부 함수 선언에서 인수로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">고정 된 포인터.</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">프로그램 기간 동안 유효한 장소.</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="translated">플러그인 / 크레이트가 선언되었지만 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">플러그인 / 상자가 선언되었지만 찾을 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">특성 유형에 대한 포인터는 패턴에 의해 암시 적으로 역 참조 될 수 없습니다. 모든 특성은 유형을 정의하지만 특성 구현 자의 크기가 고정되어 있지 않기 때문에이 유형에는 컴파일 시간 크기가 없습니다. 따라서 트레이 트 유형에 대한 모든 액세스는 포인터를 통해 이루어져야합니다. 이 오류가 발생하면 포인터를 역 참조하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">힙 할당을위한 포인터 유형.</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">중독 된 한 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">A는 중독 &lt;code&gt;Once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">그러나 중독 된 뮤텍스가 기본 데이터에 대한 모든 액세스를 막지는 못합니다. &lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; 의&lt;/a&gt; 유형은이 &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; 의&lt;/a&gt; 그렇지 않으면 성공적인 잠금에 반환 된 것이다 가드를 반환하는 방법을. 이렇게하면 잠금 장치가 감염 되더라도 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">UTF-16 바이트 슬라이스에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">UTF-8 바이트 벡터에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">플랫폼 별 코드를 편리하게 작성하기위한 서문입니다.</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">이진 힙으로 구현 된 우선 순위 큐.</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="translated">공용 유형 매개 변수 바인딩에 개인 특성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">개인 특성은 공용 유형 매개 변수 바운드에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="translated">공용 유형 서명에 개인 유형이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">개인 유형은 공용 유형 서명에 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">새로운 프로세스 생성 방법을 세밀하게 제어 할 수있는 프로세스 빌더.</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">메모리 주문에 대한 빠른 정보 :</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">다양한 운동 계획을 생성하는 난수</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">아래 및 위에 포함 된 범위 ( &lt;code&gt;start..=end&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;..end&lt;/code&gt; ) 위에 만 한정된 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;..=end&lt;/code&gt; ) 에만 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;start..&lt;/code&gt; ) 이하로만 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">원시 식별자는 일반 식별자와 비슷하지만 접두사가 &lt;code&gt;r#&lt;/code&gt; 입니다. 합니다 (참고 &lt;code&gt;r#&lt;/code&gt; 프리픽스는 실제 식별자의 일부분으로서 포함되지 않는다.) 일반 식별자는 달리, 생 식별자에 대해 상기 열거 된 것들을 제외한 모든 엄격한 또는 예약어 수있다 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 원시 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="translated">후행 &lt;code&gt;#&lt;/code&gt; 개수가 선행 &lt;code&gt;#&lt;/code&gt; 개수 와 일치하지 않기 때문에 원시 문자열이 올바르게 종료 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">항상 EOF에있는 독자.</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1 바이트 이상 반복해서 반복해서 읽는 독자</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">리더 라이터 락</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="translated">재귀 유형은 간접 지정이 없기 때문에 크기가 무한합니다.</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">참조는 참조하는 데이터보다 수명이 길다.</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="translated">매달려 있거나 정렬되지 않았거나 잘못된 값을 가리키는 참조 또는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">참조는 일부 소유 가치의 대출을 나타냅니다. 값에 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 연산자를 사용하거나 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 패턴 을 사용하여 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="translated">지역 변수에 대한 참조가 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">파일 시스템에서 열린 파일에 대한 참조</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">즉, 현재 디렉토리에의 참조 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">상위 디렉토리에 대한 참조, 즉, &lt;code&gt;..&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">참조 / 포인터가 null이거나 가리키는 모든 바이트가 동일한 할당의 일부가 아닌 경우 &quot;dangling&quot;입니다 (특히 모두 &lt;em&gt;일부&lt;/em&gt; 할당 의 &lt;em&gt;일부&lt;/em&gt; 여야 함 ). 가리키는 바이트 범위는 포인터 값과 pointee 유형의 크기 ( &lt;code&gt;size_of_val&lt;/code&gt; 사용 )에 의해 결정됩니다 . 결과적으로 범위가 비어있는 경우 &quot;dangling&quot;은 &quot;non-null&quot;과 동일합니다. 슬라이스와 문자열은 전체 범위를 가리 키므로 길이 메타 데이터가 너무 크지 않아야합니다. 특히 할당 및 따라서 슬라이스 및 문자열은 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">정규 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">일반 참조는 포인터의 한 유형이며 포인터를 생각하는 한 가지 방법은 다른 곳에 저장된 값에 대한 화살표입니다. Listing 15-6에서 &lt;code&gt;i32&lt;/code&gt; 값에 대한 참조를 작성한 후 역 참조 연산자를 사용하여 데이터에 대한 참조를 따른다.</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">관련 개념은 범위입니다. 코드가 작성되는 중첩 컨텍스트에는 &quot;범위 내&quot;로 정의 된 일련의 이름이 있습니다. 코드를 읽고, 쓰고, 컴파일 할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거 형, 모듈, 상수 또는 기타 항목을 나타내는 지 여부와 해당 항목의 의미를 알아야합니다. 범위를 만들고 범위에 있거나 범위를 벗어난 이름을 변경할 수 있습니다. 같은 범위에서 같은 이름을 가진 두 항목을 가질 수 없습니다. 이름 충돌을 해결하는 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복 표현 &lt;code&gt;[x; N]&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; 복사본을 가진 배열을 생성합니다 . &lt;code&gt;x&lt;/code&gt; 의 유형은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 과의 혼동을 피하기 위해 shebang 구문에 제한이 적용됩니다 . &lt;code&gt;#!&lt;/code&gt; 문자 뒤에는 &lt;code&gt;[&lt;/code&gt; 토큰, 중간 &lt;a href=&quot;comments&quot;&gt;주석&lt;/a&gt; 또는 &lt;a href=&quot;whitespace&quot;&gt;공백을&lt;/a&gt; 무시 합니다. 이 제한이 실패하면 shebang으로 처리되지 않고 대신 속성의 시작으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">함수 본문 외부에서 return 문이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">문자열 패턴에 대한 역방향 검색 자.</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">스크루 티네는 &lt;code&gt;match&lt;/code&gt; 표현식 및 유사한 패턴 일치 구문 에서 일치하는 표현식입니다. 예를 들어, &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 에서 식 &lt;code&gt;x&lt;/code&gt; 는 스크 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">문자열 패턴을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">스트림 끝을 넘어서는 탐색이 허용되지만 동작은 구현에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로 한 세트.</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">비슷한 오류는 E0201입니다. 차이점은 하나의 선언 블록이 있는지 여부입니다. 이 오류를 피하려면 각 &lt;code&gt;fn&lt;/code&gt; 에 고유 한 이름을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">변경 가능한 참조와 변경 불가능한 참조를 결합하는 비슷한 규칙이 있습니다. 이 코드는 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">간단한 예 :</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 반환하는 간단한 함수 는 다음과 같이 정의되고 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">간단한 스핀 락 :</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">간단한 해결 방법은 도우미 메서드를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">타입을 둘러싼 간단한 래퍼로 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 (임의) 스레드는 이 함수에서 반환 할 때 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; 를 수신하고 다른 모든 스레드는 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 반환하는 결과를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 (임의의) 스레드는 이 함수 에서 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 때 is_leader 에서 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; 를 수신하고 다른 모든 스레드는 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 결과를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">단일 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 둘 이상의 바이트로 인코딩 될 수 있습니다. 이 방법은 전체 바이트 시퀀스가 ​​성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">단일 &lt;em&gt;10 진수 리터럴&lt;/em&gt; 다음에 &lt;em&gt;지수가&lt;/em&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">경로의 단일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">단일 스레드 참조 계산 포인터 'Rc'는 'Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;T&lt;/code&gt; 유형의 요소 시퀀스에 대한 '보기'를 나타내는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적 크기&lt;/a&gt; 의 유형 입니다. 슬라이스 유형은 &lt;code&gt;[T]&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;[T]&lt;/code&gt; 로 작성된 연속적인 시퀀스로 동적 크기 뷰를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경로의 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에 영향&lt;/a&gt; 을 미침 ).</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경로의 슬라이스 ( &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 유사 ).</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">버퍼로 아무것도 읽지 않는 약간 슬픈 예 :</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">주소가 이미 다른 곳에서 사용 중이므로 소켓 주소를 바인딩 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">정의의 다소 놀라운 결과 는 &lt;code&gt;Sync&lt;/code&gt; 되지 않은 돌연변이를 제공 할 수있는 것처럼 보이지만 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 &lt;code&gt;Sync&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 가 Sync 인 경우 )입니다. 트릭은 공유 참조 뒤에있는 가변 참조 ( &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; )가 &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 인 것처럼 읽기 전용이되는 것 입니다. 따라서 데이터 경쟁의 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">소스 파일에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG 프로덕션) 이있을 수 있으며 운영 체제에이 파일을 실행하는 데 사용할 프로그램을 나타냅니다. 기본적으로 소스 파일을 실행 가능한 스크립트로 취급합니다. shebang은 파일의 시작 부분 (옵션 &lt;em&gt;UTF8BOM&lt;/em&gt; 이후)에서만 발생할 수 있습니다 . 컴파일러는이를 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="translated">반복기 파이프 라인의 소스 단계.</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O 작업에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">스레드에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 스 플라이 싱 반복자 .</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="translated">안정성 속성이 표준 라이브러리 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="translated">표준 라이브러리 외부에서 안정성 속성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">안정성 속성은 표준 라이브러리 외부에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">명령문은 컴퓨터가 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립형 요소입니다.</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="translated">진술.</target>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="translated">정적 항목은 프로그램의 전체 기간 ( &lt;code&gt;'static&lt;/code&gt; 수명) 동안 유효한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 ( &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; )은 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; )로 구성되고 바이트 벡터 ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; )는 바이트로 구성 되므로이 함수는 둘 사이를 변환합니다. 모든 바이트 조각이 유효 &lt;code&gt;String&lt;/code&gt; 그러나, S : &lt;code&gt;String&lt;/code&gt; 이 유효한 UTF-8해야합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">현재 사용중인 CPU 아키텍처를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">사용중인 특정 운영 체제를 설명하는 문자열입니다. 예제 값은 &lt;code&gt;linux&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '왼쪽'은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것이다 &lt;em&gt;우측&lt;/em&gt; 측면이 아닌 왼쪽.</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '오른쪽'은 해당 바이트 문자열의 마지막 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것입니다 &lt;em&gt;왼쪽&lt;/em&gt; 측면하지 않을 권리.</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 컨텍스트에서 &lt;code&gt;end&lt;/code&gt; 은 해당 바이트 문자열의 마지막 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 오른쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 왼쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;end&lt;/code&gt; 은 해당 바이트 문자열의 마지막 위치를 의미합니다. 영어 나 러시아어와 같이 왼쪽에서 오른쪽으로 쓰는 언어의 경우 오른쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 왼쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 컨텍스트에서 &lt;code&gt;start&lt;/code&gt; 은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 왼쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 오른쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;start&lt;/code&gt; 은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 왼쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 오른쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">문자열 리터럴은 최종 바이너리에 직접 저장된 문자열이므로 &lt;code&gt;'static&lt;/code&gt; 지속 기간 동안 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">문자열 패턴.</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; )로 구성되고 바이트 슬라이스 ( &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; )는 바이트로 구성 되므로이 함수는 둘 사이를 변환합니다. 모든 바이트 슬라이스가 유효한 문자열 슬라이스는 아니지만 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 하려면 유효한 UTF-8 이어야 합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) 로 만들어지고 바이트 벡터 ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; )는 바이트로 만들어 지므로이 함수는 둘 사이를 변환합니다. 그러나 모든 바이트 슬라이스가 유효한 &lt;code&gt;String&lt;/code&gt; 은 아닙니다 . &lt;code&gt;String&lt;/code&gt; 은 유효한 UTF-8이어야합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">문자열 슬라이스는 Rust에서 가장 원시적 인 문자열 유형으로 &lt;code&gt;str&lt;/code&gt; 로 작성됩니다 . 종종 빌린 형태로 변경 가능하거나 공유됩니다. 공유 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 이고 변경 가능한 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;mut str&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">구조체가 될 수 있습니다 &lt;code&gt;Copy&lt;/code&gt; 하고, &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이다 &lt;code&gt;Copy&lt;/code&gt; 따라서 &lt;code&gt;Point&lt;/code&gt; 가 될 자격이 &lt;code&gt;Copy&lt;/code&gt; . 대조적으로, 고려</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="translated">개인 필드가있는 구조체 생성자가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">개인 필드가있는 구조체 생성자가 호출되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">공황의 위치에 대한 정보를 포함하는 구조체.</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">구조체 식은 구문 &lt;code&gt;..&lt;/code&gt; 으로 끝나고 기능 업데이트를 나타내는식이 뒤따를 수 있습니다 . &lt;code&gt;..&lt;/code&gt; (기본) 다음에 나오는 표현식 은 새로운 struct 유형과 동일한 struct 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">중괄호로 묶인 필드가있는 구조체 표현식을 사용하면 각 개별 필드의 값을 임의의 순서로 지정할 수 있습니다. 필드 이름은 콜론으로 값과 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">괄호로 묶인 필드가있는 구조체 표현식은 튜플 구조체를 구성합니다. 여기에는 완전성을위한 특정 표현식으로 나열되어 있지만 튜플 구조체의 생성자 에 대한 &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; 과 동일합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="translated">구조체 패턴이 구조체에서 존재하지 않는 필드를 추출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">하위 패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">공황에 관한 정보를 제공하는 구조체.</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt; 구현 을 돕는 구조체 입니다.</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="translated">동일한 이름을 가진 두 개의 필드로 구조체가 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 접근 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 수정 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 조정되지 않은 유형을 포함하는 필드가 둘 이상인 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . 구조체의 형식 중 하나를 구조체의 다른 형식으로 강제 변환하려는 경우에만 발생합니다. 이 경우 구조체가 취하는 두 가지 유형 인 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로묵시 하려고합니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">표현 힌트 &lt;code&gt;repr(transparent)&lt;/code&gt; 가 있는 구조체 는 0 또는 두 개 이상의 필드를 갖지만 크기가 0이 아님을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 지정되지 않은 유형을 포함하는 필드가없는 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="translated">구조체 또는 구조체와 유사한 열거 형 변형의 필드가 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="translated">구조체 또는 구조체와 유사한 열거 형 변형의 필드가 두 번 이상 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 표현 힌트 와 구조체, 열거 또는 공용체는 사소한 정렬이 필요한 크기가 0 인 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">유닉스 도메인 소켓 서버를 나타내는 구조.</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">각 파일 형식에 대한 접근자가있는 파일 형식을 나타내는 구조입니다. &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">구문 분석되지 않은 문자열 표현뿐만 아니라 Windows 경로 접두사를 래핑하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="translated">구조 또는 열거 형 변형이 아닌 항목을 만드는 데 구조 리터럴 구문이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="translated">성공적인 변환은 끝 nul 바이트없이 호출 될 때 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널의 다른 쪽 끝이 이미 끊지 않았다고 판단되면 성공적으로 전송됩니다. 실패한 송신은 해당 수신자가 이미 할당 해제 된 것입니다. &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 의 반환 값은 데이터가 수신 되지 &lt;em&gt;않음을&lt;/em&gt; 의미 하지만 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 반환 값이 데이터가 수신됨을 의미 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 이 함수가 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; 를&lt;/a&gt; 반환 한 직후에 해당 수신기가 끊어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">접미사는 리터럴의 주요 부분 바로 뒤에 나오는 공백이 아닌 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="translated">자동 특성에 슈퍼 특성이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일회성 전역 초기화를 실행하는 데 사용할 수있는 동기화 기본 요소입니다. FFI 또는 관련 기능에 대한 일회성 초기화에 유용합니다. 이 유형은 &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new()&lt;/code&gt; &lt;/a&gt; 로만 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">일회성 글로벌 초기화를 실행하는 데 사용할 수있는 동기화 기본 요소. FFI 또는 관련 기능의 일회성 초기화에 유용합니다. 이 유형은 &lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt; 값 또는 동등한 &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt; 생성자 로만 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">동기적이고 제한된 채널. &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 의&lt;/a&gt; 함수 반환 &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 보류 된 메시지의 저장이 고정 된 크기의 사전 - 할당 된 버퍼이다 튜플. 사용 가능한 버퍼 공간이 확보 될 때까지 차단하여 모든 송신이 &lt;strong&gt;동기&lt;/strong&gt; 됩니다. 0의 경계가 허용되므로 채널은 각 발신자가 원자 적으로 수신자에게 메시지를 전달하는 &quot;랑데부&quot;채널이됩니다.</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">구문 생산</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">차용이 아직 활성 상태 인 동안 임시 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">스레드는 &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 을&lt;/a&gt; 통해 값을 반환 할 수도 있습니다.이를 사용하여 비동기 계산을 수행 할 수 있습니다 (미래가 더 적합 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">내용을 소유하는 스레드 로컬 스토리지 키.</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">당황하지 않고 완료된 스레드는 성공적으로 종료 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">스레드 로컬 키는 포함 된 값을 소유하며 스레드가 종료되면 값을 삭제합니다. &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; 로 작성됩니다 ! 매크로이며 &lt;code&gt;'static&lt;/code&gt; (임대 된 포인터 없음) 인 값을 포함 할 수 있습니다 . &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 접근 자 함수를 제공 하여 지정된 클로저에 대한 값에 대한 공유 참조를 생성합니다. 스레드 로컬 키는 변경 가능한 차용이 허용 된 경우 고유성을 보장 할 방법이 없으므로 값에 대한 공유 액세스 만 허용합니다. 대부분의 값은 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; 유형을 통해 어떤 형태의 &lt;strong&gt;내부 변이성&lt;/strong&gt; 을 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">스레드 안전 레퍼런스 카운팅 포인터. 'Arc'는 'Atomically Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">어휘 분석기에서 생산 한 토큰</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">후행 슬래시는 &lt;code&gt;/a/b&lt;/code&gt; 및 &lt;code&gt;/a/b/&lt;/code&gt; 정규화됩니다. 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">&quot; &lt;code&gt;?Sized&lt;/code&gt; 에있는 특성은 &lt;code&gt;Sized&lt;/code&gt; 에 대한 특성과 반대입니다 . 우리는 이것을 &quot; &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Sized&lt;/code&gt; 가 될 수도 있고 그렇지 않을 수도 있습니다 &quot;라고 읽습니다 . 이 구문은 &lt;code&gt;Sized&lt;/code&gt; 다른 특성이 아닌 Sized .</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">특성은 본문에 여러 메소드를 가질 수 있습니다. 메소드 서명은 한 줄에 하나씩 나열되고 각 줄은 세미콜론으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">데이터를 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">값을로 변환하는 특성 &lt;code&gt;String&lt;/code&gt; 으로 .</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">의 행동을 사용자 정의하기위한 특성 &lt;code&gt;?&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">유형에 유용한 기본값을 제공하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">임의의 바이트 스트림을 해시하는 특성.</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수 에서 임의의 리턴 유형을 구현하기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">데이터를 변경 가능하게 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">바이트 지향 싱크 인 객체의 특성.</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 값 으로 변환되거나 해석 될 수있는 객체의 특성입니다 .</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="translated">특성 구현에는 특성 정의보다 더 엄격한 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">고아 검사가 실패하거나 구현 인스턴스가 겹치는 경우 특성 구현이 일관성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="translated">고아 규칙 검사가 실패하거나 겹치는 구현 인스턴스가있는 경우 특성 구현은 일관성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">특성 구현은 구현 된 특성에 의해 선언 된 모든 비 기본 연관 항목을 정의해야하며 구현 된 특성에 의해 정의 된 기본 연관 항목을 재정의 할 수 있으며 다른 항목을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="translated">특성 구현은 특성이 안전하지만 안전하지 않은 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">특성은 유형이 제공해야하는 기능을 설명하는 데 사용되는 언어 항목입니다. 형식이 동작에 대해 특정 약속을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;고아 규칙&lt;/a&gt; 이 다른 일반 유형에 대해 방지 하는 &lt;code&gt;T&lt;/code&gt; 와 동일한 상자에서 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 에 대해 특성이 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="translated">특성 메서드가 const로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">형질 개체는 완전히 정의 된 단일 특성에 대해 정의됩니다. 일반 기본 매개 변수를 사용하면이 매개 변수를 대체 할 수 있습니다. 그러나 기본 매개 변수가 &lt;code&gt;Self&lt;/code&gt; 인 경우 각 콘크리트 유형에 따라 특성이 변경됩니다. 즉,이 &lt;code&gt;i32&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; 등 ...이 유형은 완전히 정의 된 특성의 구현을 공유하지 않습니다. 대신 각 구현에 대해 다른 매개 변수로 대체 된 특성의 구현을 공유합니다. 이것은 특질 대상을 작동시키는 데 필요한 것과 양립 할 수 없으므로 허용되지 않습니다. 기본 매개 변수의 값을 명시 적으로 지정하여 특성을 구체적으로 만들면이 문제가 해결됩니다. 고정 된 예 :</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="translated">특성이없는 특성 개체가 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="translated">동적 타이핑을 모방하는 특성.</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">원시 파일 디스크립터에서 오브젝트를 구성하는 기능을 표현하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;HANDLE&lt;/code&gt; 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;SOCKET&lt;/code&gt; 의 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">객체를 소비하고 원시 파일 디스크립터의 소유권을 얻는 기능을 표현하는 특성.</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">기본 개체에서 원시 unix 파일 설명자를 추출하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="translated">특성 유형이 역 참조되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="translated">이미 자동으로 구현 된 다른 특성이 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">투명한 구조체, 열거 형 또는 공용체는 포함 된 데이터와 똑같이 표현되어야합니다. 다른 정렬 요구 사항을 가진 크기가 0 인 필드는이 속성과 충돌 할 가능성이 있습니다. 위의 예에서, &lt;code&gt;f32&lt;/code&gt; 는 더 작은 정렬 요구 사항을 갖 더라도 &lt;code&gt;Wrapper&lt;/code&gt; 는 32 바이트로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">시그마를 사용한 까다로운 예 :</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 사용법의 간단한 예 ,</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">튜플 &lt;em&gt;유형&lt;/em&gt; 은 튜플 의 &lt;em&gt;요소&lt;/em&gt; 라고하는 다른 유형의 이기종 곱입니다 . 명목 이름이 없으며 구조적으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">튜플 인덱스는 &lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;items/enumerations&quot;&gt;튜플 변형&lt;/a&gt; 의 필드를 참조하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">튜플은 다양한 유형의 여러 값을 하나의 복합 유형으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언되면 크기가 늘어나거나 줄어들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">튜플은 다양한 유형의 여러 다른 값을 하나의 복합 유형으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언하면 크기를 늘리거나 줄일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="translated">튜플 구조체 또는 튜플 변형은 마치 구조체 또는 구조체 변형 인 것처럼 패턴에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">튜플 구조체 패턴은 하위 패턴 중 하나가 반박 가능할 때 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">튜플 구조체의 요소는 &lt;code&gt;#[simd]&lt;/code&gt; 속성을 사용할 때 머신 유형이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/enum.infallible&quot;&gt; &lt;code&gt;Infallible&lt;/code&gt; &lt;/a&gt; 의 유형 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">중독 될 수있는 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">비 블로킹 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">타입 별칭은 반복을 줄임으로써이 코드를보다 관리하기 쉽게 만듭니다. Listing 19-25에서는 상세 유형에 &lt;code&gt;Thunk&lt;/code&gt; 라는 별명을 도입 했으며이 유형의 모든 사용을 더 짧은 별명 &lt;code&gt;Thunk&lt;/code&gt; 로 대체 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="translated">tuple-struct 또는 unit-struct에 대한 형식 별칭은 해당 형식의 생성자를 한정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">열거 형에 대한 유형 별칭은 생성자를 한정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 로 주석이 달린 유형 은 모든 표현 문제를 다른 유형으로 위임하므로 더 많은 표현 힌트를 추가하는 것은 모순됩니다. 다음과 같이 &lt;code&gt;transparent&lt;/code&gt; 힌트 또는 다른 힌트를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">유형에는 여러 고유 구현이있을 수도 있습니다. 구현 유형은 원래 유형 정의와 동일한 상자 내에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">모든 구성 요소가 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 형식은 &lt;code&gt;Copy&lt;/code&gt; 를 구현할 수 있습니다 . 예를 들어이 구조체는 &lt;code&gt;Copy&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">유형 캐스트 ​​표현식은 이항 연산자 &lt;code&gt;as&lt;/code&gt; 로 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="translated">유형 종속성주기가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="translated">형식에는 &lt;code&gt;packed&lt;/code&gt; 및 &lt;code&gt;align&lt;/code&gt; 표시 힌트 가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="translated">유형에 충돌하는 &lt;code&gt;packed&lt;/code&gt; 표현 힌트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">&lt;code&gt;Try&lt;/code&gt; 를 구현하는 형식 은 성공 / 실패 이분법으로 볼 수있는 정식 방법이있는 유형 입니다. 이 특성을 통해 기존 인스턴스에서 해당 성공 또는 실패 값을 추출하고 성공 또는 실패 값에서 새 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">시간 종료로 인해 조건 변수에 대한 시간 종료 대기가 리턴되는지 여부를 표시하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="translated">생성자가있는 경우 형식이 존재하므로 인스턴스화 할 수 있습니다. 거주 유형은 유형의 값이있을 수 있다는 점에서 &quot;비어있는&quot;것이 아닙니다. &lt;a href=&quot;#uninhabited&quot;&gt;무인도의&lt;/a&gt; 반대 .</target>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="translated">생성자가없는 형식은 사람이 살지 않으므로 인스턴스화 할 수 없습니다. 무인 유형은 유형의 값이 없다는 의미에서 &quot;비어 있습니다&quot;. 무인 유형의 표준 예는 &lt;a href=&quot;types/never&quot;&gt;never 유형입니다 &lt;/a&gt; &lt;code&gt;!&lt;/code&gt; , 또는 변형이없는 &lt;code&gt;enum Never { }&lt;/code&gt; . 의 반대 &lt;a href=&quot;#inhabited&quot;&gt;거주 된&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="translated">유형이 관련 유형의 특성과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">잠금을 획득 할 때마다 리턴 될 수있는 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="translated">유형 또는 수명 매개 변수가 선언되었지만 실제로 사용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">유형 또는 모듈이 두 번 이상 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 에 지정된 유형 매개 변수 는 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">기존 매개 변수를 음영 처리하는 유형 매개 변수가 선언되었습니다. 이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="translated">기본값으로 &lt;code&gt;Self&lt;/code&gt; 를 참조하는 유형 매개 변수가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">기본값에서 &lt;code&gt;Self&lt;/code&gt; 를 참조하는 유형 매개 변수가 지정되지 않았습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="translated">기본값이있는 유형 매개 변수는 앞으로 선언 된 식별자를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">중간에 널 바이트가없는 고유 한 C 호환 널 종료 문자열을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">여러 변형 중 하나 일 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">소유하고 변경 가능한 플랫폼 네이티브 문자열을 나타낼 수 있지만 Rust 문자열과 저렴하게 상호 변환 할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">다른 유형으로 구성된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">특성이 아닌 유형이 bound 또는 &lt;code&gt;impl&lt;/code&gt; 과 같은 특성 위치에 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">동적 타이핑을 에뮬레이트하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 메서드에 전달 된 버퍼를 조건부로 초기화하는 데 사용되는 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="translated">다른 유형에 대한 인수로 나타나지 않는 유형입니다. 예를 들어, &lt;code&gt;T&lt;/code&gt; 는 발견되었지만 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 덮여있다. 이것은 유형 인수에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 표현 힌트가있는 유형에는 &lt;code&gt;align&lt;/code&gt; 표현 힌트 가있는 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">유형의 동작은 해당 유형을 호출 할 수있는 메소드로 구성됩니다. 모든 유형에서 동일한 메소드를 호출 할 수 있으면 다른 유형이 동일한 동작을 공유합니다. 특성 정의는 몇 가지 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메소드 서명을 그룹화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공용체 액세스는 공용체의 내용을 액세스 된 필드의 유형으로 변환합니다. 변환은 예기치 않은 동작이나 정의되지 않은 동작을 유발할 수 있으므로 공용 필드에서 읽거나 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현하지 않는 필드에 쓰려면 &lt;code&gt;unsafe&lt;/code&gt; 것이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유니온 선언 제외하고, 구조체 선언과 같은 구문을 사용하여 &lt;code&gt;union&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">노조는 선언 &lt;code&gt;#[repr(C)]&lt;/code&gt; 타겟 플랫폼에 대한 C 언어의 등가 C 조합 선언 같은 것 같은 크기와 정렬. 공용체는 모든 필드의 최대 크기를 정렬로 반올림하고 모든 필드의 최대 정렬을 정렬합니다. 이 최대 값은 다른 필드에서 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">실행중인 스레드의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">유닛 구조체 표현식은 유닛 구조체 아이템의 경로 일뿐입니다. 이것은 단위 구조체의 값의 암시 적 상수를 나타냅니다. 단위 구조체 값은 필드없는 구조체 식으로 구성 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">인식 할 수없는 표현 속성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="translated">사용 된 유형 이름이 범위에 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">비어있는 항목.</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">A의 값 &lt;code&gt;char&lt;/code&gt; 대리 또는 이상 &lt;code&gt;char::MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">정확히 하나의 필드를 지정해야한다는 점을 제외하고이 구문을 사용하여 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 유형 의 값을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">구조체 유형에 사용되는 것과 동일한 구문을 사용하여 유니온 유형의 값을 만들 수 있습니다. 단 하나의 필드 만 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;false를&lt;/strong&gt; 나타내는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;true를&lt;/strong&gt; 나타내는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;false를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;true를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">입력 값 &lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 스칼라 값&lt;/a&gt; 0x10FFFF 범위 0xD7FF 또는 0xE000 행 0000의 32 비트 부호 워드로 표현 (대리없는 즉 코드 포인트). &lt;code&gt;[char]&lt;/code&gt; 효과적으로 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 유형의 값은 0x0000에서 0xD7FF 또는 0xE000에서 0x10FFFF 범위의 32 비트 부호없는 단어로 표시 되는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; (즉, 서로 게이트가 아닌 코드 포인트)입니다. 이 범위를 벗어나는 &lt;code&gt;char&lt;/code&gt; 를 만드는 것은 즉시 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. &lt;code&gt;[char]&lt;/code&gt; 유효 길이 1의 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 유형의 값은 UTF-8 코드 포인트 시퀀스를 보유하는 8 비트 부호없는 바이트의 배열로 표시되는 유니 코드 문자열입니다. 이후 &lt;code&gt;str&lt;/code&gt; A는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적으로 크기 유형&lt;/a&gt; , 그것은 아닙니다 &lt;em&gt;일류&lt;/em&gt; 유형,하지만 같은 포인터 타입을 통해 인스턴스화 할 수 &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 유형의 값은 &lt;code&gt;[u8]&lt;/code&gt; 과 같은 방식으로 표현되며 8 비트 부호없는 바이트의 조각입니다. 그러나, 녹 표준 라이브러리에 대해 별도의 가정을 &lt;code&gt;str&lt;/code&gt; : 작업 방법 &lt;code&gt;str&lt;/code&gt; 가정 및 데이터에 유효한 UTF-8이 있음을 확인합니다. 비 UTF-8 버퍼 로 &lt;code&gt;str&lt;/code&gt; 메서드를 호출하면 현재 또는 미래에 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) 또는 &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 이외의 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">복사가 아닌 고정 크기 배열에서 값이 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">아직 빌린 동안 가치가 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="translated">컴파일시 크기를 알 수없는 값이 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">값이 이동되었습니다. 그러나 크기는 컴파일 타임에 알려지지 않았으며 알려진 크기의 값만 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">변경 가능하게 빌린 후에 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="translated">사용자 지정 &lt;code&gt;Drop&lt;/code&gt; 구현이있는 값은 const-eval 중에 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">고정 된 값은 해당 유형이 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 한 영구적으로 고정 된 상태를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 값을 사용하는 값-값 변환입니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="translated">이미 불변으로 차용 된 변수는 변할 수있는 것으로 차용되었습니다.</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">변수에 값이 할당되었고 그 이후로 이동하지 않은 경우 변수가 초기화됩니다. 다른 모든 메모리 위치는 초기화되지 않은 것으로 가정합니다. 안전하지 않은 Rust만이 메모리를 초기화하지 않고 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="translated">내부 함수 내에서 사용되는 변수는 동적 환경에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="translated">변수가 두 번 이상 가변으로 빌려졌습니다.</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">변수가 두 번 이상 변경 가능하도록 빌 렸습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="translated">내용이 다른 곳으로 이동 된 후 변수가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="translated">고유 액세스가 필요한 변수가 동시에 둘 이상의 클로저에서 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">매우 일반적인 입력 소스는 표준 입력입니다.</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">두 개의 측면을 갖는 &lt;code&gt;Balance&lt;/code&gt; 구조체 의 매우 간단한 구현으로, 각면은 변경 가능하고 불변으로 인덱싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">비어 있거나 점유 될 수있는 맵의 단일 항목에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 의 동작을 지정하는 가상 함수 포인터 테이블 (vtable)입니다 .</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="translated">가시성 한정자가 불필요 할 때 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">불필요 할 때 가시성 한정자가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-let 패턴은 패턴과 일치하려고 시도하고 일치하면 본문에 들어갑니다. 일치 할 수없는 경우 (일치 할 수없는 경우) 대신 &lt;code&gt;loop&lt;/code&gt; 내에서 규칙적인 &lt;code&gt;let&lt;/code&gt; - binding을 사용하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="translated">슬라이스 의 시작 부분에서 시작하여 겹치는 청크 ( 한 번에 &lt;code&gt;N&lt;/code&gt; 개의 요소)에 있는 슬라이스에 대한 윈도우 반복기</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">이 문제에 대한 해결 방법은 구조체에서 특성을 마무리하고 Drop을 구현하는 것입니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="translated">이 문제에 대한 해결 방법은 특성을 구조체로 래핑하고 Drop을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">작동하는 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 의 래퍼</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">컴파일러가 &lt;code&gt;T&lt;/code&gt; 의 소멸자 를 자동으로 호출하지 못하게하는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="translated">컴파일러가 &lt;code&gt;T&lt;/code&gt; 의 소멸자 를 자동으로 호출하지 못하도록하는 래퍼 입니다. 이 래퍼는 비용이 0입니다.</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서 차용 한 값의 래퍼 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;T&lt;/code&gt; 인스턴스를 생성하는 래퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">데이터를 빈 공간으로 이동시키는 라이터.</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">yank &lt;em&gt;는&lt;/em&gt; 코드를 삭제 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어, yank 기능은 실수로 업로드 한 비밀을 삭제하기위한 것이 아닙니다. 이 경우 해당 비밀을 즉시 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="translated">생성기 리터럴 외부에서 yield 표현식이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI, 링크, 심볼 및 FFI</target>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux 용이 아닌 &lt;code&gt;armv5te&lt;/code&gt; 와 같은 ARM 플랫폼에는 원자가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; 이있는 ARM 대상에는 전혀 원자 연산이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII 바이트 리터럴</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">ASCII 이스케이프</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'A'~ 'Z'는 'a'~ 'z'에 매핑되지만 비 ASCII 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'a'에서 'z'는 'A'에서 'Z'로 매핑되지만 ASCII가 아닌 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">메모리 할당 오류 또는 실패시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">프로세스 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">추상 반환 유형</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">(작성 추상 반환 형식 &lt;code&gt;impl Trait&lt;/code&gt; 일부 특성에 대한 &lt;code&gt;Trait&lt;/code&gt; ) 단지 기능과 고유 IMPL 반환 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">추상 구문 트리</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">이 리스너로부터 새로운 수신 연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">명령 줄 인수 수락</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; 주문을 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">이 리스너에 대한 새로운 수신 연결을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">키와 해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">키로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">패킹 된 구조체의 필드에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">&lt;a href=&quot;keyword.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 의 액세스 필드</target>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 의 액세스 필드</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">패킹 된 구조체의 멤버에 참조로 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">변경 가능한 정적 변수 액세스 또는 수정</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">이 오류의 원인이 된 기본 UTF-8 오류에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">배열 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="translated">연합의 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">해시 맵에서 값에 액세스</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">할당 이외 의 &lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 필드 액세스</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">인접 액세스 &lt;code&gt;u8&lt;/code&gt; 같은 &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">힙에있는 데이터에 액세스하려면 포인터를 따라 가야하므로 스택의 데이터에 액세스하는 것보다 속도가 느립니다. 메모리가 적을수록 최신 프로세서가 더 빠릅니다. 유추를 계속하면서 식당의 서버에서 많은 테이블의 주문을 고려하십시오. 다음 테이블로 넘어 가기 전에 한 테이블에서 모든 주문을받는 것이 가장 효율적입니다. 테이블 A에서 주문을 가져온 다음 테이블 B에서 주문을 가져온 다음 A에서 다시 한 번 주문한 다음 B에서 다시 한 번 주문하면 훨씬 느려집니다. 같은 방식으로 프로세서는 스택에있는 것처럼 다른 데이터에 가까운 데이터 (더 많은 힙에있을 수 있음)가 아닌 다른 데이터에 대해 작동하는 경우 더 잘 작업 할 수 있습니다. 힙에 많은 공간을 할당하는 데에도 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f239f31c4b24ce084fa39af1811c8d4fc4e10b36" translate="yes" xml:space="preserve">
          <source>Accessing non-&lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt;&lt;code&gt;static&lt;/code&gt; items is considered safe, but some restrictions apply. Most notably, the type of a &lt;code&gt;static&lt;/code&gt; value needs to implement the &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait, ruling out interior mutability containers like &lt;a href=&quot;cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../reference/items/static-items&quot;&gt;Reference&lt;/a&gt; for more information.</source>
          <target state="translated">비 액세스 &lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; 항목은 안전한 것으로 간주하지만, 몇 가지 제한 사항이 적용됩니다. 특히, &lt;code&gt;static&lt;/code&gt; 값 의 유형은 &lt;a href=&quot;cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; 과 같은 내부 가변성 컨테이너를 배제 하여 &lt;a href=&quot;marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 특성 을 구현해야합니다 . 자세한 내용은 &lt;a href=&quot;../reference/items/static-items&quot;&gt;참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">가변 정적 변수 액세스 또는 수정</target>
        </trans-unit>
        <trans-unit id="f13080b643bf72eee286858a8d7c3ab06b544915" translate="yes" xml:space="preserve">
          <source>Accessing unaligned fields directly with e.g. &lt;code&gt;packed.unaligned&lt;/code&gt; is safe however.</source>
          <target state="translated">그러나 예를 들어 &lt;code&gt;packed.unaligned&lt;/code&gt; 를 사용 하여 정렬되지 않은 필드에 직접 액세스하는 것은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">패키지를 정확하게 문서화하면 다른 사용자가 언제 어떻게 사용해야하는지 알 수 있으므로 문서를 작성하는 데 시간을 투자하는 것이 좋습니다. 3 장에서 두 개의 슬래시 ( &lt;code&gt;//&lt;/code&gt; 사용하여 Rust 코드를 주석 처리하는 방법에 대해 설명했습니다 . Rust는 HTML 문서를 생성 하는 &lt;em&gt;문서 주석&lt;/em&gt; 으로 편리하게 알려진 문서에 대한 특정 종류의 주석도 가지고 있습니다. HTML 은 크레이트가 &lt;em&gt;구현&lt;/em&gt; 되는 방식과 달리 크레이트 를 &lt;em&gt;사용&lt;/em&gt; 하는 방법을 알고 자하는 프로그래머를위한 공개 API 항목에 대한 문서 주석의 내용을 표시합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">획득-잠금 획득 장벽. 후속 읽기 및 쓰기는 장벽 이후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">소유 한 데이터 형식에 대한 변경 가능한 참조를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">현재 스레드를 차단할 수있을 때까지 뮤텍스를 획득합니다.</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">이 TLS 키의 값에 대한 참조를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">기본 &lt;code&gt;*mut&lt;/code&gt; 포인터를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">현재 실행 파일의 경로를 얻는 것은 여러 가지 이유로 실패 할 수있는 플랫폼 별 작업입니다. 일부 오류에는 파일 시스템 조작 실패 또는 일반 syscall 실패가 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">활성 및 비활성 속성</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">두 리더를 연결하는 어댑터.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="5377ba24487df148115875083e9ad3100b466293" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;'static&lt;/code&gt; requirement to fix them:</source>
          <target state="translated">이를 수정하기위한 &lt;code&gt;'static&lt;/code&gt; 요구 사항 ' 추가 :</target>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">게시물 상태를 &lt;code&gt;PendingReview&lt;/code&gt; 에서 &lt;code&gt;Draft&lt;/code&gt; 로 다시 변경 하는 &lt;code&gt;reject&lt;/code&gt; 메소드를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">검색 결과에 상자와 함께 표시되므로 한두 문장으로 된 설명을 추가하십시오. 를 들어 &lt;code&gt;license&lt;/code&gt; 필드, 당신은 줄 필요가 &lt;em&gt;라이센스 식별자 값을&lt;/em&gt; . &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;리눅스 재단의 소프트웨어 패키지 데이터 교환 (SPDX)는&lt;/a&gt; 이 값에 사용할 수있는 식별자를 나열합니다. 예를 들어, MIT 라이센스를 사용하여 상자에 라이센스를 부여하도록 지정하려면 &lt;code&gt;MIT&lt;/code&gt; 식별자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">게터 함수를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">아이템을 사용하기 위해 지켜야하는 제약 조건을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 및 공용 메소드에 더 많은 문서를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">라이브러리 기능 테스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">필드의 크기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">추가 &lt;code&gt;rand&lt;/code&gt; 에서 종속성으로 &lt;em&gt;Cargo.toml가&lt;/em&gt; 다운로드하는화물을 말한다 &lt;code&gt;rand&lt;/code&gt; 패키지에서 종속성 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io을&lt;/a&gt; 하고 만들 &lt;code&gt;rand&lt;/code&gt; 우리의 프로젝트에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">범위에 &lt;code&gt;use&lt;/code&gt; 및 경로를 추가 하는 것은 파일 시스템에서 심볼릭 링크를 만드는 것과 유사합니다. 추가함으로써 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; , 나무 상자 루트에 &lt;code&gt;hosting&lt;/code&gt; 유효한 이름은 단지 것처럼, 그 범위에 지금 &lt;code&gt;hosting&lt;/code&gt; 모듈이 상자 루트에 정의되었다. &lt;code&gt;use&lt;/code&gt; 범위에 포함 된 경로는 다른 경로와 마찬가지로 개인 정보를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">사용자 정의 실패 메시지 추가</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">새 상자에 메타 데이터 추가</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">파생 속성으로 유용한 기능 추가</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 필드를 형식에 추가하면 형식 이 실제로는 아니지만 형식이 &lt;code&gt;T&lt;/code&gt; 형식의 값을 저장하는 것처럼 작동한다고 컴파일러에 알립니다 . 이 정보는 특정 안전 속성을 계산할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">&lt;code&gt;Self: Sized&lt;/code&gt; 추가 : 이러한 메소드에 바인딩 된 크기 는 일반적으로이 컴파일을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">자식에서 부모로 참조 추가</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">작업 공간에 테스트 추가</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 필드를 추가하면 유형에 &lt;code&gt;T&lt;/code&gt; 유형의 데이터가 있음을 나타냅니다 . 이는 유형이 삭제되면 유형 &lt;code&gt;T&lt;/code&gt; 의 하나 이상의 인스턴스가 삭제 될 수 있음을 의미합니다 . 이것은 Rust 컴파일러의 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;드롭 체크&lt;/a&gt; 분석과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">문서 주석에 예제 코드 블록을 추가하면 라이브러리 사용 방법을 설명하는 데 도움이되며 추가 보너스가 있습니다. &lt;code&gt;cargo test&lt;/code&gt; 를 실행하면 문서의 코드 예제가 테스트로 실행됩니다! 예제가있는 문서보다 낫지는 않습니다. 그러나 문서가 작성된 후 코드가 변경되어 작동하지 않는 예제보다 나쁜 것은 없습니다. Listing 14-1 의 &lt;code&gt;add_one&lt;/code&gt; 함수에 대한 문서를 사용하여 &lt;code&gt;cargo test&lt;/code&gt; 를 실행 하면 테스트 결과에 다음과 같은 섹션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 의 동작을 변경 하는 &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; 메소드 추가</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;You win!&lt;/code&gt; 후 &lt;code&gt;break&lt;/code&gt; 라인 추가 ! 사용자가 비밀 번호를 올바르게 추측하면 프로그램이 루프를 종료합니다. 루프가 &lt;code&gt;main&lt;/code&gt; 의 마지막 부분이기 때문에 루프를 종료한다는 것은 프로그램을 종료하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 키워드를 추가하면 변경 가능한 참조가 역 참조됩니다. 변경 가능성은 참조의 변경 가능성과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">추가 과제</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">숫자에 대한 추가 기능.</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">추가 구현 자</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">추가 매개 변수가 &lt;code&gt;format!&lt;/code&gt; 전달되었습니다 ! 명명 된 또는 위치 매개 변수가 사용되지 않는 한 지정된 순서로 형식화 문자열 내의 &lt;code&gt;{}&lt;/code&gt; 을 대체하십시오 . 자세한 내용은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b89443b71b82e921f27bf8622eec75e5bb710e5e" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 추가 매개 변수가 전달되었습니다 ! 명명 된 매개 변수 또는 위치 매개 변수가 사용되지 않는 한 지정된 순서대로 형식화 문자열 내 에서 &lt;code&gt;{}&lt;/code&gt; 를 대체하십시오 . 자세한 내용은 &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5cf45e8eb3455f9aeaa5f7fa4c013c3116744f0" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;f32&lt;/code&gt; can represent a couple of special values:</source>
          <target state="translated">또한 &lt;code&gt;f32&lt;/code&gt; 는 몇 가지 특수 값을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현할 때 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 유형 은 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현할 수 있습니다 . 이를 통해 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 대해 크기가 조정되지 않은 강제 변환을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">또한 &lt;code&gt;$crate&lt;/code&gt; 사용하면 확장시 매크로가 자체 상자 내의 항목을 참조 할 수 있지만 가시성에 영향을 미치지 않습니다. 참조 된 항목이나 매크로는 여전히 호출 사이트에서 볼 수 있어야합니다. 다음 예제에서는 &lt;code&gt;foo()&lt;/code&gt; 가 공개 되지 않기 때문에 상자 외부에서 &lt;code&gt;call_foo!()&lt;/code&gt; 를 호출하려는 시도 가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="8bd65ffd560b03ecf2792061831bdc28c657f4f7" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 가리키는 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 를 사용하면 데이터를 삭제하지 않고 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 지정된 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. 데이터를 삭제하지 않고 덮어 쓰는 데 &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4db0827a894435e479c60b5c414ff857b4d8ad46" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 가리키는 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 를 사용하면 데이터를 삭제하지 않고 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 지정된 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. 데이터를 삭제하지 않고 덮어 쓰는 데 &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;src&lt;/code&gt; 를 삭제하지 않습니다 . 의미 상, &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 위치로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 Unix에서 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다.이 특성 은 인수를 사용하고 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 의&lt;/a&gt; 벡터를 가져 오거나 생성 하는 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1db4d415a7232a66cc30ffdbd6dbfd6bc3c496f2" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 Unix에서 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;트레이 트를 구현하여 인수를 소비하고 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 벡터를 가져 오거나 생성 하는 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt; 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">또한 Windows에서 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공합니다 . 이 방법의 결과는 손실없이 Windows 문자열로 라운드 트립 될 수 있는 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">또한, 채널의 큐 작업을 복용하면 변이 포함 &lt;code&gt;receiver&lt;/code&gt; 스레드가 공유하고 수정할 수있는 안전한 방법이 필요하므로, &lt;code&gt;receiver&lt;/code&gt; ; 그렇지 않으면 경쟁 조건이 발생할 수 있습니다 (16 장에서 설명).</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">또한 &lt;code&gt;isize&lt;/code&gt; 및 &lt;code&gt;usize&lt;/code&gt; 유형은 프로그램이 실행되는 컴퓨터 종류에 따라 다릅니다. 64 비트 아키텍처 인 경우 64 비트, 32 비트 아키텍처 인 경우 32 비트.</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">또한 호출자는 주어진 메모리 영역에 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트를 쓰면 유효한 값 &lt;code&gt;T&lt;/code&gt; 가되도록해야 합니다. 유효하지 않은 &lt;code&gt;T&lt;/code&gt; 값을 포함하는 &lt;code&gt;T&lt;/code&gt; 로 유형이 지정된 메모리 영역을 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">또한 문자열의 길이는 포인터에서 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">또한, 수명 &lt;code&gt;'a&lt;/code&gt; 돌아 임의로 선택되고 반드시 데이터의 실제 수명을 반영하지 않습니다. 이 수명 동안이 포인터가 가리키는 메모리가 다른 포인터를 통해 액세스되지 않도록하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한, 수명 &lt;code&gt;'a&lt;/code&gt; 돌아 임의로 선택되고 반드시 데이터의 실제 수명을 반영하지 않습니다. 이 수명 동안이 포인터가 가리키는 메모리가 &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; 외부에 쓰지 않도록하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">또한이 함수의 반환 값은 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 이며 이는 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 유형 별칭입니다 . 포맷팅 구현은 &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 에서 오류를 전파해야합니다 (예 : &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; 를&lt;/a&gt; 호출 할 때 ). 그러나 오류를 허위로 반환해서는 안됩니다. 즉, 서식 구현은 전달 된 &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; 인&lt;/a&gt; 경우에만 오류를 반환해야합니다.오류를 반환합니다. 함수 시그니처가 제안하는 것과 달리 문자열 형식화는 잘못된 작업이기 때문입니다. 이 함수는 기본 스트림에 쓰지 못할 수 있기 때문에 결과 만 반환하며, 스택을 백업 할 때 오류가 발생했다는 사실을 전파 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">또한, 특성이 구현 된 유형의 이름을 인쇄하는 기본 구현으로 &lt;code&gt;hello_macro&lt;/code&gt; 함수를 아직 제공 할 수 없습니다 . Rust에는 리플렉션 기능이 없으므로 런타임시 유형 이름을 찾을 수 없습니다. 컴파일 타임에 코드를 생성하려면 매크로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">또한 일종의 링커가 필요합니다. 이미 설치되었을 수도 있지만 Rust 프로그램을 컴파일하려고 시도하고 링커를 실행할 수 없다는 오류가 발생하면 링커가 시스템에 설치되어 있지 않으므로 수동으로 설치해야합니다. C 컴파일러는 일반적으로 올바른 링커와 함께 제공됩니다. C 컴파일러 설치 방법은 플랫폼 설명서를 확인하십시오. 또한 일부 일반적인 Rust 패키지는 C 코드에 의존하며 C 컴파일러가 필요합니다. 따라서 지금 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">포인터 캐스트 할 주소</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">주소 유형은 &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; 특성을 구현할 수 있습니다 . 구체적인 예는 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">IP 주소가 아닌 운영 체제가 리턴 한 주소는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">반복기에 &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 메소드를 추가 합니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">오버플 로시 &lt;code&gt;None&lt;/code&gt; 을 반환 하여 &lt;code&gt;usize&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">목록 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">맵 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">설정된 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">생성 된 구조체 출력에 새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">생성 된 튜플 구조체 출력에 새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">주어진 값과 동일한 기존 값을 대체하여 값을 세트에 추가합니다. 대체 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">세트에 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">프로그램에 전달할 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">목록에서 요소를 먼저 추가합니다.</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">프로그램에 전달할 여러 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">이 단계에 하나를 추가하여 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">여러 환경 변수 매핑을 추가하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">블록 / 문자 장치, 파이프 및 소켓과 같은 특수 Unix 파일 유형에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">항목 반복자의 내용을 목록 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">항목 반복자의 컨텐츠를 맵 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">항목 반복자의 컨텐츠를 세트 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="525909640b425a3865879f7bf9b4776de0cbde79" translate="yes" xml:space="preserve">
          <source>Adds the key part of a new entry to the map output.</source>
          <target state="translated">새 항목의 핵심 부분을 맵 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="82b33d8253f240296388fcf0db6ce4c17b122fb9" translate="yes" xml:space="preserve">
          <source>Adds the value part of a new entry to the map output.</source>
          <target state="translated">새 항목의 값 부분을 맵 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb6c863d4412a4b55b1d93cf3d5f7516528289e4" translate="yes" xml:space="preserve">
          <source>Advance the internal cursor of the slice.</source>
          <target state="translated">슬라이스의 내부 커서를 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">다음 인수로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">고급 기능 및 폐쇄</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">고급 특성</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">고급 유형</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">고급 함수 및 클로저 : 함수 포인터 및 리턴 클로저</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">고급 특성 : 연관된 유형, 기본 유형 매개 변수, 완전한 구문, 상위 특성 및 특성과 관련된 새 유형 패턴</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">고급 유형 : 새 유형 패턴, 유형 별칭, never 유형 및 동적 크기 유형에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c629d1551783824351df46023949d62af853825" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c9fef351384b0144be153be53f79c7fc476bedfc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41de8018927ed7b54950980aec11f8f12d46606f" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 . &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09741f9824923fbfa016237025da37c62ee69dcc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 . &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3b9d2faa7136ddd042e31d3939c786f1c8da2c" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 . &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74fde24899e07da847358f17c288cfcfe8ae74ea" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기를 &lt;code&gt;n&lt;/code&gt; 개 요소 만큼 전진시킵니다 . &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d66799c08b5e49880157cde9e0d13d223a5c3a3" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소 만큼 뒤에서 반복자를 앞으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="4f1f4e504d47f61c437fd02db056daa6ec47dc6c" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소 만큼 뒤에서 반복자를 앞으로 이동합니다 . &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d59517951217a4fde7238ff6227ce7834fa1b5e" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소 만큼 뒤에서 반복자를 앞으로 이동합니다 . &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34bb721017aea2eeaededef2c5c856023eca871d" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소 만큼 뒤에서 반복자를 앞으로 이동합니다 . &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="148c4a64097476a8bb5779b8f3210d3b2962ff05" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 요소 만큼 뒤에서 반복자를 앞으로 이동합니다 . &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">후 &lt;code&gt;#[test]&lt;/code&gt; 우리는 추가 &lt;code&gt;#[ignore]&lt;/code&gt; 우리가 제외 할 테스트에 줄을. 이제 테스트를 실행하면 &lt;code&gt;it_works&lt;/code&gt; 가 실행되지만 &lt;code&gt;expensive_test&lt;/code&gt; 는 다음을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 뒤에 &lt;code&gt;add_to_waitlist&lt;/code&gt; 로 갈 때까지 각 연속 모듈을 포함 시킵니다 . 동일한 구조의 파일 시스템을 상상할 수 있으며 &lt;code&gt;add_to_waitlist&lt;/code&gt; 프로그램 을 실행하기 위해 &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; 경로를 지정합니다 . &lt;code&gt;crate&lt;/code&gt; 이름을 사용하여 상자 루트에서 시작하는 것은 &lt;code&gt;/&lt;/code&gt; 를 사용 하여 쉘의 파일 시스템 루트에서 시작하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 가 반환 된 후 &lt;code&gt;skip_while()&lt;/code&gt; 의 작업이 종료되고 나머지 요소가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 가 반환 된 후 &lt;code&gt;take_while()&lt;/code&gt; 의 작업이 끝나고 나머지 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">&lt;code&gt;leaf&lt;/code&gt; 가 생성 된 후 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 수는 1이고 약한 수는 0입니다. 내부 범위에서 &lt;code&gt;branch&lt;/code&gt; 를 만들고 &lt;code&gt;leaf&lt;/code&gt; 와 연결합니다 .이 시점에서 수를 인쇄 할 때 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;branch&lt;/code&gt; (1 강한 카운트 1 약함 수있을 것이다 &lt;code&gt;leaf.parent&lt;/code&gt; 가리키는 &lt;code&gt;branch&lt;/code&gt; A의 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ). 우리가 카운트 인쇄 할 때 &lt;code&gt;leaf&lt;/code&gt; 하기 때문에, 우리는이 둘의 강한 수있을 것이다 볼 &lt;code&gt;branch&lt;/code&gt; 현재의 복제가 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 의 &lt;code&gt;leaf&lt;/code&gt; 에 저장 &lt;code&gt;branch.children&lt;/code&gt; 이지만 여전히 약한 카운트는 0입니다.</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">반복자가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 하면 이후의 호출은 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; 다시 생성하거나 생성하지 않을 수 있습니다 . &lt;code&gt;fuse()&lt;/code&gt; 는 반복자를 조정하여 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 주어지면 항상 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 영원히 리턴하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">이 클로저를 반복자의 모든 요소에 적용한 후 &lt;code&gt;fold()&lt;/code&gt; 는 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">이 클로저를 반복자의 모든 요소에 적용한 후 &lt;code&gt;rfold()&lt;/code&gt; 는 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbffd4bfa583f6bbb8aa4395e63df871ca521db4" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; and transmitting the ownership of the data to &lt;code&gt;s&lt;/code&gt;, the &lt;code&gt;v&lt;/code&gt; value is invalid. Even when a value is just moved to &lt;code&gt;mem::forget&lt;/code&gt; (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.</source>
          <target state="translated">호출 후 &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; 와 상기 데이터의 소유권 송신 &lt;code&gt;s&lt;/code&gt; 상기 &lt;code&gt;v&lt;/code&gt; 값이 유효하다. 값이 &lt;code&gt;mem::forget&lt;/code&gt; (검사하지 않음)으로 이동 된 경우에도 일부 유형에는 매달 리거나 더 이상 소유하지 않을 때 유효하지 않게 만드는 값에 대한 엄격한 요구 사항이 있습니다. 잘못된 값을 함수로 전달하거나 함수에서 반환하는 등 어떤 방식 으로든 유효하지 않은 값을 사용하면 정의되지 않은 동작이 구성되고 컴파일러의 가정이 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 이전에 관리 한 메모리를 담당합니다 . 특히, 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 사용 하는 &lt;a href=&quot;index#memory-layout&quot;&gt;메모리 레이아웃&lt;/a&gt; 을 고려하여 &lt;code&gt;T&lt;/code&gt; 를 올바르게 파괴 하고 메모리를 해제 해야합니다 . 가장 쉬운 방법 은 &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 Raw 포인터를 &lt;code&gt;Box&lt;/code&gt; 로 다시 변환 하여 &lt;code&gt;Box&lt;/code&gt; 소멸자가 정리를 수행하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7cad9f1c8273ecabd3f00d51212a63d92e2f707f" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw_in&quot;&gt;&lt;code&gt;Box::from_raw_in&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 이전에 관리 한 메모리를 담당합니다 . 특히, 호출자는 &lt;code&gt;T&lt;/code&gt; 를 올바르게 파괴 하고 메모리를 해제해야합니다. 이렇게하는 가장 쉬운 방법은 변환하는 것입니다 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 에 원시 포인터와 뒷면에 포인터 &lt;code&gt;Box&lt;/code&gt; 와 &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="4e43a947242c53bd7c33db133c10548b5bd4c117" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;String&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 이전에 &lt;code&gt;String&lt;/code&gt; 에서 관리 한 메모리를 담당합니다 . 이를 수행하는 유일한 방법 은 &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 원시 포인터, 길이 및 용량을 다시 &lt;code&gt;String&lt;/code&gt; 로 변환 하여 소멸자가 정리를 수행 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="102d1de8629b57b21dac90f6d521b49048558b05" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 이전에 &lt;code&gt;Vec&lt;/code&gt; 에서 관리 한 메모리를 담당합니다 . 이를 수행하는 유일한 방법 은 &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 원시 포인터, 길이 및 용량을 &lt;code&gt;Vec&lt;/code&gt; 로 다시 변환 하여 소멸자가 정리를 수행 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">이 함수를 호출 한 후, 원시 포인터는 결과가 소유 &lt;code&gt;Box&lt;/code&gt; . 특히 &lt;code&gt;Box&lt;/code&gt; 소멸자는 &lt;code&gt;T&lt;/code&gt; 의 소멸자를 호출 하고 할당 된 메모리를 해제합니다. 이를 안전하게하려면 &lt;code&gt;Box&lt;/code&gt; 가 사용 하는 &lt;a href=&quot;index#memory-layout&quot;&gt;메모리 레이아웃&lt;/a&gt; 에 따라 메모리 가 할당되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 변경 후 ! 에 &lt;code&gt;eprintln!&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같은 방식으로 표준 출력을 재지 정하는 인수없이 동일한 방식으로 프로그램을 다시 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 주소 에 &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;TcpListener&lt;/code&gt; 를 작성한 후 들어오는 TCP 연결을 청취합니다. 이러한 호출에 의해 허용 될 수있다 &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 또는 이상 반복에 의해 &lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 반복자 &lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06868983dd9010816d16a947a2feebe64fc6c151" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 주소 에 &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;TcpListener&lt;/code&gt; 를 만든 후 들어오는 TCP 연결을 수신합니다. 이들은 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 &lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt; 반복자 를 반복하여 받아 들일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">만든 후 &lt;code&gt;TcpStream&lt;/code&gt; 를 하나에 의해 &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 원격 호스트에 보내고 또는 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; A의 연결 보내고 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; 를&lt;/a&gt; , 데이터가 전송 될 수있는 &lt;a href=&quot;../io/trait.read&quot;&gt;판독&lt;/a&gt; 및 &lt;a href=&quot;../io/trait.write&quot;&gt;기록&lt;/a&gt; 그것에.</target>
        </trans-unit>
        <trans-unit id="dafc89a72358e6711ac4be0166b7dcfdffe57a68" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">만든 후 &lt;code&gt;TcpStream&lt;/code&gt; 를 하나에 의해 &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 원격 호스트에 보내고 또는 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; A의 연결 보내고 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; 를&lt;/a&gt; , 데이터가 전송 될 수있는 &lt;a href=&quot;../io/trait.read&quot;&gt;판독&lt;/a&gt; 및 &lt;a href=&quot;../io/trait.write&quot;&gt;기록&lt;/a&gt; 그것에.</target>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">소켓 주소 에 &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;UdpSocket&lt;/code&gt; 을 만든 후 다른 소켓 주소 와 데이터 &lt;a href=&quot;#method.send_to&quot;&gt;를&lt;/a&gt; 주고 &lt;a href=&quot;#method.recv_from&quot;&gt;받을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="394b482d2eb5a6a4fcc8d7fdff6cfe2cd24f75e2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">&lt;code&gt;UdpSocket&lt;/code&gt; 을 소켓 주소 에 &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 생성 한 후에 는 다른 소켓 주소와 데이터 &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;를&lt;/a&gt; 주고 &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;받을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">우리가 &lt;code&gt;execute&lt;/code&gt; 에 넣은 클로저를 사용하여 새로운 &lt;code&gt;Job&lt;/code&gt; 인스턴스를 생성 한 후 , 우리는 해당 작업을 채널의 전송 끝으로 보냅니다. 전송이 실패한 경우 &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; 를 호출 합니다. 예를 들어 모든 스레드의 실행을 중지하면 수신 측에서 새 메시지 수신을 중지 한 경우에 발생할 수 있습니다. 현재 스레드 실행을 중지 할 수 없습니다. 풀이 존재하는 한 스레드가 계속 실행됩니다. 우리가 &lt;code&gt;unwrap&lt;/code&gt; 을 사용하는 이유는 실패 사례가 발생하지 않는다는 것을 알고 컴파일러가 그것을 알지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">잠금을 해제 한 후 뮤텍스 값을 인쇄하고 내부 &lt;code&gt;i32&lt;/code&gt; 를 6 으로 변경할 수 있음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">특성을 구현 한 후에는 다음 과 같이 일반 메소드를 호출하는 것과 같은 방식으로 &lt;code&gt;NewsArticle&lt;/code&gt; 및 &lt;code&gt;Tweet&lt;/code&gt; 의 인스턴스에서 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6aee078dffc9ca07e378d1b98649828937e42093" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-21.</source>
          <target state="translated">18 장에서 &lt;code&gt;while let&lt;/code&gt; 루프에 대해 배운 후에 는 Listing 20-21에 표시된 것처럼 작업자 스레드 코드를 작성하지 않은 이유가 궁금 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">18 장에서 &lt;code&gt;while let&lt;/code&gt; 루프에 대해 배운 후 Listing 20-22에 표시된 것처럼 작업자 스레드 코드를 작성하지 않은 이유가 궁금 할 것이다.</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">코드를 실행 한 후 우선 순위 동작이 분명합니다. &lt;code&gt;|&lt;/code&gt; 운전자는 팔이 맞았을 것이고 프로그램은 &lt;code&gt;yes&lt;/code&gt; 를 인쇄했을 것이다 .</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">일정 시간이 지난 후 야간 릴리스를 사용하는 Rust 개발자가 새로운 기능을 시험해 볼 수있게되면 팀 구성원은이 기능에 대해 논의하고 야간에 어떻게 작동했는지를 확인하고 안정적인 녹으로 만들어야하는지 여부를 결정합니다. 결정이 앞으로 진행되면 형상 게이트가 제거되고 형상이 안정된 것으로 간주됩니다! 열차를 타고 Rust의 새로운 안정적인 릴리스로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">그 진술 후에 우리는 다시 일시적인 &lt;code&gt;println!&lt;/code&gt; 추가했습니다 ! 파일을 읽은 후 &lt;code&gt;contents&lt;/code&gt; 의 값을 인쇄하는 명령문 이므로 지금까지 프로그램이 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">메소드 서명 후 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 특성을 구현하는 각 유형은 메소드 본문에 대해 고유 한 사용자 정의 동작을 제공해야합니다. 컴파일러는 &lt;code&gt;Summary&lt;/code&gt; 특성이있는 모든 유형 에이 서명으로 정의 된 메소드 &lt;code&gt;summarize&lt;/code&gt; 정확하게 갖도록 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">매개 변수 뒤에는 클로저 바디를 고정하는 중괄호를 배치합니다. 클로저 바디가 단일 표현식 인 경우 선택적입니다. 중괄호 뒤에있는 클로저 끝에는 &lt;code&gt;let&lt;/code&gt; 문 을 완료하기 위해 세미콜론이 필요합니다 . 클로저 본문 ( &lt;code&gt;num&lt;/code&gt; ) 의 마지막 라인에서 반환 된 값은 호출 될 때 클로저에서 반환 된 값입니다. 해당 라인은 세미콜론으로 끝나지 않기 때문입니다. 함수 본문에서와 같이.</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">요청 라인 다음에 &lt;code&gt;Host:&lt;/code&gt; 부터 시작하는 나머지 라인 은 헤더입니다. &lt;code&gt;GET&lt;/code&gt; 요청에는 본문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">이 두 줄 뒤에 &lt;code&gt;s&lt;/code&gt; 에는 &lt;code&gt;foobar&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;push_str&lt;/code&gt; 의 우리가 반드시 매개 변수의 소유권을 싶지 않기 때문에 방법은 문자열 조각을합니다. 예를 들어, 목록 8-16의 코드 는 내용을 &lt;code&gt;s1&lt;/code&gt; 에 추가 한 후 &lt;code&gt;s2&lt;/code&gt; 를 사용할 수 없으면 불행한 것임을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">그것들이 소비 된 후에, 나머지 요소들이 산출됩니다. 이 메소드를 직접 대체하는 대신, &lt;code&gt;nth&lt;/code&gt; 메소드 를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1a8c993e11b907a98ea3122f628acdebbd6b42e" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;rand_core&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on those to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">레지스트리를 업데이트 한 후 Cargo는 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션을 확인하고 아직 가지고 있지 않은 상자를 다운로드합니다. 이 경우 &lt;code&gt;rand&lt;/code&gt; 만 종속성으로 나열했지만 Cargo는 &lt;code&gt;libc&lt;/code&gt; 및 &lt;code&gt;rand_core&lt;/code&gt; 도 가져 왔습니다 . &lt;code&gt;rand&lt;/code&gt; 는 작업 할 항목에 의존 하기 때문 입니다. 상자를 다운로드 한 후 Rust는 상자를 컴파일 한 다음 사용 가능한 종속성으로 프로젝트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">레지스트리를 업데이트 한 후 Cargo는 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션을 확인하고 아직없는 상자를 다운로드합니다. 이 경우 &lt;code&gt;rand&lt;/code&gt; 를 의존성으로 만 나열했지만 Cargo는 &lt;code&gt;rand&lt;/code&gt; 가 작동하기 위해 &lt;code&gt;libc&lt;/code&gt; 에 의존 하기 때문에 &lt;code&gt;libc&lt;/code&gt; 사본 을 가져 왔습니다. 상자를 다운로드 한 후 Rust는 상자를 컴파일 한 다음 사용 가능한 종속성으로 프로젝트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">우리가 정의한 후 &lt;code&gt;summarize_author&lt;/code&gt; 을 , 우리는 호출 할 수 있습니다 &lt;code&gt;summarize&lt;/code&gt; 의 인스턴스 &lt;code&gt;Tweet&lt;/code&gt; 구조체, 그리고 기본 구현 &lt;code&gt;summarize&lt;/code&gt; 의 정의 호출 &lt;code&gt;summarize_author&lt;/code&gt; 우리가 제공 한 것으로합니다. 우리가 구현 한 때문에 &lt;code&gt;summarize_author&lt;/code&gt; 을 의 &lt;code&gt;Summary&lt;/code&gt; 특성은 우리의 행동 주신 &lt;code&gt;summarize&lt;/code&gt; 더 이상 코드를 작성하는 우리를 필요로하지 않고 방법을.</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">잠금을 얻은 후에는 이 경우 &lt;code&gt;num&lt;/code&gt; 이라는 반환 값을 내부 데이터에 대한 변경 가능한 참조로 처리 할 수 ​​있습니다. 우리가 값을 사용하기 전에 잠금을 획득하는 유형의 시스템 보장하지만 &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; 하지 &lt;code&gt;i32&lt;/code&gt; 우리가 있도록 &lt;em&gt;해야한다&lt;/em&gt; 사용 할 수 있도록 잠금을 획득 &lt;code&gt;i32&lt;/code&gt; 값입니다. 우리는 잊을 수 없다. 타입 시스템은 그렇지 않으면 내부 &lt;code&gt;i32&lt;/code&gt; 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;tests / common / mod.rs를&lt;/em&gt; 만든 후에는 통합 테스트 파일에서 모듈로 사용할 수 있습니다. &lt;em&gt;tests / integration_test.rs&lt;/em&gt; 의 &lt;code&gt;it_adds_two&lt;/code&gt; 테스트에서 &lt;code&gt;setup&lt;/code&gt; 함수를 호출하는 예는 다음과 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 로 목록을 만든 후에 value의 값에 10을 추가 &lt;code&gt;value&lt;/code&gt; . &lt;code&gt;borrow_mut&lt;/code&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 내부 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 값 으로 역 참조하기 위해 5 장에서 논의한 자동 역 참조 기능 ( &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; 연산자 는 어디에 있습니까 ?&quot; 섹션 참조)을 사용 하는 wonre_mut on &lt;code&gt;value&lt;/code&gt; 를 호출 하여 이를 수행합니다 . &lt;code&gt;borrow_mut&lt;/code&gt; 에 있어서 리턴 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터, 우리는 그것을 참조 연산자를 사용하여 내부 값을 변경.</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">많은 Rust 코드를 작성한 후, Rust 팀은 Rust 프로그래머가 특정 상황에서 반복해서 동일한 수명 주석을 입력하고 있음을 발견했습니다. 이러한 상황은 예측 가능했으며 몇 가지 결정적인 패턴을 따랐습니다. 개발자는 이러한 패턴을 컴파일러 코드에 프로그래밍하여 차용 검사기가 이러한 상황에서 수명을 추론 할 수 있으며 명시적인 주석이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; 을 통해 Rust를 설치 한 후 최신 버전으로 쉽게 업데이트 할 수 있습니다. 쉘에서 다음 업데이트 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">다시 말하지만, 이것은 &lt;code&gt;execute&lt;/code&gt; 메소드 의 가장 간단한 구현입니다. 아무것도하지 않지만 코드를 컴파일하려고합니다. 다시 확인해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">다시, 우리는 &lt;code&gt;thread::spawn&lt;/code&gt; 을 사용하여 새 스레드를 만든 다음 &lt;code&gt;move&lt;/code&gt; 를 사용하여 &lt;code&gt;tx&lt;/code&gt; 를 클로저로 이동 시켜 생성 된 스레드가 &lt;code&gt;tx&lt;/code&gt; 를 소유 합니다. 생성 된 스레드는 채널을 통해 메시지를 보낼 수 있으려면 채널의 전송 끝을 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">컴파일러가 유추 할 수있는 경우 전체 유형을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">아하! 첫 번째 오류 메시지는 &lt;code&gt;counter&lt;/code&gt; 가 &lt;code&gt;handle&lt;/code&gt; 과 연관된 스레드의 클로저로 이동 되었음을 나타냅니다 . 이로 인해 &lt;code&gt;lock&lt;/code&gt; 을 호출 하고 결과를 두 번째 스레드의 &lt;code&gt;num2&lt;/code&gt; 에 저장할 때 &lt;code&gt;counter&lt;/code&gt; 를 캡처하지 못하게 됩니다 ! 따라서 Rust는 &lt;code&gt;counter&lt;/code&gt; 소유권 을 여러 스레드로 옮길 수 없다고 말합니다 . 우리의 스레드가 루프에 있었기 때문에 이전에보기 어려웠으며 Rust는 루프의 다른 반복에서 다른 스레드를 가리킬 수 없습니다. 15 장에서 논의한 다중 소유권 방법으로 컴파일러 오류를 수정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
