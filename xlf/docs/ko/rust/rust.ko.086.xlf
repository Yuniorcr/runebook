<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">여기서는 벡터의 100 번째 요소 (인덱싱이 0에서 시작하기 때문에 인덱스 99에 있음)에 액세스하려고하지만 3 개의 요소 만 있습니다. 이 상황에서 Rust는 공황 상태에 빠질 것입니다. &lt;code&gt;[]&lt;/code&gt; 를 사용 하면 요소를 반환하지만 잘못된 인덱스를 전달하면 Rust가 여기에 반환 할 수있는 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">여기서는 &lt;code&gt;do_something&lt;/code&gt; 함수를 100 번 호출 하지만 &lt;code&gt;for&lt;/code&gt; 루프 의 본문에서 변수 &lt;code&gt;i&lt;/code&gt; 를 사용하지 않습니다 . 녹은 우리에게 그것에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">여기서는 &lt;code&gt;email&lt;/code&gt; 이라는 필드가있는 &lt;code&gt;User&lt;/code&gt; 구조체 의 새 인스턴스를 만듭니다 . &lt;code&gt;email&lt;/code&gt; 필드의 값을 &lt;code&gt;build_user&lt;/code&gt; 함수 의 &lt;code&gt;email&lt;/code&gt; 매개 변수 값 으로 설정 하려고 합니다. 때문에 &lt;code&gt;email&lt;/code&gt; 필드와 &lt;code&gt;email&lt;/code&gt; 매개 변수는 같은 이름을 가지고, 우리는 쓰기에 필요한 &lt;code&gt;email&lt;/code&gt; 이 아닌 &lt;code&gt;email: email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">여기, 우리가의 수명 주석 한 &lt;code&gt;r&lt;/code&gt; 함께 &lt;code&gt;'a&lt;/code&gt; 및의 수명 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;'b&lt;/code&gt; . 보시다시피, 내부 &lt;code&gt;'b&lt;/code&gt; 블록은 외부 &lt;code&gt;'a&lt;/code&gt; 평생 블록 보다 훨씬 작습니다 . 컴파일 타임에 Rust는 두 수명의 크기를 비교하여 &lt;code&gt;r&lt;/code&gt; 의 수명이 &lt;code&gt;'a&lt;/code&gt; 이지만 수명이 &lt;code&gt;'b&lt;/code&gt; 인 메모리를 나타냅니다 . 때문에이 프로그램은 거부 &lt;code&gt;'b&lt;/code&gt; 는 보다 짧은 &lt;code&gt;'a&lt;/code&gt; : 참조의 대상이 참조로하지 라이브 한 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기, 우리가하는 방법이라는 정의한 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 이 반환 필드의 데이터에 대한 참조 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">여기, 우리는 구조체 정의한 &lt;code&gt;IpAddr&lt;/code&gt; A : 두 개의 필드가 &lt;code&gt;kind&lt;/code&gt; 유형 인 필드 &lt;code&gt;IpAddrKind&lt;/code&gt; (우리가 이전에 정의 된 열거)과 &lt;code&gt;address&lt;/code&gt; 타입의 필드 &lt;code&gt;String&lt;/code&gt; . 이 구조체의 두 인스턴스가 있습니다. 첫 번째, &lt;code&gt;home&lt;/code&gt; 값이 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 그와 같은 &lt;code&gt;kind&lt;/code&gt; 관련해, 주소 데이터와 &lt;code&gt;127.0.0.1&lt;/code&gt; 을 . 두 번째 인스턴스 인 &lt;code&gt;loopback&lt;/code&gt; 은 &lt;code&gt;kind&lt;/code&gt; 값 &lt;code&gt;V6&lt;/code&gt; 으로 &lt;code&gt;IpAddrKind&lt;/code&gt; 의 다른 변형을 가지며 이와 관련된 주소 &lt;code&gt;::1&lt;/code&gt; 을 갖 습니다. 우리는 구조체를 사용하여 &lt;code&gt;kind&lt;/code&gt; 와 &lt;code&gt;address&lt;/code&gt; 값이 함께 있으므로 이제 변형이 값과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">여기서는 래핑 된 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현할 때만 구현이 래퍼에 존재한다고 말합니다 . &lt;code&gt;where&lt;/code&gt; 일부 유형의 구현하지 않기 때문에 절은 중요 &lt;code&gt;Clone&lt;/code&gt; 이 방법을받지 않습니다 따라서합니다.</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="translated">여기에서 &lt;code&gt;impl Trait&lt;/code&gt; 에서 부적절한 수명을 사용했습니다 . &lt;code&gt;impl Trait&lt;/code&gt; 은 fn 또는 impl 수준에서 바인딩 된 수명 만 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">16 진 정수</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">더 높은 수준의 동기화 개체</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">더 높은 수명주기</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">특성 직전에 더 높은 수명을 지정할 수도 있지만, 유일한 차이는 전체 매개 변수가 아닌 다음 특성의 끝까지 만 연장되는 수명 매개 변수의 범위입니다. 이 기능은 마지막 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">더 높은 특성의 한계</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">코드 생성 또는 최적화 방법에 영향을주는 컴파일러 힌트.</target>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 거짓 일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 참일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">만세! 녹 1.5가 완료되었습니다! 그러나 6 주가 지났기 때문에 &lt;em&gt;다음&lt;/em&gt; 버전의 Rust, 1.6 의 새로운 베타 버전도 필요합니다 . 따라서 &lt;code&gt;beta&lt;/code&gt; 에서 &lt;code&gt;stable&lt;/code&gt; 브랜치가 나간 후 다음 버전의 &lt;code&gt;beta&lt;/code&gt; 브랜치가 &lt;code&gt;nightly&lt;/code&gt; 다시 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Deref 강제 변환이 돌연변이와 상호 작용하는 방법</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">두 가지 유형을 어떻게 비교할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">어떻게 &lt;code&gt;Eq&lt;/code&gt; 를 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">기본값을 어떻게 정의 할 수 있습니까? 당신은 &lt;code&gt;Default&lt;/code&gt; 을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 이 &lt;code&gt;Result&lt;/code&gt; 반환 한다는 것을 어떻게 알 수 있습니까? 우리는 볼 수 있었다 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 API 문서&lt;/a&gt; , 또는 우리는 컴파일러를 요청할 수 있습니다! &lt;code&gt;f&lt;/code&gt; 가 함수의 반환 유형 이 &lt;em&gt;아니라는&lt;/em&gt; 타입 주석을 제공 한 다음 코드를 컴파일하려고하면 컴파일러는 유형이 일치하지 않는다고 알려줍니다. 오류 메시지는 다음의 종류 무엇을 우리에게 말할 것이다 &lt;code&gt;f&lt;/code&gt; 는&lt;em&gt;것입니다&lt;/em&gt; . 해 봅시다! &lt;code&gt;File::open&lt;/code&gt; 의 반환 유형이 &lt;code&gt;u32&lt;/code&gt; 유형이 아니므로 &lt;code&gt;let f&lt;/code&gt; 문을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">이 책을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">시험을 쓰는 방법</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">사용자 지정 &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; 매크로 를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">하위 표현식의 값을 결합하여 표현식의 값을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">동시에 여러 코드 조각을 실행하는 스레드를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">이 문서를 읽는 방법</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">12 장에서이 두 기능을 사용하여 I / O 프로젝트를 개선하는 방법</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">그러나 &lt;code&gt;Vec&lt;/code&gt; 에 없는 인덱스에 액세스하려고하면 소프트웨어가 패닉 상태가됩니다! 너는 이것을 못해:</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">그러나주의해야합니다.이 방법은 &lt;code&gt;self&lt;/code&gt; 가 변경 가능할 것으로 예상합니다. 일반적으로 &lt;code&gt;RefCell&lt;/code&gt; 을 사용할 때는 그렇지 않습니다 . &lt;code&gt;self&lt;/code&gt; 가 변경 불가능한 경우, 대신 &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 메소드를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">그러나 전체 주문이없는 유형에 대해서는 다른 것을 별도로 구현할 수 있습니다. 예를 들어 부동 소수점 숫자의 경우 &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; 및 &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (IEEE 754-2008 섹션 5.11 참조).</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">그러나 프로그래머는 일반적으로 스레드 스케줄링에 대해 생각하지 않기 때문에 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; es 또는 동기화 루틴에 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">그러나 유형 기억 &lt;em&gt;함유 &lt;/em&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 반드시 동일한 레이아웃 아니다; Rust는 일반적으로 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 의 크기와 정렬이 동일 하더라도 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 의 필드가 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 와 동일한 순서를 보장하지 않습니다 . 또한 비트 값이 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 유효하기 때문에 컴파일러는 0이 아닌 / 틈새 채우기 최적화를 적용 할 수 없으므로 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">그러나 한 가지 경우가 있습니다 &lt;code&gt;!&lt;/code&gt; 구문은 전에 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 함수의 반환 유형 위치에서 본격적인 유형으로 안정화됩니다. 특히 두 가지 다른 함수 포인터 유형에 대한 구현이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">그러나 한 가지 경우가 있습니다 &lt;code&gt;!&lt;/code&gt; 구문은 전에 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 함수의 반환 유형 위치에서 전체 유형으로 안정화됩니다. 특히 두 가지 함수 포인터 유형에 대한 구현이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">그러나 IEEE-754의 2008 버전 이전에는 NaN 신호 비트를 해석하는 방법이 실제로 지정되지 않았다는 한 가지 경고가 있습니다. 대부분의 플랫폼 (특히 x86 및 ARM)은 2008 년에 궁극적으로 표준화 된 해석을 선택했지만 일부는 그렇지 않았습니다 (특히 MIPS). 결과적으로 MIPS의 모든 신호 NaN은 x86의 조용한 NaN이며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">그러나 &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 는 동적 상황에 가장 적합합니다. 이것은 모든 구성 요소를 미리 알고있을 때이를 수행하는 더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="translated">그러나 &lt;code&gt;dyn Trait&lt;/code&gt; 은 메서드가 각 구체적인 유형에 대해 중복되지 않으므로 &lt;code&gt;impl Trait&lt;/code&gt; / 일반 매개 변수 보다 작은 코드를 생성 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">그러나 더 나은 해결책은 유형과 특성을 완전히 명시 적으로 명명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">그러나 매크로 호출에서 후행 쉼표를 무시하는 규칙에 따라 후행 쉼표가있는 단일 인수는 여전히 튜플로 취급되지 않습니다. 필요한 경우 1 개의 튜플을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">그러나 특성의 일부인 관련 함수에는 &lt;code&gt;self&lt;/code&gt; 매개 변수 가 없습니다 . 동일한 범위의 두 유형이 해당 특성을 구현할 때 &lt;em&gt;정규화 된 구문&lt;/em&gt; 을 사용하지 않으면 Rust가 어떤 유형을 의미하는지 파악할 수 없습니다 . 예를 들어, 목록 19-19 의 &lt;code&gt;Animal&lt;/code&gt; 특성에는 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; , 구조체 &lt;code&gt;Dog&lt;/code&gt; 에 대한 &lt;code&gt;Animal&lt;/code&gt; 구현 및 &lt;code&gt;Dog&lt;/code&gt; 에 직접 정의 된 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">그러나 두 유형에 공통된 유형이있는 경우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">그러나, &lt;code&gt;a&lt;/code&gt; 여전히 참조하고 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 있었던 &lt;code&gt;b&lt;/code&gt; 것으로, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 상기 메모리 있도록 1보다 0의 카운트를 보유하고, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 힙 갖는다는 삭제되지 않을 것이다. 기억은 단지 1의 카운트로 영원히 거기에 앉을 것입니다. 이 참조주기를 시각화하기 위해 그림 15-4에서 다이어그램을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">그러나 이렇게 넓은 범위의 숫자를 표현할 수 있다는 것은 정밀도를 떨어 뜨립니다. 실수는 실수의 일부만 표현할 수 있고, 표현 가능한 근처의 수로 반올림 한 부동 소수점으로 계산할 수 있습니다. 예를 들어 &lt;code&gt;5.0&lt;/code&gt; 과 &lt;code&gt;1.0&lt;/code&gt; 은 &lt;code&gt;f32&lt;/code&gt; 로 정확하게 표현할 수 있지만 &lt;code&gt;1.0 / 5.0&lt;/code&gt; 은 &lt;code&gt;0.2&lt;/code&gt; 를 &lt;code&gt;f32&lt;/code&gt; 로 정확하게 표현할 수 없기 때문에 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; 가 됩니다 . 그러나 &lt;code&gt;println&lt;/code&gt; 으로 플로트를 인쇄 하고 친구들은 종종 중요하지 않은 숫자를 버립니다. &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; 는 &lt;code&gt;0.2&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">그러나 &lt;code&gt;alloc_excess&lt;/code&gt; 가 로컬로 리턴 한 용량을 추적하지 않으려는 클라이언트의 경우이 방법으로 유용한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">그러나 모든 기능에 많은 오류 검사가 있으면 장황하고 성 가실 것입니다. 다행스럽게도 Rust의 타입 시스템 (따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 할 수 있습니다. 함수에 특정 유형의 매개 변수가있는 경우 컴파일러가 이미 유효한 값을 가지고 있음을 알고 코드 논리를 진행할 수 있습니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 이 아닌 유형이있는 경우 프로그램 은 &lt;em&gt;아무것도&lt;/em&gt; 아닌 &lt;em&gt;것을&lt;/em&gt; 기대합니다 . 그러면 코드에서 &lt;code&gt;Some&lt;/code&gt; 과 &lt;code&gt;None&lt;/code&gt; 에 대해 두 가지 경우를 처리 할 필요가 없습니다.&lt;em&gt;&lt;/em&gt;변형 : 확실히 가치가있는 경우는 하나뿐입니다. 함수에 아무것도 전달하지 않는 코드는 컴파일되지 않으므로 런타임에 함수가 해당 사례를 확인할 필요가 없습니다. 또 다른 예는 &lt;code&gt;u32&lt;/code&gt; 와 같은 부호없는 정수 유형을 사용 하여 매개 변수가 음수가 아닌지 확인 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">그러나 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현 하면 대신 'copy semantics'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">그러나 &lt;code&gt;Super&lt;/code&gt; 가 객체 안전 하더라도 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 에서 파생되는 경우 &lt;code&gt;get_a()&lt;/code&gt; 메소드 는 함수에서 호출 될 때 알 수없는 유형의 객체를 반환합니다. &lt;code&gt;Self&lt;/code&gt; 유형 매개 변수를 사용하면 객체 안전 특성을 더 이상 안전하게 만들 수 없으므로 수퍼 특성을 지정할 때 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">그러나 이러한 유형을 계속 사용하려면 안전하지 않은 래퍼로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">그러나 구조체의 필드에 액세스하려면 필드 이름의 철자가 올바른지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">하지만 한 줄은 읽기 어렵 기 때문에 나누는 것이 가장 좋습니다. 이제이 라인이 무엇을하는지 논의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">그러나 하나의 긴 줄은 읽기가 어렵 기 때문에 나누는 것이 가장 좋습니다. 두 개의 메소드 호출에 대해 두 줄입니다. 이제이 라인이 무엇을하는지 논의 해 보자.</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">그러나이 장의 목적은 쉬운 길을 택하지 않고 배우는 것을 돕기위한 것입니다. Rust는 시스템 프로그래밍 언어이기 때문에 작업하려는 추상화 수준을 선택할 수 있으며 다른 언어에서 가능하거나 실용적인 것보다 낮은 수준으로 갈 수 있습니다. 기본 HTTP 서버 및 스레드 풀을 수동으로 작성하여 향후 사용할 상자 뒤에있는 일반적인 아이디어와 기술을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">그러나 첫 번째 솔루션을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">그러나 일부 고급 할당 방법 ( &lt;code&gt;alloc_one&lt;/code&gt; , &lt;code&gt;alloc_array&lt;/code&gt; )은 크기가 0 인 유형에 대해 잘 정의되어 있으며 선택적으로 지원할 수 있습니다. &lt;code&gt;Err&lt;/code&gt; 를 반환할지 또는 포인터 로 &lt;code&gt;Ok&lt;/code&gt; 를 반환 할지 여부는 구현 자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">그러나 때로는 라이브러리 사용자가 특정 상황에서 유효한 유형 세트를 확장 할 수 있기를 원합니다. 이를 달성하는 방법을 보여주기 위해 항목 목록을 반복하는 GUI (Graphical User Interface) 도구를 만들어 각 GUI 도구에 대한 일반적인 기술인 화면에 &lt;code&gt;draw&lt;/code&gt; 방법을 호출 합니다. GUI 라이브러리의 구조를 포함하는 &lt;code&gt;gui&lt;/code&gt; 라는 라이브러리 상자를 만듭니다 . 이 상자에는 &lt;code&gt;Button&lt;/code&gt; 또는 &lt;code&gt;TextField&lt;/code&gt; 와 같이 사람들이 사용할 수있는 일부 유형이 포함될 수 있습니다 . 또한 &lt;code&gt;gui&lt;/code&gt; 사용자는 그릴 수있는 고유 한 유형을 만들려고합니다. 예를 들어 한 프로그래머가 &lt;code&gt;Image&lt;/code&gt; 추가 하고 다른 프로그래머가 이미지 를 추가 할 수 있습니다. &lt;code&gt;SelectBox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">그러나 구조적 고정에는 몇 가지 추가 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">그러나 Rust 코드로 구문 분석 된 리터럴 토큰의 접미 부는 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">그러나 Rust 코드로 파싱 된 리터럴 토큰의 접미사는 제한됩니다. 숫자가 아닌 리터럴 토큰에서는 모든 접미사가 거부되고 숫자 리터럴 토큰은 아래 목록의 접미사에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;em&gt;하나&lt;/em&gt; 의 경우 에만 관심이있는 상황 에서는 &lt;code&gt;match&lt;/code&gt; 표현식이 약간 까다로울 수 있습니다 . 이 상황에서 Rust은 &lt;code&gt;if let&lt;/code&gt; 제공 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">그러나 null이 표현하려고한다는 개념은 여전히 ​​유용한 개념입니다. null은 현재 어떤 이유로 인해 유효하지 않거나없는 값입니다.</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">그러나 포인터가 실제로 할당 된 메모리를 가리 키지 않을 수 있습니다. 특히 &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt; 를 통해 용량이 0 인 &lt;code&gt;Vec&lt;/code&gt; 을 구성 하거나 빈 Vec에서 &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; 을 호출 하면 메모리가 할당되지 않습니다. 마찬가지로 &lt;code&gt;Vec&lt;/code&gt; 안에 0 크기의 유형을 저장하면 공간을 할당하지 않습니다. &lt;em&gt;이 경우 &lt;/em&gt;&lt;em&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 은 &lt;/em&gt;&lt;em&gt;&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 0을 &lt;/em&gt;&lt;em&gt;보고하지 않을 수 있습니다&lt;/em&gt; . &lt;code&gt;Vec&lt;/code&gt; 은 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; 경우에만 할당합니다 . 일반적으로 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;Vec&lt;/code&gt; 을 사용 하여 메모리를 할당 하고 다른 용도로 사용하려는 경우 (안전하지 않은 코드로 전달하거나 자체 메모리 기반 컬렉션을 작성하려는 경우)를 사용하여이 메모리를 할당 해제해야합니다. &lt;code&gt;from_raw_parts&lt;/code&gt; 를 사용하여 &lt;code&gt;Vec&lt;/code&gt; 을 복구 한 다음 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32()&lt;/code&gt; 는 입력 값이 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 유효한 값이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 는 이것을 무시하고 맹목적으로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; 로&lt;/a&gt; 캐스팅 하여 유효하지 않은 것을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;code&gt;char&lt;/code&gt; 인 것은 아닙니다 . &lt;code&gt;from_u32()&lt;/code&gt; 는 입력이 &lt;code&gt;char&lt;/code&gt; 에 대해 유효한 값이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;code&gt;char&lt;/code&gt; 인 것은 아닙니다 . &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 는 이것을 무시하고 맹목적으로 &lt;code&gt;char&lt;/code&gt; 로 캐스팅 하여 잘못된 것을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">그러나 두 번째 부분은 다릅니다. &lt;em&gt;가비지 수집기 (GC)&lt;/em&gt; 가있는 언어 에서 GC는 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 이에 대해 생각할 필요가 없습니다. GC가 없으면 메모리를 더 이상 사용하지 않을 때를 식별하고 요청하는 것처럼 메모리를 명시 적으로 반환하는 코드를 호출해야합니다. 이것을 올바르게하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어 버리면 기억이 낭비됩니다. 너무 일찍하면 유효하지 않은 변수가 생깁니다. 우리가 두 번 그렇게하면 버그이기도합니다. 우리는 정확히 하나의 &lt;code&gt;allocate&lt;/code&gt; 을 정확히 하나의 &lt;code&gt;free&lt;/code&gt; 와 페어링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">그러나 값이 메소드에서 자체적으로 변경되는 것이 유용하지만 다른 코드에서는 변경할 수없는 상황이 있습니다. 값의 메소드 외부의 코드는 값을 변경할 수 없습니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 내부 변경 기능을 사용할 수 있습니다. 그러나 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 차용 규칙을 완전히 극복하지 못합니다. 컴파일러의 차용 검사기는 이러한 내부 변경을 허용하며 차용 규칙은 런타임에 대신 확인됩니다. 규칙을 위반하면 &lt;code&gt;panic!&lt;/code&gt; 컴파일러 오류 대신.</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">그러나 함수 항목 에서 동일한 서명을 가진 &lt;a href=&quot;function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 로 &lt;a href=&quot;../type-coercions&quot;&gt;강제 변환&lt;/a&gt; 됩니다. 이는 함수 포인터가 직접 예상 될 때 함수 항목이 사용될 때뿐만 아니라 동일한 서명을 가진 다른 함수 항목 유형이 다른 경우에도 트리거됩니다. 같은 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;match&lt;/code&gt; 하는 무기 :</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">그러나이 테스트에는 다음과 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">그러나 &lt;code&gt;hello_macro&lt;/code&gt; 와 함께 사용하려는 각 유형에 대해 구현 블록을 작성해야합니다 . 우리는이 일을하지 않아도되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="translated">그러나이 &quot;zombie&quot;값은 안전한 코드에 노출되어서는 안되며이 함수는 두 번 이상 호출되지 않아야합니다. 값을 삭제 한 후 사용하거나 값을 여러 번 삭제하면 정의되지 않은 동작이 발생할 수 있습니다 ( &lt;code&gt;drop&lt;/code&gt; 가 수행 하는 작업에 따라 다름 ). 이는 보통 타입 시스템에 의해 방해되어 있지만, 사용자 &lt;code&gt;ManuallyDrop&lt;/code&gt; 는 컴파일러의 도움없이 그 보장을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="translated">그러나이 추가 권한에는 추가 책임이 따릅니다. 이제 건전성을 보장하는 것은 사용자의 몫입니다. &lt;code&gt;unsafe&lt;/code&gt; 키워드는 분명히 필요가 이것에 대해 걱정하는 것이 코드의 조각을 표시하여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">그러나 이것은 이상적인 해결책은 아닙니다. 프로그램이 1에서 100 사이의 값으로 만 작동하는 것이 절대적으로 중요하고이 요구 사항을 가진 많은 기능이있는 경우 모든 기능에서 이와 같이 확인하는 것이 번거롭고 영향을 줄 수 있습니다. 공연).</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">그러나이 패턴은 매우 일반적이므로 Rust는이를 위해 &lt;code&gt;while&lt;/code&gt; 루프 라고하는 내장 언어 구조를 가지고 있습니다. Listing 3-3은 &lt;code&gt;while&lt;/code&gt; : 프로그램을 세 번 반복하고 매번 카운트 다운 한 다음 루프 후에 다른 메시지를 인쇄하고 종료한다.</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">그러나 이것은 :</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">그러나 언어에는 두 개의 동시성 개념이 포함되어 있습니다. &lt;code&gt;std::marker&lt;/code&gt; 특성 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">그러나 &lt;code&gt;..&lt;/code&gt; 를 사용하면 명확해야합니다. 일치시킬 값과 무시해야 할 값이 확실하지 않은 경우 Rust는 오류를 표시합니다. Listing 18-25는 &lt;code&gt;..&lt;/code&gt; 를 모호하게 사용하는 예제를 보여 주므로 컴파일되지 않는다.</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">그러나 Listing 13-3의 문제점 중 하나를 다시 도입했다. 첫 번째 &lt;code&gt;if&lt;/code&gt; 블록 에서 클로저를 여전히 두 번 호출하고 있는데,이 경우 고가의 코드를 두 번 호출하고 사용자가 필요한 시간을 두 번 기다릴 것이다. 클로저 호출 결과를 보유하기 위해 &lt;code&gt;if&lt;/code&gt; 블록에 로컬 변수를 생성하여이 문제를 해결할 수 있지만 클로저는 다른 솔루션을 제공합니다. 우리는 그 해결책에 대해 조금 이야기 할 것입니다. 그러나 먼저 클로저 정의에 클로저 정의에 타입 주석이없는 이유와 클로저와 관련된 특성에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">그러나 실패가 예상되는 경우 &lt;code&gt;panic!&lt;/code&gt; 를 만드는 것보다 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 것이 더 적절합니다 ! 요구. 예를 들어 형식이 잘못된 데이터가 제공되는 파서 또는 속도 제한에 도달했음을 나타내는 상태를 반환하는 HTTP 요청이 있습니다. 이 경우 &lt;code&gt;Result&lt;/code&gt; 반환 하면 호출 코드를 처리하는 방법을 결정해야 할 가능성이 예상되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">그러나 특성 오브젝트를 사용 하여 특성을 구현 하는 &lt;em&gt;모든&lt;/em&gt; 오브젝트를 포함하는 테이블을 작성해야합니다 . 유형 매개 변수가있는 경우 이제 특성을 구현하는 모든 유형에 대한 구현을 추가해야하며 이론적으로 무한한 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">그러나 단일 유형을 반환하는 경우 &lt;code&gt;impl Trait&lt;/code&gt; 만 사용할 수 있습니다 . 예를 들어, &lt;code&gt;NewsArticle&lt;/code&gt; 또는 반환 형식이 &lt;code&gt;impl Summary&lt;/code&gt; 로 지정된 &lt;code&gt;Tweet&lt;/code&gt; 을 반환하는이 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">크고 작은 수백 개의 회사에서 다양한 작업을 위해 생산시 Rust를 사용합니다. 이러한 작업에는 명령 줄 도구, 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석 및 트랜스 코딩, 암호 화폐, 생물 정보학, 검색 엔진, 사물 인터넷 응용 프로그램, 기계 학습 및 Firefox 웹 브라우저의 주요 부분이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">쌍곡 코사인 함수.</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">쌍곡 사인 함수.</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">쌍곡 탄젠트 함수.</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">나는 그것을 10 억 달러의 실수라고 부릅니다. 당시에는 객체 지향 언어로 참조 할 수있는 최초의 포괄적 인 유형 시스템을 설계하고있었습니다. 필자의 목표는 컴파일러가 자동으로 검사를 수행하여 모든 참조 사용이 절대적으로 안전하도록하는 것이 었습니다. 그러나 구현하기가 쉽기 때문에 null 참조를 넣는 유혹에 저항 할 수 없었습니다. 이로 인해 수많은 오류, 취약성 및 시스템 충돌이 발생했으며, 이는 아마도 지난 40 년 동안 수십억 달러의 고통과 피해를 야기했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Rust Language Server를 사용한 IDE 통합</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">식별자 :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754는 부동 소수점의 비트 레이아웃을 매우 정확하게 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 섹션 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 섹션 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt; 에서 32 비트 정수로 정의됩니다 . 그것들은 보통 4 옥텟으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4 소켓 주소 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 명시된대로 &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; 주소&lt;/a&gt; 와 16 비트 포트 번호로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4 소켓 주소 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 명시된 바와 같이 &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 주소&lt;/a&gt; 와 16 비트 포트 번호로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 에서 128 비트 정수로 정의됩니다 . 일반적으로 8 개의 16 비트 세그먼트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6 소켓 주소는 &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; 주소&lt;/a&gt; , 16 비트 포트 번호, 트래픽 클래스, 흐름 레이블 및 범위 식별자를 포함하는 필드로 구성됩니다 (자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, 섹션 3.3&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6 소켓 주소 는 트래픽 클래스, 플로우 레이블 및 범위 ID를 포함하는 필드뿐만 아니라 &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 주소&lt;/a&gt; , 16 비트 포트 번호로 구성됩니다 (자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, 섹션 3.3&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">식별자 패턴</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 하위 패턴이 반박 할 수 없거나 하위 패턴이 지정되지 않은 경우 식별자 패턴은 반박 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">식별자 패턴은 변수와 일치하는 값을 바인딩합니다. 식별자는 패턴 내에서 고유해야합니다. 변수는 범위 내에서 같은 이름의 변수를 음영 처리합니다. 새 바인딩의 범위는 패턴이 사용되는 컨텍스트 (예 : &lt;code&gt;let&lt;/code&gt; 바인딩 또는 &lt;code&gt;match&lt;/code&gt; arm)에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">중복 코드를 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">&amp;epsilon; &amp;isin; LAST ( &lt;code&gt;uu ...&lt;/code&gt; )이면 LAST (M) = LAST ( &lt;code&gt;tt&lt;/code&gt; ) &amp;cup; (LAST ( &lt;code&gt;uu ...&lt;/code&gt; ) \ {&amp;epsilon;})입니다.</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt; 가 이전에 호출 된 경우 &lt;code&gt;VecDeque&lt;/code&gt; 의 모든 요소 는 첫 번째 슬라이스에 있고 두 번째 슬라이스는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 확장이 추가됩니다; 그렇지 않으면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; 가&lt;/a&gt; 없었다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ,이 밀어에 해당 &lt;code&gt;file_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 확장이 추가됩니다; 그렇지 않으면 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;file_name&lt;/code&gt; 을 누르는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt; 가 이전에 호출 된 경우 &lt;code&gt;VecDeque&lt;/code&gt; 의 모든 요소 는 첫 번째 슬라이스에 있고 두 번째 슬라이스는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;'static&lt;/code&gt; 다음 바인딩 어떤 일생에 사용되는 &lt;code&gt;'static&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">경우 &lt;code&gt;..&lt;/code&gt; 가 사용되지 않는, 모든 필드와 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;.create_new(true)&lt;/code&gt; 설정, &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;.create_new(true)&lt;/code&gt; 설정, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">경우 &lt;code&gt;Complete&lt;/code&gt; IS 다음 반환 된 발전기는 완전히 제공되는 값으로 완료되었습니다. 생성기가 다시 재개 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">&lt;code&gt;ForeignTrait&lt;/code&gt; 이 일부 외부 상자 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 특성 인 경우 다음 특성 &lt;code&gt;impl&lt;/code&gt; 이 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">만약 &lt;code&gt;Hello, world!&lt;/code&gt; 인쇄, 축하했다! 당신은 공식적으로 Rust 프로그램을 작성했습니다. 그것은 당신을 Rust 프로그래머로 만듭니다 &amp;ndash; 환영합니다!</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; 은 슬라이스의 크기보다 큰, 그것은 어떤 창을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">만약 &lt;code&gt;T: Drop&lt;/code&gt; , 호출 &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Arc&lt;/code&gt; 동일한 할당으로의 그 지점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 절대 시점은 동일하지.</target>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 할당으로의 그 지점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; (평등 재귀을 의미), 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 할당으로의 시점 결코 동일하지.</target>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 같은 값으로 그 시점의 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 구현하지 않습니다 &lt;code&gt;Copy&lt;/code&gt; 사용 &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 의 구현은 &lt;code&gt;Copy&lt;/code&gt; , 그것은 사용에 더 확대됨에 될 수 &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 있다 &lt;code&gt;Sized&lt;/code&gt; 이 기능은 항상 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 FFI-안전하고 그렇습니다 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 열거되지 않습니다,이 함수를 호출하면 정의되지 않은 동작이 발생할 수 있지만, 반환 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 수신기를 리턴 할 때까지 각 주소로 시도됩니다. 리스너 작성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 리턴 된 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 소켓을 반환 할 때까지 각 주소로 시도됩니다. 소켓 생성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 여러 개의 주소를 얻을 수, &lt;code&gt;connect&lt;/code&gt; 연결이 성공할 때까지 각 주소로 시도됩니다. 어떤 주소도 연결에 성공하지 못하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;connect&lt;/code&gt; 기본 OS 기능 반환하지 오류 때까지 각 주소로 시도됩니다. 일반적으로 성공적인 &lt;code&gt;connect&lt;/code&gt; 호출은 포트에서 수신 대기중인 원격 서버가 있음을 지정하지 않으며, 이러한 오류는 첫 번째 송신 후에 만 ​​감지됩니다. OS가 지정된 각 주소에 대해 오류를 반환하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;self&lt;/code&gt; 의 접두사가 아닌 경우 (즉, &lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함) &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;self&lt;/code&gt; 의 접두사가 아닌 경우 (즉, &lt;a href=&quot;struct.path#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 반환) &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 의 바이트로 시작 &lt;code&gt;get&lt;/code&gt; , 우리가 다른 요청을 받았습니다 의미한다. 잠시 후 &lt;code&gt;else&lt;/code&gt; 블록에 코드를 추가하여 다른 모든 요청에 ​​응답합니다.</target>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 이 반복자의 다음 값, 소비 및 반환. 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;k&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;k == len()&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 당황 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 보다 큰 &lt;code&gt;VecDeque&lt;/code&gt; 의 현재 길이,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 벡터의 현재 길이보다 큰 경우,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;mid&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;mid == len()&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 당황을하고, 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 개의 문자열이 반환, 마지막 문자열합니다 ( &lt;code&gt;n&lt;/code&gt; 번째 문자열은) 문자열의 나머지 부분을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각각의 추가 슬롯, 차이에 의해 확장되는 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;value&lt;/code&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 폐쇄 호출의 결과로 채워진 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 의 반환 값 은 &lt;code&gt;Vec&lt;/code&gt; 에서 생성 된 순서대로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 문자열의 현재 길이보다 큰이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">경우 &lt;code&gt;num&lt;/code&gt; 있었던 &lt;code&gt;Some(10)&lt;/code&gt; 대신에 제 1 암의 경기 가드했을 거짓 (10)는 녹는 다음 두 번째 팔이 없기 때문에 일치하는 것이다, 제 2 암에 갈 것이라고 이하 5보다이기 때문에 성냥 가드 따라서 &lt;code&gt;Some&lt;/code&gt; 변형 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 문자열을 숫자로 켤 수, 그것은 반환 &lt;code&gt;Err&lt;/code&gt; 오류에 대한 자세한 정보가 포함되어 값입니다. &lt;code&gt;Err&lt;/code&gt; 값이 일치하지 &lt;code&gt;Ok(num)&lt;/code&gt; 제의 패턴 &lt;code&gt;match&lt;/code&gt; 아암 있지만 일치 않는 &lt;code&gt;Err(_)&lt;/code&gt; 제 2 아암의 패턴. 밑줄 &lt;code&gt;_&lt;/code&gt; 은 포괄적 인 값입니다. 이 예에서는 어떤 정보가 내부에 있는지에 상관없이 모든 &lt;code&gt;Err&lt;/code&gt; 값 을 일치 시키려고 합니다. 따라서 프로그램은 두 번째 암의 코드를 &lt;code&gt;continue&lt;/code&gt; 실행 하여 &lt;code&gt;loop&lt;/code&gt; 의 다음 반복으로 이동하도록 프로그램에 지시합니다.또 다른 추측을 요청하십시오. 따라서 프로그램은 &lt;code&gt;parse&lt;/code&gt; 할 수있는 모든 오류를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 성공적으로 문자열을 숫자로 설정 할 수 있습니다, 그것은 반환됩니다 &lt;code&gt;Ok&lt;/code&gt; 결과 수를 포함 값입니다. 해당 &lt;code&gt;Ok&lt;/code&gt; 값은 첫 번째 팔의 패턴과 &lt;code&gt;match&lt;/code&gt; 하며 일치 표현식은 &lt;code&gt;parse&lt;/code&gt; 하여 &lt;code&gt;Ok&lt;/code&gt; 값 안에 넣은 &lt;code&gt;num&lt;/code&gt; 값만 반환합니다 . 그 숫자는 우리가 만들고 있는 새로운 &lt;code&gt;guess&lt;/code&gt; 변수 에서 원하는 위치에있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 절대, 현재의 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 가 &lt;code&gt;Unpin&lt;/code&gt; 유형을 참조하지 않으면 대신 &lt;code&gt;Pin::new&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; 이 절대 경로가 아닌 경우 &lt;code&gt;PATH&lt;/code&gt; 는 OS 정의 방식으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;self &amp;lt;= other&lt;/code&gt; : &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">경우 &lt;code&gt;self.value&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 코드에 저장된 폐쇄 호출 &lt;code&gt;self.calculation&lt;/code&gt; 을 ,에 결과를 저장 &lt;code&gt;self.value&lt;/code&gt; 향후 사용을 위해, 그리고뿐만 아니라 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 이미 규정 된 정렬을 충족 한 후 반환 &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 입니다 &lt;code&gt;Some(s)&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 것입니다 &lt;code&gt;Some(o)&lt;/code&gt; ,이 메소드의 반환 &lt;code&gt;Some((s, o))&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 입니다 &lt;code&gt;Some(s)&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 것입니다 &lt;code&gt;Some(o)&lt;/code&gt; ,이 메소드의 반환 &lt;code&gt;Some(f(s, o))&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 작성된 경우 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 사용하여 만든 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 되지, 반환 값이 있기 때문에, 적어도 한 경우,이 0을 반환합니다 &lt;code&gt;self&lt;/code&gt; 가치에 아직 점.</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 생성 된 경우 &lt;code&gt;None&lt;/code&gt; 이 반환 됩니다. 그렇지 않은 경우 &lt;code&gt;self&lt;/code&gt; 는 여전히 값을 가리 키 므로 리턴 된 값은 1 이상 입니다.</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 사용하여 만든 &lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 남아있는 강력한 포인터가없는 경우, 혹은이 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;self&lt;/code&gt; 를 만든 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">경우 &lt;code&gt;some_option_value&lt;/code&gt; 이 했다 &lt;code&gt;None&lt;/code&gt; 값이이 패턴과 일치하지 않을 것이라고 &lt;code&gt;Some(x)&lt;/code&gt; 패턴을 의미하는 것은 논박이다. 그러나 &lt;code&gt;let&lt;/code&gt; 문은 코드가 &lt;code&gt;None&lt;/code&gt; 값으로 수행 할 수있는 유효한 것이 없기 때문에 반박 할 수없는 패턴 만 허용 합니다. 컴파일 타임에 Rust는 반박 할 수없는 패턴이 필요한 반박 가능한 패턴을 사용하려했다고 불평합니다.</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 구현하지 않습니다 &lt;code&gt;Copy&lt;/code&gt; 사용 &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 가 구현 &lt;code&gt;Copy&lt;/code&gt; , 그것은 사용에 더 확대됨에 될 수 &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 있었다 &lt;code&gt;None&lt;/code&gt; 값 대신 &lt;code&gt;Some(5)&lt;/code&gt; 값은 밑줄에 일치하는 것, 그래서 처음 두 팔에 패턴이 일치하지 것이다. 밑줄의 패턴에 &lt;code&gt;x&lt;/code&gt; 변수를 도입하지 않았 으므로 표현식 의 &lt;code&gt;x&lt;/code&gt; 는 여전히 음영 처리되지 않은 외부 &lt;code&gt;x&lt;/code&gt; 입니다. 이 가상의 경우, &lt;code&gt;match&lt;/code&gt; 는 &lt;code&gt;Default case, x = None&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 1, 2, 3, 4, 또는 5이고, 제 1 아암이 일치한다. 이 구문은 &lt;code&gt;|&lt;/code&gt; 같은 생각을 표현하는 연산자; 대신 &lt;code&gt;1...5&lt;/code&gt; , 우리는 지정해야 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 를 사용한 경우 &lt;code&gt;|&lt;/code&gt; . 범위를 지정하는 것이 훨씬 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 1, 2, 3, 4, 또는 5이고, 제 1 아암이 일치한다. 이 구문은 &lt;code&gt;|&lt;/code&gt; 동일한 아이디어를 표현하는 연산자; 대신 &lt;code&gt;1..=5&lt;/code&gt; , 우리는 지정해야 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 사용한 경우 &lt;code&gt;|&lt;/code&gt; . 범위를 지정하는 것이 훨씬 더 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!</target>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">만약 &lt;em&gt;main.rs은&lt;/em&gt; 당신이었다 &quot;안녕하세요, 세계!&quot; 프로그램에서이 줄은 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에.</target>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">&lt;em&gt;main.rs&lt;/em&gt; 가 당신의 Hello, world 라면 ! 프로그램,이 줄은 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에.</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Rust 코드 &lt;em&gt;가&lt;/em&gt; 해당 문자열을 조사해야하는 경우 문자열 인코딩을 처리하는 다른 Rust API에서 일반적으로 수행되는 것과 같이 &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 유효하지 않은 시퀀스를 대체하여 유실 한 UTF-8로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Rust가 역 참조 강제를 구현하지 않았다면 Listing 15-12의 코드 대신 Listing 15-13의 코드를 작성하여 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 유형의 값으로 &lt;code&gt;hello&lt;/code&gt; 를 호출 해야한다 .</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">경우 &lt;code&gt;Read&lt;/code&gt; 어 기본 오버라이드 (override)하지 않는 &lt;code&gt;read_vectored&lt;/code&gt; 구현, 그것을 사용하는 코드는 모두 함께 방법을 방지 할 수 있으며, 유착은 더 높은 성능을 위해 하나의 버퍼에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Read&lt;/code&gt; 가 초기화되지 않은 메모리가 제대로 작동 할 수있는 어 보장, 그것은 호출해야 &lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">경우 &lt;code&gt;String&lt;/code&gt; 을 다시 할당하지 않습니다 그것에 요소를 추가 충분한 용량을 가지고 있습니다. 예를 들어 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">&lt;code&gt;Vacant(entry)&lt;/code&gt; 이 나오면 키 &lt;em&gt;를&lt;/em&gt; 찾지 &lt;em&gt;못한 것&lt;/em&gt; 입니다. 이 경우 유효한 조작은 항목에 값 을 &lt;code&gt;insert&lt;/code&gt; 하는 것입니다. 이 작업이 완료되면 비어있는 항목이 소비되고 삽입 된 값에 대한 변경 가능한 참조로 변환됩니다. 이를 통해 검색 자체의 수명을 넘어서 값을 추가로 조작 할 수 있습니다. 값이 삽입되었는지 여부에 관계없이 값에 대해 복잡한 논리를 수행해야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 메모리 &lt;em&gt;를&lt;/em&gt; 할당 한 경우 할당 된 메모리가 힙에 있고 (할당 자 Rust가 기본적으로 사용하도록 정의 된대로) 포인터가 &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 초기화되고 연속 된 요소를 순서대로 가리 킵니다. 슬라이스로 강제 변환 한 다음)&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 논리적으로 초기화되지 않은, 연속적인 요소.</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">경우 &lt;code&gt;Write&lt;/code&gt; 어 기본 오버라이드 (override)하지 않는 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 구현, 그것을 사용하는 코드는 모두 함께 방법을 방지 할 수 있으며, 유착은 더 높은 성능을 위해 하나의 버퍼에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">경우 &lt;code&gt;static&lt;/code&gt; 항목이 선언되어 &lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; 키워드, 다음은 프로그램에 의해 수정 될 수있다. 그러나 변경 가능한 &lt;code&gt;static&lt;/code&gt; 에 액세스 하면 다중 스레드 컨텍스트에서 데이터 경합과 같은 여러 가지 방식으로 정의되지 않은 동작이 발생할 수 있습니다. 따라서 변경 가능한 &lt;code&gt;static&lt;/code&gt; 에 대한 모든 액세스 에는 &lt;a href=&quot;keyword.unsafe&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; &lt;/a&gt; 블록이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">아직 존재하지 않아서 &lt;em&gt;새&lt;/em&gt; 파일을 만든 경우 &lt;code&gt;.create(true)&lt;/code&gt; 또는 &lt;code&gt;.create_new(true)&lt;/code&gt; 지정되어, 새로운 파일이 속성으로 선언 주어진다 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">바인딩 패턴이 명시되어 있지 않은 경우 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ref mut&lt;/code&gt; , 또는 &lt;code&gt;mut&lt;/code&gt; , 다음은 사용 &lt;em&gt;기본 바인딩 모드&lt;/em&gt; 변수가 바인딩되는 방법을 결정합니다. 기본 바인딩 모드는 이동 의미론을 사용하는 &quot;이동&quot;모드에서 시작합니다. 패턴을 일치시킬 때 컴파일러는 패턴 외부에서 시작하여 안쪽으로 작동합니다. 비 참조 패턴을 사용하여 참조를 일치시킬 때마다 자동으로 값을 역 참조하고 기본 바인딩 모드를 업데이트합니다. 참조는 기본 바인딩 모드를 &lt;code&gt;ref&lt;/code&gt; 로 설정합니다 . 변경 가능한 참조로 모드를 설정합니다 &lt;code&gt;ref mut&lt;/code&gt; 모드가 이미하지 않는 한 &lt;code&gt;ref&lt;/code&gt; 이 경우에 남아 &lt;code&gt;ref&lt;/code&gt; . 자동 역 참조 된 값이 여전히 참조 인 경우 역 참조되고이 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="translated">차용, 역 참조, 필드 또는 튜플 인덱싱 식에 확장 된 임시 범위가 있으면 해당 피연산자도 마찬가지입니다. 인덱싱 식에 확장 된 임시 범위가있는 경우 인덱싱 된 식에도 확장 된 임시 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 소문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 대문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">클린 셧다운이 필요한 경우 더 이상 소멸자가 남아 있지 않은 알려진 지점에서만이 기능을 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">const 함수가 &lt;a href=&quot;../const_eval#const-context&quot;&gt;const 컨텍스트&lt;/a&gt; 외부에서 호출되면 다른 함수와 구별 할 수 없습니다. 정규 함수로 할 수있는 const 함수로 자유롭게 무엇이든 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">자체 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야하는 경우 &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">동적 라이브러리 또는 동적으로 링크되는 실행 파일이 생성되는 경우 컴파일러는 사용 가능한 종속성을 rlib 또는 dylib 형식으로 조정하여 최종 제품을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">읽기 및 추가 액세스 권한으로 파일이 열린 경우, 파일을 연 후, 쓰기가 끝날 때마다 읽기 위치가 파일 끝에 설정 될 수 있습니다. 따라서 쓰기 전에 현재 위치를 저장하고 ( &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; 사용 ) 다음 읽기 전에 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">읽기 및 추가 액세스로 파일을 연 경우에는 파일을 연 후 및 모든 쓰기 후에 파일의 끝에서 읽을 위치를 설정할 수 있습니다. 따라서 쓰기 전에 현재 위치를 저장하고 ( &lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; 사용 ) 다음 읽기 전에 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">이 옵션을 설정 한 상태에서 파일을 성공적으로 열면 파일이 이미 있으면 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">부동 소수점 유형이 &lt;em&gt;고유&lt;/em&gt; 할 수있는 경우&lt;em&gt;&lt;/em&gt;주변 프로그램 컨텍스트에서 판별 경우 접미사 부동 소수점 리터럴에 해당 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">언어가 객체 지향 언어가되도록 상속을 받아야하는 경우 Rust는 언어가 아닙니다. 부모 구조체의 필드와 메소드 구현을 상속하는 구조체를 정의 할 방법이 없습니다. 그러나 프로그래밍 도구 상자에서 상속을받는 데 익숙한 경우 먼저 상속 이유에 따라 Rust에서 다른 솔루션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">테스트에서 메소드 호출이 실패하면 해당 메소드가 테스트중인 기능이 아니더라도 전체 테스트에 실패 할 수 있습니다. &lt;code&gt;panic!&lt;/code&gt; 때문에 ! 테스트가 실패로 표시되는 방법입니다. &lt;code&gt;unwrap&lt;/code&gt; 또는 &lt;code&gt;expect&lt;/code&gt; 호출 하면 정확히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;File::open_opts&lt;/code&gt; 호출의 일부로 새 파일이 작성되면 이 지정된 &lt;code&gt;mode&lt;/code&gt; 가 새 파일의 권한 비트로 사용됩니다. &lt;code&gt;mode&lt;/code&gt; 를 설정 하지 않으면 기본값 &lt;code&gt;0o666&lt;/code&gt; 이 사용됩니다. 운영 체제는 &lt;code&gt;umask&lt;/code&gt; 시스템으로 비트를 마스크 하여 최종 권한을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;OpenOptions::open&lt;/code&gt; 호출의 일부로 새 파일이 생성되면 이 지정된 &lt;code&gt;mode&lt;/code&gt; 가 새 파일에 대한 권한 비트로 사용됩니다. &lt;code&gt;mode&lt;/code&gt; 가 설정 되지 않은 경우 기본값 인 &lt;code&gt;0o666&lt;/code&gt; 이 사용됩니다. 운영 체제 는 최종 권한을 생성하기 위해 시스템의 &lt;code&gt;umask&lt;/code&gt; 로 비트를 마스킹합니다 .</target>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="translated">nul 바이트가 있고 마지막 요소가 없거나 nul ​​바이트가 없으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">명명 된 스레드에서 패닉이 발생하면 스레드 이름이 패닉 메시지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">프로그램에 산술 오버플로가 포함되어 있으면 프로그래머가 오류를 범한 것입니다. 다음 논의에서, 우리는 산술 오버 플로우와 랩핑 산술의 구별을 유지합니다. 첫 번째는 잘못된 반면 두 번째는 의도적 인 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">정적 키워드 가 &lt;code&gt;mut&lt;/code&gt; 키워드로 선언 되면 프로그램이이를 수정할 수 있습니다. Rust의 목표 중 하나는 동시성 버그가 발생하기 어렵게 만드는 것이며, 이는 경쟁 조건 또는 기타 버그의 매우 큰 원인입니다. 이러한 이유로, 가변 정적 변수를 읽거나 쓸 때 &lt;code&gt;unsafe&lt;/code&gt; 블록이 필요합니다. 동일한 프로세스에서 실행중인 다른 스레드와 관련하여 변경 가능한 정적에 대한 수정이 안전하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">정적 라이브러리가 생성되는 경우 모든 업스트림 종속성이 &lt;code&gt;rlib&lt;/code&gt; 에서 사용 가능해야합니다. 형식 . 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환 할 수없는 이유에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">일반 메소드 또는 특성이 동일한 것으로 간주되는 경우와 같이 둘 이상의 가능한 메소드가있는 단계에 도달하면 컴파일러 오류입니다. 이러한 경우 메소드 및 함수 호출을위한 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;명확한 함수 호출 구문&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">문자열에 연속 된 여러 구분 기호가 포함되어 있으면 출력에 빈 문자열이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">유형 &lt;code&gt;Item&lt;/code&gt; 에 특성 &lt;code&gt;Trait&lt;/code&gt; 의 연관 유형 &lt;code&gt;Assoc&lt;/code&gt; 이있는 경우 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 은 연관된 유형 정의에 지정된 유형의 별명 인 유형입니다. 또한 &lt;code&gt;Item&lt;/code&gt; 이 유형 매개 변수 인 경우 &lt;code&gt;Item::Assoc&lt;/code&gt; 을 형식 매개 변수에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">유형에 &lt;code&gt;PhantomPinned&lt;/code&gt; 가 포함 된 경우 기본적으로 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">모두 잘되면 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에 인쇄해야합니다. &lt;code&gt;cargo build&lt;/code&gt; 를 처음으로 실행 하면 Cargo는 최상위 레벨 &lt;em&gt;Cargo.lock에&lt;/em&gt; 새 파일을 작성합니다 . 이 파일은 프로젝트에서 정확한 버전의 종속성을 추적합니다. 이 프로젝트에는 종속성이 없으므로 파일이 약간 희박합니다. 이 파일을 수동으로 변경할 필요는 없습니다. 화물은 당신을 위해 그 내용을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">경우 &lt;code&gt;Alloc&lt;/code&gt; 구현이 돌아 선택 &lt;code&gt;Ok&lt;/code&gt; 이 경우 반환 포인터가 &quot;현재 할당&quot;으로 간주해야한다고 다음 (즉, 포인터가 0 크기의 액세스 블록을 의미한다). 이러한 할당 자에서 현재 할당 된 포인터를 입력으로 사용하는 &lt;em&gt;모든&lt;/em&gt; 메서드는 정의되지 않은 동작 &lt;em&gt;을&lt;/em&gt; 발생 &lt;em&gt;시키지 않고&lt;/em&gt; 크기가 0 인 포인터를 수용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">경우 &lt;code&gt;Err(e)&lt;/code&gt; 결과가 반환되는, 값 &lt;code&gt;e&lt;/code&gt; 바깥 쪽 범위의 리턴 타입 (그 자체가 구현해야하는 「랩」됩니다 &lt;code&gt;Try&lt;/code&gt; ). 특히 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; 이 반환됩니다. 여기서 &lt;code&gt;X&lt;/code&gt; 는 둘러싸는 함수의 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">는 IF &lt;code&gt;Occupied(entry)&lt;/code&gt; 산출되고, 그 키를 &lt;em&gt;한&lt;/em&gt; 발견했다. 이 경우, 사용자는 여러 가지 옵션이 있습니다 : 그들은 수 있습니다 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 점령 항목의 값을. 또한, 점유 된 항목을 해당 값에 대한 변경 가능한 참조로 변환하여 빈 &lt;code&gt;insert&lt;/code&gt; 케이스에 대칭을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">는 IF &lt;code&gt;rlib&lt;/code&gt; 의 파일이 생성되고, 그 상류 종속성에서 사용할 수있는 형식을 무엇에 아무런 제한이 없습니다. 단순히 모든 업스트림 의존성에서 메타 데이터를 읽을 수있는 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;기존&lt;/em&gt; 파일이 열립니다 &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; , 기존의 속성은 보존으로 선언 된 것들과 결합 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">I / O 오류가 발생하면 지금까지 읽은 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 있으며 길이가 적절하게 조정 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">실행 파일이 생성되고 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; 플래그가 지정되지 않은 경우 우선 &lt;code&gt;rlib&lt;/code&gt; 형식으로 종속성을 찾습니다 . rlib 형식으로 일부 종속성을 사용할 수없는 경우 동적 연결이 시도됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="translated">impl에 &lt;code&gt;#[may_dangle]&lt;/code&gt; 속성 이있는 일반 매개 변수가있는 경우 해당 impl은 &lt;code&gt;unsafe impl&lt;/code&gt; 로 선언되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">impl에 &lt;code&gt;#[may_dangle]&lt;/code&gt; 속성 이있는 일반 매개 변수가있는 경우 해당 impl은 `안전하지 않은 impl로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">주변 프로그램 컨텍스트에서 정수 유형을 &lt;em&gt;고유하게&lt;/em&gt; 판별 할 수있는 경우 접미사없는 정수 리터럴이 해당 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="translated">내장 함수가 &lt;code&gt;rustc_const_stable&lt;/code&gt; 속성 과 함께 &lt;code&gt;const fn&lt;/code&gt; 에서 사용되어야하는 경우 내장 속성도 &lt;code&gt;rustc_const_stable&lt;/code&gt; 이어야합니다 . 이러한 변경은 컴파일러 지원 없이는 사용자 코드에서 복제 할 수없는 언어로 기능을 베이크하므로 T-lang 협의없이 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">개인 항목 인 경우 현재 모듈과 해당 하위 항목에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">항목이 공개되면, 다음은 몇 가지 모듈에서 외부에서 액세스 할 수 &lt;code&gt;m&lt;/code&gt; 당신은 모든 항목의 상위 모듈에 액세스 할 수 있는지 &lt;code&gt;m&lt;/code&gt; . 다시 내보내기를 통해 항목의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">항목이 공개되면, 다음은 몇 가지 모듈에서 외부에서 액세스 할 수 &lt;code&gt;m&lt;/code&gt; 당신은 모든 항목의 부모 모듈에 액세스 할 수 있는지 &lt;code&gt;m&lt;/code&gt; . 재수출을 통해 항목의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="translated">반복기 어댑터가 패닉하면 반복기는 지정되지 않은 (그러나 메모리 안전) 상태가됩니다. 또한이 상태는 Rust 버전간에 동일하게 유지된다는 보장이 없으므로 당황한 반복자가 반환하는 정확한 값에 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 잠금 장치가 손상 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 뮤텍스가 중독 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우이 호출은 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우,이 호출은 뮤텍스가 획득되면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우, 뮤텍스를 획득하면이 호출은 실패를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로에있는 디렉토리로 지정하면 &lt;code&gt;path&lt;/code&gt; 가 존재하지 않으며, 그렇지 않으면 만들 수 없습니다. 디렉토리가 생성 될 때 (존재하지 않는 것으로 확인 된 후)에 대한 특정 오류 조건은 &lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt; 로 요약됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">다음 조건 중 하나라도 위반하면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이미 읽은 바이트는 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">둘 다없는 경우 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">둘 다 존재하지 않으면 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">dylib로 컴파일 된 경우 결과 .so는 C 라이브러리에서 링크 될 수 있으며 다른 라이브러리에서 온 것처럼 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">두 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 압축 된 반복자로부터 반환하지 않습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . 최초의 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;zip&lt;/code&gt; 단락 것이다 &lt;code&gt;next&lt;/code&gt; 두 번째 반복자에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">활성화되면 멀티 캐스트 패킷이 로컬 소켓으로 루프백됩니다. IPv6 소켓에는 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">활성화되면 멀티 캐스트 패킷이 로컬 소켓으로 루프백됩니다. 이것은 IPv6 소켓에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">언어가 객체 지향으로 간주되기 위해 캡슐화가 필수 요소 인 경우 Rust는 해당 요구 사항을 충족합니다. 다른 코드 부분에 &lt;code&gt;pub&lt;/code&gt; 을 사용 하거나 사용 하지 않는 옵션을 사용 하면 구현 세부 정보를 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">튜플 내부의 모든 유형이 다음 특성 중 하나를 구현하면 튜플 자체도이를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">일반 코드가 관련 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공 할 수있는 모든 유형에 &lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 경우 더 많은 유형이 안전하게 구현할 수 있으므로 AsRef &amp;lt;T&amp;gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="translated">제네릭 코드가 관련 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공 할 수있는 모든 유형에 대해 작동해야하는 경우 더 많은 유형이 안전하게 구현할 수 있으므로 [ &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; ] 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">위치가 지정되면 해당 위치의 요소에 대한 참조를 리턴하거나 범위를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">범위가 지정되면 해당 범위에 해당하는 하위 슬라이스를 반환하거나 범위 를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">그렇다면 반환하는 값 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">그렇지 않으면 아무 것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="translated">포인터를 정렬 할 수없는 경우 구현은 &lt;code&gt;usize::MAX&lt;/code&gt; 반환합니다 . 구현시 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;usize::MAX&lt;/code&gt; 반환 하는 것이 허용됩니다 . 알고리즘의 성능은 정확성이 아니라 여기서 사용 가능한 오프셋을 얻는 데 달려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">포인터를 정렬 할 수 없으면 구현에서 &lt;code&gt;usize::max_value()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">가능하면 가능한 각 유형 대체에 대한 함수를 작성하여 코드를 수동으로 변형하십시오. 예를 들어 특성을 사용하여이를 명확하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개 미만의 요소를 사용할 수있는 경우 &lt;code&gt;take&lt;/code&gt; 는 기본 반복기의 크기로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 생성 과 &lt;code&gt;mem::forget()&lt;/code&gt; 호출 사이에 더 많은 코드가 추가 되면 동일한 메모리가 &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;s&lt;/code&gt; 모두에서 처리되기 때문에 내부 패닉으로 인해 이중 해제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식 에 대해 동일한 팔에서 여러 패턴이 사용되는 경우 지정되지 않은 패턴이 드롭 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">필요한 경우 사용자 지정 대상 사양을 사용하여이 검사를 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">이러한 규칙 중 어느 것도 적용되지 않으면 특성의 경계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">사용자 정의 후크가 등록되지 않은 경우 기본 후크가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">지정된 유형의 자동 특성에 대해 명시 적 구현 또는 부정적인 구현이 작성되지 않은 경우 컴파일러는 다음 규칙에 따라 자동 구현을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="translated">강력한 포인터가 남아 있지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="translated">그렇지 않은 경우 한 번에 하나씩 클로저를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 다른 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">일부 메서드 만 객체로부터 안전하지 않은 경우 특성 : 객체에 명시 적으로 사용할 수없는 것으로 표시하기 위해 &lt;code&gt;where Self: Sized&lt;/code&gt; 제한을 추가 할 수 있습니다 . &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 과 같은 다른 모든 구현자는이 기능을 계속 사용할 수 있습니다 ( Box &amp;lt;Trait&amp;gt;의 &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 한다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">우리의 프로젝트 만이 포함 진 상자 인 경우 &lt;em&gt;SRC / main.rs의&lt;/em&gt; 파일을하고 있지 않습니다 &lt;em&gt;SRC / lib.rs의&lt;/em&gt; 파일을, 우리는에서 통합 테스트를 작성할 수 없습니다 &lt;em&gt;테스트를&lt;/em&gt; 디렉토리에 정의 가져 기능 &lt;em&gt;/ 주요 SRC를 .rs&lt;/em&gt; 는 &lt;code&gt;use&lt;/code&gt; 문을 사용 하여 범위 내에 있습니다 . 라이브러리 상자 만 다른 상자가 사용할 수있는 기능을 노출합니다. 이진 상자는 자체적으로 실행되도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">요구 사항이 변경되고 &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 으로 이동할 수 있어야하는 경우 문제가 발생합니다. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 에서 포인터 &lt;code&gt;Owner&lt;/code&gt; 에 &lt;code&gt;Gadget&lt;/code&gt; 는 값 사이에주기를 도입합니다. 이는 참조 카운트가 0에 도달 할 수 없으며 메모리 누출이라는 ​​값이 영원히 할당 된 상태로 유지됨을 의미합니다. 이 문제를 해결하기 위해 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">요구 사항이 변경되고 &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 으로 이동할 수 있어야하는 경우 문제가 발생합니다. &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 의 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 는주기를 도입합니다. 이는 참조 횟수가 0에 도달 할 수 없으며 할당이 절대 파괴되지 않음을 의미합니다. 메모리 누수입니다. 이 문제를 해결하기 위해 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">구문 분석에 성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 안에 값을 반환하고 , 그렇지 않으면 문자열 형식이 잘못된 경우 내부에 특정한 오류를 반환&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 에&lt;/a&gt;. 오류 유형은 특성의 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">설정된 경우이 옵션은 Nagle 알고리즘을 비활성화합니다. 즉, 적은 양의 데이터 만 있더라도 세그먼트는 가능한 한 빨리 전송됩니다. 설정하지 않으면 데이터를 보낼 양이 충분해질 때까지 데이터가 버퍼링되므로 작은 패킷이 자주 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최대 인 경우 마지막 요소가 반환됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최소 인 경우 첫 번째 요소가 리턴됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">누군가 코드를 호출하고 의미가 맞지 않는 값을 전달하면 &lt;code&gt;panic!&lt;/code&gt; 을 호출하는 것이 가장 좋습니다 ! 라이브러리를 사용하는 사람에게 코드의 버그를 알려 주어 개발 중에 수정할 수 있도록합니다. 비슷하게, &lt;code&gt;panic!&lt;/code&gt; 제어 할 수없는 외부 코드를 호출하고 수정 방법이없는 잘못된 상태를 반환하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">우리의 라이브러리를 사용하여 누군가가 구현하기로 결정하면 &lt;code&gt;SelectBox&lt;/code&gt; 가지고 구조체 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , 및 &lt;code&gt;options&lt;/code&gt; 필드를 그들은 구현 &lt;code&gt;Draw&lt;/code&gt; 상의 특성 &lt;code&gt;SelectBox&lt;/code&gt; Listing 17-8에 표시된 것처럼 유형에서도 .</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 반환되며 여기서 지속 시간은 지정된 측정에서이 측정까지 경과 한 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;buf&lt;/code&gt; 에 읽고 추가 된 바이트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">성공하면이 함수는 읽은 총 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">소유권을 얻는 것이 옵션이 아닌 경우 인덱스를 사용하는 것도 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">해당 필드의 유형이 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 인 경우 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 하는 동안 연결이 끊어 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . 마찬가지로 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 를 시도하는 동안 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 연결이 끊어 지면 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; 를 반환합니다 . .</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">는 IF &lt;code&gt;documentation&lt;/code&gt; 환경 변수가 정의되지 않으며, 다음과 같은 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">는 IF &lt;code&gt;move&lt;/code&gt; 키워드를 사용, 모든 캡처를 위해, 이동에 의해 또는 &lt;code&gt;Copy&lt;/code&gt; 유형, 복사에 의해 관계없이의 차용이 작동할지 여부. &lt;code&gt;move&lt;/code&gt; 키워드는 일반적으로 폐쇄는 폐쇄 반품 새로운 스레드를 생성하는 데 사용되는 경우로 캡처 한 값을, 오래 살 수 있도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우] &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;core&lt;/code&gt; 크레이트의 매크로 ( &lt;code&gt;std&lt;/code&gt; 가 아닌 )가 형식화 문자열 및 일부 추가 인수와 함께 사용되었으며, 예를 들어 &lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수있는 메시지를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">는 IF &lt;code&gt;push_str&lt;/code&gt; 의 방법은 소유권했다 &lt;code&gt;s2&lt;/code&gt; , 우리는 마지막 줄에 그 값을 인쇄 할 수 없습니다. 그러나이 코드는 예상대로 작동합니다!</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">상기 중간 &lt;code&gt;self&lt;/code&gt; 파라미터 접두어 &lt;code&gt;mut&lt;/code&gt; , 그것을 사용하여 일반 파라미터 유사한 가변 변수된다 &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;식별자 패턴&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 작은 현재 파일의 크기보다, 다음 파일이 수축 될 것입니다. 그것은 현재 파일의 크기보다 큰 경우, 파일이 확장 될 것입니다 &lt;code&gt;size&lt;/code&gt; 와 0으로 채워 중간 데이터를 모두 가지고있다.</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">이때 액세스 권한을 부여 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 공유 액세스가 삭제 될 때 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">실제 유형이 드롭 접착제를 필요로하거나 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않으면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="translated">실제 유형에 drop glue가 필요하지 않거나 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않으면 이 함수의 반환 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">두 포인터간에 다른 주소가 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 배수가 아닌 경우 나누기 결과는 0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">배열에 32 개 이하의 요소가있는 경우 (위 참조) 배열 참조의 &lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 구현을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">Cargo가 사용자 환경에서 얻은 작성자 정보가 올바르지 않은 경우 파일에서 수정 한 후 다시 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼에 데이터가 없으면 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; 를&lt;/a&gt; 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼에 데이터가 없으면 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; 를&lt;/a&gt; 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">용량이 &lt;code&gt;usize&lt;/code&gt; 오버플 로되거나 할당자가 오류를보고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">용량이 초과되거나 할당자가 실패를보고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">자식이 종료되면 &lt;code&gt;Ok(Some(status))&lt;/code&gt; 가 반환됩니다. 현재 종료 상태를 사용할 수 없으면 &lt;code&gt;Ok(None)&lt;/code&gt; 이 반환됩니다. 오류가 발생하면 해당 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자식 스레드가 패닉하면 패닉에 주어진 매개 변수와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자식 스레드 패닉 이 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; 하면 panic에 지정된 매개 변수와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">클로저가 이동중인 값보다 오래 지속될 수없는 경우 이동하는 대신 참조를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">클로저가 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; 반환하면 해당 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 맵에서 제거되고 양보됩니다. 클로저가 false를 반환하거나 패닉이 발생하면 요소가지도에 남아 있으며 양보되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 목록에 유지되며 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 벡터에 남아 있고 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 참을 반환하면 값이 제거되고 양보됩니다. 클로저가 false를 반환하면 값은 목록에 남아 있고 반복기에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] 슬라이스 와 함께 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 유효하지 않은 UTF-8 시퀀스를 &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 바꾸고 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 를 결과와 함께 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 슬라이스를 리턴합니다 . 그렇지 않으면 UTF-8 유효성 검사가 실패한 위치에 대한 세부 정보가 포함 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 슬라이스를 반환합니다 . 그렇지 않으면 UTF-8 유효성 검사가 실패한 위치에 대한 세부 정보와 함께 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">해당 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 가 연결을 끊었 거나이 호출이 차단되는 동안 연결이 끊어지면이 호출은 깨어나 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환 하여이 채널에서 더 이상 메시지를 수신 할 수 없음을 나타냅니다. 그러나 채널이 버퍼링되므로 연결 끊기 전에 전송 된 메시지는 여전히 제대로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">이 스트림의 데이터가 유효한 UTF-8 이 &lt;em&gt;아닌&lt;/em&gt; 경우 오류가 리턴되고 &lt;code&gt;buf&lt;/code&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 정의가 제어 할 수있는 경우 가장 간단한 해결책은 데이터를 가변적으로 캡처하는 것입니다. Fn 대신 FnMut을 사용하도록 &lt;code&gt;foo&lt;/code&gt; 를 정의하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">대상 유형이 현재 상자의 일부가 아닌 경우에 당신은 구현할 수 없습니다 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 직접. 예를 들어 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드에 도달 할 수 없다는 결정이 틀린 것으로 판명되면 프로그램은 즉시 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 종료됩니다 ! .</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복기의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현하지 않거나 반복 된 요소를 메모리에 유지하지 않으려면 대신 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt; 함수 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현하지 않거나 반복 된 요소를 메모리에 유지하지 않으려면 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복기의 요소 유형이 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; 을&lt;/a&gt; 구현 하고 소스 요소를 메모리에 유지하는 것이 괜찮다면 대신 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt; 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현 하고 소스 요소를 메모리에 유지하는 것이 좋다면 대신 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">환경 변수가 정의되어 있지 않으면 컴파일 오류가 발생합니다. 컴파일 오류를 발생시키지 않으려면 &lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;대신 매크로.</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">실행 파일이 심볼릭 링크를 통해 호출 된 경우 일부 플랫폼은 심볼릭 링크의 경로를 반환하고 다른 플랫폼은 심볼릭 링크 대상의 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">이들 강요 부위 중 하나에서의 발현이 강요-전파 발현 인 경우, 그 발현의 관련 하위-발현도 강요 부위이다. 전파는이 새로운 강제 사이트에서 반복됩니다. 전파 표현 및 관련 하위 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">기능이 승인되면 Rust 저장소에서 문제가 열리고 누군가가이를 구현할 수 있습니다. 잘 구현 한 사람은 처음에 기능을 제안한 사람이 아닐 수도 있습니다! 구현이 준비되면 &lt;a href=&quot;#unstable-features&quot;&gt;&quot;불안정한 기능&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기능 게이트 뒤 의 &lt;code&gt;master&lt;/code&gt; 브랜치에 도달 합니다.</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">파일이 이미 존재하면 파일을 쓸 때 파일을 자르지 않고 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">첫 번째 요소가 일치하면 빈 슬라이스가 반복자가 반환 한 첫 번째 항목이됩니다. 마찬가지로 슬라이스의 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 용량이 &lt;code&gt;0&lt;/code&gt; 이면 할당이 발생하지 않으며이 방법은 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 용량이 &lt;code&gt;0&lt;/code&gt; 이면 할당이 발생하지 않으며이 방법은 &lt;a href=&quot;struct.string#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">주어진 클로저 가 동일한 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;code&gt;call_once&lt;/code&gt; 를 재귀 적으로 호출 하는 경우 정확한 동작이 지정되지 않은 경우 허용되는 결과는 패닉 또는 교착 상태입니다.</target>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">지정된 클로저 가 동일한 &lt;code&gt;Once&lt;/code&gt; 인스턴스에서 &lt;code&gt;call_once&lt;/code&gt; 를 재귀 적으로 호출 하는 경우 정확한 동작이 지정되지 않으면 허용되는 결과는 패닉 또는 교착 상태입니다.</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">입력이 NaN이 아닌 경우 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">항목이 함수이면 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">항목이 수정되면 최악의 시간 복잡도는 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; ))이고 그렇지 않으면 &lt;em&gt;O&lt;/em&gt; (1)입니다.</target>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">항목이 현재 모듈에 정의되어 있지 않으면 다음 과 같이 &lt;code&gt;use&lt;/code&gt; 문을 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">가져 오는 항목이 현재 모듈의 일부 수퍼 모듈에 정의되어 있지 않으면 공용으로 선언해야합니다 (예 : &lt;code&gt;pub fn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">반복기가 부분적으로 만 사용되거나 전혀 사용되지 않는 경우 나머지 각 요소는 여전히 클로저의 대상이되고 true를 반환하면 제거되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">반복기가 부분적으로 만 사용되거나 전혀 사용되지 않는 경우 나머지 각 값은 여전히 ​​닫히고 true를 반환하면 제거되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="translated">조각의 마지막 요소가 일치하면 해당 요소는 이전 조각의 종결 자로 간주됩니다. 해당 슬라이스는 반복자가 반환하는 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="translated">문자열의 마지막 요소가 일치하면 해당 요소는 이전 하위 문자열의 종결 자로 간주됩니다. 해당 하위 문자열은 반복자가 반환하는 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="translated">길이가 일치하지 않으면 입력이 &lt;code&gt;Err&lt;/code&gt; 로 돌아옵니다 .</target>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">스레딩과 같이 참조의 수명이 충분하지 않으면 &lt;code&gt;Arc&lt;/code&gt; 를 사용하여 참조 카운트 값을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴됩니다. 가드가 떨어지면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 잠금이 해제 될 때 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">메인 스레드 패닉이 발생하면 모든 스레드가 종료되고 코드 &lt;code&gt;101&lt;/code&gt; 로 프로그램이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">맵에이 키가있는 경우 값이 업데이트되고 이전 값이 반환됩니다. 하지만 키는 업데이트되지 않습니다. 이것은 동일하지 않고 &lt;code&gt;==&lt;/code&gt; 일 수있는 유형에 중요 합니다. 자세한 내용은 &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;모듈 수준 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">지도에이 키가 있으면 값이 업데이트되고 이전 값이 반환됩니다. 그러나 키는 업데이트되지 않습니다. 이것은 동일하지 않고 &lt;code&gt;==&lt;/code&gt; 일 수있는 유형에 중요 합니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">명명 환경 변수 컴파일시에 존재하는 경우, 이러한 유형의 표현으로 확장 할 &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 그 값이 &lt;code&gt;Some&lt;/code&gt; 환경 변수의 값을. 환경 변수가 없으면 &lt;code&gt;None&lt;/code&gt; 으로 확장됩니다 . 이 유형에 대한 자세한 내용 은 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">패턴의 요소 수가 튜플의 요소 수와 일치하지 않으면 전체 유형이 일치하지 않으며 컴파일러 오류가 발생합니다. 예를 들어, 목록 18-5는 세 개의 요소가있는 튜플을 두 개의 변수로 구조화하려는 시도를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">나노초의 수가 10 억을 초과하면 (초당 나노초의 수) 제공된 초로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">경로가 일반 파일 인 경우 파일 이름입니다. 디렉토리 경로 인 경우 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 순방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 순방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 그 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="translated">패턴이 &lt;code&gt;let&lt;/code&gt; 문이 연장 패턴 다음 초기화 표현의 임시 범위가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">술어가 true이면, &lt;code&gt;cfg&lt;/code&gt; 속성 이없는 것으로 재 작성됩니다 . 술어가 false 인 경우 소스 코드에서 해당 내용이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">프로세스가 신호에 의해 종료 된 경우 해당 신호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 과도하게 제한하는 경우 정적 유형 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본값은 &lt;code&gt;f64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본적으로 부호있는 32 비트 정수 &lt;code&gt;i32&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">프로그램 경로가 상대적인 경우 (예 : &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ) 부모의 작업 디렉토리 또는 &lt;code&gt;current_dir&lt;/code&gt; 과 관련하여 해석해야하는지 모호합니다 . 이 경우의 동작은 플랫폼에 따라 다르고 불안정하므로 &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; 프로그램 을 사용 하여 절대 프로그램 경로를 얻는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">수신기 입력이있는 경우 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , 그 다음에 기준의 수명 &lt;code&gt;Self&lt;/code&gt; 모두 생략 된 출력 유효 기간 파라미터에 할당된다.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">반복이 0 번 일치 할 수 있으면 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; ), 이후에 오는 것은 무엇이든 따라 올 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">반복이 여러 번 반복 될 수있는 경우 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; ) 내용이 스스로 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">반복에 구분 기호가 포함 된 경우 해당 구분 기호는 반복 내용을 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">이 방법의 결과가 동일한 아키텍처에 의해서만 조작된다면, 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 합니다. 반환 값이 &lt;code&gt;0&lt;/code&gt; 이면 일반적으로 기본 개체가 더 이상 바이트를 받아 들일 수 없으며 앞으로는 더 이상 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">반환 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt; 이 보장되어야합니다 . 반환 값 &lt;code&gt;0&lt;/code&gt; 은 일반적으로 기본 개체가 더 이상 바이트를받을 수없고 앞으로도 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">이 메소드의 리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 보장되어야합니다 . &lt;code&gt;n&lt;/code&gt; 이 아닌 n 값은 버퍼 &lt;code&gt;buf&lt;/code&gt; 가이 소스의 &lt;code&gt;n&lt;/code&gt; 바이트 데이터 로 채워 졌음을 나타냅니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 경우 두 시나리오 중 하나를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">탐색 작업이 성공적으로 완료되면이 메서드는 스트림 시작 부분에서 새 위치를 반환합니다. 이 위치는 나중에 &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 항목이 업데이트되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">세트에이 값이 없으면 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">슬라이스가 &lt;code&gt;size&lt;/code&gt; 보다 짧은 경우 :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">슬라이스가 정렬되면 첫 번째로 반환 된 슬라이스에 중복이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">소켓이 연결되어 있지 않으면 &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; 오류 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 끝나지 않는 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">문자열로 시작하지 않으면 &lt;code&gt;prefix&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">패턴과 문자열의 끝 경우 &lt;code&gt;suffix&lt;/code&gt; , &lt;code&gt;Some&lt;/code&gt; 접미사가 제거 된 문자열로 반환됩니다. &lt;code&gt;trim_end_matches&lt;/code&gt; 와 달리 메서드는 접미사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">문자열이 &lt;code&gt;prefix&lt;/code&gt; 패턴으로 시작 하면 &lt;code&gt;Some&lt;/code&gt; 은 접두사가 제거 된 부분 문자열과 함께 반환됩니다. &lt;code&gt;trim_start_matches&lt;/code&gt; 와 달리 메서드는 접두사를 정확히 한 번 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 특성 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어진 경우 해당 유형의 객체를 확실히 반환 하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">특성 &lt;code&gt;Trait&lt;/code&gt; 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어 졌기 때문에 괜찮습니다. 형식이 해당 형식의 개체를 확실히 반환 .</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">특성에 수명 한계가없는 경우 수명은 표현식에서 유추되며 &lt;code&gt;'static&lt;/code&gt; 표현식 외부에서 정적 입니다.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">특성이 단일 수명 &lt;em&gt;한계&lt;/em&gt; 로 정의 &lt;em&gt;된&lt;/em&gt; 경우 해당 한계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">trait 객체가 제네릭 형식의 형식 인수로 사용되는 경우 포함 형식을 먼저 사용하여 바운드를 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 유형 중 하나로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 문법에 의해 생성되는 유형으로 제한됩니다 (여기서 &lt;code&gt;'lt&lt;/code&gt; 임의의 수명을 나타냄).</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">실수로 형식 매개 변수가 포함 된 경우 아래에 표시된 것처럼 형식 매개 변수를 간단히 제거하면이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;code&gt;Unpin&lt;/code&gt; , &lt;code&gt;Pin::get_mut&lt;/code&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 작성 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 액세스 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 쓰기 시간을 지원하지 않으면 반환 된 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 지정되지 않은 꼬리면 가 다음 :</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">사용자가 선호하는 색상을 지정하면 해당 색상이 배경색입니다. 오늘이 화요일이면 배경색이 녹색입니다. 사용자가 나이를 문자열로 지정하고 숫자로 구문 분석 할 수있는 경우 숫자 값에 따라 색상이 자주색 또는 주황색입니다. 이러한 조건 중 어느 것도 해당되지 않으면 배경색이 파란색입니다.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">사용자가 고강도 운동을 원한다면 몇 가지 추가 논리가 있습니다. 앱에서 생성 된 난수 값이 3이면 앱은 휴식과 수화를 권장합니다. 그렇지 않으면 복잡한 알고리즘을 기반으로 몇 분 동안 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌린 다음 이동해야하는 경우 범위가 지정된 블록을 사용하여 빌림의 수명을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌려야하는 경우 범위가 지정된 블록을 사용하여 빌려주기를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;되면 일치하는 요소의 색인을 포함하는 Result :: Ok 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수없는 경우정렬 된 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 인덱스를 포함하는&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">패턴 가드에서 값을 사용하는 경우 복제본을 사용해도 소유권이 이동하지 않으므로 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">벡터가 정렬되면 모든 복제본이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="translated">여러 유형이 관련된 경우, 이들과 상호 작용하는 유일한 방법은 트레이 트의 인터페이스를 통하는 것이며, 동적 디스패치에 의존해야하는 것도 허용 가능 &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;합니다&lt;/a&gt; . &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; 또는 &lt;code&gt;Arc&lt;/code&gt; 와 같은 다른 컨테이너 유형과 .</target>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="translated">다른 것이 없다면 &lt;code&gt;Rc&lt;/code&gt; 이 할당에 대한 Rc 포인터&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 대한 포인터는 연결 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">이 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 없으면 이 값에 대한 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터의 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 새 할당을 만들고 내부 값에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 하여 고유 한 소유권을 보장합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가 &lt;code&gt;make_mut&lt;/code&gt; 는 고유 한 소유권을 보장하기 위해 내부 값에서 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터가있는 경우 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 새 할당에 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 있으면 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 방식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">단일 유형이 관련된 경우 &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">포함 유형에서 고유 한 경계가있는 경우 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">매개 변수에 사용 된 수명이 정확히 하나 (필요한지 여부) 인 경우 해당 수명은 &lt;em&gt;모든&lt;/em&gt; 생략 된 출력 수명에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">포함 유형에서 둘 이상의 바운드가있는 경우 명시 적 바운드를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">첨부 데이터가없는 경우에 &lt;em&gt;임의의&lt;/em&gt; 열거의 변형 후 판별 직접 선택 및 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 가 삭제 될 때 버퍼에 여전히 부분 라인이 있으면 해당 내용을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt; &lt;code&gt;last_os_error&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt; &lt;code&gt;from_raw_os_error&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;struct.error#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 를 통해 생성 된 경우이 함수는 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;last_os_error&lt;/code&gt; 또는 &lt;code&gt;from_raw_os_error&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환하고, 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 소문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 대문자 매핑이 없으면 반복기는 동일한 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 소문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 에 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 가&lt;/a&gt; 제공하는 일대일 대문자 매핑이있는 경우 반복기는 해당 &lt;code&gt;char&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;char&lt;/code&gt; 가 특별한 고려 사항 (예 : 다중 &lt;code&gt;char&lt;/code&gt; )을 필요로하는 경우 반복기 는 &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; 에&lt;/a&gt; 의해 제공된 &lt;code&gt;char&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장이 여러분의 관심을 불러 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;일으켰고&lt;/a&gt; 자신 만의 스마트 포인터를 구현하고 싶다면 &amp;ldquo;The Rustonomicon&amp;rdquo; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장에서 관심을 끌고 자신 만의 스마트 포인터를 구현하려는 경우 &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;Rustonomicon&amp;rdquo;&lt;/a&gt; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;을 발견하면 &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">이 함수가 버퍼를 완전히 채우기 전에 &quot;파일 끝&quot;이 발생하면 &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; 종류의 오류를 반환합니다 . 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">이 함수에 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류가 발생하면 오류가 무시되고 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">이 함수에 임의의 I / O 형식 또는 기타 오류가 발생하면 오류 변형이 반환됩니다. 오류가 리턴되면 읽은 바이트가 없음을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">이 함수가 &lt;code&gt;Ok(0)&lt;/code&gt; 반환 하면 스트림이 EOF에 도달 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">이 함수가 오류를 반환하면 읽은 바이트 수는 지정되지 않지만 버퍼를 완전히 채우는 데 필요한 것보다 더 이상 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">이것이 버퍼링 된 채널 인 경우, 현재 버퍼가 가득 찼습니다. 이것이 버퍼링 된 채널이 아닌 경우 , 데이터를 획득 할 수있는 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">이것이 옵션이 아닌 경우 유형 매개 변수를 다른 특성 오브젝트로 바꾸는 것을 고려하십시오 (예 &lt;code&gt;T: OtherTrait&lt;/code&gt; 인 경우 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). 이 방법에 제공하려는 유형의 수가 제한되어 있으면 다른 유형의 방법을 수동으로 나열 해보십시오.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">이번이 처음 인 경우 표준 라이브러리에 대한 문서가 우연히 사용되도록 작성되었습니다. 재미있는 것을 클릭하면 일반적으로 흥미로운 장소로 연결됩니다. 여전히 놓치고 싶지 않은 중요한 것들이 있으므로 표준 라이브러리와 설명서를 둘러보십시오.</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 리턴 하면 메모리 블록의 소유권이이 할당 자에게 전송되지 않고 메모리 블록의 내용이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 &lt;code&gt;Ok(addr)&lt;/code&gt; 리턴하면 , 리턴 된 &lt;code&gt;addr&lt;/code&gt; 은 &lt;code&gt;layout&lt;/code&gt; 인스턴스를 보유하기에 적합한 스토리지 블록을 가리키는 널이 아닌 주소 입니다.</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">이 메소드가 널을 리턴하면, 메모리 블록의 소유권이이 할당 자로 전송되지 않았으며 메모리 블록의 내용은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">이로 인해 여러 후보가 발생하면 오류가 발생하며 수신자는 메소드를 호출하기 위해 적절한 수신자 유형 으로 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;변환&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">이것이 &lt;code&gt;Err&lt;/code&gt; 을 리턴하면 , 메모리 블록은 여전히 ​​원래 (더 큰) &lt;code&gt;layout&lt;/code&gt; 나타내는 것으로 간주됩니다 . 다른 곳에서 재사용하기 위해 블록을 조각하지 않았으며 메모리 블록의 소유권이 이전되지 않았으며 메모리 블록의 내용이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조되는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 해제되었거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 메소드의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 , 그 크기의 레이아웃과 &lt;code&gt;layout&lt;/code&gt; 과 같은 정렬의 데이터를 전달하는데 사용될 수 있다고 주장했다 . (할당자는 후속 블록 또는 가상 메모리 트릭을 포함하도록 메모리 블록을 확장하는 등의 작업을 수행하기 위해 노력을 기울일 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">이것이 &lt;code&gt;Ok&lt;/code&gt; 를 돌려 주면 , 할당자는 &lt;code&gt;ptr&lt;/code&gt; 에 의해 참조 된 메모리 블록이 이제 &lt;code&gt;new_size&lt;/code&gt; 에 맞고 따라서 더 작은 레이아웃의 데이터를 전달하는 데만 사용될 수 있다고 주장했습니다 . (할당자는이를 활용하여 다른 곳에서 재사용 할 수 있도록 블록의 일부를 잘라낼 수 있습니다.) 더 작은 레이아웃 내에서 블록의 잘린 내용은 변경되지 않으며 블록의 소유권이 이전되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면, &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자에게 전송됩니다. 메모리가 할당 해제되었거나 할당되지 않았을 수 있으며 사용할 수없는 것으로 간주해야합니다 (물론이 방법의 반환 값을 통해 다시 호출자에게 다시 전송되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">이것이 널이 아닌 포인터를 리턴하면 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 블록의 소유권 이이 할당 자로 전송 된 것입니다. 메모리는 할당 해제되거나 해제되지 않았을 수 있으며 사용할 수없는 것으로 간주되어야합니다 (물론이 메서드의 반환 값을 통해 호출자에게 다시 전송되지 않는 한). 새 메모리 블록은 &lt;code&gt;layout&lt;/code&gt; 으로 할당 되지만 &lt;code&gt;size&lt;/code&gt; 는 &lt;code&gt;new_size&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="translated">이 슬라이스가 분할되지 않은 경우이 메서드는 일종의 이진 검색을 수행하므로 반환 된 결과는 지정되지 않고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구문을 사용하는 경우 인쇄 할 문자 수가 실제 오브젝트보다 형식화되기 때문에 문자 수는 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="translated">이것이 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값의 범위를 초과하는 경우이 함수는 패닉, 래핑 또는 포화 상태가 될 수 있습니다. 제안 된 동작은 디버그 어설 션이 활성화되면 패닉 상태가되고 그렇지 않으면 래핑되거나 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">일치하는 두 요소가 바로 인접 해 있으면 그 사이에 빈 조각이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">우리가하면 &lt;em&gt;않는&lt;/em&gt; 깊이의 힙 데이터를 복사 할 &lt;code&gt;String&lt;/code&gt; 뿐 아니라 스택 데이터, 우리라는 일반적인 방법 사용할 수 있습니다 &lt;code&gt;clone&lt;/code&gt; . 5 장에서 메소드 구문에 대해 설명하지만 메소드는 많은 프로그래밍 언어에서 공통적 인 기능이므로 이전에 본 적이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">이 코드를 지금 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">오류를 계속 읽으면 다음과 같은 유용한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">유형의 정의를 제어하면 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 직접 &lt;code&gt;Clone&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">여기에 형식 주석을 추가하지 않으면 Rust에 다음 오류가 표시됩니다. 이는 컴파일러가 사용하려는 형식을 알기 위해 더 많은 정보가 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 함수를 &lt;code&gt;Copy&lt;/code&gt; 특성 을 구현하는 유형 으로 제한하지 않으려면 &lt;code&gt;T&lt;/code&gt; 대신 &lt;code&gt;Copy&lt;/code&gt; 대신 특성 바인딩 &lt;code&gt;Clone&lt;/code&gt; 를 갖도록 지정할 수 있습니다. 그런 다음 &lt;code&gt;largest&lt;/code&gt; 함수가 소유권을 갖기를 원할 때 슬라이스의 각 값을 복제 할 수 있습니다. 은 Using &lt;code&gt;clone&lt;/code&gt; 우리가 잠재적으로 같은 자신의 힙 데이터 것을 유형의 경우 더 힙 할당을 만들고있어 기능 수단을 &lt;code&gt;String&lt;/code&gt; 우리는 많은 양의 데이터로 작업하는 경우, 힙 할당이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">수명 주석을 잊어 버리고이 함수를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">뮤텍스를 잠그면 &lt;code&gt;recv&lt;/code&gt; 를 호출 하여 채널에서 &lt;code&gt;Job&lt;/code&gt; 을 수신합니다 . 최종 &lt;code&gt;unwrap&lt;/code&gt; 은 여기에서도 오류를지나 이동 합니다. 수신 측이 종료되면 &lt;code&gt;send&lt;/code&gt; 메소드가 &lt;code&gt;Err&lt;/code&gt; 을 반환 하는 방식과 유사하게 채널의 송신 측을 보유하는 스레드가 종료 된 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 행 사용을 나열하지 않은 경우이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">프로그램 시작 부분에 &lt;code&gt;use std::io&lt;/code&gt; 줄을 넣지 않았다면 이 함수 호출을 &lt;code&gt;std::io::stdin&lt;/code&gt; 으로 작성할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 기능의 인스턴스를 반환 &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; 터미널의 표준 입력에 대한 핸들을 나타내는 타입이다.</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">더 복잡한 키가있는 경우 &lt;code&gt;insert&lt;/code&gt; 호출 은 키 값을 업데이트하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">문자열 슬라이스가 있으면 직접 전달할 수 있습니다. 우리가 &lt;code&gt;String&lt;/code&gt; 을 가지고 있다면 , 우리는 전체 &lt;code&gt;String&lt;/code&gt; 의 슬라이스를 전달할 수 있습니다 . 대신에 대한 참조의 캐릭터 조각 걸릴하는 함수를 정의하는 &lt;code&gt;String&lt;/code&gt; 어떤 기능을 잃지 않고 우리의 API가 더 일반적이고 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">키와 값을 해시 맵에 삽입 한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연관된 값이 대체됩니다. Listing 8-24 호출의 코드가 두 번 &lt;code&gt;insert&lt;/code&gt; 되지만 해시 맵에는 Blue 팀 키 값을 두 번 삽입하기 때문에 하나의 키 / 값 쌍만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">값에 대한 참조를 해시 맵에 삽입하면 값이 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 한 유효해야합니다. 이러한 문제에 대해서는 10 장의 &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;평생 검증 참조&quot;&lt;/a&gt; 섹션에서 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Devanagari 스크립트로 작성된 힌디어 단어 &quot;नमस्ते&quot; 를 보면 다음과 같은 &lt;code&gt;u8&lt;/code&gt; 값 으로 구성된 벡터로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">여러 문자열을 연결 해야하는 경우 &lt;code&gt;+&lt;/code&gt; 연산자 의 동작 이 다루기 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">앞에서 본 것처럼 인수를 전달하지 않고 테스트를 실행하면 모든 테스트가 동시에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">&lt;em&gt;hello.txt&lt;/em&gt; 파일 &lt;em&gt;없이이&lt;/em&gt; 코드를 실행 하면 &lt;code&gt;panic!&lt;/code&gt; 에서 오류 메시지가 나타납니다 ! 것을 전화 &lt;code&gt;unwrap&lt;/code&gt; 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">이 코드를 실행하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">&lt;code&gt;takes_ownership&lt;/code&gt; 호출 한 후 &lt;code&gt;s&lt;/code&gt; 를 사용하려고하면 Rust에서 컴파일 타임 오류가 발생합니다. 이러한 정적 검사는 실수로부터 우리를 보호합니다. &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 를 사용 하는 코드를 &lt;code&gt;main&lt;/code&gt; 에 추가하여 코드를 사용할 수있는 위치와 소유권 규칙으로 인해 코드를 사용할 수없는 위치를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">&lt;code&gt;assert_eq!(5, y);&lt;/code&gt; 를 쓰려고하면 ! (5, y); 대신이 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">범위가 끝난 후 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 액세스하려고 하면 &lt;code&gt;None&lt;/code&gt; 을 다시 얻 습니다. 프로그램의 끝에서, &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;leaf&lt;/code&gt; 변수에 있기 때문에, (1)의 강한 카운트 0 약함 카운트를 갖는 &lt;code&gt;leaf&lt;/code&gt; 이제 유일한 기준이다 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 다시.</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Listing 15-15와 같이 Listing 15-14에서 &lt;code&gt;main&lt;/code&gt; 함수를 수정 하여 &lt;code&gt;Drop&lt;/code&gt; 특성의 &lt;code&gt;drop&lt;/code&gt; 메소드를 수동으로 호출하려고 하면 컴파일러 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Listing 15-3에서 코드를 컴파일하려고하면 Listing 15-4에 표시된 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Listing 10-21에 나와있는 것처럼 &lt;code&gt;longest&lt;/code&gt; 함수 를 구현하려고하면 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">참조와 마찬가지로 컴파일러 오류가 발생하지 않고 이러한 규칙을 위반하려고하면 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 구현이 런타임시 패닉 상태가됩니다. Listing 15-23은 Listing 15-22 의 &lt;code&gt;send&lt;/code&gt; 구현 수정을 보여준다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 인해 런타임 시이 작업을 수행 할 수 없음 을 설명하기 위해 동일한 범위에 대해 두 개의 변경 가능한 차용을 의도적으로 작성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; 대신 &lt;code&gt;None&lt;/code&gt; 을 사용하는 경우 컴파일러 가 &lt;code&gt;None&lt;/code&gt; 값만 보고 &lt;code&gt;Some&lt;/code&gt; 변형이 보유 할 유형을 유추 할 수 없으므로 Rust에 어떤 유형의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 있는지 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">벡터의 각 요소에 차례로 액세스하려면 인덱스를 사용하여 한 번에 하나씩 액세스하는 대신 모든 요소를 ​​반복 할 수 있습니다. Listing 8-8은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용하여 &lt;code&gt;i32&lt;/code&gt; 값으로 구성된 벡터의 각 요소에 대한 불변 참조를 가져 와서 인쇄하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">경로에 정의 된 &lt;em&gt;모든&lt;/em&gt; 공개 항목을 범위 로 가져 오려면 해당 경로 다음에 glob 연산자 인 &lt;code&gt;*&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도 보려면 &lt;code&gt;--nocapture&lt;/code&gt; 플래그 를 사용하여 출력 캡처 동작을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="translated">테스트를 통과하기 위해 인쇄 된 값도보고 싶다면 마지막에 &lt;code&gt;--show-output&lt;/code&gt; 을 사용하여 성공한 테스트의 출력을 보여 주도록 Rust에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">이 함수가 &lt;code&gt;item1&lt;/code&gt; 과 &lt;code&gt;item2&lt;/code&gt; 가 다른 유형을 갖도록하려면 &lt;code&gt;impl Trait&lt;/code&gt; 을 사용하는 것이 적절합니다 (두 유형이 &lt;code&gt;Summary&lt;/code&gt; 를 구현하는 한 ). 두 매개 변수를 모두 같은 유형으로 만들려면 다음과 같이 특성 바운드를 사용하여 표현하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">튜플에서 하나 이상의 값을 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;무시&lt;/a&gt; 하려면 &quot;패턴의 값 무시&quot; 섹션 에서 볼 수 있듯이 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 을 사용할 수 있습니다 . 문제가 패턴에 너무 많은 변수가있는 경우, 해결책은 변수를 제거하여 유형을 일치시켜 변수의 수가 튜플의 요소 수와 같도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">이 코드를 실행할 수 있다면 스폰 된 스레드가 전혀 실행되지 않고 즉시 백그라운드에 놓일 수 있습니다. 스폰 된 스레드는 &lt;code&gt;v&lt;/code&gt; 내부에 대한 참조를 갖지만 주 스레드 는 15 장에서 설명한 &lt;code&gt;drop&lt;/code&gt; 함수를 사용하여 즉시 &lt;code&gt;v&lt;/code&gt; 를 삭제 합니다. 그런 다음 스폰 된 스레드가 실행되기 시작하면 &lt;code&gt;v&lt;/code&gt; 는 더 이상 유효하지 않으므로 이에 대한 참조는 또한 유효하지 않습니다. 아뇨!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">우리는 전화로한다면 &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , &lt;code&gt;coin&lt;/code&gt; 것 &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . 해당 값을 각 일치 팔과 비교할 때 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 도달 할 때까지 일치하지 않습니다 . 이 시점에서 &lt;code&gt;state&lt;/code&gt; 바인딩은 &lt;code&gt;UsState::Alaska&lt;/code&gt; 값이됩니다 . 그런 다음 &lt;code&gt;println!&lt;/code&gt; 에서 해당 바인딩을 사용할 수 있습니다 ! 따라서 &lt;code&gt;Quarter&lt;/code&gt; 의 &lt;code&gt;Coin&lt;/code&gt; 열거 형 변형 에서 내부 상태 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">상태 패턴을 사용하지 않는 대체 구현을 작성하는 경우 &lt;code&gt;Post&lt;/code&gt; 의 메소드 또는 게시물 의 상태를 확인하고 해당 위치의 동작을 변경 하는 &lt;code&gt;main&lt;/code&gt; 코드 에서 &lt;code&gt;match&lt;/code&gt; 표현식을 대신 사용할 수 있습니다. 즉, 게시 된 상태에있는 게시물의 모든 의미를 이해하려면 여러 곳을 살펴 봐야합니다! 이것은 우리가 추가 한 상태를 증가시킬뿐입니다. 각각의 &lt;code&gt;match&lt;/code&gt; 표현에는 다른 팔이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 상자 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 한 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 우리가 목록 2-4의 추측 게임에서 가졌던 다음 두 개의 &lt;code&gt;use&lt;/code&gt; 문은 &lt;code&gt;std&lt;/code&gt; 에서 항목 을 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">동일한 패키지 또는 동일한 모듈에 정의 된 여러 항목을 사용하는 경우 각 항목을 자체 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 추측 게임의 목록 2-4에있는 이 두 가지 &lt;code&gt;use&lt;/code&gt; 문장은 &lt;code&gt;std&lt;/code&gt; 에서 범위로 항목을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">당신이 경우 &lt;em&gt;어떻게&lt;/em&gt; 녹에, 컴파일러는 당신에게 (에 의해 제어 기본적으로 경고를 줄 것이다 쓰기 &lt;code&gt;unused_must_use&lt;/code&gt; 의 보풀).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">찾고있는 이름을 이미 알고 있다면 가장 빠른 방법은 페이지 상단의 검색 창을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">자체 스마트 포인터 유형을 정의하고 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST 강제 변환 시스템&lt;/a&gt; 을 사용 하여 크기가 조정되지 않은 유형에서 크기가 조정되지 않은 유형으로 변환 하려면 &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">타입을 잘 생각한다면 &lt;code&gt;map()&lt;/code&gt; 과 같이 생각할 수 있습니다 : &lt;code&gt;A&lt;/code&gt; 타입 의 요소를 제공 하는 반복자가 있고 다른 &lt;code&gt;B&lt;/code&gt; 타입의 반복자를 원한다면 &lt;code&gt;map()&lt;/code&gt; 사용할 수 있습니다 &lt;code&gt;A&lt;/code&gt; 를 가져 오고 &lt;code&gt;B&lt;/code&gt; 를 반환 하는 클로저를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 변환 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 함수의 안전하지 않은 버전이 있습니다.이 함수 는 동작이 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">바이트 슬라이스가 유효한 UTF-8인지 확인하고 유효성 검사의 오버 헤드를 발생시키지 않으려면 &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; 이 기능의 안전하지 않은 버전이 있습니다.이 기능 은 동작은 동일하지만 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 null이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 반환하는 일종의 &lt;code&gt;as_mut_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">포인터가 널이 될 수 없다고 확신하고 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;T&lt;/code&gt; 를 리턴하는 일종의 &lt;code&gt;as_ref_unchecked&lt;/code&gt; 를 찾고 있다면 포인터를 직접 역 참조 할 수 있음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">숫자 유형을 bool로 캐스트하려는 경우 대신 0과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">속기 필드 패턴을 사용하지만 다른 이름으로 구조체 필드를 참조하려는 경우 명시 적으로 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">속기 필드 패턴을 사용하고 있지만 다른 이름으로 struct 필드를 참조하려면 명시 적으로 이름을 변경해야합니다. 구조체 필드는 콜론 전에 사용 된 이름에 의해 식별됩니다 &lt;code&gt;:&lt;/code&gt; 구조체 패턴이 구조체 형식의 선언이 일치되고 유사합니다 그래서.</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">기존 파일 형식을 처리 할 프로그램을 작성하는 경우이 기능을 사용하기 전에 해당 형식의 공백 정의를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">예를 들어 권한 오류로 인해 파일이 포함 된 디렉토리에 액세스 할 수 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 전략을 사용할 수없는 경우 유형 이 메소드가없는 &lt;code&gt;Eq&lt;/code&gt; 를 구현하도록 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">안전한 코드로 액세스 할 수 있는 수명 &lt;code&gt;'a&lt;/code&gt; ( &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 참조) 로 안전한 참조를 작성하는 경우 (예를 들어 리턴했기 때문에) 해당 참조와 모순되는 방식으로 데이터에 액세스하면 안됩니다 &lt;code&gt;'a&lt;/code&gt; 의 나머지 . 예를 들어,이 방법은 당신이 가지고 있다고하면 &lt;code&gt;*mut T&lt;/code&gt; 에서 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 와에 캐스팅 &lt;code&gt;&amp;amp;T&lt;/code&gt; 다음의 데이터를, &lt;code&gt;T&lt;/code&gt; 는 (모든 모듈로 불변 유지해야 &lt;code&gt;UnsafeCell&lt;/code&gt; 의 데이터 내에서 발견 &lt;code&gt;T&lt;/code&gt; 해당 참조의 수명까지 물론,) 만료됩니다. 마찬가지로 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 생성하면안전 코드로 해제 된 참조가 있으면 해당 참조가 만료 될 때까지 &lt;code&gt;UnsafeCell&lt;/code&gt; 내의 데이터에 액세스하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">변수를 만들지 만 아무데도 사용하지 않으면 Rust는 일반적으로 버그가 될 수 있으므로 경고를 표시합니다. 그러나 때로는 프로토 타입을 만들거나 프로젝트를 시작할 때와 같이 아직 사용하지 않는 변수를 만드는 것이 유용합니다. 이 상황에서 변수 이름을 밑줄로 시작하여 사용하지 않는 변수에 대해 경고하지 않도록 Rust에 지시 할 수 있습니다. Listing 18-20에서는 사용하지 않는 두 개의 변수를 작성하지만이 코드를 실행할 때 그 중 하나에 대한 경고 만 표시된다.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="translated">트레이 트 객체를 사용하기로 결정한 경우 컴파일러는 컴파일 도중이 아니라 &lt;em&gt;런타임&lt;/em&gt; 에 호출 할 메서드를 파악하는 코드를 생성해야하므로 성능에 영향을주는 &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;동적 디스패치에&lt;/a&gt; 의존한다는 점에 유의 하십시오 . 특성 개체를 사용하여 성능을 위해 유연성을 거래하고 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="translated">당신이없는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 하지만, 단지 &lt;code&gt;&amp;amp;U&lt;/code&gt; 있도록 &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (예 : &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt; ), 당신은 사용할 수 있습니다 &lt;code&gt;iter().any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &quot;적어도&quot;동작을 원하지 않으면 &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 호출하지 않으면 프로그램이 컴파일되지만 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">테스트를 병렬로 실행하지 않거나 사용 된 스레드 수를보다 세밀하게 제어하려면 &lt;code&gt;--test-threads&lt;/code&gt; 플래그와 사용하려는 스레드 수를 테스트에 보낼 수 있습니다 이진. 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아주 ​​가능성이 높음) 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">신호성에 신경 쓰지 않는다면 (아마도) 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Rust의 기본 사항을 모르는 경우 Rust Book을 방문하여 시작할 수 있습니다. https://doc.rust-lang.org/book/</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="translated">Rust의 기초를 모르신다면 &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; 에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">이름을 한정하지 않으면 코드는 &quot;GET&quot;및 &quot;POST&quot;라는 새 변수를 대신 바인딩합니다. 이 동작은 원하는 것이 &lt;code&gt;rustc&lt;/code&gt; 있으므로 rustc 는 이러한 상황이 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">이 오류가 발생하면 입력 유형의 가능한 모든 값이 일치하도록 패턴을 변경해야합니다. 열거 형과 같이 변형이 적은 유형의 경우 모든 경우를 명시 적으로 다루어야합니다. 또는 밑줄 &lt;code&gt;_&lt;/code&gt; 와일드 카드 패턴을 &quot;다른 것&quot;과 일치시키기 위해 다른 모든 패턴 뒤에 추가 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">이 오류가 발생하면 당신은 아마 사용할 필요가 &lt;code&gt;match&lt;/code&gt; 하거나 &lt;code&gt;if let&lt;/code&gt; 실패의 가능성을 처리 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">C 또는 C ++ 배경이 있다면 &lt;code&gt;gcc&lt;/code&gt; 또는 &lt;code&gt;clang&lt;/code&gt; 과 유사하다는 것을 알 수 있습니다. 성공적으로 컴파일 한 후 Rust는 바이너리 실행 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 목록 이있는 경우 &lt;code&gt;collect()&lt;/code&gt; 를 사용 하여 실패한 것이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있다면 일반적으로 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 불변입니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경되거나 변경되지 않고 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 될 수 없다는 제한을 해결하는 유일한 핵심 언어 기능 입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 변경을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서도 앨리어싱 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 을 얻을 수있는 합법적 인 방법 은 &lt;em&gt;없습니다.&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; 참조가 있으면 Rust에서 &lt;code&gt;SomeStruct&lt;/code&gt; 의 모든 필드 는 변경할 수 없습니다. 컴파일러는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 변경 가능하게 별명 지정되거나 변경되지 않았으며 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 고유 하다는 지식을 기반으로 최적화를 수행합니다 . &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 는이 제한을 해결하는 유일한 핵심 언어 기능입니다. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 내부 가변성을 허용하는 다른 모든 유형은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용 하여 내부 데이터를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">프로그램에 &lt;code&gt;match&lt;/code&gt; 를 사용하여 표현하기에 너무 장황한 논리가 있는 &lt;code&gt;if let&lt;/code&gt; 이 Rust 도구 상자에도 있다는 것을 기억 하십시오.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;String&lt;/code&gt; 을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8 바이트의 벡터가있는 경우 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 여기 에서 &lt;code&gt;String&lt;/code&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">유효한 UTF-8 바이트의 벡터가 있으면 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 만들 수 있습니다 . 당신도 반대를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&lt;/code&gt; 의 소유권이 있다면 , 대신 &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">컨테이너의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값의 소유권이있는 경우 &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">값에 대한 소유권이있는 경우에는 대신 &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">당신은 구현하는 뭔가가있는 경우 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , 당신이 사용할 수있는 &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 의 유형을&lt;/a&gt; 로를 설정하는 &lt;code&gt;BufRead&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">변경하지 않고 즉시 &lt;code&gt;cargo build&lt;/code&gt; 다시 실행 하면 &lt;code&gt;Finished&lt;/code&gt; 라인 에서 다른 출력을 얻을 수 없습니다 . Cargo는 이미 종속성을 다운로드하여 컴파일 &lt;em&gt;했음을 알고 있으며 Cargo.toml&lt;/em&gt; 파일 에서 관련 항목을 변경하지 않았습니다 . Cargo는 또한 코드에 대해 아무것도 변경하지 않았으므로 다시 컴파일하지도 않는다는 것을 알고 있습니다. 할 일이 없으면 단순히 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 대신 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 필요한 경우 &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">널 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">nul 종결자가 있는 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스 &lt;em&gt;가&lt;/em&gt; 필요한 경우 대신 &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대신 &lt;code&gt;String&lt;/code&gt; 이 필요한 경우 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 이 소멸 될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 값 의 파괴보다 오래 지속될 수 있는 &lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 물론 &lt;code&gt;Hash&lt;/code&gt; 특성을 직접 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">값이 해시되는 방식을보다 세밀하게 제어해야하는 경우 &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 참조가 여러 개 필요한 경우 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; 에 대한 여러 참조가 필요한 경우 &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">기능이 필요한 경우 야간 릴리스의 컴파일러를 사용해야합니다 (하지만 나중에 기능이 제거되거나 변경 될 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">이것이 필요한 경우, 무언가 잘못하고있을 가능성이 큽니다. Rust는 다른 구조체의 레이아웃에 대해 많은 것을 보증하지 않습니다 (동일한 선언을 가진 두 구조체는 다른 레이아웃을 가질 수 있음). 변환을 완전히 피하는 해결책이 있다면 대신 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">객체 경계를 넘어야하는 경우 포인터를 정수로 캐스팅하고 거기에서 산술을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">&lt;em&gt;많은&lt;/em&gt; 스트림 의 길이를 가져와야하고 탐색 위치를 신경 쓰지 않는 경우 &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; 를 호출 하고 반환 값을 사용하여 탐색 조작 수를 줄일 수 있습니다. 또한 스트림 길이입니다).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">개별 유니 코드 스칼라 값에 대한 작업을 수행해야하는 경우 &lt;code&gt;chars&lt;/code&gt; 메서드 를 사용하는 것이 가장 좋습니다 . &quot;नमस्ते&quot;에서 &lt;code&gt;chars&lt;/code&gt; 를 호출 하면 &lt;code&gt;char&lt;/code&gt; 유형의 6 개 값이 분리되어 반환 되며 결과를 반복하여 각 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">네임 스페이스 만 가져 오려면 직접 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">&lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 열고 사소한 변경을 한 다음 저장하고 다시 빌드하면 두 줄의 출력 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">원하는 경우 스크립트를 다운로드하여 실행하기 전에 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">작업 공간의 상자를 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에 게시하는 경우 작업 공간의 각 상자를 별도로 게시해야합니다. &lt;code&gt;cargo publish&lt;/code&gt; 명령은 없습니다 &lt;code&gt;--all&lt;/code&gt; 플래그 또는 &lt;code&gt;-p&lt;/code&gt; 각 상자의 디렉토리 및 실행으로 변경해야합니다, 그래서 깃발을 &lt;code&gt;cargo publish&lt;/code&gt; 나무 상자를 게시하는 작업 공간에 각각의 상자에.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">전역 변경 가능 상태를 원하면 &lt;code&gt;static mut&lt;/code&gt; 변경 또는 전역 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">이 코드를 실행하고 기본 스레드의 출력 만 보거나 겹치지 않으면 범위에서 숫자를 늘려서 운영 체제가 스레드간에 전환 할 수있는 기회를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">버전 번호가 표시되면 가지고 있습니다! &lt;code&gt;command not found&lt;/code&gt; 과 같은 오류가 표시되는 경우 설치 방법에 대한 설명서를보고 Cargo를 별도로 설치하는 방법을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 표시되면 Rust가 성공적으로 설치된 것입니다! 이 정보가 표시되지 않고 Windows에있는 경우 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하십시오 . 이것이 모두 정확하고 Rust가 여전히 작동하지 않으면 도움을 얻을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 거기서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 자신이라고 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 유용한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 및 &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;스택 오버플로가 있습니다.&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">이 정보가 보이면 Rust를 성공적으로 설치 한 것입니다! 이 정보가 보이지 않고 Windows를 사용하고 있다면 Rust가 &lt;code&gt;%PATH%&lt;/code&gt; 시스템 변수 에 있는지 확인하세요 . 모든 것이 맞고 Rust가 여전히 작동하지 않는다면 도움을받을 수있는 곳이 많이 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;공식 Rust Discord&lt;/a&gt; 의 #beginners 채널입니다 . 그곳에서 당신을 도울 수있는 다른 Rustaceans (우리가 우리 스스로 부르는 어리석은 별명)와 대화 할 수 있습니다. 다른 훌륭한 리소스로 &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;는 사용자 포럼&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">우리가 &quot;Hello, world!&quot;에서했던 것처럼 Cargo를 사용하지 않는 프로젝트를 시작했다면 프로젝트에서 Cargo를 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리 로 이동하고 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Cargo를 사용하지 않는 프로젝트를 시작했다면 Hello, world! 프로젝트에서화물을 사용하는 프로젝트로 변환 할 수 있습니다. 프로젝트 코드를 &lt;em&gt;src&lt;/em&gt; 디렉토리로 &lt;em&gt;옮기고&lt;/em&gt; 적절한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="translated">여전히 열거 형에 &lt;code&gt;Default&lt;/code&gt; 를 구현 하려면 &quot;직접&quot;수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">외부 크레이트의 모듈을 사용하려고했고 Rust 2015를 사용하고 있다면, 외부 &lt;code&gt;extern crate&lt;/code&gt; 선언 (보통 크레이트 루트에 위치)을 놓쳤을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">당신이 구현하려고하면 &lt;code&gt;Copy&lt;/code&gt; 비 포함하는 구조체 또는 열거에 &lt;code&gt;Copy&lt;/code&gt; 된 데이터를, 당신은 오류 얻을 것이다 &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">마지막 &lt;code&gt;println!&lt;/code&gt; 주석을 해제하면 ! 프로그램을 실행, 녹으로이주기를 인쇄하려고합니다 를 가리키는 &lt;code&gt;b&lt;/code&gt; 가리키는 등이 스택 오버 플로우 때까지. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 속성에서 제공하는 것과 다른 동작을 원할 경우 수동으로 구현하는 방법에 대한 자세한 내용은 각 특성에 대한 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">다른 사용자가 모듈에서 변형을 직접 가져올 수있게하려면 &lt;code&gt;pub use&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">이 필드에 액세스하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소멸자를 실행하여 값을 올바르게 처리하려면 &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">클로저가 환경에서 사용하는 값의 소유권을 갖도록하려면 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이 기술은 데이터를 새 스레드가 소유하도록 데이터를 이동하기 위해 새 스레드에 클로저를 전달할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">명령 행 인수를 얻으려면 &lt;code&gt;std::env::args&lt;/code&gt; . 지정된 종료 코드로 종료하려면 &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="translated">정렬 순서를 유지하면서 정렬 된 벡터에 항목을 삽입하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">첫 번째 &lt;code&gt;String&lt;/code&gt; 을 계속 사용하려면 이를 복제하고 대신 복제본에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리를 누출하려면 &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 과 일치 시키려면 가드를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="translated">메서드에서 반환 된 값과 일치 시키려면 먼저 값을 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리에 대한 원시 포인터를 얻으려면 &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최대 값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">한 단계에서 최소값을 얻으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">현재 오류를 생략하고 해당 소스 만 사용하려면 &lt;code&gt;skip(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">특정 옵션을 무시하고 다른 기본값을 계속 유지하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 변수의 값을 바꾸려면 &lt;a href=&quot;fn.swap&quot;&gt; &lt;code&gt;swap&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 대신 전달 된 값으로 바꾸려면 replace를 참조 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 또는 더미 값으로 바꾸려면 &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전달 된 값으로 &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 이전 값을 반환하려면 replace를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">SPDX에 나타나지 않는 라이센스를 사용하려면 해당 라이센스의 텍스트를 파일에 넣고 프로젝트에 파일을 포함시킨 다음 &lt;code&gt;license-file&lt;/code&gt; 을 사용하여 해당 파일의 이름을 대신 지정해야합니다. 사용 &lt;code&gt;license&lt;/code&gt; 키</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">메소드를 사용하려면 메소드 뒤에 &lt;code&gt;()&lt;/code&gt; 를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.4.0&lt;/code&gt; 또는 &lt;code&gt;0.4.x&lt;/code&gt; 시리즈의 버전 을 사용 하려면 다음과 같이 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 업데이트해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">당신이 사용하고자하는 경우 &lt;code&gt;rand&lt;/code&gt; 버전 &lt;code&gt;0.6.0&lt;/code&gt; 시작 또는 모든 버전 &lt;code&gt;0.6.x&lt;/code&gt; 시리즈를, 당신은 업데이트해야 할 것 &lt;em&gt;Cargo.toml의&lt;/em&gt; 대신이 같은 모습에 파일을 :</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">이 속성을 impl의 모든 메소드에 적용하려면 각 메소드에 수동으로 주석을 답니다. 전체 impl에 &lt;code&gt;#[inline]&lt;/code&gt; 으로 주석을 달 수 없습니다 . 속성으로 .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="translated">Rust의 소유권에 대해 더 알고 싶다면 책의 &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;소유권 이해&lt;/a&gt; 장에서 시작 하십시오.</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Rust의 소유권에 대해 더 배우려면 다음 장에서 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Windows API로 작업하는 경우 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">내 보낸 매크로를 모두 가져 오려면 인수없이 &lt;code&gt;macro_use&lt;/code&gt; 를 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Ruby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙한 경우 별도의 단계로 프로그램을 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다. Rust는 &lt;em&gt;미리 컴파일 된&lt;/em&gt; 언어로, 프로그램을 컴파일하고 다른 사람에게 실행 파일을 제공 할 수 있으며 Rust를 설치하지 않아도 실행할 수 있습니다. 누군가에게 &lt;em&gt;.rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; 또는 &lt;em&gt;.js&lt;/em&gt; 파일을 제공하는 경우 루비, 파이썬 또는 JavaScript 구현이 (각각) 설치되어 있어야합니다. 그러나 이러한 언어에서는 프로그램을 컴파일하고 실행하기위한 명령이 하나만 필요합니다. 모든 것은 언어 디자인의 절충입니다.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">문제가 발생하면 Listing 20-15의 코드를보기 전에 이러한 변경 사항을 직접 구현해보십시오.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Linux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 하나가 아닌 두 개의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Rust 베타 또는 안정적인 릴리스를 사용하는 경우 기능 플래그를 사용할 수 없습니다. 이것이 우리가 새로운 기능을 영원히 안정적으로 선언하기 전에 새로운 기능을 실제로 사용할 수있게하는 열쇠입니다. 최첨단 기술을 선택하려는 사람들은 그렇게 할 수 있으며, 견고한 경험을 원하는 사람들은 안정을 유지하고 코드가 깨지지 않을 것임을 알 수 있습니다. 정체없는 안정성.</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 로&lt;/a&gt; 작업하는 경우 &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한 파일의 내용을 다른 파일로 복사하고 파일 시스템 경로를 사용하는 경우 &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">다른 언어로 작업하는 동안 &lt;em&gt;얕은 복사&lt;/em&gt; 와 &lt;em&gt;깊은 복사&lt;/em&gt; 라는 용어를 들었다면 데이터를 복사하지 않고 포인터, 길이 및 용량을 복사하는 개념은 얕은 복사를하는 것처럼 들릴 것입니다. 그러나 Rust는 얕은 카피 라 불리는 대신 첫 번째 변수를 무효화하기 때문에 &lt;em&gt;이동이라고&lt;/em&gt; 합니다. 이 예제에서, 우리는 말할 것 &lt;code&gt;s1&lt;/code&gt; 되었다 &lt;em&gt;이동&lt;/em&gt; 에 &lt;code&gt;s2&lt;/code&gt; . 실제 상황은 그림 4-4에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">값의 소멸자를 명시 적으로 호출하려면 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">컬렉션을 만드는 경우 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 를 구현 하면 컬렉션을 &lt;code&gt;for&lt;/code&gt; 루프 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">당신은 부작용의 일종을하고 있다면, 선호 &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 접두사 만 얻는 것이 괜찮다면 먼저 &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">당신이 이것을 반환하고 &lt;code&gt;SUCCESS&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; 에서 &lt;code&gt;Err(_)&lt;/code&gt; 및 &lt;code&gt;Ok(())&lt;/code&gt; 각각 대신 반환하는 것을 고려 하십시오.이 코드는 동일한 코드를 반환하지만 오류를 &lt;code&gt;eprintln!&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">보푸라기 검사를 무시하려면 &lt;code&gt;forbid&lt;/code&gt; 를 변경할 수 있습니다 를 &lt;code&gt;deny&lt;/code&gt; 하거나 &lt;code&gt;forbid&lt;/code&gt; 설정이 명령 줄 옵션으로 제공된 경우 &lt;code&gt;-F&lt;/code&gt; 대신 &lt;code&gt;-D&lt;/code&gt; 를 사용하여 내부 보푸라기 검사 속성을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="translated">PowerShell을 사용하는 경우 환경 변수를 설정하고 프로그램을 별도의 명령으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">야간 버전의 rustc를 사용하는 경우 해당 기능을 추가하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">rustc의 안정 버전 또는 베타 버전을 사용하는 경우 불안정한 기능을 사용할 수 없습니다. 이렇게하려면 야간 버전의 rustc (rustup 사용)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">당신이 쓰고 있다면 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; &lt;code&gt;for&lt;/code&gt; 루프와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="translated">상자 이름을 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">어떤 종류의 컬렉션으로 자신을 발견하고 해당 컬렉션의 요소에 대한 작업을 수행 해야하는 경우 신속하게 '반복자'가 발생합니다. 반복자는 관용적 Rust 코드에서 많이 사용되므로 익숙해 질 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">구조체가 실제로 &lt;code&gt;T&lt;/code&gt; 유형의 데이터를 &lt;em&gt;소유&lt;/em&gt; 하지 않으면 다음 과 같은 참조 유형을 사용하는 것이 좋습니다 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (이상적으로) 또는 &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (생명이 적용되지 않는 경우 ) 소유권을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">유형이 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt; &lt;code&gt;partial_cmp&lt;/code&gt; &lt;/a&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">유형이 &lt;code&gt;Ord&lt;/code&gt; 인 경우 구현할 수 있습니다 &lt;code&gt;partial_cmp()&lt;/code&gt; &lt;code&gt;cmp()&lt;/code&gt; 를 사용하여 partial_cmp () 를 .</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 고정을 사용하는 경우 (예 : 위의 두 가지 예) &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현할 때주의해야합니다 . &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 하지만,이 호출된다 &lt;em&gt;당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 컴파일러가 자동으로 &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt; &lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt; &lt;/a&gt; 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">유형에 고정 (예 : 위의 두 예)을 사용하는 경우 &lt;code&gt;Drop&lt;/code&gt; 구현시주의해야합니다 . &lt;code&gt;drop&lt;/code&gt; 기능은 소요 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 만이라고&lt;em&gt; 당신의 유형이 이전에 고정 된 경우에도&lt;/em&gt; ! 마치 컴파일러가 자동으로 &lt;code&gt;get_unchecked_mut&lt;/code&gt; 을 호출 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">대신 클로저가 &lt;code&gt;self.vec&lt;/code&gt; 를 직접 사용하는 경우에는 &lt;code&gt;self&lt;/code&gt; 캡처를 시도합니다. 하는 경우 변경 가능한 참조로 . 그러나 &lt;code&gt;self.set&lt;/code&gt; 이 이미 반복되어 빌려 지기 때문에 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">의 나머지 필드를 무시합니다 &lt;code&gt;person&lt;/code&gt; . 나머지 필드는 값을 가질 수 있으며 변수에 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; 가 중첩 된 값의 일부 무시</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">와 값의 나머지 부분을 무시 &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">특별히 요청하지 않는 한 일부 테스트 무시</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">패턴에서 값 무시</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; 로 전체 값 무시</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; 로 이름을 시작하여 사용하지 않는 변수 무시</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">거실에서 TV로 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 상상해보십시오 . 한 사람이 TV를 보려고 들어 오면 TV가 켜집니다. 다른 사람들은 방에 들어 와서 TV를 볼 수 있습니다. 마지막 사람이 방을 나가면 더 이상 TV를 사용하지 않기 때문에 TV를 끕니다. 다른 사람이 여전히 TV를보고있는 동안 누군가 TV를 끄면 나머지 TV 시청자로부터 큰소리가 들릴 것입니다!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 원시 항목은 사용이 매우 제한적입니다. 대신 &lt;code&gt;raw_entry_mut&lt;/code&gt; 을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">불변 슬라이스 반복자</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">소유 가치에서 불변으로 차용합니다. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다. 값이 현재 변경 가능한 경우에는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">래핑 된 값을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Impl 블록은 수명 매개 변수를 별도로 선언합니다. 수명 매개 변수가 고유 한 유형을 구현하는 경우 수명 매개 변수를 impl 블록에 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">특성 증폭</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">구현 &lt;code&gt;unsafe&lt;/code&gt; &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">유형에 대한 일부 기능을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">저렴한 가변 변환 가능 변환을 위해 &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">저렴한 참조 참조 변환을위한 &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">가치에서 가치로의 전환을 소비하기위한 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">현재 상자 외부의 유형으로 값-값 변환을 사용하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 특성을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">유형에 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">논리적으로 불변 인 메소드의 구현 세부 사항.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt; 구현</target>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현에서는 당황하거나 중단하지 않고 메모리 소진시 &lt;code&gt;Err&lt;/code&gt; 을 반환하도록 권장 되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 중단되지 않고 메모리 소진시 널을 리턴하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">구현은 당황하거나 중단하는 대신 메모리 소진시 null을 반환하도록 권장되지만 이는 엄격한 요구 사항은 아닙니다. (특히 : 메모리 소모로 인해 중단되는 기본 고유 할당 라이브러리 위에이 특성을 구현 하는 것이 &lt;em&gt;합법적&lt;/em&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">구현에는 &lt;code&gt;impl&lt;/code&gt; 키워드 앞에 외부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 과 관련 항목이 포함 된 괄호 안에있는 내부 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 이 포함될 수 있습니다. 내부 속성은 관련 항목보다 먼저 와야합니다. 여기서 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; . 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 다른 특성을 수동으로 구현하여 실수로 동의하지 않게 만드는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현은 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 구현&lt;em&gt;&lt;/em&gt; 서로 동의 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; &lt;code&gt;a == b&lt;/code&gt; 이고 모든 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 대해 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 경우에만 동일 합니다 . 일부 특성을 도출하고 수동으로 다른 특성을 구현하여 실수로 동의하지 않는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">운영자 특성의 구현은 일반적인 의미와 &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;운영자 우선 순위&lt;/a&gt; 를 염두에두고 각각의 상황에서 놀랍지 않아야합니다 . 예를 들어, &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; 을&lt;/a&gt; 구현할 때 연산은 곱셈과 유사해야하며 연관성과 같은 예상 속성을 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대해 &lt;code&gt;Eq&lt;/code&gt; 와 같은 것들을 구현 합니다. 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="translated">특정 길이까지 고정 길이 배열에 대한 &lt;code&gt;Eq&lt;/code&gt; 와 같은 구현 . 결국 우리는 모든 길이로 일반화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="translated">이 특성의 구현은 &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; 에 대한 인수가 안전한 참조이면 결과도 마찬가지 라고 약속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">외국 유형에 대한 구현</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">&lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 수동 구현 은 안전하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Add&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Binary&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 뒤에있는 데이터에 편리하게 액세스 할 수 &lt;code&gt;Deref&lt;/code&gt; 를 구현할 수 있습니다 . 반면에 &lt;code&gt;Deref&lt;/code&gt; 및 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 에 관한 규칙 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이 때문에 혼란을 피하기 &lt;strong&gt;위해 스마트 포인터에만 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; 를 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">스마트 포인터 용 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현 하면 뒤에있는 데이터를 편리하게 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현할 수 있습니다 . 반면, &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;DerefMut&lt;/code&gt; 에 관한 규칙은 스마트 포인터를 수용하도록 특별히 설계되었습니다. 이것 때문에,&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/strong&gt;혼란을 피하기&lt;strong&gt; 위해 스마트 포인터&lt;/strong&gt; 에&lt;strong&gt; 대해서만 &lt;/strong&gt;&lt;strong&gt;DerefMut&lt;/strong&gt;&lt;strong&gt; 을 구현해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">구현 &lt;code&gt;Display&lt;/code&gt; 유형에 디스플레이 :</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">구현 &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;FromIterator&lt;/code&gt; 유형에 맞는 FromIterator :</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">구현 &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">구현 &lt;code&gt;Into&lt;/code&gt; 외부 유형 변환에</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="translated">이전 버전의 Rust에서 외부 유형으로 변환하기 위해 &lt;code&gt;Into&lt;/code&gt; 구현 하기</target>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">구현 &lt;code&gt;IntoIterator&lt;/code&gt; 유형에 맞는 IntoIterator :</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerExp&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;LowerHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;Octal&lt;/code&gt; 구현하기 :</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">타입에 대한 &lt;code&gt;Pointer&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">제네릭으로 &lt;code&gt;Sub&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TryInto&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperExp&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">유형에 &lt;code&gt;UpperHex&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;split_at_mut&lt;/code&gt; 구현 :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">반복자 구현</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">다른 유형으로의 변환으로 전환 구현</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">유형에 대한 특성 구현</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">유형에 특성을 구현하는 것은 일반 메소드를 구현하는 것과 유사합니다. 차이점은 &lt;code&gt;impl&lt;/code&gt; 후에 구현하려는 특성 이름을 입력 한 다음 &lt;code&gt;for&lt;/code&gt; 키워드 를 사용 하고 특성을 구현하려는 유형의 이름을 지정한다는 것입니다. &lt;code&gt;impl&lt;/code&gt; 블록 내에서 특성 정의가 정의한 메소드 서명을 넣습니다. 각 서명 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 특성의 메소드가 특정 유형에 대해 원하는 특정 동작으로 메소드 본문을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;안전하지 않은 특성&lt;/a&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">객체 지향 디자인 패턴 구현</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">안전하지 않은 특성 구현</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; 특성 구현</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; 메소드 구현</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">&lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 함수 구현</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">이행 &lt;code&gt;Deref&lt;/code&gt; 특성 것은 당신의 행동 사용자 정의 할 수 있습니다 &lt;em&gt;참조 연산자&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; 을 (곱셈 또는 글로브 연산자 반대). 스마트 포인터를 일반 참조처럼 취급 할 수있는 방식으로 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 참조에서 작동하는 코드를 작성하고 해당 코드를 스마트 포인터로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 대한 &lt;code&gt;Unpin&lt;/code&gt; 특성을 구현하면 유형 고정의 제한이 해제 되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 함수 를 사용하여 &lt;code&gt;T&lt;/code&gt; 를 &lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 밖으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">특성 구현</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">이러한 특성을 구현하면 특정 운영자에게 과부하를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성을 구현하면 유형 고정의 제한이 해제되어 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 와 같은 기능으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 특성의 구현 자를 '리더'라고합니다.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">&lt;code&gt;Write&lt;/code&gt; 특성의 구현 자는 때때로 '작가'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="translated">사전 식으로 배열 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">문자열에 대한 비교 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">문자열 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">사전 식으로 벡터의 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 스트링 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 하여 하위 문자열 슬라이싱을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">두 문자열을 연결하기위한 &lt;code&gt;+&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 에 추가하기위한 &lt;code&gt;+=&lt;/code&gt; 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">암시 적 차용</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">함수와 메소드를 사용한 암시 적 역 참조 강제</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">암시 적 차용은 다음과 같은 표현으로 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">암시 적으로 활성화</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">다른 상자 나 모듈에서 항목을 가져 오거나 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="translated">이름에 바인딩하지 않고 트레이 트의 메서드 만 가져 오기 위해 &lt;code&gt;_&lt;/code&gt; 로 가져 오기 (예 : 충돌 방지) : &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">변수 선언 및 표현식 문과 같이 항목이 아닌 문 뒤에는 가져 오기 ( &lt;code&gt;use&lt;/code&gt; 문)를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">스레드 풀을 사용하여 서버의 처리량을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">I / O 프로젝트 개선</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">스레드 풀로 처리량 개선</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">오류 메시지 개선</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 사용 &lt;code&gt;for&lt;/code&gt; 생성하는 루프 카운터 &lt;code&gt;id&lt;/code&gt; 새로 만드는 &lt;code&gt;Worker&lt;/code&gt; 그와 &lt;code&gt;id&lt;/code&gt; , 그리고 벡터에 노동자를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는 우리의 새로운 채널을 생성하고 풀 보류에게 보내는 끝이있다. 이것은 여전히 ​​경고와 함께 성공적으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">에서 &lt;code&gt;ThreadPool::new&lt;/code&gt; , 우리는의 채널의 수신 측 넣어 &lt;code&gt;Arc&lt;/code&gt; 와 &lt;code&gt;Mutex&lt;/code&gt; . 각각의 새 작업자에 대해 우리는 &lt;code&gt;Arc&lt;/code&gt; 를 복제하여 참조 횟수를 늘려 작업자가 수신 엔드의 소유권을 공유 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 전화를 &lt;code&gt;Dog::baby_name&lt;/code&gt; 정의 관련 함수를 호출 기능, &lt;code&gt;Dog&lt;/code&gt; 직접. 이 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서는 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 두 인스턴스를 &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 다음 생성 된 CustomSmartPointer 를 인쇄 합니다. . 의 끝에서 &lt;code&gt;main&lt;/code&gt; , 우리의 경우 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 는 범위의 외출 것이며, 녹 우리가에 넣어 코드 호출 &lt;code&gt;drop&lt;/code&gt; 우리의 마지막 메시지를 인쇄하는 방법. &lt;code&gt;drop&lt;/code&gt; 메소드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리의 두 인스턴스 생성 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 을 누른 다음 인쇄 &lt;code&gt;CustomSmartPointers created&lt;/code&gt; . &lt;code&gt;main&lt;/code&gt; 이 끝날 때 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 의 인스턴스는 범위 를 벗어나고 Rust는 &lt;code&gt;drop&lt;/code&gt; 메소드에 넣은 코드를 호출하여 최종 메시지를 인쇄합니다. &lt;code&gt;drop&lt;/code&gt; 메서드를 명시 적으로 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리는 새로운 문을 추가했습니다 : &lt;code&gt;fs::read_to_string&lt;/code&gt; 합니다 &lt;code&gt;filename&lt;/code&gt; 해당 파일을 엽니하고, 반환 &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; 파일의 내용.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; , 우리가 정의한 &lt;code&gt;Point&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;5&lt;/code&gt; )와 &lt;code&gt;f64&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (값 &lt;code&gt;10.4&lt;/code&gt; ). &lt;code&gt;p2&lt;/code&gt; 변수 A는 &lt;code&gt;Point&lt;/code&gt; 의 문자열 슬라이스 갖는 구조체 &lt;code&gt;x&lt;/code&gt; (값 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) 및 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; (가치와 &lt;code&gt;c&lt;/code&gt; ). 호출 &lt;code&gt;mixup&lt;/code&gt; 에 &lt;code&gt;p1&lt;/code&gt; 인수하여 &lt;code&gt;p2&lt;/code&gt; 우리가 제공 &lt;code&gt;p3&lt;/code&gt; 이되는, &lt;code&gt;i32&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;p1&lt;/code&gt; 에서 왔기 때문 입니다. &lt;code&gt;p3&lt;/code&gt; 변수는있을 것이다 &lt;code&gt;char&lt;/code&gt; 에 대한 &lt;code&gt;y&lt;/code&gt; 로 하기 때문에, &lt;code&gt;y&lt;/code&gt; 는 온 &lt;code&gt;p2&lt;/code&gt; . &lt;code&gt;println!&lt;/code&gt; 매크로 호출은 &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">에서 &lt;code&gt;match&lt;/code&gt; 표현, 당신은을 사용하여 여러 패턴을 일치시킬 수 있습니다 &lt;code&gt;|&lt;/code&gt; 구문 수단 &lt;em&gt;또는&lt;/em&gt; . 예를 들어, 다음 코드는 &lt;code&gt;x&lt;/code&gt; 값과 일치 팔을 비교합니다. 첫 번째는 &lt;em&gt;또는&lt;/em&gt; 옵션이 있습니다. 즉 &lt;code&gt;x&lt;/code&gt; 값이 해당 팔의 값 중 하나와 일치하면 해당 팔의 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">C 및 C ++에서는 메소드 호출에 두 개의 다른 연산자가 사용됩니다 &lt;code&gt;.&lt;/code&gt; 객체에서 직접 메소드를 호출하는 경우 &lt;code&gt;-&amp;gt;&lt;/code&gt; 객체 에 대한 포인터에서 메소드를 호출하는 경우 먼저 포인터를 역 참조해야하는 경우 즉, &lt;code&gt;object&lt;/code&gt; 가 포인터 인 경우 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; 은 &lt;code&gt;(*object).something()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="translated">C에서 데이터 구조의 끝을 넘어서 읽으려는 시도는 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리의 위치에있는 모든 것을 얻을 수 있습니다. 이를 &lt;em&gt;버퍼 오버 읽기&lt;/em&gt; 라고하며 공격자가 데이터 구조 이후에 저장된 데이터를 읽을 수 없도록 인덱스를 조작 할 수있는 경우 보안 취약성을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">1 장에서는 &lt;code&gt;cargo new&lt;/code&gt; 가 에디션에 대한 약간의 메타 데이터를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 추가하는 것을 보았습니다 . 이 부록은 그 의미에 대해 이야기합니다!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;유형에 대한 특성 구현&amp;rdquo;&lt;/a&gt; 섹션의 10 장 에서 특성 또는 유형이 상자에 국한된 유형에 대한 특성을 구현할 수 있다는 고아 규칙을 언급했습니다. 튜플 구조체에서 새 유형을 만드는 &lt;em&gt;newtype pattern을&lt;/em&gt; 사용하여 이러한 제한을 &lt;em&gt;해결할 수&lt;/em&gt; 있습니다. ( 5 장의 &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&quot;명명 된 필드가없는 튜플 구조 사용&quot;&lt;/a&gt; 섹션에서 튜플 구조를 다루었습니다 . 튜플 구조에는 하나의 필드가 있고 특성을 구현하려는 유형 주위에 얇은 래퍼가됩니다. 그런 다음 포장지 유형은 상자에 국한되며 포장지에 특성을 구현할 수 있습니다. &lt;em&gt;신형&lt;/em&gt;하스켈 프로그래밍 언어에서 유래 한 용어입니다. 이 패턴을 사용하면 런타임 성능이 저하되지 않으며 컴파일시 래퍼 유형이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">10 장에서는 구조체에 참조를 저장할 수 있도록 이러한 오류를 수정하는 방법에 대해 설명하지만 지금 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 과 같은 참조 대신 &lt;code&gt;String&lt;/code&gt; 과 같은 소유 유형을 사용하여 이와 같은 오류를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">12 장에서 바이너리 상자와 라이브러리 상자가 포함 된 패키지를 만들었습니다. 프로젝트가 개발됨에 따라 라이브러리 상자가 계속 커지고 패키지를 여러 라이브러리 상자로 더 분할하려고 할 수 있습니다. 이 상황에서 Cargo는 &lt;em&gt;작업 영역&lt;/em&gt; 이라는 기능을 제공하여 함께 개발 된 여러 관련 패키지를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">13 장에서는 클로저가 환경에서 사용하는 값의 소유권을 갖도록 클로저의 매개 변수 목록 앞에 &lt;code&gt;move&lt;/code&gt; 키워드를 사용할 수 있다고 언급 했습니다. 이 기법은 한 스레드에서 다른 스레드로 값 소유권을 이전하기 위해 새 스레드를 작성할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">15 장에서는 스마트 포인터 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 참조 계수 값을 생성 하여 여러 소유자에게 값을 제공했습니다. 여기서도 똑같이하고 무슨 일이 일어나는지 봅시다. Listing 16-14의 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 랩핑하고 소유권을 스레드로 이동하기 전에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 복제한다 . 이제 오류를 보았으므로 &lt;code&gt;for&lt;/code&gt; 루프를 다시 사용하도록 전환 하고 &lt;code&gt;move&lt;/code&gt; 키워드를 클로저 로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">16 장에서는 다양한 동시 프로그래밍 모델을 살펴보고 Rust가 여러 스레드에서 두려움없이 프로그래밍하는 방법에 대해 설명합니다. 17 장에서는 Rust 관용구가 익숙한 객체 지향 프로그래밍 원칙과 어떻게 비교되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">16 장에서는 이 사용 사례에 적합한 &lt;em&gt;채널 (&lt;/em&gt; 두 스레드 간 통신하는 간단한 방법)에 대해 배웠습니다 . 채널을 사용하여 작업 대기열로 작동하고, &lt;code&gt;execute&lt;/code&gt; 하면 &lt;code&gt;ThreadPool&lt;/code&gt; 에서 &lt;code&gt;Worker&lt;/code&gt; 인스턴스로 작업을 보내면 작업이 스레드로 전송됩니다. 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">2 장에서는 &lt;code&gt;rand&lt;/code&gt; 라는 외부 패키지를 사용하여 임의의 숫자를 얻는 추측 게임 프로젝트를 프로그래밍했습니다 . 프로젝트에서 &lt;code&gt;rand&lt;/code&gt; 를 사용 하기 &lt;em&gt;위해이&lt;/em&gt; 행을 &lt;em&gt;Cargo.toml에&lt;/em&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">20 장에서는 저수준 멀티 스레드 웹 서버를 구현할 프로젝트를 완성 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">제 3 장에서 우리는 언급 &lt;code&gt;for&lt;/code&gt; 루프가 녹 코드에서 가장 일반적인 루프 구조이지만, 우리가 아직 그 패턴을 설명하지 않은 &lt;code&gt;for&lt;/code&gt; 소요됩니다. (A)에 &lt;code&gt;for&lt;/code&gt; 루프 패턴 직접 키워드 다음 값인 &lt;code&gt;for&lt;/code&gt; 너무에서 &lt;code&gt;for x in y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 패턴된다.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">4 장의 &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Dangling References&quot;&lt;/a&gt; 섹션에서 컴파일러는 참조가 항상 유효한지 확인한다고 언급했습니다. 안전하지 않은 녹에는 참조와 유사한 &lt;em&gt;원시 포인터&lt;/em&gt; 라는 두 가지 새로운 유형이 있습니다 . 참조와 마찬가지로 원시 포인터는 변경 불가능하거나 변경 가능하며 각각 &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 로 작성됩니다. 별표는 역 참조 연산자가 아닙니다. 유형 이름의 일부입니다. 원시 포인터의 맥락에서, &lt;em&gt;불변&lt;/em&gt; 은 의미가 역 참조 된 후 포인터를 직접 할당 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">5 장, 리스팅 5-15에서, 우리는 &lt;code&gt;Rectangle&lt;/code&gt; 구조체와 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 사용했다. 이것은 Listing 11-5에서 반복된다. 이 코드를 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에 넣고 &lt;code&gt;assert!&lt;/code&gt; 사용하여 테스트를 &lt;em&gt;해보자 &lt;/em&gt;! 매크로.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">6 장에서 우리는 &lt;code&gt;if let&lt;/code&gt; 식이 주로 하나의 경우에만 일치 하는 &lt;code&gt;match&lt;/code&gt; 을 작성하는 더 짧은 방법으로 사용하는 방법에 대해 논의했습니다 . 선택적으로, &lt;code&gt;if let&lt;/code&gt; 해당 할 수 있습니다 &lt;code&gt;else&lt;/code&gt; 실행 포함 된 코드를에서 패턴 경우 &lt;code&gt;if let&lt;/code&gt; 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">7 장에서는 &lt;code&gt;mod&lt;/code&gt; 키워드를 사용하여 코드를 모듈로 구성 하는 방법, &lt;code&gt;pub&lt;/code&gt; 키워드를 사용하여 항목을 공개 하는 방법 및 &lt;code&gt;use&lt;/code&gt; 키워드를 사용 하여 항목을 범위로 가져 오는 방법에 대해 설명했습니다 . 그러나 상자를 개발하는 동안 귀하에게 적합한 구조는 사용자에게별로 편리하지 않을 수 있습니다. 여러 수준을 포함하는 계층 구조에서 구조체를 구성하려고 할 수 있지만 계층에서 깊게 정의한 형식을 사용하려는 사람들은 해당 형식이 있는지 찾는 데 어려움이있을 수 있습니다. 그들은 또한 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; 을 입력 해야하는 것에 짜증이 날 수도 있습니다 . &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; 하지 말고 ; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">7 장에서는 Rust의 모듈 시스템과 코드 및 공개 API (Application Programming Interface) 구성을위한 개인 정보 보호 규칙에 대해 설명합니다. 8 장에서는 벡터, 문자열 및 해시 맵과 같은 표준 라이브러리가 제공하는 공통 컬렉션 데이터 구조에 대해 설명합니다. 9 장은 Rust의 오류 처리 철학과 기술을 탐구합니다.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">8 장에서 벡터의 한 가지 제한은 벡터가 한 가지 유형의 요소 만 저장할 수 있다는 것입니다. Listing 8-10에서 정수, 부동 수 및 텍스트를 보유하는 변형이 있는 &lt;code&gt;SpreadsheetCell&lt;/code&gt; 열거 형을 정의한 해결 방법을 만들었습니다 . 즉, 각 셀에 서로 다른 유형의 데이터를 저장할 수 있으며 셀 행을 나타내는 벡터를 계속 가질 수 있습니다. 이것은 상호 교환 가능한 항목이 코드 컴파일 시점을 알고있는 고정 된 유형의 세트 일 때 완벽하게 좋은 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">열거 형 정의에서</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">함수 정의에서</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">목록 10-3, 우리라는 이름의 함수로 가장 큰 수를 발견 한 코드 추출 &lt;code&gt;largest&lt;/code&gt; . 하나의 특정 목록에서만 가장 큰 숫자를 찾을 수있는 Listing 10-1의 코드와 달리이 프로그램은 두 개의 다른 목록에서 가장 큰 숫자를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">Listing 11-7에서 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성하여 매개 변수에 &lt;code&gt;2&lt;/code&gt; 를 더하고 결과를 리턴한다. 그런 다음 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">Listing 12-6에서 우리는 &lt;code&gt;String&lt;/code&gt; 값 의 슬라이스를 가져와 슬라이스 로 인덱싱하고 값을 복제하여 &lt;code&gt;Config&lt;/code&gt; 구조체 의 인스턴스를 생성하는 코드를 추가 하여 &lt;code&gt;Config&lt;/code&gt; 구조체가 해당 값을 소유 할 수있게했다 . Listing 13-24에서는 Listing 12-23에서와 같이 &lt;code&gt;Config::new&lt;/code&gt; 함수 의 구현을 재현했다 .</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">Listing 12-8에서 인덱스 1과 2에 액세스하기 전에 슬라이스가 충분히 길다는 것을 확인하는 &lt;code&gt;new&lt;/code&gt; 함수에 점검을 추가 한다. 슬라이스가 충분히 길지 않으면 프로그램은 패닉 상태가되고 더 나은 오류 메시지를 표시한다. &lt;code&gt;index out of bounds&lt;/code&gt; 메시지 색인 .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">Listing 13-18에서는 호출에서 반환 된 반복자를 반복 하여 벡터 로 &lt;code&gt;map&lt;/code&gt; 한 결과를 수집한다 . 이 벡터는 원래 벡터의 각 항목을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">Listing 13-19에서는 환경에서 &lt;code&gt;shoe_size&lt;/code&gt; 변수 를 캡처하여 &lt;code&gt;Shoe&lt;/code&gt; 구조체 인스턴스 컬렉션을 반복 하는 클로저와 함께 &lt;code&gt;filter&lt;/code&gt; 를 사용한다 . 지정된 크기의 신발 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">Listing 15-19에서 &lt;code&gt;main&lt;/code&gt; 을 변경 하여 list &lt;code&gt;c&lt;/code&gt; 주위에 내부 범위를 갖도록한다 . &lt;code&gt;c&lt;/code&gt; 가 범위를 벗어날 때 참조 카운트가 어떻게 변하는 지 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">Listing 15-26에서는 Listing 15-25의 정의를 사용 하는 &lt;code&gt;main&lt;/code&gt; 함수를 추가하고있다 . 이 코드의 목록을 작성 및 예약리스트 &lt;code&gt;b&lt;/code&gt; 의 목록에 그 점 &lt;code&gt;a&lt;/code&gt; . 그런 다음의 목록을 수정 를 가리 &lt;code&gt;b&lt;/code&gt; 기준주기를 생성. &lt;code&gt;println!&lt;/code&gt; 이 있습니다 ! 이 과정에서 참조 카운트가 다양한 지점에있는 것을 보여주는 방법 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">Listing 16-8에서 우리는 메인 스레드에서 채널의 수신단으로부터 값을 얻을 것이다. 이것은 강 끝의 물에서 고무 오리를 검색하거나 채팅 메시지를받는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">Listing 18-11에서 패턴 가드 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했다. 새로운 변수는 패턴 내부에서 생성 된 리콜 &lt;code&gt;match&lt;/code&gt; 외부 변수를 사용하는 대신에 식 &lt;code&gt;match&lt;/code&gt; . 새로운 변수는 외부 변수의 값에 대해 테스트 할 수 없음을 의미했습니다. Listing 18-27은이 문제를 해결하기 위해 매치 가드를 사용하는 방법을 보여준다.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">목록 7-11에서, 우리는 가져 &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; 의 범위에 모듈을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 의 우리가 단지 지정해야하므로 기능 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 통화에 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 에서 기능을 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">Listing 7-11에서 왜 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 을 지정한 다음 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수에 &lt;code&gt;use&lt;/code&gt; 경로를 지정 하여 동일한 결과를 얻기 보다는 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; :: add_to_waitlist 를 호출 한 이유가 궁금 할 것이다 . 목록 7-13에서와 같이.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">분석법 정의에서</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">Rust 1.3에서는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156에&lt;/a&gt; 설명 된대로 기본 객체 수명 범위가 변경 될 것으로 예상됩니다 . 컴파일러가이 변경으로 인해 코드에 컴파일 오류가 발생할 수 있다고 생각하기 때문에 경고 메시지가 표시됩니다. 가능하지는 않지만 이것이 잘못된 경보 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="translated">Rust 2015에서 &lt;code&gt;use&lt;/code&gt; 구문의 경로 는 크레이트 루트에 상대적입니다. 현재 및 부모 모듈과 관련된 항목을 가져 오려면 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사를 각각 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="translated">Rust 2018에서는 &lt;code&gt;extern crate&lt;/code&gt; 선언이 필요하지 않으며 대신 &lt;code&gt;use&lt;/code&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="translated">Rust 2018에서 &lt;code&gt;use&lt;/code&gt; 명령문의 경로 는 상자 이름 또는 리터럴 &lt;code&gt;crate::&lt;/code&gt; 시작하지 않는 한 현재 모듈에 상대적 입니다.이 경우 상자 루트에서 시작합니다. Rust 2015 코드에서와 같이 &lt;code&gt;self::&lt;/code&gt; 및 &lt;code&gt;super::&lt;/code&gt; 접두사는 각각 현재 및 부모 모듈을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">Rust에서 함수는 패닉 상태에 빠지거나 전 이적으로 패닉 상태에있는 함수를 호출하면 &quot;반환&quot;할 수 있습니다. 이러한 종류의 제어 흐름이 항상 예상되는 것은 아니며 두 가지 중요한 구성 요소의 조합을 통해 미묘한 버그가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">Rust에서 &lt;em&gt;릴리스 프로파일&lt;/em&gt; 은 서로 다른 구성으로 사전 정의되고 사용자 정의 가능한 프로파일로, 프로그래머가 코드 컴파일을위한 다양한 옵션을보다 효과적으로 제어 할 수 있습니다. 각 프로파일은 다른 프로파일과 독립적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 주석은 두 개의 슬래시로 시작하여 줄 끝까지 계속되어야합니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">Rust에서는 전역 변수를 &lt;em&gt;정적&lt;/em&gt; 변수 라고 합니다. Listing 19-9는 문자열 슬라이스를 값으로 사용하여 정적 변수를 선언하고 사용하는 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">Rust에서 통합 테스트는 라이브러리 외부에 있습니다. 라이브러리는 다른 코드와 같은 방식으로 라이브러리를 사용하므로 라이브러리의 공용 API에 속하는 함수 만 호출 할 수 있습니다. 이들의 목적은 라이브러리의 많은 부분이 올바르게 작동하는지 테스트하는 것입니다. 자체적으로 올바르게 작동하는 코드 단위는 통합시 문제가 발생할 수 있으므로 통합 코드의 테스트 범위도 중요합니다. 통합 테스트를 작성하려면 먼저 &lt;em&gt;tests&lt;/em&gt; 디렉토리 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">Rust에서는 다른 사용 사례에 대해 다른 유형의 표현을 제공하는 것이 일반적입니다. 예를 들어, 값에 대한 저장 위치 및 관리는 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 유형을 통해 특정 용도에 적합하게 선택 될 수 있습니다 . 모든 유형에 사용할 수있는 이러한 일반 래퍼 외에도 일부 유형은 선택적인 패싯을 제공하여 잠재적으로 비용이 많이 드는 기능을 제공합니다. 이러한 유형에 대한 예는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 기본 문자열을 확장 할 수있는 기능이 추가되는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . 단순하고 불변 인 문자열에는 추가 정보를 불필요하게 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하려는 경우 벡터가 아닌 슬라이스로 슬라이스를 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rust에서는 읽기 액세스를 제공하고 싶을 때 슬라이스를 벡터보다는 인수로 전달하는 것이 더 일반적입니다. &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">Rust에서 이터레이터는 &lt;em&gt;게으르다&lt;/em&gt; . 즉, 이터레이터를 사용하기 위해 이터레이터를 소비하는 메소드를 호출 할 때까지 효과가 없다. 예를 들어, 목록 13-13의 코드는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정의 된 &lt;code&gt;iter&lt;/code&gt; 메소드 를 호출하여 벡터 &lt;code&gt;v1&lt;/code&gt; 의 항목에 대해 반복자를 작성합니다 . 이 코드 자체는 유용한 기능을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 단순 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 지정하거나 인수로 전달하면 수신자가 사본을 가져 와서 원래 값을 그대로 둡니다. 이러한 유형은 복사 할 때 할당 할 필요가없고 종료자가 없습니다 (즉, 소유 한 상자가 없거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ). 따라서 컴파일러는 복사가 저렴하고 안전하다고 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성을 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 규칙에 따라 명시 적으로 복사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rust에서 일부 간단한 유형은 &quot;암시 적으로 복사 가능&quot;하며이를 할당하거나 인수로 전달할 때 수신자는 원래 값을 그대로두고 사본을 얻습니다. 이러한 유형은 복사 할 할당이 필요하지 않으며 종료자가 없으므로 (즉, 소유 된 상자를 포함하지 않거나 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않음 ) 컴파일러는 복사하기에 저렴하고 안전한 것으로 간주합니다. 다른 유형의 경우 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 는 Clone 트레이 트를 구현 하고 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 명시 적으로 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">Rust에서 일부 유형은 컴파일 타임에 알려진 크기를 갖지 않습니다. 예를 들어, &lt;code&gt;[u32]&lt;/code&gt; 와 같은 슬라이스 유형 에서는 요소 수를 컴파일 타임에 알 수 없으므로 전체 크기를 계산할 수 없습니다. 결과적으로, 이러한 유형은 참조 (예 : &lt;code&gt;&amp;amp;T&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 또는 다른 포인터 유형 (예 : &lt;code&gt;Box&lt;/code&gt; 또는 &lt;code&gt;Rc&lt;/code&gt; )을 통해서만 조작 할 수 있습니다 . 대신 참조로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">Rust에서 문자열은 항상 유효한 UTF-8이며 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">Rust에서 컴파일러는 값이 변하지 않는다고 말할 때 실제로 변하지 않도록 보장합니다. 즉, 코드를 읽고 쓸 때 값이 어떻게, 어디서 변경 될 수 있는지 추적 할 필요가 없습니다. 따라서 코드를 쉽게 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rust에서 관용적 주석 스타일은 두 개의 슬래시로 주석을 시작하고 주석은 줄 끝까지 계속됩니다. 한 줄 이상으로 확장되는 주석의 경우 다음과 같이 각 줄에 &lt;code&gt;//&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">Rust에서 배열로 들어가는 값은 대괄호 안에 쉼표로 구분 된 목록으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">소유권과 차용의 개념을 사용하는 Rust에서 참조와 스마트 포인터의 추가 차이점은 참조는 데이터 만 빌리는 포인터라는 점입니다. 대조적으로, 많은 경우에, 스마트 포인터 는 그들이 가리키는 데이터를 &lt;em&gt;소유&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">Rust에서는 컴파일 타임에 크기가 알려진 경우에만 값을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">구조 정의에서</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">터키어에서 라틴어의 'i'는 두 가지 형식 대신 다섯 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">A의 &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 정의하고 관련 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 유형, 평생에만 반환 유형이 아닌 인수 유형에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">A의 &lt;code&gt;fn&lt;/code&gt; 형, 수명은 인수 유형 만 반환 형식에 표시하지.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 프로그램에서 표준 라이브러리에는 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의해 사용되는 하나의 &quot;전역&quot;메모리 할당자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">일치 표현식에서는 숫자와 문자 만 범위와 일치시킬 수 있습니다. 컴파일러가 컴파일 타임에 범위가 비어 있지 않은지 확인하고 임의 비교 함수를 평가할 수 없기 때문입니다. 두 엔드 포인트 사이에서 주문 가능한 유형의 값을 캡처하려는 경우 가드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">패턴에서 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하지 않는 모든 값 은 동일한 방식으로 바인딩되어야합니다. 여기서 목표는 이동 및 참조에 의한 바인딩을 동시에 피하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">패턴에서 : 포괄적 인 범위 패턴</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 비슷한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 하면 다시 호출하면 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; 을&lt;/a&gt; 다시 반환 할 수도 있고 반환하지 않을 수도 있습니다 . 이 목적을 위해 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt; 은 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 프로토콜 과 유사한 방식으로 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가 &lt;code&gt;next_back()&lt;/code&gt; 에서 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 다시 호출하면 &lt;code&gt;Some&lt;/code&gt; 을 다시 반환하거나 반환하지 않을 수 있습니다 . &lt;code&gt;next()&lt;/code&gt; 와 &lt;code&gt;next_back()&lt;/code&gt; 은이 목적을 위해 상호 교환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">어떤 방식 으로든 모든 프로그래밍 언어의 채널은 단일 소유권과 유사합니다. 일단 채널로 값을 전송하면 더 이상 해당 값을 사용하지 않아야합니다. 공유 메모리 동시성은 다중 소유권과 같습니다. 여러 스레드가 동시에 동일한 메모리 위치에 액세스 할 수 있습니다. 스마트 포인터가 다중 소유권을 가능하게하는 15 장에서 보았 듯이, 서로 다른 소유자가 관리해야하기 때문에 다중 소유권이 복잡성을 추가 할 수 있습니다. Rust의 유형 시스템 및 소유권 규칙은 이러한 관리를 올바르게 수행하는 데 크게 도움이됩니다. 예를 들어, 공유 메모리에 대한 가장 일반적인 동시성 기본 요소 중 하나 인 뮤텍스를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">변경 불가능한 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 많은 상황에서 컴파일러가 &lt;code&gt;Deref&lt;/code&gt; 를 암시 적으로 사용합니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 변경 가능한 컨텍스트에서는 &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">가변 컨텍스트에서 (단항) &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 명시 적 역 참조 작업에 사용되는 것 외에도 &lt;code&gt;DerefMut&lt;/code&gt; 은 많은 환경에서 컴파일러에 의해 암시 적으로 사용됩니다. 이 메커니즘을 &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;' &lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt; 이라고 합니다. 불변의 문맥에서는 &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">코드가 예상 한 올바른 값을 반환하는지 확인하는 것 외에도 코드가 예상 한대로 오류 조건을 처리하는지 확인하는 것이 중요합니다. 예를 들어, 9 장, 목록 9-10에서 만든 &lt;code&gt;Guess&lt;/code&gt; 유형을 고려하십시오 . 용도가 다른 코드를 &lt;code&gt;Guess&lt;/code&gt; 하는 보증에 따라 &lt;code&gt;Guess&lt;/code&gt; 경우 우리는 것을 보장이 만들려고하는 테스트를 작성할 수 1과 100 사이의 값만 포함됩니다 &lt;code&gt;Guess&lt;/code&gt; 범위 패닉 그 값 외부와 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">패턴 일치를 통해 구조를 제거하는 것 외에도 마침표 ( &lt;code&gt;.&lt;/code&gt; )와 액세스하려는 값의 색인을 사용하여 튜플 요소에 직접 액세스 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">메모리 블록 피팅 외에도 &lt;code&gt;layout&lt;/code&gt; 의 배향의 &lt;code&gt;layout&lt;/code&gt; 메모리의 블록을 할당하는 데 사용되는 정렬과 일치한다.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">그룹화 기능 외에도 구현 세부 정보를 캡슐화하면 코드를 더 높은 수준에서 재사용 할 수 있습니다. 작업을 구현 한 후에는 다른 코드가 구현 방식을 알지 않고도 코드의 공용 인터페이스를 통해 해당 코드를 호출 할 수 있습니다. 코드를 작성하는 방법은 다른 코드에 사용할 공용 파트와 변경 권한을 보유한 프라이빗 구현 세부 사항을 정의합니다. 이것은 머리에 유지해야 할 세부 사항의 양을 제한하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">&lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; 형식으로 고정 유형을 제공하는 것 외에도 함수는 유형 특성 목록을 특성 범위와 함께 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 외에도 Rust는 사용자가 주어진 범위 내에서만 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">공개 및 비공개 이외에도 Rust를 사용하면 지정된 범위 내에서 항목을 볼 수 있도록 선언 할 수 있습니다. &lt;code&gt;pub&lt;/code&gt; 제한에 대한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Clone&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;아래&lt;/a&gt; 에 나열된 구현 자 외에도 다음 유형도 &lt;code&gt;Copy&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">또한받는 &lt;code&gt;#[cfg]&lt;/code&gt; 속성이 매크로 구성 플래그 논리식 평가를 허용하도록 제공된다. 이로 인해 코드 중복이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석에 추가하여 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 정보 &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; 는 또한 원료 및 구문 분석되지 않은 보유 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 에&lt;/a&gt; 의해 반환 슬라이스, &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">서명에 따라 다양한 기능 포인터가 제공됩니다. 함수 포인터는 안전과 안전하지 않은 두 가지 방식으로 제공됩니다. 일반 &lt;code&gt;fn()&lt;/code&gt; 함수 포인터는 안전 함수 만 가리킬 수 있지만 &lt;code&gt;unsafe fn()&lt;/code&gt; 함수 포인터는 안전 또는 안전하지 않은 함수를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">또한, &lt;code&gt;unsafe&lt;/code&gt; 블록이 반드시 위험 내부의 코드를 의미하지 않거나 확실히 메모리 안전 문제가있는 것 : 의도는 프로그래머로, 당신은 내부의 코드를 확인합니다 것입니다 &lt;code&gt;unsafe&lt;/code&gt; 유효한 방법으로 블록 의지 액세스 메모리 .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">또한,의 함수 포인터 &lt;em&gt;어떤&lt;/em&gt; 서명, ABI, 또는 안전은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , 모든 &lt;em&gt;안전&lt;/em&gt; 함수 포인터 구현 &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; 을&lt;/a&gt; . 이러한 특성은 컴파일러에 특별히 알려져 있기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">또한 이것에 의해 암시 된 설계 선택이 있습니다. Rust는 자동으로 데이터의 &quot;심층&quot;사본을 자동으로 생성하지 않습니다. 따라서 &lt;em&gt;자동&lt;/em&gt; 복사는 런타임 성능 측면에서 저렴한 것으로 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">또한, 우리는 다룰 &lt;em&gt;내부 가변성&lt;/em&gt; 불변의 유형은 내부 값을 돌연변이에 대한 API를 노출 패턴. 또한 &lt;em&gt;참조주기&lt;/em&gt; , 메모리 누수 방법 및 방지 방법에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">다른 모든 경우 ( &lt;code&gt;setting_value&lt;/code&gt; 또는 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 ) 두 번째 암 의 &lt;code&gt;_&lt;/code&gt; 패턴으로 표시되면 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;setting_value&lt;/code&gt; 가되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">다른 모든 경우에는 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류 에서 &lt;code&gt;Dragon&lt;/code&gt; 열거 형 에서 &lt;code&gt;Born&lt;/code&gt; 변형 을 반환하려면 변형이 아닌 열거 형을 반환하도록 함수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="translated">이 모든 오류에서 유형이 예상되었습니다. 예를 들어, 첫 번째 오류에서 우리 는 불가능한 &lt;code&gt;Mordor&lt;/code&gt; 모듈 을 인스턴스화하려고했습니다 . 모듈 내에서 유형을 인스턴스화하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">에서 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">이중 연결 목록에서 컬렉션은 실제로 요소 자체에 메모리를 할당하지 않습니다. 할당은 클라이언트에 의해 제어되며 요소는 컬렉션보다 수명이 짧은 스택 프레임에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서는 중첩 된 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 사람들이 필요로하는 별도의 &lt;code&gt;use&lt;/code&gt; 문 수를 줄일 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">더 큰 프로그램에서 중첩 된 경로를 사용하여 동일한 패키지 또는 모듈에서 많은 항목을 범위로 가져 오면 많은 부분에서 필요한 개별 &lt;code&gt;use&lt;/code&gt; 문 수가 줄어들 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="translated">두 경우 모두 변수 ( &lt;code&gt;_&lt;/code&gt; 라고 함 )를 선언 하고 유형을 지정합니다. 그러나 &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; 및 &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; 는 유형이 아니므로 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">이 두 가지 예에서 '&amp;szlig;'는 인코딩하는 데 2 ​​바이트가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">이 두 가지 예에서 '𝕊'은 인코딩하는 데 두 개의 &lt;code&gt;u16&lt;/code&gt; 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특별한 동작을 호출하는 데 사용됩니다 (아래 &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; 및 &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt; 에서 설명 ). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치 및 전사됩니다. 예외는 matcher의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 &lt;code&gt;(())&lt;/code&gt; 는 &lt;code&gt;{()}&lt;/code&gt; 와 일치 하지만 &lt;code&gt;{{}}&lt;/code&gt; 와는 일치 하지 않습니다 . &lt;code&gt;$&lt;/code&gt; 문자 는 일치하거나 문자 그대로 기록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">matcher와 transcriber 모두에서 &lt;code&gt;$&lt;/code&gt; 토큰은 매크로 엔진에서 특수한 동작을 호출하는 데 사용됩니다 (아래의 &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions 참조&lt;/a&gt; ). 이러한 호출에 포함되지 않은 토큰은 문자 그대로 일치하고 기록됩니다 (단, 예외). 단, 매처의 외부 분리 문자는 모든 분리 문자 쌍과 일치합니다. 따라서, 예를 들어, 정규가 &lt;code&gt;(())&lt;/code&gt; 일치 &lt;code&gt;{()}&lt;/code&gt; 하지만 &lt;code&gt;{{}}&lt;/code&gt; . 문자 &lt;code&gt;$&lt;/code&gt; 는 문자 그대로 일치하거나 전사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">matcher와 transcriber에서 반복은 &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 안에 반복 될 토큰을 배치 한 후 반복 연산자를 선택적으로 선택하고 선택적으로 사이에 분리기 토큰이 있습니다. 분리기 토큰은 분리 기호 또는 반복 연산자 중 하나 이외의 임의의 토큰 일 수 있지만 &lt;code&gt;;&lt;/code&gt; 그리고 &lt;code&gt;,&lt;/code&gt; 가장 일반적이다. 예를 들어 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 는 쉼표로 구분 된 여러 식별자를 나타냅니다. 중첩 반복이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 크기의 종류 (얇은) 포인터에 대해, 이것은 단순한 과제와 동일한 효과를 가지고, 반면 크기를 지정하지 않은 형태로 (FAT) 포인터는,이 동작은, 포인터의 일부에 영향을 미칠 것이다.</target>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 변형의 경우 내부 오류를 검색합니다. &lt;code&gt;try!&lt;/code&gt; 그런 다음 &lt;code&gt;From&lt;/code&gt; 을 사용하여 변환을 수행합니다 . 이것은 특수 오류와보다 일반적인 오류 사이의 자동 변환을 제공합니다. 결과 오류가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">항목이 &lt;code&gt;impl&lt;/code&gt; 내부의 함수 인 경우 개인 도우미 함수를 정의하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="translated">문서 주석 다음에 항목을 문서화하려는 경우 외부 문서 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">중첩 모듈이 많은 경우 &lt;code&gt;pub use&lt;/code&gt; 하여 최상위 수준에서 유형을 다시 내 보내면 상자를 사용하는 사람들의 경험에 큰 차이가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">경우에 따라 Rust에 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 강제 변환 이라고하는이 변환을 수행하기에 충분한 정보가 없습니다 . 다음 예제에서 문자열 슬라이스 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; 은 특성 &lt;code&gt;TraitExample&lt;/code&gt; 을 구현하고 &lt;code&gt;example_func&lt;/code&gt; 함수 는 특성을 구현하는 모든 것을 취합니다. 이 경우 Rust는 두 가지 암시 적 변환을 수행해야하는데, Rust는이를 수행 할 수단이 없습니다. 따라서 다음 예제는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">경우에 따라 하위 바인딩이 메모리 안전을 위반할 수 있습니다. 차후 버전의 Rust에서 차용 검사기를 업데이트하면이 제한이 제거 될 수 있지만 현재는 패턴을 하위 바인딩없이 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">이에 비해 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 는 잠금을 획득 한 리더 또는 기록기를 구분하지 않으므로 잠금을 사용할 수있을 때까지 기다리는 스레드를 차단합니다. 라이터가 잠금을 보유하지 않는 한 &lt;code&gt;RwLock&lt;/code&gt; 을 사용하면 여러 독자가 잠금을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">결론 : 항상 원하는 색인이 실제로 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">반대로 열거 형을 공개하면 모든 변형이 공개됩니다. 우리는 단지 필요 &lt;code&gt;pub&lt;/code&gt; 전과 &lt;code&gt;enum&lt;/code&gt; 목록 7-10에서와 같이 키워드.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">대조적으로, Rust의 문장은 &lt;em&gt;대부분&lt;/em&gt; 시퀀스 표현 평가를 포함하고 명시 적으로 제공하는 역할 을합니다.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">반대로, 목록 19-7에서 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 을 사용하면 슬라이스를 사용할 때 충돌이 발생할 수 있습니다. 이 코드는 임의의 메모리 위치를 취하고 10,000 항목 길이의 슬라이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">본질적으로 &lt;code&gt;*const c_void&lt;/code&gt; 는 C의 &lt;code&gt;const void*&lt;/code&gt; 와 &lt;code&gt;*mut c_void&lt;/code&gt; 는 C의 &lt;code&gt;void*&lt;/code&gt; 와 같습니다 . 즉, Rust의 &lt;code&gt;()&lt;/code&gt; 유형 인 C의 &lt;code&gt;void&lt;/code&gt; 반환 유형 과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">함수 시그니처에서 각 매개 변수의 유형을 선언 &lt;em&gt;해야합니다&lt;/em&gt; . 이것은 Rust 디자인에서 의도적으로 결정한 것입니다. 함수 정의에 타입 주석이 필요하다는 것은 컴파일러가 코드의 다른 곳에서이를 사용하여 의미를 파악할 필요가 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">일반적으로 &lt;code&gt;--crate-type=bin&lt;/code&gt; 또는 &lt;code&gt;--crate-type=lib&lt;/code&gt; 는 모든 컴파일 요구에 충분해야하며 상자의 출력 형식에 대해보다 세밀한 제어가 필요한 경우 다른 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">일반적으로 C ++ 구현은 오버 헤드 제로 원칙을 준수합니다. 사용하지 않는 것은 지불하지 않습니다. 그리고 더 : 당신이 사용하는 것, 당신은 더 나은 코딩을 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">일반적으로 형식을 지정하여 수행 할 수있는 모든 캐스트는 &lt;code&gt;as&lt;/code&gt; 를 사용하여 수행 할 수도 있으므로 &lt;code&gt;let x: u32 = 123&lt;/code&gt; 을 쓰는 대신 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 쓸 수 있습니다 (참고 : &lt;code&gt;let x: u32 = 123&lt;/code&gt; 은 그 상황에서 최고입니다). 그러나 다른 방향에서는 동일하지 않지만, 명시 적으로 &lt;code&gt;as&lt;/code&gt; 를 사용하면 원시 포인터의 유형을 변경하거나 클로저를 원시 포인터로 바꾸는 것과 같이 암시 적으로 허용되지 않는 몇 가지 강제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">일반적으로이 기능은 패닉 상태 일 수 있으므로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 소문자를 명시 적으로 처리하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">일반적으로 정규화 된 구문은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">일반적으로 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값 을 사용하려면 각 변형을 처리 할 코드가 필요합니다. &lt;code&gt;Some(T)&lt;/code&gt; 값 이있는 경우에만 실행되는 일부 코드를 원하며이 코드 는 내부 &lt;code&gt;T&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 값이 있고 해당 코드에 사용 가능한 &lt;code&gt;T&lt;/code&gt; 값 이없는 경우 다른 코드를 실행하려고 합니다. &lt;code&gt;match&lt;/code&gt; 표현식 열거 사용할 때 단지이를 수행하는 제어 흐름 구조이다 그것이 갖는 ENUM 어떤 변형에 따라 다양한 코드를 실행하고, 그 코드가 일치하는 값 안의 데이터를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">일반적으로 유형의 크기는 컴파일에서 안정적이지 않지만 프리미티브와 같은 특정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">일반적으로이 책은 앞뒤로 순서대로 읽고 있다고 가정합니다. 이후의 장은 이전 장의 개념을 바탕으로하며, 이전 장에서는 주제에 대한 자세한 내용을 다루지 않을 수 있습니다. 우리는 일반적으로 이후 장에서 주제를 다시 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">일반적으로 반박과 반박 할 수없는 패턴의 차이에 대해 걱정할 필요는 없습니다. 그러나 오류 메시지에 표시 될 때 응답 할 수 있도록 반품 성 개념에 익숙해야합니다. 이 경우 코드의 의도 된 동작에 따라 패턴 또는 패턴을 사용하는 구문을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">여기에서 &lt;code&gt;jon_snow&lt;/code&gt; 는 이미 &lt;code&gt;nights_watch&lt;/code&gt; 참조에 의해 빌려 &lt;code&gt;starks&lt;/code&gt; 동시에 스타크 폐쇄에 의해 빌릴 수 없습니다 . 이 문제를 해결하려면 차용이 끝난 후 마감을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 변경할 수 없으므로 &lt;code&gt;y&lt;/code&gt; 에서 변경 가능하게 빌리려고 하면 실패합니다. 이 오류를 해결하려면 &lt;code&gt;x&lt;/code&gt; 를 변경 가능 하게 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">여기에서 &lt;code&gt;y&lt;/code&gt; 는 내부 범위의 끝에서 삭제되지만 &lt;code&gt;println&lt;/code&gt; 까지 &lt;code&gt;x&lt;/code&gt; 에 의해 빌려집니다 . 이전 예제를 수정하려면 println 이후까지 &lt;code&gt;y&lt;/code&gt; 가 떨어지지 않도록 범위를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstra는 1972 년의&amp;ldquo;The Humble Programmer&amp;rdquo;에세이에서&amp;ldquo;프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법 일 수 있지만 그들의 부재를 보여주기에는 부적절하다&amp;rdquo;고 말했다. 그렇다고 테스트를 최대한 많이 시도해서는 안된다는 의미는 아닙니다!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">2009 년 발표에서&amp;ldquo;Null References : Billion Dollar Mistake&amp;rdquo;는 null 발명가 인 Tony Hoare가 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">불변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">변경 불가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">스레드에서 &lt;code&gt;Worker&lt;/code&gt; 는 채널의 수신 측을 반복하고 수신 작업의 폐쇄를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">표준 라이브러리에서 반복자를 제공하지 않는 언어의 경우 인덱스 0에서 변수를 시작하고 해당 변수를 사용하여 벡터로 색인하여 값을 가져오고 루프에서 변수 값을 증가 시켜서 동일한 기능을 작성할 수 있습니다. 벡터의 총 항목 수에 도달 할 때까지</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">포인터가있는 언어에서는 다른 메모리에 포인터를 유지하면서 메모리를 확보하여 다른 사람에게 제공되었을 수있는 메모리의 위치를 ​​참조 하는 &lt;em&gt;댕글 링 포인터&lt;/em&gt; 를 잘못 만드는 것이 쉽습니다 . 이와 대조적으로 Rust에서는 컴파일러가 참조가 참조에 매달려 있지 않도록 보장합니다. 일부 데이터에 대한 참조가있는 경우 컴파일러는 데이터에 대한 참조가 데이터를 참조하기 전에 데이터가 범위를 벗어나지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">다른 많은 프로그래밍 언어에서 색인으로 참조하여 문자열의 개별 문자에 액세스하는 것은 유효하고 일반적인 작업입니다. 그러나 Rust에서 인덱싱 구문을 사용하여 &lt;code&gt;String&lt;/code&gt; 일부에 액세스하려고 하면 오류가 발생합니다. 목록 8-19의 유효하지 않은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">많은 프로그래밍 언어에서 스택과 힙에 대해 자주 생각할 필요가 없습니다. 그러나 Rust와 같은 시스템 프로그래밍 언어에서 값이 스택에 있는지 또는 힙에 있는지는 언어의 작동 방식과 특정 결정을 내리는 이유에 더 많은 영향을 미칩니다. 소유권의 일부는이 장의 뒷부분에서 스택 및 힙과 관련하여 설명되므로 준비에 대한 간단한 설명이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 블록 내의 메소드 시그니처 에서 참조는 구조체의 필드에있는 참조의 수명과 연관되거나 독립적 일 수 있습니다. 또한 수명 제거 규칙을 사용하면 메서드 서명에 수명 주석이 필요하지 않은 경우가 많습니다. Listing 10-25에서 정의한 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 라는 구조체를 사용하여 몇 가지 예를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">메소드 서명에는 다른 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입 한 후 저장하려는 값의 유형을 종종 유추 할 수 있으므로이 유형 주석을 수행 할 필요가 거의 없습니다. 초기 값을 갖는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 생성하는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 제공합니다 ! 편의상 매크로. 매크로는 사용자가 제공 한 값을 보유한 새 벡터를 생성합니다. Listing 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">보다 현실적인 코드에서 Rust는 값을 삽입하면 저장하려는 값의 유형을 추론 할 수 있으므로이 유형 주석을 거의 수행 할 필요가 없습니다. 초기 값이 있는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 만드는 것이 더 일반적 이며 Rust는 &lt;code&gt;vec!&lt;/code&gt; 편의를 위해 매크로. 매크로는 사용자가 제공 한 값을 보유하는 새 벡터를 생성합니다. 목록 8-2 는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 보유 하는 새로운 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 를 만듭니다 . 정수 유형은 3 장의 &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;데이터 유형&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기본 정수 유형이므로 &lt;code&gt;i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="translated">대부분의 경우 (모두는 아니지만) 하나의 표현 힌트 만 사용하면 충분합니다. 현재 아키텍처에 따라 표현 힌트를 &lt;code&gt;cfg_attr&lt;/code&gt; 려면 cfg_attr을 사용 하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">대부분의 경우 더 이상 특정 함수 매개 변수가 필요하지 않은 경우 서명을 변경하여 사용하지 않는 매개 변수가 포함되지 않도록합니다. 함수 매개 변수를 무시하면 특정 유형 서명이 필요하지만 구현의 함수 본문에 매개 변수 중 하나가 필요하지 않은 경우 특성을 구현할 때와 같이 일부 경우에 특히 유용 할 수 있습니다. 그러면 컴파일러는 이름을 대신 사용했을 때와 같이 사용하지 않는 함수 매개 변수에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="translated">대부분의 경우 잊혀진 가져 오기 또는 오타입니다. 그러나 이러한 유형을 가질 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">대부분의 경우 참조는 원래 값과 매우 유사하게 사용할 수 있습니다. 필드 액세스, 메소드 호출 및 인덱싱은 동일하게 작동합니다 (물론 변경 규칙 저장). 또한 비교 연산자는 참조의 구현을 투명하게 참조하여 참조 값을 소유 한 값과 동일하게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">대부분의 최신 운영 체제에서 실행 된 프로그램의 코드는 &lt;em&gt;프로세스&lt;/em&gt; 에서 실행되며 운영 체제는 여러 프로세스를 한 번에 관리합니다. 프로그램 내에서 동시에 실행되는 독립 부품을 가질 수도 있습니다. 이러한 독립 부품을 실행하는 기능을 &lt;em&gt;스레드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">대부분의 경우 컴파일되지 않은 올바른 코드 버전으로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">가변 컨텍스트에서 &lt;code&gt;*x&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 참조도 아니고 원시 포인터도 아님)는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">변경 가능한 컨텍스트 에서 비 포인터 유형의 &lt;code&gt;*x&lt;/code&gt; 는 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">한 번의 컴파일 세션에서 컴파일러는 명령 행 플래그 또는 &lt;code&gt;crate_type&lt;/code&gt; 속성을 사용하여 여러 아티팩트를 생성 할 수 있습니다 . 하나 이상의 명령 행 플래그가 지정된 경우, 모든 &lt;code&gt;crate_type&lt;/code&gt; 속성은 명령 행으로 지정된 아티팩트 만 빌드하기 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">한 가지 방법으로이 프로그램이 더 좋습니다. 튜플을 사용하면 약간의 구조를 추가 할 수 있으며 이제는 하나의 인수 만 전달합니다. 그러나 다른 방식으로,이 버전은 덜 명확합니다. 튜플은 해당 요소의 이름을 지정하지 않으므로 튜플의 일부를 인덱싱해야하기 때문에 계산이 더 혼란스러워졌습니다.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">유형이이 특성을 구현하려면 모든 메소드에 대한 구현을 제공해야 할뿐만 아니라 유형 &lt;code&gt;E&lt;/code&gt; 를 지정해야합니다 . 표준 라이브러리 유형 &lt;code&gt;Vec&lt;/code&gt; 에 대한 &lt;code&gt;Container&lt;/code&gt; 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 작성 하려면 &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">파일을 생성하려면 &lt;a href=&quot;struct.openoptions#method.write&quot;&gt; &lt;code&gt;OpenOptions::write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.openoptions#method.append&quot;&gt; &lt;code&gt;OpenOptions::append&lt;/code&gt; &lt;/a&gt; 액세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Rust의 전역 유형 유추가 없음을 일관성있게 유지하기 위해 항목 서명의 디자인으로 유형 및 const 자리 표시자가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="translated">요구 사항을 &lt;code&gt;'static&lt;/code&gt; 에서 인수에서 파생 된 수명 으로 변경하려면 익명 수명 &lt;code&gt;'_&lt;/code&gt; 또는 적절한 명명 된 수명에 명시 적 경계를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="translated">이러한 종류의 제약 조건을 인코딩하려면 &lt;code&gt;where&lt;/code&gt; 절과 새로운 유형 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제네릭 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 할 수있는 모든 인수를 취하기를 원한다는 것을 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 경계를 사용할 수 있습니다 . 예 : &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 로 변환 할 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일반 함수가 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 될 수있는 모든 인수를 취하도록 표현하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 특성 범위를 사용할 수 있습니다 . 예를 들어, &lt;code&gt;is_hello&lt;/code&gt; 함수 는 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 로 변환 될 수있는 모든 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">이 오류를 해결하려면 사용중인 유형이 특성을 구현하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">이 오류를 해결하려면 &lt;code&gt;pub&lt;/code&gt; 키워드 를 사용하여 항목을 공개해야 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">컴파일 타임에 내장 함수를 사용하려면 https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs에서 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 로 구현을 복사해야합니다. /interpret/intrinsics.rs는 추가 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 극한한다.</target>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴을보다 인체 공학적으로 만들기 위해 &lt;a href=&quot;types/function-item&quot;&gt;함수 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;클로저 특성&lt;/a&gt; 서명 에서 수명 인수를 &lt;em&gt;생략&lt;/em&gt; 할 수 있습니다 . 다음 규칙은 생략 된 수명에 대한 수명 매개 변수를 유추하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; ' 도 동일한 방식으로 수명을 추정하는 데 사용할 수 있습니다. 경로의 수명 동안 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">일반적인 패턴이 더 인체 공학적으로 만들기 위해, 평생 인수 할 수있다 &lt;em&gt;생략&lt;/em&gt; 의 &lt;a href=&quot;types/function-item&quot;&gt;기능 항목&lt;/a&gt; , &lt;a href=&quot;types/function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 및 &lt;a href=&quot;types/closure&quot;&gt;폐쇄 형질&lt;/a&gt; 서명. 다음 규칙은 제거 된 수명에 대한 수명 매개 변수를 추론하는 데 사용됩니다. 추론 할 수없는 수명 매개 변수를 제거하는 것은 오류입니다. 자리 표시 자 수명 &lt;code&gt;'_&lt;/code&gt; 은 동일한 방식으로 수명을 추론하는 데 사용할 수도 있습니다. 경로의 수명의 경우 &lt;code&gt;'_&lt;/code&gt; 를 사용하는 것이 좋습니다. 특성 개체 수명은 &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;아래에&lt;/a&gt; 설명 된 다른 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="translated">C 표현 레이아웃 &lt;code&gt;repr(C)&lt;/code&gt; 를 일치 &lt;code&gt;pad_to_align&lt;/code&gt; 려면 레이아웃을 모든 필드로 확장 한 후 pad_to_align 을 호출해야 합니다. (지정되지 않았기 때문에 기본 Rust 표현 레이아웃 &lt;code&gt;repr(Rust)&lt;/code&gt; 와 일치하는 방법은 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">사용하기 쉽고 사용자에게 필요한 내용 만 노출하는 잘 구성된 API를 사용자에게 제공하기 위해 이제 Rust의 모듈을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">즉, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; 이다 &lt;em&gt;하지&lt;/em&gt; 같은 &lt;code&gt;y&lt;/code&gt; , 그것을하지 않는 정의되지 않은 동작 간접 참조 인 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 로 포인트 동일한 할당 된 개체.</target>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">다시 말해서, 모든 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 는&lt;/a&gt; 자신을 반환함으로써 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 이것은 두 가지를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">즉, 각 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;park&lt;/code&gt; 및 &lt;code&gt;unpark&lt;/code&gt; 를 사용하여 잠 그거나 잠금을 해제 할 수있는 스핀 락과 같은 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">다시 말해, 크기가 0 인 포인터가 할당 자에서 흘러 나올 수 있으면 할당자는 마찬가지로 해당 포인터가 할당 해제 및 재 할당 방법으로 다시 흐르는 포인터를 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">즉, 두 키가 같으면 해시도 같아야합니다. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 은&lt;/a&gt; 모두이 동작에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">즉, 두 키가 같으면 해시가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="translated">즉, 위의 예에서 &lt;code&gt;Drop::drop&lt;/code&gt; 을 명시 적으로 호출하려고 하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">즉, 두 반복기를 체인으로 연결합니다. 🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">즉, &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 레이어를 자동으로 제거합니다 . 매핑이 이미 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환하고 건너 뛰려는 경우&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 의 다음 &lt;code&gt;filter_map&lt;/code&gt; 사용에 훨씬 좋네요 훨씬이다.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">즉, 두 개의 이터레이터를 하나로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">즉, &lt;code&gt;f(c)&lt;/code&gt; 와 같은 모든 문자 &lt;code&gt;c&lt;/code&gt; 를 제거하십시오. 가 &lt;code&gt;false&lt;/code&gt; 를 반환 . 이 방법은 원래 순서대로 각 문자를 한 번만 방문하여 유지되며 유지되는 문자의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="translated">즉, 모든 요소가 제거 &lt;code&gt;e&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; . 요소는 정렬되지 않은 (및 지정되지 않은) 순서로 방문됩니다.</target>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 와 같은 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거하십시오. 반환 &lt;code&gt;false&lt;/code&gt; . 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">즉, 모든 요소 &lt;code&gt;e&lt;/code&gt; 를 제거 하여 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; false를 돌려 준다. 이 방법은 원래 순서대로 각 요소를 정확히 한 번 방문하여 유지되며 유지 된 요소의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">즉, 모든 쌍 제거 &lt;code&gt;(k, v)&lt;/code&gt; 되도록 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">즉, 결과는 &lt;code&gt;self / rhs&lt;/code&gt; 정수로 반올림 &lt;code&gt;n&lt;/code&gt; 되도록 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . 경우 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; 이 제로 (녹 기본값)쪽으로 둥근 같다; 만약 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; 이 무한대를 향하여 +/- 라운드 같다.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">다시 말해 여기에는 두 가지 중요한 시점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">다시 말해, Rust에게 &lt;code&gt;search&lt;/code&gt; 함수에 의해 반환 된 데이터 는 &lt;code&gt;contents&lt;/code&gt; 인수 에서 &lt;code&gt;search&lt;/code&gt; 함수에 전달 된 데이터가 존재하는 한 지속될 것이라고 Rust에 알려줍니다 . 이건 중요하다! 슬라이스가 참조 &lt;em&gt;하는&lt;/em&gt; 데이터 는 참조가 유효해야합니다. 컴파일러는 우리의 문자열 조각을 만들고 있어요 가정하면 &lt;code&gt;query&lt;/code&gt; 보다는 &lt;code&gt;contents&lt;/code&gt; &lt;em&gt;&lt;/em&gt; 안전성 검사가 잘못 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">즉, &lt;code&gt;match&lt;/code&gt; 하는 구문 설탕으로 생각 &lt;code&gt;if let&lt;/code&gt; 값이 하나의 패턴과 일치하는 실행 코드와 다른 모든 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">즉, 당신은 변환해야 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; A와 &lt;code&gt;T&lt;/code&gt; 수행하기 전에 &lt;code&gt;T&lt;/code&gt; 의 그것으로 작업을. 일반적으로 이것은 null과 관련하여 가장 일반적인 문제 중 하나를 포착하는 데 도움이됩니다. 실제로는 무언가가 null이 아니라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">다시 말해서 : t &amp;isin; FOLLOW (M) 토큰 시퀀스가 ​​존재하는 경우에만 (잠재적으로 비어 있음) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; 여기서 :</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">그러나 잘못된 예에서는 단일 콘크리트 유형을 참조하고 있습니다. 우리는 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현 한다는 것을 알고 있기 때문에 &lt;code&gt;where&lt;/code&gt; 절 에도이를 지정할 이유가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; 및 &lt;code&gt;Hash&lt;/code&gt; 는 차용 및 소유 값과 동일해야합니다. &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; 는 &lt;code&gt;x == y&lt;/code&gt; 와 동일한 결과를 제공해야합니다. .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="translated">특히, 함수 포인터에 &lt;code&gt;#[track_caller]&lt;/code&gt; 를 사용하여 함수를 강제하면 관찰자가 속성 함수의 정의 사이트에서 호출 된 것처럼 보이는 shim이 생성되어 가상 호출에서 실제 호출자 정보가 손실됩니다. 이 강제의 일반적인 예는 메서드가 속성을 갖는 특성 개체의 생성입니다.</target>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">특히, 하나의 소정의 할당을 통해 할당 된 메모리 블록이 있는지 레이아웃 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;a.usable_size(k)&lt;/code&gt; 를 반환 &lt;code&gt;(l, u)&lt;/code&gt; 다음 하나의 해당 블록을 전달할 수 &lt;code&gt;a.dealloc()&lt;/code&gt; 크기에 레이아웃을 범위 [l, u]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="translated">특히, 이전 코드 예제에서와 같이 레지스터 제약 조건의 닫는 대괄호를 잊은 경우 (문제 # 51430 참조) 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">특히 레지스터 제약 조건의 닫는 괄호를 잊어 버린 경우 발생할 수 있습니다 (문제 # 51430 참조).</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">특히, 원시 항목을 초기화하는 데 사용 된 해시는 여전히 항목에 저장된 키의 해시와 일치해야합니다. 크기를 조정할 때 HashMap 구현에서 키만 사용 가능한 해시를 다시 계산해야 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">특히 결과 포인터는 &lt;code&gt;self&lt;/code&gt; 가 가리키는 동일한 할당 된 개체에 연결된 상태로 유지 됩니다. 다른 할당 된 개체에 액세스하는 데 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; . Rust에서 모든 (스택 할당) 변수는 별도의 할당 된 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">특히, 리턴 값 &lt;code&gt;r&lt;/code&gt; 은 대부분의 경우 &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; 를 충족시킵니다 . 그러나, 부동 소수점에 의한 반올림 에러는 발생할 수있다 &lt;code&gt;r == rhs.abs()&lt;/code&gt; 경우 수학적 정의를 위반 &lt;code&gt;self&lt;/code&gt; 보다 훨씬 작다 &lt;code&gt;rhs.abs()&lt;/code&gt; 크기와의 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . 이 결과는 함수의 공동 도메인 요소가 아니지만 실수에서 가장 가까운 부동 소수점 수이므로 &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 속성을 대략적으로 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="translated">특히이 반복기가 구성되는 내부 부분에 대해 &lt;code&gt;fold()&lt;/code&gt; 호출을 시도 하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">특히, 이 반복자가 구성된 내부 부분에서 &lt;code&gt;try_fold()&lt;/code&gt; 호출을 시도 하십시오. 여러 번의 통화가 필요한 경우 &lt;code&gt;?&lt;/code&gt; 연산자는 누산기 값을 연결하는 데 편리하지만 초기 반품 전에 유지해야하는 불변량을주의하십시오. 이것은 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 메소드이므로 오류가 발생한 후 반복을 재개 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">드문 경우이지만 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 대신 패닉이 발생하는 코드를 작성하는 것이 더 적절합니다 . 예제, 프로토 타입 코드 및 테스트에서 패닉이 적절한 이유를 살펴 보겠습니다. 그런 다음 컴파일러가 실패가 불가능하다고 말할 수는 없지만 사람이 할 수있는 상황에 대해 논의합니다. 이 장은 라이브러리 코드에서 패닉 상태를 결정하는 방법에 대한 일반적인 지침으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">간단히 말해 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 는 모든 유형일 수 있음)는 다른 유형이므로 컴파일러는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값을 마치 유효한 값인 것처럼 사용할 수 없게 합니다. 예를 들어,이 코드는 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; &lt;code&gt;i8&lt;/code&gt; 을 추가하려고하기 때문에 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">단일 스레드 시나리오에서는 신호 처리기 또는 특정 종류의 저수준 코드를 작성할 때 문제가 발생할 수 있습니다. 이 순서를 방지 하려면 &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;컴파일러 펜스&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">일부 언어에서는 프로그래머가 스마트 포인터 인스턴스 사용을 마칠 때마다 메모리 나 리소스를 비우려면 코드를 호출해야합니다. 잊어 버린 경우 시스템이 과부하되어 충돌 할 수 있습니다. Rust에서는 값이 범위를 벗어날 때마다 특정 코드 비트가 실행되도록 지정할 수 있으며 컴파일러는이 코드를 자동으로 삽입합니다. 결과적으로 특정 유형의 인스턴스가 완료된 프로그램의 어느 곳에 나 정리 코드를 배치 할 때주의 할 필요가 없습니다. 여전히 리소스가 누출되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="translated">일부 프로그래밍 언어에서 문자열 형식화 함수의 동작은 운영 체제의 로케일 설정에 따라 다릅니다. Rust의 표준 라이브러리에서 제공하는 형식 함수는 로케일 개념이 없으며 사용자 구성에 관계없이 모든 시스템에서 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 유형 조합이 모호 할 수 있습니다. 모호성을 피하기 위해 유형 주위에 괄호를 사용하십시오. 예를 들어, &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;참조 유형&lt;/a&gt; 내의 &lt;a href=&quot;trait-bounds&quot;&gt;유형 경계에&lt;/a&gt; 대한 &lt;code&gt;+&lt;/code&gt; 연산자 는 경계가 적용되는 위치가 확실하지 않으므로 괄호를 사용해야합니다. 이 명확성을 요구하는 문법 규칙 은 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; 대신 &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; 규칙을 사용합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
