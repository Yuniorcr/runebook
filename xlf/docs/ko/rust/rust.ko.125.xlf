<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="49a40db56fe6180d9e3eb242542f45d2d3173d4f" translate="yes" xml:space="preserve">
          <source>AncillaryData</source>
          <target state="translated">AncillaryData</target>
        </trans-unit>
        <trans-unit id="8c3f77779f46bdbd3940ac1fe6a4e53f4cdfa790" translate="yes" xml:space="preserve">
          <source>AncillaryError</source>
          <target state="translated">AncillaryError</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">그리고 &lt;em&gt;SRC는 / front_of_house.rs이&lt;/em&gt; 의 몸에서 정의를 얻을 수 &lt;code&gt;front_of_house&lt;/code&gt; 의 목록 7-22에서와 같이 모듈.</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">그리고 매우 일반적인 출력 소스는 표준 출력입니다.</target>
        </trans-unit>
        <trans-unit id="5cd52670a2b07449cbe1bd4abb403c682ccaf168" translate="yes" xml:space="preserve">
          <source>And finally, for the last example, only &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; work as explicit self parameters. Example:</source>
          <target state="translated">마지막으로 마지막 예에서는 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;Self&lt;/code&gt; , &lt;code&gt;Self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; 만 명시 적 자체 매개 변수로 작동합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">그리고 마지막으로,&amp;ldquo;모노 모르 파이 제이션 (monomorphization)&amp;rdquo;과 같이시의 어느 곳에도없는 단어를 검색 할 때 어떤 줄도 갖지 않도록하십시오 :</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">마지막으로 표준 라이브러리는 여러 표준 매크로를 내보내고이 &lt;a href=&quot;#macros&quot;&gt;페이지에 나열합니다&lt;/a&gt; (기술적으로 모든 표준 매크로가 표준 라이브러리에 의해 정의 된 것은 아니며 일부는 컴파일러에 의해 정의되지만 여기서는 동일하게 문서화 됨) . 전주곡과 마찬가지로 표준 매크로는 기본적으로 모든 상자에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">그리고 이제 작업 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">그리고 이제 몇 가지 실례 :</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">등등.</target>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">그리고 우리의 최종 결과는 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">모두 크기 때문에 예상 출력은 다음과 같을 것이다 &lt;code&gt;rect2&lt;/code&gt; 이 의 크기보다 작은 &lt;code&gt;rect1&lt;/code&gt; 하지만 &lt;code&gt;rect3&lt;/code&gt; 는 보다 넓은 &lt;code&gt;rect1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;generics#where-clauses&quot;&gt;where 절을&lt;/a&gt; 사용 하는 것을 제외하고는 동일한 예 입니다.</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">그런 다음 구조체의 파생 매크로에서 사용법 :</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">그런 다음 상기 파생 매크로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">그런 다음 이진 상자를 사용하여 &quot;42&quot;를 표준 출력으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="57be02e986031e930e9bf37db6620140ea92c664" translate="yes" xml:space="preserve">
          <source>And then we use it in a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">그런 다음 바이너리 크레이트에서 사용하여 &quot;42&quot;를 표준 출력으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">그리고이 함수를 변형으로 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">이제 끝났습니다. 이제 목록 17-11이 모두 작동합니다! 블로그 게시물 워크 플로의 규칙으로 상태 패턴을 구현했습니다. 규칙과 관련된 논리는 &lt;code&gt;Post&lt;/code&gt; 전체에 흩어져 있지 않고 상태 객체에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">그리고 당신은 프로그램의 하드 링크를 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">익명 유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">OOP와 일반적으로 관련된 또 다른 측면은 &lt;em&gt;encapsulation&lt;/em&gt; 이라는 아이디어인데 , 이는 객체의 구현 세부 사항이 해당 객체를 사용하여 코딩 할 수 없음을 의미합니다. 따라서 객체와 상호 작용하는 유일한 방법은 공개 API를 사용하는 것입니다. 객체를 사용하는 코드는 객체의 내부에 닿아 데이터 나 동작을 직접 변경할 수 없어야합니다. 이를 통해 프로그래머는 객체를 사용하는 코드를 변경할 필요없이 객체의 내부를 변경하고 리팩토링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">이 오류를 발생시키는 다른 경우는 유형을 상위 모듈로 가져 오는 경우입니다. 이 문제를 해결하려면 제안을 따르고 File을 직접 &lt;code&gt;use super::File;&lt;/code&gt; 하거나 super :: File을 사용하십시오. 부모 네임 스페이스에서 형식을 가져옵니다. 이 오류를 일으키는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">이 오류가 발생하는 또 다른 경우는 값이 예상되지만 다른 것이 발견 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">해시 맵의 또 다른 일반적인 사용 사례는 키 값을 찾은 다음 이전 값을 기반으로 업데이트하는 것입니다. 예를 들어, 목록 8-26은 각 단어가 일부 텍스트에 나타나는 횟수를 세는 코드를 보여줍니다. 단어와 함께 해시 맵을 키로 사용하고 값을 증가시켜 해당 단어를 본 횟수를 추적합니다. 단어를 처음 본 경우에는 먼저 값 0을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="6faac33ab3de2071db8e2f1ae3893ca39a492717" translate="yes" xml:space="preserve">
          <source>Another common way to evaluate an iterator is to use the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">반복기를 평가하는 또 다른 일반적인 방법은 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 새 컬렉션을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">이 라이브러리에 의존하는 또 다른 상자에는 현재 정의 된 모듈 구조를 지정하여 &lt;code&gt;art&lt;/code&gt; 의 항목 을 범위로 가져 오는 &lt;code&gt;use&lt;/code&gt; 문 이 필요 합니다 . 14-4 보여줍니다 사용하는 상자의 예를 나열 &lt;code&gt;PrimaryColor&lt;/code&gt; 을 하고 &lt;code&gt;mix&lt;/code&gt; 로부터 항목 &lt;code&gt;art&lt;/code&gt; 상자를 :</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">소유권이없는 다른 데이터 형식은 &lt;em&gt;슬라이스&lt;/em&gt; 입니다. 슬라이스를 사용하면 전체 컬렉션이 아닌 컬렉션에서 연속 된 요소 시퀀스를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">주의해야 할 또 다른 세부 사항은 Rust가 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용할 때 모든 종류의 논리 오류로부터 보호 할 수 없다는 것입니다 . 15 장에서 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하면 두 개의 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 서로를 참조하여 메모리 누수가 발생 하는 참조주기가 생성 될 위험이 있음을 상기 하십시오. 마찬가지로 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;em&gt;교착 상태&lt;/em&gt; 가 발생할 위험이 있습니다.&lt;em&gt;&lt;/em&gt;. 작업이 두 개의 리소스를 잠글 필요가 있고 두 개의 스레드가 각각 잠금 중 하나를 획득하여 서로를 영원히 기다릴 때 발생합니다. 교착 상태에 관심이있는 경우 교착 상태가있는 Rust 프로그램을 작성하십시오. 그런 다음 어떤 언어로든 뮤텍스에 대한 교착 상태 완화 전략을 연구하고 Rust에서 구현하십시오. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;MutexGuard&lt;/code&gt; 에 대한 표준 라이브러리 API 설명서 는 유용한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">상수와 정적 변수의 또 다른 차이점은 정적 변수를 변경할 수 있다는 것입니다. 변경 가능한 정적 변수에 액세스하고 수정하는 것은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . Listing 19-10은 이름이 &lt;code&gt;COUNTER&lt;/code&gt; 인 가변 정적 변수를 선언, 액세스 및 수정하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">또 다른 단점은 우리가 논리를 복제했다는 것입니다. 중복의 일부를 제거하기 위해, 우리는 디폴트 구현하기 위해 시도 할 수 있습니다 &lt;code&gt;request_review&lt;/code&gt; 을 하고 &lt;code&gt;approve&lt;/code&gt; 온 방법 &lt;code&gt;State&lt;/code&gt; 특성이 반환 &lt;code&gt;self&lt;/code&gt; ; 그러나 이것은 특성이 구체적인 &lt;code&gt;self&lt;/code&gt; 가 정확히 무엇인지 알지 못하기 때문에 물체 안전에 위배 됩니다. &lt;code&gt;State&lt;/code&gt; 를 특성 객체로 사용할 수 있기를 원 하므로 객체 안전을위한 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">다른 잘못된 코드 예제 :</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">복잡한 NT의 다른 예는 &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; 이며, 이는 &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; 형식의 모든 조각과 일치합니다 . 안녕 &amp;lt;expr&amp;gt;; ... 여기서 &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; 적어도 한 번 발생합니다. 이 복잡한 NT에는 전용 구분 기호 토큰이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ec0f590b55aa6269d2b833239d2434dfe2c8db0" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 유형 의 또 다른 예는 참조 계수 포인터 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 입니다. 참조 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 주어지면 새 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 복제 하여 비원 자적 방식으로 참조 횟수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 이외의 타입 의 다른 예는 참조 카운트 포인터 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 참조가 주어지면 , 새로운 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 복제 하여 비원 자적 방식으로 참조 카운트를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">구조체에 &lt;code&gt;Cow&lt;/code&gt; 를 유지하는 방법을 보여주는 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 의 4 바이트 고정 크기의 또 다른 의미는 per- &lt;code&gt;char&lt;/code&gt; 처리가 더 많은 메모리를 사용하여 종료 될 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">매크로와 함수의 또 다른 중요한 차이점은 파일을 호출 &lt;em&gt;하기 전에&lt;/em&gt; 매크로를 정의하거나 범위 내로 가져와야한다는 것입니다. 함수는 어디에서나 정의하고 어디에서나 호출 할 수있는 기능 과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">개선의 여지가 있음을 보여주는 또 다른 지표 는 &lt;code&gt;parse_config&lt;/code&gt; 의 &lt;code&gt;config&lt;/code&gt; 부분입니다 . 이는 반환하는 두 값이 관련되어 있고 둘 다 하나의 구성 값의 일부임을 의미합니다. 우리는 현재 두 가지 값을 튜플로 그룹화하는 것 이외의 데이터 구조에서이 의미를 전달하지 않습니다. 두 값을 하나의 구조체에 넣고 각 구조체 필드에 의미있는 이름을 지정할 수 있습니다. 그렇게하면이 코드의 미래 관리자가 서로 다른 값이 서로 어떻게 관련되어 있고 그 목적이 무엇인지 더 쉽게 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">우리가 이미 사용하고있는 또 다른 종류의 제네릭을 &lt;em&gt;lifetimes&lt;/em&gt; 라고 합니다. 수명은 유형에 원하는 동작이 있는지 확인하는 것이 아니라 필요한만큼 참조가 유효한지 확인합니다. 평생 어떻게 그렇게하는지 보자.</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; 과 비슷한 또 다른 방법 인 &lt;code&gt;expect&lt;/code&gt; 는 &lt;code&gt;panic!&lt;/code&gt; 선택할 수있게합니다 ! 에러 메시지. &lt;code&gt;unwrap&lt;/code&gt; 대신 &lt;code&gt;expect&lt;/code&gt; 를 사용 하고 좋은 오류 메시지를 제공 하면 의도를 전달하고 공황의 원인을 쉽게 추적 할 수 있습니다. &lt;code&gt;expect&lt;/code&gt; 의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">UTF-8에 대한 또 다른 요점은 Rust의 관점에서 문자열을 보는 세 가지 관련 방법, 즉 바이트, 스칼라 값 및 grapheme 클러스터 ( &lt;em&gt;문자&lt;/em&gt; 라고 부르는 것에 가장 가까운 것)가 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">또 다른 문제는 다음과 같습니다. &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt; 구현하여 &lt;code&gt;Foo&lt;/code&gt; 유형에 대해 &lt;code&gt;+&lt;/code&gt; 연산자를 오버로드했다고 가정 하지만 이 예제에서와 같이 &lt;code&gt;+=&lt;/code&gt; 를 사용하면 작동하지 않습니다. :</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Rust가 안전하지 않은 대체 자아를 갖는 또 다른 이유는 기본 컴퓨터 하드웨어가 본질적으로 안전하지 않기 때문입니다. Rust가 안전하지 않은 작업을 수행하지 못하게 한 경우 특정 작업을 수행 할 수 없습니다. Rust는 운영 체제와 직접 상호 작용하거나 자체 운영 체제 작성과 같은 저수준 시스템 프로그래밍을 수행 할 수 있어야합니다. 저수준 시스템 프로그래밍 작업은 언어의 목표 중 하나입니다. 안전하지 않은 Rust로 수행 할 수있는 작업과 수행 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">구조체 인스턴스화에 대한 또 다른 단축키를 사용할 수 있습니다. 구조체 업데이트 구문이라는 동일한 유형의 이전 구조체 대부분과 동일한 값을 가진 새 구조체를 만들어야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">스레드가 발생할 때 또 다른 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">참조주기를 피하는 또 다른 솔루션은 데이터 구조를 재구성하여 일부 참조가 소유권을 나타내고 일부 참조가 그렇지 않도록하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비 소유 관계로 구성된주기를 가질 수 있으며 소유권 관계 만 값을 삭제할 수 있는지 여부에 영향을줍니다. Listing 15-25에서 우리는 항상 &lt;code&gt;Cons&lt;/code&gt; 변형이 자신의 목록을 소유하기를 원하므로 데이터 구조를 재구성 할 수 없다. 비 소유 관계가 참조주기를 방지하는 적절한 방법인지 확인하기 위해 부모 노드와 자식 노드로 구성된 그래프를 사용하는 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; 또 다른 스타일의 doc comment, //! , 주석 다음에 항목에 문서를 추가하지 않고 주석이 포함 된 항목에 문서를 추가합니다. 우리는 일반적으로 크레이트 루트 파일 ( 컨벤션에 따라 &lt;em&gt;src / lib.rs&lt;/em&gt; ) 또는 크레이트 또는 모듈 전체를 문서화하기 위해 모듈 내에서 이러한 문서 주석을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7c509361e45630a3070d0b558a9e089279230886" translate="yes" xml:space="preserve">
          <source>Another use case for &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 또 다른 사용 사례는 안전 하지 않은 특성을 구현하는 것입니다. 적어도 하나의 메서드에 컴파일러가 확인할 수없는 불변성이있을 때 트레이 트는 안전하지 않습니다. 우리는 특성이 있음을 선언 할 수 있습니다 &lt;code&gt;unsafe&lt;/code&gt; 가산하여 &lt;code&gt;unsafe&lt;/code&gt; 전에 키워드 &lt;code&gt;trait&lt;/code&gt; 과 같은 특성의 구현 마킹 &lt;code&gt;unsafe&lt;/code&gt; 목록 19-11에서와 같이,도.</target>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">newtype 패턴의 또 다른 사용은 유형의 구현 세부 사항을 추상화하는 것입니다. 새로운 유형을 사용하여 사용 가능한 기능을 직접 제한하는 경우 새 유형은 개인 내부 유형의 API와 다른 공용 API를 노출시킬 수 있습니다. 예.</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">또 다른 유용한 기능 &lt;code&gt;impl&lt;/code&gt; 블록은 우리가 내 함수를 정의 할 수있는 것입니다 &lt;code&gt;impl&lt;/code&gt; 블록 &lt;em&gt;하지 않는&lt;/em&gt; 걸릴 &lt;code&gt;self&lt;/code&gt; 매개 변수로. 그것들은 구조체와 관련되어 있기 때문에 &lt;em&gt;관련 함수&lt;/em&gt; 라고 합니다. 그것들은 작업 할 구조체의 인스턴스가 없기 때문에 메소드가 아닌 함수입니다. 이미 연결된 함수 &lt;code&gt;String::from&lt;/code&gt; 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">일치 암의 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩 할 수 있다는 것입니다. 이것이 열거 형 변형에서 값을 추출하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;Maker&lt;/code&gt; 에서 관련 유형을 제거 하고 대신 입력 유형 매개 변수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f7bb901bc2f8efc6ca57a7f109d4ad53f1c9e20" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using iterators and the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. We&amp;rsquo;ll be going into more detail about iterators and their associated methods in the &lt;a href=&quot;ch13-02-iterators&quot;&gt;&amp;rdquo;Processing a Series of Items with Iterators&amp;rdquo; section of Chapter 13&lt;/a&gt;. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">해시 맵을 구성하는 또 다른 방법은 튜플 벡터에서 반복기와 &lt;code&gt;collect&lt;/code&gt; 메서드를 사용하는 것입니다. 여기서 각 튜플은 키와 해당 값으로 구성됩니다. &lt;a href=&quot;ch13-02-iterators&quot;&gt;13 장의 &quot;반복자를 사용하여 일련의 항목 처리&quot;섹션&lt;/a&gt; 에서 반복기와 관련 메서드에 대해 자세히 설명합니다 . &lt;code&gt;collect&lt;/code&gt; 방법을 포함 컬렉션 종류의 번호로 데이터 수집 &lt;code&gt;HashMap&lt;/code&gt; . 예를 들어, 두 개의 개별 벡터에 팀 이름과 초기 점수가있는 경우 &lt;code&gt;zip&lt;/code&gt; 메서드를 사용하여 &quot;Blue&quot;가 10과 쌍을 이루는 튜플 벡터를 만들 수 있습니다 . 그런 다음 &lt;code&gt;collect&lt;/code&gt; 메소드를 사용하여 튜플 벡터를 해시 맵으로 바꿀 수 있습니다 ( Listing 8-21 참조).</target>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">해시 맵을 구성하는 또 다른 방법은 튜플의 벡터 에서 &lt;code&gt;collect&lt;/code&gt; 메소드를 사용하는 것입니다 . 각 튜플은 키와 해당 값으로 구성됩니다. &lt;code&gt;collect&lt;/code&gt; 방법을 포함 컬렉션 종류의 번호로 데이터 수집 &lt;code&gt;HashMap&lt;/code&gt; . 예를 들어 두 개의 별도 벡터에 팀 이름과 초기 점수가있는 경우 &lt;code&gt;zip&lt;/code&gt; 방법을 사용하여 &quot;Blue&quot;가 10과 쌍을 이루는 튜플의 벡터를 만들 수 있습니다 . 그런 다음 &lt;code&gt;collect&lt;/code&gt; 메소드를 사용하여 튜플의 벡터를 해시 맵으로 변환 할 수 있습니다 ( 목록 8-21 참조).</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; 에 대한 다른 생각 방법 : &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 의 클로저는 각 요소에 대해 하나의 항목을 반환하고 &lt;code&gt;flat_map()&lt;/code&gt; 의 클로저는 각 요소에 대한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1f28d9b77a5082f5c9d67a87d7ff9fdc9ab88db" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; 에 대한 또 다른 생각 : &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 의 클로저는 각 요소에 대해 하나의 항목을 반환하고 &lt;code&gt;flat_map()&lt;/code&gt; 의 클로저는 각 요소에 대한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">통합 필드에 액세스하는 다른 방법은 패턴 일치를 사용하는 것입니다. 공용체 필드의 패턴 일치는 패턴이 정확히 하나의 필드를 지정해야한다는 점을 제외하고 구조체 패턴과 동일한 구문을 사용합니다. 패턴 일치는 특정 필드와의 결합을 읽는 것과 같으므로 &lt;code&gt;unsafe&lt;/code&gt; 블록 에도 배치 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">여러 값을 수집하는 또 다른 방법은 &lt;em&gt;배열을&lt;/em&gt; 사용하는 것 입니다. 튜플과 달리 배열의 모든 요소는 동일한 유형을 가져야합니다. Rust의 배열은 튜플과 같이 고정 길이를 가지기 때문에 Rust의 배열은 다른 언어의 배열과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">컴파일러에 충분한 정보를 제공하는 또 다른 방법은 일반 유형 매개 변수를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">우리가 &lt;code&gt;largest&lt;/code&gt; 구현할 수있는 또 다른 방법 은 함수가 슬라이스 의 &lt;code&gt;T&lt;/code&gt; 값에 대한 참조를 반환하는 것 입니다. 우리가 반환 형식을 변경하는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 대신 &lt;code&gt;T&lt;/code&gt; 하여 참조를 반환하는 함수의 본문을 변경, 우리는 필요하지 않을 &lt;code&gt;Clone&lt;/code&gt; 또는 &lt;code&gt;Copy&lt;/code&gt; 범위를 특징 부 (trait)과 우리가 힙 할당을 피할 수 있습니다. 이 대체 솔루션을 직접 구현해보십시오!</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">모든 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 는 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;크기&lt;/a&gt; 가 0 입니다. &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 로 만들 수 있습니다 . &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 를 사용 하는 경우 적절한 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 인스턴스 자체를 구현하므로이를 수행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="39acf470f03d64f751336d22936382dc10cf66e8" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">모든 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 는 것입니다 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;크기가 0 인&lt;/a&gt; . &lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 으로 만들 수 있습니다 . &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 를 사용 하는 경우 적절한 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 인스턴스 자체를 구현하므로이를 수행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">모든 &lt;code&gt;enum&lt;/code&gt; 값은 해당 &lt;code&gt;enum&lt;/code&gt; 형에 대한 가장 큰 변형 뿐만 아니라 판별자를 저장하는 데 필요한 크기 만큼 많은 메모리를 소비 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">모든 &lt;code&gt;with_capacity&lt;/code&gt; 의 생성자는 지정된 수의 요소에 대한 충분한 공간을 할당 컬렉션을 지시합니다. 이상적으로 이것은 많은 요소에 대한 것이지만 일부 구현 세부 사항은 이것을 막을 수 있습니다. 자세한 내용은 컬렉션 별 설명서를 참조하십시오. 일반적으로 삽입 할 요소 수를 정확히 알거나 최소한 그 수에 대한 상한선이있는 경우 &lt;code&gt;with_capacity&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">이 목록에 포함되지 않은 모든 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="49edcccea744a8f077751ea25c38d4fc4cfa0fe8" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">모든 IP 주소는 버전 4 또는 버전 6 주소 일 수 있지만 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 열거 형 값이 변형 중 하나 일 수 있기 때문에 열거 형 데이터 구조를 적절하게 만듭니다. 버전 4 및 버전 6 주소는 여전히 기본적으로 IP 주소이므로 코드가 모든 종류의 IP 주소에 적용되는 상황을 처리 할 때 동일한 유형으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">모든 IP 주소는 버전 4 또는 버전 6 주소 일 수 있지만 동시에 둘 다일 수는 없습니다. 열거 형 값은 변형 중 하나 일 수 있으므로 IP 주소의 속성으로 인해 열거 형 데이터 구조가 적합합니다. 버전 4와 버전 6 주소는 여전히 기본적으로 IP 주소이므로 코드가 모든 종류의 IP 주소에 적용되는 상황을 처리 할 때 동일한 유형으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">'인쇄 가능한 ASCII'범위 &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; 의 모든 문자는 이스케이프되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">이 순서를 제외한 모든 문자</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">나열된 문자를 제외한 모든 문자</target>
        </trans-unit>
        <trans-unit id="cf63f064edae30139fdd89fa67002f6be993edd6" translate="yes" xml:space="preserve">
          <source>Any conversions allowed by coercion can also be explicitly performed by the &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;type cast operator&lt;/a&gt;, &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">강압에 의해 허용되는 모든 변환은 명시 적으로 수행 할 수 &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;타입 캐스트 연산자&lt;/a&gt; , &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">초과 용량이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cfff92a36bb4f2aba0bfefa3df53467014699fa5" translate="yes" xml:space="preserve">
          <source>Any implementation where a type appears &lt;a href=&quot;#uncovered-type&quot;&gt;uncovered&lt;/a&gt;. &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt;, and &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; are considered blanket impls. However, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; is not a blanket impl, as all instances of &lt;code&gt;T&lt;/code&gt; which appear in this &lt;code&gt;impl&lt;/code&gt; are covered by &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">유형이 &lt;a href=&quot;#uncovered-type&quot;&gt;드러나지 않은&lt;/a&gt; 것처럼 보이는 모든 구현 . &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt; 경우 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt; 경우 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt; 및 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 경우 impl &amp;lt;T&amp;gt; Bar &amp;lt;T&amp;gt; 는 블랭킷으로 간주됩니다. impls. 그러나 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 는 블랭킷 impl이 아닙니다. 이 &lt;code&gt;impl&lt;/code&gt; 에 나타나는 &lt;code&gt;T&lt;/code&gt; 의 모든 인스턴스 가 &lt;code&gt;Vec&lt;/code&gt; 에 포함되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">모든 종류의 집계 생성자 (배열, &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , 튜플, ...)</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">접미사가있는 모든 종류의 리터럴 (문자열, 정수 등)은 토큰으로 유효하며 오류없이 매크로에 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f537d5097da9afc6f346b4806da2a5f2a4e11dd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">접미사가있는 모든 종류의 리터럴 (문자열, 정수 등)은 토큰으로 유효하며 오류없이 매크로에 전달할 수 있습니다. 매크로 자체는 그러한 토큰을 해석하는 방법과 오류 생성 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 유니 코드 시퀀스는 &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">범위 내의 모든 문자</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">나열된 모든 문자</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 구현 한 &lt;a href=&quot;../visibility-and-privacy&quot;&gt;가시적&lt;/a&gt; 특성에 의해 제공되는 모든 방법 . 경우 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터에 형질 경계에서 제공 방법 &lt;code&gt;T&lt;/code&gt; 는 먼저 조회한다. 그런 다음 범위의 나머지 모든 메소드가 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="5c8d97ac8cad3dfb222e1fcec0cd986d681f1547" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Arc::new&lt;/code&gt;.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터는 반환 된 차용 기간 동안 역 참조되지 않아야합니다. 예를 들어 &lt;code&gt;Arc::new&lt;/code&gt; 바로 뒤에 그러한 포인터가 존재하지 않는 경우는 사소한 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="0c05e8f1c6956f4765a713498f6a6547d98317e6" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Rc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Rc::new&lt;/code&gt;.</source>
          <target state="translated">동일한 할당에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터는 반환 된 차용 기간 동안 역 참조되지 않아야합니다. 예를 들어 &lt;code&gt;Rc::new&lt;/code&gt; 바로 뒤에 그러한 포인터가 존재하지 않는 경우는 사소한 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">게시물에서 시도한 다른 변경 사항은 적용되지 않습니다. 예를 들어, 검토를 요청하기 전에 초안 블로그 게시물을 승인하려고하면 게시물이 게시되지 않은 초안으로 남아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">다른 문자에는 '\ xNN'형식의 16 진수 이스케이프가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">힙 메모리 또는 파일 핸들과 같이 값이 관리하는 모든 리소스는 도달 할 수없는 상태로 영원히 유지됩니다. 그러나이 메모리에 대한 포인터가 계속 유효하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">숫자가 아닌 리터럴 토큰에서는 접미사가 거부되고 숫자 리터럴 토큰은 아래 목록의 접미사 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bced9874925b40b1709b82b080279f57f95fc4" translate="yes" xml:space="preserve">
          <source>Any time a type &lt;code&gt;T&lt;/code&gt; is considered &lt;a href=&quot;#local-type&quot;&gt;local&lt;/a&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; are also considered local. Fundamental type constructors cannot &lt;a href=&quot;#uncovered-type&quot;&gt;cover&lt;/a&gt; other types. Any time the term &quot;covered type&quot; is used, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered.</source>
          <target state="translated">모든 유형의 시간 &lt;code&gt;T&lt;/code&gt; 가 고려된다 &lt;a href=&quot;#local-type&quot;&gt;지역&lt;/a&gt; , &lt;code&gt;&amp;amp;T&lt;/code&gt; , &lt;code&gt;&amp;amp;mut T&lt;/code&gt; , &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 현지 간주됩니다. 기본 타입의 생성자가 없습니다 &lt;a href=&quot;#uncovered-type&quot;&gt;다루&lt;/a&gt; 다른 유형. &quot;유형을 적용&quot;할 때마다 용어가 사용되는 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;&amp;amp;T&lt;/code&gt; , &lt;code&gt;&amp;amp;mut T&lt;/code&gt; , &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 적용으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">표준 라이브러리에서 유형 또는 함수를 제공 할 때마다 그 기능 또는 사용법을 잘 모를 경우 API (Application Programming Interface) 문서를 사용하여 찾으십시오!</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 유형 으로 만 구성된 모든 유형은 자동으로 &lt;code&gt;Send&lt;/code&gt; 로 표시됩니다 . 거의 모든 프리미티브 유형은 원시 포인터를 제외하고 &lt;code&gt;Send&lt;/code&gt; 이며 19 장에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 의 모든 유형 매개 변수 또는 수명 매개 변수 는 다음 기준 중 하나 이상을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b06ed0f2a9b9712d1ad4ec6082f1ea5cba3b543" translate="yes" xml:space="preserve">
          <source>Any type parameter parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 의 모든 유형 매개 변수 매개 변수 는 다음 기준 중 하나 이상을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f149c09f36db068ab34499979d351f1c8d5f7f1e" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; 를 파생하는 모든 유형은 해당 유형 매개 변수가 &lt;code&gt;Eq&lt;/code&gt; 를 구현하는지 여부에 &lt;em&gt;관계없이이&lt;/em&gt; 특성을 자동으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="788cf861093b3924fc04a0b5f4dac3cbdc3bb2d9" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; 를 파생하는 모든 유형 은 유형 매개 변수가 &lt;code&gt;Eq&lt;/code&gt; 를 구현하는지 여부에 &lt;em&gt;관계없이이&lt;/em&gt; 특성을 자동으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="cfadd00c3ae966bd61c993066771bfd5d6d8d45d" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;PartialEq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 를 파생하는 모든 유형 은 유형 매개 변수가 &lt;code&gt;Eq&lt;/code&gt; 를 구현하는지 여부에 &lt;em&gt;관계없이이&lt;/em&gt; 특성을 자동으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">내부 변경이 가능한 모든 유형 은 공유 참조를 통해 변경 될 수있는 값 주위의 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt; 래퍼 도 사용해야합니다 . 이 작업에 실패하면 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. 예를 들어, &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; 에서 -ing &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문 이외의 다른 용도로 는 효과가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">누구나 Rust를 개선하기 위해 RFC를 작성할 수 있으며, 제안은 여러 주제 서브 팀으로 구성된 Rust 팀에 의해 검토되고 논의됩니다. &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;Rust의 웹 사이트&lt;/a&gt; 에는 언어 디자인, 컴파일러 구현, 인프라, 문서 등 프로젝트의 각 영역에 대한 팀이 포함 된 전체 팀 목록이 있습니다. 해당 팀은 제안서와 의견을 읽고 자신의 의견을 작성하며 결국 기능을 수락하거나 거부 할 합의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">제네릭 형식 매개 변수가있는 메서드 나 함수 외에도 구조체 또는 특성의 형식 매개 변수를 유추 할 수없는 경우이 오류가 발생할 수 있습니다. 이 경우 모든 후보가 동일한 리턴 유형을 가지므로 항상 유형 어노테이션을 사용할 수있는 것은 아닙니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="b813c448dbc23e1f367ecbf1266f8f07cadc0bab" translate="yes" xml:space="preserve">
          <source>Apart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is for one of the following:</source>
          <target state="translated">수명 연장과 별도로 식의 임시 범위는 식을 포함하는 가장 작은 범위이며 다음 중 하나에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 를 사용하여 문자열에 추가</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">부록 A,&amp;ldquo;키워드&amp;rdquo;에는 2015 년판과 2018 년판으로 작성된 코드가 상호 운용 될 수있는 새로운 원시 식별자 기능도 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">부록 A : 키워드</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">부록 B : 연산자 및 기호</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">부록 C : 파생 특성</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">부록 D-유용한 개발 도구</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">부록 D의 제목은&amp;ldquo;유용한 개발 도구&amp;rdquo;이며 Rust 코드 작성에 도움이되는 최근에 출시 된 도구를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">부록 E-에디션</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">부록 F : 책의 번역</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">부록 G-녹이 발생하는 방식과&amp;ldquo;밤에 녹이 슬다&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">설계에 영향을 미치는 언어에 대한 이론적 근거와 참조를 제공하는 부록 장.</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">부록 : 매크로 후속 설정 모호성 공식 사양</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">지정된 문자열 슬라이스를이 &lt;code&gt;String&lt;/code&gt; 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">컬렉션 뒤에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">목록 뒤에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 뒷면에 요소를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 를이 &lt;code&gt;String&lt;/code&gt; 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">응용 프로그램 이진 인터페이스 (ABI)</target>
        </trans-unit>
        <trans-unit id="9a4440ced79c9610e5a61ec32030ae30f58d9a8c" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;), or returns the provided default (if &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">포함 된 값에 함수를 적용 하거나 ( &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; 인&lt;/a&gt; 경우 ) 제공된 기본값을 반환합니다 ( &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 인&lt;/a&gt; 경우 ).</target>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">포함 된 값에 함수를 적용하거나 (있는 경우) 기본값을 계산합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">포함 된 값에 함수를 적용하거나 (있는 경우) 제공된 기본값을 반환합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c71f5fd4b8bc9dae7fc6bb52c696f533ce8ed924" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error.</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd078bc0e6ebca661ba36b845bc2f34f79671219" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f3965e6fc53b243d5a7c2dc2282a44cca3805a" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb07d601f2efbf0db36543c96f74916e4858345" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다. &lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfe6a04d1d11293ba9f6db79767b686fae8501d1" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다. &lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="813b671e50d44d7d39a003bdb093dc2cdbf235f8" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복기의 요소에 함수를 적용하고 첫 번째 참 결과 또는 첫 번째 오류를 반환합니다. &lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">&quot;?&quot;를 적용합니다 운영자. &lt;code&gt;Ok(t)&lt;/code&gt; 의 반환은 실행이 정상적으로 계속되어야한다는 것을 의미하며 &lt;code&gt;?&lt;/code&gt; 값 &lt;code&gt;t&lt;/code&gt; 입니다. &lt;code&gt;Err(e)&lt;/code&gt; 의 반환은 실행이 가장 안쪽에있는 &lt;code&gt;catch&lt;/code&gt; 로 분기 되거나 함수에서 반환 되어야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&quot;?&quot;를 적용합니다 운영자. &lt;code&gt;Ok(t)&lt;/code&gt; 의 반환은 실행이 정상적으로 계속되어야한다는 것을 의미하며 &lt;code&gt;?&lt;/code&gt; 값 &lt;code&gt;t&lt;/code&gt; 입니다. &lt;code&gt;Err(e)&lt;/code&gt; 의 반환은 실행이 가장 안쪽에있는 &lt;code&gt;catch&lt;/code&gt; 로 분기 되거나 함수에서 반환 되어야 함을 의미 합니다. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84c127ccde0ff66daa4ff755926ef467d8ab1d62" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&quot;?&quot;를 적용합니다. 운영자. &lt;code&gt;Ok(t)&lt;/code&gt; 반환은 실행이 정상적으로 계속되어야 함을 의미하고 &lt;code&gt;?&lt;/code&gt; 값 &lt;code&gt;t&lt;/code&gt; 입니다. &lt;code&gt;Err(e)&lt;/code&gt; 반환은 실행이 가장 안쪽에있는 &lt;code&gt;catch&lt;/code&gt; 로 분기 하거나 함수에서 반환 해야 함을 의미 합니다. &lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6233fb9390747dc2f23a28899738d6cc6a72590f" translate="yes" xml:space="preserve">
          <source>Applying the attribute to a function &lt;code&gt;f&lt;/code&gt; allows code within &lt;code&gt;f&lt;/code&gt; to get a hint of the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the &quot;topmost&quot; tracked call that led to &lt;code&gt;f&lt;/code&gt;'s invocation. At the point of observation, an implementation behaves as if it walks up the stack from &lt;code&gt;f&lt;/code&gt;'s frame to find the nearest frame of an &lt;em&gt;unattributed&lt;/em&gt; function &lt;code&gt;outer&lt;/code&gt;, and it returns the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the tracked call in &lt;code&gt;outer&lt;/code&gt;.</source>
          <target state="translated">함수에 속성을 적용 &lt;code&gt;f&lt;/code&gt; 내 코드 수 &lt;code&gt;f&lt;/code&gt; 는 의 힌트를 얻을 &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 에지도하는 &quot;맨 위의&quot;추적 호출의 &lt;code&gt;f&lt;/code&gt; 의 호출을. 관찰의 시점에서 구현 동작합니다 그것은로부터 스택 걸어 것처럼 &lt;code&gt;f&lt;/code&gt; 의 가장 가까운 프레임 찾을 수의 프레임을 &lt;em&gt;기여하지&lt;/em&gt; 기능의 &lt;code&gt;outer&lt;/code&gt; 하고는 반환 &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 의 추적 전화의 &lt;code&gt;outer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8404e9317204d7715d2f49a56717841155af3a5d" translate="yes" xml:space="preserve">
          <source>Approximate desugaring</source>
          <target state="translated">대략적인 탈당</target>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">기수 10의 대략적인 유효 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="741aa1a23115e831e460da0298845488131bda9a" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f32::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">10 진수의 대략적인 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f32::DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8912ed7e59aeef6ce8c4355dd3b80515ddbd4f1" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f64::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">10 진수의 대략적인 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f64::DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">아르키메데스 상수 (&amp;pi;)</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">널이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">불변 및 가변 포인터 또는 동일한 위치에 대한 다중 가변 포인터를 사용하여 차용 규칙을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">유효한 메모리를 가리킬 수는 없습니다</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">인수와 요소 구분자</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">함수 호출에 대한 인수</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; 에 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수 &lt;code&gt;or&lt;/code&gt; 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수가 전달 &lt;code&gt;or&lt;/code&gt; 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수가 전달 &lt;code&gt;or&lt;/code&gt; 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열성적으로 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">산술 덧셈</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">산술 덧셈과 대입</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">산술 및 논리 이진 연산자</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">정수의 산술 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">산술 부서</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">산술 나누기와 할당</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">산술 곱셈</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">산술 곱셈과 대입</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">산술 부정</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">산술 나머지</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">산술 나머지 및 할당</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">산술 빼기</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">산술 빼기와 대입</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Arity는 함수 또는 연산자가 취하는 인수 수를 나타냅니다. 일부 예에서, &lt;code&gt;f(2, 3)&lt;/code&gt; 및 &lt;code&gt;g(4, 6)&lt;/code&gt; 은 arity 2를 갖는 반면 &lt;code&gt;h(8, 2, 6)&lt;/code&gt; 은 arity 3을 갖습니다. &lt;code&gt;!&lt;/code&gt; 연산자는 arity 1이 있습니다</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">배열 레이아웃</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">배열 및 배열 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">배열 및 슬라이스 인덱싱 표현식</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">배열 표현식 속성</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">배열 표현식</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 &lt;code&gt;len&lt;/code&gt; 사본을 포함하는 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">반복 구문이있는 배열 리터럴. 여기서 배열의 유형은 &lt;code&gt;[U; n]&lt;/code&gt; . 반복 된 하위-발현은 유형 &lt;code&gt;U&lt;/code&gt; 에 대한 강제에 대한 강제 사이트 이다.</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">배열이 &lt;code&gt;[U; n]&lt;/code&gt; . 배열 리터럴의 각 하위 표현식은 &lt;code&gt;U&lt;/code&gt; 형을 강제로 변환하는 강제 사이트입니다 .</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="translated">배열 반복 길이 표현식</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">포인터 캐스트에 대한 배열</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">유형의 &lt;code&gt;len&lt;/code&gt; 인스턴스를 포함하는 배열 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">배열 유형 길이 표현식</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Clone&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">배열의 &lt;code&gt;nth&lt;/code&gt; 요소가 배열의 시작에서 &lt;code&gt;n * the size of the type&lt;/code&gt; 바이트 의 크기 만큼 오프셋 되도록 배열이 배치됩니다 . 배열 &lt;code&gt;[T; n]&lt;/code&gt; 의 크기를 갖는 &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; 과 동일한 배향 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">배열은 힙이 아닌 스택에 데이터를 할당하려는 경우 (4 장에서 스택 및 힙에 대해 자세히 설명 할 것임) 또는 항상 고정 된 수의 요소가 있는지 확인하려는 경우에 유용합니다. 그러나 배열은 벡터 유형만큼 유연하지 않습니다. 벡터는 표준 라이브러리에서 제공하는 유사한 수집 유형 &lt;em&gt;입니다&lt;/em&gt; 성장 또는 크기 축소 할 수있었습니다. 배열을 사용할지 벡터를 사용할지 확실하지 않으면 벡터를 사용해야합니다. 8 장에서는 벡터에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">배열은 &lt;a href=&quot;primitive.slice&quot;&gt;슬라이스 ( &lt;code&gt;[T]&lt;/code&gt; )로&lt;/a&gt; 강제 변환 되므로 슬라이스에서 슬라이스 메소드를 호출 할 수 있습니다. 실제로 이것은 배열 작업을위한 대부분의 API를 제공합니다. 슬라이스는 동적 크기를 가지며 배열로 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">의 배열 &lt;em&gt;어떤&lt;/em&gt; 크기는 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성이 컴파일러에 특별히 알려져 있기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 크기의 배열은 요소 유형이 허용하는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">0에서 32 (포함) 사이의 크기 배열은 요소 유형이 허용하는 경우 &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 특성을 구현 합니다. 임시 방편으로 트레이 트 구현은 최대 크기 32까지 정적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4f9eb669ece946f30cfd95add30aac8bad032e42" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">0에서 32 (포함) 크기의 배열은 요소 유형이 허용하는 경우 &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 특성을 구현 합니다. 임시 방편으로 트레이 트 구현은 최대 크기 32까지 정적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">0에서 32까지의 크기의 배열 (포함)은 요소 유형이 허용하는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;if&lt;/code&gt; 표현에 자신의 패턴 매칭 변형이 &lt;code&gt;if let&lt;/code&gt; , 이렇게도 할 &lt;code&gt;while&lt;/code&gt; 으로 표현 &lt;code&gt;while let&lt;/code&gt; . &lt;code&gt;while let&lt;/code&gt; 표현은 다음 식에 대한 패턴과 일치하는 패턴 매칭이 성공하면 루프 본문을 실행하거나 루프를 종료합니다. &lt;code&gt;break&lt;/code&gt; 와 &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; 표현식을 &lt;code&gt;while&lt;/code&gt; 처럼 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">IANA가 새 주소를 할당하면이 방법이 업데이트됩니다. 이로 인해 예약되지 않은 주소가이 방법의 오래된 버전에 의존하는 코드에서 예약 된 것으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="translated">Rust는 포함 된 모든 필드의 소멸자를 자동으로 호출하므로 대부분의 경우 &lt;code&gt;Drop&lt;/code&gt; 을 구현할 필요가 없습니다 . 그러나 리소스를 직접 관리하는 유형과 같이 유용한 경우가 있습니다. 그 리소스는 메모리, 파일 디스크립터, 네트워크 소켓 일 수 있습니다. 해당 유형의 값이 더 이상 사용되지 않으면 메모리를 해제하거나 파일 또는 소켓을 닫아 리소스를 &quot;정리&quot;해야합니다. 이것은 소멸자의 작업이므로 &lt;code&gt;Drop::drop&lt;/code&gt; 의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 동반자 로서이 특성은 유형이 변경 가능한 참조를 제공하여 기본 유형으로 빌릴 수 있도록합니다. 다른 유형으로 대출에 대한 자세한 내용 은 &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">결과로서, 만약 해시 맵 나누기 &lt;code&gt;K&lt;/code&gt; 랩핑 &lt;code&gt;Q&lt;/code&gt; 의 값은 상이한 해시 생성 &lt;code&gt;Q&lt;/code&gt; 를 . 예를 들어, 문자열을 감싸지 만 대소 문자를 무시하고 ASCII 문자를 비교하는 유형이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">데이터 수집으로서 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 키와 값을 모두 소유합니다. 그러나 키의 실제 데이터가 일종의 관리 유형으로 래핑 된 경우 키 데이터에 대한 참조를 사용하여 값을 검색 할 수 있어야합니다. 예를 들어, 키가 문자열 인 경우 해시 맵과 함께 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 으로 저장 될 가능성이 높으며 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 사용하여 검색 할 수 있습니다 . 따라서 &lt;code&gt;insert&lt;/code&gt; 는 &lt;code&gt;String&lt;/code&gt; 에서 작동해야 하지만 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 을 사용할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">소유권의 첫 번째 예로, 일부 변수 의 &lt;em&gt;범위&lt;/em&gt; 를 살펴 보겠습니다 . 범위는 항목이 유효한 프로그램 내의 범위입니다. 다음과 같은 변수가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ec757385247cd107e43eba2a3f4a658f211a87a6" translate="yes" xml:space="preserve">
          <source>As a hack to work around this, we use two separate traits injected by each of the two derives (&lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; and &lt;code&gt;#[derive(Eq)]&lt;/code&gt;) and check that both of them are present as part of structural-match checking.</source>
          <target state="translated">이 문제를 해결하기위한 해킹으로, 두 &lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; ( # [derive (PartialEq)] 및 &lt;code&gt;#[derive(Eq)]&lt;/code&gt; ) 각각에 의해 주입 된 두 개의 개별 특성을 사용 하고 둘 다 구조의 일부로 존재하는지 확인합니다. 일치 확인.</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">언어로서 Rust는 &lt;em&gt; 많은&lt;/em&gt; 코드의 안정성에 대한합니다. 우리는 Rust이 여러분이 지을 수있는 견고한 기반이되기를 원하며, 끊임없이 변화하고 있다면 불가능할 것입니다. 동시에, 새로운 기능을 시험해 볼 수 없다면, 출시 이후까지, 더 이상 변경할 수없는 중요한 결함을 찾지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">라이브러리 작성자 는 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; 이&lt;/a&gt; 더 큰 유연성을 제공하고 동등한 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; 구현을 무료로 제공하므로 항상 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 구현을 선호해야 합니다. 표준 라이브러리에서 담요 구현. 현재 상자 이외의 유형으로 변환해야 할 경우 에만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="translated">도서관 저자로서, 당신은 항상 구현을 선호한다 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 보다는 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; 더 큰 유연성을 제공하며 동등한 제공하는 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; 무료로 구현, 덕분에 표준 라이브러리의 포괄적 구현. Rust 1.41 이전 버전을 대상 으로 할 때 현재 상자 외부의 유형으로 변환 할 때 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 직접 구현해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">더 간결한 대안으로 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하고 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다 . &lt;code&gt;for&lt;/code&gt; 목록 3-5의 코드와 같은 루프 보인다.</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">이 코드의 결과로 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;lol&lt;/code&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">결과적으로이 메서드는 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 과 같은 주소 를 유니 캐스트 링크 로컬 주소로 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 하지만 Ipv6Addr :: is_unicast_link_local_strict () 는 그렇지 않습니다. RFC를 완전히 준수하는 엄격한 유효성 검사가 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과적으로이 방법은 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 와 같은 주소 를 유니 캐스트 링크 로컬 주소로 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 하지만 is_unicast_link_local_strict () 는 그렇지 않습니다. RFC를 완전히 준수하는 엄격한 유효성 검증이 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 일련의 바이트로 구성되므로 문자열 슬라이스를 바이트 단위로 반복 할 수 있습니다. 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 반복자 와 해당 바이트 위치 를 모두 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 반복자 와 해당 바이트 위치 를 모두 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">항상 그렇듯이 '문자'에 대한 인간의 직감은 유니 코드의 정의에 매핑되지 않을 수 있습니다. 예를 들어, 비슷한 모양에도 불구하고 '&amp;eacute;'문자는 하나의 유니 코드 코드 포인트이고 '&amp;eacute;'는 두 개의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">언제나처럼 중괄호를 사용하여 새 범위를 만들어 &lt;em&gt;동시&lt;/em&gt; 참조가 아닌 여러 개의 가변 참조를 허용 할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">뮤텍스를 사용하는 방법의 예로써, Listing 16-12와 같이 단일 스레드 컨텍스트에서 뮤텍스를 사용하여 시작해 보자.</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">특성에 대한 방법의 예로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">인라인으로 정의 된 클로저 또는 명명 된 함수를 사용할 수있는 위치의 예로 &lt;code&gt;map&lt;/code&gt; 사용을 살펴 보겠습니다 . &lt;code&gt;map&lt;/code&gt; 함수 를 사용하여 숫자 벡터를 문자열 벡터로 바꾸려면 다음과 같이 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">예를 들어, 목록 11-10에는 매개 변수의 값을 인쇄하고 10을 반환하는 바보 함수와 통과 테스트 및 실패 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">예를 들어, &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 와 같은 매크로 매처 는 이론적으로 Rust에서 받아 들일 수 있습니다. &lt;code&gt;[,]&lt;/code&gt; 는 합법적 인 표현의 일부가 될 수 없기 때문에 구문 분석은 항상 모호하지 않습니다. 때문에, &lt;code&gt;[&lt;/code&gt; 이 표현을 후행 시작할 수 있습니다, &lt;code&gt;[&lt;/code&gt; 안전 식 후에 들어오는 배제 할 수있는 문자가 아닙니다. 경우 &lt;code&gt;[,]&lt;/code&gt; 녹 이후 버전에서 사용 가능하고,이 정규 모호한 될 것 또는 작동 코드를 깨는, misparse 것입니다. &lt;code&gt;$i:expr,&lt;/code&gt; 또는 &lt;code&gt;$i:expr;&lt;/code&gt; 과 같은 매처 ; 법적 것이다, 그러나 때문에 &lt;code&gt;,&lt;/code&gt; 그리고 &lt;code&gt;;&lt;/code&gt; 합법적 인 구분 기호입니다. 구체적인 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">예를 들어, &lt;em&gt;loops&lt;/em&gt; 디렉토리 에서 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 다음과 같이 변경하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">예를 들어, 열거 형 변형 중 하나를 변경하여 내부에 데이터를 보유합시다. 1999 년부터 2008 년까지 미국은 한쪽에 50 개 주마다 각기 다른 디자인으로 분기를 기록했습니다. 다른 동전은 국가 디자인을 얻지 못 했으므로 1/4만이 추가 가치를 갖습니다. 우리는 &lt;code&gt;Quarter&lt;/code&gt; 변형을 수정하여 &lt;code&gt;UsState&lt;/code&gt; 안에 저장된 UsState 값 을 포함 시킴으로써이 정보를 &lt;code&gt;enum&lt;/code&gt; 에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">예를 들어, &lt;code&gt;Display&lt;/code&gt; 특성과 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 상자 외부에 정의되어 있기 때문에 고아 규칙으로 인해 직접 수행 할 수없는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Display&lt;/code&gt; 를 구현하려고한다고 가정하겠습니다 . &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스를 보유하는 &lt;code&gt;Wrapper&lt;/code&gt; 구조체를 만들 수 있습니다 . 그런 다음 &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; 를 구현 하고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 값을 사용할 수 있습니다 ( Listing 19-23).</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">예를 들어 식당의 기능을 제공하는 라이브러리 상자를 작성해 봅시다. 함수의 시그니처를 정의하지만 실제로 코드로 레스토랑을 구현하는 대신 코드 구성에 집중하기 위해 본문을 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">예를 들어 다음 항목에 대해서만 항목을 알고있는 목록을 사용하는 대신 하위 항목 &lt;em&gt;과&lt;/em&gt; 부모 항목에 대해 항목을 알고있는 트리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 16 장의 &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 특성 과의 확장 성 동시성 &quot; 섹션에서 논의한 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 마커 특성을 기억하십시오 . 유형이 전체적으로 &lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 유형 으로 구성된 경우 컴파일러는 이러한 특성을 자동으로 구현 합니다. 원시 포인터와 같이 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 가 아닌 유형을 포함하는 유형을 구현하고 해당 유형을 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 로 표시 하려면 &lt;code&gt;unsafe&lt;/code&gt; 것을 사용해야합니다. Rust는 우리 유형이 스레드간에 안전하게 전송되거나 여러 스레드에서 액세스 될 수 있음을 보증하는지 확인할 수 없습니다. 따라서 이러한 검사를 수동으로 수행하고 &lt;code&gt;unsafe&lt;/code&gt; 로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">예를 들어, 전달 된 숫자에 2를 더하는 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성한다고 가정 하십시오. 이 함수의 서명은 정수를 매개 변수로 승인하고 결과로 정수를 리턴합니다. 해당 함수를 구현하고 컴파일 할 때 Rust는 예를 들어이 함수에 대한 &lt;code&gt;String&lt;/code&gt; 값이나 잘못된 참조를 전달하지 않도록하기 위해 지금까지 배운 모든 유형 검사 및 대출 검사를 수행합니다. 그러나 Rust &lt;em&gt;는&lt;/em&gt; 이 함수가 우리가 의도 한대로 정확하게 수행하는지 확인할 &lt;em&gt;수 없습니다&lt;/em&gt; . 즉, 매개 변수 더하기 10 또는 매개 변수 빼기 50 대신 매개 변수 더하기 2를 반환합니다! 그곳에서 테스트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">반복자로서 :</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">또 다른 예로, &lt;code&gt;Maker&lt;/code&gt; 특성이 있고 &lt;code&gt;Foo&lt;/code&gt; 를 만드는 &lt;code&gt;FooMaker&lt;/code&gt; 유형을 설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">다른 예로서, 다음 코드는 오디오 디코더로부터 취해진 다. 디코딩 알고리즘은 선형 예측 수학 연산을 사용하여 이전 샘플의 선형 함수에 기초하여 미래 값을 추정한다. 이 코드는 반복자 체인을 사용하여 데이터 의 &lt;code&gt;buffer&lt;/code&gt; 슬라이스, 12 개의 &lt;code&gt;coefficients&lt;/code&gt; 배열 및 &lt;code&gt;qlp_shift&lt;/code&gt; 에서 데이터를 이동시키는 양의 세 가지 변수에 대해 수학을 수행 합니다. 이 예제에서 변수를 선언했지만 값을 지정하지 않았습니다. 이 코드는 컨텍스트 외부에서 별 의미가 없지만 Rust가 높은 수준의 아이디어를 낮은 수준의 코드로 변환하는 방법에 대한 간결하고 실제적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="translated">아래에서 볼 수 있듯이 &lt;code&gt;else&lt;/code&gt; 뒤에는 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;if let&lt;/code&gt; 또는 블록 &lt;code&gt;{}&lt;/code&gt; 이 와야하며 해당 표현식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">설명한대로 &lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">설명한대로 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">10 장에서 논의한 것처럼 특성을 구현하려면 특성의 필수 메소드에 대한 구현을 제공해야합니다. &lt;code&gt;Deref&lt;/code&gt; 특성, 표준 라이브러리에서 제공하는이라는 하나의 방법 구현하기 위해 우리를 필요로 &lt;code&gt;deref&lt;/code&gt; 그 차용의 &lt;code&gt;self&lt;/code&gt; 반환 내부 데이터에 대한 참조를. Listing 15-10에는 &lt;code&gt;MyBox&lt;/code&gt; 정의에 추가하기위한 &lt;code&gt;Deref&lt;/code&gt; 구현이 포함되어있다 .</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">17 장에서 논의한 것처럼 &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;take&lt;/code&gt; 메소드 는 &lt;code&gt;Some&lt;/code&gt; 변형을 제거하고 대신 &lt;code&gt;None&lt;/code&gt; 을 남겨 둡니다 . 우리가 사용하고있는 &lt;code&gt;if let&lt;/code&gt; destructure하기 위해 &lt;code&gt;Some&lt;/code&gt; 및 스레드를 얻을; 그런 다음 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 합니다. 워커의 스레드가 이미 &lt;code&gt;None&lt;/code&gt; 이면 워커가 이미 스레드를 정리했음을 알 수 있으므로이 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">6 장에서 논의한 바와 같이, 우리는 &lt;code&gt;match&lt;/code&gt; 표현에 패턴을 사용 합니다. 공식적으로 &lt;code&gt;match&lt;/code&gt; 표현식은 키워드 &lt;code&gt;match&lt;/code&gt; , 일치 할 값 및 패턴으로 구성된 하나 이상의 일치 암 및 값이 해당 팔의 패턴과 일치하는 경우 실행할 식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">배후에서 일어나는 일에 대해 최적화가 활성화되면 최종 생성 된 기계 코드가 코드와 매우 다르게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">함수로서, 구문, 패닉 또는 루프를 끝없이 리턴해야합니다. 반환 된 구문은 절차 적 매크로의 종류에 따라 구문을 대체하거나 추가합니다. 패닉은 컴파일러에 의해 포착되어 컴파일러 오류로 바뀝니다. 컴파일러를 중단시키는 컴파일러는 무한 루프를 포착하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">인간으로서 우리는이 코드를보고 &lt;code&gt;string1&lt;/code&gt; 이 &lt;code&gt;string2&lt;/code&gt; 보다 길 므로 &lt;code&gt;result&lt;/code&gt; 에 &lt;code&gt;string1&lt;/code&gt; 에 대한 참조가 포함된다는 것을 알 수 있습니다 . 때문에 &lt;code&gt;string1&lt;/code&gt; 아직 범위 밖으로 사라하지 않았에 대한 참조 &lt;code&gt;string1&lt;/code&gt; 여전히 유효합니다 &lt;code&gt;println!&lt;/code&gt; 성명서. 그러나 컴파일러는이 경우 참조가 유효한지 확인할 수 없습니다. 우리는 Rust에게 &lt;code&gt;longest&lt;/code&gt; 함수에 의해 리턴 된 참조 의 수명은 전달 된 참조의 수명보다 작은 것과 동일 하다고 이야기 했다. 따라서 빌림 검사기는 Listing 10-24의 코드가 유효하지 않은 참조를 갖는 것을 허용하지 않는다 .</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">대부분의 다른 프로그래밍 언어와 마찬가지로 Rust의 부울 형식에는 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 의 두 가지 가능한 값이 있습니다. 부울의 크기는 1 바이트입니다. Rust의 부울 유형은 &lt;code&gt;bool&lt;/code&gt; 을 사용하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; 표현식&lt;/a&gt; 의 경우처럼 스크 루틴은 &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;지연 부울 연산자 표현식이&lt;/a&gt; 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">그것이 나오는 것에 따라,하지만, 대부분의 특성은 가질 수 &lt;code&gt;impl&lt;/code&gt; 를 들어 &lt;code&gt;!&lt;/code&gt; . 예를 들어 &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">명령 줄 구문 분석 논리가 작 으면 &lt;em&gt;main.rs에&lt;/em&gt; 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">이 장의 시작 부분에서 언급했듯이 테스트는 복잡한 학문이며 다른 사람들은 다른 용어와 조직을 사용합니다. Rust 커뮤니티는 두 가지 주요 범주 인 &lt;em&gt;단위 테스트&lt;/em&gt; 와 &lt;em&gt;통합 테스트&lt;/em&gt; 측면에서 테스트에 대해 생각 &lt;em&gt;합니다&lt;/em&gt; . 단위 테스트는 작고 집중적이며 한 번에 하나의 모듈을 개별적으로 테스트하며 개인 인터페이스를 테스트 할 수 있습니다. 통합 테스트는 전적으로 라이브러리 외부에 있으며 공용 인터페이스 만 사용하고 테스트 당 여러 모듈을 사용하는 다른 외부 코드와 같은 방식으로 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">앞에서 언급했듯이 특성 오브젝트에는 메소드 테이블에 대한 포인터가 포함되어 있습니다. 우리가 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;read_line&lt;/code&gt; 은 사용자가 입력 한 내용을 전달하는 문자열에 넣지 만 값 (이 경우 &lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 반환합니다 . 녹 명명 된 유형의 수 있습니다 &lt;code&gt;Result&lt;/code&gt; 일반 : 표준 라이브러리의 &lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 다음과 같은 하위 모듈에 대한 특정 버전, &lt;code&gt;io::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">앞에서 언급했듯이 Rust가 동시성을 처리하는 방법은 거의 없기 때문에 많은 동시성 솔루션이 상자로 구현됩니다. 이들은 표준 라이브러리보다 더 빠르게 발전하므로 멀티 스레드 상황에서 사용할 최신의 최신 상자를 온라인으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">2 장에서 언급했듯이 기본적으로 변수는 변경할 수 없습니다. 이것은 Rust가 제공하는 안전하고 쉬운 동시성을 활용하는 방식으로 코드를 작성하기 위해 Rust가 제공하는 많은 넛지 중 하나입니다. 그러나 변수를 변경할 수있는 옵션이 여전히 있습니다. Rust가 불변성을 선호하는 방법과 이유, 왜 선택하지 않는지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">모듈 문서에서 언급했듯이 스레드는 일반적으로 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; 사용하여 통신하기 위해 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">비 녹음 호출 규칙은 해제를 지원하지 않으므로 extern 함수 끝을 지나서 해제하면 프로세스가 중단됩니다. LLVM에서는 잘못된 명령을 실행하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">위에서 언급했듯이 강제는 대부분의 코드가이 구별에 관심을 가질 필요가 없음을 의미합니다. 그러나 &lt;strong&gt;변환식&lt;/strong&gt; 을 사용하여 fn 항목을 fn 포인터로 변환 할 때 차이점을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="translated">유형 자체에 대한 문서에서 언급했듯이 본질적으로 불투명 한 ID이지만 각 스레드에 대해 고유하다는 것이 보장됩니다. 반환 된 값은 완전히 불투명하며 동등성 테스트 만 안정적입니다. 새 스레드가 어떤 값을 반환할지 보장 할 수 없으며 이는 Rust 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">예상대로 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 와 같은 기본 유형 은 모두 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 이며 튜플, 구조체 및 열거 형과 같이이를 포함하는 간단한 집계 유형도 마찬가지입니다. 기본 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 유형 의 더 많은 예 에는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 같은 &quot;불변&quot;유형과 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 대부분의 다른 컬렉션 유형 과 같이 단순 상속 된 변경 가능성이있는 유형이 포함됩니다. ( 컨테이너 가 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 가 되려면 일반 매개 변수가 Sync 여야 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">예상대로 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 와 같은 기본 유형 은 모두 &lt;code&gt;Sync&lt;/code&gt; 이므로 튜플, 구조체 및 열거 형과 같은 유형을 포함하는 간단한 집계 유형입니다. 기본 &lt;code&gt;Sync&lt;/code&gt; 유형 의 더 많은 예 에는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 같은 &quot;불변&quot;유형과 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 대부분의 다른 콜렉션 유형 과 같이 단순하게 상속 된 변경이 가능한 유형이 있습니다. 컨테이너 가 &lt;code&gt;Sync&lt;/code&gt; 가되도록하려면 일반 매개 변수가 Sync 이어야 &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">당으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt; , 전체 &lt;code&gt;FEC0::/10&lt;/code&gt; 접두사는 사용되지 않습니다. 새 소프트웨어는 사이트 로컬 주소를 지원하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;derive&lt;/code&gt; 속성은 구조체, 공용체 또는 열거 형에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;code&gt;for&lt;/code&gt; 루프 (다른 모든 루프와 함께)는 수명과 유사한 구문을 사용하여 태그를 지정할 수 있습니다 (시각적으로는 시각적으로 유사하며 실제로는 완전히 다릅니다). 동일한 태그를 &lt;code&gt;break&lt;/code&gt; 태그가 지정된 루프 가 끊어 지므로 내부 루프에 유용합니다. 확실히 goto가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="translated">슬라이스는 참조하는 시퀀스의 길이를 저장하므로 &lt;a href=&quot;marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 유형 에 대한 포인터 크기의 두 배를 갖습니다 . &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;동적 크기 유형&lt;/a&gt; 에 대한 참조도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt; 의 사용자 데이터 그램 프로토콜 사양에 명시된 바와 같이 UDP는 순서가없고 신뢰할 수없는 프로토콜입니다. TCP 프리미티브에 대해서는 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">문자열 조각은 바이트 조각이므로 원시 포인터는 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다 . 이 포인터는 문자열 슬라이스의 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">문자열 슬라이스가 바이트 슬라이스이므로 원시 포인터는 &lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다 . 이 포인터는 문자열 슬라이스의 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">따라서 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;from_utf8&lt;/code&gt; 함수 및 메소드 계열은 예를 들어이 오류를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">데이터 구조의 작성자는 각 필드에 대해 고정이이 필드에 &quot;전파&quot;되는지 여부를 결정하게됩니다. 전파되는 고정은 유형의 구조를 따르기 때문에 &quot;구조적&quot;이라고도합니다. 다음 하위 섹션에서는 두 가지 선택을 위해 고려해야 할 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">오류 메시지에서 알 수 있듯이 &lt;code&gt;u8&lt;/code&gt; 만 &lt;code&gt;char&lt;/code&gt; 로 캐스트 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용됨에 따라 이식 가능한 코드는 대신 &lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt; 를 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용되므로 이식 가능한 코드는 대신 &lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">이것이이 특성에 대한 유일한 방법이므로 &lt;a href=&quot;trait.extend&quot;&gt;특성 수준&lt;/a&gt; 문서에는 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">이것이이 특성에 필요한 유일한 방법이므로 &lt;a href=&quot;trait.extend&quot;&gt;특성 수준&lt;/a&gt; 문서에 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">평소와 같이,이 결과는 무엇이 잘못되었는지 정확하게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">구조체와 마찬가지로 일반적인 데이터 형식을 변형으로 보유하도록 열거 형을 정의 할 수 있습니다. 6 장에서 사용한 표준 라이브러리가 제공 하는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 형에 대해 다시 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">벡터를 인쇄 할 때 보았 듯이 프로그램 이름은 &lt;code&gt;args[0]&lt;/code&gt; 의 벡터에서 첫 번째 값을 차지 하므로 인덱스 &lt;code&gt;1&lt;/code&gt; 에서 시작 합니다. &lt;code&gt;minigrep&lt;/code&gt; 이받는 첫 번째 인수 는 검색하는 문자열이므로 변수 &lt;code&gt;query&lt;/code&gt; 의 첫 번째 인수에 대한 참조를 넣습니다 . 두 번째 인수는 파일 이름이되므로 변수 &lt;code&gt;filename&lt;/code&gt; 에 두 번째 인수에 대한 참조를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">단항 &lt;code&gt;*&lt;/code&gt; 연산자에 과부하가 걸리는 것 &lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;expressions/method-call-expr&quot;&gt;메소드 해석&lt;/a&gt; 및 &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref 강제&lt;/a&gt; 에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt; 가 반환 된 포인터의 유효성을 검증 할 수 없으며이 수명 보장 할 수 있기 때문에, 이것은 안전하지 않은 &lt;code&gt;'a&lt;/code&gt; 반환이 실제로 포함 된 데이터의 유효 수명이다.</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 내부 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;밑줄 가져 오기&lt;/a&gt; 와 마찬가지로 매크로는 동일한 범위에서 동일한 명명되지 않은 상수를 두 번 이상 안전하게 방출 할 수 있습니다. 예를 들어, 다음은 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">와 같은 &lt;code&gt;let&lt;/code&gt; 바인딩 함수 인수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴&lt;/a&gt; 이므로 let 바인딩에 유효한 모든 패턴도 인수로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">&lt;code&gt;split()&lt;/code&gt; 과 마찬가지로 첫 번째 또는 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 첫 번째 (또는 마지막) 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">변수와 마찬가지로 값을 변경하려면 3 장에서 설명한대로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변수를 변경 가능하게 만들어야합니다. &lt;code&gt;i32&lt;/code&gt; 이며 Rust는 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 주석이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">많은 종류와 마찬가지로, 우리는 만들 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 관련 기능을 사용하여 &lt;code&gt;new&lt;/code&gt; . 뮤텍스 내부의 데이터에 액세스하기 위해 &lt;code&gt;lock&lt;/code&gt; 메소드를 사용하여 잠금 을 획득합니다. 이 호출은 현재 스레드를 차단하므로 잠금을 설정해야 할 때까지 아무 작업도 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">일반 변수와 마찬가지로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변경 가능성을 지정 합니다. &lt;code&gt;COUNTER&lt;/code&gt; 에서 읽거나 쓰는 코드 는 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에 있어야합니다 . 이 코드는 &lt;code&gt;COUNTER: 3&lt;/code&gt; 컴파일하고 인쇄합니다 . 는 단일 스레드이기 때문에 을 . 여러 스레드가 &lt;code&gt;COUNTER&lt;/code&gt; 에 액세스 하면 데이터 경쟁이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8272d2e249bc06a5d6f6ca737f5c0ac8a4d70c5" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. 이것은 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 달성 할 수 있습니다 . 이를 직접 구현하는 경우 다음 속성이 유지되는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. 이는 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 달성 할 수 있습니다 . 이를 직접 구현하는 경우 다음 속성이 유지되는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="484bca70aea1a557734e7bf929079e6ee00fa7d3" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. 이것은 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 달성 할 수 있습니다 . 이를 직접 구현하는 경우 다음 속성이 유지되는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">변수와 마찬가지로 엄격하게 필요한 것보다 더 장황한 비용으로 명시 성과 선명도를 높이려면 유형 주석을 추가 할 수 있습니다. Listing 13-5에서 정의한 클로저의 타입에 주석을 달면 Listing 13-7에 나온 정의와 같다.</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">더 많은 통합 테스트를 추가 할 때 &lt;em&gt;tests&lt;/em&gt; 디렉토리 에 둘 이상의 파일을 만들어 구성하는 데 도움이 될 수 있습니다. 예를 들어 테스트중인 기능별로 테스트 기능을 그룹화 할 수 있습니다. 앞에서 언급했듯이 &lt;em&gt;테스트의&lt;/em&gt; 각 파일&lt;em&gt;&lt;/em&gt; 디렉토리의 별도의 상자로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">1 장에서도 배웠 듯이 &lt;code&gt;println!&lt;/code&gt; 화면에 문자열을 인쇄하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">당신의 서명에서 볼 수 있듯이 &lt;code&gt;spawn&lt;/code&gt; 에 주어진 폐쇄 양쪽에 두 제약이 있습니다 &lt;code&gt;spawn&lt;/code&gt; 및 반환 값은,의 그들을 설명 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">보시다시피 안정적인 툴체인이 기본값입니다. 대부분의 Rust 사용자는 대부분 안정적인 시간을 사용합니다. 최첨단 기능을 염두에두고 대부분의 시간을 안정적으로 사용하고 싶지만 특정 프로젝트에서 야간에 사용하는 것이 좋습니다. 그렇게하려면 &lt;code&gt;rustup override&lt;/code&gt; 해당 프로젝트 디렉토리에서 rustup override 를 하여 야간 툴체인을 하나의 &lt;code&gt;rustup&lt;/code&gt; 으로 설정할 수 있습니다. 사용하여 해당 디렉토리에있을 때 이 사용해야 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">보시다시피 예상 유효 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">보시다시피 부모 모듈을 사용하면 두 가지 &lt;code&gt;Result&lt;/code&gt; 유형이 구분 됩니다. 대신 &lt;code&gt;use std::fmt::Result&lt;/code&gt; 를 &lt;code&gt;use std::io::Result&lt;/code&gt; 하면 두 개가됩니다 &lt;code&gt;Result&lt;/code&gt; 하면 동일한 범위에 Result 유형이 있고 Rust는 &lt;code&gt;Result&lt;/code&gt; 를 사용할 때 어떤 결과 유형을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">보시다시피, 우리는 추측 입력 프롬프트에서 모든 것을 루프로 옮겼습니다. 루프 내부의 라인을 각각 다른 4 칸씩 들여 쓰기하고 프로그램을 다시 실행하십시오. 프로그램이 우리가 지시 한대로 정확하게 수행하고 있기 때문에 새로운 문제가 있음을 주목하십시오 : 또 다른 추측을 영원히 요청하십시오! 사용자가 종료 할 수없는 것 같습니다!</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">보시다시피, 주어진 상황에서 실제 형식으로 대체하기 위해 중괄호로 형식 매개 변수를 지정할 수 있습니다 (일반 형식 문자열 구문 사용). 또한 &lt;code&gt;{Self}&lt;/code&gt; 는 유형을 대신합니다 (이 경우 &lt;code&gt;bool&lt;/code&gt; 사용하려고 시도한 bool )을 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">보시다시피, 많은 측면에서 (레이아웃, 안전 및 소유권 제외) 노조는 구조체에서 구문 형태를 상속 한 결과 구조체와 똑같이 동작합니다. 이는 Rust 언어의 언급되지 않은 많은 측면 (예 : 프라이버시, 이름 확인, 형식 유추, 제네릭, 특성 구현, 고유 구현, 일관성, 패턴 확인 등)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">보시다시피, 많은 측면에서 (레이아웃, 안전성 및 소유권 제외) 공용체는 구조체에서 구문 모양을 상속 한 결과 구조체와 똑같이 작동합니다. 이것은 또한 Rust 언어의 언급되지 않은 여러 측면 (프라이버시, 이름 확인, 유형 추론, 제네릭, 특성 구현, 고유 구현, 일관성, 패턴 검사 등)에도 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">16 장에서 배운 것처럼 &lt;code&gt;thread::spawn&lt;/code&gt; 은 새 스레드를 생성 한 다음 새 스레드의 클로저에서 코드를 실행합니다. 이 코드 및로드 실행하면 &lt;em&gt;/ 절전&lt;/em&gt; 브라우저에서를 다음 &lt;em&gt;/&lt;/em&gt; 두 개 더 브라우저 탭, 당신은 참으로 요청 것을 볼 수 있습니다 &lt;em&gt;/이&lt;/em&gt; 기다릴 필요가 없습니다&lt;em&gt; / 절전&lt;/em&gt; 마무리. 그러나 우리가 언급했듯이, 제한없이 새로운 스레드를 만들 수 있기 때문에 결국 시스템을 압도합니다.</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">당신이 짐작할 수 있듯이 &lt;code&gt;continue&lt;/code&gt; 하십시오 &lt;code&gt;!&lt;/code&gt; 값. 즉, Rust가 &lt;code&gt;guess&lt;/code&gt; 유형을 계산할 때 일치 팔은 &lt;code&gt;u32&lt;/code&gt; 값이고 다른 하나는 &lt;code&gt;!&lt;/code&gt; 값. 왜냐하면 &lt;code&gt;!&lt;/code&gt; Rust는 &lt;code&gt;guess&lt;/code&gt; 의 유형 이 &lt;code&gt;u32&lt;/code&gt; 라고 결정합니다. .</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">의심 할 수 있듯이 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 스마트 포인터입니다. 더 정확하게, 호출 &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;반환&lt;/em&gt; 라는 스마트 포인터 &lt;code&gt;MutexGuard&lt;/code&gt; A의 포장, &lt;code&gt;LockResult&lt;/code&gt; 우리를 호출하여 처리하는 것을 &lt;code&gt;unwrap&lt;/code&gt; . &lt;code&gt;MutexGuard&lt;/code&gt; 스마트 포인터 구현 &lt;code&gt;Deref&lt;/code&gt; 우리의 내면 데이터에서 포인트; 스마트 포인터에는 또한 범위를 벗어날 때 자동으로 잠금을 해제 하는 &lt;code&gt;Drop&lt;/code&gt; 구현이 있습니다. &lt;code&gt;MutexGuard&lt;/code&gt; 가이는 목록 16-12의 내부 범위 끝에서 발생합니다. 결과적으로 잠금 해제가 자동으로 이루어지기 때문에 잠금 해제를 잊어 버리고 뮤텍스가 다른 스레드에서 사용되는 것을 차단할 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;cargo new&lt;/code&gt; 는 &quot;Hello, world!&quot;를 생성합니다. 당신을 위해 프로그램. &lt;em&gt;src / main.rs&lt;/em&gt; 파일을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;main&lt;/code&gt; 기능은 프로그램의 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">6 장에서 보았 듯이 패턴을 리터럴과 직접 일치시킬 수 있습니다. 다음 코드는 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Listing 17-15에서 보듯이 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 구문을 사용하는 메소드를 작성할 수있다 . 이를 통해 메소드 는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 저장된 &lt;code&gt;Self&lt;/code&gt; 값의 소유권을 가질 수있다 . 이것이 바로 우리가 여기서하고 싶은 일이지만 불행히도 Rust는 우리를 허락하지 않을 것입니다. 클로저가 호출 될 때 동작을 구현하는 Rust의 일부는 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 사용하여 구현되지 않습니다 . 따라서 Rust는 이 상황에서 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 를 사용하여 클로저의 소유권을 가져와 클로저를 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 밖으로 옮길 수 있다는 것을 아직 이해하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">2 장의 &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀번호에 맞춰 추측하기&quot;&lt;/a&gt; 섹션 의 추측 게임 튜토리얼에서 보았 듯이 이전 변수와 동일한 이름을 가진 새 변수를 선언하고 새 변수는 이전 변수를 가리게 할 수 있습니다. Rustaceans는 첫 번째 변수가 두 번째 변수에 의해 &lt;em&gt;음영 처리&lt;/em&gt; 된다고 말하는데 , 이는 두 번째 변수의 값이 변수가 사용될 때 나타나는 값임을 의미합니다. 동일한 변수 이름을 사용 하고 다음과 같이 &lt;code&gt;let&lt;/code&gt; 키워드 사용을 반복하여 변수를 음영 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">큰 프로그램을 작성할 때는 전체 프로그램을 추적하는 것이 불가능하기 때문에 코드를 구성하는 것이 중요합니다. 관련 기능을 그룹화하고 고유 한 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾는 위치와 기능 작동 방식을 변경할 위치를 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">프로젝트가 성장함에 따라 작업 영역 사용을 고려하십시오. 하나의 큰 코드 덩어리보다 작은 개별 구성 요소를 이해하는 것이 더 쉽습니다. 또한, 상자를 작업 공간에 보관하면 종종 종종 변경되는 경우 더 쉽게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">닫는 중괄호를 제외하고 지금까지 추가 된 코드에서 논의 할 줄이 하나 더 있습니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">닫는 중괄호 외에도 지금까지 추가 된 코드에서 논의 할 줄이 하나 더 있습니다. 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">문자열의 길이를 물으면 12라고 말할 수 있습니다. 그러나 Rust의 대답은 24입니다. 이는 문자열의 각 유니 코드 스칼라 값이 2 바이트의 저장 공간을 차지하기 때문에 UTF-8로 &quot;Здравствуйте&quot;를 인코딩하는 데 필요한 바이트 수입니다. 따라서 문자열 바이트에 대한 인덱스가 항상 유효한 유니 코드 스칼라 값과 상관되지는 않습니다. 시연하려면이 잘못된 녹 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">결과가 당신이 기대하는 것이라고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">어설 션은 항상 디버그 및 릴리스 빌드 모두에서 확인되며 비활성화 할 수 없습니다. &lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt; 참조하십시오 !릴리스 빌드에서 기본적으로 사용되지 않는 어설 션의 경우</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">부울 표현식이 &lt;code&gt;true&lt;/code&gt; 임을 주장 합니다. 런타임에 .</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 서로 동일하다고 주장합니다 ( PartialEq 사용) . 합니다.</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">두 표현식이 서로 같다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">두 표현식이 서로 같지 &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ( PartialEq 사용 ).</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">두 표현식이 서로 같지 않다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">대입 식</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">할당 &lt;code&gt;A + B&lt;/code&gt; 에 &lt;code&gt;A&lt;/code&gt; 그것을 인쇄 할 때까지 합계가 결코 업데이트되지 점점 글로벌 변수, 임시 위치에 저장 될 수 있기 때문에, 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">일치는 부작용을 가질 수 없으므로 패턴 가드에는 지정이 허용되지 않습니다. 부작용으로 인해 일치하는 개체 또는 일치하는 환경이 변경되어 일치하는 항목이 완전하지 않을 수 있습니다. 예를 들어, 할당이 허용 된 경우 다음은 팔과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">고정 된 참조 뒤의 메모리에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">관련 상수</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">관련 상수 예</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">관련 기능</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">연관된 유형 컨테이너 예제</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">관련 상수, 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">관련 기능 및 방법</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">연관된 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자에 사용됩니다. 예를 들어, 하나의 차원 매개 변수를 가진 관련 함수를 제공하고이를 너비와 높이 로 사용하여 동일한 값을 두 번 지정하지 않고 사각형 &lt;code&gt;Rectangle&lt;/code&gt; 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">첫 번째 매개 변수 이름이 &lt;code&gt;self&lt;/code&gt; 인 연관된 함수를 &lt;em&gt;메소드&lt;/em&gt; 라고하며 , &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;메소드 호출 연산자 &lt;/a&gt; &lt;code&gt;x.foo()&lt;/code&gt; 예 : x.foo () 및 일반 함수 호출 표기법 ) 를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">직접 이름을 지정할 수없는 유형의 관련 항목 (예 : &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; , &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">관련 항목은 관련 항목이 논리적으로 관련 항목과 관련이있을 때 유용합니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;is_some&lt;/code&gt; 메소드 는 본질적으로 옵션과 관련되어 있으므로 연관되어야합니다.</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">이 패턴과 관련된 검색 자</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 관련 유형 .</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 연관된 유형 .</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; 의 관련 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">연관된 유형은 제네릭과 유사한 개념으로 보일 수 있는데, 후자는 처리 할 수있는 유형을 지정하지 않고 함수를 정의 할 수 있다는 점에서 다릅니다. 왜 관련 유형을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">동일한 디렉토리에 다음 내용을 가진 두 개의 파일이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7203654194ae4db3f1b4a3c121163c9fc8267f3" translate="yes" xml:space="preserve">
          <source>Assumes that the &lt;code&gt;VecDeque&lt;/code&gt; is sorted by the key, for instance with &lt;a href=&quot;#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">예를 들어 동일한 키 추출 함수를 사용하는 &lt;a href=&quot;#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;VecDeque&lt;/code&gt; 가 키별로 정렬 되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">슬라이스가 키를 기준으로 정렬되어 있다고 가정합니다 (예 : 동일한 키 추출 기능을 사용하는 &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="translated">모든 요소가 초기화되었다고 가정하면 변경 가능한 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="translated">모든 요소가 초기화되었다고 가정하고 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">내용이 &lt;code&gt;abcdef\n&lt;/code&gt; 인 &lt;code&gt;foo.txt&lt;/code&gt; 라는 파일이 있다고 가정하고 두 개의 핸들을 작성하고 그 중 하나를 찾고 다른 핸들에서 나머지 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">별표 글로브 가져 오기는 &lt;code&gt;_&lt;/code&gt; 로 가져온 항목을 가져옵니다. 는 이름이없는 형태 로 .</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="translated">비동기 블록은 클로저처럼 함수 경계처럼 작동합니다. 따라서 &lt;code&gt;?&lt;/code&gt; 연산자 및 &lt;code&gt;return&lt;/code&gt; 식은 둘 다 둘러싸는 함수 나 다른 컨텍스트가 아닌 미래의 출력에 영향을줍니다. 즉, 클로저 내에서 &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; 을 반환 하면 미래의 출력으로 &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 의 결과가 반환됩니다 . 마찬가지로 &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; 오류를 전파하면 해당 오류는 미래의 결과로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="translated">비동기 블록 은 클로저 와 동일한 &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;캡처 모드&lt;/a&gt; 를 사용하여 환경에서 변수를 캡처합니다 . 클로저와 마찬가지로 &lt;code&gt;async { .. }&lt;/code&gt; 작성시 각 변수의 캡처 모드는 블록의 내용에서 유추됩니다. 그러나 &lt;code&gt;async move { .. }&lt;/code&gt; 블록은 참조 된 모든 변수를 결과 미래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="translated">비동기 컨텍스트</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">비동기 기능</target>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="translated">비동기 함수는 호출시 작동하지 않습니다. 대신 미래에 대한 인수를 캡처합니다. 폴링되면 해당 퓨처는 함수의 본문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">비동기 값.</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="translated">높은 수준에서 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 포인터 유형 &lt;code&gt;P&lt;/code&gt; 의 pointee가 메모리에서 안정적인 위치를 갖도록합니다. 즉, 다른 위치로 이동할 수없고 메모리가 삭제 될 때까지 할당 해제 될 수 없음을 의미합니다. pointee가 &quot;고정&quot;되었다고 말합니다. 고정 된 데이터와 고정되지 않은 데이터를 결합하는 유형을 논의 할 때 상황이 더 미묘 해집니다. 자세한 내용 &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">항상 데이터 경쟁을 피해야합니다. 여러 스레드가 동일한 &lt;code&gt;UnsafeCell&lt;/code&gt; 에 액세스 할 수있는 경우 다른 모든 액세스 (또는 원자 사용)와 관련하여 쓰기 작업이 올바르게 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중 하나&lt;/em&gt; (모두는 아니지만) 하나 변경 가능한 참조 또는 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중&lt;/em&gt; 하나 변경 가능한 참조 &lt;em&gt;또는&lt;/em&gt; 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">컴파일 타임에 &lt;code&gt;Trait&lt;/code&gt; 의 각 구현은 구현 과 관련된 다양한 메소드 (및 기타 항목)를 포함하는 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">컴파일 타임에 Rust는 타입이 차지하는 공간을 알아야합니다. 컴파일 타임에 크기를 알 수없는 유형 중 하나는 &lt;em&gt;재귀 유형입니다&lt;/em&gt; 이며 값은 자체 유형의 일부로 동일한 유형의 다른 값을 가질 수 있습니다. 이 값 중첩은 이론적으로 무한대로 계속 될 수 있기 때문에 Rust는 재귀 유형의 값에 필요한 공간의 양을 모릅니다. 그러나 상자의 크기는 알려진 것이므로 재귀 유형 정의에 상자를 삽입하면 재귀 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">참조 카운트가 변경되는 프로그램의 각 지점에서 &lt;code&gt;Rc::strong_count&lt;/code&gt; 함수를 호출하여 얻을 수있는 참조 카운트를 인쇄합니다 . 이 함수라는 &lt;code&gt;strong_count&lt;/code&gt; 아닌 &lt;code&gt;count&lt;/code&gt; 때문에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 또한 A 형 갖는다 &lt;code&gt;weak_count&lt;/code&gt; 을 ; &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&quot;참조 사이클 방지 : &lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &quot; 섹션 에서 &lt;code&gt;weak_count&lt;/code&gt; 가 사용되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">처음에는 메모리가 전혀 할당되어 있지 않지만 문자열에 추가하면 용량이 적절하게 증가합니다. &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메소드를 대신 사용하여 처음에 올바른 용량을 할당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">처음에는 메모리가 전혀 할당되지 않았지만 문자열에 추가하면 용량이 적절하게 증가합니다. 대신 &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 처음에 올바른 용량을 할당하면 :</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">가장 간단하게 Rust의 &lt;code&gt;test&lt;/code&gt; 는 테스트 속성으로 주석이 달린 함수입니다 . 속성은 Rust 코드에 대한 메타 데이터입니다. 한 가지 예는 5 장의 구조체와 함께 사용 하는 &lt;code&gt;derive&lt;/code&gt; 속성입니다. 함수를 테스트 함수로 변경하려면 &lt;code&gt;fn&lt;/code&gt; 앞에 줄에 &lt;code&gt;#[test]&lt;/code&gt; 를 추가하십시오 . &lt;code&gt;cargo test&lt;/code&gt; 명령으로 테스트를 실행할 때 Rust는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수를 실행하고 각 테스트 함수의 통과 여부를보고 하는 테스트 러너 바이너리를 빌드 합니다.</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 또는 특성의 일반 유형 매개 변수 중 하나 이상 이 다음 문법을 충족해야합니다. 여기서 &lt;code&gt;C&lt;/code&gt; 는 포함하는 상자 내에 정의 된 공칭 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">포인터 중 하나 이상이 데이터 쓰기에 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">&lt;code&gt;T0..=Tn&lt;/code&gt; 유형 중 하나 이상 은 &lt;a href=&quot;../glossary#local-type&quot;&gt;로컬 유형&lt;/a&gt; 이어야합니다 . 하자 &lt;code&gt;Ti&lt;/code&gt; 최초의 유형합니다.</target>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">&lt;code&gt;T0..=Tn&lt;/code&gt; 유형 중 하나 이상 은 로컬 유형이어야합니다. 하자 &lt;code&gt;Ti&lt;/code&gt; 최초의 유형합니다.</target>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="translated">현재 Rust, C, 시스템 등과 같은 사전 정의 된 ABI는 거의 없습니다. ABI가 미리 정의되어 있는지 확인합니다. 예를 들어 'Rust'에서 주어진 ABI를 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">현재, 대출이 여전히 범위 내에있는 동안 발생하는 수익률을 갖는 것은 허용되지 않습니다. 이 오류를 해결하려면 대출금이 수익률과 겹치지 않는 더 작은 범위로 &quot;포함&quot;되거나 다른 방법으로 제거되어야합니다. 예를 들어, 차용을 제거하고 정수를 값으로 저장하여 이전 예를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="translated">현재 생성기에 대해 하나 이상의 명시 적 매개 변수를 전달하는 것은 허용되지 않으며 이는 생성기에 대해 최대 1 개의 매개 변수를 사용하여 수정할 수 있습니다. 예를 들어, 하나의 매개 변수 만 전달하여 이전 예제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="translated">런타임에 &lt;code&gt;dyn Trait&lt;/code&gt; 에서 메서드를 호출해야 할 때 vtable을 참조하여 함수 포인터를 얻은 다음 해당 함수 포인터가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="translated">런타임에이 함수는 &lt;code&gt;self != other&lt;/code&gt; 처럼 동작 합니다. 그러나 일부 컨텍스트 (예 : 컴파일 타임 평가)에서는 두 포인터의 부등식을 항상 결정할 수있는 것은 아니므로이 함수는 나중에 실제로 부등하다고 &lt;code&gt;false&lt;/code&gt; 된 포인터에 대해 거짓 을 반환 할 수 있습니다. 그러나 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 포인터가 같지 않음이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="translated">런타임에이 함수는 &lt;code&gt;self == other&lt;/code&gt; 처럼 동작 합니다. 그러나 일부 컨텍스트 (예 : 컴파일 타임 평가)에서는 두 포인터의 동등성을 항상 결정할 수있는 것은 아니므로이 함수는 나중에 실제로 동일한 것으로 &lt;code&gt;false&lt;/code&gt; 되는 포인터에 대해 거짓 을 반환 할 수 있습니다. 그러나 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 포인터가 동일하다는 것이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">이 장의 시작 부분에서 벡터는 동일한 유형의 값만 저장할 수 있다고 말했습니다. 불편할 수 있습니다. 다른 유형의 항목 목록을 저장 해야하는 유스 케이스가 있습니다. 다행히 열거 형의 변형은 동일한 열거 형으로 정의되므로 벡터에 다른 유형의 요소를 저장해야 할 때 열거 형을 정의하고 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">시점의 &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;else&lt;/code&gt; 블록 반복을 많이 가지고 : 그들은 두 파일을 읽고 스트림에 파일의 내용을 작성하고 있습니다. 유일한 차이점은 상태 줄과 파일 이름입니다. 상태 라인의 값과 파일 이름을 변수에 할당하는 별도의 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 라인 으로 이러한 차이를 끌어내어 코드를 더 간결하게 만들어 봅시다 . 그런 다음 코드에서 변수를 무조건 사용하여 파일을 읽고 응답을 작성할 수 있습니다. Listing 20-9는 큰 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록을 교체 한 후의 결과 코드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b1fe5f0e39ec55eb0cd362275db96ad9cd1656e2" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;.await&lt;/code&gt;, and the &lt;code&gt;Try&lt;/code&gt; operator (&lt;code&gt;?&lt;/code&gt;) are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;for&lt;/code&gt; 루프, &lt;code&gt;.await&lt;/code&gt; 및 &lt;code&gt;Try&lt;/code&gt; 연산자 ( &lt;code&gt;?&lt;/code&gt; )는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;const fn&lt;/code&gt; 내에서 금지되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;loop&lt;/code&gt; 의 루핑 구문 은 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;const fn&lt;/code&gt; 내에서 금지되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">현재 &lt;code&gt;println!&lt;/code&gt; 사용하여 모든 출력을 터미널에 쓰고 있습니다 ! 함수. 대부분의 터미널은 일반 정보의 경우 &lt;em&gt;표준 출력&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; )과 오류 메시지의 경우 &lt;em&gt;표준 오류&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; )의 두 가지 출력을 제공 합니다. 이 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 보내지 만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">현재 우리는 &lt;code&gt;println!&lt;/code&gt; 사용하여 모든 출력을 터미널에 쓰고 있습니다 ! 매크로. 대부분의 터미널은 일반 정보를위한 &lt;em&gt;표준 출력&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; )과 오류 메시지를위한 &lt;em&gt;표준 오류&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; )의 두 가지 종류의 출력을 제공 합니다. 이 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 지정하지만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">이 글을 쓰는 시점에서 &lt;code&gt;rustfmt&lt;/code&gt; 라는 자동 포맷터 도구 가 개발 중입니다. Rust 프로젝트에서 표준 스타일을 고수하려면 &lt;code&gt;rustfmt&lt;/code&gt; 가 특정 스타일로 코드를 포맷합니다. Rust 팀은 결국이 도구를 &lt;code&gt;rustc&lt;/code&gt; 와 같은 표준 Rust 배포판에 포함시킬 계획 입니다. 따라서이 책을 읽는 시점에 따라 컴퓨터에 이미 설치되어있을 수 있습니다! 자세한 내용은 온라인 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">이 글을 쓰는 시점에서 Rust 2015와 Rust 2018의 두 가지 Rust 에디션을 사용할 수 있습니다.이 책은 Rust 2018 에디션 관용구를 사용하여 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">당시 우리는 비효율적 인 &lt;code&gt;clone&lt;/code&gt; 호출 에 대해서는 걱정하지 않겠다고 말했습니다 . 글쎄, 그 시간은 지금이다!</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">당시에는이 코드에서 몇 가지 세부 사항을 건너 뛰었습니다. 6 장 &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&quot; &lt;code&gt;match&lt;/code&gt; 제어 흐름 연산자&quot;&lt;/a&gt; 섹션에서 &lt;code&gt;match&lt;/code&gt; 암이 모두 동일한 유형을 반환해야 한다고 논의했습니다 . 예를 들어 다음 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 모두에서 &lt;code&gt;cargo build&lt;/code&gt; 가 성공적으로 완료되어야합니다 . 절차 적 매크로가 실제로 작동하는지 확인하려면이 상자를 Listing 19-30의 코드에 연결해 보자! &lt;code&gt;cargo new pancakes&lt;/code&gt; 를 사용 하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 에 새 바이너리 프로젝트를 작성하십시오 . &lt;code&gt;pancakes&lt;/code&gt; 상자의 &lt;em&gt;Cargo.toml에&lt;/em&gt; 종속 &lt;code&gt;hello_macro_derive&lt;/code&gt; 으로 &lt;code&gt;hello_macro&lt;/code&gt; 및 hello_macro_derive 를 추가해야합니다 . 다음과 같이 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 버전 을 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io &lt;/a&gt; &lt;code&gt;path&lt;/code&gt; 종속성에 게시하는 경우 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; , 그들은 정기적으로 종속 될 것이다; 그렇지 않은 경우 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">이 시점에서 &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;tic-tac-toe&lt;/code&gt; 가 됩니다. 모든 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 문자를 사용하면 현재 상황을 파악하기가 어렵습니다.보다 복잡한 문자열 결합을 위해서는 &lt;code&gt;format!&lt;/code&gt; 사용할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">이제 게임의 첫 부분이 완료되었습니다. 키보드에서 입력을받은 다음 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">이 시점에서 범위와 변수가 유효한시기의 관계는 다른 프로그래밍 언어의 관계와 유사합니다. 이제 우리는 &lt;code&gt;String&lt;/code&gt; 타입 을 소개함으로써 이러한 이해를 바탕으로 구축 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">이제 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하여 작업 공간을 빌드 할 수 있습니다 . &lt;em&gt;add&lt;/em&gt; 디렉토리 의 파일 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">이 시점에서 동일한 기능을 유지하기 위해 테스트를 통과하면서 검색 기능의 구현을 리팩토링 할 기회를 고려할 수 있습니다. 검색 기능의 코드는 그리 나쁘지는 않지만 반복자의 유용한 기능을 활용하지 않습니다. 이 예제로 돌아가서 &lt;a href=&quot;ch13-02-iterators&quot;&gt;13 장&lt;/a&gt; 에서 반복자를 자세히 살펴보고 개선 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">이 시점에서 우리는 동일한 기능을 유지하기 위해 테스트를 통과하면서 검색 기능의 구현을 리팩토링 할 수있는 기회를 고려할 수있었습니다. 검색 기능의 코드는 나쁘지 않지만 반복자의 유용한 기능을 활용하지는 않습니다. 이 예제로 돌아가서 [Chapter 13] [ch13]에서 반복자를 자세히 살펴보고 개선 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;content&lt;/code&gt; 를 호출 할 때 , deref 강제가 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 에 영향을 미치 므로 궁극적으로 &lt;code&gt;State&lt;/code&gt; 특성 을 구현하는 유형 에서 &lt;code&gt;content&lt;/code&gt; 메소드가 호출됩니다 . 즉 , &lt;code&gt;State&lt;/code&gt; 특성 정의 에 &lt;code&gt;content&lt;/code&gt; 를 추가해야하며 , 여기서는 상태 17-18에 표시된대로 상태에 따라 리턴 할 컨텐츠에 대한 논리를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;upgrade&lt;/code&gt; 메소드 를 사용하여 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 대한 참조를 얻으려고하면 &lt;code&gt;None&lt;/code&gt; 값을 얻습니다 . 우리는 이것을 첫 번째 &lt;code&gt;println!&lt;/code&gt; 의 출력에서 ​​볼 수 있습니다 ! 성명서:</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 현재 사용중인 &lt;code&gt;rand&lt;/code&gt; 크레이트 의 버전이 &lt;em&gt;0.3.15임을 나타내는 Cargo.lock&lt;/em&gt; 파일 이 변경 &lt;code&gt;0.3.15&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 에서 현재 사용중인 &lt;code&gt;rand&lt;/code&gt; 상자 의 버전 이 &lt;code&gt;0.5.6&lt;/code&gt; 이라는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">이 시점에서 패턴을 사용하는 몇 가지 방법을 보았지만 패턴을 사용할 수있는 모든 곳에서 패턴이 동일하게 작동하지는 않습니다. 어떤 곳에서는 패턴을 반박 할 수 없어야합니다. 다른 상황에서는 반박 할 수 있습니다. 다음에이 두 가지 개념에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">이제 추측 게임을 성공적으로 구축했습니다. 축하합니다!</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 사용한 원자 기준 카운팅</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">원자 메모리 주문</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">원자 연산은 더 큰 크기의 원자를 갖는 명령 계층에서 구현 될 수있다. 예를 들어, 일부 플랫폼은 4 바이트 원자 명령어를 사용하여 &lt;code&gt;AtomicI8&lt;/code&gt; 을 구현 합니다 . 이 에뮬레이션은 코드의 정확성에 영향을 미치지 않아야한다는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 시맨틱을 사용한 원자 작업 은 펜스와 동기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">원자 유형은 정적 변수에 저장 될 수 있으며 &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt; 와 같은 상수 이니셜 라이저를 사용하여 초기화 됩니다. 원자 정적은 종종 게으른 전역 초기화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">원자 유형은 스레드간에 기본 공유 메모리 통신을 제공하며 다른 동시 유형의 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">원자 변수는 스레드간에 공유하기에 안전 하지만 ( &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 ) 자체적으로 공유 메커니즘을 제공하고 Rust 의 &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;스레딩 모델&lt;/a&gt; 을 따르지는 않습니다 . 원자 변수를 공유하는 가장 일반적인 방법은 원자 변수를 &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (원자 적으로 참조 계산 된 공유 포인터) 에 넣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">원자 변수는 스레드간에 공유하기에 안전 하지만 ( &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 ) 스레드 자체 의 녹 &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;모델&lt;/a&gt; 을 공유하고 따르는 메커니즘을 제공하지는 않습니다 . 원자 변수를 공유하는 가장 일반적인 방법은에 넣어하는 &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (극히 미세 - 참조 카운트 공유 포인터).</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">핸들의 토큰을 아직 사용할 수없는 경우 원자 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">상자를 콘크리트 유형으로 다운 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dc2a85c8ec42aea412c46625d0258c82f5009a" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 깨우기를 위해 현재 작업을 등록하여 미래를 최종 값으로 확인합니다. &lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">아이템을 가져 오려고 시도했지만이 이름의 외계 상자가 이미 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">가져올 수없는 값을 가져 오려고했습니다. 이것은 특성에서 메소드를 가져 오려고 할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">기본 유형의 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">필드와 같은 메소드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">구조체에서 존재하지 않는 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">구조체의 개인 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">함수 나 메소드가 아닌 것을 호출하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="translated">알 수없는 종류의 포인터로 /에서 캐스트를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">역 참조 할 수없는 변수를 역 참조하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">변수 유형이 잘못된 변수에 변수를 전달하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">컴파일을 시도하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 유형의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">형식이 잘못된 소켓 주소 &lt;code&gt;&amp;amp;str&lt;/code&gt; (포트 누락) 에서 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 반복자 를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="translated">&lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 으로 &amp;amp; packed.unaligned 와 같은 표현식 을 사용하여 &lt;code&gt;unaligned&lt;/code&gt; 구조체 필드에 대한 원시 포인터를 만들려고 시도하면 정렬되지 않은 중간 참조가 생성되어 원시 포인터로 변환됩니다. 컴파일러가 항상 참조가 적절하게 정렬 될 것으로 예상하기 때문에이 참조가 임시적이며 즉시 캐스트되는 것은 중요하지 않습니다. 결과적으로 &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 하면 프로그램에서 즉시 &lt;em&gt;정의되지 않은 동작이&lt;/em&gt; 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">객체 안전이 아닌 형질에 대한 형질 개체를 만들려고하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">이 잠금을 얻으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">공유 읽기 액세스 권한으로이 rwlock을 확보하려고합니다.</target>
        </trans-unit>
        <trans-unit id="60ca78e1d1551297af7765e326760c4a38aa394c" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory.</source>
          <target state="translated">메모리 블록 할당을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="943f34bb668f31f44c32b4ace4e03989407198f9" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c43d8666b34161b53b0b2ccf4916af8bde88930" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">이미 종료 된 하위의 종료 상태를 수집하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c1be452e1098fe5e2ba823c663805fe4f191d856" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="e0f700a71652c58da7326026511c609bb65c78a5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="a1b8bfe658e12622625c1e875a019db8830b0989" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="66a76479bea9155fc85828e929db52c84fd63e6c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="b97a798e91eb0541c3e3c246eb5e2ac5797cb455" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ed691c14807b35b2f2548e2bc752f978c9b573b3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="468a506dd2d83e7c4d19f2315c61b797dc6e4d81" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="501645681c486dcfde763f239c9dbc39c9a89e74" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="e87e26b0a7cd242115748e46f0ec96044936078e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8a0d914b6e10991069d8605388d14c2b1ca592cd" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="958ed88b5c4639ba37034945d4fa7653d11ec14d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; 을 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="be612cdd6f48c673bcc19746b3317e990d42bddc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="3c356c6158c8679c2d029abe3620f468bf5b9b89" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="42ea0a6247bb234c0382208391062366c8d45afa" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="de4b3bab90d338dc97a29e174b6ac89affad0eee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="3306b6d8338537145c4e522fa6d3095a838e24ed" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1b8c226a4f3a2e9faf3bd2edc42cfa8c056aa1dc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2350a1a3377e42242cdfb3bcc58bf4230d39faee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; 을 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="616abf596e103379ba7981d5f1e76f05a2ea5666" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f894e5fc7159364d10324e42a2aabd76a1311686" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="e0ae0dea78c18426532483b357c55d9190d0c56e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1ef3839c406eb138bd48f980d20053dec4a89576" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="18c41b12b6a5c51bf92010b091987428554830e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5448bf065e3955c9eea9670b86f542b60f1a0d99" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="0c5994e4c20d71914f91892cc5ecb435c7068406" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c142214aae8a432d7a06e49f1095d64d5abcf8e1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="6debd548d7dfbbbf4dd441963174cff21d7cdf02" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="e5bd3db3824015309ca5994329cb635606bb61e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c9e3ad073d959cecc0ef2f46909df5654f941abe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="27970ce49dac2a260596044481b8209701cc6df9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5cc731c548e3edd60d482acb352eb954334d827f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf1693e06446e1b570049dea824ca2f5de4f983" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="fbf21f7180107143b1c2df0ada7adb608ce576f5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="933cccb563bf70c8384b3537cf5d53af66522f2f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1923808fa8774e72e6b98f0d83b066dadba4e2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="354ab0355cf5bb942ae945004201e3e00a7b805c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="e1efb3585f71154fa405501c22aeb01a824f8ab1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c157007b3ce40ab86f83ee061270c2516fbee74c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8a3363ae51b3ea763ca696b60555078ab17bcbb4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="74c1a1e7cdabd9277cf3f6090aec0cbb69fbae9d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="a1fa909a8d07ec9bebd2c3a4ba3244aa21e756ab" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="4fc706f3890ff34068fa3987549fc9e943e12ee7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="9406edc100eab7a11042f495f5605472cde3da93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; 을 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="9302879ee5829e1588c324186708b8a56fd80bf6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="b776a75cae811bf723255d190f55f89b79a29f17" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="332b91f901664ebad9ee86d115e69f5a7a3b4d2e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f1ac4806f54fa95041af1e83978837424908c0" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="9382ddfacff70da4aaa8665a550fdda9aeffbdbe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="30cfff31cec5836c2d435b155797b06f97a88b5a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="79e1a0344dcbdab94d2a5a137db0b6fe3077cc05" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="4b5d4e575e612dc8137f25de68e1c8c2bca6bb80" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="0813f21e382c2efbc0af883a820eed2568b9960b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="93fb19758341f597fd85cf5eff51cea75139832f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8ec588e739f156798bddcb79b1a4f397464f2ee1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cb3c9348ff015679d375f740e5de8691a989ad" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroI128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="78453501b58efe0df37ba60dce757e854979bf0b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1754f440af8e327e3628892e889e890ca0fdfa7a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="04f7b535be0370cddd62901980eb0ddf9e3fbcef" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="e99899bbe257c97c7294c60c8cbb6dcdaba0937c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="50ffacd53f0d563c90eca54db4e3068e8ac7bc58" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c32f0af0599976a74621043264a001a3e32ccab3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="99847ce375f1c7bf52ad9dbf9cbe8ebc71c7e0d1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5abc78a9982271a77eb82cbdd6f2e2a5c397b7e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2c394131db124e9071401792a8209e92dd32cde6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f0859484eecde175859b2793704416213e22b608" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; 을 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="72fdb2a4fa84fd42a73a35812e8216884b62fceb" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; 을 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="06fdd2383cf95915cfbafeedd94c6cf3ece1cda1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="4b8ba1870526b34b3010dfda32d9e6ef25b46c3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; 을 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="609415cf60341744050aa964021a2dbc6757bce9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1e3cfcd25580562f26787f2a4ece451df14e3410" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="22e09395ec650cc77cefa22bbdfa6829f42f4235" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8d6c92d747eecea95deef0df11e2de577f89b584" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="bd6a16a046a47e51b8dbbc17c05fb83363da4079" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="681e0c5dd009397d090a42219e25007f044800b1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="fbde01dde5e3f3012cf4334646a7f5ef28b672b2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="ac4a8de77e7ee61e1fc27cc89dab1a66ef82bc93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="09ce329fa4a9ee415c158ac8a1274f6e57fb2e20" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1abe67a3e4364a619efb676e5daa3d020ddb2d3f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d9bf65adb8592efb46990546bc8cbe35b0283a56" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5b6551a1616534f8c2d695ae7db8375e577d6398" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="08c2cbaf513eb994bd548c282a61f57637c77f67" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="6d6851d41e88cb2aaa40c97ac167640ba1262eb3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="35ddc3e3dfd9a428705e36e86a5e0594a1b9eff7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="60905ee844e93f0259575760c3d1354fd6ee0145" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="34b553e368c520708ccfbe33c562a7aac19b19ea" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2bbbce1f0f87a53359eb132f6a57b8badd4665c5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU8&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="adc18f3bf4b5cd397ebe0fa08f9b0234fe5f4691" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="3a8feff95241828b618a9f8f2cedee35cf34dbc2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="39ef28f0274fbbc17ccd2ed7051a33a172b5845b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="6bee2c6e9925f66c4b7aa5fa6a1b124e2eb59e5e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1f97a59c56e1d9e1b3d6440f468bdeaa5169d29a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="915108f700cb0a82a36eec28483bf51e615c31a7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f9d60598f796fd4c7d2797827f8cc377d4829f91" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="5a888711092f4db9142baf49d1d094a1588d95bc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="96596905fbde7e740d6654a8d248b25e64e80725" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="a42cd22a3bffa9bab2837c2ad66ee139ebc73564" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="94d1fb95e25a0fa6c34caf0d382246658d283ed6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; 를 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i128&lt;/code&gt; 을 &lt;code&gt;NonZeroI128&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i16&lt;/code&gt; 을 &lt;code&gt;NonZeroI16&lt;/code&gt; 으로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i64&lt;/code&gt; 를 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i8&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u128&lt;/code&gt; 을 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u16&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u64&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u8&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; 을 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 으로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="translated">상자를 구체적인 유형으로 다운 캐스트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="610fb844291f2a525fe83689f6eb20dc7f8fe95f" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block.</source>
          <target state="translated">메모리 블록 확장을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6aa5063683af7571841f72f0953d587299850850" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54633b194aa39ce8f38436cb1feb8f160a116984" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;trait.allocator#method.grow&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">독점적 인 쓰기 액세스 권한으로이 rwlock을 잠그려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">파일을 읽기 전용 모드로 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">차단하지 않고이 수신자에서 보류중인 값을 리턴하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">차단하지 않고이 채널에서 값을 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">이 채널에서 값을 보내려고 시도하여 보낼 수없는 경우 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08f5853268ae278f691eb7a82a1231c55496e49d" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block.</source>
          <target state="translated">메모리 블록 축소를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c648c706ee8142ae651a14916b0ab8f1c626c9d5" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b1e6da2468f6f1396385de5f3580dfdb6c5c166" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">모든 OS 내부 메타 데이터를 디스크에 동기화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하려고 시도하여 성공하면 내부 값 삭제를 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하려고 시도하여 성공하면 내부 값 삭제를 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어 지거나 &lt;code&gt;deadline&lt;/code&gt; 에 도달 하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 중단되었거나 &lt;code&gt;timeout&lt;/code&gt; 이상 대기하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어지면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">속성에 동일한 메타 항목이 두 번 이상 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">속성 매크로</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">속성 매크로는 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 의 서명이있는 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 사용하여 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공용 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;함수에&lt;/a&gt; 의해 정의됩니다 . 첫 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 속성 이름 다음에 나오는 구분 된 토큰 트리이며 외부 구분 기호를 포함하지 않습니다. 속성이 베어 속성 이름으로 작성되면 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 속성 이 비어 있습니다. 두 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목의&lt;/a&gt; 다른 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 포함 하는 나머지 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 입니다. 반환 된 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 을 임의의 수로 대체합니다.&lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">속성 매크로는 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 의 서명이있는 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 가진 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공용 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;함수에&lt;/a&gt; 의해 정의됩니다 . 첫 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 외부 구분자를 포함하지 않고 속성 이름 뒤에 구분 된 토큰 트리입니다. 속성이 기본 속성 이름으로 작성된 경우 속성 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 이 비어 있습니다. 두 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목의&lt;/a&gt; 다른 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 포함한 나머지 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 입니다. 반환 된 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 을 임의의 숫자로 바꿉니다.&lt;a href=&quot;items&quot;&gt;품목&lt;/a&gt; . 이러한 매크로는 새로운 &lt;code&gt;macro_rules&lt;/code&gt; 스타일 매크로 를 정의하는 구문으로 확장 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">속성과 유사한 매크로</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">속성 유사 매크로는 사용자 지정 파생 매크로와 유사하지만 &lt;code&gt;derive&lt;/code&gt; 속성에 대한 코드를 생성하는 대신 새 속성을 만들 수 있습니다. 그들은 또한 더 유연한 위치 : &lt;code&gt;derive&lt;/code&gt; 에만 구조체와 열거 작동; 함수와 같은 다른 항목에도 속성을 적용 할 수 있습니다. 다음은 속성과 유사한 매크로를 사용하는 예입니다 . 웹 애플리케이션 프레임 워크를 사용할 때 함수에 주석을 추가하는 &lt;code&gt;route&lt;/code&gt; 라는 속성이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">모든 항목에서 사용 가능한 사용자 정의 속성을 정의하는 속성과 유사한 매크로</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">속성은 다음과 같은 종류로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">언어의 많은 것들에 속성이 적용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">구현의 속성</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">모듈의 속성</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">진술의 속성</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">블록 표현식의 속성</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="translated">클로저 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">클로저 매개 변수의 속성은 &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">인턴 블록의 속성</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">extern 함수 매개 변수의 속성은 &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="translated">함수 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="translated">함수 포인터 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">함수 포인터 매개 변수의 속성은 &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">함수의 속성</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">시합 암의 속성</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="translated">메소드 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">메소드 매개 변수의 속성은 &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">증강 &lt;code&gt;AllocErr&lt;/code&gt; CapacityOverflow 변형과 함께.</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">오스틴 그룹 부질 라</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">자동 특성 구현</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">자동 구현 자</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">자동 특성</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">자동 특성은 표준 구현 문서에서 &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; 로 표시되는 자동 구현을 무시하는 부정적인 구현을 가질 수도 있습니다 . 예를 들어 &lt;code&gt;*mut T&lt;/code&gt; 의 음의 구현이 &lt;code&gt;Send&lt;/code&gt; 등 &lt;code&gt;*mut T&lt;/code&gt; 되지 않는다 &lt;code&gt;Send&lt;/code&gt; 경우에도, &lt;code&gt;T&lt;/code&gt; 가 있습니다. 현재 추가적인 부정적인 구현을 지정하는 안정적인 방법은 없습니다. 그것들은 표준 라이브러리에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">자동 특성에는 방법 또는 관련 항목이있을 수 없습니다. 자세한 정보는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;옵트 인 내장 특성 RFC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">일반적으로 하나의 특성 만 허용 되더라도 자동 특성은 모든 &lt;a href=&quot;types/trait-object&quot;&gt;특성 오브젝트에&lt;/a&gt; 대한 추가 바인딩으로 추가 될 수 있습니다 . 예를 들어 &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; 는 유효한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">보내기 및 동기화와 같은 자동 특성은이 규칙에서 예외입니다. 기본 제공되지 않은 특성 하나와 여러 가지 자동 특성을 사용할 수 있습니다. 예를 들어 다음은 올바르게 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">자동 &lt;code&gt;deref&lt;/code&gt; 바람직하지 않다; 예를 들어, 스마트 포인터 자체의 메소드와 포인터의 참조자를 구별</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt; 를 사용한 자동 서식</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="67ac2af5490a5a8399786f2d57a2cb9f4e9a1f32" translate="yes" xml:space="preserve">
          <source>Await expressions</source>
          <target state="translated">Await 식</target>
        </trans-unit>
        <trans-unit id="e627821b85e700b6a817bfb93d0fa75ca6938994" translate="yes" xml:space="preserve">
          <source>Await expressions are legal only within an &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt;, like an &lt;a href=&quot;../items/functions#async-functions&quot;&gt;&lt;code&gt;async fn&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;block-expr#async-blocks&quot;&gt;&lt;code&gt;async&lt;/code&gt; block&lt;/a&gt;. They operate on a &lt;a href=&quot;../../std/future/trait.future&quot;&gt;future&lt;/a&gt;. Their effect is to suspend the current computation until the given future is ready to produce a value.</source>
          <target state="translated">Await 식은 &lt;a href=&quot;../items/functions#async-functions&quot;&gt; &lt;code&gt;async fn&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;block-expr#async-blocks&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 블록 과 같은 &lt;a href=&quot;block-expr#async-context&quot;&gt;비동기 컨텍스트&lt;/a&gt; 내에서만 유효합니다 . 그들은 &lt;a href=&quot;../../std/future/trait.future&quot;&gt;미래에서&lt;/a&gt; 작동합니다 . 그 효과는 주어진 미래가 값을 생성 할 준비가 될 때까지 현재 계산을 중단하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">대박! 이제 약 40 줄의 Rust 코드로 된 간단한 웹 서버를 사용하여 한 페이지의 콘텐츠로 하나의 요청에 응답하고 404 응답으로 다른 모든 요청에 ​​응답합니다.</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">대박! 하나의 작은 마지막 조정으로, 우리는 추측 게임을 끝낼 것입니다. 프로그램이 여전히 비밀 번호를 인쇄하고 있음을 상기하십시오. 테스트에는 효과가 있었지만 게임을 망쳤습니다. &lt;code&gt;println!&lt;/code&gt; 삭제합시다 ! 비밀 번호를 출력합니다. 코드 2-6은 최종 코드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">B- 트리는 캐시 효율성과 검색에서 수행되는 작업량을 최소화하는 것의 근본적인 절충을 나타냅니다. 이론적으로 BST (Binary Search Tree)는 정렬 된 맵에 가장 적합한 선택입니다. BST는 완벽하게 균형 잡힌 BST가 요소를 찾는 데 필요한 이론적 최소량의 비교를 수행하기 때문입니다 (log &lt;sub&gt;2&lt;/sub&gt; n). 그러나 실제로 이것이 수행되는 방식은 최신 컴퓨터 아키텍처 에는 &lt;em&gt;매우&lt;/em&gt; 비효율적입니다. 특히 모든 요소는 자체적으로 힙이 할당 된 노드에 저장됩니다. 이것은 모든 단일 삽입이 힙 할당을 트리거하고 모든 단일 비교가 캐시 누락이어야 함을 의미합니다. 이것들은 실제로 실제로 비싼 일이기 때문에, 우리는 최소한 BST 전략을 재고해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="translated">BLOCK_COMMENT :</target>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEAN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
